[
    {
        "title": "Squares of a Sorted Array",
        "question_content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n\nExample 2:\n\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.\n\n&nbsp;\nFollow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?",
        "solutions": [
            {
                "id": 221922,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495394,
                "title": "c-simplest-one-pass-two-pointers",
                "content": "Based on [original post by yukuairoy](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/283978/Python-Two-Pointers).\\n\\nLet\\'s take example with negative and positive numbers, like:\\n```\\n[-4, -2, 0, 1, 3]\\n```\\nSince we need to put squeres in result array, we can consider that all numbers are positive (since: `-4**2 = 4**2 = 16`). Now our array looks like it sorted from middle to outside on both sides:\\n```\\n[4, 2, 0, 1, 3]\\n```\\nNow, we can have two pointers `l` to left most element, `r` to most right element.\\nCreate `res` result array same size as `A`.\\nMove from right to left in `res` and past `max(abs(A[l]), abs(A[r]))`, move correspondingly `l++` or `r--`.\\n\\n![image](https://assets.leetcode.com/users/andnik/image_1580828708.png)\\n\\nSame works for example with all negative and all positive numbers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[-4, -2, 0, 1, 3]\\n```\n```\\n[4, 2, 0, 1, 3]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        vector<int> res(A.size());\\n        int l = 0, r = A.size() - 1;\\n        for (int k = A.size() - 1; k >= 0; k--) {\\n            if (abs(A[r]) > abs(A[l])) res[k] = A[r] * A[r--];\\n            else res[k] = A[l] * A[l++];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310865,
                "title": "python-a-comparison-of-lots-of-approaches-sorting-two-pointers-deque-iterator-generator",
                "content": "This question is a cool one in that there is lots of different approaches, each with its own pros and cons. And then there\\'s also different ways of implementing them, depending on whether you are after raw performance or beautiful code.\\n\\nSomething slightly irritating is that leetcode isn\\'t testing with big enough test cases to push the time complexity of the O(n-log-n) approaches below the O(n) ones. It goes to show, sometimes what \"wins\" at the notoriously inaccurate Leetcode time/ space percentiles isn\\'t always the best in practice, or even in an interview.\\n\\n# Approach #1: Using built in sort.\\nThere are a few similar approaches we can take here, each with its own subtle differences. All are of an ```O(n-log-n)``` time complexity due to using the inbuilt sort, although they differ in their space complexity.\\n\\n## a) Overwriting input:\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\\n\\nThis approach uses ```O(1)``` memory beyond the input array, and is truely **in-place**. *However*, it is not always a good idea to overwrite inputs. Remember that because we passed it by reference, the original is actually lost. Often functions like this are a part of an API, and in a lot of cases, nobody wants an API that clobbers their input.\\n\\nI think it\\'s best to ask your interviewer if they want something done **in-place** or not. It is a common misconception that we should *always* be trying to do things in-place, overwriting the inputs.\\n\\n## b) Making a new array, not in place, O(n) auxillary space.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\\n\\nAhhhh, our good \\'ol clever Python one-liner. There is a suble space inefficiency in it though. For a brief moment, we\\'re using 3n memory, not 2n. The one line has 2 not-in-place operations in it; the list comprehension creates a new list, and so does sorted. The list comprehension list is promptly garbage collected upon function return, *but* because it was briefly there, the max memory usage was ultimately 3n. With lots of memory, this is totally fine, and the pythonic nature of it makes it a great solution. But we do need to be aware of it.\\n\\n## c) Making a new array, not in place, O(1) auxillary space.\\n\\nMaking a new array, in place.\\n\\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\\n\\nSo, is this ```O(1)``` space or ```O(n)``` space? Arguments can be made either way, sometimes people say to count the output data stucture in the calculation, and sometimes they don\\'t. If we\\'re talking about *auxillary* space, we generally don\\'t count the output data structure, which would make it ```O(1)```. I think this is a more accurate way of putting it -- we are trying to measure what the algorithm itself is using, not just what the inevitable size of the output is. But it\\'s important to be clear in interviews what you are and aren\\'t counting.\\n\\n## Overall thoughts on these approaches\\nYou won\\'t be coding any of these approaches in an interview (in my own very, very limited experience though!). By all means your interviewer will want to hear that you could do it this way, but there is 3 big problems if they are the only approaches you can come up with.\\n1) We shouldn\\'t need to use an O(n-log-n) sort operation on data that for the most part is already sorted. There\\'s something not right with that. If this is the approach the interviewer wanted, they wouldn\\'t have given you the numbers in a sorted list in the first place.\\n2) Following on from that, there are O(n) solutions.\\n3) Why would they be asking you to code something so trivial? Let\\'s be honest. They want to see you writing some meaty code. \\n\\nThe remaining approaches exploit the existing sorting. If we were to go down the list squaring each number, we\\'d have a \"v\" sorted list, in that the squares of the negatives decrease, and then the squares of the positives increase, i.e.\\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\\n\\nWe can get this into a sorted list in ```O(n)``` time.\\n# Approach 2: Raw pointers\\nIn terms of performance, you can\\'t beat this (well, if leetcode actually tested on massive test cases...). It\\'s O(n) time, and O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n# Approach 3: Using a deque \\nThis approach is the first of the trading-off-some-raw-performance-for-beauty=and-elegance approaches. It remains as ```O(n)``` *time complexity* like approach 2, but the heavy-weight nature of it will slow it down by a constant amount. If this doesn\\'t matter though (and in a lot of cases it doesn\\'t), then the elegance will reduce the risk of bugs and lead to more readable and maintable code. It is also important to note that it does use ```O(n)``` *auxillary space*.\\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\\n\\n# Approach 4: The iterator pattern\\nThis is one of my favourites. While it suffers from the same constant time slowdown as the previous approach, its auxillary space usage remains at ```O(1)```. The iterator pattern is a great way of splitting up code into more testable units. It seperates the problem of getting the squares in a sorted order from the problem of writing them into an array.\\n\\nThere are 2 subapproaches. One that returns the squares in reversed order, and one that puts them around the right way. The latter is more complex to code, but it means that the code dealing with the writing doesn\\'t have to reverse them, and it is still a time complexity of ```O(n)``` and an auxillary space usage of ```O(1)```.\\n\\n## a) Iterator returning from largest -> smallest\\n\\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\\n\\n## b) Iterator returning from smallest -> largest\\n\\nThis one uses a binary search to set the left and right pointers in the middle of the array to begin with. This way, the items are returned in the correct order. We don\\'t even need explicit write code here!\\n\\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\\n\\n# Approach 5: Generators\\nWhy are we using iterators for such a simple task? We can use a generator function instead!\\n\\nAgain, it\\'s O(n) time with O(1) auxillary space.\\n\\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```\\n\\n# In conclusion\\nI\\'m sure there are many more approaches. Another would be to combine the 2 pointer technique with the binary search. \\n\\nI\\'m interested in thoughts people have on which is best in an interview!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Queue",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```O(n-log-n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        for i in range(len(A)):\\n            A[i] *= A[i]\\n        A.sort()\\n        return A\\n```\n```O(1)```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([v**2 for v in A])\\n```\n```\\ndef sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [v**2 for v in A]\\n\\t\\treturn_array.sort() # This is in place!\\n\\t\\treturn return_array\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```[-4, -2, -1, 0, 1, 2, 3, 5] -> [16, 4, 1, 0, 1, 4, 9, 25]```\n```O(n)```\n```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        left_read_pointer = 0\\n        right_read_pointer = len(A) - 1\\n        left_square = A[left_read_pointer] ** 2\\n        right_square = A[right_read_pointer] ** 2\\n        while write_pointer >= 0:\\n            if left_square > right_square:\\n                return_array[write_pointer] = left_square\\n                left_read_pointer += 1\\n                left_square = A[left_read_pointer] ** 2\\n            else:\\n                return_array[write_pointer] = right_square\\n                right_read_pointer -= 1\\n                right_square = A[right_read_pointer] ** 2\\n            write_pointer -= 1\\n        return return_array\\n```\n```O(n)```\n```O(n)```\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        number_deque = collections.deque(A)\\n        reverse_sorted_squares = []\\n        while number_deque:\\n            left_square = number_deque[0] ** 2\\n            right_square = number_deque[-1] ** 2\\n            if left_square > right_square:\\n                reverse_sorted_squares.append(left_square)\\n                number_deque.popleft()\\n            else:\\n                reverse_sorted_squares.append(right_square)\\n                number_deque.pop()\\n        return reverse_sorted_squares[::-1]\\n```\n```O(1)```\n```O(n)```\n```O(1)```\n```\\nclass SquaresIterator(object):\\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer = 0\\n        self.right_pointer = len(sorted_array) - 1\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        if self.left_pointer > self.right_pointer:\\n            raise StopIteration\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square > right_square:\\n            self.left_pointer += 1\\n            return left_square\\n        else:\\n            self.right_pointer -= 1\\n            return right_square\\n     \\n\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return_array = [0] * len(A)\\n        write_pointer = len(A) - 1\\n        for square in SquaresIterator(A):\\n            return_array[write_pointer] = square\\n            write_pointer -= 1\\n        return return_array\\n```\n```\\nclass SquaresIterator(object):\\n    \\n    def __init__(self, sorted_array):\\n        self.sorted_array = sorted_array\\n        self.left_pointer, self.right_pointer = self._get_pointers()\\n    \\n    def __iter__(self):\\n        return self\\n    \\n    def __next__(self):\\n        \\n        # If there\\'s no values remaining.\\n        if self.left_pointer < 0 and self.right_pointer >= len(self.sorted_array):\\n            raise StopIteration\\n        \\n        # If there\\'s no values remaining on the left end.\\n        if self.left_pointer < 0:\\n            self.right_pointer += 1\\n            return self.sorted_array[self.right_pointer - 1] ** 2\\n        \\n        # If there\\'s no values remaining on the right end.\\n        if self.right_pointer >= len(self.sorted_array):\\n            self.left_pointer -= 1\\n            return self.sorted_array[self.left_pointer + 1] ** 2\\n        \\n        # If there\\'s values remaining on both ends.\\n        left_square = self.sorted_array[self.left_pointer] ** 2\\n        right_square = self.sorted_array[self.right_pointer] ** 2\\n        if left_square < right_square:\\n            self.left_pointer -= 1\\n            return left_square\\n        else:\\n            self.right_pointer += 1\\n            return right_square\\n    \\n    \\n    def _get_pointers(self):\\n        low = 0\\n        high = len(self.sorted_array)\\n        while high - low > 1:\\n            mid = low + (high - low) // 2\\n            if self.sorted_array[mid] > 0:\\n                high = mid\\n            else:\\n                low = mid\\n        return low, high\\n        \\n    \\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(SquaresIterator(A))\\n```\n```\\nclass Solution:\\n    \\n    def generate_sorted_squares(self, nums):\\n        \\n        # Start by doing our binary search to find where\\n        # to place the pointers.\\n        left = 0\\n        right = len(nums)\\n        while right - left > 1:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > 0:\\n                right = mid\\n            else:\\n                left = mid\\n        \\n        # And now the main generator loop. The condition is the negation\\n        # of the StopIteration condition for the iterator approach.\\n        while left >= 0 or right < len(nums):\\n            if left < 0:\\n                right += 1\\n                yield nums[right - 1] ** 2\\n            elif right >= len(nums):\\n                left -= 1\\n                yield nums[left + 1] ** 2\\n            else:\\n                left_square = nums[left] ** 2\\n                right_square = nums[right] ** 2\\n                if left_square < right_square:\\n                    left -= 1\\n                    yield left_square\\n                else:\\n                    right += 1\\n                    yield right_square\\n        \\n    \\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return list(self.generate_sorted_squares(A))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222079,
                "title": "python-o-n-10-lines-two-solutions-explained-beats-100",
                "content": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\\nThe question boils down to understanding that if we look at the magnitude of the elements in the array, `A`, both ends \"slide down\" and converge towards the center of the array. With that understanding, we can use two pointers, one at each end, to iteratively collect the larger square to a list. However, collecting the larger square in a list with `list`\\'s `append`, results in elements sorted in descending order. To circumvent this, we need to append to the left of the list. Using a `collections.deque()` allows us to append elements to the left of `answer` in O(1) time, maintaining the required increasing order.\\n\\n**Alternative without deque or list reversal**\\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\\nWe first declare a list of length, `len(A)` then add the larger square from the back of the list, denoted by the index `r - l`.\\n\\n**Shorter, terribly unreadable version - 6 lines**\\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef sortedSquares(self, A):\\n    answer = collections.deque()\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer.appendleft(left * left)\\n            l += 1\\n        else:\\n            answer.appendleft(right * right)\\n            r -= 1\\n    return list(answer)\\n```\n```python\\ndef sortedSquares(self, A):\\n    answer = [0] * len(A)\\n    l, r = 0, len(A) - 1\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        if left > right:\\n            answer[r - l] = left * left\\n            l += 1\\n        else:\\n            answer[r - l] = right * right\\n            r -= 1\\n    return answer\\n```\n```python\\ndef sortedSquares(self, A):\\n    l, r, answer = 0, len(A) - 1, [0] * len(A)\\n    while l <= r:\\n        left, right = abs(A[l]), abs(A[r])\\n        answer[r - l] = max(left, right) ** 2\\n        l, r = l + (left > right), r - (left <= right)\\n    return answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 973576,
                "title": "a-good-interview-problem-interview-explanation-c",
                "content": "I really like these problems when the right solutions are not that trivial to come by and the solutions actually require some explanation analysis for the advantages and disadvantages.\\n\\nThe obvious/simplest solution would be just using **built in sort** (or code one yourself) and you can say it would work O(NlogN) time / O(1) space. (some python people can say built in works for O(N), but w/e)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\\n\\nThe interviewer may easily ask if you could do better time wise ... and well, here, time to think a bit xD\\n\\nOne can do **counting sort** with the constraints of NUM_MAX <= 10^4 are not that big for numbers themselves and scale same as the N <= 10^4 so it would be a good idea. Just need to make every number absolute and count them. O(N) time, O(NUM_MAX <= 10^4) extra space.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\\n\\n\\nFor people who are here on leetcode for sometime they would come to an idea of two pointers pretty fast, however, with some caveat. \\n\\nFirst why two pointers? Well, after a bit of thinking you may notice that after squaring numbers, all negative numbers are big ... they go down, meet at zero with positive numbers ... and then all those positive numbers are squared. So natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\\nCleaner implementation of the two pointers is to go from the both ends of the list as the biggest numbers are there and meet in the middle instead. This solution is way nicer to code, but needs a bit of **reverse** thinking ;) \\nO(N) time, O(N) space.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nI believe the most important part is to be able to **thoroughly argue**. One must be very thorough in the opinions and not leave anything unanswered as the interviewer will notice some inaccuracies in the explanation right away. It is usually the giveaway if the person has analytical skills to understand problems completely, what those problems would entail, and how different solutions address those problems. \\n\\nTry to argue when would each of the solutions above do great, and when not so great. What if we change contraints (increase, decrease), which solutions would fail, which will thrive? One example is to say that counting sort is actually better when numbers are all NUM_MAX < N, cause that defines extra space and well that would make it a solution that uses less space with the same O(N) time, or if we increase N < 10^7 e.g. \\n\\nI hope that helps everyone to prepare for the coding interview, just give it a thought for every other problem that makes a huge difference :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        for (auto &x : a) x *= x;\\n        sort(a.begin(), a.end());\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int j = 0, m = 0;\\n        for (auto &x : a) x = abs(x), m = max(m, x);\\n        vector <int> c(m + 1, 0);\\n        for (auto &x : a) c[x]++; \\n        for (int i = 0; i <= m; i++) \\n            while (c[i]--) \\n                a[j++] = i * i;\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int m = 0, n = a.size(), k = 0;\\n        vector <int> ret(n, 0);\\n        while (m < n && a[m] < 0) m++;\\n        for (auto &x : a) x *= x;\\n        int i = m - 1, j = m;\\n        while (i >= 0 && j < n) {\\n            if (a[i] < a[j]) ret[k++] = a[i--];\\n            else ret[k++] = a[j++];\\n        }\\n        while (i >= 0) ret[k++] = a[i--];\\n        while (j <  n) ret[k++] = a[j++];\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        int i = 0, j = a.size() - 1, k = j;\\n        vector <int> ret(k + 1, 0);\\n        while (k >= 0) {\\n            if (abs(a[i]) > abs(a[j])) ret[k--] = a[i] * a[i++];\\n            else ret[k--] = a[j] * a[j--];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463098,
                "title": "o-n-detailed-aproach",
                "content": "**Brute Force Approach**\\nSquares of sorted array seems like the easiest problem, if you try to solve it in **O(nlogn) **approach\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n**Optimized Approach**\\nBut if you want to solve the problem in **O(n)** then it needs brainstorming to find the approach.\\nInput: nums = [-7,-3,2,3,11]\\nIf we see the elements with their absolute value then will get to know the element at the start and the last can be the highest value.\\nSo we use this approach to find our solution, by using the two pointer solution\\nTaking one pointer at the start of the array and then another pointer at the last of the array, and then compare these values\\n{7,-3,0,3,9,11}\\nMath.abs(-7) < Math.abs(11)\\n\\n{ , , , ,121} in the resultant array\\n\\nby this we will get the last element of the last array and we can store that value to the resultant array\\n\\nrepeat the same method until left\\u2264right.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```\\n\\n**DO UPVOTE IF YOU LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i = 0;i<nums.length;i++)\\n        {\\n            nums[i] *= nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left = 0;\\n        int right = nums.length -1;\\n        int index = nums.length- 1;\\n        int result[] = new int [nums.length];\\n        while(left<=right)\\n        {\\n            if(Math.abs(nums[left])>Math.abs(nums[right]))\\n            {\\n                result[index] = nums[left] * nums[left];\\n                left++;\\n            }\\n            else\\n            {\\n                result[index] = nums[right] * nums[right];\\n                right--;\\n            }\\n            index--;\\n        }\\n        return result;\\n    }\\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283978,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        result = [None for _ in A]\\n        left, right = 0, len(A) - 1\\n        for index in range(len(A)-1, -1, -1):\\n            if abs(A[left]) > abs(A[right]):\\n                result[index] = A[left] ** 2\\n                left += 1\\n            else:\\n                result[index] = A[right] ** 2\\n                right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410331,
                "title": "java-o-n-two-pointer-w-comments-beats-100",
                "content": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\npublic int[] sortedSquares(int[] A) {\\n\\t//result array\\n\\tint[] res = new int[A.length];\\n\\t//pointers for left and right\\n\\tint lo = 0; int hi = A.length - 1;\\n\\t//iterate from n to 0\\n\\tfor (int i = A.length - 1; i >= 0; i--) {\\n\\t\\t//check if abs left is less than or equal to abs right\\n\\t\\tif (Math.abs(A[lo]) >= Math.abs(A[hi])) {\\n\\t\\t\\t//add left squared to result array\\n\\t\\t\\tres[i] = A[lo] * A[lo];\\n\\t\\t\\t//increment left pointer\\n\\t\\t\\tlo++;\\n\\t\\t} else {\\n\\t\\t\\t//add right squared to result array\\n\\t\\t\\tres[i] = A[hi] * A[hi];\\n\\t\\t\\t//decrement right pointer\\n\\t\\t\\thi--;\\n\\t\\t}\\n\\t}\\n\\t//result\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 221924,
                "title": "c-java-4-lines-o-n-inside-out-or-outside-in",
                "content": "We find the first non-negative element in the array. From there, we move \\'negative\\' pointer (```np```) towards zero, and \\'positive\\' pointer (```pp```) towards the end of the array, selecting the next square.\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\\nIn a way, we are going *inside out* and filling our result vector from the beginning. Alternativelly, we can go *outside in* and fill the result in the reverse order:\\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\\nJava version:\\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```np```\n```pp```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res;\\n  int pvt = lower_bound(begin(A), end(A), 0) - begin(A);\\n  for (int pp = pvt, pn = pvt - 1; pp < A.size() || pn >= 0;) {\\n    if (abs(pn >= 0 ? A[pn] : INT_MAX) < abs(pp < A.size() ? A[pp] : INT_MAX))\\n      res.push_back(pow(A[pn--], 2));\\n    else res.push_back(pow(A[pp++], 2));\\n  }\\n  return res;\\n}\\n```\n```\\nvector<int> sortedSquares(vector<int>& A) {\\n  vector<int> res(A.size());\\n  for (int pn = 0, pp = A.size() - 1, pos = A.size() - 1; pn <= pp; --pos)\\n    res[pos] = pow(abs(A[pn]) < abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}  \\n```\n```\\npublic int[] sortedSquares(int[] A) {\\n  int[] res = new int[A.length];\\n  for (int pn = 0, pp = A.length - 1, pos = A.length - 1; pn <= pp; --pos)\\n    res[pos] = (int)Math.pow(Math.abs(A[pn]) < Math.abs(A[pp]) ? A[pp--] : A[pn++], 2);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285251,
                "title": "javascript-two-pointers-solution",
                "content": "Since we know that the source array is sorted, it is obvious that the largest numbers (by absolute value) are at the edges of the array, gradually decreasing towards the middle. So two pointers technique is ideal here.\\n\\n```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    let result = [];\\n    let l = 0;\\n    let r = A.length - 1;\\n    let p = r;\\n\\n    while (l <= r) {\\n        if (A[l] ** 2 > A[r] ** 2) {\\n            result[p--] = A[l++] ** 2;\\n        } else {\\n            result[p--] = A[r--] ** 2;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1102204,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nRuntime: 96 ms, faster than 99.97% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 45.6 MB, less than 21.94% of JavaScript online submissions for Squares of a Sorted Array.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    // use two pointers\\n    // create a new array\\n    const result = new Array(nums.length);\\n    let left = 0, \\n        right = nums.length - 1;\\n    \\n\\t// don\\'t want to rearrange the array, so iterating the array in descending order \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (Math.abs(nums[left]) < Math.abs(nums[right])) {\\n            result[i] = nums[right] ** 2\\n            right--;\\n        } else {\\n            result[i] = nums[left] ** 2\\n            left++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672974,
                "title": "js-two-pointers-85-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/92e8f912-6d40-492d-8d31-fa705da87411_1665151374.3462088.png)\\n\\nTwo pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nIn solving this problem, we alternately compare the values by indexes of pointers, and depending on whether one or another value is greater than another, we shift the pointers until we go through the entire array. To create a new sorted array, we also create an additional index variable so as not to affect the already added (sorted values).\\n\\n![image](https://assets.leetcode.com/users/images/5df0d2ab-6066-4948-90b9-e47ac2c572f0_1665156031.6328247.png)\\n\\n\\n```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    let idx = end;\\n    let sortPowArr = [];\\n\\n    while (idx > -1) {\\n        if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n            sortPowArr[idx--] = nums[start] * nums[start];\\n            start++;\\n        } else {\\n            sortPowArr[idx--] = nums[end] * nums[end];\\n            end--;\\n        }\\n    }\\n    return sortPowArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1759948,
                "title": "c-efficient-two-pointers-tc-o-n-sc-o-n-with-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n\\n* Since we need to put squeres in result array, we can consider that all numbers are positive\\n* Let\\'s take example with negative and positive numbers, like: `[-4, -2, 0, 1, 3]` => `[4, 2, 0, 1, 3]`\\n* Now, we can have two pointers `low` to left most element, `high` to most right element.\\n* Create `v` result array/vector same size as ` nums `.\\n* Move from right to left in resutl array `v`  whit the help of `k` , and put squares  of` max(abs(nums[low]), abs(nums[high]) ),` move correspondingly`low++` or `high--`\\n\\n*Time Complexity: O (n)\\nSpace Complexity: O (n)*\\n#### C++ code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-1;\\n        \\n        vector<int>v(n);//resutl vector\\n        int k=n-1;//start traversing for the end of v till 0   \\n        \\n        while(low<=high){\\n            if(abs(nums[low]) > abs(nums[high])){\\n                v[k--]=nums[low] * nums[low];\\n                low++;\\n            }else{\\n                v[k--]=nums[high] * nums[high];\\n                high--;\\n            }\\n        }\\n        return v; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336381,
                "title": "one-liner-two-pointer-explanation-python",
                "content": "One Liner:\\nThis is probably what comes first to your mind. Why not just find all squares and sort them. Simple right? But this will give you an `O(n*logn)` solution. Which is good but we can do better than this.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\\n\\nTwo Pointer Solution:\\nWe know our input is always sorted. So the largest squared values are on left and right sides of the input. So we can use 2 pointers `(l, r)` to compared the left and right most values and insert the larger ones to the resultant list.\\nBut when we add larger ones first, we have a list that\\'s in descending order. We want the result to be in ascending order. We can simply reverse the resultant list to get that.\\nThis 2 pointer approach will give us a `O(n)` solutions.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\\n\\nMinor optimisation:\\nIn the above algorithm, we reverse the output which is a `O(n)` operation. Which can be avoided by creating a result list of the same length with dummy values (I\\'m taking 0s here but this doesn\\'t actually matter). The thing to keep in mind is that, we\\'re finding the largest values one by one. So we have to fill the result from the right end, or the starting index will be `len(nums) - 1`. We keep decrementing this value as we add more values to the result.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```\\n\\nPlease upvote if you found this useful!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([num ** 2 for num in nums])\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1 # Initialise 2 pointers\\n        res = [] # initialise the result list\\n\\n        while l <= r: # continue the loop untill we go through all values, either with left pointer or with right pointer\\n            if abs(nums[l]) > abs(nums[r]):\\n\\t\\t\\t\\t# If the absolute value at left pointer is bigger, we know the square of left value will be bigger than the right one\\n                res.append(nums[l]**2)\\n                l += 1 # increment pointer because we can now look at the next value\\n            else:\\n\\t\\t\\t\\t# If left is not bigger, it\\'s either equal or right value is bigger. In both cases, we can add right value to the result.\\n                res.append(nums[r]**2)\\n                r -= 1 # decrement pointer to go to the previous value\\n        return res[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums) - 1\\n        res = [0] * len(nums) # create a result list with dummy values\\n        i = len(nums) - 1 # index on which we will fill the result\\n\\n        while l <= r:\\n            if abs(nums[l]) > abs(nums[r]):\\n                res[i] = nums[l]**2\\n                l += 1\\n            else:\\n                res[i] = nums[r]**2\\n                r -= 1\\n            i -= 1 # we have filled the result on this index, now we go to the index one lesser than this\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181063,
                "title": "java-clean-concise-code-two-pointer-technique-100-optimal-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int[] answer = new int[nums.length];\\n        int i = 0, j = nums.length - 1, k = nums.length - 1;\\n        \\n        while (k >= 0) {\\n            if (Math.abs (nums[i]) > Math.abs (nums[j])) {\\n                answer[k--] = nums[i] * nums[i++];\\n            }\\n            else {\\n                answer[k--] = nums[j] * nums[j--];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110139,
                "title": "beats-100-c-two-pinter-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is array is already sorted so no need to first take all the elemnts and then sort and also making tc  nlogn either we will do two pointer appraoch and check absolute value form start and last where they can be placed .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo Pointer Appraoch :\\n- Keep two pinters and check if (magnitude wise i,e take abs) $$arr[i]>arr[j] $$push $$arr[i]^2 $$else push $$arr[j]^2$$\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>ans(n);\\n        int i=0,j=n-1,k=n-1;\\n        while(i<=j){\\n            if(abs(arr[i])>abs(arr[j])){\\n                ans[k--]=(arr[i]*arr[i]),i++;\\n            }\\n            else ans[k--]=(arr[j]*arr[j]),j--;\\n        }\\n        //reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251088,
                "title": "c-solution",
                "content": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C\\nint *sortedSquares(int *A, int ASize, int *returnSize) {\\n    int *result = malloc(sizeof(int) * (*returnSize = ASize)), *p = A, *q = A + ASize - 1;\\n    int index = ASize - 1;\\n    while (p <= q) {\\n        *p = *p > 0 ? *p : *p * -1;\\n        *q = *q > 0 ? *q : *q * -1;\\n        if (*p >= *q) {\\n            result[index--] = *p * (*p);\\n            p++;\\n        } else {\\n            result[index--] = *q * (*q);\\n            q--;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189378,
                "title": "python-two-pointer-clean-simple-o-n-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, We are having many solutions but here i am showing you just 2. \\n1. We are having a **Two Pointer** approach which should work well.\\n    - Here we had one pointer $$i$$ at $$start$$ index, second pointer $$j$$ at $$end$$ index , a list $$ans$$ of size n, and a $$k$$ pointer to update value in $$ans$$ list.\\n    - Then, we start comapring absolute value in nums where pointers are pointing.\\n    - ` if abs(nums[l]) > nums[r]:`\\n    - So, we update value at $$k$$ position in ans with ` nums[l] * nums[l]`.\\n    - ` else:`\\n    - Update value at $$k$$ position in ans with ` nums[r] * nums[r]`.\\n2. **List Comprehension + Sorting:** \\n    - Here, we are making a list with square of nums using list comprehension and making it sort and directly returning it.\\n\\n# Code\\n## 1. Two Pointer Approach :\\n\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\\n## 2. List Comprehension + Sorting :\\n\\n### Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```\\n- Here I personally felt **List Comprehension + Sorting** isn\\'t fast but this approach give me fast runtime in submission.\\n- So, don\\'t know what\\'s wrong with leetcode runtime checking algorithm.\\n- If anyone have suggestion please comment it.\\n- If you found it helpful please upvote, it helps to create such a more content.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Two Pointer Approach\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        k = n - 1\\n        ans = [0] * n\\n        while k >= 0:\\n            if abs(nums[l]) > nums[r]:\\n                ans[k] = nums[l] * nums[l]\\n                l += 1\\n            else:\\n                ans[k] = nums[r] * nums[r]\\n                r -= 1\\n            k -= 1\\n        return ans\\n\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # One Liner\\n        return sorted([num * num for num in nums])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943161,
                "title": "full-description-on-how-to-solve-using-two-pointers-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use two pointers approach to solve this problem. The given array is **sorted** means the **square** of the elements present at either the **leftmost side** and the **rightmost side** is the greatest.\\n\\nExample:-\\n$$nums = [-14,-1,0,3,10]$$ \\nSquare of -14 is the greatest of all sqaures.\\n\\n$$nums = [-7,-3,2,3,11]$$\\nSquare of 11 is the greatest of all sqaures, followed by square of -7.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have taken two pointers: `left` and `right`.\\n\\n`left` initially points to first element of the given array whereas `right` points to last element of the given array.\\n\\nNow,lets run a `while()`loop with the condition`left<=right`. The condition means that we will perform particular operations till `left` pointer is either before, or at the same position as the `right` pointer.\\n\\ni.e.: \\n![My First Board.jpg](https://assets.leetcode.com/users/images/f2e94a4b-3268-4299-98b3-dff8d7e2550f_1671818204.6543193.jpeg)\\n\\n*left pointer cannot go ahead of right pointer but both can be at same position therefore \\'=\\' sign is also used in the condition.*\\n\\n---\\n\\nNow, lets understand the body of the while loop, which is the main algorithm of our code.\\n\\n**Firstly :-** We compare the abs values pointed by the `left` and `right` pointers and store it in the `max` variable. We will use ternary operator for this task. \\n\\n***Moving the pointers***\\n We also need to move the pointers so we check which pointer\\'s value `max` is storing. So we use an `if()`loop here with the condition `max==nums[right]`, if the condition is *true*, it means abs value pointed by `right` is greater than the abs value pointed by `left`, so we move right pointer by one position i.e., `right--`. If the condition is false, we move the left pointer.\\n\\n**Lastly :-** We store the square of the greater value i.e., `max*max` and store it in `ans[k]`. `K` is a variable used for the resultant array, initially pointing to last index of the `ans`. After storing the value, we decrement the value of k.\\n\\n---\\n\\n\\n\\n\\n\\n**Variables and their use in the code:**\\n- `left` : left pointer, initial value = 0, points to 1st element of the array.\\n- `right`: right pointer, initial value = `nums.length-1` i.e., points to the last value of the array.\\n- `k`: used to store values in the new array `ans`. Initial value of `nums.length-1` i.e. points to last position in the resultant array as we will eneter elements from right to left.\\n- `max`: used to store the greater of the two number pointed by `left` and `right`.\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int left=0, right=nums.length-1;\\n        int ans[]= new int[nums.length];\\n        int k=nums.length-1;\\n        while(left<=right){\\n            int max=(Math.abs(nums[left])<Math.abs(nums[right])? nums[right]: nums[left]);\\n            if(max==nums[right])\\n                right--;\\n                else \\n                    left++;\\n            ans[k]=max*max;\\n            k--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783139,
                "title": "c-concise-o-n-solution",
                "content": "C# doesn\\'t get enough love here, but here\\'s a fairly simple/intuitive example of a concise one pass solution using C#\\n\\n```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\n    public int[] SortedSquares(int[] nums) {\\n        var arr = new int[nums.Length];\\n        int begIndex = 0;\\n        int endIndex = nums.Length-1;\\n        int end = endIndex;\\n        while (begIndex <= endIndex)\\n            arr[end--] = Math.Abs(nums[endIndex]) > Math.Abs(nums[begIndex])\\n                ? nums[endIndex] * nums[endIndex--]\\n                : nums[begIndex] * nums[begIndex++];\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467196,
                "title": "intuition-java-two-pointer-plots-visualization",
                "content": "**If you guys are thinking about the intuition behind this two pointer algorithm , This article is for you!!**\\n\\nConsider , \\nInput:  nums = [-4,-1,0,3,10]\\nafter squaring we will get [16,1,0,9,100]\\nif we plot this points as (0,16), (1,1), (2,0), (3,9), (4,100)\\nwe will get the following plots\\n![image](https://assets.leetcode.com/users/images/d4dd8182-3262-4df3-aa1e-571c7386451f_1631786175.9753773.png)\\nOur goal is to find squares of sorted array , So by seeing the plot we can make out the maximum value is 100. Here, max value is on extreme right.\\n\\nNow, we can similarly think about these two plots\\n\\n![image](https://assets.leetcode.com/users/images/c4528640-9431-4a9a-95d3-aac7586ef67c_1631786259.1755123.png)\\n Here, max value is on extreme left.\\n \\n![image](https://assets.leetcode.com/users/images/2820deda-263c-4f87-9455-c27b6679285d_1631786303.2714875.png)\\n Here, max value is present on extreme left as well as extreme right.\\n \\n \\n Till here, we have understood that to get max value in entire array we have to check for extreme left and right, hence we fill our answer array in reverse manner.\\n So we keep two pointers at extreme ends and check which square is greatest among them and finally place it in answer array, similarly we will do for all elements.\\n \\n \\n \\n ```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```\\n \\n \\n Time Complexity: O(N)\\n Auxillary Space: O(1) \\n\\n**NOTE : since the function itself is expecting from us to return answer in an array , it is not considered in auxiliary space.**\\n\\n\\n# YOU ALL CAN BUY ME A COFFEE AT \\uD83D\\uDC47\\n https://www.buymeacoffee.com/deepakgupta",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n \\n public int[] sortedSquares(int[] nums) {\\n        \\n        int i = 0; //pointer at extreme left\\n        int j = nums.length-1;//pointer at extreme right\\n        int k = nums.length-1;//used for filling answer array in reverse\\n        \\n        int[]ans = new int[nums.length];\\n        \\n        while(i<=j)\\n        {\\n            int v1 = nums[i];\\n            int v2 = nums[j];\\n            int sq1 = v1*v1;\\n            int sq2 = v2*v2;\\n            if( sq1 < sq2)\\n            {\\n                ans[k--] = sq2;\\n                j--;\\n            }\\n            else\\n            {\\n                ans[k--] = sq1;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477544,
                "title": "go-o-n-solution-with-explanation",
                "content": "**Explanation - Code at bottom**\\nWe know that a non-decreasing array means that the numbers will be sorted from the smallest to the largest - with the lowest negative number on the far left, and the greatest positive number on the far right.\\n\\nTake a look at example 1 from the problem: nums = [-4, -1, 0, 3, 10].\\n\\nLet\\'s explore those numbers in the array to see if we can identify a pattern. \\n\\nIf we square every number in the list we arrive at [16, 1, 0, 9, 100]. We can see that squared negative numbers results in a positive integer - so whether we square the negatives or we square the absolute values, we arrive at the same result.\\n\\nSquaring the absolute values [4, 1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100].\\nSquaring the negative values [-4, -1, 0, 3, 10] gives us a new array of [16, 1, 0, 9, 100]\\n\\nAgain, because the given array is in non-decreasing order we know that the largest value will always be either the absolute value of the first number of the given array or the absolute value of the last number of the given array.\\n\\nKnowing this, we can start off by comparing the absolute values of the first and last indices of the given array to determine which is larger. We can then append the largest of the two to the last index of our new array.\\n\\nSo, is the absolute value of -4 less than the absolute value of 10? Yes, because 16 is less than 100. So we can add the square of 10 to the last index in our new array.\\n\\n[null, null, null, null, 100]\\n\\nNow that we have added the last index of the given array, we can ignore that index from here on out. \\n\\n[-4, -1, 0, 3]\\n\\nThe largest absolute value on the right is now 3. Let\\'s compare the squared absolute value of 3 to the outermost index on the left - again, this is -4.\\n\\n(abs(-4))^2 = 16\\n(abs(93))^2 = 9\\n\\n16 is greater than 9, so the next number to be added to our new array is 16.\\n\\n[null, null, null, 16, 100]\\n\\nWe now ignore the initial first index, as it\\'s square has already been placed in our new array, and focus on the remaining given array. \\n\\n[-1, 0, 3]\\n\\nAgain, we know the next largest squared number will come from one of the two outside numbers. So let\\'s find it.\\n\\n(abs(-1))^2 = 1\\n(abs(3))^2 = 9\\n\\n9 is greater than 1 so let\\'s add it to our new array.\\n\\n[null, null, 9, 16, 100]\\n\\nThat means our given array is now\\n\\n[-1, 0]\\n\\nAgain, we are going to compare the left-most and right-most indices.\\n\\n(abs(-1))^2 = 1\\n(abs(0))^2 - 0\\n\\n1 is greater than 0 so let\\'s add it to our new array.\\n\\n[null, 1, 9, 16, 100]\\n\\nWe have one remaining index from our given array so let\\'s add it.\\n\\n[0, 1, 9, 16, 100]\\n\\nWe have taken each index from the given array, squared it, then placed it sorted within a new array.\\n\\n*Of note, we can square the numbers before or after the comparison and get the same result.*\\n\\nabsolute(-4) < absolute(10) and (absolute(-4))^2 < (absolute(10))^2\\n\\n**Let\\'s code this algorithm in Go.**\\n\\nStart by getting the length of whatever the input array is.\\n\\n`n := len(nums)`\\n\\nNext, create our new slice, of type int and size n, that will contain the sorted squares. We can call it result. \\n\\n`result := make([]int, n)`\\n\\nWe can now create our left and right pointers.\\n\\n`left, right := 0, n - 1`\\n\\n*Note: We are using n - 1 here because there are n items in the array, starting at 1, but the index always starts with 0. So the final index of the array is n - 1.*\\n\\nWe can now start filling in our new array from the last index to the start. So, from n - 1 to 0.\\n\\nLet\\'s declare a square variable.\\n\\n`square := 0`\\n\\nNow we need to compare the absolute values. We can use the math package, but I will just create our own function that returns the absolute value:\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\\n\\nWithin our for loop iterating over our new slice in reverse, let\\'s compare the absolute values of each pointer and set square to the largest one and adjust the pointer at that value.\\n\\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\\n\\n**Here is the final code with comments:**\\n\\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n```\n```\\nfor i := n - 1; i >= 0; i-- {\\n        square := 0\\n        \\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n    }\\n```\n```\\n// function to get the absolute value\\nfunc Abs(x int) int {\\n    if x < 0 {\\n        return -x\\n    }\\n    \\n    return x\\n}\\n\\n// main function to get the sorted squares array\\nfunc sortedSquares(nums []int) []int {\\n    \\n    n := len(nums) // get the length of the given array\\n    result := make([]int, n) // create a new slice of type int that can hold n values\\n    \\n    // left and right pointers\\n    left, right := 0, n - 1\\n    \\n    // iterate through our new slice (result) in reverse as we will be adding numbers from largest to smallest\\n    for i := n - 1; i >= 0; i-- {\\n        square := 0 // the variable that will store the largest absolute value of the two pointers\\n        \\n        // if the absolute value of the left pointer is less than the absolute value of the right pointer, \\n        // set square to the larger number from the right pointer and move the right pointer one left.\\n        // Else set square to the larger number from the left pointer and move the left pointer one right.\\n        if Abs(nums[left]) < Abs(nums[right]) {\\n            square = nums[right]\\n            right--\\n        } else {\\n            square = nums[left]\\n            left ++\\n        }\\n        \\n        // square the value and add it to the appropriate index\\n        result[i] = square * square\\n    }\\n    \\n    // return the sorted array with the squared values\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2748647,
                "title": "java-runtime-1ms-faster-than-100-memory-usage-less-than-95-87",
                "content": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/55988ba5-1e00-4f70-9aff-5b34e26e9cbe_1666863577.579867.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] sortedSquares(int[] nums) {\\n        int length = nums.length;\\n        if (length == 0) return new int[0];\\n        \\n        int[] result = new int[length];\\n        int l = 0, r = length - 1;\\n        for (int i = length - 1; i >= 0; i--) {\\n            int start = nums[l] * nums[l];\\n            int end = nums[r] * nums[r];\\n            if (start > end) {\\n                result[i] = start;\\n                l++;\\n            } else {\\n                result[i] = end;\\n                r--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302304,
                "title": "js-faster-than-99-simple-solution",
                "content": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortedSquares = function(A) {\\n  const result = [];\\n  let head = 0;\\n  let tail = A.length - 1;\\n\\n  while (head <= tail) {\\n    if (A[head] ** 2 > A[tail] ** 2) result.push(A[head++] ** 2);\\n    else result.push(A[tail--] ** 2);\\n  }\\n\\n  return result.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243791,
                "title": "java-1-line-solution-using-streams",
                "content": "Java one liner\\n```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "solutionTags": [],
                "code": "```\\nreturn Arrays.stream(A).map(a -> a*a).sorted().toArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1666085,
                "title": "c-easy-solution-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Simple approach: convert squares of every elements & then sort them.\\n- **Time complexity:** O(nlogn).\\n\\n### Solution 02\\n\\n- 2 pointer approach.\\n- Take a separate array of size n.\\n- Take 2 pointers: l & r.\\n- Compare square of l & r indexed elements & put the max element to last of ans array.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size()-1;\\n        int l=0, r=n;\\n        vector<int> ans(nums.begin(), nums.end());\\n        \\n        while(n>=0){\\n            if(nums[l]*nums[l] > nums[r]*nums[r]){\\n                ans[n] = nums[l]*nums[l];\\n                l++; n--;\\n            }\\n            else{\\n                ans[n] = nums[r]*nums[r];\\n                r--; n--;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461322,
                "title": "python-one-line-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i * i for i in nums])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299085,
                "title": "3-solutions-2-pointer-and-sort-explained",
                "content": "**Solution 1**\\n- uses 2 pointers. \\n- **Start both pointers from opposite directions**. When working with sorted arrays, ask yourself it makes sense to start pointers from opposite ends. In this problem, starting from opposite ends is a good strategy. This visualization may help. \\n![image](https://assets.leetcode.com/users/images/a93e2573-233a-4e5e-85bf-98eb792f854e_1624738522.3515596.png)\\n- If we start from opposite ends, we know that both ends will give us the respective highest squares, especially when working with negative numbers.\\n- Next, we make a comparison, and grab the highest value and insert it into the results array.\\n\\n```\\n[-4, -3,  0, 3, 5]\\n```\\n\\neven if we don\\'t have negative numbers this strategy works nicely.\\n\\n```\\n[ 0, 3, 5, 7]\\n```\\n\\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\\n\\n\\n**Solution 2**\\n- 2 pointer, start pointers close to each other\\n- start right index at the first positive number index\\n- start left index and the first positive number index - 1;\\n![image](https://assets.leetcode.com/users/images/4b11ad63-5b29-4c86-b289-4fe7d637925d_1624739338.4962318.png)\\n\\nSolution 2, requires **aloooot of edge case handling**, so the first solution is definetly better, I think. Again, with sorted inputs, its always good idea to ask yourself if starting pointers from the opposite direction is better/simpler\\n\\n\\n**Solution 3 (brute force)**\\n- loop over each element, square it. Before returning sort the list\\n- downside, compared to solution 1 is that we are sorting which adds `n log n` complexity \\n\\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```\\n\\n\\nAdditonal resource readings\\n- https://emre.me/coding-patterns/two-pointers/",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n[-4, -3,  0, 3, 5]\\n```\n```\\n[ 0, 3, 5, 7]\\n```\n```\\nvar sortedSquares = function (nums) {\\n    const results = new Array(nums.length);\\n    let left_idx = 0;\\n    let right_idx = nums.length-1;\\n    let next_highest_square_index = nums.length-1; // keep track where our next insert position will be in the results array\\n\\n    while(left_idx <= right_idx){\\n        const left_el = Math.pow(nums[left_idx],2)\\n        const right_el = Math.pow(nums[right_idx],2)\\n        if(left_el > right_el){\\n            results[next_highest_square_index] = left_el\\n            next_highest_square_index -=1;\\n            left_idx +=1\\n        }\\n        else {\\n            results[next_highest_square_index] = right_el;\\n\\t\\t\\tnext_highest_square_index -= 1;\\n            right_idx -= 1\\n        }\\n    }\\n    return results\\n};\\n```\n```\\nvar sortedSquares = function(nums) {\\n    return nums\\n            .map(num => Math.pow(num, 2))\\n            .sort((a,b) => a-b); // sort ascending\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514315,
                "title": "javascript-two-pointers-o-n-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n* 132/132 cases passed (92 ms)\\n* Your runtime beats 99.09 % of javascript submissions\\n* Your memory usage beats 88.89 % of javascript submissions (42.6 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n  const res = [];\\n  let i = 0;\\n  while (A[i] < 0) i++;\\n  let j = i - 1;\\n  while (j >= 0 || i < A.length) {\\n    if (i >= A.length || -A[j] <= A[i]) {\\n      res.push(A[j--] ** 2);\\n    } else {\\n      res.push(A[i++] ** 2);\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873182,
                "title": "c-easy-solution-100-o-n",
                "content": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* nums, int numsSize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(nums[0]) * numsSize);\\n    int start = 0;\\n    int end = numsSize - 1;\\n    for (int i = numsSize - 1; start <= end; i--) {\\n        int a = nums[start] * nums[start];\\n        int b = nums[end] * nums[end];\\n        if (a > b) {\\n            res[i] = a;\\n            start++;\\n        } else {\\n            res[i] = b;\\n            end--;\\n        }\\n    }\\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419437,
                "title": "python-two-pointers-solution-o-n",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        i = 0\\n        n = len(nums)\\n        j = n - 1\\n        \\n        new = [0] * n\\n        k = n - 1\\n        \\n        while i <= j:\\n            if abs(nums[i]) < abs(nums[j]):\\n                new[k] = nums[j] ** 2\\n                j -= 1\\n                \\n            else:\\n                new[k] = nums[i] ** 2\\n                i += 1\\n            k -= 1\\n            \\n        return new",
                "codeTag": "Java"
            },
            {
                "id": 2230684,
                "title": "simple-o-n-solution-not-o-nlogn",
                "content": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n   vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0 , r = n-1;\\n        for(int i = n-1 ; i>=0 ; i--){\\n            if(abs(nums[l]) > abs(nums[r])){\\n                \\n            \\n                ans[i] = nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                ans[i] = nums[r]*nums[r];\\n                r--;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764051,
                "title": "c-o-n-sol",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n        {\\n            arr[ptr] = pow(A[end--],2);\\n        }\\n        else\\n        {\\n            arr[ptr] = pow(A[start++],2);\\n        }\\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410492,
                "title": "c-with-two-indices-explained",
                "content": "So at first we look at sorting as nlogn and we know we need to have this solution, \\nthe naive solution here is just multiply everything and sort again.\\n\\nlet\\'s try better than that.\\n\\nwe need to understand that the only thing we know of absolute value is the fact is says how far are we from zero. meaning if we compare two numbers in their absulote values we know which one is bigger, so when we will raise them by power of 2 they will be positives as well. \\nso this is the main idea here how do we utilize Math.Abs in order to sort our array.\\n\\nso the tricky part is to understand how to fill the array. well ...\\n\\nso we need to understand which Math.Abs is bigger in order to put it....last...\\nbecause we are sorting.\\n\\nwho can be the biggest? the last value or the first value (which is negative in the example.)\\n\\nso we have start and end index and we compare \\nMath.Abs(A[start]) > Math.Abs(A[end)\\n\\nwhoever is bigger goes to the end;\\n\\nso we need to start the iteration from the end as well.\\n\\n```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public int[] SortedSquares(int[] A) {\\n        int[] res=new int[A.Length];\\n        int start = 0;\\n        int end = A.Length-1;\\n        for(int i=A.Length-1;i>=0; i--)\\n        {\\n            if(Math.Abs(A[start]) > Math.Abs(A[end]))\\n            {\\n                res[i]  = A[start] * A[start];\\n                start++;\\n            }\\n            else{\\n                res[i] = A[end]*A[end];\\n                end--;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366635,
                "title": "94-faster-than-all-the-submission-o-n-time-solution-with-detailed-explantnation",
                "content": "**First Aproach :**\\n* \\t Iterate through the vector and square the elements.\\n* \\t Use built in sort function to sort the vector.\\n* \\t this solution is slow and take O(n log n).\\n\\t\\n```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\\n\\n**Second Aproach :**\\n\\n Since we are given with ***sorted array*** we can iterate through the vector and get the first positive number, which will divide the array in two halfs.\\n* \\tThese two halfs are sorted and there squares will also be sorted.\\n* \\tNow merge the sorted arrays as we do it in merge sort.\\n* \\tThis approach will yeild a O(n) solution.\\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```\\n\\n Please do comment and let me know if i am wrong anywhere or if you have any better approach.\\n Thanks",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n        for(int i=0;i<A.size();i++){\\n            A[i]*=A[i];\\n        }\\n     \\n        sort(A.begin(),A.end());\\n        \\n        return A;\\n    }\\n```\n```\\nclass Solution {\\n\\npublic:    \\n    vector<int> sortedSquares(vector<int>& A) {  \\n        \\n        int l=A.size(),j=l-1;\\n        \\n        vector<int> result;\\n        \\n        //geting the index of first non negative number\\n        for(int m=0;m<l;m++){\\n            if(A[m]>=0){\\n                j=m;break;\\n            }\\n        }\\n              \\n        //squaring the elements.\\n        for(int i=0;i<l;i++)\\n        {\\n            A[i]*=A[i];\\n            \\n        }\\n        int k=j,i=j-1;\\n        //merging the elements such that they are increasing order.\\n           while(i>=0 && k<l){\\n               if(A[i]<A[k]){\\n                   result.push_back(A[i]);\\n                   i--;\\n               }\\n               else{\\n                   result.push_back(A[k]);\\n                   k++;\\n               }\\n           }\\n            //copy rest of elemets to result\\n            while(i>=0){\\n                result.push_back(A[i]);i--;\\n            }\\n            while(k<l){\\n                result.push_back(A[k]);k++;\\n            }\\n            return result ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569679,
                "title": "c-using-two-pointer-method-easy-solution-95-25-faster",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        //Two Pointer\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        vector<int>v(n,0);\\n        for(int i = n-1;i>=0;i--){\\n            if(abs(nums[left])>nums[right]){\\n                v[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                v[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884640,
                "title": "95-faster-one-pass-solution-two-pointers",
                "content": "***Please Upvote to keep me motivated*** \\u270C\\n\\n**Intution :-** Maintain the two pointers in start and in the end and check the absolute values in array.\\nWhichever is largest, push its square into the result array. Reverse the result array and return it.\\nWe are not maintaining the smaller values in result array because we may get more smaller values by moving ahead in the nums array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int l = 0;\\n        int h = n - 1;\\n        while(l <= h){\\n           if(abs(nums[l]) > abs(nums[h])){\\n               res.push_back(nums[l] * nums[l]);\\n               l++;\\n           } \\n           else{\\n                res.push_back(nums[h] * nums[h]);\\n                 h--;\\n           }\\n        }\\n        reverse(res.begin() , res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517010,
                "title": "reading-the-question-carefully-is-very-important-java-easy",
                "content": "+ A classic 2 pointer solution, s is pointer1 and e is pointer 2.\\n+ s starts from the begenning and e from end.\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int l = nums.length;\\n        int[] f = new int[l];\\n        int s=0, e=l-1, i=l-1,a,b;\\n        while(s<=e){\\n            a= nums[s]*nums[s]; b= nums[e]*nums[e];\\n            if(a>b){\\n                f[i]=a;\\n                s++;\\n            }else{\\n                f[i]=b;\\n                e--;\\n            }\\n            i--;\\n        }\\n        return f;\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973045,
                "title": "c-c-short-and-simple-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize){\\n    int* arr = malloc(sizeof(int)*ASize);\\n    *returnSize = ASize;\\n    int end = ASize-1, start = 0, ptr = ASize-1;\\n    while ((start <= end) && (ptr>=0))\\n    {\\n        if (pow(A[end],2) >= pow(A[start],2))\\n            arr[ptr] = pow(A[end--],2);\\n        else\\n            arr[ptr] = pow(A[start++],2);\\n        \\n        ptr--;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678147,
                "title": "c-two-pointer-solution",
                "content": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n) where n is the size of input array\\n    Space: O(n) due to the output array\\n*/\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        \\n        int[] res = new int[A.Length];       \\n        int left = 0, right = A.Length - 1;        \\n        \\n        for(int i = A.Length - 1; i >= 0; i--)\\n        {\\n            if(Math.Abs(A[left]) >= Math.Abs(A[right]))\\n            {\\n                res[i] = A[left] * A[left];\\n                left++;\\n            }\\n            else\\n            {\\n                res[i] = A[right] * A[right];\\n                right--;\\n            }           \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074042,
                "title": "ruby-solution-using-pointers-instead-of-built-in-ruby-sort-method",
                "content": "**O(nlogn) Solution**\\nYes, we all know that Ruby is awesome and this problem can be solved with a simple one-liner:\\n```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\\nBut, there are a couple issues with this solution. Most notably, this is NOT the most optimal solution. Ruby\\'s `sort` method uses quicksort internally, thus the complexity for this solution will end up being `O(nlogn)`. The other issue with this solution is that it doesn\\'t really honor the spirit of LeetCode (IE, coming up with your own clever algorithm to solve a given problem). In a real world interview your interviewer likely wouldn\\'t accept this as a \"final\" solution. Maybe a first stab. And first stabs aren\\'t bad! But we can do better.\\n\\n**O(n) Solution**\\nUsing simple pointers, we can come up with an `O(n)` solution. The basic principle: We know the `nums` array is already sorted, but the trick here is that it may contain some negative values. This means that when we square those negative values they\\'ll end up at some new index location in our final squared and sorted array. Luckily, we do know that they are already sorted ... just sorted in a more-or-less *backwards* order. Using this knowledge, we take two pointers - one for the left side of the nums array and one on the right side - and slowly increase the left pointer while simultaneously decreasing the right pointer, comparing the results of each squared number at each iteration. **Think of the array as two parts: a left array sorted from left to right and a right array sorted from right to left.** We move our left pointer along the \"left\" array and the right pointer along the \"right\" array, from largest to smallest in each case. We then stick the larger of the two at the end of our final array and move on to compare the next two left and right values by decreasing the left or right index by one each step. Our comparison window will slowly shrink until the left and right pointers meet and we have compared all values in the array one at a time. At this point we will have inserted each squared value *in sorted order* into our final array, and we\\'re done. Bim bam boom.\\n\\nHere\\'s my implmentation:\\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Sorting"
                ],
                "code": "```Ruby\\ndef sorted_squares(nums)\\n  nums.map { |n| n**2 }.sort\\nend\\n```\n```ruby\\ndef sorted_squares(nums)\\n  arr = [] # Initialize an empty array to store squared values\\n  l = 0 # Initialize the left pointer to zero (IE, the LARGEST value of the \"left\" array)\\n  r = nums.size - 1 # Initialize the right pointer to the size of nums (IE, the LARGEST value for the \"right\" array)\\n  i = r # Initialize our \"insert index\". Because we are starting with the largest values and working our way inward, we will insert each value into the array starting at the end (IE, the largest index in nums)\\n  \\n  until i < 0 # Loop until we\\'ve exhausted all nums\\n    left = nums[l]**2 # Square the left side value\\n    right = nums[r]**2 # Square the right side value\\n    \\n    if left > right\\n\\t  # If the left value is larger store it in our array at the current index and increment the left pointer\\n      arr[i] = left\\n      l += 1\\n    else\\n\\t  # Otherwise the right value is larger, store it at the current index and decrement the right pointer\\n      arr[i] = right\\n      r -= 1\\n    end\\n    \\n    i -= 1 # We inserted one squared value into our final array, decrement the current index\\n  end\\n     \\n  arr # Return the final array\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1695344,
                "title": "java-two-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n**Do upvote if you find this useful**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int[] res=new int[n];\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--){\\n            if(Math.abs(nums[left])>=Math.abs(nums[right])){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234202,
                "title": "swift-no-brainer",
                "content": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        return A.map{ $0 * $0 }.sorted()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531964,
                "title": "java-two-pointers",
                "content": "![IMG_20230516_220315.jpg](https://assets.leetcode.com/users/images/a8e537ec-9c2f-4402-95b0-5db8601d2d16_1684263908.2499745.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        int left = 0;\\n        int right = n - 1;\\n        int i = n - 1;\\n\\n        while (left <= right) {\\n            int leftSquare = nums[left] * nums[left];\\n            int rightSquare = nums[right] * nums[right];\\n\\n            if (leftSquare > rightSquare) {\\n                result[i] = leftSquare;\\n                left++;\\n            } else {\\n                result[i] = rightSquare;\\n                right--;\\n            }\\n\\n            i--;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062168,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0, n=nums.size();\\n        while(i<n-1 && abs(nums[i+1])<=abs(nums[i]))\\n        i++;\\n        i++;\\n        int j=i-1;\\n        vector<int> ans;\\n        while(j>=0 && i<n)\\n        {\\n            if(abs(nums[j])<abs(nums[i]))\\n            {\\n                ans.push_back(nums[j]*nums[j]);\\n                j--;\\n            }\\n            else\\n            {\\n                ans.push_back(nums[i]*nums[i]);\\n                i++;\\n            }\\n        }\\n        while(j>=0)\\n        {\\n            ans.push_back(nums[j]*nums[j]);\\n            j--;\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back(nums[i]*nums[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480790,
                "title": "shortest-possible-java-solution-only-4-lines-of-code-beats-100",
                "content": "Before showing the solution I suggest having a look at the [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/) problem if you didn\\'t, and you can see how I solved it [here](https://leetcode.com/problems/merge-sorted-array/discuss/1480686/shortest-java-solution-only-6-lines-of-code-beats-100).\\n\\nBy using the same logic, our approuch is to have two pointers starting at the beginning and end of the array and select whichever is higher and continuously fills out our new array from end to start with the selected element.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        \\n        for (int i = 0, j = nums.length - 1, current = j; current >= 0; ) {\\n            temp[current--] = Math.abs(nums[i]) >= Math.abs(nums[j]) ? nums[i] * nums[i++] : nums[j] * nums[j--];\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972954,
                "title": "python-oneliner-o-n-explained",
                "content": "Note, that our numbers will look like this: first we have some negative numbers in increasing order (may be `0` of them) and then we have some positive numbers in increasing order (again may be `0` of them). \\n\\n1. Note, that if we have negative number in increasing order, then their squares will be in decreasing order, so we need to invert this part.\\n2. If we have positive increasing numbers, then their squares also increasing numbers.\\n3. Now we have two lists with increasing numbers and we need to creaty one list with increasing numbers, how we can do it? We can use **merge** sort and do it by hands. However it happens, that if we run the code as it is it will be `O(n)`. Why? Because python uses so-called **Timsort** https://en.wikipedia.org/wiki/Timsort which will look for sorted patterns in data.\\n\\n**Complexity**: time and space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        return sorted([i**2 for i in nums if i > 0][::-1] + [i**2 for i in nums if i <= 0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483503,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        return sorted([x**2 for x in A])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230731,
                "title": "c-well-commented-solution-with-explanation-using-double-ended-queue",
                "content": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea ---- \\n1) Store the array in a double ended queue  \\n2) Now the element with the largest magnitude would be at the front or at the back\\n3) Moreover, the element with the largest magnitude would have the largest square value\\n4) So, Pop it and similarly get the second largest in magnitude\\n5) Finally, Reverse the answer to sort in non_decreasing order\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& myVector);\\n};\\n\\n/* Returns the vector of sorted square */\\nvector<int> Solution :: sortedSquares(vector<int>& myVector)\\n{\\n    // Declare the deque and the container to hold the answer\\n    vector<int> answer;\\n    deque<int> dq;\\n    \\n    // Fill all elements in the deque\\n    for(auto ele: myVector)\\n        dq.push_back(ele);\\n    \\n    // Keep extracting the element with the highest magnitude\\n    while(!dq.empty())\\n    {\\n        // Get a copy\\n        int front = dq.front();\\n        int back = dq.back();\\n        \\n        // If the largest magnitude occurs at the front, pop it and append it\\n        if(abs(front) > abs(back))\\n        {\\n            dq.pop_front();\\n            answer.push_back(front*front);\\n        }\\n        \\n        // Else pop the back and append it to answer\\n        else\\n        {\\n            dq.pop_back();\\n            answer.push_back(back*back);\\n        }\\n    }\\n    \\n    // Fianlly Reverse the answer to sort in non decreasing order\\n    reverse(answer.begin(), answer.end());\\n    \\n    // Return the new answer\\n    return answer;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806619,
                "title": "simple-python-solution-by-queue",
                "content": "![image.png](https://assets.leetcode.com/users/images/37ab4945-e4fe-414d-aec6-72e248e4217d_1668256343.9517837.png)\\n\\n\\n# Intuition\\nusing Queue\\n\\n# Approach\\n1. compare square of left most element and square of right most element, assign pop the max element from queue\\n2. Repeat this until the deque contains element.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []\\n        num_deque = collections.deque(nums)\\n\\n        while num_deque:\\n            left = num_deque[0] ** 2\\n            right = num_deque[-1] ** 2\\n\\n            if left > right:\\n                res.append(left)\\n                num_deque.popleft()\\n            else:\\n                res.append(right)\\n                num_deque.pop()\\n        \\n        return res[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238816,
                "title": "python-two-pointers-o-n-runtime-71-43",
                "content": "### Solution\\nFirstly, we initialize left and right pointers at the beginning and the end of the array. Then, we check the absolute values of the ends and populate the array in decreasing order.\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]):\\n                new_arr.append(nums[right]**2)\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2)\\n                left += 1\\n            \\n        return(new_arr[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126752,
                "title": "java-two-approaches-o-n-concise-solution-one-pass-with-well-explained-code",
                "content": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n     * BruteForce Approach.\\n     * (1) Square all the elements of array.\\n     * (2) Sort the squared array.\\n     * Time Complexity = O(n*logn) for sorting.\\n     * Space Complexity = O(1) no extra space is used.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n\\n    /*\\n     * Better Approach.\\n     * (1) Create new array & start filling it from behind.\\n     * (2) Make two pointers that points starting & ending index of original array\\n     * respectively.\\n     * Time Complexity = O(n) for traversing.\\n     * Space Complexity = O(n) extra space for answer array.\\n     */\\n\\n    static int[] sortedSquares(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int start = 0, end = nums.length - 1;\\n\\n        int ansIdx = nums.length - 1;\\n        while (start <= end) {\\n            if (nums[start] * nums[start] > nums[end] * nums[end]) {\\n                ans[ansIdx--] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                ans[ansIdx--] = nums[end] * nums[end];\\n                end--;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\tPlease Upvote if you like this :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1109072,
                "title": "java-two-pointers-o-n-with-interview-tips",
                "content": "Before proceeding to solution ask clarification question. for eg:\\n 1. can the values in the array be negative.\\n 2. can square of values can exceed Integer.MAX_VALUE.\\n 3. values are in long or Integer.\\n 4. is given array sorted.(even if the example are sorted) this helped me in google interview interviewer told me that this is nice question. (I was not asked this question but a question where sample cases where sorted )\\n \\n now move to solution :\\nSolution 1: Square all the values of the array and now sort the array . \\n                    Time :O(nlogn) and space O(1) \\n\\t\\t\\t\\t\\task then sir/mam that this is one kind of solution should i need to improve time complexity                      or are you fine with it. (if they told to improve then go to O(n) soln)\\n\\t\\t\\t\\t\\t\\nSolution 2: \\t\\t\\t\\t\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if find it helpful love to hear some feedback or any doubt you have in solution.",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        \\n        \\n        int i=0;\\n        int j=A.length-1;\\n        int k=A.length-1;\\n        int[] ans=new int[A.length];\\n        \\n        while(i<=j){\\n            int val1=Math.abs(A[i]);\\n            int val2=Math.abs(A[j]);\\n             \\n            if(val2>val1){\\n                val2=val2*val2;\\n                ans[k]=val2;\\n                k--;\\n                j--;\\n            }else{\\n                val1=val1*val1;\\n                ans[k]=val1;\\n                k--;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325435,
                "title": "short-java-solution-1ms-beat-100-40-3mb",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int res[] = new int[A.length];\\n        int i = 0;\\n        int k = A.length - 1;\\n        int z = A.length - 1;\\n        while(z >= 0){ \\n            res[z--] = Math.abs(A[i]) > Math.abs(A[k]) ? A[i] * A[i++] : A[k] * A[k--];\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 286050,
                "title": "java-100-rt",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int i = 0, j = A.length -1, k=j;\\n        int[] B = new int[A.length];\\n        while(k>=0){\\n            int x = A[i]*A[i], y = A[j]*A[j];\\n            if(x >= y){\\n                B[k] = x;\\n                i++;\\n            } else{\\n                B[k] = y;\\n                j--;\\n            }\\n\\t\\t\\tk--;\\n        }\\n        return B;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226530,
                "title": "javascript-o-n-solution-w-explanation-11-lines-no-arrays-sort",
                "content": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```\\n\\nUsing the given, we know that the array is already in sorted order. \\nThis tells us:\\n1. The next largest square will be on either end of the array.\\n2. We can use two pointers starting on each end to find the largest square then append it to our result. We move the pointer that held the larger square.\\n3. Once our pointers have crossed we have covered every value in the original array and can return our result array.\\n\\nNote: *Instead of using the unshift() function I have decided to use push and then reversing the whole array because unshift is a costly function that has to move all of the elements of the array.*\\n\\n```\\nvar sortedSquares = function(A) {\\n    let res = [];\\n    let up = 0, down = A.length-1;\\n    \\n    let a = A[up]*A[up];\\n    let b = A[down]*A[down];\\n    \\n    while (up <= down) {\\n        if (a > b) {\\n            res.push(a);\\n            up++;\\n            a = A[up]*A[up];\\n        } else {\\n            res.push(b);\\n            down--;\\n            b = A[down]*A[down];\\n        }\\n    }\\n    \\n    return res.reverse();\\n};",
                "solutionTags": [],
                "code": "```Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663563,
                "title": "2-javascript-solutions-with-explanations",
                "content": "There\\'s at least 2 ways which we can solve this problem:\\n\\n1. As the question suggests, it\\'s easy to map through our input, square each number and then sort the output.\\n\\n```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\\n\\nThis would result in an algorithm that is `O(n log n)` due to the underlying quicksort and requires constant `O(log n)` space.\\n\\n2. We could instead take advantage of the property of the array being sorted and instead create an output array and 2 pointers that will increment/decrement depending on the result of the squaring of each and comparing them.\\n\\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```\\n\\nThis results in an algorithm that requires `O(n)` time as traverse our entire input array and `O(n)` space as our created array is dependent on the size of our input.\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nreturn nums\\n        .map(num => Math.pow(num, 2))\\n        .sort((numOne, numTwo) => numOne - numTwo);\\n```\n```\\nconst sortedSquares = nums => {\\n    const sorted = new Array(nums.length);\\n    \\n    let start = 0;\\n    let end = sorted.length - 1;\\n    \\n    for (let insert = end; insert >= 0; insert--) {\\n        const squaredStart = Math.pow(nums[start], 2);\\n        const squaredEnd = Math.pow(nums[end], 2);\\n        \\n        if (squaredStart > squaredEnd) {\\n            sorted[insert] = squaredStart;\\n            start++;\\n        } else {\\n            sorted[insert] = squaredEnd;\\n            end--;\\n        }\\n    }\\n    \\n    return sorted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596760,
                "title": "easy-c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nIf you like the solution then please upvote. Open to queries.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        vector<int> res(nums.size());\\n        int l = 0, r = nums.size() - 1;\\n        \\n        for (int k = nums.size() - 1; k >= 0; k--) {\\n            \\n            if (abs(nums[r]) > abs(nums[l])) \\n                res[k] = nums[r] * nums[r--];\\n            else \\n                res[k] = nums[l] * nums[l++];\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472964,
                "title": "commented-rust-o-n-beats-99",
                "content": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {\\n        // The code works without this, but it removes a\\n        // lot of useless allocations for a base case\\n        if nums.len() == 1 {\\n            return vec![i32::pow(nums[0], 2)];\\n        }\\n        \\n        // We\\'ll use this for inserting later\\n        let mut location = nums.len();\\n        \\n        // Pre-allocate so we can start indexing from the end\\n        let mut output = vec![0; location];\\n        \\n        // These are our markers for the 2 ends of the array\\n        let mut left = 0 as usize;\\n        let mut right = nums.len() - 1;\\n        \\n        // We\\'re only going to compute each value once\\n        let mut computed_left = i32::pow(nums[left], 2);\\n        let mut computed_right = i32::pow(nums[right], 2);\\n        \\n        while left != right {\\n            // Every loop we\\'re moving one spot further to the left\\n            location-=1;\\n            // Every loop iteration we check which value is larger and\\n            // put that at the end of the output vector that we pre-allocated\\n            if computed_left > computed_right {\\n                output[location] = computed_left;\\n                left+=1;\\n                computed_left = i32::pow(nums[left], 2);\\n            } else {\\n                output[location] = computed_right;\\n                right-=1;\\n                computed_right = i32::pow(nums[right], 2);\\n            }\\n        }\\n        // Could do either one, because at this point they should be the\\n        // same index / value\\n        output[0] = computed_right;\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217913,
                "title": "c-two-pointers",
                "content": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n**1st approach :** 1) Take the squares of each element and store it.\\n                                2) Then finally sort the vector and return it.\\n                                3) T.C - O(NlogN)\\n **2 approach :** Take two pointers at either ends of array.\\n                              Check abs value of both the elements and fill \\n\\t\\t\\t\\t\\t\\t\\t  the array backwards bcoz largest value will be at last\\n\\n\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\t\\t\\t\\t\\t\\t\\tvector<int>ans(nums.size());\\n\\t\\t\\t\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t\\t\\t\\tint j=nums.size()-1;\\n\\t\\t\\t\\t\\t\\t\\tfor(int k=nums.size()-1;k>=0;k--)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(abs(nums[i]) < abs(nums[j]))\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[j]*nums[j];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   j--;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ans[k] = nums[i]*nums[i];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i++;\\n\\t\\t\\t\\t\\t\\t\\t\\t   }\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t   return ans;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3834119,
                "title": "most-optimal-code-clean-code-explanation-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The problem which can be solved using inbuilt sorting function, but we need to execute this in O(n).\\n- We\\'ll be dealing with two pointers with NO DOUBT.\\n- Let\\'s point to end and and start.\\n- The one which is greater put at the end.\\n- And decrement the pointer of ans vector.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int i=0,j=nums.size()-1, k=nums.size()-1;\\n        vector<int>v(nums.size(),0);\\n        while(i<=j)\\n        {\\n            if(abs(nums[i])>=abs(nums[j]))\\n             v[k--]=(pow(nums[i++],2));\\n            \\n            else v[k--]=(pow(nums[j--],2));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123725,
                "title": "c-3-line-sol-must-watch-2023-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& v) {\\n        for_each(v.begin(),v.end(),[](int &x){x*=x;});\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868051,
                "title": "java-optimized-easy",
                "content": "## **Please Upvote if you understood this** (\\uFF5E\\uFFE3\\u25BD\\uFFE3)\\uFF5E\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n//         for(int i=0;i<nums.length;i++) nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n//         return nums;\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int index = end;\\n        int[] res = new int[nums.length];\\n        while(start<=end){\\n            if(Math.abs(nums[start])>Math.abs(nums[end])){\\n                res[index--]=nums[start]*nums[start];\\n                start++;\\n            }\\n            else{\\n                res[index--]=nums[end]*nums[end];\\n                end--;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763243,
                "title": "java-without-sorting-one-pass-solution-o-n",
                "content": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int n=nums.length,i=0,j,x=0;\\n        int a[] = new int[n];     \\n        while(i<n && nums[i]<0)\\n            i++;\\n        j=i-1;\\n        while(j>=0 && i<n)\\n        {\\n            if(nums[i] < -nums[j])\\n                a[x++]=nums[i]*nums[i++];\\n            else\\n                a[x++]=nums[j]*nums[j--];\\n        }\\n        while(j>=0)\\n            a[x++]=nums[j]*nums[j--];\\n        while(i<n)\\n            a[x++]=nums[i]*nums[i++];\\n        //Arrays.sort(nums);\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681614,
                "title": "swift-two-pointers-o-n",
                "content": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```swift\\nfunc sortedSquares(_ nums: [Int]) -> [Int] {\\n    var right = nums.count - 1\\n    var left = 0\\n    \\n    var result = nums\\n    var index = right\\n    while index >= 0 {\\n        if abs(nums[left]) < abs(nums[right]) {\\n            result[index] = nums[right] * nums[right]\\n            right -= 1\\n        } else {\\n            result[index] = nums[left] * nums[left]\\n            left += 1\\n        }\\n        index -= 1\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592437,
                "title": "python-two-pointer-approach",
                "content": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\\n\\n\\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# Two pointer approach\\nclass Solution(object):\\n    def sortedsquares(self, nums):\\n        result = [None for _ in nums]\\n        left, right = 0, len(nums)-1\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                result[i] = nums[left] ** 2\\n                left += 1\\n            else:\\n                result[i] = nums[right] ** 2\\n                right -= 1\\n        return result\\n```\n```\\n# one liner solution:\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        return sorted ([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422991,
                "title": "java-two-pointer-approach-o-n-faster-than-100",
                "content": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        if (nums == null || nums.length == 0) return nums;\\n        \\n        int len = nums.length;\\n        \\n        int result[] = new int[len];\\n        int firstPtr = 0, lastPtr = len-1;\\n        int k = len - 1;\\n        while (k >= 0) {\\n            int firstSq = nums[firstPtr] * nums[firstPtr];\\n            int lastSq = nums[lastPtr] * nums[lastPtr];\\n            \\n            if (firstSq >= lastSq) {\\n                result[k] = firstSq;\\n                firstPtr++;\\n            } else {\\n                result[k] = lastSq;\\n                lastPtr--;\\n            }\\n            \\n            k--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763982,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize)\\n{\\n    int* res = (int *)malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *pos = A + ASize - 1, *neg = A, k = ASize - 1;\\n    while (pos != neg - 1)\\n    {\\n        if (*pos >= abs(*neg))\\n        {\\n            res[k] = (*pos) * (*pos);\\n            k--;\\n            pos--;\\n        }\\n        else\\n        {\\n            res[k] = (*neg) * (*neg);\\n            k--;\\n            neg++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235219,
                "title": "runtime-error",
                "content": "When I execute the code follows, the error info showed like this.\\nFinished in N/A\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==29==ERROR: AddressSanitizer: SEGV on unknown address 0x180a7fff8012 (pc 0x0000004121a3 bp 0x7ffdc83ec450 sp 0x7ffdc83ec080 T0)\\n==29==The signal is caused by a READ memory access.\\n    #3 0x7fccfd9322e0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202e0)\\n\\nAddressSanitizer can not provide additional info.\\n==29==ABORTING\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        int left = 0;\\n        int right = A.size()-1;\\n        vector <int> ans;\\n        for(int j=A.size()-1;j>=0;j--){\\n            if(A[left]*A[left]>A[right]*A[right]){\\n                ans.insert(A.begin()+j,A[left]*A[left]);\\n                left++;\\n            }\\n            else{\\n                ans.insert(A.begin()+j,A[right]*A[right]);\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222278,
                "title": "java-3-lines-o-n-time",
                "content": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortedSquares(int[] A) {\\n        int[] r = new int[A.length];\\n        for(int d=A.length-1,u=0,i=d; i>=0; i--) r[i] = -A[u]>A[d] ? A[u]*A[u++] : A[d]*A[d--];\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101079,
                "title": "1ms-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] array = new int[nums.length];\\n        int i = 0;\\n        int j = nums.length-1;\\n        int k = nums.length-1;\\n        while(i<=j){\\n            int val1 = nums[i]*nums[i];\\n            int val2 = nums[j]*nums[j];\\n            if(val1 > val2){\\n                array[k] = val1;\\n                i++;\\n            }else{\\n                array[k] = val2;\\n                j--;\\n            }\\n            k--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796230,
                "title": "2ms-solution-fully-explained-two-pointers-o-n-java",
                "content": "# Approach : Two Pointers Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Request \\uD83D\\uDE4F\\uD83D\\uDE4F:\\n- If you find this solution easy to understand and helpful.\\nThen please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code (Explained in comments below \\uD83D\\uDC47\\uD83D\\uDC47)\\n```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortedSquares(int[] nums) \\n    {\\n        int i=0;//pointer 1\\n        int j=nums.length-1;//pointer 2\\n        int[] arr=new int[nums.length];//new array to store sorted squares\\n        int l=nums.length-1;//index variable\\n        while(i<=j)// Create a loop until i is less than j\\n        {\\n            int sq1=nums[i]*nums[i];//square of pointer 1\\n            int sq2=nums[j]*nums[j];//square of pointer 2\\n            if(sq1<sq2)//if 1st element is smaller than last element\\n            {\\n                arr[l--]=sq2;//storing maximum value at last index\\n                j--;\\n            }\\n            else//if 1st element is greater than last element\\n            {\\n                arr[l--]=sq1;//storing minimum value at first index\\n                i++;\\n            }\\n\\n        }return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720654,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int n = A.length;\\n        int[] result = new int[n];\\n        int i = 0, j = n - 1;\\n        for (int p = n - 1; p >= 0; p--) {\\n            if (Math.abs(A[i]) > Math.abs(A[j])) {\\n                result[p] = A[i] * A[i];\\n                i++;\\n            } else {\\n                result[p] = A[j] * A[j];\\n                j--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254389,
                "title": "3-approaches-clean-and-concise-code-two-pointers-c",
                "content": "Here, I will be discussing 3 approaches to this problem.\\n\\n**Approach 1: Using Sorting**\\n\\nThe simplest solution would be just using built-in sort function and you can say it would work by squaring the elements in-place (over-writing) them and finally sorting it.\\n\\n```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\\n\\n**Time Complexity: O(nlogn)**\\n**Space Complexity: O(1)**\\n\\n\\n**Approach 2: Two Pointers - 1**\\n\\nLet\\'s take an example with negative and positive numbers, like:\\n\\n[-4, -2, 0, 1, 3]\\n\\nSince, we need to put squares in result array, we can consider that all numbers are positive (since: -4 ** 2 = 4 ** 2 = 16). Now our array looks like it sorted from middle to outside on both sides:\\n\\n[4, 2, 0, 1, 3]\\n\\nNow, we can have two pointers \"left\" to left most element, \"right\" to the right most element.\\nCreate \"res\" result array with the same size as A.\\nMove from right to left in res and check max(abs(A[l]), abs(A[r])), then correspondingly move left++ or right--.\\n\\n\\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Approach 3: Two Pointers - 2**\\nFirstly, why another two pointers approach? \\n\\nWell, after a bit of thinking you may notice that after squaring numbers, firstly, all negative numbers which are big would go further away from zero and negative numbers smaller relatively would meet at zero with the positive numbers.\\n\\nNow, the same goes with the case of positive numbers squared. Thus, it is a natural solution of merging two sorted lists from the middle will do. Just use two pointers that go from the middle outwards. This is intutitive and really easy to undertsand.\\n\\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```\\n**Time Complexity: O(n)**\\n**Space Complexity: O(n)**\\n\\n**Please upvote this solution if you liked it! \\uD83D\\uDE00\\u270C\\uFE0F**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tint n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=pow(nums[i],2);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n```\n```\\n\\t\\tint n=nums.size();\\n        vector<int> res(n);\\n        int left=0;\\n        int right=n-1;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(abs(nums[left])>abs(nums[right])) res[i]=nums[left]*nums[left++];\\n            else res[i]=nums[right]*nums[right--];\\n        }\\n        return res;\\n```\n```\\n\\t\\t//Two Pointers-2\\n        int n=nums.size();\\n        vector<int> res(n);\\n        int p=0;\\n        while(p<n && nums[p]<0) p++;\\n        int neg=p-1;\\n        int i;\\n        for(i=0;neg>=0 && p<n;i++)\\n        {\\n            if(nums[neg]*nums[neg]<nums[p]*nums[p]) res[i]=nums[neg]*nums[neg--];\\n            else res[i]=nums[p]*nums[p++];\\n        }\\n\\t\\t//For leftover positive elements\\n        for(;p<n;i++)\\n            res[i]=nums[p]*nums[p++];\\n\\t\\t\\n\\t\\t//For leftover negative elements\\n        for(;neg>=0;i++)\\n            res[i]=nums[neg]*nums[neg--];\\n        \\n\\t\\treturn res;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2013937,
                "title": "two-pointers-and-one-liner-approach-python",
                "content": "**One Liner Approach**\\n```\\nreturn sorted(i*i for i in nums)\\n```\\n\\n**Two Pointers Approach**\\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nreturn sorted(i*i for i in nums)\\n```\n```\\n        n = len(nums)\\n        result = [0] * n\\n        left = 0\\n        right = n - 1\\n        for i in range(n - 1, -1, -1):\\n            if abs(nums[left]) < abs(nums[right]):\\n                square = nums[right]\\n                right -= 1\\n            else:\\n                square = nums[left]\\n                left += 1\\n            result[i] = square * square\\n        return result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791585,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 329 ms, faster than 46.92% of Python3 online submissions for Squares of a Sorted Array.\\n# Memory Usage: 16.3 MB, less than 40.77% of Python3 online submissions for Squares of a Sorted Array.\\nclass Solution:\\n    def sortedSquares(self, nums):\\n        i, j, n = 0, len(nums)-1, len(nums)-1\\n        result = [0 for _ in range(len(nums))]\\n        while n>=0:\\n            if abs(nums[i])>abs(nums[j]):\\n                result[n] = nums[i]**2\\n                i += 1\\n            else:\\n                result[n] = nums[j]**2\\n                j -= 1\\n            n -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701883,
                "title": "easy-to-understand-solution-with-comments-explaination",
                "content": "If this solution helps please consider upvoting\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n//         This takes O(N) time\\n//         declare a new vector\\n        vector<int> res(nums.size());\\n//         two pointer taken for sorting\\n        int left=0,right=nums.size()-1;\\n//         start from the last \\n        for(int i =nums.size()-1;i>=0;i--){\\n//             used abs because we know array is sorted to all negative numbers will be on the left\\n            if(abs(nums[left])>nums[right]){\\n                res[i]=nums[left]*nums[left];\\n                left++;\\n            }\\n//             else we add the last element\\n            else{\\n                res[i]=nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678024,
                "title": "python-o-n-solution",
                "content": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef sortedSquares(self, nums: List[int]) -> List[int]:\\n        lowIndex=0\\n        highIndex=len(nums)-1\\n        Index=len(nums)-1\\n        a=[0]*len(nums)\\n        while(lowIndex<=highIndex):\\n            if(abs(nums[lowIndex])>=abs(nums[highIndex])):\\n                a[Index]=nums[lowIndex]*nums[lowIndex]\\n                lowIndex+=1\\n            else:\\n                a[Index]=nums[highIndex]*nums[highIndex]\\n                highIndex-=1\\n            Index-=1\\n        return a\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1627809,
                "title": "simple-java-solution-o-n-time",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }\\n            else{\\n                res[k]=nums[r]*nums[r];\\n                r--;\\n            }\\n            k--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\n    public int[] sortedSquares(int[] nums) {\\n        int l=0,r=nums.length-1,k=r;\\n        int[] res = new int[nums.length];\\n        while(l<=r){\\n            if(Math.abs(nums[l])>Math.abs(nums[r])){\\n                res[k]=nums[l]*nums[l];\\n                l++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1413346,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1: Sorting Approach**\\n\\n**Algorithm**:\\n1. Create an array of the squares of each element\\n1. Sort the array of squares.\\n\\n**Time Complexity**: `O(N log N)`, where `N` is the length of input array.\\n**Space complexity**: `O(log N)` In Java, the Arrays.sort() is implemented as a variant of quicksort algorithm whose space complexity is `O(log N)`.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: Two Pointer Approach**\\n\\n**Intuition**:\\n- Since the array `A` is sorted, loosely speaking it has some negative elements with squares in decreasing order, then some positive elements with squares in increasing order.\\n- For example, with `[-3, -2, -1, 4, 5, 6]`, we have the negative part `[-3, -2, -1]` with squares `[9, 4, 1]`, and the positive part `[4, 5, 6]` with squares `[16, 25, 36]`\\n- Now, this is a variant of merging two sorted arrays.\\n\\n**Algorithm**:\\n1. We can use two pointers, one at each end, to iteratively collect the larger square to the result array.\\n\\n**Time Complexity**: `O(N)`, where `N` is the length of input array.\\n**Space Complexity**: `O(N)` if we consider the space required for result array and `O(1)` otherwise.\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            result[i] = A[i] * A[i];\\n        }\\n        \\n        Arrays.sort(result);\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] A) {\\n        int[] result = new int[A.length];\\n        int start = 0;\\n        int end = A.length - 1;\\n\\n        for (int i = A.length - 1; i >= 0; i--) {\\n            if (Math.abs(A[start]) < Math.abs(A[end])) {\\n                result[i] = A[end] * A[end];\\n                end--;\\n            } else {\\n                result[i] = A[start] * A[start];\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160450,
                "title": "python-stack-o-n-memory-o-n",
                "content": "Traverse the array nums once.\\nFor elements which are negative, just append them to the stack, and once you start encountering non-negative elements, start clearing the stack by comparing current element to last value in stack and then appending the squared value to output accordingly. \\nFinally, if all elements have been seen in nums, start clearing stack by appending squared value to output. \\n\\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        stack = []\\n        output = []\\n        for i in range(len(nums)):\\n            if nums[i] < 0:\\n                stack.append(-nums[i])\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    output.append(stack.pop() ** 2)\\n                output.append(nums[i] ** 2)\\n        while stack:\\n            output.append(stack.pop() ** 2)\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088214,
                "title": "kotlin-simple",
                "content": "Two pointers approach:\\n```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\\n\\nNaive approach:\\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        val arr = IntArray(nums.size)\\n        var l = 0\\n        var r = nums.lastIndex\\n        var i = arr.lastIndex\\n        while (l <= r) {\\n            if (nums[l] * nums[l] > nums[r] * nums[r]) {\\n                arr[i] = nums[l] * nums[l]\\n                l++\\n            } else {\\n                arr[i] = nums[r] * nums[r]\\n                r--\\n            }\\n            i--\\n        }\\n        arr[0] = nums[l] * nums[l]\\n\\n        return arr\\n    }\\n```\n```\\nfun sortedSquares(nums: IntArray) = nums.map { it * it }.sorted().toIntArray()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 973317,
                "title": "c-two-pointers-moving-from-both-ends",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        const int n = nums.size();\\n        vector<int> ans(n);\\n        int l = 0, r = n - 1, idx = n - 1;\\n        while(l<=r){\\n            if(nums[l]*nums[l] < nums[r] * nums[r]){\\n                ans[idx--] = nums[r] * nums[r];\\n                r--;\\n            }else{\\n                ans[idx--] = nums[l] * nums[l];\\n                l++;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972966,
                "title": "squares-of-a-sorted-array-java-o-n-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length, i= 0, j = n-1, idx = n-1;\\n        \\n        int[] ans = new int[n];\\n        \\n        while(idx >= 0){\\n            if(Math.abs(nums[i]) > Math.abs(nums[j])){\\n                ans[idx] = nums[i]*nums[i];\\n                i++;\\n            }else{\\n                ans[idx] = nums[j]*nums[j];\\n                j--;\\n            } \\n            idx--;\\n        }\\n        \\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763999,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> sortedSquares(vector<int>& A)\\n\\t{\\n        vector<int> res;\\n        int i_negative, i_positive;\\n        \\n        for (i_positive = 0; i_positive < A.size() && A[i_positive] < 0; i_positive++);\\n        i_negative = i_positive - 1;\\n        \\n        while (i_negative >= 0 && i_positive < A.size()) \\n\\t\\t{\\n            if (-A[i_negative] <= A[i_positive])\\n                res.push_back(pow(A[i_negative--], 2));\\n            else\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        \\n        if (res.size() < A.size()) \\n\\t\\t{\\n            while (i_negative >= 0)\\n                res.push_back(pow(A[i_negative--], 2));\\n            while (i_positive < A.size())\\n                res.push_back(pow(A[i_positive++], 2));\\n        }\\n        return res;\\n    }\\n};\\n\\nstatic auto _______ = []()\\n{\\n    // turn off sync\\n    std::ios::sync_with_stdio(false);\\n    // untie in/out streams\\n    std::cin.tie(nullptr);\\n    return 0;\\n}();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557344,
                "title": "kotlin-o-n-95-time-100-space",
                "content": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun sortedSquares(A: IntArray): IntArray {\\n        \\n        // Create markers to use to navigate inward since we know that\\n        // the polar ends are (possibly, but not always) the largest\\n        var leftMarker = 0\\n        var rightMarker = A.size - 1\\n        \\n        // Create a marker to track insertions into the new array\\n        var resultIndex = A.size - 1\\n        val result = IntArray(A.size)\\n        \\n        // Iterate over the items until the markers reach each other.\\n        // Its likely a little faster to consider the case where the left\\n        // marker is no longer producing elements that are less than zero.\\n        while (leftMarker <= rightMarker) {\\n            // Grab the absolute values of the elements at the respective\\n            // markers so they can be compared and inserted into the right\\n            // index.\\n            val left = Math.abs(A[leftMarker])\\n            val right = Math.abs(A[rightMarker])\\n            \\n            // Do checks to decide which item to insert next.\\n            result[resultIndex] = if (right > left) {\\n                rightMarker--\\n                right * right\\n            } else {\\n                leftMarker++\\n                left * left\\n            }\\n            \\n            // Once the item is inserted we can update the index we want\\n            // to insert at next.\\n            resultIndex--\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520334,
                "title": "javascript-two-pointers-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortedSquares = function(A) {\\n    if (A.length < 2) // Early exit if the array only has less than two element.\\n        return [ Math.pow(A[0], 2) ];\\n    \\n    const newArray = [];\\n    let i = 0;\\n    let j = A.length - 1;\\n    \\n    while (i <= j) {\\n        const left = Math.pow(A[i], 2); // Square the number to obtain positive value. e.g. -2**2 = 4\\n        const right = Math.pow(A[j], 2); // Square the number to obtain positive value. e.g. 4**2 = 16\\n         \\n        if (left >= right) { // If left is bigger or equal than the right add that as the first position of the array\\n            newArray.unshift(left);\\n            i++;\\n        } else { // If the right is bigger than the left add that as the first position of the array\\n            newArray.unshift(right);\\n            j--;\\n        }\\n    } // It will traverse the array only once, since if you combine i and j the two pointers will meet in a middle point,\\n    \\n    return newArray;\\n    \\n    /**\\n    * Use two pointers to compare each end since we know that they are the highest numbers when squared.\\n    * Time Complexity: O(n)\\n    * Space Complexity: O(n)\\n    **/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359123,
                "title": "golang-solution",
                "content": "when see sorted   we usually thought two pointer\\n```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortedSquares(A []int) []int {\\n\\tret := make([]int, len(A))\\n\\tleft, right := 0, len(A)-1\\n\\tfor i := len(A)-1; i >= 0; i-- {\\n        if math.Abs(float64(A[left])) < math.Abs(float64(A[right])) {\\n\\t\\t\\tret[i] = A[right] * A[right]\\n            right--\\n\\t\\t} else {\\n\\t\\t\\tret[i] = A[left] * A[left]\\n            left++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226469,
                "title": "go-two-pointers-without-finding-first-positive-number",
                "content": "The idea is than we can go down from both ends and collecting result array in descending order.\\n\\n```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc sortedSquares(A []int) []int {\\n    length := len(A)\\n    res := make([]int, length)\\n    i, j := 0, length - 1\\n    \\n    for z := length - 1; z >= 0; z-- {\\n        sq1, sq2 := A[i]*A[i], A[j]* A[j]\\n        \\n        if sq1 > sq2 {\\n            res[z] = sq1\\n            i++\\n        } else {\\n            res[z] = sq2\\n            j--\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224554,
                "title": "c-1-line",
                "content": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SortedSquares(int[] A) {\\n        return A.Select(a => a * a).OrderBy(b => b).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243882,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129573,
                "title": "tc-o-n-sc-o-1-two-pointer-approach-easy-understanding-beats-90-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Only focusing on Mangnitude for -ve numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int> ans;\\n       int i=-1,j=0;\\n       for(int k=0;k<nums.size();k++){\\n           if(nums[k]<0) i=k;\\n       }\\n       j=i+1;\\n        \\n        while(i>=0 && j<nums.size()){\\n            if(-1*nums[i]>=nums[j]){\\n                ans.push_back(nums[j]*nums[j]); j++;\\n            }\\n            else {\\n                ans.push_back(nums[i]*nums[i]); i--;\\n            }\\n        }\\n        while(j<nums.size()){\\n            ans.push_back(nums[j]*nums[j]); j++;\\n        }\\n        while(i>=0){\\n            ans.push_back(nums[i]*nums[i]); i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905692,
                "title": "simple-python3-two-pointer-easy-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two pointers to start from edges of sorted list. Since 0 is the smallest value and we have the potential to have negative and positive numbers that need to be interwoven, we can take advantage of the sorted list by having a left and right (l, r) pointers. Then we can see if the element at l or r has a larger absolute value (which implies larger square value) and fill in res so that it descends in squared value. The idea is to start from the wings of the nums list and center down to 0, which would thus give you a sorted decreasing list of squares. Then since the problem asks for increasing, just reverse the list at the end. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ where $$N$$ is the length of nums. \\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```\\n\\nThanks for taking a look at my solution, and feel free to let me know if I can improve anything :)",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l, r = 0, len(nums)-1\\n        res = []\\n\\n        while l <= r:\\n            if abs(nums[l]) >= abs(nums[r]):\\n                res.append(nums[l] ** 2)\\n                l += 1\\n            else:\\n                res.append(nums[r] ** 2)\\n                r -= 1\\n        return reversed(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319821,
                "title": "python-o-n-solution-explained",
                "content": "#### **Final Code:**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\\n\\n#### **Steps:**\\n* **Step1:**  \\nCreate an empty array to store the squared values.\\n```result = []```\\n\\n* **Step2:**  \\nInitialize our 2 pointers: left and right, and set them equal to the first and last index\\n                      positions of the array.\\n```left, right = 0, len(nums) - 1```\\n\\n* **Step3:** \\nWe can run a while loop and continue till our left pointer is greater than the right pointer.\\nmeaning till they cross each other in the array\\n```while left <= right:```\\n\\n* **Step4:**  \\nIf the square of the number on the right is greater than the square of the left number then\\nappend it to the result array and **decrease** the right pointer \\nOr\\nappend the left square and **increase** the left pointer.\\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\\n* **Step5:**  \\nAfter this we will end up with the result array but it is in descending order.\\nTo make it in ascending order we can just reverse it like:\\n```return result[::-1]```\\n\\n**And we have conquered this problem: Squares of Sorted Array \\uD83E\\uDD13**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        result = []        \\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            \\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n            \\n        return result[::-1]\\n```\n```result = []```\n```left, right = 0, len(nums) - 1```\n```while left <= right:```\n```\\n            if nums[left] ** 2 < nums[right] ** 2:\\n                result.append(nums[right] ** 2)\\n                right -= 1\\n                \\n            else:\\n                result.append(nums[left] ** 2)\\n                left += 1\\n```\n```return result[::-1]```",
                "codeTag": "Java"
            },
            {
                "id": 2123293,
                "title": "c-using-stack",
                "content": "**Using stack :** We are pushing squared (sq) values of elements in stack , push the current sq value if stack top is greater then sq else pop from stack till stack top is greater then the sq and simultaneously put that sq in result (vector). \\n\\n```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```\\t\\nIf you like the solution , do **UPVOTE**.\\nFeel free to ask any doubts in the comment section.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n vector<int> sortedSquares(vector<int>& nums) {\\n        stack<int> st;\\n        vector<int> res;\\n        \\n        for(int i=0 ; i<nums.size() ; i++){\\n            int sq = nums[i] * nums[i];\\n\\t\\t\\t\\n\\t\\t\\t// if sq is less then the top of stack then push sq in the stack\\n            if(st.size() == 0 || st.top() >= sq ){\\n                st.push(sq);\\n            }\\n\\t\\t\\t// else store the top of stack in res and pop from the stack till stack top is greater then the sq\\n            else{\\n                while(st.size() > 0 && st.top() < sq){\\n                    res.push_back(st.top());\\n                    st.pop();     \\n                }\\n                st.push(sq);\\n            }\\n        }\\n\\t\\t// if stack is not empty push all elements in res\\n        while(st.size() > 0){\\n            res.push_back(st.top());\\n            st.pop(); \\n        }\\n        return res;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112476,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        \\n        l, r = 0, n - 1\\n        res = []\\n        while l <= r:\\n            if abs(nums[r]) > abs(nums[l]):\\n                res.append(nums[r] * nums[r])\\n                r -= 1\\n            else:\\n                res.append(nums[l] * nums[l])\\n                l += 1\\n                \\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083247,
                "title": "java-two-pointers",
                "content": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\\'\\'\\'\\n\\n\\t\\tint i=0,j=nums.length-1;\\n        int[] ans=new int[nums.length];\\n        for(int k=nums.length-1;k>=0;k--)\\n        {\\n            if(Math.abs(nums[i])>Math.abs(nums[j]))\\n            {\\n                ans[k]=(int)Math.pow(nums[i],2);\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k]=(int)Math.pow(nums[j],2);\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1934797,
                "title": "my-java-o-n-solution-beats-100-submissions",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        int i=0,j=nums.length-1;\\n        for (int k=sol.length-1;k>=0;k--){\\n            if (Math.abs(nums[i])>Math.abs(nums[j])){\\n                sol[k] = nums[i]*nums[i];\\n                i++;\\n            }else {\\n                sol[k] = nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882625,
                "title": "python3-two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        start,end = 0, len(nums)-1\\n        result  = [0] * (end+1)\\n        index = end\\n        while index>=0:\\n            startElementSquare, endElementSquare = nums[start]**2, nums[end]**2\\n            if(endElementSquare > startElementSquare):\\n                result[index] = endElementSquare\\n                end -= 1\\n            else:\\n                result[index] = startElementSquare\\n                start+=1\\n            index-=1\\n        return result\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877413,
                "title": "javascript-two-pointers-clean-and-simple",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    const squreSorted = new Array(nums.length); // define empty array\\n \\n    \\n    let leftIndx = 0; // left pointer\\n    let rightIndx = nums.length - 1; // right pointer\\n    \\n    let pointer = nums.length; // point to last empty squreSorted index\\n    \\n    while(pointer){\\n        pointer--;\\n        \\n        let leftValue = nums[leftIndx] ** 2;\\n        let rightValue = nums[rightIndx] ** 2;\\n        \\n        if(leftValue > rightValue) \\n        {\\n            squreSorted[pointer] = leftValue;\\n            leftIndx++;\\n        }\\n        else{ \\n            squreSorted[pointer] = rightValue;\\n            rightIndx--;\\n        }\\n    }\\n    \\n    return squreSorted\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850495,
                "title": "javascript-solution",
                "content": "Runtime: 88 ms, faster than 99.30% of JavaScript online submissions for Squares of a Sorted Array.\\nMemory Usage: 49.3 MB, less than 10.82% of JavaScript online submissions for Squares of a Sorted Array.\\n```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar sortedSquares = function(nums) {\\n    let arr = [];\\n    let start = 0;\\n    let end = nums.length -1;\\n    \\n    while(start <= end){\\n        if(nums[start] **2 > nums[end] **2){\\n            arr.push(nums[start] **2);\\n            start++;\\n        } else {\\n            arr.push(nums[end] **2);\\n            end--;\\n        }\\n    }\\n    return arr.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1781273,
                "title": "java-brute-o-nlogn-better-o-n-both-explained",
                "content": "**1. First approach is to iterate and update with its square. And then Sort the array and return.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\\n\\n**2. Second approach is to use of two pointer and take whichever (abs) is greater and update it in new array. Iterate until new array become updated.**\\n\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        int i=0,j=nums.length-1,k=nums.length-1;\\n        while(k>=0){\\n            if(Math.abs(nums[i])>=Math.abs(nums[j])){\\n                arr[k]=nums[i]*nums[i];\\n                i++;\\n            }\\n            else{\\n                arr[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708128,
                "title": "javascript-radix-sort-o-n-time-o-1-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```\\n\\nThis solution is using radix sort which has a time complexity of O(kN). However, there are specific applications where if k is small enough that Radix Sort will exhibit linear-time performance in practice. Counting sort should also exhibit O(n) time complexity for the same reasons.\\n\\nIt is also using O(1) space complexity.\\n\\nYou can learn more about Radix sort here: http://en.wikipedia.org/wiki/Radix_sort",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n\\nfunction getDigit(number, place) {\\n    return Math.floor(Math.abs(number) / Math.pow(10, place)) % 10;\\n}\\n\\nfunction getDigitCount(number) {\\n    return number === 0\\n        ? number\\n        : Math.floor(Math.log10(Math.abs(number))) + 1;\\n}\\n\\nfunction getHighestDigitCount(numbers) {\\n    return Math.max(...numbers.map(n => getDigitCount(n)));\\n}\\n\\nfunction radixSort(numbers) {\\n    const maxDigitCount = getHighestDigitCount(numbers);\\n\\n    let numArr = [];\\n\\n    for(let i = 0; i < maxDigitCount; i++) {\\n\\n        for(let j = 0; j < numbers.length; j++) {\\n            let digit = getDigit(numbers[j], i);\\n            if(numArr[digit] === undefined) {\\n                numArr[digit] = [numbers[j]];\\n            } else {\\n                numArr[digit].push(numbers[j]);\\n            }\\n        }\\n\\n        numbers = numArr.flat(1);\\n        numArr = [];\\n    }\\n\\n    return numbers;\\n}\\n\\nvar sortedSquares = function(nums) {\\n    for(let i = 0; i < nums.length; i++) {\\n        nums[i] = Math.abs(nums[i] ** 2);\\n    }\\n    return radixSort(nums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1707363,
                "title": "c-cpp-different-stl-implementation",
                "content": "Tried this to make this solution nearly 100% fast, Ended up 95% Faster\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for_each(nums.begin(),nums.end(),[](int& a){a=a*a;});\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670332,
                "title": "java-with-explanation-two-pointers-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\\n\\n# Explanation \\n\\nWhen squaring an integer, its sign doesn\\'t matter: the answer is always the same. This means that in our array of negative and positive integers, the largest squares are located towards both ends of the array. \\n\\nThe idea behind my code is getting the bigger number from either ends of the array using what\\'s called the **two-pointer** technique. \\n\\n### Code run-through: \\n\\n1. Initiliaze your variables. \\n\\ta. `start` points to the first index of your array while `end` is the last.\\n\\tb. `squares` is where you would store your sorted squares. \\n\\tc. `j` is used populate your `squares` array; it starts from the end of the array (`nums.length - 1`) since you\\'d be populating it with the biggest elements first. \\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\\n\\n2. The next part is the meat of the code. \\n\\ta. The `while-loop` goes through all the elements in `nums` until the `start <= end` (you\\'ll see why). \\n\\tb. The `if-else` statement checks which of the either indices has the bigger **absolute** value. \\n\\tc. If `nums[start]` is bigger than `nums[end]`, then we set `squares[j]` to the square of`nums[start]`; then increment `start` by 1. \\n\\t\\td. Else, we set we set `squares[j]` to the square of`nums[end]`; then decrement `end` by 1.\\n\\t\\te. Finally, decrement `j` by 1. \\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```\\n\\n### Run-time Analysis:\\n\\nSince we only loop through the array once, we have a linear runtime O(n). \\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        int[] squares = new int[nums.length];\\n\\t\\t\\n        int j = nums.length - 1;\\n        \\n        while (start <= end) {\\n            if (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n                squares[j] = nums[start] * nums[start];\\n                start++;\\n            } else {\\n                squares[j] = nums[end] * nums[end];\\n                end--;\\n            }\\n            j--;\\n        }\\n        \\n        return squares;\\n    }\\n}\\n```\n```\\nint start = 0;\\nint end = nums.length - 1;\\nint[] squares = new int[nums.length];\\n\\nint j = nums.length - 1;\\n```\n```\\nwhile (start <= end) {\\n\\tif (Math.abs(nums[start]) > Math.abs(nums[end])) {\\n\\t\\tsquares[j] = nums[start] * nums[start];\\n\\t\\tstart++;\\n\\t} else {\\n\\t\\tsquares[j] = nums[end] * nums[end];\\n\\t\\tend--;\\n\\t}\\n\\tj--;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594612,
                "title": "java-o-n-time-complexity-easy-solution",
                "content": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\nBrute force Approach\\nTime Complexity - O(n + nlogn)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0;\\n        for(int num: nums){\\n            result[i++] = num*num;\\n        }\\n        Arrays.sort(result);\\n        return result;\\n    }\\n\\nApproach no. 2\\nTime Complexity - O(n)\\nSpace Complexity - O(n)\\npublic int[] sortedSquares(int[] nums) {\\n        int[] result = new int[nums.length];\\n        int i = 0, j= nums.length-1, k = nums.length-1;\\n        while(i<=j && k>=0){\\n            if(nums[i]*nums[i] < nums[j]*nums[j]){\\n                result[k] = nums[j]*nums[j];\\n                j--;\\n            }else{\\n                result[k] = nums[i]*nums[i];\\n                i++;\\n            }\\n            k--;\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1498777,
                "title": "java-solution-2ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[ncur] * nums[ncur];\\n\\t\\t\\t\\t\\t\\tncur--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\treturn square;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[] sortedSquares(int[] nums) {\\n \\n\\t\\t\\tint[] square = new int[nums.length];\\n\\t\\t\\tint pcur = 0 ;\\n\\t\\t\\tint ncur = nums.length-1;\\n\\n\\t\\t\\tfor(int i = nums.length-1; i >= 0; i--){\\n\\t\\t\\t\\tif(nums[pcur]* nums[pcur] > nums[ncur] * nums[ncur]){\\n\\t\\t\\t\\t\\t\\tsquare[i] = nums[pcur] * nums[pcur];\\n\\t\\t\\t\\t\\t\\tpcur++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1483326,
                "title": "c-no-sorting-simple-solution",
                "content": "**Please Upvote if it helped You !!!\\nHappy Coding :)**\\n```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) \\n    {\\n        vector<int> answer(nums.size());\\n        int left=0;\\n        int right=nums.size()-1;\\n        for(int i=right;i>=0;i--)\\n        {\\n            if(abs(nums[right]) > abs(nums[left]))\\n            {\\n                answer[i]=nums[right] * nums[right];\\n                right--;\\n            }\\n            else \\n            {\\n                answer[i]=nums[left] * nums[left];\\n                left++;\\n            }\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439593,
                "title": "javascript-o-n-time-o-1-space-simple-easy-to-understand-solution",
                "content": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n// ! O(1) space complexity when not considering the result array as extra space, otherwise O(n) space complexity\\n\\nvar sortedSquares = function(nums) {\\n  let li = 0, ri = nums.length - 1, result = [];\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    let left = Math.abs(nums[li]), right = Math.abs(nums[ri]);\\n\\n    if (left <= right) { result[i] = right * right; ri--; }\\n    else if (left > right) { result[i] = left * left; li++; }\\n  }\\n\\n  return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411602,
                "title": "two-pointers-c-simple-solution-o-n",
                "content": "***Please upvote if you find this useful***\\n\\nWe take another vector ```result``` of the same size as vector ```nums``` to store the new array, containing the sqaures in sorted order.\\n\\nWe then take two pointers ```start``` and ```end``` pointing to the first and last index of the ```nums``` vector. \\nWe also take another pointer ```i``` which points at last index of our new vector ```result```\\n\\nThen, we compare that whether, the squared value of the first index or the squared value of last index is higher. Whichever is higher, we put that value in the last index of our ```result``` vector. We run the loop and traverse ```nums``` till ```start``` pointer is less than or equal to ```end``` pointer. \\n\\n*Intuition: * If you carefully notice, you will see that the first element and the last element of the ```nums``` vector has the potential of giving the largest squared number. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        vector<int> result(nums.size()) ;\\n        int i = result.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            if(nums[start]*nums[start] > nums[end]*nums[end])\\n            {\\n                result[i] = nums[start]*nums[start]; \\n                start++;\\n            }\\n               \\n        \\n        else{\\n            result[i] = nums[end]*nums[end];\\n            end--;\\n        }\\n           i--; \\n            \\n        }  \\n        return result;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```result```\n```nums```\n```start```\n```end```\n```nums```\n```i```\n```result```\n```result```\n```nums```\n```start```\n```end```\n```nums```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252319,
                "title": "c-two-pointers-o-n-no-sorting-required",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& a) {\\n        \\n        int n=a.size();\\n        vector<int>ans(n);\\n        int i=0;\\n        int j=n-1;\\n        int k=n-1;\\n        \\n        while(i<=j)\\n        {\\n            if(abs(a[i])>=abs(a[j]))\\n            {\\n                ans[k] = a[i]*a[i];\\n                i++;\\n            }\\n            else\\n            {\\n                ans[k] = a[j]*a[j];\\n                j--;\\n            }\\n            k--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167055,
                "title": "c-o-n-99-99-faster",
                "content": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    vector<int> sortedSquares(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> res(n);\\n        int s = 0, e = n - 1, idx = n - 1;\\n        \\n        while(s <= e)\\n        {\\n            if(abs(nums[s]) < abs(nums[e]))\\n            {\\n                res[idx--] = nums[e] * nums[e];\\n                e--;\\n            }\\n            else\\n            {\\n                res[idx--] = nums[s] * nums[s];\\n                s++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1164759,
                "title": "java-single-while-loop-approach-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n\\t\\tint[] res = new int[nums.length];\\n\\t\\tint i = 0;\\n\\t\\tint j = nums.length - 1;\\n\\t\\tint counter = nums.length - 1;\\n\\t\\twhile (counter >= 0) {\\n\\t\\t\\tint iSquare = nums[i] * nums[i];\\n\\t\\t\\tint jSquare = nums[j] * nums[j];\\n\\t\\t\\tif (iSquare > jSquare) {\\n\\t\\t\\t\\tres[counter] = iSquare;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[counter] = jSquare;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tcounter--;\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062638,
                "title": "java-o-n-1ms",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n = nums.length;\\n        int arr[] = new int [n];\\n        int start =0, end = n-1;\\n        for(int i =n-1;i>=0;i--){\\n            int square =Math.abs(nums[start])<Math.abs(nums[end])?nums[end--]:nums[start++];\\n            arr[i] = square*square;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941592,
                "title": "c-two-approach-solution",
                "content": "**1. Using in-built sort function (NlogN time complexity)**\\nRuntime: 100 ms, faster than 54.72% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\n**2. Using two pointers (O(N) time complexity)**\\nRuntime: 20 ms, faster than 97.93% of C++ online submissions for Squares of a Sorted Array.\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortedSquares(vector<int>& nums) {\\n\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<int> res(n);\\n\\n\\t\\t\\tint i = 0; //pointing on \\'nums\\' vector\\n\\t\\t\\tint j = n-1; //pointing on \\'nums\\' vector\\n\\t\\t\\tint idx = n-1; //pointing on \\'res\\' vector\\n\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tint v1 = nums[i] * nums[i];\\n\\t\\t\\t\\tint v2 = nums[j] * nums[j];;\\n\\n\\t\\t\\t\\tif(v1 > v2){\\n\\t\\t\\t\\t\\tres[idx] = v1;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tres[idx] = v2;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tidx--;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tvector<int> sortedSquares(vector<int>& A) {\\n\\n\\t\\t\\t\\t\\tfor(int i=0;i<A.size();i++) A[i] *= A[i];\\n\\n\\t\\t\\t\\t\\tsort(A.begin(),A.end());\\n\\n\\t\\t\\t\\t\\treturn A;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 659371,
                "title": "simple-and-straightforward-python-solution-o-n",
                "content": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```\\n\\ntwo pointer approach",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n        res = []\\n        \\n        i = 0\\n        j = len(A) - 1\\n        \\n        while i <= j:\\n            \\n            if abs(A[i]) < abs(A[j]):\\n                res.append(A[j]**2)\\n                j-=1\\n            else:\\n                res.append(A[i]**2)\\n                i+=1\\n                \\n                \\n        return res[::-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 576683,
                "title": "swift",
                "content": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        var res = [Int](repeating: 0, count: A.count)\\n        var index = A.count - 1\\n        var left = 0\\n        var right = A.count - 1\\n        while left <= right {\\n            var a = A[left] * A[left]\\n            var b = A[right] * A[right]\\n            if a > b {\\n                res[index] = a\\n                index -= 1\\n                left += 1\\n            } else {\\n                res[index] = b\\n                index -= 1\\n                right -= 1\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 504370,
                "title": "python-explained-without-using-sorted",
                "content": "The intuition is that the first and last bits of the originally sorted array will be the two candidates to append to the squares array back to front. \\n\\nFor example, in: `[-9,-3,-2,0,3,4]` the two largest possible are -9^2 and 4^2. If it\\'s the left, increment left and append it to the back of the result array. \\n\\n```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def sortedSquares(self, A: List[int]) -> List[int]:\\n        l, r, ptr = 0, len(A) - 1, len(A) - 1\\n        fin = [None] * len(A)\\n        while l <= r:\\n            lS, rS = A[l] ** 2, A[r] ** 2\\n            if lS >= rS: \\n                fin[ptr], l = lS, l + 1\\n            else:\\n                fin[ptr], r = rS, r - 1\\n            ptr -= 1\\n        return fin\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 391005,
                "title": "two-pointers-c-one-pass-o-n-detailed-explanation",
                "content": "Note that the given array is already sorted, so in terms of sqaure values, it can be considered as at most two sorted arrays connected somewhere in the middle. Then we could use the same idea to merge two sorted arrays.\\n\\n```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```cpp\\n    vector<int> sortedSquares(vector<int>& a) {        \\n        int n = a.size();\\n        int L = 0; // read position from left a[]\\n        int R = n-1; // read position from right a[]\\n        int w = n-1; // write position in res[]\\n        \\n        vector<int> res(n);\\n        \\n        while (w >= 0) // pick large one in asb\\n            res[w--] = (abs(a[L]) >= abs(a[R]))? a[L]*a[L++] : a[R]*a[R--];\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332449,
                "title": "swift-o-n-solution",
                "content": "```swift\\nclass Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            } else {\\n                outputs[p] = A[j] * A[j]\\n                j -= 1\\n            }\\n        }\\n        \\n        return outputs\\n    }\\n}\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func sortedSquares(_ A: [Int]) -> [Int] {\\n        let n = A.count\\n        var outputs = Array(repeating: 0, count: n)\\n        \\n        var i = 0, j = n - 1\\n        \\n        for p in (0 ..< n).reversed() {\\n            if abs(A[i]) > abs(A[j]) {\\n                outputs[p] = A[i] * A[i]\\n                i += 1\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 239305,
                "title": "c-solution",
                "content": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* sortedSquares(int* A, int ASize, int* returnSize) {\\n    int* ans = calloc(ASize, sizeof(int));\\n    *returnSize = ASize;\\n    int i = 0, j = ASize - 1, index = ASize - 1;\\n    while(i <= j)\\n    {\\n        if(-A[i] > A[j])\\n        {\\n            ans[index--] = A[i] * A[i];\\n            i++;\\n        }\\n        else\\n        {\\n            ans[index--] = A[j] * A[j];\\n            j--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3697662,
                "title": "easy-solution-two-pointers-beats-97-facebook",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n- The code aims to square each element in the given input array nums, sort the squared values in non-decreasing order, and return the sorted result.\\n- It uses two pointers, left and right, to track the left and right ends of the input array.\\n- The algorithm initializes an empty result array of the same size as nums.\\n- Starting from the ends of the array, the algorithm compares the absolute values of the elements at the left and right pointers.\\n- It squares the larger absolute value and assigns it to the end of the result array.\\n- The pointer of the assigned value is then decremented.\\n- The algorithm moves the pointer that corresponds to the element with the smaller absolute value.\\n- This process continues until the pointers meet or cross each other.\\n- Finally, the algorithm returns the sorted result array.\\n- The time complexity is O(n) linear because the algorithm iterates through the input array only once. \\n- The space complexity is also O(n) linear because it requires space to store the result array of the same size as the input array.\\n\\n```\\nI hope this helps ^_^\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int left=0, right=nums.size()-1;\\n        vector<int> arr(nums.size());\\n        int i=arr.size()-1;\\n        while(left<=right){\\n            int temp=max(nums[left]*nums[left],nums[right]*nums[right]);\\n            arr[i--]=temp;\\n            if(abs(nums[left])<abs(nums[right])){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\n```\\nI hope this helps ^_^\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391656,
                "title": "easy-clean-js-solution",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst sortedSquares = function(nums) {\\n  const arr =  nums.map(value => Math.pow(value,2));\\n  return arr.sort((a,b)=> a-b);\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3196486,
                "title": "simple-two-pointer-solution-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array sorted in non-decreasing order, we need to return an array of the squares of each number sorted in non-decreasing order. Since the given array is sorted, the squares of $$negative$$ numbers will be in $$decreasing$$ order and the squares of $$positive$$ numbers will be in $$increasing$$ order. We can merge these two arrays of squares using a $$two-pointer$$ approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will start with two pointers, $$left$$ and $$right$$, both at the two ends of the given array. We will also create an empty result array called $$\\'res\\'$$.\\n- We will loop until the $$left$$ pointer is less than or equal to the $$right$$ pointer.\\n- If the element pointed by the $$left$$ pointer is negative, we will compare its $$absolute$$ value with the element pointed by the $$right$$ pointer. \\n- If the absolute value of the $$left$$ element is greater than or equal to the $$right$$ element, we will add the square of the $$left$$ element to the $$\\'res\\'$$ array and move the $$left$$ pointer one position to the right.\\n- Otherwise, we will add the square of the right element to the $$\\'res\\'$$ array and move the $$right$$ pointer one position to the left.\\n- If the element pointed by the $$left$$ pointer is non-negative, we will $$break$$ out of the loop since all remaining elements will also be non-negative and their squares will be in $$increasing$$ order.\\n- We will loop through the remaining elements in the array from the $$right$$ pointer to the $$left$$ pointer and append their squares to the $$\\'res\\'$$ array.\\n- Since we appended the squares of the remaining elements from right to left, we need to reverse the $$\\'res\\'$$ array to get the squares in $$non-decreasing$$ order.\\n- We will return the $$\\'res\\'$$ array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nThe given array is iterated twice - once using the two-pointer\\napproach and once to loop through the remaining elements. \\nTherefore, the time complexity of this algorithm is O(n), where \\'n\\'\\nis the length of the given array.\\n```\n```\\nWe are creating an empty array to store the result. Therefore, \\nthe space complexity of this algorithm is O(n), where \\'n\\' is \\nthe length of the given array.\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        res = []  # to store the result\\n        left, right = 0, len(nums)-1  # initialize left and right pointers to the two ends of the array\\n        \\n        # loop until left pointer is less than or equal to right pointer\\n        while left <= right:\\n            if nums[left] < 0:  \\n                # if the element pointed by left pointer is negative\\n                # compare absolute value of left element with the right element\\n                if abs(nums[left]) >= nums[right]:\\n                    res.append(nums[left]**2)  \\n                    # if absolute value of left element is greater than or equal\\n                    # to right element, add square of left element to the result array\\n                    left += 1  # move left pointer one position to the right\\n                else:\\n                    res.append(nums[right]**2)  \\n                    # if absolute value of left element is less than right element, add square of right\\n                    # element to the result array\\n                    right -= 1  # move right pointer one position to the left\\n            else:  \\n                # if the element pointed by left pointer is non-negative, break out of the loop\\n                break\\n        \\n        # loop through the remaining elements from right pointer to left pointer and \\n        # append their squares to the result array\\n        for i in range(right, left-1, -1):\\n            res.append(nums[i]**2)\\n        \\n        res.reverse()  # reverse the result array to get the squares in non-decreasing order\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144443,
                "title": "one-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        return sorted([i*i for i in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114237,
                "title": "basic-code-begginer-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Please Upvote if you like the approach \\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int temp=nums[i]*nums[i];\\n            ans.push_back(temp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066994,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiplicatio of two elements at same index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this problem i just simply multiply elements at same index and after that i just simply sort the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]*nums[i];\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n    }\\n};\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838888,
                "title": "c-best-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=(nums[i]*nums[i]);\\n        }\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797840,
                "title": "kotlin-one-liner-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun sortedSquares(nums: IntArray): IntArray {\\n        return nums.map { it * it }.sorted().toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792303,
                "title": "python-two-pointers-99-45-faster-o-n-solution",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```\\n\\n**Please upvote if you like the solution**\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        c,n=0,len(nums)\\n        if n==1:\\n            nums[0]*=nums[0]\\n            return nums\\n        for i in range(n):\\n            if nums[i]>=0: #it will give us the index of the first postive number\\n                break\\n            c+=1\\n        for i in range(n):\\n            nums[i]*=nums[i]\\n        if c==n:\\n            return nums[-1::-1]\\n        i,j=c,c-1\\n        ans=[]\\n        while i<n and j>=0:\\n            if nums[i]<nums[j]:\\n                ans.append(nums[i])\\n                i+=1\\n            else:\\n                ans.append(nums[j])\\n                j-=1\\n# Here wer are running these two loops to check that if there is any element left or not\\n        for ind in range(i,n):\\n            ans.append(nums[ind]) \\n        for ind in range(j,-1,-1):\\n            ans.append(nums[ind])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784534,
                "title": "python-easy",
                "content": "**2 Pointer Approch**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\\n**OverWriting Method**\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        i = 0 \\n        j = len(nums) - 1\\n        lst = []\\n        while(i<=j):\\n            if(nums[i]<0):\\n                nums[i] *= -1\\n            if(nums[j]<0):\\n                nums[j] = nums[j]*(-1)\\n            if(nums[i]>nums[j]):\\n                    lst.append(nums[i]*nums[i])\\n                    i+=1\\n            else:\\n                    lst.append(nums[j]*nums[j])\\n                    j-=1\\n        return lst[::-1]\\n```\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        lst = []\\n        for i in nums:\\n            lst.append(i*i)\\n        return sorted(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676939,
                "title": "clean-0ms-runtime-faster-than-100-submission",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(N)\\n```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n         if(nums.length==0)\\n            return nums; \\n\\t\\t\\t\\n//naive Approach\\n//         for(int i=0;i<nums.length;i++)\\n//             nums[i]*=nums[i];\\n//         Arrays.sort(nums);\\n       \\n            \\n        int ans[]= new int[nums.length];\\n            \\n        int l=0;\\n        int r = ans.length-1;\\n        int index = nums.length-1;\\n        \\n        while(l<=r)\\n        {\\n            int val1 = nums[l]*nums[l];\\n            int val2 = nums[r]*nums[r];\\n            if(val1>val2)\\n            {\\n                ans[index] = val1;\\n                l++;\\n            }\\n            else\\n            {\\n                ans[index] = val2;\\n                r--;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598384,
                "title": "c-solution-two-pointers",
                "content": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }\\n            else{\\n                ans[i] = nums[right]*nums[right];\\n                right--;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        vector<int>ans(nums.size(),0);\\n        \\n        for(int i = nums.size()-1; i>=0; i--){\\n            \\n            if(abs(nums[left]) > nums[right]){\\n                ans[i] = nums[left]*nums[left];\\n                left++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2429646,
                "title": "java-easiest-solution-beginner-friendly-approach-8ms-runtime-faster-than-50-submission",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406220,
                "title": "2-pointers-fully-explained-python-3-o-n-79-29-faster",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        \\n        # Solution with 2 Pointers\\n        # Time Complexity: O(n)  Space Complexity: O(n)\\n        \\n        \"\"\"\\n        \\n        1. Initialize two pointers: lowValue = 0; highValue = len(nums) - 1\\n        2. Create a list with same length as nums to  store squared values arranged in non decreasing order\\n        3. Loop through the nums array \"Backwards\" (last index to 0) \\n        \\n            For each i, compare the absolute values of given list at the lowValue and highValue indexes\\n            \\n            3a. If absolute value of element at index lowValue >= absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index lowValue)\\n                - lowValue += l (Increment lowValue)\\n                \\n            3b. Else if absolute value of element at index lowValue < absolute value of element at index highValue:\\n                \\n                - Element of index i of new list = square (element at index highValue)\\n                - highValue -= l (Decrement highValue)\\n             \\n        \"\"\"\\n                \\n        # Step 1.\\n        \\n        lowValue = 0\\n        highValue = len(nums) - 1\\n        \\n        # Step 2.\\n        nums_square = [None] * int(len(nums))\\n        \\n        # Step 3.\\n        for i in range(len(nums) - 1, -1, -1):\\n            \\n            # Step 3a.\\n            if abs(nums[lowValue]) >= abs(nums[highValue]):\\n                \\n                nums_square[i] = nums[lowValue] * nums[lowValue]\\n                lowValue+=1\\n            \\n            # Step 3b\\n            else:\\n                nums_square[i] = nums[highValue] * nums[highValue]\\n                highValue-=1\\n                \\n        return nums_square\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284502,
                "title": "simple-python-solution-optimized-two-pointer-approach-with-comments",
                "content": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n# Two Pointer Approach\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left, right, new_arr = 0, len(nums)-1, []\\n        \\n        while left <= right:\\n            if abs(nums[left]) <= abs(nums[right]): # if the absolute value of left pointer value is less than or equal to right pointer\\n                new_arr.append(nums[right]**2) # Since we need non decreasing order sorted array, append the square of the value of right pointer to nums.\\n                right -= 1\\n            else:\\n                new_arr.append(nums[left]**2) # append left pointer value to nums\\n                left += 1\\n            \\n        return(new_arr[::-1]) # since we need non decreasing order, we reverse the nums array\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2280333,
                "title": "c-solution-3-lines-code-better-than-94-square-then-sort",
                "content": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvector<int> sortedSquares(vector<int>& nums) {\\n        for(auto &i: nums)\\n\\t\\t\\ti = i*i;\\n        sort(nums.begin(), nums.end());\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267875,
                "title": "c-easy-clean-and-fastest-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector<int>res(nums.size());\\n        int l=0,r=nums.size()-1;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(abs(nums[r])>abs(nums[l]))\\n            {\\n                res[i]=nums[r]*nums[r];\\n                r--;\\n            }\\n            else\\n            {\\n                res[i]=nums[l]*nums[l];\\n                l++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076517,
                "title": "easiest-java-soln-using-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int [n];\\n        int a=0,b=n-1,x,y,i=n-1;\\n            while(a<=b)\\n            {\\n                x=nums[a]*nums[a];\\n                y=nums[b]*nums[b];\\n                if(x>y)\\n                {\\n                    ans[i--]=x;\\n                    a++;\\n                }\\n                else\\n                {\\n                    ans[i--]=y;\\n                    b--;\\n                }\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042618,
                "title": "o-n-solution-in-javascript",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortedSquares = function(nums) {\\n    let result = Array(nums.length).fill(0);\\n    let left = 0;\\n    let right = nums.length - 1;\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\\n            result[i] = nums[left] ** 2;\\n            left += 1;\\n        } else {\\n            result[i] = nums[right] ** 2;\\n            right -= 1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966872,
                "title": "squares-of-a-sorted-array-java-easy-o-n-2-pointers-fastest-soln",
                "content": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        //Naive Approach\\n        \\n//         int n=nums.length;\\n//         int []arr=new int[n];\\n        \\n//         for(int i=0;i<n;i++){\\n//             arr[i]=nums[i]*nums[i];\\n//         }\\n        \\n//         Arrays.sort(arr);\\n        \\n//         return arr;\\n        \\n        \\n        int n=nums.length;\\n        \\n        int i=0;\\n        int j=n-1;\\n        \\n        int []res=new int[n];\\n        \\n        for(int k=n-1;k>=0;k--){\\n            if(Math.abs(nums[i])>Math.abs(nums[j])){\\n                res[k]=nums[i]*nums[i];\\n                i++;\\n            }else{\\n                res[k]=nums[j]*nums[j];\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938824,
                "title": "very-easy-and-straight-forward-solution",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```\\n\\nStep-1: Traverse the array\\nStep-2: At each traversal simply multiply the two numbers and store it at the \\'i-th\\' place.\\nStep-3: Sort the array and return its value.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            nums[i]=nums[i]*nums[i];\\n        }\\n        \\n        Arrays.sort(nums);\\n        \\n        return nums;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903311,
                "title": "most-efficient-python-solution-using-two-pointers-approach",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```\\n**Complexity Analysis**\\n\\nTime Complexity: O(n) [Linear]\\nSpace complexity: O(n)\\n\\n**PLEASE UPVOTE FOR MOTIVATING ME TO CONTINUE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        l=0\\n        r=len(nums)-1\\n        ans=[0]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[l]**2<nums[r]**2:\\n                ans[i]=nums[r]**2\\n                r-=1\\n            else:\\n                ans[i]=nums[l]**2\\n                l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874940,
                "title": "python3-two-pointers-approach",
                "content": "In the two pointer approach you have to use two pointers to move around the array an do the stuff that you need.\\n\\nSo in this case, we have a pointer to the start of the array and another pointer in the end of the array. We compare the absolute value of the two values and get the bigger one, square the value and put at the end of the new array, and increment or decrement the pointer depending on which value is bigger.\\n\\nContinue on the loop till the start pointer is == to the end pointer and you will have the new array ordened with the squared values.\\n\\nPlease, if you have a better solution using the two pointers approach let me know!!! :D\\n\\n```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        start, end = 0, length - 1\\n        res = [0]*length\\n        index = -1\\n\\n        while start <= end:\\n            if abs(nums[start]) > abs(nums[end]):\\n                res[index] = nums[start] * nums[start]\\n                start += 1\\n            else:\\n                res[index] = nums[end] * nums[end]\\n                end -= 1\\n            index -= 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792436,
                "title": "python-two-pointer-98-less-space",
                "content": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            l_sq = nums[left]**2\\n            r_sq = nums[right]**2\\n            \\n            if l_sq > r_sq:\\n                nums.insert(right + 1, l_sq)\\n                nums.pop(left)\\n            else:\\n                nums[right] = r_sq\\n            \\n            right -= 1\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759471,
                "title": "go-two-solutions-sort-o-nlogn-and-two-pointers-o-n",
                "content": "Hello Gophers!\\n\\n## Without the constraint O(n)\\n\\n### Solution 1 - Sort O(nlogn)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\\n\\n## With the constraint O(n)\\n\\n> Constraint: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?\\n\\n### Solution 2 - Two Pointers O(n)\\n\\nInstead of sorting, we use two pointers.\\nWe square all the nums, we add the numbers to the result slice (array)\\nfrom the smallest to the biggest, from middle of the array to the extemities (begin/end).\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\\n\\n### Solution 3 - Two Pointers improved O(n)\\n\\nInspired by [this great solution](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/495394/C%2B%2B%3A-Simplest-one-pass-two-pointers) (please, go like his post if you liked mine because of this solution):  \\ndo the same as the second solution, but\\n- we don\\'t square the values (step 1) before the construction of our result slice (step 3)\\n- we add the numbers to the result slice (array) from the biggest to the smallest, from the extemities (begin/end) of the array to the middle (no need of step 2)\\n\\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers"
                ],
                "code": "```go\\nfunc sortedSquares(nums []int) []int {\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    sort.Ints(nums) // This is the reason why it\\'s O(nlogn)\\n    return nums\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    // STEP 1\\n\\t// First, we square all the nums\\n    for idx, num := range nums {\\n        num *= num\\n        nums[idx] = num\\n    }\\n    \\n    if len(nums) <= 1 {\\n        return nums\\n    }\\n    \\n\\t// STEP 2\\n\\t// After this, we move our two pointers where the smallest number is found\\n\\t// (near center, could be beginning or end)\\n    var ptr1, ptr2 int = 0, 1\\n    for ptr2 < len(nums)-1 && nums[ptr1] >= nums[ptr1+1] && nums[ptr2] >= nums[ptr2+1] {\\n        ptr1++\\n        ptr2++\\n    }\\n    \\n\\t// STEP 3\\n\\t// We add the smallest number to the result slice (array)\\n\\t//\\n\\t// If we add the value of the first pointer `ptr1`, we move it to left\\n\\t// Else if we add the value of the second pointer `ptr2`, we move it to the right\\n\\t// \\n\\t// If we are done with one pointer, to add values of the other pointers.\\n\\t// And we do this until we can\\'t.\\n    result := make([]int, 0)\\n    for {\\n        if ptr1 < 0 && ptr2 >= len(nums) {\\n            return result\\n        } else if ptr1 < 0 {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        } else if ptr2 >= len(nums) {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else if nums[ptr1] <= nums[ptr2] {\\n            result = append(result, nums[ptr1])\\n            ptr1--\\n        } else {\\n            result = append(result, nums[ptr2])\\n            ptr2++\\n        }\\n    }\\n    \\n    return result\\n}\\n```\n```go\\nfunc sortedSquares(nums []int) []int {\\n    var ptr1, ptr2 int = 0, len(nums)-1\\n    var currentIndex int = len(nums)-1\\n    result := make([]int, len(nums))\\n    for ptr2 >= ptr1 {    \\n        val1, val2 := nums[ptr1], nums[ptr2]\\n        sqr1, sqr2 := val1*val1, val2*val2\\n        if sqr1 >= sqr2 {\\n            result[currentIndex] = sqr1\\n            ptr1++\\n        } else /* if sqr1 < sqr2 */ {\\n            result[currentIndex] = sqr2\\n            ptr2--\\n        }\\n        currentIndex--\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1683558,
                "title": "python-2-approaches",
                "content": "### Approach 1: \\n*  **Using Python Bisect to find the position to keep the element, so that the array remains sorted.**\\n \\n```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```       \\n\\n   ### Approach 2:\\n*    **Using two pointers technique**\\n*   **Took less time than the first approach**\\n\\n   ```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        negativeList = []\\n        positiveList = []\\n        \\n        if len(nums) == 1:\\n            return [nums[0]**2]\\n        \\n        for i in nums:\\n            if i<0:\\n                negativeList.append(i)\\n            else:\\n                positiveList.append(i)\\n                \\n        negativeList = [abs(i) for i in negativeList]\\n\\n        for  i in negativeList:\\n            x = bisect.bisect(positiveList, i)\\n            positiveList.insert(x,i)\\n        \\n        res = [i*i for i in positiveList]\\n        return res\\n```\n```\\n   class Solution(object):\\n    def sortedSquares(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        answer = [None]*len(nums)\\n        for i in range(len(nums)-1,-1,-1):\\n            if abs(nums[left]) > abs(nums[right]):\\n                answer[i] = nums[left]**2\\n                left += 1\\n                \\n            else:\\n                answer[i] = nums[right]**2\\n                right-=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658950,
                "title": "c-naive-vs-linear-time-constant-space-2-pointer-solution-100-time-90-space",
                "content": "First of all, the naive approach, which is trivially transforming the array and then sorting it, in place:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\\n\\nPlus another variant of it I wrote [here](https://leetcode.com/problems/squares-of-a-sorted-array/discuss/793033/C%2B%2B-In-Place-3-Lines-Solution-Explained-~60-Time-~90-Space) a while ago.\\n\\nStill decent start in an interview setting, but odds are is that we will be asked the follow up question of this problem soon, so how can we solve it in linear time, even if it requires us to sort the elements following a new criterium?\\n\\nWell, turns out that we are not really left on our own device on this point, since we are provided an array that is *initially* already sorted and that is no small advantage at all!\\n\\nThe trick will be for us to pinpoint there the negative numbers end and when the positive ones star, with two separate points - at that point, we will pick the lesser one in absolute value and insert it into our result variable and so on.\\n\\nIn order to proceed, we will first of all declare a few support variables:\\n* `len` will store the length of our initial input, which also happens to be the length of our result variable;\\n* `i` will be the pointer set at the beginning of all the non-negative numbers (ie: `0` included, for convenience, not that it would change much if you were to put it under the other pointer); since `nums` is given to us as sorted, we can find this place in logn time, with built-in binary search (just be ready to explain how it works in an interview!);\\n* `j`, specularly, will point to the last (and thus lesser, since `nums` is sorted) negative number, right before `i`;\\n* `r` will point to where in `res` we will go writing;\\n* `n` is a support variable we will use soon;\\n* `res` is our accumulator variable, initially set to be of size `len` to avoid reallocations (and that is also why we have to use `r` to write in it).\\n\\nWe will then have a first loop that will proceed as long both `i` and `j` are within the boundaries of `nums` and that will:\\n* check if the absolute value of the element pointed by `j` is smaller than the one pointed by `i`, in which case we will:\\n\\t* store `nums[j]` into `n`;\\n\\t* decrease `j`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n* alternatively, we will:\\n\\t* store `nums[i]` into `n`;\\n\\t* increase `i`;\\n\\t* write `n * n` in `res` at position `r`;\\n\\t* increase `r`;\\n\\nFor the sake of efficiency, once either of this conditions is no longer `true`, we will then run two separate loops to do what we did in the first or second case, until even the second pointer is out of boundaries (ie: we are done writing into `res`); a bit of duplicated code, I concede, but still rather good to avoid looping with one extra unnecessary condition.\\n\\nOnce done, we can return `res` :)\\n\\nThe code (which varies crazily in performance when you run it, sometimes logging more than 4X the best time, my guess is because the test cases were not really well balanced across different runs):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, hey: since `lower_bound` gives us iterators, can\\'t we just use them? Turns out we of course can and they also perform better, at least running the code a few times for comparison:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n        std::transform(begin(A), end(A), begin(A), [](int a){ return a * a; });\\n        sort(begin(A), end(A));\\n        return A;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), i = lower_bound(begin(nums), end(nums), 0) - begin(nums),\\n            j = i - 1, r = 0, n;\\n        vector<int> res(len);\\n        while (j > -1 && i < len) {\\n            // first case: negative number with smaller absolute value\\n            if (-nums[j] < nums[i]) {\\n                n = nums[j--];\\n                res[r++] = n * n;\\n            }\\n            // second case: positive number with smaller absolute value\\n            else {\\n                n = nums[i++];\\n                res[r++] = n * n;\\n            }\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j > -1) {\\n            n = nums[j--];\\n            res[r++] = n * n;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i < len) {\\n            n = nums[i++];\\n            res[r++] = n * n;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        int len = nums.size(), r = 0;\\n        auto start = begin(nums), ed = end(nums), i = lower_bound(start, ed, 0), j = i - 1;\\n        vector<int> res(len);\\n        while (j >= start && i != ed) {\\n            // first case: negative number with smaller absolute value\\n            if (-*j < *i) res[r++] = *j * *j--;\\n            // second case: positive number with smaller absolute value\\n            else res[r++] = *i * *i++;\\n        }\\n        // dealing with leftover negative numbers, if any\\n        while (j >= start) {\\n            res[r++] = *j * *j--;\\n        }\\n        // dealing with leftover positive numbers, if any\\n        while (i != ed) {\\n            res[r++] = *i * *i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627416,
                "title": "easy-c-solution-with-two-pointers",
                "content": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> sortedSquares(vector<int>& nums) {\\n        vector <int> arr(nums.size());\\n\\t\\t// q and p are pointers, k is needed to push highest elements at the end of a new array\\n        int q=0, p=nums.size()-1, k=nums.size()-1;\\n        \\n        while(q<=p){\\n            if(nums[q]*nums[q]>nums[p]*nums[p]){\\n                arr[k--]=nums[q]*nums[q]; // Here we push at the end\\n                q++;\\n            }\\n            else{\\n                arr[k--]=nums[p]*nums[p];\\n                p--;\\n            }\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577468,
                "title": "java-linear-time-solution",
                "content": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }\\n            else\\n            {\\n                square = nums[left];\\n                left++;  \\n            }\\n                \\n            answer[i]= square*square;\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] sortedSquares(int[] nums) {\\n        \\n        int n= nums.length;\\n        int left=0;\\n        int right=n-1;\\n        int[] answer = new int[n];\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            int square =0;\\n            // We take a reverse approach for negative numbers\\n            if(Math.abs(nums[left])< Math.abs(nums[right]))\\n            {\\n                square= nums[right];\\n                right--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576438,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1565880,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564797,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570583,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570076,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575767,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573931,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573757,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1969402,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575297,
                "content": [
                    {
                        "username": "robertocannella",
                        "content": "I created this interacitve tool to help me understand visually what is happening behind the code.   It  may help out others as well.  I will continue to build these so if there is interest in a specific algorithm or challenge, just send a note.\\nhttps://robertocannella-f5b4b.web.app/coding-challenges/sorted-squares"
                    },
                    {
                        "username": "zainabsajid",
                        "content": "this helped me alot thanks!\\n"
                    },
                    {
                        "username": "c8763yee",
                        "content": "thanks! but i don\\'t unstand why the 2nd approach using $O(logN)$ time complexity instead of $O(n)$"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You are amazing man!"
                    },
                    {
                        "username": "Itz-Verma",
                        "content": "thanks!"
                    },
                    {
                        "username": "kirsty",
                        "content": "Great animations, thank you! One comment - I believe the 2 ptr approach is actually O(N) runtime, your site says \"Two Pointer: O(N log N) time, O(N) or O(logN) space\".  Can you explain why it would be O(NlogN) runtime, or if it is a typo? "
                    },
                    {
                        "username": "Ayoub-89",
                        "content": "Legend ! thanks.\\n"
                    },
                    {
                        "username": "Damiandd",
                        "content": "it would be nice to slow it down a bit, but still excellent work. great thx!"
                    },
                    {
                        "username": "thapabharat123456",
                        "content": "wow..."
                    },
                    {
                        "username": "garrethue",
                        "content": "Hey, just want to say that I love your animations and the site in general. Keep it up dude!"
                    },
                    {
                        "username": "ijxx",
                        "content": "+1 for your animations."
                    },
                    {
                        "username": "puckhog08",
                        "content": "In the Arrays 101 Explore card leetcode asks you to solve this problem in-place and in O(n) time:\\n\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nHowever, even their own solution doesn\\'t meet these requirements. It doesn\\'t seem possible to stay within O(n) time without using extra space. Has anyone solved it this way?"
                    },
                    {
                        "username": "rokade",
                        "content": "[@blundell337](/blundell337) Asking an inplace solution for this (where we are not allowed to create a new output array) is the same problem as \"merge two sorted arrays in place and in O(n) time\". This can be done, but the techniques are extremely complicated. Here\\'s a white paper showing how it can be done :\\nhttp://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf\\n\\nOn a high level, the alog in the white paper uses parts of one of the array as a buffer to aid in sorting and merging the rest of the two arrays. I dont think one can be expected to give this solution in an interview.\\nHowever, i read it and found it fascinating on the same level that i find Knuth-Prat-Morris algorithm fascinating :)"
                    },
                    {
                        "username": "blundell337",
                        "content": "They mention in the \"Two Pointers\" explanation: \\n\\n\"Like in the previous two examples, this algorithm uses constant space (if we don\\'t count the output as extra space) and has a linear runtime.\"\\n\\nSo perhaps they are again, not counting the output?"
                    },
                    {
                        "username": "Primusai",
                        "content": "Python\\'s builtin sort is timsort which works by aggregating increasing and decreasing runs and then merging them. Since the resultant array after squaring all the terms will be first strictly decreasing and then strictly increasing, timsort reverses the strictly decreasing segment and then merges both runs in O(N)."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "How does timsort actually function? Is it an ensemble of sorting methods?"
                    },
                    {
                        "username": "h4rishabh",
                        "content": "Just a simple implementation, using Java 8 Streams\\n\\n` return Arrays.stream(nums).map(x -> x*x).sorted().toArray();`\\n\\n"
                    },
                    {
                        "username": "Devvyn",
                        "content": "this defeats the point of the question. You are not supposed to use built in functions. You are supposed to solve with data structures and algorithms. This question is meant to test two pointers approach. "
                    },
                    {
                        "username": "milileetcode",
                        "content": "![image](https://assets.leetcode.com/users/images/50ed0057-5595-48b7-bfc2-41c60b2f3229_1595280154.602534.png)\\n\\n\\nThis time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\\n\\nDid anyone work out such a solution?\\n"
                    },
                    {
                        "username": "joyrajlongjam",
                        "content": "![image](https://assets.leetcode.com/users/images/415c5cca-7771-4133-98f3-166e95fe6c05_1632028652.9367518.png)\\n"
                    },
                    {
                        "username": "t0rped0",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "Ed_H",
                        "content": "From the given information (provided when the (i) icon next to the problem name is selected):\\n\"This time, you must solve it in O(N) time and O(1) space. No using built-in sort, and no creating a new array.\"\\n\\nThe given solution, both Java and Python versions, creates a new array.  The solutions in the comments either create a new array, or they do an in-place sort.  The in-place sorts usually use a built-in sort, which is not an O(N) solution, in addition to violating the \"No using built-in sort\" requirement.\\n\\nWe can have O(N) time or use O(1) space.  I don\\'t believe we can have both, and would be very interested in seeing an example to the contrary."
                    },
                    {
                        "username": "anth-volk",
                        "content": "For JS, an actually good programmer would just use the most syntactic, readable elements of the language, right? nums.map, followed by nums.sort. This code would be more readable, more maintainable, and potentially more modular, depending on implementation. And yet here we are, trying to move around array indices to sort this thing *slightly* faster"
                    },
                    {
                        "username": "nilanjan9",
                        "content": "\\'\\'\\'\\nreturn sorted(list(map(lambda x:x*x,nums )))\\n\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1573930,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572727,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1572541,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576328,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1576715,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1574693,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1573915,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 2073126,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1929284,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1915592,
                "content": [
                    {
                        "username": "nikash",
                        "content": "https://youtu.be/_lZ6hpETdKM"
                    },
                    {
                        "username": "satwik95",
                        "content": "\\tvar sortedSquares = function(A) {\\n\\t\\treturn A.map(function(item){return item*item;}).sort(function(a, b){return a-b;});\\n\\t};"
                    },
                    {
                        "username": "dmc8686",
                        "content": "O(nlogn) seems to be the faster one than O(n). Testcases aren\\'t big enough I think."
                    },
                    {
                        "username": "talk2ritaj",
                        "content": "for i in range(len(nums)):\\n\\t nums[i]=nums[i]**2\\nreturn sorted(nums)"
                    },
                    {
                        "username": "_Ivan_Vigorito_",
                        "content": "If you like it, Upvote ;) \\n\\n\\n#### Solution\\nreturn sorted(map(lambda x: (x)**2, nums))"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/squares-of-sorted-array.html"
                    },
                    {
                        "username": "kunalchitkara",
                        "content": "`var sortedSquares = A => A.sort((x,y) => Math.abs(x) - Math.abs(y)).map(x => x*x);`"
                    },
                    {
                        "username": "tushartiwari25",
                        "content": "Can anyone explain how a two pointer solution in one of binary search...."
                    },
                    {
                        "username": "__buruno",
                        "content": "it maybe a very dumb question but i\\'ll ask anyway... can anybody explain to me why do i need to do *returnsize = numsSize?"
                    },
                    {
                        "username": "tuhinssam",
                        "content": "after putting this constraint: \"Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach\", it doesn\\'t remain easy anymore"
                    }
                ]
            },
            {
                "id": 1888341,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1880457,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1856876,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1809015,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1791819,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1787176,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1786287,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781187,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1781171,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1763423,
                "content": [
                    {
                        "username": "ansarnitp",
                        "content": "Is it possible to solve in O(n) time and O(k) space ?\\nLike in two pointer method, we use an extra array to store the values. But I don\\'t want to use any extra array and sort the squared result in the same array itself."
                    },
                    {
                        "username": "manojjha",
                        "content": "Hello guys for my below solution my testcases are passing when I run the code but when I submit it then I get error \"Time Limit Exceeded\". In submission it 128/137 testcases passed \\n\"\"\"class Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n        SquareList=[]\\n        SquareList = [num**2 for num in nums]\\n        for i in range(len(SquareList)):\\n            for j in range(len(SquareList)):\\n                if SquareList[i]<SquareList[j]:\\n                    SquareList[j], SquareList[i] = SquareList[i],SquareList[j]\\n        return SquareList\"\"\"\\nWhat is wrong I am doing in this?\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "Hope you aren\\'t gonna do sorting :)"
                    },
                    {
                        "username": "yzwang271828",
                        "content": "Further follow-up. Is there a solution of O(N) time complexity and at the same time sort the array in-place? \\n\\nIn the \"merge two sorted array\" approach, I can only think of copying the negatives to a new array and fill back into the original nums array. Can we avoid the \"copying\" into a new array part?"
                    },
                    {
                        "username": "chubbycccc",
                        "content": "Hello guys, would you like to help me to solve this error?  I have no idea why the error showed that\"list assignment index out of range\" for the \"result[k]=result[j]*result[j].\\nThanks a lot !\\n\\nclass Solution:\\n    def sortedSquares(self, nums: List[int]) -> List[int]:\\n          result=[]\\n          n=len(nums)\\n          k,j=n-1,n-1\\n          i=0\\n         while i<=j:\\n            if nums[i]*nums[i]>nums[j]*nums[j]:\\n                result[k]=nums[i]*nums[i]\\n                i+=1\\n            else:\\n                result[k]=nums[j]*nums[j]\\n                j-=1\\n            k-=1\\n        \\n        return result\\n"
                    },
                    {
                        "username": "payalraman0",
                        "content": "if you want to solve it in O(n) time ,it can be converted in merge two sorted arrays but you need extra space O(n) . I don\\'t know how to do it in TC: O(n), SC :O(1) "
                    },
                    {
                        "username": "payalraman0",
                        "content": "[@linuscodes56](/linuscodes56) you don\\'t need to reverse the array"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "amanjaiman890",
                        "content": "I Solved this question by 1ms O(n), you guys have any idea/solution that we can solve by 0ms :)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "are you sure bro?.Seems confusing"
                    },
                    {
                        "username": "payalraman0",
                        "content": "Can you tell me how you have done in O(N)"
                    },
                    {
                        "username": "Ayu_0308958",
                        "content": " for(int i=0;i<nums.size();i++){\\n        nums[i] =(nums[i]*nums[i]);}\\n        sort(nums.begin(),nums.end());\\n        return nums;\\n"
                    },
                    {
                        "username": "Bhavyaa_Arora_08",
                        "content": "Is an O(1) space or inplace solution possible for this question ?"
                    },
                    {
                        "username": "fireship_2004",
                        "content": "[@linuscodes56](/linuscodes56) stop spamming dude. you just said to push the values^2 in decreasing order in a new array then how come your solution stays in O(1) space complexity?"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@linuscodes56](/linuscodes56) if you are using additional space then how it will be o(1).That will be o(n)"
                    },
                    {
                        "username": "linuscodes56",
                        "content": "yes it is possible . the array is in sorted order so apply two pointer and push the values^2 in decreasing order in new array than reverse the array."
                    },
                    {
                        "username": "harshmishra3263",
                        "content": "I have solved this question using bubble sort and in this it is showing that you have passed 137 out of 137 test cases but above it is displaying time limit exceeded.\\n"
                    }
                ]
            },
            {
                "id": 1761845,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1742261,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732657,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1732488,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1728889,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1725935,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1683890,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1676020,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1630715,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            },
            {
                "id": 1749808,
                "content": [
                    {
                        "username": "Abhi3091",
                        "content": "\\n        for(in\\nt i = 0; i<nums.length; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        int left = 0;\\n\\n        int right = nums.length-1;\\n        int index = nums.length-1;\\n        int[] result = new int[nums.length];\\n\\n\\n        while(left <= right){\\n            //16 1 0 9 100\\n            int leftSquare = nums[left];\\n            int rightSquare = nums[right];\\n\\n            //we want to fill up the arrays from right\\n            // the trick is to use new array result\\n            //compare using pointers if right square is large\\n            // update and decrement right index\\n            if(rightSquare > leftSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            //else left index is incremented\\n            }else if(leftSquare > rightSquare){\\n\\n                result[index] = leftSquare;\\n                left++;\\n            //if equal then right value and right index decremented\\n            }else if(leftSquare == rightSquare){\\n\\n                result[index] = rightSquare;\\n                right--;\\n            }\\n\\n            index--;\\n        }\\n\\n        return result;\\n\\nMy java solution beats 100 %"
                    },
                    {
                        "username": "kprat",
                        "content": "Can someone help explain the space and time complexity of this solution:\\n\\nobject Solution {\\n    def sortedSquares(nums: Array[Int]): Array[Int] = {\\n        var left = 0\\n        var right = nums.length\\n        var newArray = new Array[Int](nums.length)\\n        var min = 0\\n        if (nums.length==1)\\n            return Array(sq(nums(0)))\\n        //val status:HashMap[Int,Boolean] = HashMap[Int,Boolean]()\\n        while(left<nums.length-1){\\n            //printArray(nums)\\n            if(Math.abs(nums(left))>Math.abs(nums(left+1)))\\n             swap(left,left+1)\\n            else \\n              {\\n              newArray(left) = sq(nums(left))\\n              newArray(left+1) = sq(nums(left+1))\\n              left+=1\\n              }\\n        }\\n        def swap(i:Int,j:Int) = {\\n            val temp = nums(j)\\n            nums(j) = nums(i)\\n            nums(i) = temp\\n            //newArray(i) = sq(nums(i))\\n            //newArray(j) = sq(nums(j))\\n            if(i>0){\\n            left-=1\\n            }\\n        }\\n\\n        def sq(i:Int):Int = {\\n            i*i\\n        }\\n\\n        def printArray(nums:Array[Int]) = {\\n            println(\"Left:\"+left)\\n            println(\"Array Status\")\\n            nums.foreach(x=> print(\" \" + x + \" \"))\\n            println()\\n        }\\n        newArray\\n    }\\n}"
                    },
                    {
                        "username": "mkaypl",
                        "content": "O(N^2) for time complexity (it\\'s bubble sort)"
                    },
                    {
                        "username": "hoangduy265",
                        "content": "`public class Solution {\n    public int[] SortedSquares(int[] nums) {\n        int[] result = new int[nums.Length];\n        for (int i = 0; i < nums.Length; i++)\n        {\n            if (nums[i] < 0) nums[i] = -nums[i];\n            result[i] = nums[i] * nums[i];\n        }\n        Array.Sort(result);\n        return result;\n    }\n}`"
                    },
                    {
                        "username": "AKUTOTA_SANJAY",
                        "content": "  vector<int> sortedSquares(vector<int>& nums) {\n        vector<int> v;\n        int pi=0,ni,k,l;\n        while(nums[pi]<0)\n        {\n            pi++;\n        }      \n        k=pi;\n        ni=pi-1;\n        for(int k=0;k<nums.size();k++)\n        {\n            nums[k]=nums[k]*nums[k];\n        }\n\n            if(ni==-1)\n            {\n                return nums;\n            }\n          else\n          {\n        while(k<nums.size() and ni>=0)\n        {\n            if(nums[k]<nums[ni])\n            {\n                 \n                v.push_back(nums[k]);\n                k++;\n               \n            }\n            else\n            {\n                 v.push_back(nums[ni]);\n                 ni--;\n            }  \n\n            }\n    }\n        \n        \n        for( ;ni>=0;ni--)\n        {\n            v.push_back(nums[ni]);\n        }\n\n        for(;k<nums.size();k++)\n        {\n             v.push_back(nums[k]);\n        }\n\n     return v;\n    }\n\n\nGetting this error plz help?\n\n=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000514 at pc 0x000000345f9b bp 0x7fffa113dd10 sp 0x7fffa113dd08\nREAD of size 4 at 0x602000000514 thread T0\n    #2 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000514 is located 0 bytes to the right of 4-byte region [0x602000000510,0x602000000514)\nallocated by thread T0 here:\n    #6 0x7f5544f740b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n=>0x0c047fff80a0: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "  return nums.Select(x => x * x ).OrderBy(x=> x).ToArray();\\nC# Linq\\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Anyone else getting signed integer overflow? Not sure how to fix this with the return type being a vector<int>"
                    },
                    {
                        "username": "Soumya1999",
                        "content": "Why its shows like memory limit exceeded?\\n"
                    },
                    {
                        "username": "Aryan_Arya",
                        "content": "I have a doubt, can we find the minimum absolute element using log(n) time complexity. Our array is given in sorted fashion. Can we use binary search to find the smallest element (in terms of magnitude)?"
                    },
                    {
                        "username": "irfann2022skipq",
                        "content": "Solved it in very easy wasy with O(n) time complexity.\nvar sortedSquares = function(nums) {\n    let squareArray = []\n    for(let i=0;i<nums.length;i++){\n      squareArray.push(nums[i]*nums[i])\n    }\n    return squareArray.sort((a,b)=>{return a-b})\n}  "
                    },
                    {
                        "username": "eliaashraf",
                        "content": "An easy solution to this would be to first find the squares of each element using a pointer and then using a Arrays.sort(array_name) function to solve this prolem.\\n\\nThis is what I have done-\\n `for(int i = 0; i <= nums.length - 1; i++){\\n            nums[i] = nums[i] * nums[i];\\n        }\\n        Arrays.sort(nums);\\n        return nums;`"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "then the time complexity will be 0(n logn).Try to solve this in 0(n).That is the challenge"
                    },
                    {
                        "username": "mkaypl",
                        "content": "Sorting isn\\'t O(n), just in case you missed the follow up note."
                    }
                ]
            }
        ]
    },
    {
        "title": "Constrained Subsequence Sum",
        "question_content": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the maximum sum of a <strong>non-empty</strong> subsequence of that array such that for every two <strong>consecutive</strong> integers in the subsequence, <code>nums[i]</code> and <code>nums[j]</code>, where <code>i &lt; j</code>, the condition <code>j - i &lt;= k</code> is satisfied.</p>\n\n<p>A <em>subsequence</em> of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,2,-10,5,20], k = 2\n<strong>Output:</strong> 37\n<b>Explanation:</b> The subsequence is [10, 2, 5, 20].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3], k = 1\n<strong>Output:</strong> -1\n<b>Explanation:</b> The subsequence must be non-empty, so we choose the largest number.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,-2,-10,-5,20], k = 2\n<strong>Output:</strong> 23\n<b>Explanation:</b> The subsequence is [10, -2, -5, 20].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 597751,
                "title": "java-c-python-o-n-decreasing-deque",
                "content": "## **Intuition**\\nWe need to know the maximum in the window of size `k`.\\nUse `heqp` will be `O(NlogN)`\\nUse `TreeMap` will be `O(NlogK)`\\nUse `deque` will be `O(N)`\\n<br>\\n\\n## **Prepare**\\nHow about google \"sliding window maximum\",\\nand make sure you understand 239. Sliding Window Maximum\\nDone. (If not done, continue read)\\n<br>\\n\\n## **Explanation**\\nUpdate `res[i]`,\\nwhere `res[i]` means the maximum result you can get if the last element is `A[i]`.\\n\\nI directly modify on the input `A`,\\nif you don\\'t like it,\\nuse a copy of `A`\\n\\nKeep a decreasing deque `q`,\\n`deque[0]` is the maximum result in the last element of result.\\n\\nIf `deque[0] > 0`. we add it to `A[i]`\\n\\nIn the end, we return the maximum `res`.\\n<br>\\n\\n## **Complexity**\\nBecause all element are pushed and popped at most once.\\nTime `O(N)`\\n\\nBecause at most O(K) elements in the deque.\\nSpace `O(K)`\\n<br>\\n\\n## **More**\\nDeque can be widely used in all bfs problems.\\nFor more complecated usage,\\nI recall this problem\\n[862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/)\\n<br>\\n\\n**Java:**\\n```java\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res = A[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            A[i] += !q.isEmpty() ? q.peek() : 0;\\n            res = Math.max(res, A[i]);\\n            while (!q.isEmpty() && A[i] > q.peekLast())\\n                q.pollLast();\\n            if (A[i] > 0)\\n                q.offer(A[i]);\\n            if (i >= k && !q.isEmpty() && q.peek() == A[i - k])\\n                q.poll();\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        int res = A[0];\\n        for (int i = 0; i < A.size(); ++i) {\\n            A[i] += q.size() ? q.front() : 0;\\n            res = max(res, A[i]);\\n            while (q.size() && A[i] > q.back())\\n                q.pop_back();\\n            if (A[i] > 0)\\n                q.push_back(A[i]);\\n            if (i >= k && q.size() && q.front() == A[i - k])\\n                q.pop_front();\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def constrainedSubsetSum(self, A, k):\\n        deque = collections.deque()\\n        for i in xrange(len(A)):\\n            A[i] += deque[0] if deque else 0\\n            while len(deque) and A[i] > deque[-1]:\\n                deque.pop()\\n            if A[i] > 0:\\n                deque.append(A[i])\\n            if i >= k and deque and deque[0] == A[i - k]:\\n                deque.popleft()\\n        return max(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res = A[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        for (int i = 0; i < A.length; ++i) {\\n            A[i] += !q.isEmpty() ? q.peek() : 0;\\n            res = Math.max(res, A[i]);\\n            while (!q.isEmpty() && A[i] > q.peekLast())\\n                q.pollLast();\\n            if (A[i] > 0)\\n                q.offer(A[i]);\\n            if (i >= k && !q.isEmpty() && q.peek() == A[i - k])\\n                q.poll();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        int res = A[0];\\n        for (int i = 0; i < A.size(); ++i) {\\n            A[i] += q.size() ? q.front() : 0;\\n            res = max(res, A[i]);\\n            while (q.size() && A[i] > q.back())\\n                q.pop_back();\\n            if (A[i] > 0)\\n                q.push_back(A[i]);\\n            if (i >= k && q.size() && q.front() == A[i - k])\\n                q.pop_front();\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def constrainedSubsetSum(self, A, k):\\n        deque = collections.deque()\\n        for i in xrange(len(A)):\\n            A[i] += deque[0] if deque else 0\\n            while len(deque) and A[i] > deque[-1]:\\n                deque.pop()\\n            if A[i] > 0:\\n                deque.append(A[i])\\n            if i >= k and deque and deque[0] == A[i - k]:\\n                deque.popleft()\\n        return max(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597693,
                "title": "python-c-dp-with-decreasing-deque",
                "content": "**Idea**\\nThis is a typical knapsack problem. we maintain an array `dp`, where `dp[i]` is the maximum sum we can get from nums[:i] and nums[i] is guaranteed to be included.\\n\\n- Base case: `dp[0] = nums[0]`\\n- state transition: `dp[i] = max(dp[i - k], dp[i-k+1], ..., dp[i - 1], 0) + x`\\n    - NOTE that x can be a fresh start when all the previous dp are negative.\\n\\nThis algorithm is only \\x10`O(n * k)`, we need to improve it to `O(n)` because both `k` and `n` can be 10^5.\\n\\nThe Idea is straight-forward, we can maintain an non-increasing deque `decrease` that records the maximum value among `dp[i - k], dp[i-k+1], ..., dp[i - 1]`. When encountering a new value `x`, we only record it in `decrease` if `x > decrease[decrease.size - 1]`. Thus the first element in `decrease` will always be the largest value we want.\\n\\n**Complexity**\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n**Python**\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = nums[:1]\\n        decrease = collections.deque(dp)\\n        for i, x in enumerate(nums[1:], 1):\\n            if i > k and decrease[0] == dp[i - k - 1]:\\n                decrease.popleft()\\n            tmp = max(x, decrease[0] + x)\\n            dp += tmp,\\n            while decrease and decrease[-1] < tmp:\\n                decrease.pop()\\n            decrease += tmp,                \\n        return max(dp)  \\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp {nums[0]};\\n        deque<int> decrease {nums[0]};\\n        int res = nums[0];\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n            if (i > k && decrease[0] == dp[i - k - 1])\\n                decrease.pop_front();\\n            int tmp = max(nums[i], decrease[0] + nums[i]);\\n            dp.push_back(tmp);\\n            while (!decrease.empty() && decrease.back() < tmp)\\n                decrease.pop_back();\\n            decrease.push_back(tmp);\\n            \\n            res = max(res, tmp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = nums[:1]\\n        decrease = collections.deque(dp)\\n        for i, x in enumerate(nums[1:], 1):\\n            if i > k and decrease[0] == dp[i - k - 1]:\\n                decrease.popleft()\\n            tmp = max(x, decrease[0] + x)\\n            dp += tmp,\\n            while decrease and decrease[-1] < tmp:\\n                decrease.pop()\\n            decrease += tmp,                \\n        return max(dp)  \\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp {nums[0]};\\n        deque<int> decrease {nums[0]};\\n        int res = nums[0];\\n        \\n        for (int i=1; i<nums.size(); i++) {\\n            if (i > k && decrease[0] == dp[i - k - 1])\\n                decrease.pop_front();\\n            int tmp = max(nums[i], decrease[0] + nums[i]);\\n            dp.push_back(tmp);\\n            while (!decrease.empty() && decrease.back() < tmp)\\n                decrease.pop_back();\\n            decrease.push_back(tmp);\\n            \\n            res = max(res, tmp);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605822,
                "title": "java-decreasing-monotonic-queue-clean-code-o-n",
                "content": "**Idea**\\ndp[i] is the max sum we can have from A[:i] when A[i] has been chosen.\\n\\n**\\u2714\\uFE0F Solution 1: DP Straight forward - TLE**\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = Math.max(i - k, 0); j < i; j++) { // choose the max element in latest k elements, it\\'s in range [i-k, i-1]\\n                max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N*K)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DP + Decreasing Monotonic Queue**\\nWe need to get the max element in k latest elements in `O(1)` by using Decreasing Monotonic Queue, the same with this problem: [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/598751)\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: DP + Decreasing Monotonic Queue + Optimized Space**\\nUse `arr` as `dp` instead of create new one.\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint max = Math.max(0, deque.isEmpty() ? 0 : arr[deque.peekFirst()]);\\n            arr[i] += max;\\n            ans = Math.max(ans, arr[i]);\\n            while (!deque.isEmpty() && arr[i] >= arr[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(K)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = 0;\\n            for (int j = Math.max(i - k, 0); j < i; j++) { // choose the max element in latest k elements, it\\'s in range [i-k, i-1]\\n                max = Math.max(max, dp[j]);\\n            }\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int max = Math.max(0, deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\\n            dp[i] = arr[i] + max;\\n            ans = Math.max(ans, dp[i]);\\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] arr, int k) {\\n        int n = arr.length;\\n        Deque<Integer> deque = new LinkedList<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint max = Math.max(0, deque.isEmpty() ? 0 : arr[deque.peekFirst()]);\\n            arr[i] += max;\\n            ans = Math.max(ans, arr[i]);\\n            while (!deque.isEmpty() && arr[i] >= arr[deque.peekLast()]) { // If dp[i] >= deque.peekLast() -> Can discard the tail since it\\'s useless\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n            if (i - deque.peekFirst() + 1 > k) { // remove the last element of range k\\n                deque.removeFirst();\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597744,
                "title": "python-o-n-monoqueue",
                "content": "Consider a typical (but inefficient) DP: we have dp[i] = the max sum of some non-empty subset of nums[..i] that contains nums[i].  The final answer is max(dp).\\n\\nIn this dp, we have the recurrence relation `dp[i+K] = nums[i+K] + max(0, dp[i], dp[i+1], ..., dp[i+K-1])`.  We can use a monoqueue (a queue that supports a O(1) max operation) to efficiently perform this DP - it stores the result of max(...) and we update it by eg. adding dp[i+K+1] and popping dp[i].\\n\\n```\\nclass Monoqueue(collections.deque):\\n    def enqueue(self, val):\\n        count = 1\\n        while self and self[-1][0] < val:\\n            count += self.pop()[1]\\n        self.append([val, count])\\n\\n    def dequeue(self):\\n        ans = self.max()\\n        self[0][1] -= 1\\n        if self[0][1] <= 0:\\n            self.popleft()\\n        return ans\\n\\n    def max(self):\\n        return self[0][0] if self else 0\\n\\n\\nclass Solution(object):\\n    def constrainedSubsetSum(self, A, K):\\n        monoq = Monoqueue()\\n        ans = max(A)\\n        for i, x in enumerate(A):\\n            monoq.enqueue(x + max(0, monoq.max()))\\n            if i >= K:\\n                ans = max(ans, monoq.dequeue())\\n        return max(ans, monoq.dequeue())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Monoqueue(collections.deque):\\n    def enqueue(self, val):\\n        count = 1\\n        while self and self[-1][0] < val:\\n            count += self.pop()[1]\\n        self.append([val, count])\\n\\n    def dequeue(self):\\n        ans = self.max()\\n        self[0][1] -= 1\\n        if self[0][1] <= 0:\\n            self.popleft()\\n        return ans\\n\\n    def max(self):\\n        return self[0][0] if self else 0\\n\\n\\nclass Solution(object):\\n    def constrainedSubsetSum(self, A, K):\\n        monoq = Monoqueue()\\n        ans = max(A)\\n        for i, x in enumerate(A):\\n            monoq.enqueue(x + max(0, monoq.max()))\\n            if i >= K:\\n                ans = max(ans, monoq.dequeue())\\n        return max(ans, monoq.dequeue())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402185,
                "title": "c-4-ways-tle-tle-accepted-accepted",
                "content": "```\\n//Approach-1 (Recursion+Memo) - TLE (18 / 25 test cases passed)\\n/*\\n\\tYou should always start from an approach like this for \\n\\tany DP problem.\\n*/\\nclass Solution {\\npublic:\\n    int k, n;\\n    unordered_map<string, int> mp;\\n    int solve(vector<int>& nums, int idx, int lastIdx) {\\n        if(idx >= n) return 0;\\n        string key = to_string(idx) + \"_\" + to_string(lastIdx);\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        if(lastIdx == -1) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        } else if(idx-lastIdx <= k) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        }\\n        \\n        return mp[key] = 0;\\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        this->n = nums.size();\\n        this->k = k;\\n        int val = solve(nums, 0, -1);\\n        mp.clear();\\n        \\n        if(val == 0)\\n            return *max_element(begin(nums), end(nums));\\n        return val;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Bottom Up DP) - TLE (20 / 25 test cases passed)\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        for(int i = 0; i<n; i++)\\n            t[i] = nums[i];\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            for(int j = i-1; i-j <= k && j >= 0; j--) {\\n                t[i] = max(t[i], nums[i] + t[j]);\\n            }\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Using Priority_queue) Accepted\\n/*\\n\\tBasically in approach-2, you want the maximum value in the range of [i, i-k]\\n\\tWhy not store them in max heap and access them in one go\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            while(!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\\n\\n```\\n//Approach-4 (Using monotonic decreasing deque) Accepted\\n/*\\n\\t\\tThis is similar to approach-3 it\\'s just we use deque and maintain decreasing order.\\n\\t\\tNOTE : Approach-3 and Approach-4 are used to solve \"Sliding Window Maximum\" also with similar approach (Leetcode-239)\\n\\t\\tLink : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Sliding%20Window/Sliding%20Window%20Maximum.cpp\\n*/\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> deq;\\n        vector<int> t(nums);\\n        int maxR = t[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            while(!deq.empty() && deq.front() < i-k)\\n                deq.pop_front();\\n            \\n            if(!deq.empty())\\n                t[i] = max(t[i], nums[i] + t[deq.front()]);\\n            \\n            //we maintain the deque in descending order\\n            while(!deq.empty() && t[i] >= t[deq.back()])\\n                deq.pop_back();\\n            \\n            deq.push_back(i);\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        return maxR;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Recursion+Memo) - TLE (18 / 25 test cases passed)\\n/*\\n\\tYou should always start from an approach like this for \\n\\tany DP problem.\\n*/\\nclass Solution {\\npublic:\\n    int k, n;\\n    unordered_map<string, int> mp;\\n    int solve(vector<int>& nums, int idx, int lastIdx) {\\n        if(idx >= n) return 0;\\n        string key = to_string(idx) + \"_\" + to_string(lastIdx);\\n        if(mp.count(key))\\n            return mp[key];\\n        \\n        if(lastIdx == -1) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        } else if(idx-lastIdx <= k) {\\n            int taken    = nums[idx] + solve(nums, idx+1, idx);\\n            int notTaken = solve(nums, idx+1, lastIdx);\\n            return mp[key] = max(taken, notTaken);\\n        }\\n        \\n        return mp[key] = 0;\\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        this->n = nums.size();\\n        this->k = k;\\n        int val = solve(nums, 0, -1);\\n        mp.clear();\\n        \\n        if(val == 0)\\n            return *max_element(begin(nums), end(nums));\\n        return val;\\n    }\\n};\\n```\n```\\n//Approach-2 (Bottom Up DP) - TLE (20 / 25 test cases passed)\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        for(int i = 0; i<n; i++)\\n            t[i] = nums[i];\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            for(int j = i-1; i-j <= k && j >= 0; j--) {\\n                t[i] = max(t[i], nums[i] + t[j]);\\n            }\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\n```\\n//Approach-3 (Using Priority_queue) Accepted\\n/*\\n\\tBasically in approach-2, you want the maximum value in the range of [i, i-k]\\n\\tWhy not store them in max heap and access them in one go\\n*/\\n\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            \\n            while(!pq.empty() && pq.top().second < i - k)\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```\n```\\n//Approach-4 (Using monotonic decreasing deque) Accepted\\n/*\\n\\t\\tThis is similar to approach-3 it\\'s just we use deque and maintain decreasing order.\\n\\t\\tNOTE : Approach-3 and Approach-4 are used to solve \"Sliding Window Maximum\" also with similar approach (Leetcode-239)\\n\\t\\tLink : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Sliding%20Window/Sliding%20Window%20Maximum.cpp\\n*/\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        deque<int> deq;\\n        vector<int> t(nums);\\n        int maxR = t[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            \\n            while(!deq.empty() && deq.front() < i-k)\\n                deq.pop_front();\\n            \\n            if(!deq.empty())\\n                t[i] = max(t[i], nums[i] + t[deq.front()]);\\n            \\n            //we maintain the deque in descending order\\n            while(!deq.empty() && t[i] >= t[deq.back()])\\n                deq.pop_back();\\n            \\n            deq.push_back(i);\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        return maxR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597714,
                "title": "python-simple-explanation-heap-solution",
                "content": "Recommended reading: https://en.wikipedia.org/wiki/Heap_(data_structure)\\n\\nAt first glance, this seems easy. All you need to do is use dynamic programming to keep track of the largest subset sum ending at, and including index i for 0 <= i < len(nums) (we\\'ll call this dp[i]), and return the maximum value out of them. However, calculating the best subset sum for every i requires looking back at previous value dp[j] for i - k <= j < i. This is no good, because if k is too big, this solution is basically O(N**2). That\\'ll give you a TLE.\\n\\nInstead of that, maintain a max heap of the values that would be in dp. In this heap, include the index that this value corresponds to. So, instead of an array dp, you\\'d have a heap filled with (dp[i], i). At each iteration \\'i\\', make sure the current maximum is within k indices from i. If it isn\\'t, pop from the heap until it is.\\n\\nNote that the max heap functions of heapq are slow for some reason, so I instead keep a min heap and multiply each dp[i] by -1 to compensate for that. I got a TLE when I tried using the max heap functions for some reason! Isn\\'t that weird?\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\timport heapq\\n\\n\\theap = [(-nums[0], 0)]\\n\\tret = nums[0]\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tremove = i - k - 1\\n\\t\\twhile remove >= heap[0][1]:\\n\\t\\t\\theapq.heappop(heap)\\n\\n\\t\\tcur = max(0, -heap[0][0]) + nums[i]\\n\\t\\tret = max(ret, cur)\\n\\t\\theapq.heappush(heap, (-cur, i))\\n\\n\\treturn ret\\n```",
                "solutionTags": [],
                "code": "```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\timport heapq\\n\\n\\theap = [(-nums[0], 0)]\\n\\tret = nums[0]\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tremove = i - k - 1\\n\\t\\twhile remove >= heap[0][1]:\\n\\t\\t\\theapq.heappop(heap)\\n\\n\\t\\tcur = max(0, -heap[0][0]) + nums[i]\\n\\t\\tret = max(ret, cur)\\n\\t\\theapq.heappush(heap, (-cur, i))\\n\\n\\treturn ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597767,
                "title": "cpp-8-line-dp-solution-easy-to-understand",
                "content": "This is a O(N log N) solution.\\n\\nNot so fast, but easy to understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // dp[i] is the max subset sum which ENDING AT i\\n        vector<int> dp(nums.size());\\n        // window contains dp[i - k:i] and a additional 0.\\n        multiset<int> window = {0};\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // dp[i] = nums[i] + max(0, dp[i - k: i])\\n            dp[i] = nums[i] + *window.rbegin();\\n            // update window.\\n            window.insert(dp[i]);\\n            if(i >= k) window.erase(window.find(dp[i - k]));\\n        }\\n        \\n        // return max(dp)\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // dp[i] is the max subset sum which ENDING AT i\\n        vector<int> dp(nums.size());\\n        // window contains dp[i - k:i] and a additional 0.\\n        multiset<int> window = {0};\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            // dp[i] = nums[i] + max(0, dp[i - k: i])\\n            dp[i] = nums[i] + *window.rbegin();\\n            // update window.\\n            window.insert(dp[i]);\\n            if(i >= k) window.erase(window.find(dp[i - k]));\\n        }\\n        \\n        // return max(dp)\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736798,
                "title": "python-thought-process-recursion-memoization-tabulation-monoqueue",
                "content": "In this post, I\\'ll describe my thought process behind solving this question. I will start with a naive recursive solution and improve it to the optimal O(n) solution using DP + monoqueue.\\n\\n**1. Recursion**\\n\\nLet\\'s say that `nums[j]` is the **last** number in the required subsequence. Since we need to maximize the sum of the numbers in the subsequence, the previous number in the subsequence could be `max(nums[j-1], nums[j-2], ..., nums[j-i], ..., nums[j-k])` where `j-i >= 0`. However, if all `nums[j-1], nums[j-2], ..., nums[j-i], ..., nums[j-k]` are negative, there would be no previous number, as it would lower the required sum.\\n\\nLet `F(j)` denote the maximum sum of the subsequence with `nums[j]` as the last number. Following the idea above, `F(j) = nums[j] + max(0, F(j-1), F(j-2), ..., F(j-i), ... F(j-k))` where `j-i >= 0`. Note that if all of the valid `F(j-1), F(j-2), ..., F(j-i), ... F(j-k)` are negative, we will not choose any of these values because choosing one of them would lower the value of the required sum: hence we have a `0` in the `max` term. Since the solution to this problem is built off of solutions to the subproblems, we formuate a recursive solution.\\n\\nFor each `j` in the range `[0, len(nums)-1]`, inclusive, we will call `F(j)`, i.e, we consider every `j` as a potential last index of the subsequence. The required answer will be the max of all such `F(j)`.\\n\\nNote that this solution can also be formulated in a forward direction instead of going backwards. E.g. `F(i) = nums[i] + max(0, F(i+1), F(i+2), ... F(i+j), ..., F(i+k)` where `i+j < len(nums)` and `F(i)` denotes the maximum sum of the suquence with `nums[i]` as the **first** element. The reason why I chose to go backwards is because it is easier to convert it to an iterative approach as explained later.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\\n\\n**Time complexity: O(k^n) (TLE)**\\n**Space complexity: O(n)**\\n\\nThe recurrence relation is,\\n```\\nF(n) = F(n-1) + F(n-2) + ... + F(n-k)\\n.\\n.\\n.\\nF(0) = 1\\n```\\nIf you draw a recursion tree, it will be a `k-ary` tree with depth `n`, where `n` is the length of `nums`. The time complexity is the number of nodes in this tree, `O(k^n)`. The space complexity is the depth of this tree (recursion stack), `O(n)`.\\n\\n**2. Memoization**\\n\\nThe above solution has multiple calls to `F(j)` with the same `j`. To avoid exponential growth, we can store these intermediate results and retrieve them from memory next time the function is called with the same `j`. This is called Memoization (not Memorization), and it is a way of doing dynamic programming. A really convenient way to do memoization in Python is using the decorator `lru_cache`.\\n\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        @lru_cache(maxsize=None) # add this line to the previous solution\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\\n\\n**Time complexity: O(nk) (TLE)**\\n**Space complexity: O(n)**\\n\\nBy doing memoization, `F(j)` is processed at most once, where `j` is in the range `[0, n-1]`, inclusive. To determine each `F(j)`, we recursively call `F(j-1), F(j-2), ..., F(j-i), ... F(j-k)`. Hence, for each `F(j)`, we do `k` amount of work. Think of it as using a for loop with `k` iterations. Since there are `n` such calls to `F(j)` as described previously, we do `n*k` amount of work overall. Hence, the time complexity is `O(nk)`. The space complexity has two components: recursion stack and the memory used for memoization. Together, they require `2*n` amount of space. Hence the space complexity remains linear, `O(n)`.\\n\\n**3. Tabulation**\\n\\nWe can use an iterative approach for the above solution. Tabulation is another (iterative) way of doing dynamic programming. We create a list called `dp` with size `n` and initialize it with zeros. Here, `dp[j]` represents the maximum sum of the subsequence with `nums[j]` as the last element. Using the same idea described in the above solutions, `dp[j] = nums[j] + max(0, dp[j-1], dp[j-2], ..., dp[j-i], ..., dp[j-k])`, where `j-i >= 0`. To start with, we set `dp[0] = nums[0]`, this is our initial condition. For each `j` in the range `[1, n-1]`, inclusive, we determine `dp[j]`. The final answer is the max of all such `dp[j]`.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        ans = dp[0]\\n        for j in range(1, len(nums)):\\n\\t\\t\\t# use max(0, j-k) in the range to keep the index within bounds\\n            for i in reversed(range(max(0, j-k), j)):\\n                dp[j] = max(dp[j], dp[i])\\n            dp[j] += nums[j]\\n            ans = max(ans, dp[j])\\n        return ans\\n```\\n\\n**Time complexity: O(nk) (TLE)**\\n**Space complexity: O(n)**\\n\\nThe time and space complexity is the same as the memoization solution. Perhaps, the time complexity of the memoization solution can be better understood after relating it to this solution. The space complexity is `O(n)` due to the `dp` list. We can modify the code a little and improve it to `O(k)`, since we care only about the previous `k` elements of `dp` at a time. Or we can avoid using a `dp` list and update the `nums` list directly to make it `O(1)`.\\n\\n**4. Tabulation with Monoqueue**\\n\\nTo understand this approach, I highly recommend you to solve [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) first. In the previous approach, we determine `dp[j]` by finding the maximum of the previous `k` elements of `dp`. The bottleneck of the previous approach is iterating `k` times for each `j` to find this maximum, resulting in `O(nk)` time complexity. This can be avoided by using a monoqueue: a monotonically decreasing (or increasing in some cases) queue. Essentially, we use the sliding window maximum approach on the `dp` list. The gist of this approach is figuring out the following:\\n\\nLet\\'s say we want to determine `dp[j]`. Consider the window `dp[j-k] to dp[j-1]`. There are two indexes in this window, `p` and `q`, where `p` < `q`.\\n1. `nums[p] < nums[q]`. In this case, `nums[p]` is no longer a candidate for the maximum since we have found `nums[q]`, which is greater than `nums[p]`, within the window. So we can discard `nums[p]`.\\n2. `nums[p] >= nums[q]`. In this case, `nums[p]` **is** a candidate for the maximum. But we also need to keep track of `nums[q]` because it might become a candidate later when `p` goes out of the window. Note that index `q` comes after index `p`, therefore, as the window slides forward (while determining `dp[j+1], dp[j+2], ..., dp[n-1]`), we will lose `p` first.\\n\\nFrom the above points, it is evident that we need to keep track of monotonically decreasing numbers.\\n\\nWhile keeping track of such numbers, if the largest number (the first number in this monotonically decreasing list) goes out of the window for a certain `dp[j]`, we need to remove it from the beginning of the list. Hence we use a monoqueue (and not a monostack).\\n\\nThat being said, we maintain a monoqueue while determining each `dp[j]`. For each `j` in the range `[1, n-1]`, inclusive, we check whether the first element of the queue is within the window. If not, then we pop it from the beginning. If yes, then this element is, indeed, the maximum within the window due to the monoqueue property. Thus `dp[j] = nums[j] + max(0, queue[0])`. Now, we add this `dp[j]` to the monoqueue while maintaining its property by removing all the elements less than `dp[j]` from the end of the queue. As before, the final answer is the max of all `dp[j]`.\\n\\nHere is the code:\\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \\n        ans = dp[0]\\n        \\n\\t\\t# queue holds the index\\n        queue = deque([0])\\n        \\n        for j in range(1, len(nums)):\\n            if queue and queue[0] < j-k:\\n                queue.popleft()\\n            \\n            dp[j] = nums[j] + max(0, dp[queue[0]])\\n            \\n            while queue and dp[queue[-1]] < dp[j]:\\n                queue.pop()\\n            \\n            queue.append(j)\\n            ans = max(ans, dp[j])\\n        \\n        return ans\\n```\\n\\n**Time complexity: O(n)**\\n**Space complexity: O(n)**\\n\\nThis monoqueue takes care of the unnecessary `k` iterations in the previous approach and reduces the time complexity to `O(n)`, since each element is added and popped out of the queue at most once. The space complexity is `O(k)` due to queue and `O(n)` due to the `dp` list. It can be reduced to `O(k)` by directly updating the `nums` list instead of creating a `dp` list.\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\n```\\nF(n) = F(n-1) + F(n-2) + ... + F(n-k)\\n.\\n.\\n.\\nF(0) = 1\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        @lru_cache(maxsize=None) # add this line to the previous solution\\n        def helper(j):\\n            if j < 0:\\n                return 0\\n            \\n            max_val = 0\\n            for i in range(1, k+1):\\n                max_val = max(max_val, helper(j-i))\\n            \\n            return nums[j]+max_val\\n        \\n        ans = float(\"-inf\")\\n        for i in range(len(nums)):\\n            ans = max(ans, helper(i))\\n        return ans\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        ans = dp[0]\\n        for j in range(1, len(nums)):\\n\\t\\t\\t# use max(0, j-k) in the range to keep the index within bounds\\n            for i in reversed(range(max(0, j-k), j)):\\n                dp[j] = max(dp[j], dp[i])\\n            dp[j] += nums[j]\\n            ans = max(ans, dp[j])\\n        return ans\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \\n        ans = dp[0]\\n        \\n\\t\\t# queue holds the index\\n        queue = deque([0])\\n        \\n        for j in range(1, len(nums)):\\n            if queue and queue[0] < j-k:\\n                queue.popleft()\\n            \\n            dp[j] = nums[j] + max(0, dp[queue[0]])\\n            \\n            while queue and dp[queue[-1]] < dp[j]:\\n                queue.pop()\\n            \\n            queue.append(j)\\n            ans = max(ans, dp[j])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597768,
                "title": "cpp-monotonic-deque-solution",
                "content": "let dp[i] = the maximum sum of the subset using A[i] as the ending number\\n\\ndp[i] = max(A[i], dp[i - 1] + A[i], dp[i - 2] + A[i] ... dp[i - k] + A[i]);\\n\\nso we can easily have a O(N* k) solution, which won\\'t work in this problem (TLE I guess)\\n\\nThe dp[i - 1] ... dp[i - k] is actually a sliding window.\\n\\nAnd we can use the solution of [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) to solve it\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\n    int constrainedSubsetSum(vector<int> A, int k) {\\n\\t\\tdeque<int> mono;\\n\\t\\tint n = A.size();\\n\\t\\tvector<int> dp(n, 0);\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (mono.size() && mono.front() < i - k)\\n\\t\\t\\t\\tmono.pop_front();\\n\\t\\t\\tint max_cur = mono.size() ? dp[mono.front()] : 0;\\n\\t\\t\\tdp[i] = max(max_cur,0) + A[i];\\n\\t\\t\\twhile (!mono.empty() && dp[i] > dp[mono.back()]) {\\n\\t\\t\\t\\tmono.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tmono.push_back(i);\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int> A, int k) {\\n\\t\\tdeque<int> mono;\\n\\t\\tint n = A.size();\\n\\t\\tvector<int> dp(n, 0);\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (mono.size() && mono.front() < i - k)\\n\\t\\t\\t\\tmono.pop_front();\\n\\t\\t\\tint max_cur = mono.size() ? dp[mono.front()] : 0;\\n\\t\\t\\tdp[i] = max(max_cur,0) + A[i];\\n\\t\\t\\twhile (!mono.empty() && dp[i] > dp[mono.back()]) {\\n\\t\\t\\t\\tmono.pop_back();\\n\\t\\t\\t}\\n\\t\\t\\tmono.push_back(i);\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598467,
                "title": "javascript-sliding-window-o-n-time-and-o-k-space",
                "content": "#### Follow the comments for the algorithm :-\\n\\n```\\n//have a window array that should not exceed the size k\\n//store index and lastKsum in that window array, initialize \"max\" to nums[0] \\n//for nums length iterate over array, extract first elememt of window (index, lastKsum)\\n//check if window is in bound of k size.\\n//if not shift the first element out\\n//calculate the newsum which would be lastKsum/0 + nums[i]\\n//calcute max from max and newsum\\n//pop out the elements from window till their lastKsum is less than new sum or the window is empty\\n//push the index and new sum to window\\n//return max\\n\\nvar constrainedSubsetSum = function(nums, k) {\\n    var window = [[0,nums[0]]];\\n    var max = nums[0];\\n    for(var i=1; i<nums.length; i++){\\n        var [index,lastKsum] = window[0];\\n        if(index == i-k){\\n            window.shift();\\n        }\\n        var sum = Math.max(lastKsum, 0) + nums[i]\\n        max = Math.max(max, sum);\\n        while(window.length>0 && window[window.length-1][1] < sum){\\n            window.pop();\\n        }\\n        window.push([i,sum]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n//have a window array that should not exceed the size k\\n//store index and lastKsum in that window array, initialize \"max\" to nums[0] \\n//for nums length iterate over array, extract first elememt of window (index, lastKsum)\\n//check if window is in bound of k size.\\n//if not shift the first element out\\n//calculate the newsum which would be lastKsum/0 + nums[i]\\n//calcute max from max and newsum\\n//pop out the elements from window till their lastKsum is less than new sum or the window is empty\\n//push the index and new sum to window\\n//return max\\n\\nvar constrainedSubsetSum = function(nums, k) {\\n    var window = [[0,nums[0]]];\\n    var max = nums[0];\\n    for(var i=1; i<nums.length; i++){\\n        var [index,lastKsum] = window[0];\\n        if(index == i-k){\\n            window.shift();\\n        }\\n        var sum = Math.max(lastKsum, 0) + nums[i]\\n        max = Math.max(max, sum);\\n        while(window.length>0 && window[window.length-1][1] < sum){\\n            window.pop();\\n        }\\n        window.push([i,sum]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005863,
                "title": "dp-sliding-window-maximum-video-explanation-cpp",
                "content": "To understand this question, please implement [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) (it will increase your count of another hard problem!!). Solution to this is explained very clearly by Aditya Verma on his YT channel [here](https://www.youtube.com/watch?v=xFJXtB5vSmM&t=2035s)\\n\\nFor English, you can refer this video by Pepcoding [here](https://www.youtube.com/watch?v=TCHSXAu5pls)\\n\\nOnce completely undertanding the above solution, this solution can be seen as a variation of that problem with the following main differences:\\n1. Here we find the maximum from the dp array while in the original question we find maximum in the given array\\n2. Here the window excludes the current element (j) while finding the maximum. (We find the maximum in dp array k elements before j and take a decision whether to add that maxValue to the nums[j] and store it in the dp array or simple store nums[j] (`dp[j] = max(nums[j], nums[j]+maxValue)`)\\n\\nFinally, we find the maximum value in this dp array and return that.\\n\\n```\\n// Using Sliding Window Maximum + DP\\n// We create a dp array. At each point we fill the dp[j] by finding the maximum of\\n// window size k before j (excluding j).\\n// i.e. dp[j] = max(nums[j], nums[j] + maxValue)\\n// the maxValue is represented by the front of the deque (q.front())\\n// At the end, we find the max in the dp array and return.\\n\\n// To understand how Sliding Window Maximum works, video link is given above.\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        \\n        int i = 0;\\n        int j = 0;\\n    \\n        deque<int> q;\\n        while(j<nums.size()){\\n            if (q.empty()){\\n                dp[j] = nums[j];\\n                q.push_back(j);\\n            }else{\\n                dp[j] = max(nums[j], nums[j] + dp[q.front()]);\\n                while(!q.empty() && dp[q.back()]<dp[j]){\\n                    q.pop_back();\\n                }\\n                q.push_back(j);\\n            }\\n            \\n            if (j-i<k){\\n                j++;\\n            }else{\\n                if(!q.empty() && q.front() == i){\\n                    q.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        int mx = INT_MIN;\\n        \\n        for (auto i: dp){\\n            mx = max(mx, i);\\n        }\\n        \\n        \\n        return mx;\\n        \\n    }\\n};\\n```\\n\\nLet me know if you have any doubts.\\n\\nBonus: [Jump Game VI](https://leetcode.com/problems/jump-game-vi/) is also a variation of Sliding Window Maximum and very similar to this one. Try and implement that as well. (only one line of code change to this code).\\n\\nHope this helps!! \\n\\nPlease Upvote. Thanks!",
                "solutionTags": [],
                "code": "```\\n// Using Sliding Window Maximum + DP\\n// We create a dp array. At each point we fill the dp[j] by finding the maximum of\\n// window size k before j (excluding j).\\n// i.e. dp[j] = max(nums[j], nums[j] + maxValue)\\n// the maxValue is represented by the front of the deque (q.front())\\n// At the end, we find the max in the dp array and return.\\n\\n// To understand how Sliding Window Maximum works, video link is given above.\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        \\n        int i = 0;\\n        int j = 0;\\n    \\n        deque<int> q;\\n        while(j<nums.size()){\\n            if (q.empty()){\\n                dp[j] = nums[j];\\n                q.push_back(j);\\n            }else{\\n                dp[j] = max(nums[j], nums[j] + dp[q.front()]);\\n                while(!q.empty() && dp[q.back()]<dp[j]){\\n                    q.pop_back();\\n                }\\n                q.push_back(j);\\n            }\\n            \\n            if (j-i<k){\\n                j++;\\n            }else{\\n                if(!q.empty() && q.front() == i){\\n                    q.pop_front();\\n                }\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        int mx = INT_MIN;\\n        \\n        for (auto i: dp){\\n            mx = max(mx, i);\\n        }\\n        \\n        \\n        return mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 818658,
                "title": "java-3-approaches-well-commented-brute-force-o-nk-treemap-o-nlogk-sliding-deque-o-n",
                "content": "```\\n/**\\n * Approach: Extension of treeMap solution. Instead of using treeMap, used a monotonic increasing queue to keep track of sliding maximum\\n * TimeComplexity: O(n)\\n */\\npublic int constrainedSubsetSumUsingDeque(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tArrayDeque<Integer> queue = new ArrayDeque<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (queue.isEmpty() ? 0 : queue.peekFirst()));\\n\\t\\twhile (!queue.isEmpty() && queue.peekLast() < dp[i]) {\\n\\t\\t\\t//remove all elements smaller than dp[i]\\n\\t\\t\\tqueue.pollLast();\\n\\t\\t}\\n\\t\\tqueue.add(dp[i]);\\n\\t\\tif (i >= k && dp[i - k] == queue.peekFirst()) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window, also pollFirst() only if the value equals the prefix sum falling outside the window\\n\\t\\t\\t// because there is a chance that it has already been polled\\n\\t\\t\\tqueue.pollFirst();\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: Extension of brute force approach, instead of iterating over the past k indices to find the max,\\n * store the result of the past k indices in a treeMap and use lastKey() to find the max value\\n * TimeComplexity: O(nlogk)\\n */\\npublic int constrainedSubsetSumUsingTreeMap(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t//max to handle negative lastKey()\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (map.isEmpty() ? 0 : map.lastKey()));\\n\\t\\tmap.put(dp[i], map.getOrDefault(dp[i], 0) + 1);\\n\\t\\tif (i >= k) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window\\n\\t\\t\\tint key = dp[i - k];\\n\\t\\t\\tint val = map.get(key);\\n\\t\\t\\tif (val == 1) {\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(key, val - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: For every index i, check the result of the previous i-k indexes and update the result at dp[i]\\n * Basically need to find the maximum for the previous k indexes in order to compute the result for dp[i]\\n * Time Complexity: O(n*k)\\n */\\npublic int constrainedSubsetSumBruteForceTLE(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = nums[i];\\n\\t\\tint maxOffset = i - k;\\n\\t\\tfor (int j = i - 1; j >= 0 && j >= maxOffset; j--) {\\n\\t\\t\\tdp[i] = Math.max(dp[i], nums[i] + dp[j]);\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Approach: Extension of treeMap solution. Instead of using treeMap, used a monotonic increasing queue to keep track of sliding maximum\\n * TimeComplexity: O(n)\\n */\\npublic int constrainedSubsetSumUsingDeque(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tArrayDeque<Integer> queue = new ArrayDeque<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (queue.isEmpty() ? 0 : queue.peekFirst()));\\n\\t\\twhile (!queue.isEmpty() && queue.peekLast() < dp[i]) {\\n\\t\\t\\t//remove all elements smaller than dp[i]\\n\\t\\t\\tqueue.pollLast();\\n\\t\\t}\\n\\t\\tqueue.add(dp[i]);\\n\\t\\tif (i >= k && dp[i - k] == queue.peekFirst()) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window, also pollFirst() only if the value equals the prefix sum falling outside the window\\n\\t\\t\\t// because there is a chance that it has already been polled\\n\\t\\t\\tqueue.pollFirst();\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: Extension of brute force approach, instead of iterating over the past k indices to find the max,\\n * store the result of the past k indices in a treeMap and use lastKey() to find the max value\\n * TimeComplexity: O(nlogk)\\n */\\npublic int constrainedSubsetSumUsingTreeMap(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\t//max to handle negative lastKey()\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + (map.isEmpty() ? 0 : map.lastKey()));\\n\\t\\tmap.put(dp[i], map.getOrDefault(dp[i], 0) + 1);\\n\\t\\tif (i >= k) {\\n\\t\\t\\t//need to remove the prefix sum falling out of the window\\n\\t\\t\\tint key = dp[i - k];\\n\\t\\t\\tint val = map.get(key);\\n\\t\\t\\tif (val == 1) {\\n\\t\\t\\t\\tmap.remove(key);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmap.put(key, val - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n\\n/**\\n * Approach: For every index i, check the result of the previous i-k indexes and update the result at dp[i]\\n * Basically need to find the maximum for the previous k indexes in order to compute the result for dp[i]\\n * Time Complexity: O(n*k)\\n */\\npublic int constrainedSubsetSumBruteForceTLE(int[] nums, int k) {\\n\\tint n = nums.length;\\n\\tint[] dp = new int[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i] = nums[i];\\n\\t\\tint maxOffset = i - k;\\n\\t\\tfor (int j = i - 1; j >= 0 && j >= maxOffset; j--) {\\n\\t\\t\\tdp[i] = Math.max(dp[i], nums[i] + dp[j]);\\n\\t\\t}\\n\\t}\\n\\treturn Arrays.stream(dp).max().getAsInt();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 668769,
                "title": "java-dp-and-arraydeque",
                "content": "version 1:\\nPure DP, TLE\\ndp[i] means results based on first half of array ending with i, but must contains i in the subsequence;\\nit will be easy to get dp[j] based on dp[i], where j - k <= i < j;\\n```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = nums[i];\\n            for (int j = 1; j <= k && i - j >= 0; j++) dp[i] = Math.max(dp[i], dp[i - j] + nums[i]);\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n```\\n\\nVersion 2, \\nWe are only interested in the max of a slinding window, that is, max dp from dp[i], where j - k <= i < j.\\nSounds familiar? Right, we can use  deque to:\\n1, Maintain a mono decreasing queue then apply DP;\\n2, Use a Deque to optimize, where we just need to get the max dp from dp[i], where j - k <= i < j;\\nRef; https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC%2B%2BPython-O(N)-Decreasing-Deque\\n```\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = nums[i] + (dq.isEmpty() ? 0 : dp[dq.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while (!dq.isEmpty() && dp[i] >= dp[dq.peekLast()]) dq.pollLast();\\n            if (dp[i] > 0) dq.offer(i);\\n            while (i >= k && !dq.isEmpty() && dq.peek() <= i - k) dq.poll();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i] = nums[i];\\n            for (int j = 1; j <= k && i - j >= 0; j++) dp[i] = Math.max(dp[i], dp[i - j] + nums[i]);\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int res = dp[0];\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = nums[i] + (dq.isEmpty() ? 0 : dp[dq.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while (!dq.isEmpty() && dp[i] >= dp[dq.peekLast()]) dq.pollLast();\\n            if (dp[i] > 0) dq.offer(i);\\n            while (i >= k && !dq.isEmpty() && dq.peek() <= i - k) dq.poll();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597761,
                "title": "simple-sliding-window-solution-based-on-sliding-window-maximum-python",
                "content": "It is really similar to the [Sliding Window Maximum Problem](https://leetcode.com/problems/sliding-window-maximum). \\n\\nWe would use a double ended queue to store the maximum sums in last K indices.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        d = collections.deque([(0, nums[0])])\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            idx, lastKSumMax = d[0]\\n            if idx == i - k:\\n                d.popleft()\\n            newSum = max(lastKSumMax, 0) + nums[i]\\n            ans = max(ans, newSum)\\n            while d and d[-1][1] < newSum:\\n                d.pop()\\n            d.append((i, newSum))\\n        return ans\\n```\\n\\nTake `[10, -2, -10, -5, 20], k=2` as an example,\\n\\n1. First, we have `[(0, 10)]` as deque initialization,\\n2. Then with `-2`, we have a newSum `8` and push it to our deque. Our deque would be `[(0, 10), (1, 8)]`,\\n3. Then with `-10`, we have a newSum `0`, this time we need to do a `popleft` operation as the sum at index `0` should not be used anymore in the future calculation. Again, our deque would be `[(1, 8), (2, 0)]`,\\n4. With `-5`, we have a newSum `3`, and again we need to do a `popleft` operation. We also need to pop `(2, 0)` as `3 > 0`(we would never use the sum at index `2` as the sum at index `3` is greater than it. Our deque would be `[(3, 3)]`,\\n5. With `20` we have newSum `23`, and our deque would be `[(4, 23)]`.\\n\\nThe answer would be 23 as it is the biggest newSum. \\n\\nThe time complexity should be just `O(N)`, and space complexity is `O(K)`. \\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        d = collections.deque([(0, nums[0])])\\n        ans = nums[0]\\n        for i in range(1, len(nums)):\\n            idx, lastKSumMax = d[0]\\n            if idx == i - k:\\n                d.popleft()\\n            newSum = max(lastKSumMax, 0) + nums[i]\\n            ans = max(ans, newSum)\\n            while d and d[-1][1] < newSum:\\n                d.pop()\\n            d.append((i, newSum))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597924,
                "title": "java-monotonic-decreasing-deque-o-n",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> dq = new LinkedList();\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            int firstIndex = dq.isEmpty() ? -1 : dq.peekFirst();\\n            int prevMax = firstIndex==-1 ? 0 : dp[firstIndex];\\n            dp[i] = prevMax+nums[i];\\n            res = Math.max(res, dp[i]);\\n            if(firstIndex<=i-k){\\n                dq.pollFirst();\\n            }\\n            while(!dq.isEmpty() && dp[i]>=dp[dq.peekLast()]){\\n                dq.pollLast();\\n            }\\n            if(dp[i]>0) dq.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        Deque<Integer> dq = new LinkedList();\\n        int res = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            int firstIndex = dq.isEmpty() ? -1 : dq.peekFirst();\\n            int prevMax = firstIndex==-1 ? 0 : dp[firstIndex];\\n            dp[i] = prevMax+nums[i];\\n            res = Math.max(res, dp[i]);\\n            if(firstIndex<=i-k){\\n                dq.pollFirst();\\n            }\\n            while(!dq.isEmpty() && dp[i]>=dp[dq.peekLast()]){\\n                dq.pollLast();\\n            }\\n            if(dp[i]>0) dq.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597736,
                "title": "c-dp-with-multiset-o-n-lg-k-with-monotone-deque-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n log k)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        multiset<int> prevs({sums[0][1]});\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            int temp = max(0, *prevs.rbegin()) + nums[i];\\n            if (i >= k) prevs.erase(sums[i % k][1]);\\n            sums[i % k][1] = temp;\\n            prevs.insert(sums[i % k][1]);\\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```\\n\\nThanks for the idea of maintaining a monotone deque from other posts. The time complexity is further reduced to O(N).\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        deque<int> dq({0}); // store indices of sums[index][1]\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            sums[i % k][1] = max(0, dq.empty() ? 0 : sums[dq.front() % k][1]) + nums[i];\\n\\t\\t\\t\\n            // store at most k indices\\n            while (!dq.empty() && dq.front() <= i - k)\\n                dq.pop_front();\\n\\t\\t\\t\\n\\t\\t\\t// maintain the decreasing order\\n            while (!dq.empty() && sums[dq.back() % k][1] <= sums[i % k][1])\\n                dq.pop_back();\\n            \\n\\t\\t\\t// update if the current sum is positive\\n\\t\\t\\tif (sums[i % k][1] > 0)\\n                dq.push_back(i);\\n            \\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n log k)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        multiset<int> prevs({sums[0][1]});\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            int temp = max(0, *prevs.rbegin()) + nums[i];\\n            if (i >= k) prevs.erase(sums[i % k][1]);\\n            sums[i % k][1] = temp;\\n            prevs.insert(sums[i % k][1]);\\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        // Time Complexity: O(n)\\n        // Space Complexity: O(k)\\n        \\n        int n = nums.size();\\n        int sums[k][2];\\n        \\n        // 0: not choose nums[i], so we take max of sums[i-1][0], sums[i-1][1] (res from previous)\\n        // 1: choose nums[i], then have to choose between sums[i-k] and sums[i-1]\\n        \\n        sums[0][0] = 0;\\n        sums[0][1] = nums[0];\\n        \\n        bool neg = nums[0] < 0;\\n        int least = nums[0];\\n        deque<int> dq({0}); // store indices of sums[index][1]\\n        \\n        for (int i = 1; i < n; ++i) {\\n            sums[i % k][0] = max(sums[(i - 1) % k][0], sums[(i - 1) % k][1]);\\n            sums[i % k][1] = max(0, dq.empty() ? 0 : sums[dq.front() % k][1]) + nums[i];\\n\\t\\t\\t\\n            // store at most k indices\\n            while (!dq.empty() && dq.front() <= i - k)\\n                dq.pop_front();\\n\\t\\t\\t\\n\\t\\t\\t// maintain the decreasing order\\n            while (!dq.empty() && sums[dq.back() % k][1] <= sums[i % k][1])\\n                dq.pop_back();\\n            \\n\\t\\t\\t// update if the current sum is positive\\n\\t\\t\\tif (sums[i % k][1] > 0)\\n                dq.push_back(i);\\n            \\n            if (neg &= nums[i] < 0) least = max(least, nums[i]);\\n        }\\n        \\n        return neg ? least : max(sums[(n - 1) % k][0], sums[(n - 1) % k][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225612,
                "title": "c-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n      deque<pair<int,int>>dq;\\n      int ans=INT_MIN;\\n      for(int i=0;i<nums.size();i++){\\n        \\n        while(!dq.empty() && dq.front().first<i-k){\\n         dq.pop_front();\\n        } \\n        if(!dq.empty()){\\n         nums[i] = max(nums[i],nums[i]+dq.front().second);\\n        }\\n         while(!dq.empty()&&nums[i]>=dq.back().second) dq.pop_back();\\n         dq.push_back({i,nums[i]});\\n         ans=max(ans,nums[i]);\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n      deque<pair<int,int>>dq;\\n      int ans=INT_MIN;\\n      for(int i=0;i<nums.size();i++){\\n        \\n        while(!dq.empty() && dq.front().first<i-k){\\n         dq.pop_front();\\n        } \\n        if(!dq.empty()){\\n         nums[i] = max(nums[i],nums[i]+dq.front().second);\\n        }\\n         while(!dq.empty()&&nums[i]>=dq.back().second) dq.pop_back();\\n         dq.push_back({i,nums[i]});\\n         ans=max(ans,nums[i]);\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821169,
                "title": "python-using-deque-and-concept-of-dp-with-explaination-o-n",
                "content": "Observation from the question:\\nWe want to find the sequence with max sum, and the different between any two number in the sequence should not bigger than k:\\n=> suppose dp[i] means the max sum of all the valid sequences that end at nums[i]\\n=> dp[i] = max(dp[i-k] + nums[i], dp[i-k+1] +nums[i], ... ,dp[i-1] +nums[i], nums[i])\\n\\nif we use dp, the time complexity is  O(NK), but here we can use \"deque\" to improve the time complexity to  O(N).\\nwe use deque to save the information: \\nthe possible useful sequence which end with a number form A[i-k:i-1], in a decreasing order (according to the sum of the sequence)\\n(actually we save the index in deque, because we need to check the index to make sure the sequence is valid)\\nso that every time we only need O(1) to compute dp[i] instead of O(K) => dp[i] = nums[deque[0]] + nums[i]\\n\\nhere, I didn\\'t create new dp array, I just saved dp[i] directly in A[i], because we will never use A[i] again after computed dp[i]. \\nSo here, new A[i] = dp[i] = max sum of the valid sequence end at i.\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        deque = []\\n        for i, num in enumerate(nums):\\n                \\n            while(deque and deque[0] < i - k): # delete that didn\\'t end with a number in A[i-k:i]\\n                deque.pop(0)\\n                \\n            if deque:  # compute the max sum we can get at index i\\n                nums[i] = nums[deque[0]] + num\\n            \\n            while(deque and nums[deque[-1]] < nums[i]): \\n                # delet all the sequence that smaller than current sum, becaus there will never be\\n                # considers ==> smaller than current sequence, and end before current sequence\\n                deque.pop()\\n                \\n            if nums[i] > 0: # if nums[i] < 0, it can\\'t be a useful prefix sum    \\n            \\tdeque.append(i)\\n        \\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        deque = []\\n        for i, num in enumerate(nums):\\n                \\n            while(deque and deque[0] < i - k): # delete that didn\\'t end with a number in A[i-k:i]\\n                deque.pop(0)\\n                \\n            if deque:  # compute the max sum we can get at index i\\n                nums[i] = nums[deque[0]] + num\\n            \\n            while(deque and nums[deque[-1]] < nums[i]): \\n                # delet all the sequence that smaller than current sum, becaus there will never be\\n                # considers ==> smaller than current sequence, and end before current sequence\\n                deque.pop()\\n                \\n            if nums[i] > 0: # if nums[i] < 0, it can\\'t be a useful prefix sum    \\n            \\tdeque.append(i)\\n        \\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606588,
                "title": "c-solution-100-memory-70-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {   \\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        \\n        dp[0]=nums[0];\\n        q.push_back(0);\\n        int ans=dp[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {   \\n            dp[i] = max(0,dp[q.front()]) + nums[i];\\n            ans=max(ans,dp[i]);\\n            \\n            while(!q.empty() && q.front()<=i-k)  //Similar to sliding window maximum problem\\n                q.pop_front();\\n            while(!q.empty() && dp[i]>=dp[q.back()])\\n                q.pop_back();\\n            q.push_back(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {   \\n        int n = nums.size();\\n        vector<int> dp(n);\\n        deque<int> q;\\n        \\n        dp[0]=nums[0];\\n        q.push_back(0);\\n        int ans=dp[0];\\n        \\n        for(int i=1;i<n;i++)\\n        {   \\n            dp[i] = max(0,dp[q.front()]) + nums[i];\\n            ans=max(ans,dp[i]);\\n            \\n            while(!q.empty() && q.front()<=i-k)  //Similar to sliding window maximum problem\\n                q.pop_front();\\n            while(!q.empty() && dp[i]>=dp[q.back()])\\n                q.pop_back();\\n            q.push_back(i);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328738,
                "title": "dp-with-segment-tree",
                "content": "\\n```\\nclass Solution {\\npublic: \\n    int tree[4*100001] ; \\n    void update(int node, int low, int high,int val, int ind) {\\n        if(low==high) {\\n            tree[node]=val; \\n            return ; \\n        }\\n        int mid=(low+high)>>1; \\n        if(ind<=mid) {\\n            update(2*node,low,mid, val, ind)  ; \\n        }\\n        else {\\n            update(2*node+1,mid+1, high, val , ind) ; \\n        }\\n        tree[node]=max(tree[2*node],tree[2*node+1]) ; \\n    }\\n    int rangequery(int node, int low, int high, int l, int r) {\\n           if(l>high or r<low) {\\n               return 0; \\n           }\\n           if(low>=l and high<=r) {\\n               return tree[node] ; \\n           }\\n           int mid=(low+high)>>1; \\n           int left=rangequery(2*node, low, mid, l , r) ; \\n           int right=rangequery(2*node+1, mid+1, high, l, r) ; \\n           return max(left, right) ; \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n         int n=nums.size() ; ; \\n         vector<int>dp(n,-1e9) ;\\n         dp[0]=nums[0] ; \\n         update(1,0,n-1,dp[0],0) ; \\n         for(int i=1; i<n; i++) {\\n                int left=i-k; \\n                if(left<0) left=0; \\n               int  prev=rangequery(1,0,n-1,left,i-1) ; \\n               if(prev>=0) dp[i]=prev+nums[i]; \\n               else dp[i]=nums[i] ;  \\n               update(1,0,n-1,dp[i],i) ; \\n         }\\n         int res=dp[0] ; \\n         for(int i=1; i<n; i++) res=max(res , dp[i]) ; \\n         return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int tree[4*100001] ; \\n    void update(int node, int low, int high,int val, int ind) {\\n        if(low==high) {\\n            tree[node]=val; \\n            return ; \\n        }\\n        int mid=(low+high)>>1; \\n        if(ind<=mid) {\\n            update(2*node,low,mid, val, ind)  ; \\n        }\\n        else {\\n            update(2*node+1,mid+1, high, val , ind) ; \\n        }\\n        tree[node]=max(tree[2*node],tree[2*node+1]) ; \\n    }\\n    int rangequery(int node, int low, int high, int l, int r) {\\n           if(l>high or r<low) {\\n               return 0; \\n           }\\n           if(low>=l and high<=r) {\\n               return tree[node] ; \\n           }\\n           int mid=(low+high)>>1; \\n           int left=rangequery(2*node, low, mid, l , r) ; \\n           int right=rangequery(2*node+1, mid+1, high, l, r) ; \\n           return max(left, right) ; \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n         int n=nums.size() ; ; \\n         vector<int>dp(n,-1e9) ;\\n         dp[0]=nums[0] ; \\n         update(1,0,n-1,dp[0],0) ; \\n         for(int i=1; i<n; i++) {\\n                int left=i-k; \\n                if(left<0) left=0; \\n               int  prev=rangequery(1,0,n-1,left,i-1) ; \\n               if(prev>=0) dp[i]=prev+nums[i]; \\n               else dp[i]=nums[i] ;  \\n               update(1,0,n-1,dp[i],i) ; \\n         }\\n         int res=dp[0] ; \\n         for(int i=1; i<n; i++) res=max(res , dp[i]) ; \\n         return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817246,
                "title": "java-solution-using-heap-and-dynamic-programming-o-n",
                "content": "My first intuition was to solve the problem just like we solve LIS i.e by using two loops which would result in O(n2) complexity and i was quite satisfied with my solution as it passed my test cases , however on getting the TLE , i soon realized my mistake as the complexity was hitting O(n2) . \\n\\nThe thought of using a priorityqueue came when i realized that all we need between the indices [j-k<=i<j] is the max in that range , however we need to ascertain that the max we are getting is infact from the range specified .\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int res=nums[0];\\n        Queue<Integer> queue=new PriorityQueue<>((a,b)->dp[b]-dp[a]); //Declaring Max heap\\n        \\n        Arrays.fill(dp,Integer.MIN_VALUE);\\n        dp[0]=nums[0];\\n        queue.offer(0);\\n        \\n        for(int j=1;j<n;j++){\\n            int i=Math.max(j-k,0);    // get the furthest index possible \\n            while(!queue.isEmpty() && queue.peek()<i) queue.poll();     // find the global max in the specified range for that particular j index\\n            int idx=queue.peek();\\n            dp[j]=Math.max(dp[idx]+nums[j],nums[j]);\\n            res=Math.max(res,dp[j]);\\n            queue.offer(j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        int res=nums[0];\\n        Queue<Integer> queue=new PriorityQueue<>((a,b)->dp[b]-dp[a]); //Declaring Max heap\\n        \\n        Arrays.fill(dp,Integer.MIN_VALUE);\\n        dp[0]=nums[0];\\n        queue.offer(0);\\n        \\n        for(int j=1;j<n;j++){\\n            int i=Math.max(j-k,0);    // get the furthest index possible \\n            while(!queue.isEmpty() && queue.peek()<i) queue.poll();     // find the global max in the specified range for that particular j index\\n            int idx=queue.peek();\\n            dp[j]=Math.max(dp[idx]+nums[j],nums[j]);\\n            res=Math.max(res,dp[j]);\\n            queue.offer(j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566821,
                "title": "c-dp-tabulation-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int ans=-10000;\\n        int dp[n+1];\\n        \\n        dp[0]=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[i];\\n            ans=max(ans,dp[i]);\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        pq.push(make_pair(nums[0],0));\\n        for(int i=1;i<n;i++)\\n        {\\n            while(i-pq.top().second>k)\\n            {\\n                pq.pop();\\n            }\\n            dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            pq.push(make_pair(dp[i],i));\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int n=nums.size();\\n        int ans=-10000;\\n        int dp[n+1];\\n        \\n        dp[0]=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[i];\\n            ans=max(ans,dp[i]);\\n        }\\n        priority_queue<pair<int,int>>pq;\\n        pq.push(make_pair(nums[0],0));\\n        for(int i=1;i<n;i++)\\n        {\\n            while(i-pq.top().second>k)\\n            {\\n                pq.pop();\\n            }\\n            dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            pq.push(make_pair(dp[i],i));\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597906,
                "title": "java-heap",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        if(nums.length==1)return nums[0];\\n        int dp[]=new int[nums.length];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a2[1]-a1[1];\\n        });\\n        int res=Integer.MIN_VALUE;\\n        pq.add(new int[]{0,nums[0]});\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.size()!=0&&i-pq.peek()[0]>k){\\n                res=Math.max(res,pq.poll()[1]);\\n            }\\n            int cur[]=new int[]{i,nums[i]};\\n            if(pq.size()!=0){\\n                cur[1]+=Math.max(0,pq.peek()[1]);\\n                pq.add(cur);\\n            }\\n        }\\n        res=Math.max(res,pq.peek()[1]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        if(nums.length==1)return nums[0];\\n        int dp[]=new int[nums.length];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a2[1]-a1[1];\\n        });\\n        int res=Integer.MIN_VALUE;\\n        pq.add(new int[]{0,nums[0]});\\n        for(int i=1;i<nums.length;i++){\\n            while(pq.size()!=0&&i-pq.peek()[0]>k){\\n                res=Math.max(res,pq.poll()[1]);\\n            }\\n            int cur[]=new int[]{i,nums[i]};\\n            if(pq.size()!=0){\\n                cur[1]+=Math.max(0,pq.peek()[1]);\\n                pq.add(cur);\\n            }\\n        }\\n        res=Math.max(res,pq.peek()[1]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676228,
                "title": "same-as-jump-game-iv-and-sliding-window-maximum",
                "content": "Solution to Constrained Subsequence:\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n            \\n            \\n        \\n            int n = nums.size();\\n            vector<int> score = nums; // First Change Line\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n            return *max_element(score.begin(),score.end()); // Second Change Line\\n            \\n    }\\n```\\n\\n\\nSolution To Jump Game IV :\\n```\\nint maxResult(vector<int>& nums, int k) {\\n        \\n            int n = nums.size();\\n            vector<int> score(n,INT_MIN);  // See Exact Line Above\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n           // cout\\n            return score[nums.size()-1];  // See Exact Line Above\\n    }\\n```\\n\\nSolution to SLIDING WINDOW MAXIMUM\\n\\n```\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            \\n            \\n            \\n            priority_queue<pair<int,int>> pq;\\n            vector<int> ans;\\n            \\n            for(int i = 0;i<nums.size();i++){\\n                    while(!pq.empty() && pq.top().second < i - k + 1) pq.pop();\\n                    pq.push({nums[i],i});\\n                    if(pq.size() >= k){\\n                            ans.push_back(pq.top().first);\\n                    }\\n            }\\n            return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n            \\n            \\n        \\n            int n = nums.size();\\n            vector<int> score = nums; // First Change Line\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n            return *max_element(score.begin(),score.end()); // Second Change Line\\n            \\n    }\\n```\n```\\nint maxResult(vector<int>& nums, int k) {\\n        \\n            int n = nums.size();\\n            vector<int> score(n,INT_MIN);  // See Exact Line Above\\n            score[0] = nums[0];\\n            \\n            priority_queue<pair<int,int>> pq;\\n            pq.push({score[0],0});\\n            \\n            for(int i = 1;i<nums.size();i++){\\n                    \\n                    while(!pq.empty() && pq.top().second < i-k) pq.pop();\\n                    \\n                    score[i] = max(score[i],nums[i] + (pq.empty() ? 0  : pq.top().first));\\n                   \\n                    pq.push(make_pair(score[i],i));\\n                    \\n                 \\n            }\\n           // cout\\n            return score[nums.size()-1];  // See Exact Line Above\\n    }\\n```\n```\\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\\n            \\n            \\n            \\n            priority_queue<pair<int,int>> pq;\\n            vector<int> ans;\\n            \\n            for(int i = 0;i<nums.size();i++){\\n                    while(!pq.empty() && pq.top().second < i - k + 1) pq.pop();\\n                    pq.push({nums[i],i});\\n                    if(pq.size() >= k){\\n                            ans.push_back(pq.top().first);\\n                    }\\n            }\\n            return ans;\\n        \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2583565,
                "title": "c-98-faster-solution-using-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578199,
                "title": "segment-tree-o-nlogn",
                "content": "for nums[i] we have to take maximum sum in the range i-k to i-1 so to find maximu sum we have used Segment tree which gives us ths query in O(logN) time\\nand then we are updating the segment tree as nums[i]+max_sum_in_range(i-k,i-1)\\n```\\nclass SegmentTree\\n{\\n    public:\\n    vector<int> tree;\\n    int n;\\n    SegmentTree(int n)\\n    {\\n        int x=ceil(log2(n));\\n        int max_size=2*(int)pow(2,x)-1;\\n        this->n=max_size;\\n        this->tree.resize(max_size);\\n    }\\n    int query(int ql,int qr,int cl,int cr,int node){\\n        if(cl>=ql && cr<=qr){\\n            return tree[node];\\n        }\\n        if(cr<ql||cl>qr){\\n            return 0;\\n        }\\n        int mid=(cl+cr)/2;\\n        int x=query(ql,qr,cl,mid,2*node+1),y=query(ql,qr,mid+1,cr,2*node+2);\\n        return max(x,y);\\n    }\\n    void update(int idx,int val, int cl,int cr,int pos){\\n        if(pos<cl||pos>cr)return;\\n        \\n        if(cl==cr){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(cl+cr)/2;\\n        update(2*idx+1,val,cl,mid,pos);\\n        update(2*idx+2,val,mid+1,cr,pos);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        SegmentTree t(nums.size());\\n    \\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,i-k),right=max(0,i-1);\\n            int x=t.query(left,right,0,nums.size()-1,0);\\n            t.update(0,nums[i]+x,0,nums.size()-1,i);\\n        }\\n        return t.tree[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree\\n{\\n    public:\\n    vector<int> tree;\\n    int n;\\n    SegmentTree(int n)\\n    {\\n        int x=ceil(log2(n));\\n        int max_size=2*(int)pow(2,x)-1;\\n        this->n=max_size;\\n        this->tree.resize(max_size);\\n    }\\n    int query(int ql,int qr,int cl,int cr,int node){\\n        if(cl>=ql && cr<=qr){\\n            return tree[node];\\n        }\\n        if(cr<ql||cl>qr){\\n            return 0;\\n        }\\n        int mid=(cl+cr)/2;\\n        int x=query(ql,qr,cl,mid,2*node+1),y=query(ql,qr,mid+1,cr,2*node+2);\\n        return max(x,y);\\n    }\\n    void update(int idx,int val, int cl,int cr,int pos){\\n        if(pos<cl||pos>cr)return;\\n        \\n        if(cl==cr){\\n            tree[idx]=val;\\n            return;\\n        }\\n        int mid=(cl+cr)/2;\\n        update(2*idx+1,val,cl,mid,pos);\\n        update(2*idx+2,val,mid+1,cr,pos);\\n        tree[idx]=max(tree[2*idx+1],tree[2*idx+2]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        SegmentTree t(nums.size());\\n    \\n        for(int i=0;i<nums.size();i++){\\n            int left=max(0,i-k),right=max(0,i-1);\\n            int x=t.query(left,right,0,nums.size()-1,0);\\n            t.update(0,nums[i]+x,0,nums.size()-1,i);\\n        }\\n        return t.tree[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333895,
                "title": "c-easy-to-understand-priority-queue",
                "content": "**Approach:**\\n1. Maintain a `Max Heap`  maximum sum with `k` window. \\n2. Calculate the `Current Sum` push it to the `Max Heap` and also calculate the `max sum`.\\n3. Check the window is greater than `k` or not. If it is greater than `k` remove the elements from the `Max Heap`.\\n\\n**Time:** `O(N log K)`\\n**Space:** `O(K)`\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<array<int, 2>> que;\\n        int ret = nums[0], curr;\\n        que.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (!que.empty() && que.top()[1] < i - k) {\\n                que.pop();\\n            }\\n            curr = max(0, que.top()[0]) + nums[i];\\n\\t\\t    ret = max(ret, curr);\\n            que.push({curr, i});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<array<int, 2>> que;\\n        int ret = nums[0], curr;\\n        que.push({nums[0], 0});\\n        for (int i = 1; i < nums.size(); i++) {\\n            while (!que.empty() && que.top()[1] < i - k) {\\n                que.pop();\\n            }\\n            curr = max(0, que.top()[0]) + nums[i];\\n\\t\\t    ret = max(ret, curr);\\n            que.push({curr, i});\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257482,
                "title": "c-easy-approach-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       int n = nums.size();\\n       int dp[n];\\n       priority_queue<pair<int, int>> pq;\\n       int ans = INT_MIN;\\n       for(int i = n-1; i>=0; i--){\\n         while(pq.size() > 0 && pq.top().second > i+k){\\n            pq.pop();\\n         }\\n\\n         dp[i] = nums[i];\\n         if(pq.size() > 0){\\n           if(pq.top().first >=0){\\n            dp[i] += pq.top().first;\\n           }\\n         }\\n         ans = max(dp[i], ans);\\n         pq.push({dp[i], i});\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       int n = nums.size();\\n       int dp[n];\\n       priority_queue<pair<int, int>> pq;\\n       int ans = INT_MIN;\\n       for(int i = n-1; i>=0; i--){\\n         while(pq.size() > 0 && pq.top().second > i+k){\\n            pq.pop();\\n         }\\n\\n         dp[i] = nums[i];\\n         if(pq.size() > 0){\\n           if(pq.top().first >=0){\\n            dp[i] += pq.top().first;\\n           }\\n         }\\n         ans = max(dp[i], ans);\\n         pq.push({dp[i], i});\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142135,
                "title": "c-monotonic-deque-similar-to-jump-game-vi",
                "content": "* Deque stores elements in decreasing order such that front of deque will give max element.\\n\\n* Problem Based on Same Idea [Jump Game VI](https://leetcode.com/contest/weekly-contest-220/problems/jump-game-vi/)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(dq.size() and dq.front() < i - k ) dq.pop_front() ;\\n            int curr_max = dq.size() ? nums[dq.front()] : 0 ;\\n            nums[i] += max(0,curr_max) ; \\n            while(dq.size() and nums[dq.back()] <= nums[i]) dq.pop_back() ;\\n            dq.push_back(i) ;\\n        }\\n        \\n        return *max_element(begin(nums),end(nums)) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq ;\\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            while(dq.size() and dq.front() < i - k ) dq.pop_front() ;\\n            int curr_max = dq.size() ? nums[dq.front()] : 0 ;\\n            nums[i] += max(0,curr_max) ; \\n            while(dq.size() and nums[dq.back()] <= nums[i]) dq.pop_back() ;\\n            dq.push_back(i) ;\\n        }\\n        \\n        return *max_element(begin(nums),end(nums)) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733168,
                "title": "c-o-n-decreasing-monotonic-queue-solution",
                "content": "Let\\'s see the optimal substructure of the problem:\\nThe optimal subsequence sum that terminate at element nums[i] should be\\n1. 0 + nums[i],  if all the previous k subsequence sum are all negative\\n2. (The largest optimal subsequence sum for the previous k subsequences that terminates at nums[i-k]...numsp[i-1]) + nums[i]\\n\\nSo the motivation to use a monotonic (decreasing) queue is that we have to keep the largest subsequence sum for the previous k elements. At each step we first pop out the out-of-range subsequence sum from the front(the larger side), determine the optimal subsequence sum terminated at nums[i], and then push the current sum from the back(the smaller side).\\n\\n```\\n\\tint constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq; // (subsequence sum, index)\\n        \\n        int res = INT_MIN;\\n        for (int i =0; i < nums.size(); ++i) {\\n\\t\\t\\t// pop out subsequences that ends at index < i-k\\n            while(!dq.empty() && dq.front().second < i - k) {\\n                dq.pop_front();\\n            }\\n\\t\\t\\t// determine current subsequence sum\\n\\t\\t\\t// dq.front() is the largest valid subseq sum\\n\\t\\t\\t// if dq is empty, then all the previous subseq sum are all non-positive integer\\n            int cur = nums[i] + (dq.empty()?0:dq.front().first);\\n\\t\\t\\t\\n\\t\\t\\t// if the current subseq sum is positive, then it is no way to keep subseq sum\\n\\t\\t\\t// that is smaller than current subseq sum\\n            if (cur > 0){\\n                while(!dq.empty() && dq.back().first <= cur) {\\n                    dq.pop_back();\\n                }\\n                dq.push_back({cur, i});\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```\\n\\nSince each subseq sum can only be push to the deque once and pop out once, the time complexity is O(N).\\nThe space complexity for this problem is O(n) because there can be at most n elements in the deque.",
                "solutionTags": [
                    "C",
                    "Monotonic Queue"
                ],
                "code": "```\\n\\tint constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq; // (subsequence sum, index)\\n        \\n        int res = INT_MIN;\\n        for (int i =0; i < nums.size(); ++i) {\\n\\t\\t\\t// pop out subsequences that ends at index < i-k\\n            while(!dq.empty() && dq.front().second < i - k) {\\n                dq.pop_front();\\n            }\\n\\t\\t\\t// determine current subsequence sum\\n\\t\\t\\t// dq.front() is the largest valid subseq sum\\n\\t\\t\\t// if dq is empty, then all the previous subseq sum are all non-positive integer\\n            int cur = nums[i] + (dq.empty()?0:dq.front().first);\\n\\t\\t\\t\\n\\t\\t\\t// if the current subseq sum is positive, then it is no way to keep subseq sum\\n\\t\\t\\t// that is smaller than current subseq sum\\n            if (cur > 0){\\n                while(!dq.empty() && dq.back().first <= cur) {\\n                    dq.pop_back();\\n                }\\n                dq.push_back({cur, i});\\n            }\\n            res = max(res, cur);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676684,
                "title": "python-o-n-monotonic-deque-sliding-window-with-explanation",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # O(n) monotonic deque sliding window solution\\n        # max_dq is a monotonic deque containing the top\\n        # sums in the current window of size k.\\n        # each element is a tuple of sum and index of last element in that sum\\n        max_dq = deque()\\n        max_dq.append([nums[0], 0])\\n\\n        max_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            # remove the max if it exceeds the current window bounds\\n            if i - max_dq[0][1] > k:\\n                max_dq.popleft()\\n            \\n            # the max sum containing element i is either nums[i] alone\\n            # or the maximum from the window of size k\\n            # we easily get that from the front of the deque\\n            curr_max = max(nums[i], nums[i] + max_dq[0][0])\\n\\n            # push the current sum to appropriate spot in monotonic deque\\n            while max_dq and curr_max > max_dq[-1][0]:\\n                max_dq.pop()\\n            max_dq.append([curr_max, i])\\n\\n            max_sum = max(max_sum, curr_max)\\n\\n        return max_sum\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # O(n) monotonic deque sliding window solution\\n        # max_dq is a monotonic deque containing the top\\n        # sums in the current window of size k.\\n        # each element is a tuple of sum and index of last element in that sum\\n        max_dq = deque()\\n        max_dq.append([nums[0], 0])\\n\\n        max_sum = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            # remove the max if it exceeds the current window bounds\\n            if i - max_dq[0][1] > k:\\n                max_dq.popleft()\\n            \\n            # the max sum containing element i is either nums[i] alone\\n            # or the maximum from the window of size k\\n            # we easily get that from the front of the deque\\n            curr_max = max(nums[i], nums[i] + max_dq[0][0])\\n\\n            # push the current sum to appropriate spot in monotonic deque\\n            while max_dq and curr_max > max_dq[-1][0]:\\n                max_dq.pop()\\n            max_dq.append([curr_max, i])\\n\\n            max_sum = max(max_sum, curr_max)\\n\\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524114,
                "title": "python3-dp-mono-queue",
                "content": "dp[i] is the max result that ends at this position\\nkey concept: dp[i] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n\\nWe can directly calculate this `max(dp[i - 1], dp[i - 2].. dp[i - k]`. The time complexity is O(N^2).\\nThe sliding windown and monotonic queue idea can be applied to dp array to the get the previous maximum number here, reducing the time complexity to O(N).\\n\\n```py\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # Maximum sum subsequence \\n\\t\\t# Max skip -> k steps\\n        # dp[i] is the max results that ended at this position\\n        # dp[0] = nums[0]\\n        # dp[1] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n        # compare 1 by 1 -> O(n^2)\\n        # some data structure to find previous max\\n\\t\\t# find the max in a sliding window\\n        # queue -> Monotonic queue\\n        # queue is applied for dp array\\n        q = deque([])\\n        dp = [float(\"-inf\")] * (len(nums) + 1)\\n        q.append(0) \\n        for i in range(len(nums)):\\n            # max(dp[i - 1], dp[i - 2].. dp[i - k])\\n            # k >= 1\\n            while q and i + 1 - q[0] > k:\\n                q.popleft()\\n                \\n            dp[i + 1] = max(nums[i] + dp[q[0]], nums[i])\\n            while q and dp[i + 1] >= dp[q[-1]]:\\n                q.pop()   \\n            q.append(i + 1)\\n            \\n        return max(dp[1:])\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # Maximum sum subsequence \\n\\t\\t# Max skip -> k steps\\n        # dp[i] is the max results that ended at this position\\n        # dp[0] = nums[0]\\n        # dp[1] = max(nums[i] + max(dp[i - 1], dp[i - 2].. dp[i - k]), nums[i])\\n        # compare 1 by 1 -> O(n^2)\\n        # some data structure to find previous max\\n\\t\\t# find the max in a sliding window\\n        # queue -> Monotonic queue\\n        # queue is applied for dp array\\n        q = deque([])\\n        dp = [float(\"-inf\")] * (len(nums) + 1)\\n        q.append(0) \\n        for i in range(len(nums)):\\n            # max(dp[i - 1], dp[i - 2].. dp[i - k])\\n            # k >= 1\\n            while q and i + 1 - q[0] > k:\\n                q.popleft()\\n                \\n            dp[i + 1] = max(nums[i] + dp[q[0]], nums[i])\\n            while q and dp[i + 1] >= dp[q[-1]]:\\n                q.pop()   \\n            q.append(i + 1)\\n            \\n        return max(dp[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026799,
                "title": "normal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        multiset<int> m;\\n        m.insert(0);\\n        for(int i =0; i<nums.size(); i++){\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n            if(i>=k){\\n                m.erase(m.find((dp[i-k])));\\n            }\\n            \\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size());\\n        multiset<int> m;\\n        m.insert(0);\\n        for(int i =0; i<nums.size(); i++){\\n            dp[i] = nums[i] + *m.rbegin();\\n            m.insert(dp[i]);\\n            if(i>=k){\\n                m.erase(m.find((dp[i-k])));\\n            }\\n            \\n        }\\n        \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716743,
                "title": "intiutive-solution-greedy-dp-without-using-deque",
                "content": "My Approach is ,if we find a block of negative no bw blocks of positive numbers.\\nlike [1,2,4,2,3,**-4,-1,-3,-2,-3**,3,5,2,1] , So what we need to do calculate maimum value of this negative window to get out of that ,and for this we will use DP **O((size of window x k))** +greedliy selected positive blocks **O(n)**.\\n```\\nint call(vector<int>&nums,int st,int end,int k)\\n    {   \\n        int n=end-st+1;\\n        if(n<k)\\n            return 0;\\n        int dp[end-st+1];\\n        int ans=INT_MIN;\\n       // Similar to LIS approach ,we can skip k-1 indexes from any point \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[st+i];\\n            if(i>=k)\\n            {   int val=INT_MIN;\\n                for(int j=i-1;j>=i-k;j--)\\n                {\\n                    val=max(val,dp[j]);\\n                }\\n               dp[i]+=val;\\n               \\n             \\n            }\\n            if(i>=n-k)\\n                ans=max(ans,dp[i]);  // If it reachable to end with one jump\\n            \\n        }\\n       return ans; \\n    }\\n    \\n    int sequenceSum(vector<int>&updated)\\n    {\\n        int n=updated.size();\\n        int cur=0;\\n        int ans=INT_MIN;  // Simply update maximum sequence sum\\n        for(int i=0;i<n;i++)\\n        {\\n           cur+=updated[i];\\n            if(cur>ans)\\n                ans=cur;\\n            if(cur<0)\\n                cur=0;\\n        }\\n        return ans;\\n    }\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       \\n        vector<int>updated;  // further Updated input\\n        int n=nums.size();\\n        int l=0;      // start of neg index\\n        int i=0;\\n        int count=0;\\n        \\n        while(i<n)\\n        {  \\n            l=i;\\n            if(nums[i]>=0)\\n            {\\n                updated.push_back(nums[i]);   //if nums[i]>0,just push it to updated vector\\n                i++;\\n                continue;\\n            }\\n                \\n            while(i<n&&nums[i]<0)\\n            {\\n                i++;\\n                count++;      // Iterate till we find a positive number\\n            }\\n            if(count==n)\\n                return *max_element(nums.begin(),nums.end());  // if all elements are neg\\n           \\n            int change=call(nums,l,i-1,k);// It will find minimum cost to clear all negative window from l to i-1\\n            \\n            updated.push_back(change); // Push that value\\n            \\n        }\\n        \\n        int maximumSum=sequenceSum(updated);  // Now find maximum sequence sum\\n        \\n        return maximumSum;\\n        \\n    }",
                "solutionTags": [],
                "code": "My Approach is ,if we find a block of negative no bw blocks of positive numbers.\\nlike [1,2,4,2,3,**-4,-1,-3,-2,-3**,3,5,2,1] , So what we need to do calculate maimum value of this negative window to get out of that ,and for this we will use DP **O((size of window x k))** +greedliy selected positive blocks **O(n)**.\\n```\\nint call(vector<int>&nums,int st,int end,int k)\\n    {   \\n        int n=end-st+1;\\n        if(n<k)\\n            return 0;\\n        int dp[end-st+1];\\n        int ans=INT_MIN;\\n       // Similar to LIS approach ,we can skip k-1 indexes from any point \\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i]=nums[st+i];\\n            if(i>=k)\\n            {   int val=INT_MIN;\\n                for(int j=i-1;j>=i-k;j--)\\n                {\\n                    val=max(val,dp[j]);\\n                }\\n               dp[i]+=val;\\n               \\n             \\n            }\\n            if(i>=n-k)\\n                ans=max(ans,dp[i]);  // If it reachable to end with one jump\\n            \\n        }\\n       return ans; \\n    }\\n    \\n    int sequenceSum(vector<int>&updated)\\n    {\\n        int n=updated.size();\\n        int cur=0;\\n        int ans=INT_MIN;  // Simply update maximum sequence sum\\n        for(int i=0;i<n;i++)\\n        {\\n           cur+=updated[i];\\n            if(cur>ans)\\n                ans=cur;\\n            if(cur<0)\\n                cur=0;\\n        }\\n        return ans;\\n    }\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n       \\n        vector<int>updated;  // further Updated input\\n        int n=nums.size();\\n        int l=0;      // start of neg index\\n        int i=0;\\n        int count=0;\\n        \\n        while(i<n)\\n        {  \\n            l=i;\\n            if(nums[i]>=0)\\n            {\\n                updated.push_back(nums[i]);   //if nums[i]>0,just push it to updated vector\\n                i++;\\n                continue;\\n            }\\n                \\n            while(i<n&&nums[i]<0)\\n            {\\n                i++;\\n                count++;      // Iterate till we find a positive number\\n            }\\n            if(count==n)\\n                return *max_element(nums.begin(),nums.end());  // if all elements are neg\\n           \\n            int change=call(nums,l,i-1,k);// It will find minimum cost to clear all negative window from l to i-1\\n            \\n            updated.push_back(change); // Push that value\\n            \\n        }\\n        \\n        int maximumSum=sequenceSum(updated);  // Now find maximum sequence sum\\n        \\n        return maximumSum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 599572,
                "title": "python3-o-n-time-o-k-space-easy-to-understand-monotonic-queue-dp",
                "content": "This is inspired by my friend\\'s Monotonic Queue code and maximum subarray sum.\\n\\nFirst, let\\'s take a look of the question: \\n```\\nGiven an integer array nums and an integer k, \\nreturn the maximum sum of a non-empty subset of that array such that for every two consecutive integers in the subset,\\nnums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\\n```\\nIt\\'s pretty similar to maximum subarray sum but with some restrictions like: the picked numbers in the subsequence must be within a window k (not sure if it\\'s the best word to explain..)\\n\\nLet\\'s take a look of the transition function for maximum subarray sum:\\n```\\ndp[i] = max(nums[i], dp[i-1]+nums[i]) \\n# should we take this number with previous sum or just start with the current number\\n```\\n\\nSimilarly, for this question, we can construct a transition function:\\n```\\ndp[i] = max(nums[i], dp[j]+arr[i]) for j in range(i-k, i)\\n# should we take this number with the previous sum, where the previous sum shoud be the max in range dp[i-k:i]\\n# Or should we just start with the current number\\n```\\n\\nBut with this DP setup, it\\'s taking O(NK) time and I\\'m facing the TLE.\\n\\nAnother necessary step is to further reduce time complexity through supporting O(1) find maximum in the sliding window dp[i-k:i] instead of O(K).\\n\\nA useful technique - monotonic queue - came into my mind. So we can keep a sliding window of K to traverse the array, and keep a maxQueue to track/update the maximum value in the sliding window of K.\\n\\nHere is a the implementation:\\nI learned the MaxQueue/MinQueue class implementation from my friend, and I\\'m reusing most of the MaxQueue code here.\\nI feel like wrapping the functionality of MaxQueue into a class would be easier for people to read!\\n```\\nfrom collections import deque\\nclass MaxQueue:\\n\\n    def __init__(self, k):\\n        self.capacity = k\\n        self.queue = deque()\\n        self.maxQueue = deque()\\n\\n\\n    def enqueue(self, value):\\n        if len(self.queue) == self.capacity:\\n            self.pop()\\n\\n        self.queue.append(value)\\n        while self.maxQueue and value > self.maxQueue[-1]:\\n            self.maxQueue.pop()\\n        self.maxQueue.append(value)\\n\\n\\n    def pop(self):\\n        val = self.queue.popleft()\\n        if val == self.getMax():\\n            self.maxQueue.popleft()\\n        return val\\n\\n\\n    def getMax(self):\\n        return self.maxQueue[0]\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if not nums or len(nums) == 0:\\n            return 0\\n\\n        globalmax = 0\\n\\n        maxQueue = MaxQueue(k)\\n        maxQueue.enqueue(nums[0])\\n\\n        globalmax = nums[0]\\n        for i in range(1, len(nums)):\\n            maxQueue.enqueue(max(nums[i], nums[i] + maxQueue.getMax()))\\n            globalmax = max(globalmax, maxQueue.getMax())\\n\\n        return globalmax\\n```\\n\\nI think this is a really good problem by combining DP with monotonic queue.\\nThe structure of Monotonic queue class can be reused in a lot of problems and can be generalized into a framework.\\nHope my solution can help you understand and generalize the question!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nGiven an integer array nums and an integer k, \\nreturn the maximum sum of a non-empty subset of that array such that for every two consecutive integers in the subset,\\nnums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\\n```\n```\\ndp[i] = max(nums[i], dp[i-1]+nums[i]) \\n# should we take this number with previous sum or just start with the current number\\n```\n```\\ndp[i] = max(nums[i], dp[j]+arr[i]) for j in range(i-k, i)\\n# should we take this number with the previous sum, where the previous sum shoud be the max in range dp[i-k:i]\\n# Or should we just start with the current number\\n```\n```\\nfrom collections import deque\\nclass MaxQueue:\\n\\n    def __init__(self, k):\\n        self.capacity = k\\n        self.queue = deque()\\n        self.maxQueue = deque()\\n\\n\\n    def enqueue(self, value):\\n        if len(self.queue) == self.capacity:\\n            self.pop()\\n\\n        self.queue.append(value)\\n        while self.maxQueue and value > self.maxQueue[-1]:\\n            self.maxQueue.pop()\\n        self.maxQueue.append(value)\\n\\n\\n    def pop(self):\\n        val = self.queue.popleft()\\n        if val == self.getMax():\\n            self.maxQueue.popleft()\\n        return val\\n\\n\\n    def getMax(self):\\n        return self.maxQueue[0]\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if not nums or len(nums) == 0:\\n            return 0\\n\\n        globalmax = 0\\n\\n        maxQueue = MaxQueue(k)\\n        maxQueue.enqueue(nums[0])\\n\\n        globalmax = nums[0]\\n        for i in range(1, len(nums)):\\n            maxQueue.enqueue(max(nums[i], nums[i] + maxQueue.getMax()))\\n            globalmax = max(globalmax, maxQueue.getMax())\\n\\n        return globalmax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598900,
                "title": "c-faster-than-100-less-than-100-mem-o-n-k",
                "content": "Runtime: 152 ms\\nMemory Usage: 40 MB\\n\\n```\\n\\n   public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.Length];\\n        \\n        dp[dp.Length-1] = nums[nums.Length-1];\\n        int max = dp[dp.Length-1];\\n        \\n        int crntMaxIndex = dp.Length-1;\\n        int limit;\\n            \\n        for(int i=nums.Length-2; i>=0; i--)\\n        {\\n            if (crntMaxIndex - i > k)\\n            {\\n                limit = Math.Min(i+k+1, nums.Length);\\n                crntMaxIndex = i+1;\\n                \\n                for(int j=i+2; j < limit; j++)\\n                {\\n                    if (dp[crntMaxIndex] < dp[j])\\n                    {\\n                         crntMaxIndex = j;\\n                    }\\n                } \\n            }\\n            \\n            dp[i] = Math.Max(nums[i], nums[i] + dp[crntMaxIndex]);\\n                \\n            if (dp[i] >= dp[crntMaxIndex])\\n            {\\n                crntMaxIndex = i;\\n            }\\n            \\n            max = Math.Max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Runtime: 152 ms\\nMemory Usage: 40 MB\\n\\n```\\n\\n   public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.Length];\\n        \\n        dp[dp.Length-1] = nums[nums.Length-1];\\n        int max = dp[dp.Length-1];\\n        \\n        int crntMaxIndex = dp.Length-1;\\n        int limit;\\n            \\n        for(int i=nums.Length-2; i>=0; i--)\\n        {\\n            if (crntMaxIndex - i > k)\\n            {\\n                limit = Math.Min(i+k+1, nums.Length);\\n                crntMaxIndex = i+1;\\n                \\n                for(int j=i+2; j < limit; j++)\\n                {\\n                    if (dp[crntMaxIndex] < dp[j])\\n                    {\\n                         crntMaxIndex = j;\\n                    }\\n                } \\n            }\\n            \\n            dp[i] = Math.Max(nums[i], nums[i] + dp[crntMaxIndex]);\\n                \\n            if (dp[i] >= dp[crntMaxIndex])\\n            {\\n                crntMaxIndex = i;\\n            }\\n            \\n            max = Math.Max(max, dp[i]);\\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 597912,
                "title": "c-o-n-o-nlogn-o-n-2-solution",
                "content": "**1. O(N^2) Solution with Dynamic Programming**\\n**Let DP[i] means maximum result we can get at index[i], which has to include current value**\\nFor example, [10, -2, -10, -5, 20], k = 2. \\nWill get [10, 8, 0, 3, 23]\\n\\nFor each **DP[i]**, we need to update **DP[i] = max(DP[i], cur + DP[j]), DP[j]** means all the index satisfies **i - k <= j < i**\\n\\n**2. O(NLogN) Solution with Ordered Set**\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        int res = INT_MIN;\\n        set<int> st;\\n        vector<int> mem;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t    // cur means the maxRes we can get at index i;\\n            int cur = nums[i] + (st.empty() ? 0 : *st.rbegin());\\n            res = max(res, cur);\\n            \\n\\t\\t\\t// keep an orderd set\\n            if (cur > 0) st.insert(cur);\\n            mem.push_back(cur);\\n            \\n            // keep k + 1 sliding window, pop out the element out of border\\n            if (i - k >= 0) {\\n                if (st.empty()) continue;\\n                if (mem[i - k] == *st.rbegin()) {\\n                    st.erase(st.find(mem[i-k]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**3. O(N) Solution with Monotonic Decreasing Queue**\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\tint res = INT_MIN;\\n\\tdeque<int> q;\\n\\tvector<int> mem;\\n\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t// cur means the maxRes we can get at index i;\\n\\t\\tint cur = nums[i] + (q.empty() ? 0 : q.front());\\n\\t\\tres = max(res, cur);\\n\\t\\t\\n\\t\\t// make sure current number popped out all smaller number\\n\\t\\twhile (!q.empty() && q.back() < cur) q.pop_back();\\n\\t\\tif (cur > 0) q.push_back(cur); \\n\\t\\tmem.push_back(cur);\\n\\n\\t\\t// keep k + 1 sliding window, pop out the element out of border\\n\\t\\tif (i - k >= 0) {\\n\\t\\t\\tif (mem[i - k] == q.front()) {\\n\\t\\t\\t\\tq.pop_front();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        int res = INT_MIN;\\n        set<int> st;\\n        vector<int> mem;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t    // cur means the maxRes we can get at index i;\\n            int cur = nums[i] + (st.empty() ? 0 : *st.rbegin());\\n            res = max(res, cur);\\n            \\n\\t\\t\\t// keep an orderd set\\n            if (cur > 0) st.insert(cur);\\n            mem.push_back(cur);\\n            \\n            // keep k + 1 sliding window, pop out the element out of border\\n            if (i - k >= 0) {\\n                if (st.empty()) continue;\\n                if (mem[i - k] == *st.rbegin()) {\\n                    st.erase(st.find(mem[i-k]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\tint res = INT_MIN;\\n\\tdeque<int> q;\\n\\tvector<int> mem;\\n\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t// cur means the maxRes we can get at index i;\\n\\t\\tint cur = nums[i] + (q.empty() ? 0 : q.front());\\n\\t\\tres = max(res, cur);\\n\\t\\t\\n\\t\\t// make sure current number popped out all smaller number\\n\\t\\twhile (!q.empty() && q.back() < cur) q.pop_back();\\n\\t\\tif (cur > 0) q.push_back(cur); \\n\\t\\tmem.push_back(cur);\\n\\n\\t\\t// keep k + 1 sliding window, pop out the element out of border\\n\\t\\tif (i - k >= 0) {\\n\\t\\t\\tif (mem[i - k] == q.front()) {\\n\\t\\t\\t\\tq.pop_front();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597729,
                "title": "c-o-n-log-n-dp-sliding-window-balanced-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        multiset<int, greater<int>> win;\\n        dp[0] = nums[0];\\n        win.insert(nums[0]);\\n        int result = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int m = *win.begin();\\n            dp[i] = max(nums[i], nums[i] + m);\\n            win.insert(dp[i]);\\n            if (win.size() > k) {\\n                win.erase(win.find(dp[i - k]));\\n            }\\n            result = max(result, dp[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        multiset<int, greater<int>> win;\\n        dp[0] = nums[0];\\n        win.insert(nums[0]);\\n        int result = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            int m = *win.begin();\\n            dp[i] = max(nums[i], nums[i] + m);\\n            win.insert(dp[i]);\\n            if (win.size() > k) {\\n                win.erase(win.find(dp[i - k]));\\n            }\\n            result = max(result, dp[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476819,
                "title": "python-dp-max-window-element-monotonic-queue",
                "content": "\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = copy.deepcopy(nums)\\n        q = deque()\\n        q.append(0)\\n        for i in range(1,len(nums)):\\n            while(q[-1] < i-k ):\\n                q.pop()\\n            dp[i] = max(dp[i],dp[q[-1]]+nums[i])\\n            while( len(q)>0 and dp[q[0]] <= dp[i] ):\\n                q.popleft()\\n            q.appendleft(i)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = copy.deepcopy(nums)\\n        q = deque()\\n        q.append(0)\\n        for i in range(1,len(nums)):\\n            while(q[-1] < i-k ):\\n                q.pop()\\n            dp[i] = max(dp[i],dp[q[-1]]+nums[i])\\n            while( len(q)>0 and dp[q[0]] <= dp[i] ):\\n                q.popleft()\\n            q.appendleft(i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652789,
                "title": "monotonic-queue-in-python-faster-than-98-47",
                "content": "This problem can be solved in O(N lg N) by using a heap or BST, and can also be solved in O(N) by using a monotonic queue instead of the tree structures. \\nThe idea is to maintain a queue that consists of up to previous k results for the current element to success. \\nThe queue is monotonic because the older the element in the queue should be the larger.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i, v in enumerate(nums):\\n            if len(q): \\n                nums[i] += nums[q[0]]\\n            if q and i - q[0] >= k:\\n                q.popleft()\\n            if nums[i] > 0:\\n                while q and nums[q[-1]] <= nums[i]:\\n                    q.pop()\\n                q.append(i)\\n        return max(nums)\\n                \\n",
                "solutionTags": [
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "This problem can be solved in O(N lg N) by using a heap or BST, and can also be solved in O(N) by using a monotonic queue instead of the tree structures. \\nThe idea is to maintain a queue that consists of up to previous k results for the current element to success. \\nThe queue is monotonic because the older the element in the queue should be the larger.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i, v in enumerate(nums):\\n            if len(q): \\n                nums[i] += nums[q[0]]\\n            if q and i - q[0] >= k:\\n                q.popleft()\\n            if nums[i] > 0:\\n                while q and nums[q[-1]] <= nums[i]:\\n                    q.pop()\\n                q.append(i)\\n        return max(nums)\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1489330,
                "title": "python-soln",
                "content": "Use a monotone decreasing deque. \\n* The deque stores (local_maxsum_i, i) tuples to indicate the local maximum subsequence sum using and ending at the nums[i]. \\n* The deque is decreasing because we want a maximum sum of sub-sequence with respect to the constrained index range bounded by k. So if we want to compute the \"local_maxsum_i\" at index i, we only need to check the \"local_maxsum_m\" at index m (m < i) such that:\\n\\t* The index m is as close to index i as possible and i - m <= k.\\n\\t* The \"local_maxsum_m\" is the maximum subsequence sum we have seen so far before we proceed to the index i.\\n\\t* If we keep proceeding to the next index n > i > m and found that local_maxsum_i >= local_maxsum_m, then local_maxsum_n = local_maxsum_i + nums[n] because \"local_maxsum_i\" is better than \"local_maxsum_m\" in both maximal value and index constraint aspects. This leads to the monotone decreasing deque.\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # edge case\\n        if n == 1:\\n            return nums[0]\\n\\n        res = nums[0]\\n        dq = collections.deque([])\\n        dq.append((nums[0], 0))   # use a monotone decreasing deque\\n        for i in range(1, n):\\n            e = nums[i]\\n            # compliance with the index range constraint\\n            while dq and i - dq[0][1] > k:\\n                dq.popleft()\\n\\n            local_max = max(dq[0][0], 0) + e\\n            # maintain deque monotonicity\\n            while dq and local_max >= dq[-1][0]:\\n                dq.pop()\\n            dq.append((local_max, i))\\n            res = max(res, local_max)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        # edge case\\n        if n == 1:\\n            return nums[0]\\n\\n        res = nums[0]\\n        dq = collections.deque([])\\n        dq.append((nums[0], 0))   # use a monotone decreasing deque\\n        for i in range(1, n):\\n            e = nums[i]\\n            # compliance with the index range constraint\\n            while dq and i - dq[0][1] > k:\\n                dq.popleft()\\n\\n            local_max = max(dq[0][0], 0) + e\\n            # maintain deque monotonicity\\n            while dq and local_max >= dq[-1][0]:\\n                dq.pop()\\n            dq.append((local_max, i))\\n            res = max(res, local_max)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445396,
                "title": "dp-deque",
                "content": "Normal DP will give TLE. It is modified with monotonically increasing deque. \\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        for(int j=0; j<n; j++) {\\n            while(!dq.empty()&&j-dq.front()>k) dq.pop_front();\\n            dp[j]=nums[j];\\n            if(!dq.empty()) dp[j]=max(dp[j], nums[j]+dp[dq.front()]);\\n            while(!dq.empty()&&dp[dq.back()]<dp[j]) dq.pop_back();\\n            dq.push_back(j);\\n            // cout<<dp[j]<<\" \";\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        deque<int> dq;\\n        for(int j=0; j<n; j++) {\\n            while(!dq.empty()&&j-dq.front()>k) dq.pop_front();\\n            dp[j]=nums[j];\\n            if(!dq.empty()) dp[j]=max(dp[j], nums[j]+dp[dq.front()]);\\n            while(!dq.empty()&&dp[dq.back()]<dp[j]) dq.pop_back();\\n            dq.push_back(j);\\n            // cout<<dp[j]<<\" \";\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369153,
                "title": "c-dp-solution-with-thinking-process-brute-force-priority-queue-mono-queue",
                "content": "The initial try is to approach this problem by DP: assuming dp[i] is the max subsequece sum ending at i; Then it\\'s straight forward to come up the dp relation:\\ndp[i] = nums[i] + max(dp[j], i-j <= k)\\n\\nNotice that there is no requirement on the left boundary, i.e we can have subsequence such as [i1, i2, ...] where i1 > k. So we can always initialize dp[i] as nums[i], which is a natrual subsequence with length 1 [i].\\n\\nThe time complexity is O(KN), and of course this will get TLE. Next step we will improve on getting max(dp[j], i-j<=k) using priority queue or mono queue. \\n```\\n// O(KN) solution, TLE\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            for (int j = i-1; j>=0 && j+k >= i; --j) {\\n                dp[i] = std::max(dp[i], nums[i]+dp[j]);\\n            }\\n            ans = std::max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPriority queue seems a very straightforward improvement on getting max, while maintaining the i-j<=k requirement. \\n```\\n// O(NlogN) solution\\nclass Solution_1 {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        auto cmp = [] (const pair<int,int>& lhs, const pair<int,int>& rhs) {\\n            return lhs.second < rhs.second;  \\n        };\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        pq.push({0, nums[0]});\\n        int ans = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int curr = nums[i];\\n            while (pq.size() && pq.top().first+k < i) pq.pop();\\n            curr = std::max(curr, nums[i]+pq.top().second);\\n            ans = std::max(ans, curr);\\n            pq.push({i, curr});\\n        }\\n        return ans;\\n    }\\n};\\n```\\nMono queue is relatively advanced: it\\'s a very effective structure to keep min/max value in a sliding window scenario. In this case, since we need the max value in the past, mono queue (decreasing order) can be utilized. \\nTo learn and understand mono queue, [leetcode 239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is your friend.\\nEverytime, when you need get min/max value in a sliding window, try mono queue (at least it always works for me.)\\n```\\n// O(N) solution\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        deque<int> desc_dq;\\n        desc_dq.push_back(0);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            while(desc_dq.size() && desc_dq.front()+k < i) desc_dq.pop_front();\\n            dp[i] = std::max(dp[i], nums[i]+dp[desc_dq.front()]);\\n            ans = std::max(ans, dp[i]);\\n            while(desc_dq.size() && dp[i] >= dp[desc_dq.back()]) desc_dq.pop_back();\\n            desc_dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// O(KN) solution, TLE\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            for (int j = i-1; j>=0 && j+k >= i; --j) {\\n                dp[i] = std::max(dp[i], nums[i]+dp[j]);\\n            }\\n            ans = std::max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(NlogN) solution\\nclass Solution_1 {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        auto cmp = [] (const pair<int,int>& lhs, const pair<int,int>& rhs) {\\n            return lhs.second < rhs.second;  \\n        };\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        pq.push({0, nums[0]});\\n        int ans = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int curr = nums[i];\\n            while (pq.size() && pq.top().first+k < i) pq.pop();\\n            curr = std::max(curr, nums[i]+pq.top().second);\\n            ans = std::max(ans, curr);\\n            pq.push({i, curr});\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// O(N) solution\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> dp(nums.size(), 0);\\n        dp[0] = nums[0];\\n        int ans = dp[0];\\n        deque<int> desc_dq;\\n        desc_dq.push_back(0);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            dp[i] = nums[i];\\n            while(desc_dq.size() && desc_dq.front()+k < i) desc_dq.pop_front();\\n            dp[i] = std::max(dp[i], nums[i]+dp[desc_dq.front()]);\\n            ans = std::max(ans, dp[i]);\\n            while(desc_dq.size() && dp[i] >= dp[desc_dq.back()]) desc_dq.pop_back();\\n            desc_dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335790,
                "title": "python-o-n-w-monoqueue-8-lines",
                "content": "```\\nfrom collections import deque\\n\\nclass Monoqueue:\\n    \\n    def __init__(self):\\n        self.dq = deque()\\n        self.data = list()\\n        \\n    def push(self, index, val):\\n        while len(self.dq) > 0 and val >= self.data[self.dq[-1]]:\\n            self.dq.pop()\\n        self.data.append(val)\\n        self.dq.append(index)\\n    \\n    def front(self, curr, k):\\n        if curr-self.dq[0] > k:\\n            self.dq.popleft()\\n        return self.data[self.dq[0]]\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\'\\'\\'\\n        Algorithm:\\n            1. Define max_sum[i] := max{max_sum[i-j] for j e (1,k), 0} + nums[i]\\n            2. Define max_sum[0] = nums[0]\\n            3. Let M = max{max_sum[i-j] for j e (1,k)}.\\n                Then we can find M in constant time by maintaining a monoqueue which\\n                stores the maximum max_sum value within k of index i\\n        \\'\\'\\'\\n        n = len(nums)\\n        max_sum = nums\\n        mq = Monoqueue()\\n        mq.push(0,nums[0])\\n        \\n        for i in range(1,n):\\n            max_sum[i] = max(0,mq.front(i,k))+nums[i]\\n            mq.push(i,max_sum[i])      \\n        return max(max_sum)\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        \\'\\'\\'\\n        Algorithm:\\n            1. Define max_sum[i] := max{max_sum[i-j] for j e (1,k), 0}",
                "codeTag": "Java"
            },
            {
                "id": 1079569,
                "title": "java-dp-monoqueue",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res=Integer.MIN_VALUE;\\n        LinkedList<int[]>mono=new LinkedList<>();\\n        int dp[]=new int[A.length];\\n        \\n        \\n        for(int i=0;i<A.length;i++){//decrease\\n            while(mono.size()>0&&mono.getFirst()[1]<i-k){\\n                mono.removeFirst();\\n            }\\n            dp[i]=A[i];\\n            \\n            if(mono.size()>0){\\n                int first=mono.getFirst()[0];\\n                dp[i]+=Math.max(first,0);\\n            }\\n            while(mono.size()>0&&dp[i]>mono.getLast()[0]){\\n                mono.removeLast();\\n            }\\n            \\n            \\n            mono.add(new int[]{dp[i],i});\\n            res=Math.max(res,dp[i]);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] A, int k) {\\n        int res=Integer.MIN_VALUE;\\n        LinkedList<int[]>mono=new LinkedList<>();\\n        int dp[]=new int[A.length];\\n        \\n        \\n        for(int i=0;i<A.length;i++){//decrease\\n            while(mono.size()>0&&mono.getFirst()[1]<i-k){\\n                mono.removeFirst();\\n            }\\n            dp[i]=A[i];\\n            \\n            if(mono.size()>0){\\n                int first=mono.getFirst()[0];\\n                dp[i]+=Math.max(first,0);\\n            }\\n            while(mono.size()>0&&dp[i]>mono.getLast()[0]){\\n                mono.removeLast();\\n            }\\n            \\n            \\n            mono.add(new int[]{dp[i],i});\\n            res=Math.max(res,dp[i]);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050327,
                "title": "python-double-end-queue-and-dp-o-n-complexity",
                "content": "```\\n        n = len(nums)\\n        queue = deque()\\n        dp = [0] * n\\n        for i in range(0, n):\\n            # print(queue)\\n            while(queue and i - queue[0] > k):\\n                print(\"get in\")\\n                queue.popleft()\\n                \\n            if not queue:\\n                dp[i] = nums[i]\\n                if dp[i] > 0:\\n                    queue.append(i)\\n                continue\\n\\n            last = queue.pop()\\n            # print(\"just before:\", queue)\\n            while(queue and dp[queue[-1]] <= dp[last]):\\n                queue.pop()\\n            if queue:\\n                dp[i] = dp[queue[0]] + nums[i]\\n            else:\\n                dp[i] = dp[last] + nums[i]\\n            \\n            queue.append(last)\\n            \\n            if dp[i] > 0:\\n                queue.append(i)\\n        \\n        # print(dp)    \\n            \\n        return max(dp)\\n```\\n\\ndp[i] is the \"good\" subsequence containing the ith element with largest sum.\\nqueue[0] is the index such that i - index <= k and dp[index] is the largest.",
                "solutionTags": [],
                "code": "```\\n        n = len(nums)\\n        queue = deque()\\n        dp = [0] * n\\n        for i in range(0, n):\\n            # print(queue)\\n            while(queue and i - queue[0] > k):\\n                print(\"get in\")\\n                queue.popleft()\\n                \\n            if not queue:\\n                dp[i] = nums[i]\\n                if dp[i] > 0:\\n                    queue.append(i)\\n                continue\\n\\n            last = queue.pop()\\n            # print(\"just before:\", queue)\\n            while(queue and dp[queue[-1]] <= dp[last]):\\n                queue.pop()\\n            if queue:\\n                dp[i] = dp[queue[0]] + nums[i]\\n            else:\\n                dp[i] = dp[last] + nums[i]\\n            \\n            queue.append(last)\\n            \\n            if dp[i] > 0:\\n                queue.append(i)\\n        \\n        # print(dp)    \\n            \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1027802,
                "title": "python-3-dp-and-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))] \\n        dp[0]=nums[0]\\n        heap = []\\n        heapq.heapify(heap)\\n        for i in range(1,len(nums)):\\n            while len(heap)>0 and heap[0][1]<i-k:\\n                heapq.heappop(heap)\\n            heapq.heappush(heap, (-dp[i-1],i-1))\\n            max_=-heap[0][0]\\n            dp[i] = max(0,max_)+nums[i]\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))] \\n        dp[0]=nums[0]\\n        heap = []\\n        heapq.heapify(heap)\\n        for i in range(1,len(nums)):\\n            while len(heap)>0 and heap[0][1]<i-k:\\n                heapq.heappop(heap)\\n            heapq.heappush(heap, (-dp[i-1],i-1))\\n            max_=-heap[0][0]\\n            dp[i] = max(0,max_)+nums[i]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023925,
                "title": "dp-monotonic-deque-c",
                "content": "1. monotonic deque\\n```\\nTC: O(N)\\nSC: O(N)\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            dp[i] = max(nums[i] + dq.front(), nums[i]); \\n            res = max(dp[i], res);\\n            while(!dq.empty() && dq.back() < dp[i])\\n                dq.pop_back();\\n            dq.push_back(dp[i]);\\n            if(i - k >= 0 && dq.front() == dp[i - k])\\n                dq.pop_front();\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n```\\n\\n2. monotonic deque,  optimize the space\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(k+1, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n\\n        for(int i = 1; i < n; i++){\\n\\n            int id = i % (k + 1);\\n            dp[id] = max(nums[i] + dq.front(), nums[i]);\\n            res = max(dp[id], res);\\n            while(!dq.empty() && dq.back() < dp[id])\\n                dq.pop_back();\\n            dq.push_back(dp[id]);\\n            if(i - k >= 0 && dq.front() == dp[(i - k) % (k + 1)])\\n                dq.pop_front();\\n\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTC: O(N)\\nSC: O(N)\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(n, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++){\\n            \\n            dp[i] = max(nums[i] + dq.front(), nums[i]); \\n            res = max(dp[i], res);\\n            while(!dq.empty() && dq.back() < dp[i])\\n                dq.pop_back();\\n            dq.push_back(dp[i]);\\n            if(i - k >= 0 && dq.front() == dp[i - k])\\n                dq.pop_front();\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n```\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        vector<int> dp(k+1, 0);\\n        deque<int> dq{nums[0]};\\n        int res = nums[0];\\n        dp[0] = nums[0];\\n\\n        for(int i = 1; i < n; i++){\\n\\n            int id = i % (k + 1);\\n            dp[id] = max(nums[i] + dq.front(), nums[i]);\\n            res = max(dp[id], res);\\n            while(!dq.empty() && dq.back() < dp[id])\\n                dq.pop_back();\\n            dq.push_back(dp[id]);\\n            if(i - k >= 0 && dq.front() == dp[(i - k) % (k + 1)])\\n                dq.pop_front();\\n\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998674,
                "title": "dynamic-programming-and-decreasing-queue",
                "content": "### Solution\\n\\nMy intution is to use dynamic programming to solve this problem, since most optimal (maximum or minimum) problem can be solved this way. Let dp[i] be the maximum constrained subsequence sum ending at nums[i] which satisfying the constraint. Then\\n\\n```python\\ndp[i] = max(dp[i - 1], ..., dp[i - k]) + nums[i]\\n\\nret = max(dp[i])\\n```\\n\\nSo a straightforward implementation is below.\\n\\n```python\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        let dp[i] be the maximum subset sum with nums[i] as the last element in the subsequence\\n        then ret = max(dp[i]) for i in range(0,n)\\n        \\n        dp[i] = max(dp[i - 1], dp[i - 2], .., dp[i - k]) + nums[i]\\n        \\'\\'\\'\\n        n = len(nums)\\n        dp = [0 for i in range(n)]\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                dp[i] = max(dp[i], dp[i - j])\\n            dp[i] += nums[i]\\n        return max(dp)\\n```\\n\\nThe time complexity is O(n\\\\*k)\\n\\nHowever, this does not pass the OJ. Could we optimize it further? The answer is yes. If we look at the innermost loop, acutally we are computing the maximum over a sliding window of size k + 1 ([i - k, i]). It is similar to problem [239](https://wenxu1024.github.io/2021/01/02/lc239.html). We can utilize a decreasing queue to solve it. That is when the front of queue went outside of the windowing, we pop it out. And if the end of the queue is smaller than the current val, we pop the end of the queue before appending the current val to the queue.\\n\\nBelow is the implementation\\n\\n```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        queue = collections.deque()\\n        n = len(nums)\\n        ret = [0 for i in range(n - k + 1)]\\n        for i in range(n):\\n            while len(queue) and i - queue[0] + 1 > k:\\n                queue.popleft()\\n            while len(queue) and nums[queue[-1]] < nums[i]:\\n                queue.pop()\\n            queue.append(i)\\n            if i >= k - 1:\\n                ret[i - k + 1] = nums[queue[0]]\\n        return ret\\n```\\n\\nTime complexity is O(3\\\\*n). Since element is added to and poppped out of the queue once. The last return max take O(n).",
                "solutionTags": [],
                "code": "```python\\ndp[i] = max(dp[i - 1], ..., dp[i - k]) + nums[i]\\n\\nret = max(dp[i])\\n```\n```python\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        let dp[i] be the maximum subset sum with nums[i] as the last element in the subsequence\\n        then ret = max(dp[i]) for i in range(0,n)\\n        \\n        dp[i] = max(dp[i - 1], dp[i - 2], .., dp[i - k]) + nums[i]\\n        \\'\\'\\'\\n        n = len(nums)\\n        dp = [0 for i in range(n)]\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            for j in range(1, k + 1):\\n                dp[i] = max(dp[i], dp[i - j])\\n            dp[i] += nums[i]\\n        return max(dp)\\n```\n```python\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        queue = collections.deque()\\n        n = len(nums)\\n        ret = [0 for i in range(n - k + 1)]\\n        for i in range(n):\\n            while len(queue) and i - queue[0] + 1 > k:\\n                queue.popleft()\\n            while len(queue) and nums[queue[-1]] < nums[i]:\\n                queue.pop()\\n            queue.append(i)\\n            if i >= k - 1:\\n                ret[i - k + 1] = nums[queue[0]]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984185,
                "title": "java-solution-dp-and-monotonic-queue-time-o-n",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] f = new int[n];\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            while (i > k && !queue.isEmpty() && queue.peekFirst() < i - k) {\\n                queue.pollFirst();\\n            }\\n            f[i] = Math.max(queue.isEmpty() ? 0 : f[queue.peekFirst()], 0) + nums[i];\\n            while (!queue.isEmpty() && f[i] >= f[queue.peekLast()]) {\\n                queue.pollLast();\\n            }\\n            queue.offer(i);\\n            ans = Math.max(ans, f[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] f = new int[n];\\n        ArrayDeque<Integer> queue = new ArrayDeque<>();\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            while (i > k && !queue.isEmpty() && queue.peekFirst() < i - k) {\\n                queue.pollFirst();\\n            }\\n            f[i] = Math.max(queue.isEmpty() ? 0 : f[queue.peekFirst()], 0) + nums[i];\\n            while (!queue.isEmpty() && f[i] >= f[queue.peekLast()]) {\\n                queue.pollLast();\\n            }\\n            queue.offer(i);\\n            ans = Math.max(ans, f[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949950,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time",
                "content": "**Explanation**\\nWe use a hashtable (DP) `index_to_maximum_sequence[<position>]` to store the sum of the best subsequence among all subsequences which include the element on the position `<position>` as their last element. The deque `window_maximum_indices` stores the indices of the best subsequences which end in an element within the window. Whenver a new element becomes part of the window, the best subsequence is calculated by adding the sum of the best subsequence among all best subsequences which end in an element within the window (or `0` if all sums are negative) to the current element. This new best subsequence replaces all best sequences which are smaller than or equal to the sum of this subsequence since it appears later index-wise (its last element) with a sum at least as high making it possible to combine more elements with this sequence later. This is achieved by removing the indices of the best subsequences up to the first one which is higher in `window_maximum_indices`. Due to the nature of this process, the stored indices are sorted in descending order. If the smallest index, which is the last element in the deque, becomes invalid (`current_index - smallest_max_index < k`), it will be removed and the corresponding best subsequence will not be considered anymore. In the end, we return the highest subsequence sum which is the highest value in `index_to_maximum_sequence`.\\n__________________\\n**Runtime Complexity**\\n`O(n)` since the indices of the input elements are visited twice at most.\\n_________________\\n**Space Complexity**\\n`O(n)` since our hashtable is of the same size as the input (this can be optimized since the subsequences which are not part of the window anymore can be ignored).\\n________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        window_maximum_indices    = collections.deque( [0] )\\n        index_to_maximum_sequence = [ nums[0] ]\\n        \\n        \\n        for i in range( 1, len(nums) ):\\n            if ( i - k > window_maximum_indices[-1] ):\\n                window_maximum_indices.pop()\\n\\n            index_to_maximum_sequence.append( nums[i] + max( 0, index_to_maximum_sequence[ window_maximum_indices[-1] ] ) )\\n            \\n            \\n            while ( len(window_maximum_indices) and index_to_maximum_sequence[-1] >= index_to_maximum_sequence[ window_maximum_indices[0] ] ):\\n                window_maximum_indices.popleft()\\n                \\n            window_maximum_indices.appendleft(i)\\n            \\n        return max(index_to_maximum_sequence)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        window_maximum_indices    = collections.deque( [0] )\\n        index_to_maximum_sequence = [ nums[0] ]\\n        \\n        \\n        for i in range( 1, len(nums) ):\\n            if ( i - k > window_maximum_indices[-1] ):\\n                window_maximum_indices.pop()\\n\\n            index_to_maximum_sequence.append( nums[i] + max( 0, index_to_maximum_sequence[ window_maximum_indices[-1] ] ) )\\n            \\n            \\n            while ( len(window_maximum_indices) and index_to_maximum_sequence[-1] >= index_to_maximum_sequence[ window_maximum_indices[0] ] ):\\n                window_maximum_indices.popleft()\\n                \\n            window_maximum_indices.appendleft(i)\\n            \\n        return max(index_to_maximum_sequence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835137,
                "title": "100-optimising-kaden-s-approach-of-o-n-k-to-linear-o-n-using-deque",
                "content": "# **Kaden\\'s Approach O(N*K)**\\n***12/15 Test case***\\n\\nState of dp[i]  = For the current element at i in nums, what would be the maxSum we can get if we include the nums[i]\\n\\nChoices : { Start new subsequence from nums , or include this value nums[i] int last j\\'th subsequence } j = [i-k , i-1]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t`\\tmax( nums[i] , dp[j]+nums[i] )`\\n\\nNow find the maximum value that we Encountered => maxValue\\n\\n``` \\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) { \\n\\t\\t // brute kaden\\'s\\n        \\n        vector<int> dp(nums.size(),-100000);\\n        \\n        int maxValue = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1 ; j>=0 && j>=i-k ; j--)\\n            {\\n                dp[i] = max({dp[i],dp[j]+nums[i],nums[i]});   \\n                maxValue = max(maxValue,dp[i]);\\n            }\\n        }\\n        \\n        return maxValue;\\n \\n    }\\n};\\n```\\n\\n# **Optimisation of finding the maximum for K size window** **O(N)**\\n**100% Time**\\n\\nPreviously what we were doing was to maximise the dp[j] + nums[i]\\nWhich can be done lineraly using Deque by mantainig the decreasing deque \\n( sliding window maximum - Leetcode)\\n\\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        // optimise using deque\\n        \\n        vector<int> dp(nums.size());\\n        \\n        deque<int> maxWindow;\\n        \\n        dp[0] = nums[0];\\n        maxWindow.push_back(0);\\n        \\n        int maxValue = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // the proximity for an element is only the last k characters so remove all the indexes which are less than i-k\\n            while(maxWindow.empty()==false && maxWindow.front() < i-k)\\n                maxWindow.pop_front();\\n\\n            // dp[i] = { max value from previous k size window + nums[i] , or nums[i] }\\n            dp[i] = max(dp[maxWindow.front()]+nums[i],nums[i]);\\n            maxValue = max(maxValue,dp[i]);\\n            \\n\\n            // now update the maxWindow Value from the current dp[i] value\\n            while(maxWindow.empty()==false && dp[i] > dp[maxWindow.back()])\\n                maxWindow.pop_back();\\n            maxWindow.push_back(i);\\n            \\n        }\\n        \\n        \\n        \\n        return maxValue;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) { \\n\\t\\t // brute kaden\\'s\\n        \\n        vector<int> dp(nums.size(),-100000);\\n        \\n        int maxValue = nums[0];\\n        dp[0] = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            for(int j=i-1 ; j>=0 && j>=i-k ; j--)\\n            {\\n                dp[i] = max({dp[i],dp[j]+nums[i],nums[i]});   \\n                maxValue = max(maxValue,dp[i]);\\n            }\\n        }\\n        \\n        return maxValue;\\n \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Solution()\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n    }\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        // optimise using deque\\n        \\n        vector<int> dp(nums.size());\\n        \\n        deque<int> maxWindow;\\n        \\n        dp[0] = nums[0];\\n        maxWindow.push_back(0);\\n        \\n        int maxValue = nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            // the proximity for an element is only the last k characters so remove all the indexes which are less than i-k\\n            while(maxWindow.empty()==false && maxWindow.front() < i-k)\\n                maxWindow.pop_front();\\n\\n            // dp[i] = { max value from previous k size window + nums[i] , or nums[i] }\\n            dp[i] = max(dp[maxWindow.front()]+nums[i],nums[i]);\\n            maxValue = max(maxValue,dp[i]);\\n            \\n\\n            // now update the maxWindow Value from the current dp[i] value\\n            while(maxWindow.empty()==false && dp[i] > dp[maxWindow.back()])\\n                maxWindow.pop_back();\\n            maxWindow.push_back(i);\\n            \\n        }\\n        \\n        \\n        \\n        return maxValue;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 806662,
                "title": "java-deque",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        Deque<Integer> q = new ArrayDeque();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            dp[i]=nums[i];\\n            \\n            // element is out of range\\n            if(i>k && q.peekFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            dp[i]=Math.max(dp[i],q.peek()+nums[i]);\\n            \\n            // remove untill currrent sum is greater than last element\\n            while(!q.isEmpty() && (q.peekLast()<dp[i])){\\n                q.pollLast();\\n            }\\n            q.offerLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n\\n==============Timeout Solution=================\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        for(int i = 1; i < nums.length; ++i){\\n            dp[i] = nums[i];\\n            for(int j = i-1; i-k <= j && j >= 0; --j){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        Deque<Integer> q = new ArrayDeque();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            dp[i]=nums[i];\\n            \\n            // element is out of range\\n            if(i>k && q.peekFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            dp[i]=Math.max(dp[i],q.peek()+nums[i]);\\n            \\n            // remove untill currrent sum is greater than last element\\n            while(!q.isEmpty() && (q.peekLast()<dp[i])){\\n                q.pollLast();\\n            }\\n            q.offerLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n\\n==============Timeout Solution=================\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = Integer.MIN_VALUE;\\n        max = Math.max(dp[0], max);\\n        for(int i = 1; i < nums.length; ++i){\\n            dp[i] = nums[i];\\n            for(int j = i-1; i-k <= j && j >= 0; --j){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            max = Math.max(dp[i], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802792,
                "title": "c-top-down-dfs-dp-with-segment-tree-o-nlogn",
                "content": "```dp(i)=nums[i]+max(0,dp(i+1),dp(i+2),...,dp(i+k))```\\nSo, if we select the ith number , then we have to select only the first positive number in the range of ```[i+1,i+k]```. All subsequent positive numbers will be taken care of by the subproblem of the dp. We only have to look for positive numbers because adding a negative number will only reduce the sum. If we take a negative number, which inturn will give access to net positive numbers, for that case, if you can\\'t find a positive number in the given range, return the largest negative number in that range.\\n```\\nvector<int> tree;\\nint memo[100000];\\nint build(int start,int end,vector<int>& arr,int i)\\n{\\n    if(start==end)\\n        return tree[i]=start;\\n    else\\n    {\\n        int q=start+(end-start)/2;\\n        int left=build(start,q,arr,2*i+1),right=build(q+1,end,arr,2*i+2);\\n        if(arr[left]>0)\\n            return tree[i]=left;\\n        else if(arr[right]>0)\\n            return tree[i]=right;\\n        else\\n            return tree[i]=(arr[left]>arr[right]?left:right);\\n    }\\n}\\nint query(int start,int end,int lo,int hi,int i,vector<int>& arr)\\n{\\n    if(end<lo||start>hi)\\n        return -1;\\n    else if(start<=lo&&hi<=end)\\n        return tree[i];\\n    else\\n    {\\n        int q=lo+(hi-lo)/2;\\n        int left=query(start,end,lo,q,2*i+1,arr),right=query(start,end,q+1,hi,2*i+2,arr);\\n        if(left==-1)\\n            return right;\\n        if(right==-1)\\n            return left;\\n        if(arr[left]>0)\\n            return left;\\n        else if(arr[right]>0)\\n            return right;\\n        else\\n            return arr[left]>arr[right]?left:right;\\n    }\\n}\\nint dp(int i,vector<int>& arr,int k)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    else if(memo[i]!=-1)\\n        return memo[i];\\n    else\\n    {\\n        int q=0;\\n        if(i+1<arr.size())\\n        {\\n            int t=query(i+1,min(i+k,(int)arr.size()-1),0,arr.size()-1,0,arr);\\n            q=max(q,dp(t,arr,k));\\n        }\\n        return memo[i]=arr[i]+q;\\n    }\\n}\\nint constrainedSubsetSum(vector<int>& nums, int k) \\n{\\n    int n=nums.size();\\n    int x = (int)(ceil(log2(n)));  \\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    build(0,nums.size()-1,nums,0);\\n    memset(memo,-1,sizeof(memo));\\n    int ret=INT_MIN;\\n    for(int i=0;i<n;++i)\\n        ret=max(ret,dp(i,nums,k));\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```dp(i)=nums[i]+max(0,dp(i+1),dp(i+2),...,dp(i+k))```\n```[i+1,i+k]```\n```\\nvector<int> tree;\\nint memo[100000];\\nint build(int start,int end,vector<int>& arr,int i)\\n{\\n    if(start==end)\\n        return tree[i]=start;\\n    else\\n    {\\n        int q=start+(end-start)/2;\\n        int left=build(start,q,arr,2*i+1),right=build(q+1,end,arr,2*i+2);\\n        if(arr[left]>0)\\n            return tree[i]=left;\\n        else if(arr[right]>0)\\n            return tree[i]=right;\\n        else\\n            return tree[i]=(arr[left]>arr[right]?left:right);\\n    }\\n}\\nint query(int start,int end,int lo,int hi,int i,vector<int>& arr)\\n{\\n    if(end<lo||start>hi)\\n        return -1;\\n    else if(start<=lo&&hi<=end)\\n        return tree[i];\\n    else\\n    {\\n        int q=lo+(hi-lo)/2;\\n        int left=query(start,end,lo,q,2*i+1,arr),right=query(start,end,q+1,hi,2*i+2,arr);\\n        if(left==-1)\\n            return right;\\n        if(right==-1)\\n            return left;\\n        if(arr[left]>0)\\n            return left;\\n        else if(arr[right]>0)\\n            return right;\\n        else\\n            return arr[left]>arr[right]?left:right;\\n    }\\n}\\nint dp(int i,vector<int>& arr,int k)\\n{\\n    if(i>=arr.size())\\n        return 0;\\n    else if(memo[i]!=-1)\\n        return memo[i];\\n    else\\n    {\\n        int q=0;\\n        if(i+1<arr.size())\\n        {\\n            int t=query(i+1,min(i+k,(int)arr.size()-1),0,arr.size()-1,0,arr);\\n            q=max(q,dp(t,arr,k));\\n        }\\n        return memo[i]=arr[i]+q;\\n    }\\n}\\nint constrainedSubsetSum(vector<int>& nums, int k) \\n{\\n    int n=nums.size();\\n    int x = (int)(ceil(log2(n)));  \\n    int max_size = 2*(int)pow(2, x) - 1;\\n    tree.resize(max_size);\\n    build(0,nums.size()-1,nums,0);\\n    memset(memo,-1,sizeof(memo));\\n    int ret=INT_MIN;\\n    for(int i=0;i<n;++i)\\n        ret=max(ret,dp(i,nums,k));\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 779631,
                "title": "c-14lines-code-with-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> sums(nums);\\n        priority_queue<pair<int, int>> q;\\n        int ans = INT_MIN;\\n        for (int i = 0; i < sums.size(); i++) {\\n            while (!q.empty() && q.top().second < i-k)\\n                q.pop();\\n            int maximum = 0;\\n            if (!q.empty())\\n                maximum = q.top().first;\\n            sums[i] = maximum > 0 ? sums[i]+maximum : sums[i];\\n            ans = max(ans, sums[i]);\\n            q.push(make_pair(sums[i], i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector<int> sums(nums);\\n        priority_queue<pair<int, int>> q;\\n        int ans = INT_MIN;\\n        for (int i = 0; i < sums.size(); i++) {\\n            while (!q.empty() && q.top().second < i-k)\\n                q.pop();\\n            int maximum = 0;\\n            if (!q.empty())\\n                maximum = q.top().first;\\n            sums[i] = maximum > 0 ? sums[i]+maximum : sums[i];\\n            ans = max(ans, sums[i]);\\n            q.push(make_pair(sums[i], i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769496,
                "title": "java-dp-mono-deque",
                "content": "Two key points\\n1. DP with the right ending points of the subarray.\\n2. To further reduce time complexity, use mononiticly decreasing deque to store the index of DP values. To design it, consider two aspects: recency and max value. If a DP value is both smaller and less recent than the current DP value, then it can be deleted, since it will be dominated by the current DP value.\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        // DP to store the max ending with current index\\n        int[] dp = new int[nums.length];\\n        // Monotonic decreasing deque to store the index of dp value\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            dp[i] = nums[i];\\n            while (!deque.isEmpty() && i - deque.peekFirst() > k) {\\n                deque.pollFirst();\\n            }\\n            if (!deque.isEmpty())\\n                dp[i] = Math.max(dp[i], dp[i] + dp[deque.peekFirst()]);\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < dp.length; ++i)\\n            res = Math.max(dp[i], res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        // DP to store the max ending with current index\\n        int[] dp = new int[nums.length];\\n        // Monotonic decreasing deque to store the index of dp value\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            dp[i] = nums[i];\\n            while (!deque.isEmpty() && i - deque.peekFirst() > k) {\\n                deque.pollFirst();\\n            }\\n            if (!deque.isEmpty())\\n                dp[i] = Math.max(dp[i], dp[i] + dp[deque.peekFirst()]);\\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\\n                deque.pollLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        int res = Integer.MIN_VALUE;\\n        for (int i = 0; i < dp.length; ++i)\\n            res = Math.max(dp[i], res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748456,
                "title": "c-o-n-w-o-k-space",
                "content": "```\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<std::pair<int,int>> seen;\\n        int ans = INT_MIN, l = 0, r = 0;\\n        while(r < nums.size()) {\\n            while(r - l <= k) {\\n                int current = seen.empty() ? nums[r] : seen.front().first + nums[r];\\n                ans = max(ans, current);\\n                while(!seen.empty() && seen.back().first < current) {\\n                    seen.pop_back();\\n                }\\n                if (current > 0) {\\n                    seen.push_back(std::make_pair(current, r));\\n                }\\n                r++;\\n            }\\n            if(seen.front().second == l) {\\n                seen.pop_front();\\n            }\\n            l++;\\n        }  \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<std::pair<int,int>> seen;\\n        int ans = INT_MIN, l = 0, r = 0;\\n        while(r < nums.size()) {\\n            while(r - l <= k) {\\n                int current = seen.empty() ? nums[r] : seen.front().first + nums[r];\\n                ans = max(ans, current);\\n                while(!seen.empty() && seen.back().first < current) {\\n                    seen.pop_back();\\n                }\\n                if (current > 0) {\\n                    seen.push_back(std::make_pair(current, r));\\n                }\\n                r++;\\n            }\\n            if(seen.front().second == l) {\\n                seen.pop_front();\\n            }\\n            l++;\\n        }  \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 651679,
                "title": "python-dp-using-deque-o-n-time-o-k-space-brief",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        res, dp = nums[0], collections.deque([(0, nums[0])])\\n        for i in range(1, len(nums)):\\n            maxSeqSumEndsHere = nums[i] + max(0, dp[0][1])\\n            if dp[0][0] + k == i:\\n                dp.popleft()\\n            while dp and dp[-1][1] <= maxSeqSumEndsHere:\\n                dp.pop()\\n            dp.append((i, maxSeqSumEndsHere))\\n            res = max(res, maxSeqSumEndsHere)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        res, dp = nums[0], collections.deque([(0, nums[0])])\\n        for i in range(1, len(nums)):\\n            maxSeqSumEndsHere = nums[i] + max(0, dp[0][1])\\n            if dp[0][0] + k == i:\\n                dp.popleft()\\n            while dp and dp[-1][1] <= maxSeqSumEndsHere:\\n                dp.pop()\\n            dp.append((i, maxSeqSumEndsHere))\\n            res = max(res, maxSeqSumEndsHere)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634603,
                "title": "c-kaden-s-with-priority-queue-time-o-nlogn-space-o-n",
                "content": "The idea is very similar to Kaden\\'s, however, instead of calculating the max-sum-so-far for the current index based solely on the last index, we greedily pick the maximum from the last k indices.\\n\\n```\\nclass Solution{\\n  public:\\n    int constrainedSubsetSum(vector<int>& nums, int k){\\n\\t  // max heap to store max sum so far for the last k elements \\n\\t  // the elements of the heap are pairs, {max sum for the index, index}\\n      priority_queue<pair<int, int>> pq;\\n\\t  // res = final result, cur = max sum so far for the current index\\n      int len = (int)nums.size(), res = 1 << 31, cur = 0;\\n      for(int idx = 0; idx < len; ++idx){\\n        while(!pq.empty() && idx - pq.top().second > k){\\n\\t\\t  // exclude the numbers which are not within k distance\\n          pq.pop();\\n        }\\n\\t\\t// kaden\\'s step, find the max sum for the current index and push it in the heap\\n        auto t = pq.empty() ? 0 : pq.top().first;\\t\\t\\n        cur = max(t + nums[idx], nums[idx]);                \\n        res = max(cur, res);\\n        pq.emplace(cur, idx);\\n      }\\n      return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution{\\n  public:\\n    int constrainedSubsetSum(vector<int>& nums, int k){\\n\\t  // max heap to store max sum so far for the last k elements \\n\\t  // the elements of the heap are pairs, {max sum for the index, index}",
                "codeTag": "Java"
            },
            {
                "id": 606666,
                "title": "simple-o-n-solution-with-decreasing-deque-and-without-using-extra-dp-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        \\n        deque<pair<int, int>> q; // pair of <indexes, max subsequence sum ending at that index. We need not to have additional dp array \\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        int result = nums[0];\\n        \\n        q.push_back({0, nums[0]});\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            if(q.front().first < i-k)\\n                q.pop_front();\\n            \\n            \\n            int maxSubSequenceSumEndingHere = max(q.front().second + nums[i], nums[i]);\\n            result = max(result, maxSubSequenceSumEndingHere);\\n            \\n            while(!q.empty() && q.back().second <= maxSubSequenceSumEndingHere)\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back({i, maxSubSequenceSumEndingHere});\\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        \\n        deque<pair<int, int>> q; // pair of <indexes, max subsequence sum ending at that index. We need not to have additional dp array \\n        \\n        \\n        \\n        int n = nums.size();\\n        \\n        int result = nums[0];\\n        \\n        q.push_back({0, nums[0]});\\n        \\n        for(int i = 1; i<n; i++)\\n        {\\n            if(q.front().first < i-k)\\n                q.pop_front();\\n            \\n            \\n            int maxSubSequenceSumEndingHere = max(q.front().second + nums[i], nums[i]);\\n            result = max(result, maxSubSequenceSumEndingHere);\\n            \\n            while(!q.empty() && q.back().second <= maxSubSequenceSumEndingHere)\\n            {\\n                q.pop_back();\\n            }\\n            q.push_back({i, maxSubSequenceSumEndingHere});\\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599195,
                "title": "thinking-process-of-why-we-need-decreasing-deque-monotonic-deque",
                "content": "There are brilliant answers in other post with similiar idea but I wish to share my thinking process here why decreasing deque was required. \\n\\nAfter reading the question, I think we need dp and I start to think about how to draw all states in tree. A good way might be ending with the current index being used. \\n\\nFor example, given input [10,2,-10,-8,5,20] and k = 2. When index is 4, we must use 5. If we want to connect to the begining of input 10, we cannot skip -10 or -8. \\n\\nTherefore, the state transfer method is something similar to dp[cur] = max(dp[cur], dp[i]+num[cur]) where i is from the range of `cur - k` to `cur`. \\n\\nAnswer must live in any end cur number is used. Therefore, we get the maximum value from dp array. \\n\\nTherefore, I have my first solution. \\n\\n```\\npublic int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n         dp[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            for (int j = Math.max(0, i-k); j < i; j++){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```\\n\\nHowever, this will give you \"Time Limit Exceeded\" as the time complexity can run up to N(nk) where n is the lenth of input array. \\n\\nWe need to optimize following step. \\n\\n```\\nfor (int j = Math.max(0, i-k); j < i; j++){\\n\\tdp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n}\\n```\\n\\nThinking about what we did here is to get the best (largest) value in the range of i-k and i. If we can have an efficient data structure and query the best within a range while **maintaining it is not costly**. We need to maintain it when we travel across the array. We don\\'t need element that is smaller than i-k, for example,  [10,2,-10,-8,5,20] and k = 2, when we inspect 20, we only care dp[3], dp[4], other index must be poped from the data structure. \\n\\nHere we need to store the index in the data structure and not the value as we need to drop it easily. So the requirement is get max value efficiently and pop value when it is out of range. \\n\\nThis give you monotonic deque and of course you have to do this problem before. https://leetcode.com/problems/sliding-window-maximum/ \\n\\nTherefore, we can have the second solution and time will be optimized to O(N).\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(0);\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            \\n            // fulfill two conditions, query max and moving efficiently \\n            // make sure stack is valid \\n            while (!stack.isEmpty() && stack.peekFirst() < i - k){\\n                stack.pollFirst();\\n            }\\n            dp[i] = Math.max(dp[i], dp[stack.peekFirst()] + nums[i]);\\n            // for (int j = Math.max(0, i-k); j < i; j++){ // do this more efficiently \\n            //     dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            // }\\n            \\n            // maintain stack \\n            while(!stack.isEmpty() && dp[i] > dp[stack.peekLast()]){\\n                stack.pollLast();\\n            }\\n            stack.offerLast(i);\\n            \\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n         dp[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            for (int j = Math.max(0, i-k); j < i; j++){\\n                dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            }\\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n```\n```\\nfor (int j = Math.max(0, i-k); j < i; j++){\\n\\tdp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n}\\n```\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int res = nums[0];\\n        int[] dp = new int[n]; // maximum using n-1 index \\n        dp[0] = nums[0];\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.offerLast(0);\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n            \\n            // fulfill two conditions, query max and moving efficiently \\n            // make sure stack is valid \\n            while (!stack.isEmpty() && stack.peekFirst() < i - k){\\n                stack.pollFirst();\\n            }\\n            dp[i] = Math.max(dp[i], dp[stack.peekFirst()] + nums[i]);\\n            // for (int j = Math.max(0, i-k); j < i; j++){ // do this more efficiently \\n            //     dp[i] = Math.max(dp[i], dp[j]+nums[i]);\\n            // }\\n            \\n            // maintain stack \\n            while(!stack.isEmpty() && dp[i] > dp[stack.peekLast()]){\\n                stack.pollLast();\\n            }\\n            stack.offerLast(i);\\n            \\n            res = Math.max(res, dp[i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598436,
                "title": "simple-c-code-maximum-value-is-a-k-size-sliding-window",
                "content": "It\\'s not a hard question.\\n\\nBut just very curious how people could solve this kind of questions in less than 5 min in the contest....\\n\\n\\n```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\tint res = INT_MIN;\\n\\tvector<int> counter(nums.size(), 0);\\n\\tdeque<int> q;\\n\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\n\\t\\tint maxVal = 0;\\n\\n\\t\\tif (!q.empty()) maxVal = counter[q.front()];\\n\\n\\t\\tcounter[i] = max(nums[i], nums[i] + maxVal);\\n\\n\\t\\twhile(!q.empty() && counter[i] > counter[q.back()]) q.pop_back();\\n\\t\\tq.push_back(i);\\n\\n\\t\\tif (q.front() <= i - k) q.pop_front();\\n\\n\\t\\tres = max(res, counter[i]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\tint res = INT_MIN;\\n\\tvector<int> counter(nums.size(), 0);\\n\\tdeque<int> q;\\n\\n\\tfor (int i = 0; i < nums.size(); ++i) {\\n\\n\\t\\tint maxVal = 0;\\n\\n\\t\\tif (!q.empty()) maxVal = counter[q.front()];\\n\\n\\t\\tcounter[i] = max(nums[i], nums[i] + maxVal);\\n\\n\\t\\twhile(!q.empty() && counter[i] > counter[q.back()]) q.pop_back();\\n\\t\\tq.push_back(i);\\n\\n\\t\\tif (q.front() <= i - k) q.pop_front();\\n\\n\\t\\tres = max(res, counter[i]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 598237,
                "title": "simple-c-solution-with-multiset",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int constrainedSubsetSum(vector<int>& nums, int k) \\n    {\\n        int result=-2147483648;\\n        int n=nums.size();\\n        int dp[n+1];//dp[i+1] is the maximum sum of subarray nums[0]~nums[i]\\n        memset(dp,0,sizeof(dp));\\n        multiset<int> m={0};//maintain a list for last k states (for dp[i+1]: dp[i-k+1] to dp[i] are all feasible states)\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i+1]=nums[i];//nums[i] can always be the first element to start with\\n            dp[i+1]=max(dp[i+1],dp[i+1]+*m.rbegin());//*m.rbegin() is the largest among dp[i-k+1] to dp[i]\\n            if(m.size()<k)\\n            {\\n                m.insert(dp[i+1]);//still not reach the capacity\\n            }\\n            else\\n            {\\n                m.erase(m.find(dp[i+1-k]));//remove the state which is out of reach\\n                m.insert(dp[i+1]);//add the current state(it will be the previous state in the next round) instead\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            result=max(result,dp[i]);//all the nums[i] can be the last element\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int constrainedSubsetSum(vector<int>& nums, int k) \\n    {\\n        int result=-2147483648;\\n        int n=nums.size();\\n        int dp[n+1];//dp[i+1] is the maximum sum of subarray nums[0]~nums[i]\\n        memset(dp,0,sizeof(dp));\\n        multiset<int> m={0};//maintain a list for last k states (for dp[i+1]: dp[i-k+1] to dp[i] are all feasible states)\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i+1]=nums[i];//nums[i] can always be the first element to start with\\n            dp[i+1]=max(dp[i+1],dp[i+1]+*m.rbegin());//*m.rbegin() is the largest among dp[i-k+1] to dp[i]\\n            if(m.size()<k)\\n            {\\n                m.insert(dp[i+1]);//still not reach the capacity\\n            }\\n            else\\n            {\\n                m.erase(m.find(dp[i+1-k]));//remove the state which is out of reach\\n                m.insert(dp[i+1]);//add the current state(it will be the previous state in the next round) instead\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            result=max(result,dp[i]);//all the nums[i] can be the last element\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598155,
                "title": "java-o-nlogk-easy-to-understand",
                "content": "Explanation: We can transform the problem into `dp[i]`, where `dp[i]` means the best sum we can do starting at position `i`, **obligatorily using** the element at `nums[i]`. Then, when we are computing for position `i`, we keep track of the the last `k` sums, and check if `nums[i]` plus the best sum among those is better than just `nums[i]`.\\n\\nI implement this using a `TreeMap` to find the best result in the last K and to also account for duplicates, and a `LinkedList` to keep track of the last K window.\\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        TreeMap<Integer,Integer> count = new TreeMap<Integer,Integer>();\\n        LinkedList<Integer> window = new LinkedList<Integer>();\\n        \\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int ans = nums[0];\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            Integer best = count.size()>0?count.lastKey():0;\\n            \\n            dp[i] = Math.max(dp[i],nums[i]+best);\\n            \\n            window.addFirst(dp[i]);\\n            count.put(dp[i],count.getOrDefault(dp[i],0)+1);\\n            \\n            ans = Math.max(ans,dp[i]);\\n            \\n            if (window.size() > k) {\\n                int tail = window.removeLast();\\n                if (count.get(tail) == 1) count.remove(tail);\\n                else count.put(tail,count.get(tail)-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        TreeMap<Integer,Integer> count = new TreeMap<Integer,Integer>();\\n        LinkedList<Integer> window = new LinkedList<Integer>();\\n        \\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int ans = nums[0];\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            dp[i] = nums[i];\\n            Integer best = count.size()>0?count.lastKey():0;\\n            \\n            dp[i] = Math.max(dp[i],nums[i]+best);\\n            \\n            window.addFirst(dp[i]);\\n            count.put(dp[i],count.getOrDefault(dp[i],0)+1);\\n            \\n            ans = Math.max(ans,dp[i]);\\n            \\n            if (window.size() > k) {\\n                int tail = window.removeLast();\\n                if (count.get(tail) == 1) count.remove(tail);\\n                else count.put(tail,count.get(tail)-1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597892,
                "title": "c-dp-with-priority-queue",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector <int> dp(nums.size(), 0);\\n        priority_queue <pair <int, int>> q;\\n        dp[0] = nums[0];\\n        q.emplace(dp[0], 0);\\n        for(int i = 1; i < nums.size(); i++){ \\n            while(q.size() && q.top().second < i-k) q.pop();\\n            dp[i] = max(q.top().first + nums[i], nums[i]);\\n            q.emplace(dp[i], i);\\n        }   \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        vector <int> dp(nums.size(), 0);\\n        priority_queue <pair <int, int>> q;\\n        dp[0] = nums[0];\\n        q.emplace(dp[0], 0);\\n        for(int i = 1; i < nums.size(); i++){ \\n            while(q.size() && q.top().second < i-k) q.pop();\\n            dp[i] = max(q.top().first + nums[i], nums[i]);\\n            q.emplace(dp[i], i);\\n        }   \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597851,
                "title": "python-dp-maxheap",
                "content": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums) # dp[i] = max subset sum of nums[:i+1] when taking i-th value\\n        dp[0] = nums[0]\\n        heap = [(-dp[0],0)] # max heap of (-dp[i], i)\\n        for i in range(1, len(nums)):\\n            while i-heap[0][1] > k:\\n                heapq.heappop(heap)\\n            mdp = -heap[0][0]\\n            dp[i] = max(nums[i], nums[i]+mdp)\\n            heapq.heappush(heap, (-dp[i],i))\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0]*len(nums) # dp[i] = max subset sum of nums[:i+1] when taking i-th value\\n        dp[0] = nums[0]\\n        heap = [(-dp[0],0)] # max heap of (-dp[i], i)\\n        for i in range(1, len(nums)):\\n            while i-heap[0][1] > k:\\n                heapq.heappop(heap)\\n            mdp = -heap[0][0]\\n            dp[i] = max(nums[i], nums[i]+mdp)\\n            heapq.heappush(heap, (-dp[i],i))\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 597844,
                "title": "segment-tree-c-solution",
                "content": "```\\nclass SegmentTree{\\n  long int n;   \\n  vector<long int> tree;\\n\\npublic:\\n  SegmentTree(long int v) : n(4*v){\\n    tree.resize(4*v);\\n  }\\n\\n  long int query(long int requiredLeft, long int requiredRight, long int left, long int right, long int current = 1){\\n    if(left > right)\\n      return 0;\\n\\n    if(requiredLeft > right || requiredRight < left)\\n      return 0;\\n\\n    if(left >= requiredLeft && right <= requiredRight)\\n      return tree[current];\\n\\n    long int mid = (left + right) / 2;\\n    return max(query(requiredLeft,requiredRight,left,mid,2*current) , query(requiredLeft,requiredRight,mid+1,right,2*current + 1));\\n  }\\n\\n  void update(long int idx, long int value, long int left, long int right, long int current = 1){\\n    if(idx < left || idx > right)\\n      return;\\n\\n    tree[current] = max(value,tree[current]);\\n    if(left != right){\\n      long int mid = (left + right) / 2;\\n      update(idx,value,left,mid,2*current);\\n      update(idx,value,mid+1,right,2*current + 1);\\n    }\\n  }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        long int n = nums.size();\\n        SegmentTree tree(n + 1);\\n        vector<long int> ans(n);\\n        \\n        for(long int i = 0; i < k; i++){\\n            ans[i] = max(tree.query(1,i,1,n),0L) + nums[i];\\n            tree.update(i + 1, ans[i],1,n);\\n        }\\n        \\n        for(long int i = k; i < n; i++){  \\n            ans[i] = tree.query(i - k + 1, i ,1,n) + nums[i];\\n            tree.update(i + 1, ans[i], 1, n);\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree{\\n  long int n;   \\n  vector<long int> tree;\\n\\npublic:\\n  SegmentTree(long int v) : n(4*v){\\n    tree.resize(4*v);\\n  }\\n\\n  long int query(long int requiredLeft, long int requiredRight, long int left, long int right, long int current = 1){\\n    if(left > right)\\n      return 0;\\n\\n    if(requiredLeft > right || requiredRight < left)\\n      return 0;\\n\\n    if(left >= requiredLeft && right <= requiredRight)\\n      return tree[current];\\n\\n    long int mid = (left + right) / 2;\\n    return max(query(requiredLeft,requiredRight,left,mid,2*current) , query(requiredLeft,requiredRight,mid+1,right,2*current + 1));\\n  }\\n\\n  void update(long int idx, long int value, long int left, long int right, long int current = 1){\\n    if(idx < left || idx > right)\\n      return;\\n\\n    tree[current] = max(value,tree[current]);\\n    if(left != right){\\n      long int mid = (left + right) / 2;\\n      update(idx,value,left,mid,2*current);\\n      update(idx,value,mid+1,right,2*current + 1);\\n    }\\n  }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        long int n = nums.size();\\n        SegmentTree tree(n + 1);\\n        vector<long int> ans(n);\\n        \\n        for(long int i = 0; i < k; i++){\\n            ans[i] = max(tree.query(1,i,1,n),0L) + nums[i];\\n            tree.update(i + 1, ans[i],1,n);\\n        }\\n        \\n        for(long int i = k; i < n; i++){  \\n            ans[i] = tree.query(i - k + 1, i ,1,n) + nums[i];\\n            tree.update(i + 1, ans[i], 1, n);\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597824,
                "title": "dp-with-sliding-window-beats-100",
                "content": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int maxx = dp[0];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        for (int i = 1; i < nums.length; i++) { \\n            int max = nums[i];\\n            if (!queue.isEmpty()) {\\n                max = Math.max(nums[i], nums[i] + dp[queue.peek()]);\\n            }\\n        \\n            if (!queue.isEmpty() && i - queue.peek() >= k) {\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && max > dp[queue.peek()])\\n                queue.poll();\\n            queue.add(i);\\n            dp[i] = max;\\n            maxx = Math.max(maxx, max);\\n        }\\n        \\n        return maxx;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int maxx = dp[0];\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        for (int i = 1; i < nums.length; i++) { \\n            int max = nums[i];\\n            if (!queue.isEmpty()) {\\n                max = Math.max(nums[i], nums[i] + dp[queue.peek()]);\\n            }\\n        \\n            if (!queue.isEmpty() && i - queue.peek() >= k) {\\n                queue.poll();\\n            }\\n            while (!queue.isEmpty() && max > dp[queue.peek()])\\n                queue.poll();\\n            queue.add(i);\\n            dp[i] = max;\\n            maxx = Math.max(maxx, max);\\n        }\\n        \\n        return maxx;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 597800,
                "title": "java-dp-deque-solution",
                "content": "```\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int[] dp = new int[a.length+1];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < a.length; i++) {\\n            dp[i] = a[i];\\n            while(!dq.isEmpty() && i - dq.getFirst() > k) dq.removeFirst();\\n            if(!dq.isEmpty()) dp[i] = Math.max(dp[i], dp[dq.getFirst()] + a[i]);\\n            res = Math.max(res, dp[i]);\\n            while(!dq.isEmpty() && dp[i] > dp[dq.getLast()]) dq.removeLast();\\n            dq.addLast(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int[] dp = new int[a.length+1];\\n        Deque<Integer> dq = new LinkedList<>();\\n        int res = Integer.MIN_VALUE;\\n        for(int i = 0; i < a.length; i++) {\\n            dp[i] = a[i];\\n            while(!dq.isEmpty() && i - dq.getFirst() > k) dq.removeFirst();\\n            if(!dq.isEmpty()) dp[i] = Math.max(dp[i], dp[dq.getFirst()] + a[i]);\\n            res = Math.max(res, dp[i]);\\n            while(!dq.isEmpty() && dp[i] > dp[dq.getLast()]) dq.removeLast();\\n            dq.addLast(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597752,
                "title": "python-max-min-heap-with-explanation",
                "content": "We need to store previous sums. If they are negative use min-heap, otherwise use max-heap. For each element in nums store the max possible sum along with the index value. If the index value is violated remove it from the heap. Here is the python code:\\n\\n```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        min_h = []\\n        heapq.heapify(min_h)\\n        max_h = []\\n        heapq.heapify(max_h)\\n        \\n        for i,e in enumerate(nums):\\n            if i==0:\\n                cum_sum = nums[0]\\n                max_sub = cum_sum\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,0))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, 0))    \\n            else:\\n                TT = []\\n                if min_h:\\n                    tmp = min_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(min_h)\\n                        if not min_h:\\n                            break\\n                        tmp = min_h[0]\\n                if min_h:\\n                    TT.append(min_h[0][0] + nums[i])\\n                if max_h:\\n                    tmp = max_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(max_h)\\n                        if not max_h:\\n                            break\\n                        tmp = max_h[0]\\n                if max_h:\\n                    TT.append(-max_h[0][0] + nums[i])\\n                TT.append(nums[i])\\n                \\n                cum_sum = max(TT)\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,i))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, i))    \\n                max_sub = max(max_sub, cum_sum)\\n                \\n        return max_sub\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        min_h = []\\n        heapq.heapify(min_h)\\n        max_h = []\\n        heapq.heapify(max_h)\\n        \\n        for i,e in enumerate(nums):\\n            if i==0:\\n                cum_sum = nums[0]\\n                max_sub = cum_sum\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,0))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, 0))    \\n            else:\\n                TT = []\\n                if min_h:\\n                    tmp = min_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(min_h)\\n                        if not min_h:\\n                            break\\n                        tmp = min_h[0]\\n                if min_h:\\n                    TT.append(min_h[0][0] + nums[i])\\n                if max_h:\\n                    tmp = max_h[0]\\n                    while i-tmp[1]>k:\\n                        _ = heapq.heappop(max_h)\\n                        if not max_h:\\n                            break\\n                        tmp = max_h[0]\\n                if max_h:\\n                    TT.append(-max_h[0][0] + nums[i])\\n                TT.append(nums[i])\\n                \\n                cum_sum = max(TT)\\n                if cum_sum>=0:\\n                    heapq.heappush(max_h, (-cum_sum,i))\\n                else:\\n                    heapq.heappush(min_h, (cum_sum, i))    \\n                max_sub = max(max_sub, cum_sum)\\n                \\n        return max_sub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040252,
                "title": "just-lis-with-condition-on-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n     {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) \\n        {\\n            \\n            while(!pq.empty() && pq.top().second + k  < i )\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> P;\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n     {\\n        int n = nums.size();\\n        \\n        vector<int> t(n, 0);\\n        t = nums;\\n        priority_queue<P, vector<P>> pq;\\n        pq.push({t[0], 0});\\n        \\n        int maxR = t[0];\\n        \\n        for(int i = 1; i<n; i++) \\n        {\\n            \\n            while(!pq.empty() && pq.top().second + k  < i )\\n                pq.pop();\\n            \\n            t[i] = max(t[i], nums[i] + pq.top().first);\\n            pq.push({t[i], i});\\n            \\n            maxR = max(maxR, t[i]);\\n        }\\n        \\n        \\n        return maxR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019780,
                "title": "c-using-dp-monotonic-queue-maxqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MaxStack \\n{\\n    stack<pair<int,int>> S; //{val, max}\\npublic:\\n    void push(int val)\\n    {\\n        int mx = (S.empty()) ? val : max(val, S.top().second);\\n        S.push({val, mx});\\n    }\\n\\n    void pop()\\n    {\\n        S.pop();\\n    }\\n\\n    int top()\\n    {\\n        return S.top().first;\\n    }\\n\\n    int getMax()\\n    {\\n        return S.top().second;\\n    }\\n\\n    bool empty()\\n    {\\n        return S.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S.size();\\n    }\\n};\\n\\nclass MaxQueue\\n{\\n    MaxStack S1, S2;\\npublic:\\n    void push(int val)\\n    {\\n        S1.push(val);\\n    }\\n    \\n    void tranferFromS1ToS2()\\n    {\\n        while(!S1.empty())\\n        {\\n            S2.push(S1.top());\\n            S1.pop();\\n        }\\n    }\\n\\n    void pop()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        S2.pop();\\n    }\\n\\n    int front()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        return S2.top();\\n    }\\n\\n    int getMax()\\n    {\\n        if(S2.empty()) return S1.getMax();\\n        if(S1.empty()) return S2.getMax();\\n        return max(S1.getMax(), S2.getMax());\\n    }\\n\\n    bool empty()\\n    {\\n        return S1.empty() && S2.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S1.size() + S2.size();\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    //DP + Monotonic Queue (MaxQueue)\\n    // j <= i + k => next window of size : k (starting from i + 1 to i + k)\\n    //dp[i] = maxSum if i include a[i] + ...\\n    int constrainedSubsetSum(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        MaxQueue Q;\\n        int dp[n]; memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            dp[i] = a[i];\\n\\n            if(!Q.empty()) dp[i] = max(dp[i], a[i] + Q.getMax());\\n\\n            Q.push(dp[i]);\\n\\n            while(!Q.empty() && Q.size() > k) Q.pop();\\n        }\\n\\n        int ans = dp[0];\\n        for(int i = 1; i < n; i++)\\n            ans = max(ans, dp[i]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass MaxStack \\n{\\n    stack<pair<int,int>> S; //{val, max}\\npublic:\\n    void push(int val)\\n    {\\n        int mx = (S.empty()) ? val : max(val, S.top().second);\\n        S.push({val, mx});\\n    }\\n\\n    void pop()\\n    {\\n        S.pop();\\n    }\\n\\n    int top()\\n    {\\n        return S.top().first;\\n    }\\n\\n    int getMax()\\n    {\\n        return S.top().second;\\n    }\\n\\n    bool empty()\\n    {\\n        return S.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S.size();\\n    }\\n};\\n\\nclass MaxQueue\\n{\\n    MaxStack S1, S2;\\npublic:\\n    void push(int val)\\n    {\\n        S1.push(val);\\n    }\\n    \\n    void tranferFromS1ToS2()\\n    {\\n        while(!S1.empty())\\n        {\\n            S2.push(S1.top());\\n            S1.pop();\\n        }\\n    }\\n\\n    void pop()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        S2.pop();\\n    }\\n\\n    int front()\\n    {\\n        if(S2.empty()) tranferFromS1ToS2();\\n        return S2.top();\\n    }\\n\\n    int getMax()\\n    {\\n        if(S2.empty()) return S1.getMax();\\n        if(S1.empty()) return S2.getMax();\\n        return max(S1.getMax(), S2.getMax());\\n    }\\n\\n    bool empty()\\n    {\\n        return S1.empty() && S2.empty();\\n    }\\n\\n    int size()\\n    {\\n        return S1.size() + S2.size();\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    //DP + Monotonic Queue (MaxQueue)\\n    // j <= i + k => next window of size : k (starting from i + 1 to i + k)\\n    //dp[i] = maxSum if i include a[i] + ...\\n    int constrainedSubsetSum(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        MaxQueue Q;\\n        int dp[n]; memset(&dp, 0x00, sizeof(dp));\\n\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            dp[i] = a[i];\\n\\n            if(!Q.empty()) dp[i] = max(dp[i], a[i] + Q.getMax());\\n\\n            Q.push(dp[i]);\\n\\n            while(!Q.empty() && Q.size() > k) Q.pop();\\n        }\\n\\n        int ans = dp[0];\\n        for(int i = 1; i < n; i++)\\n            ans = max(ans, dp[i]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003556,
                "title": "swift-deque-clear-solution",
                "content": "\\n```\\nclass Solution {\\n    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {\\n        let N = nums.count\\n        var dp = Array(repeating: 0, count: N)\\n        dp[0] = nums[0]\\n        var deque = Deque<Int>()\\n        deque.push(dp[0])\\n\\n        for i in 1..<N {\\n            dp[i] = max(nums[i], deque.max()! + nums[i])\\n\\n            if deque.count == k {\\n                deque.pop()\\n            }\\n            deque.push(dp[i])\\n        }\\n\\n        var res = Int.min\\n        for i in 0..<N {\\n            res = max(res, dp[i])\\n        }\\n        return res\\n    }\\n}\\n\\n//Default Deque Implementation\\nclass Deque<T:Comparable> {\\n    var q = [T]()\\n    var maxq = [T]()\\n    var minq = [T]()\\n    var count : Int { q.count }\\n    var isEmpty : Bool { q.isEmpty }\\n    func push(_ ele: T) {\\n        q.append(ele)\\n\\n        while !maxq.isEmpty, maxq.last! < ele {\\n            maxq.removeLast()\\n        }\\n        maxq.append(ele)\\n\\n        while !minq.isEmpty, minq.last! > ele {\\n            minq.removeLast()\\n        }\\n        minq.append(ele)\\n    }\\n\\n    func max() -> T? {\\n        return maxq.first\\n    }\\n\\n    func min() -> T? {\\n        return minq.first\\n    }\\n\\n    func pop() -> T? {\\n        var deleteVal = q.removeFirst()\\n        \\n        if deleteVal == maxq.first {\\n            maxq.removeFirst()\\n        }\\n\\n        if deleteVal == minq.first {\\n            minq.removeFirst()\\n        }\\n\\n        return deleteVal\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func constrainedSubsetSum(_ nums: [Int], _ k: Int) -> Int {\\n        let N = nums.count\\n        var dp = Array(repeating: 0, count: N)\\n        dp[0] = nums[0]\\n        var deque = Deque<Int>()\\n        deque.push(dp[0])\\n\\n        for i in 1..<N {\\n            dp[i] = max(nums[i], deque.max()! + nums[i])\\n\\n            if deque.count == k {\\n                deque.pop()\\n            }\\n            deque.push(dp[i])\\n        }\\n\\n        var res = Int.min\\n        for i in 0..<N {\\n            res = max(res, dp[i])\\n        }\\n        return res\\n    }\\n}\\n\\n//Default Deque Implementation\\nclass Deque<T:Comparable> {\\n    var q = [T]()\\n    var maxq = [T]()\\n    var minq = [T]()\\n    var count : Int { q.count }\\n    var isEmpty : Bool { q.isEmpty }\\n    func push(_ ele: T) {\\n        q.append(ele)\\n\\n        while !maxq.isEmpty, maxq.last! < ele {\\n            maxq.removeLast()\\n        }\\n        maxq.append(ele)\\n\\n        while !minq.isEmpty, minq.last! > ele {\\n            minq.removeLast()\\n        }\\n        minq.append(ele)\\n    }\\n\\n    func max() -> T? {\\n        return maxq.first\\n    }\\n\\n    func min() -> T? {\\n        return minq.first\\n    }\\n\\n    func pop() -> T? {\\n        var deleteVal = q.removeFirst()\\n        \\n        if deleteVal == maxq.first {\\n            maxq.removeFirst()\\n        }\\n\\n        if deleteVal == minq.first {\\n            minq.removeFirst()\\n        }\\n\\n        return deleteVal\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987592,
                "title": "python-dp-heap-sliding-window",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp=[0 for i in range(len(nums))]\\n        h=[]\\n        for i in range(len(nums)-1,-1,-1):\\n            if i+k+1<len(nums):\\n                while h and h[0][1]>=i+k+1:heappop(h)\\n            a=0\\n            if h:a=max(0,-h[0][0])\\n            dp[i]=nums[i]+a\\n            heappush(h,(-dp[i],i))\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp=[0 for i in range(len(nums))]\\n        h=[]\\n        for i in range(len(nums)-1,-1,-1):\\n            if i+k+1<len(nums):\\n                while h and h[0][1]>=i+k+1:heappop(h)\\n            a=0\\n            if h:a=max(0,-h[0][0])\\n            dp[i]=nums[i]+a\\n            heappush(h,(-dp[i],i))\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979066,
                "title": "three-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //reccusrion +memo(TLE)\\n\\n    //  unordered_map<string,int>m;\\n\\n    // int solve(int i,vector<int>&nums,int k,int p){\\n    //     if(i==nums.size())return 0;\\n\\n    //     int nottake=0;\\n    //     string temp=to_string(i)+\\',\\'+to_string(p);\\n    //     if(m.find(temp)!=m.end())return m[temp];\\n    //     if(p==-1||i-p<=k){\\n    //         nottake=solve(i+1,nums,k,p);\\n    //     }\\n    //     int take=0;\\n\\n    //     if(p==-1||i-p<=k){\\n    //         take=nums[i]+solve(i+1,nums,k,i);\\n    //     }\\n    //     return m[temp]= max(take,nottake);\\n    // }\\n   \\n\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\n    //  if(k==1)return *max_element(nums.begin(),nums.end());\\n    \\n    //   int ans= solve(0,nums,k,-1);\\n    //   if(ans==0){\\n    //       return *max_element(nums.begin(),nums.end());\\n    //   }else{\\n    //       return ans;\\n    //   }\\n    \\n    //Tabulation(TLE)\\n\\n    // int n=nums.size();\\n    // vector<int>dp(n,0);\\n    // for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    // int ans=dp[0];\\n    // for(int i=1;i<n;i++){\\n    //     for(int j=i-1;i-j<=k&&j>=0;j--){\\n    //         dp[i]=max(dp[i],nums[i]+dp[j]);\\n    //     }\\n    //     ans=max(ans,dp[i]);\\n    // }\\n\\n     //Using priority_queue(Accepted)\\n\\n     int n=nums.size();\\n    vector<int>dp(n,0);\\n\\n\\n    for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n    pq.push({dp[0],0});\\n    int ans=dp[0];\\n    for(int i=1;i<n;i++){\\n        while(!pq.empty()&&pq.top().second<i-k)pq.pop();\\n\\n        dp[i]=max(dp[i],nums[i]+pq.top().first);\\n        pq.push({dp[i],i});\\n        ans=max(ans,dp[i]);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //reccusrion +memo(TLE)\\n\\n    //  unordered_map<string,int>m;\\n\\n    // int solve(int i,vector<int>&nums,int k,int p){\\n    //     if(i==nums.size())return 0;\\n\\n    //     int nottake=0;\\n    //     string temp=to_string(i)+\\',\\'+to_string(p);\\n    //     if(m.find(temp)!=m.end())return m[temp];\\n    //     if(p==-1||i-p<=k){\\n    //         nottake=solve(i+1,nums,k,p);\\n    //     }\\n    //     int take=0;\\n\\n    //     if(p==-1||i-p<=k){\\n    //         take=nums[i]+solve(i+1,nums,k,i);\\n    //     }\\n    //     return m[temp]= max(take,nottake);\\n    // }\\n   \\n\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n\\n\\n    //  if(k==1)return *max_element(nums.begin(),nums.end());\\n    \\n    //   int ans= solve(0,nums,k,-1);\\n    //   if(ans==0){\\n    //       return *max_element(nums.begin(),nums.end());\\n    //   }else{\\n    //       return ans;\\n    //   }\\n    \\n    //Tabulation(TLE)\\n\\n    // int n=nums.size();\\n    // vector<int>dp(n,0);\\n    // for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    // int ans=dp[0];\\n    // for(int i=1;i<n;i++){\\n    //     for(int j=i-1;i-j<=k&&j>=0;j--){\\n    //         dp[i]=max(dp[i],nums[i]+dp[j]);\\n    //     }\\n    //     ans=max(ans,dp[i]);\\n    // }\\n\\n     //Using priority_queue(Accepted)\\n\\n     int n=nums.size();\\n    vector<int>dp(n,0);\\n\\n\\n    for(int i=0;i<nums.size();i++)dp[i]=nums[i];\\n    priority_queue<pair<int,int>,vector<pair<int,int>>>pq;\\n    pq.push({dp[0],0});\\n    int ans=dp[0];\\n    for(int i=1;i<n;i++){\\n        while(!pq.empty()&&pq.top().second<i-k)pq.pop();\\n\\n        dp[i]=max(dp[i],nums[i]+pq.top().first);\\n        pq.push({dp[i],i});\\n        ans=max(ans,dp[i]);\\n    }\\n    \\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954171,
                "title": "easy-to-understand-basic-solution-c-priority-queue-iit-roorkee",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({0,n-1});\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(i<=y)\\n            {\\n                int val=x+nums[i];\\n                if(val>nums[i])\\n                {\\n                    maxi=max(maxi,val);\\n                    pq.push({val,i+k});\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,nums[i]);\\n                    pq.push({nums[i],i+k});\\n                }\\n                break;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k)\\n    {\\n        int maxi=INT_MIN;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({0,n-1});\\n        for(int i=0;i<n;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n            int x=pq.top().first;\\n            int y=pq.top().second;\\n            if(i<=y)\\n            {\\n                int val=x+nums[i];\\n                if(val>nums[i])\\n                {\\n                    maxi=max(maxi,val);\\n                    pq.push({val,i+k});\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,nums[i]);\\n                    pq.push({nums[i],i+k});\\n                }\\n                break;\\n            }\\n            else\\n            {\\n                pq.pop();\\n            }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937248,
                "title": "c-easy-priority-queue-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\nQuestion is much similar to JUMP GAME(6);\\nJust the addition of little Kadane\\'s algo variation,\\n\\n# Approach\\n->It uses a priority queue to keep track of the maximum sum subsequence ending at each index. \\n->The queue only stores elements within the valid range (within \\'k\\' indices).\\n->At each step, the code updates the current maximum sum considering the current element and the maximum sum ending before it. \\n->The final result is the maximum subsequence sum respecting the given constraint.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({nums[0],0});\\n        int c=nums[0];\\n        int maxi=nums[0];\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            while(pq.top().second<i-k)\\n            {\\n                pq.pop();\\n            }\\n           \\n            c=max(nums[i],pq.top().first+nums[i]);\\n            ans=max(ans,c);\\n            pq.push({c,i});         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        pq.push({nums[0],0});\\n        int c=nums[0];\\n        int maxi=nums[0];\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            while(pq.top().second<i-k)\\n            {\\n                pq.pop();\\n            }\\n           \\n            c=max(nums[i],pq.top().first+nums[i]);\\n            ans=max(ans,c);\\n            pq.push({c,i});         \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922267,
                "title": "python-simple-with-priority-queue",
                "content": "# Intuition\\nKeep on max priority queue sums seen so far.\\nOn every step remove from top those that are out boundry i-k.\\nTake top and try to construct current candidate.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        pq, result = [], -inf\\n        for i, v in enumerate(A):\\n            while pq and (i - pq[0][1] > k): heappop(pq)\\n            if pq: v = max(v, v-pq[0][0])\\n            heappush(pq, (-v, i))\\n            result = max(result, v)    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        pq, result = [], -inf\\n        for i, v in enumerate(A):\\n            while pq and (i - pq[0][1] > k): heappop(pq)\\n            if pq: v = max(v, v-pq[0][0])\\n            heappush(pq, (-v, i))\\n            result = max(result, v)    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921215,
                "title": "c-solution-with-intuition",
                "content": "# Intuition\\nith element will store maximum sum of subsequence (MSS) starting from it so it will choose MSS starting from  its next k elements this is idea of DP and for storing MSS we will use Monotonic queue(deque).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        deque<int> q;\\n        int ans=nums[n-1];\\n       \\n        for(int i=n-1;i>=0;i--)\\n        {           \\n            nums[i]+=(q.size() ? q.front() : 0);\\n            if(q.size() && i+k<n && q.front() == nums[i+k])  q.pop_front();\\n            \\n            while(q.size() && q.back()<nums[i])\\n            {\\n               q.pop_back();\\n            }\\n           \\n            if(nums[i]>0)q.push_back(nums[i]);\\n            ans=max(nums[i],ans);\\n        }\\n        \\n       return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        deque<int> q;\\n        int ans=nums[n-1];\\n       \\n        for(int i=n-1;i>=0;i--)\\n        {           \\n            nums[i]+=(q.size() ? q.front() : 0);\\n            if(q.size() && i+k<n && q.front() == nums[i+k])  q.pop_front();\\n            \\n            while(q.size() && q.back()<nums[i])\\n            {\\n               q.pop_back();\\n            }\\n           \\n            if(nums[i]>0)q.push_back(nums[i]);\\n            ans=max(nums[i],ans);\\n        }\\n        \\n       return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865640,
                "title": "dp-pq",
                "content": "# Intuition\\nDp+ priorityQueue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int constrainedSubsetSum(int[] nums, int k) {\\n\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif(o2[1]!=o1[1]){\\n\\t\\t\\t\\t\\treturn o2[1]-o1[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint max=nums[0];\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tq.add(new int[]{0,nums[0]});\\n\\t\\t\\n\\t\\tfor (int i=1;i<n;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[0]<i-k){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max,Math.max(nums[i], q.peek()[1]+nums[i]));\\n\\t\\t\\tq.add(new int[]{i,Math.max(nums[i], q.peek()[1]+nums[i])});\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int constrainedSubsetSum(int[] nums, int k) {\\n\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif(o2[1]!=o1[1]){\\n\\t\\t\\t\\t\\treturn o2[1]-o1[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint max=nums[0];\\n\\t\\tint n = nums.length;\\n\\t\\t\\n\\t\\tq.add(new int[]{0,nums[0]});\\n\\t\\t\\n\\t\\tfor (int i=1;i<n;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[0]<i-k){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max,Math.max(nums[i], q.peek()[1]+nums[i]));\\n\\t\\t\\tq.add(new int[]{i,Math.max(nums[i], q.peek()[1]+nums[i])});\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860721,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int arr[]=new int[nums.length];\\n        arr[arr.length-1]=nums[nums.length-1];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        l.add(nums[nums.length-1]);\\n        int p=nums.length-1;\\n        int max=arr[arr.length-1];\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(i+k>=nums.length-1)\\n            {\\n                if(nums[i]+l.get(l.size()-1)>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    int low=0,high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n            }\\n            else\\n            {\\n                 int low=0,high=l.size()-1;\\n                 while(low<=high)\\n                 {\\n                     int mid=(low+high)/2;\\n                     if(l.get(mid)==arr[p])\\n                     {\\n                         l.remove(mid);\\n                         break;\\n                     }\\n                     else if(l.get(mid)>arr[p])\\n                     {\\n                         high=mid-1;\\n                     }\\n                     else\\n                     {\\n                         low=mid+1;\\n                     }\\n                 }\\n                 p--;\\n                 if((nums[i]+l.get(l.size()-1))>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    low=0;\\n                    high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n\\n            }\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int arr[]=new int[nums.length];\\n        arr[arr.length-1]=nums[nums.length-1];\\n        ArrayList<Integer> l=new ArrayList<Integer>();\\n        l.add(nums[nums.length-1]);\\n        int p=nums.length-1;\\n        int max=arr[arr.length-1];\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(i+k>=nums.length-1)\\n            {\\n                if(nums[i]+l.get(l.size()-1)>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    int low=0,high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n            }\\n            else\\n            {\\n                 int low=0,high=l.size()-1;\\n                 while(low<=high)\\n                 {\\n                     int mid=(low+high)/2;\\n                     if(l.get(mid)==arr[p])\\n                     {\\n                         l.remove(mid);\\n                         break;\\n                     }\\n                     else if(l.get(mid)>arr[p])\\n                     {\\n                         high=mid-1;\\n                     }\\n                     else\\n                     {\\n                         low=mid+1;\\n                     }\\n                 }\\n                 p--;\\n                 if((nums[i]+l.get(l.size()-1))>nums[i])\\n                {\\n                   arr[i]=nums[i]+l.get(l.size()-1);\\n                }\\n                else\\n                {\\n                    arr[i]=nums[i];\\n                }\\n                if(l.size()==1)\\n                {\\n                    if(l.get(0)>arr[i])\\n                    {\\n                        l.add(0,arr[i]);\\n                    }\\n                    else\\n                    {\\n                        l.add(arr[i]);\\n                    }\\n                }\\n                else\\n                {\\n                    low=0;\\n                    high=l.size()-1;\\n                    int index=0;\\n                    while(low<=high)\\n                    {\\n                        int mid=(low+high)/2;\\n                        if(l.get(mid)>=arr[i])\\n                        {\\n                            index=mid;\\n                            high=mid-1;\\n                        }\\n                        else\\n                        {\\n                            low=mid+1;\\n                            index=mid+1;\\n                        }\\n                    }\\n                    l.add(index,arr[i]);\\n                }\\n\\n            }\\n            if(arr[i]>max)\\n            {\\n                max=arr[i];\\n            }\\n        }\\n\\n        return max;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843805,
                "title": "python-decreasing-queue-o-n",
                "content": "# Approach\\nThis is almost exactly the same as this problem: https://leetcode.com/problems/jump-game-vi/\\nOnly difference is we have an if condition at the beginning of the for loop in this one. If the number in the queue is negative, there is no point in adding it to our current number so we skip it.\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque([0])\\n        for i in range(1, n):\\n            # if the number we have at the beginning of the queue is less than 0 there is no point in including it in our result\\n            if nums[q[0]] > 0:\\n                nums[i] += nums[q[0]]\\n            # if what we have currently is greater than what we had before, we can continue building up on the current number and forget about the rest\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n            # we can jump a maximum of k units from any index so we pop from the beginning of the queue if we are outside that window\\n            if i - k >= q[0]:\\n                q.popleft()\\n        return max(nums)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque([0])\\n        for i in range(1, n):\\n            # if the number we have at the beginning of the queue is less than 0 there is no point in including it in our result\\n            if nums[q[0]] > 0:\\n                nums[i] += nums[q[0]]\\n            # if what we have currently is greater than what we had before, we can continue building up on the current number and forget about the rest\\n            while q and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n            # we can jump a maximum of k units from any index so we pop from the beginning of the queue if we are outside that window\\n            if i - k >= q[0]:\\n                q.popleft()\\n        return max(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717849,
                "title": "o-nlogn-priority-queue-easy-to-understand",
                "content": "# Intuition\\nFor every index we will store the maximum constrained subsequence sum ending at that index. We only need to know the maximum of last k.\\n\\n# Approach\\nWe will use a priority queue to store the maximums ending at every index. If the difference between current index and index of the maximum is greater than k, then we will pop until the difference is less than k or there are no other elements in the priority queue.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i<nums.size(); i++){\\n            if(i - pq.top().second > k){\\n                while(pq.empty() == false && i - pq.top().second > k) pq.pop();\\n                if(pq.empty()){\\n                    ans = max(ans,nums[i]);\\n                    pq.push({nums[i],i});\\n                }\\n                else{\\n                    int curr = nums[i] + pq.top().first;\\n                    ans = max(ans,max(curr,nums[i]));\\n                    pq.push({max(curr,nums[i]),i});\\n                }\\n            }\\n            else{\\n                int curr = nums[i] + pq.top().first;\\n                ans = max(ans,max(curr,nums[i]));\\n                pq.push({max(curr,nums[i]),i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans = nums[0];\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({nums[0],0});\\n        for(int i = 1; i<nums.size(); i++){\\n            if(i - pq.top().second > k){\\n                while(pq.empty() == false && i - pq.top().second > k) pq.pop();\\n                if(pq.empty()){\\n                    ans = max(ans,nums[i]);\\n                    pq.push({nums[i],i});\\n                }\\n                else{\\n                    int curr = nums[i] + pq.top().first;\\n                    ans = max(ans,max(curr,nums[i]));\\n                    pq.push({max(curr,nums[i]),i});\\n                }\\n            }\\n            else{\\n                int curr = nums[i] + pq.top().first;\\n                ans = max(ans,max(curr,nums[i]));\\n                pq.push({max(curr,nums[i]),i});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708290,
                "title": "easiest-hard-on-leetcode",
                "content": "```\\nint constrainedSubsetSum(vector<int>& nums, int k)\\n    {  \\n        int n=nums.size();\\n        vector<int>dp(n); // dp[i]:max subsequence sum provided that we take nums[i] \\n        priority_queue<pair<int,int>>pq; // max sum in the sliding window and the index \\n        int ans=dp[0]=nums[0];\\n        \\n        pq.push({dp[0],0});\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            while(!pq.empty() and i-pq.top().second>k)\\n                pq.pop(); // index out of bounds\\n            \\n            dp[i]=nums[i]+max(pq.top().first,0); // if all negatives do not choose any\\n            pq.push({dp[i],i});\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t```\\n\\t\\n\\tBy the way u can also implement the same logic using Deque(monotonic queue teachnique ,if u dont know u should)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k)\\n    {  \\n        int n=nums.size();\\n        vector<int>dp(n); // dp[i]:max subsequence sum provided that we take nums[i] \\n        priority_queue<pair<int,int>>pq; // max sum in the sliding window and the index \\n        int ans=dp[0]=nums[0];\\n        \\n        pq.push({dp[0],0});\\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            while(!pq.empty() and i-pq.top().second>k)\\n                pq.pop(); // index out of bounds\\n            \\n            dp[i]=nums[i]+max(pq.top().first,0); // if all negatives do not choose any\\n            pq.push({dp[i],i});\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480988,
                "title": "c-monotonic-queue-beat-100",
                "content": "Check the hints in problem description\\n\\n```\\npublic class Solution {\\n    public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.Length;\\n        LinkedList<(int i, int s)> l=new LinkedList<(int i, int s)>();\\n        int res=nums[0];\\n        int left=0;\\n        int sum=nums[0];\\n        l.AddLast((0,sum));\\n        for(int i=1;i<n;i++){\\n            while(l.Count>0 && l.First.Value.i<i-k)\\n                l.RemoveFirst();\\n            \\n            sum=nums[i]+(l.First.Value.s > 0 ? l.First.Value.s : 0);\\n            while(l.Count>0 && l.Last.Value.s<=sum)\\n                    l.RemoveLast();\\n                \\n            l.AddLast((i,sum));\\n            res=Math.Max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```\\npublic class Solution {\\n    public int ConstrainedSubsetSum(int[] nums, int k) {\\n        int n=nums.Length;\\n        LinkedList<(int i, int s)> l=new LinkedList<(int i, int s)>();\\n        int res=nums[0];\\n        int left=0;\\n        int sum=nums[0];\\n        l.AddLast((0,sum));\\n        for(int i=1;i<n;i++){\\n            while(l.Count>0 && l.First.Value.i<i-k)\\n                l.RemoveFirst();\\n            \\n            sum=nums[i]+(l.First.Value.s > 0 ? l.First.Value.s : 0);\\n            while(l.Count>0 && l.Last.Value.s<=sum)\\n                    l.RemoveLast();\\n                \\n            l.AddLast((i,sum));\\n            res=Math.Max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359967,
                "title": "alternative-to-find-max-in-sliding-window-situations",
                "content": "# Intuition\\n\\nThe problem can be solved by a simple Dynamic Programming implementation, the trick is that we need to find the max value in a range of cells.\\n\\nThis search is recurrent and follows a pattern very similar to a Sliding Window, as we want to find the max between the cell previous to the current (`i`) and K cells before (`i-k`).\\n\\nThe idea is that every time we update the current cell we check if it is greater or equal than the max value on the window, if it is simply set this as the max (set the maxIndex to point to it). If many slides happen and no new max is found the previous max will eventually fall outside the window we need to recalculate the new min.\\nThis can be done in multiple ways\\n- Mono Deque algorithm - Fastes Way in theory\\n  - Mono Deque allows us to keep track of global min/max and local min/max (if it is min or max depends on how it is implemented)\\n- Scan the window again - Slowest Way in theory\\n  - To recalculate the new min we simply need to scan the new window and and take note of the giggest value.\\n  - In the worst case we will have a sequence from 1000 to -1000 making us recalculate the max at each time we move the window.\\n- Log(n) Datastructures (segment trees, heaps, BST, etc)\\n\\n\\nNote: the description of the problem says that k can be between 1 and 10^5, but if you run the test cases you will notice that it doesnt accept values above 10005.\\n\\nNote: in case you want to know more about the Segment Tree, here you can read more: https://leetcode.com/problems/best-team-with-no-conflicts/solutions/3124655/fenwick-treebinary-indexed-tree-and-segment-tree-variation-to-find-max-or-min/\\n\\n# Approach\\n- Dynamic Programming\\n- MonoDeque\\n- Segment Tree\\n\\n# Complexity\\n- Time complexity:\\n  - Mono Deque: $$O(n)$$\\n  - Scan window: $$O(n*k)$$\\n  - Segment Tree: $$O(n*log(k))$$\\n\\n- Space complexity:\\n  - Mono Deque: $$O(n)$$\\n  - Scan window: $$O(n)$$\\n  - Segment Tree: $$O(n)$$\\n\\n# Codes\\n## Mono Deque\\n![image.png](https://assets.leetcode.com/users/images/5171476c-9f58-41ca-9dd9-72e27a5f1acf_1680196511.668469.png)\\n\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0];\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        ArrayDeque<Integer> md=new ArrayDeque<>();\\n        md.push(0);\\n        for(int i=1;i<nums.length;i++) {\\n            // if the last number index (oldest added) is previous\\n            // to the window we remove it\\n            if(md.getLast()<i-k) md.removeLast();\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[md.getLast()]+v);\\n            // Mono deque implementation to remove smaller values\\n            // than the tail (this is the magic/heart)\\n            while(!md.isEmpty()&&memo[md.peek()]<=m) md.pop();\\n            md.push(i);\\n            if(m>max) max=m;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## Scan window\\n![image.png](https://assets.leetcode.com/users/images/1d914899-4195-4001-a268-b61adac2dcec_1680194908.3771832.png)\\n\\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0], maxIndex=0;\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            // Window moved past maxIndex, lets recalculate\\n            if(maxIndex<i-k) {\\n                int v=Integer.MIN_VALUE;\\n                for(int j=i-1;i-j<=k;j--) {\\n                    if(memo[j]>v) {\\n                        v=memo[j];\\n                        maxIndex=j;\\n                    }\\n                }\\n            }\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[maxIndex]+v);\\n            // found new position of the maxIndex, lets set it\\n            if(m>=max) {\\n                maxIndex=i;\\n                max=m;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## Segment Tree\\n![image.png](https://assets.leetcode.com/users/images/7f2f2004-2a43-4d08-a3e9-f6c724aa6446_1680196568.3171434.png)\\n\\n```java\\nclass Solution {\\n    int[] st;\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] memo=new int[nums.length];\\n        st=new int[2*memo.length];\\n        int max=Integer.MIN_VALUE/2;\\n        for(int i=nums.length-1;i>-1;i--) {\\n            int v=nums[i], m=v;\\n            m=Math.max(v,v+get(i+1,i+k));\\n            max=Math.max(max,m);\\n            memo[i]=m;\\n            update(i,m);\\n        }\\n        return max;\\n    }\\n    void update(int pos, int val) {\\n        pos+=st.length>>1;\\n        st[pos]=val;\\n        for(int i=pos;i>0;i>>=1) {\\n            if(i%2==0) st[i>>1]=Math.max(st[i],i<st.length-1?st[i+1]:Integer.MIN_VALUE/2);\\n            else st[i>>1]=Math.max(st[i-1],st[i]);\\n        }\\n    }\\n    int get(int left, int right) {\\n        left+=st.length>>1;\\n        right+=st.length>>1;\\n        right=Math.min(right,st.length-1);\\n        int max=Integer.MIN_VALUE/2;\\n        while(left<right) {\\n            if(left%2==1) max=Math.max(max,st[left++]);\\n            max=Math.max(max,st[left]);\\n            left>>=1;\\n            if(right%2==0) max=Math.max(max,st[right--]);\\n            max=Math.max(max,st[right]);\\n            right>>=1;\\n        }\\n        return left==right?Math.max(max,st[left]): max;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0];\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        ArrayDeque<Integer> md=new ArrayDeque<>();\\n        md.push(0);\\n        for(int i=1;i<nums.length;i++) {\\n            // if the last number index (oldest added) is previous\\n            // to the window we remove it\\n            if(md.getLast()<i-k) md.removeLast();\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[md.getLast()]+v);\\n            // Mono deque implementation to remove smaller values\\n            // than the tail (this is the magic/heart)\\n            while(!md.isEmpty()&&memo[md.peek()]<=m) md.pop();\\n            md.push(i);\\n            if(m>max) max=m;\\n        }\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int max=nums[0], maxIndex=0;\\n        int[] memo=new int[nums.length];\\n        memo[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            // Window moved past maxIndex, lets recalculate\\n            if(maxIndex<i-k) {\\n                int v=Integer.MIN_VALUE;\\n                for(int j=i-1;i-j<=k;j--) {\\n                    if(memo[j]>v) {\\n                        v=memo[j];\\n                        maxIndex=j;\\n                    }\\n                }\\n            }\\n            // The max sum with the curr numberis either with\\n            // it alone or with it and the prev max sum\\n            int v=nums[i], m=memo[i]=Math.max(v,memo[maxIndex]+v);\\n            // found new position of the maxIndex, lets set it\\n            if(m>=max) {\\n                maxIndex=i;\\n                max=m;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    int[] st;\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] memo=new int[nums.length];\\n        st=new int[2*memo.length];\\n        int max=Integer.MIN_VALUE/2;\\n        for(int i=nums.length-1;i>-1;i--) {\\n            int v=nums[i], m=v;\\n            m=Math.max(v,v+get(i+1,i+k));\\n            max=Math.max(max,m);\\n            memo[i]=m;\\n            update(i,m);\\n        }\\n        return max;\\n    }\\n    void update(int pos, int val) {\\n        pos+=st.length>>1;\\n        st[pos]=val;\\n        for(int i=pos;i>0;i>>=1) {\\n            if(i%2==0) st[i>>1]=Math.max(st[i],i<st.length-1?st[i+1]:Integer.MIN_VALUE/2);\\n            else st[i>>1]=Math.max(st[i-1],st[i]);\\n        }\\n    }\\n    int get(int left, int right) {\\n        left+=st.length>>1;\\n        right+=st.length>>1;\\n        right=Math.min(right,st.length-1);\\n        int max=Integer.MIN_VALUE/2;\\n        while(left<right) {\\n            if(left%2==1) max=Math.max(max,st[left++]);\\n            max=Math.max(max,st[left]);\\n            left>>=1;\\n            if(right%2==0) max=Math.max(max,st[right--]);\\n            max=Math.max(max,st[right]);\\n            right>>=1;\\n        }\\n        return left==right?Math.max(max,st[left]): max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280287,
                "title": "java-solution-using-deque",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = dp[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n\\n            // if element is out of range, then remove the 1st element from queue\\n            if(i>k && q.getFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            //update max value of i by comparing it with current element to first element of the \\n            // queue\\n            dp[i]=Math.max(dp[i],q.getFirst()+nums[i]);\\n\\n            // remove untill currrent sum is greater than last element\\n            //this monotonically decreasing queue\\n            while(!q.isEmpty() && (q.getLast()<dp[i])){\\n                q.removeLast();\\n            }\\n            q.addLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```\\n\\nRefer to the below problem which is similar\\n[Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        int max = dp[0];\\n        Deque<Integer> q = new ArrayDeque<>();\\n        q.offer(nums[0]);\\n        for(int i = 1; i < nums.length; i++){\\n            dp[i] = nums[i];\\n\\n            // if element is out of range, then remove the 1st element from queue\\n            if(i>k && q.getFirst() == dp[i-k-1]){\\n                q.removeFirst();\\n            }\\n            //update max value of i by comparing it with current element to first element of the \\n            // queue\\n            dp[i]=Math.max(dp[i],q.getFirst()+nums[i]);\\n\\n            // remove untill currrent sum is greater than last element\\n            //this monotonically decreasing queue\\n            while(!q.isEmpty() && (q.getLast()<dp[i])){\\n                q.removeLast();\\n            }\\n            q.addLast(dp[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n        \\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257221,
                "title": "c-dp-monoqueue-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nslight modification of jump vi as there jump can be of [1,k] steps here gap bw elements of subsequence can be of [1,k] .For that we maintain monoqueue to get the max sum in range of k and if adding to this sum increases the final sum then we add it otherwise not\\nAt last we get the all possible max sums that can be generated starting subseq at every index maximum out of those will be our ans \\nConsider my jump game 6 solution if required  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na dp and monoqueue is used to mintain the max sum ans sums in range of k res. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> dp(nums.size(),0);\\n        dq.push_back(nums.size()-1);\\n        dp.back()=nums.back();\\n        int ans=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(dq.size() && (dq.front()>i+k)){\\n                dq.pop_front();\\n            }\\n            dp[i]=max(nums[i],nums[i]+dp[dq.front()]);\\n            ans=max(ans,dp[i]);\\n            while(dq.size() && dp[i]>=dp[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> dq;\\n        vector<int> dp(nums.size(),0);\\n        dq.push_back(nums.size()-1);\\n        dp.back()=nums.back();\\n        int ans=nums.back();\\n        for(int i=nums.size()-2;i>=0;i--){\\n            while(dq.size() && (dq.front()>i+k)){\\n                dq.pop_front();\\n            }\\n            dp[i]=max(nums[i],nums[i]+dp[dq.front()]);\\n            ans=max(ans,dp[i]);\\n            while(dq.size() && dp[i]>=dp[dq.back()]){\\n                dq.pop_back();\\n            }\\n            dq.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244226,
                "title": "python-simple-dp-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums, k):\\n        n = len(nums)\\n\\n        dp, stack = [nums[0]] + [0]*(n-1), []\\n\\n        for i in range(1,n):\\n            while stack and stack[0][1] + k < i:\\n                heappop(stack)\\n\\n            heappush(stack,(-dp[i-1],i-1))\\n\\n            dp[i] = max(0,-stack[0][0]) + nums[i]\\n\\n        return max(dp)\\n\\n\\n\\n\\n\\n            \\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums, k):\\n        n = len(nums)\\n\\n        dp, stack = [nums[0]] + [0]*(n-1), []\\n\\n        for i in range(1,n):\\n            while stack and stack[0][1] + k < i:\\n                heappop(stack)\\n\\n            heappush(stack,(-dp[i-1],i-1))\\n\\n            dp[i] = max(0,-stack[0][0]) + nums[i]\\n\\n        return max(dp)\\n\\n\\n\\n\\n\\n            \\n\\n            \\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242743,
                "title": "easy-c-solution",
                "content": "**Solution 1 (DP --TLE)**\\n\\nWe can use the simple bottom up Dp  concept.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n+1];\\n        memset(dp,INT_MIN,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=max(i-k,0);\\n            dp[i]=nums[i];\\n            for(int j=i-1;j>=idx;j--)\\n            {\\n                dp[i]=max({dp[i],dp[j]+nums[i]});\\n            }\\n        }\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) ma=max(ma,dp[i]);\\n        return ma;\\n    }\\n};\\n```\\n\\n**Solution 2 (Max Priority Queue --- Accepted)**\\n\\nWe will take max priority queue with pair and store in form of ({val,index}). At every index if current index-index of top or priority queue is >k then we will pop that pair from priority queue otherwise we will take that accordingly.For more clearity check the code.\\n\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        int ma=INT_MIN,s=0;\\n        s=nums[0];\\n        ma=max(ma,s);\\n        pq.push({s,0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while((i-pq.top().second)>k)\\n            {\\n                pq.pop();\\n            }\\n            auto it=pq.top();\\n            int val=it.first;\\n            s=max(0,val)+nums[i];\\n            ma=max(ma,s);\\n            pq.push({s,i});\\n            \\n        }\\n        return ma;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int dp[n+1];\\n        memset(dp,INT_MIN,sizeof dp);\\n        for(int i=0;i<n;i++)\\n        {\\n            int idx=max(i-k,0);\\n            dp[i]=nums[i];\\n            for(int j=i-1;j>=idx;j--)\\n            {\\n                dp[i]=max({dp[i],dp[j]+nums[i]});\\n            }\\n        }\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) ma=max(ma,dp[i]);\\n        return ma;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>pq;\\n        int ma=INT_MIN,s=0;\\n        s=nums[0];\\n        ma=max(ma,s);\\n        pq.push({s,0});\\n        for(int i=1;i<n;i++)\\n        {\\n            while((i-pq.top().second)>k)\\n            {\\n                pq.pop();\\n            }\\n            auto it=pq.top();\\n            int val=it.first;\\n            s=max(0,val)+nums[i];\\n            ma=max(ma,s);\\n            pq.push({s,i});\\n            \\n        }\\n        return ma;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133756,
                "title": "short-and-easy-decreasing-subsequence-sum-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every element we need to keep track of maximum subsequence sum ending at previous k elements only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep a Queue of size maximum k. The front of this queue will have the maximum subsequence sum ending at one of the last k elements. Keep moving the widow by one element and deleting the unwanted stuff from the queue created. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=nums[0];\\n        deque<pii> dq;\\n        dq.push_back({nums[0],0});\\n        for(int i=1; i<n; i++){\\n            while(!dq.empty() && i-dq.front().second > k) dq.pop_front();\\n            int sum=max(dq.front().first,0)+nums[i];\\n            while(!dq.empty() && dq.back().first<=sum) dq.pop_back();\\n            dq.push_back({sum,i});\\n            res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> pii;\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int res=nums[0];\\n        deque<pii> dq;\\n        dq.push_back({nums[0],0});\\n        for(int i=1; i<n; i++){\\n            while(!dq.empty() && i-dq.front().second > k) dq.pop_front();\\n            int sum=max(dq.front().first,0)+nums[i];\\n            while(!dq.empty() && dq.back().first<=sum) dq.pop_back();\\n            dq.push_back({sum,i});\\n            res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut dp = vec![0; nums.len()];\\n        let mut max = nums[0];\\n        let mut q = std::collections::VecDeque::new();\\n        for i in 0..nums.len() {\\n            dp[i] = nums[i];\\n            if let Some(&j) = q.front() {\\n                dp[i] = std::cmp::max(dp[i], dp[j] + nums[i]);\\n            }\\n            max = std::cmp::max(max, dp[i]);\\n            while let Some(&j) = q.back() {\\n                if dp[j] < dp[i] {\\n                    q.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            q.push_back(i);\\n            if let Some(&j) = q.front() {\\n                if i as i32 - j as i32 >= k {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn constrained_subset_sum(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut dp = vec![0; nums.len()];\\n        let mut max = nums[0];\\n        let mut q = std::collections::VecDeque::new();\\n        for i in 0..nums.len() {\\n            dp[i] = nums[i];\\n            if let Some(&j) = q.front() {\\n                dp[i] = std::cmp::max(dp[i], dp[j] + nums[i]);\\n            }\\n            max = std::cmp::max(max, dp[i]);\\n            while let Some(&j) = q.back() {\\n                if dp[j] < dp[i] {\\n                    q.pop_back();\\n                } else {\\n                    break;\\n                }\\n            }\\n            q.push_back(i);\\n            if let Some(&j) = q.front() {\\n                if i as i32 - j as i32 >= k {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3065962,
                "title": "heap-solution-python",
                "content": "# Code\\n```\\nimport heapq\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = [(0, -1)]\\n\\n        ans = nums[0]\\n        for i, num in enumerate(nums):\\n            while q and i - q[0][1] > k:\\n                heapq.heappop(q)\\n            s, idx = q[0]\\n            ans = max(ans, num, -s + num)\\n            heapq.heappush(q, (min(s - num, -num), i))\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = [(0, -1)]\\n\\n        ans = nums[0]\\n        for i, num in enumerate(nums):\\n            while q and i - q[0][1] > k:\\n                heapq.heappop(q)\\n            s, idx = q[0]\\n            ans = max(ans, num, -s + num)\\n            heapq.heappush(q, (min(s - num, -num), i))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049591,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3013906,
                "title": "c-easy-and-3-line-solution-only-priority-queue-nicely-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>q; // to store max sum so far and the corresponding index\\n        int n=nums.size(),ans=nums[0];\\n        q.push({nums[0],0});\\n        for(int i=1;i<n;i++){\\n            while((i-q.top().second)>k) q.pop(); // if the window size is exceeding k than pop- out the values from the queue \\n            ans=max(ans,max(nums[i],nums[i]+q.top().first));  // maximum result so far\\n            q.push({max(nums[i],nums[i]+q.top().first),i});   // storing the maximum result with corresponding index\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>>q; // to store max sum so far and the corresponding index\\n        int n=nums.size(),ans=nums[0];\\n        q.push({nums[0],0});\\n        for(int i=1;i<n;i++){\\n            while((i-q.top().second)>k) q.pop(); // if the window size is exceeding k than pop- out the values from the queue \\n            ans=max(ans,max(nums[i],nums[i]+q.top().first));  // maximum result so far\\n            q.push({max(nums[i],nums[i]+q.top().first),i});   // storing the maximum result with corresponding index\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010597,
                "title": "dp-monotonic-queue-beat-100-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar constrainedSubsetSum = function (nums, k) {\\n  const q = [];\\n  const sum = Array(nums.length).fill(0);\\n  let res = nums[0];\\n  for (let i = 0; i < nums.length; i++) {\\n    sum[i] = nums[i];\\n    if(q.length) sum[i] += sum[q[0]];\\n    res = Math.max(res, sum[i]);\\n    if (q.length && i - q[0] >= k) q.shift();\\n    while (q.length && sum[q[q.length - 1]] <= sum[i]) q.pop();\\n    if (sum[i] > 0) q.push(i);\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2980962,
                "title": "dp-monotonic-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        dq.push_back({0, nums[0]});\\n        int result = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            // remove elements from front that are\\n            // more than k indices apart\\n            while(not dq.empty() and i-dq.front().first > k) {\\n                dq.pop_front();\\n            }\\n\\n            int val = nums[i] + max(0, dq.front().second);\\n            result = max(result, val);\\n\\n            // maintain a monotonically decreasing queue\\n            while(not dq.empty() and dq.back().second < val) {\\n                dq.pop_back();\\n            }\\n\\n            dq.push_back({i, val});\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        dq.push_back({0, nums[0]});\\n        int result = nums[0];\\n\\n        for(int i=1; i<nums.size(); i++) {\\n            // remove elements from front that are\\n            // more than k indices apart\\n            while(not dq.empty() and i-dq.front().first > k) {\\n                dq.pop_front();\\n            }\\n\\n            int val = nums[i] + max(0, dq.front().second);\\n            result = max(result, val);\\n\\n            // maintain a monotonically decreasing queue\\n            while(not dq.empty() and dq.back().second < val) {\\n                dq.pop_back();\\n            }\\n\\n            dq.push_back({i, val});\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979424,
                "title": "python-solution-using-monotone-queue-linear-time-faster-than-90",
                "content": "\\n# Code\\n```python []\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sz = len(nums)\\n        dp, queue = [0] * sz, deque()\\n        dp[-1] = nums[-1]\\n        queue.append(sz - 1)\\n        for idx in range(sz - 2, -1, -1):\\n            if queue[0] - idx > k:\\n                queue.popleft()\\n            dp[idx] += (nums[idx] + dp[queue[0]])\\n            dp[idx] = max(dp[idx], nums[idx])\\n            while queue and dp[idx] > dp[queue[-1]]:\\n                queue.pop()\\n            queue.append(idx)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```python []\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sz = len(nums)\\n        dp, queue = [0] * sz, deque()\\n        dp[-1] = nums[-1]\\n        queue.append(sz - 1)\\n        for idx in range(sz - 2, -1, -1):\\n            if queue[0] - idx > k:\\n                queue.popleft()\\n            dp[idx] += (nums[idx] + dp[queue[0]])\\n            dp[idx] = max(dp[idx], nums[idx])\\n            while queue and dp[idx] > dp[queue[-1]]:\\n                queue.pop()\\n            queue.append(idx)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916618,
                "title": "no-extra-dp-easy-to-understand-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncompute sum and put in deque itself\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPush sum to the dq and the end till where the sum is calculated and perfrom monotonic queue operations for decreasing deque\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans=INT_MIN;\\n        int sum=0;\\n        deque<pair<int,int>> dq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum=nums[i];\\n            while(!dq.empty()&&dq.front().second<i-k)\\n                dq.pop_front();\\n            if(!dq.empty()&&dq.front().first>0){\\n                sum+=dq.front().first;\\n            }\\n            ans=max(ans,sum);\\n            while(!dq.empty()&&dq.back().first<sum){\\n                dq.pop_back();\\n            }\\n            dq.push_back({sum,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int ans=INT_MIN;\\n        int sum=0;\\n        deque<pair<int,int>> dq;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            sum=nums[i];\\n            while(!dq.empty()&&dq.front().second<i-k)\\n                dq.pop_front();\\n            if(!dq.empty()&&dq.front().first>0){\\n                sum+=dq.front().first;\\n            }\\n            ans=max(ans,sum);\\n            while(!dq.empty()&&dq.back().first<sum){\\n                dq.pop_back();\\n            }\\n            dq.push_back({sum,i});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912457,
                "title": "c-very-simple-and-fast-max-heap-implementation",
                "content": "TC: O(N * LogN)    --> it will be slightly more than nlogn as we are poping using while loop\\nSC:O(K)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        int maxi=nums[0],ptr=0;\\n        pq.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            //if ptr is not in the range of i\\n            if(i-k>ptr){\\n                mp[nums[ptr]]++;//make an entry to pop-out nums[ptr]\\n                ptr++;\\n            }\\n        //check if top value has some entry in map to pop , if yes\\n        //pop the top and decraese the pop-count in map\\n            while(mp[pq.top()]>0){  \\n                mp[pq.top()]--;\\n                pq.pop();\\n            }\\n            \\n            nums[i]+= max(0,pq.top());\\n            maxi=max(maxi,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        priority_queue<int>pq;\\n        unordered_map<int,int>mp;\\n        int maxi=nums[0],ptr=0;\\n        pq.push(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            //if ptr is not in the range of i\\n            if(i-k>ptr){\\n                mp[nums[ptr]]++;//make an entry to pop-out nums[ptr]\\n                ptr++;\\n            }\\n        //check if top value has some entry in map to pop , if yes\\n        //pop the top and decraese the pop-count in map\\n            while(mp[pq.top()]>0){  \\n                mp[pq.top()]--;\\n                pq.pop();\\n            }\\n            \\n            nums[i]+= max(0,pq.top());\\n            maxi=max(maxi,nums[i]);\\n            pq.push(nums[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904813,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int constrainedSubsetSum(vector<int>&v, int k) {\\n        ll mx=*max_element(begin(v), end(v));\\n        if(mx<1){\\n            return mx;\\n        }\\n        ll n=v.size();\\n        vi(ll)dp(n);\\n        map<ll,ll>mp={{0, 1}};\\n        for(ll i=0;i<n;++i){\\n            if(i>k){\\n                --mp[dp[i-k-1]];\\n                if(!mp[dp[i-k-1]]){\\n                    mp.erase(dp[i-k-1]);\\n                }\\n            }\\n            dp[i]=v[i]+mp.rbegin()->first;\\n            ++mp[dp[i]];\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int constrainedSubsetSum(vector<int>&v, int k) {\\n        ll mx=*max_element(begin(v), end(v));\\n        if(mx<1){\\n            return mx;\\n        }\\n        ll n=v.size();\\n        vi(ll)dp(n);\\n        map<ll,ll>mp={{0, 1}};\\n        for(ll i=0;i<n;++i){\\n            if(i>k){\\n                --mp[dp[i-k-1]];\\n                if(!mp[dp[i-k-1]]){\\n                    mp.erase(dp[i-k-1]);\\n                }\\n            }\\n            dp[i]=v[i]+mp.rbegin()->first;\\n            ++mp[dp[i]];\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891898,
                "title": "monotonic-queue-dp-clean-code-o-n-time-and-o-k-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly I treated the question as lis problem and I came up with $$O(n^2)$$ solution but finally I realized that I can use monotonic queue to remove the inner loop and reduce the time complexity. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        ans = nums[0]\\n        queue = deque([(0, nums[0])])\\n        n = len(nums)\\n        for index in range(1, n):\\n            while queue and index - queue[0][0] > k:\\n                queue.popleft()\\n\\n            current = max(nums[index], nums[index]+queue[0][1])\\n            ans = max(ans, current)\\n            while queue and queue[-1][1] <= current:\\n                queue.pop()\\n            queue.append((index, current))\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        ans = nums[0]\\n        queue = deque([(0, nums[0])])\\n        n = len(nums)\\n        for index in range(1, n):\\n            while queue and index - queue[0][0] > k:\\n                queue.popleft()\\n\\n            current = max(nums[index], nums[index]+queue[0][1])\\n            ans = max(ans, current)\\n            while queue and queue[-1][1] <= current:\\n                queue.pop()\\n            queue.append((index, current))\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856260,
                "title": "python3-using-monotonic-queue",
                "content": "class Solution:\\n\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dec_q = collections.deque()\\n        dp = [0]*len(nums)\\n        \\n        for i,num in enumerate(nums):\\n            if i>k and dp[i-k-1] == dec_q[0]:\\n                dec_q.popleft()\\n            dp[i] = max(dec_q[0] if dec_q else 0,0)+num\\n            while dec_q and dec_q[-1]<dp[i]:\\n                dec_q.pop()\\n            dec_q.append(dp[i])\\n        \\n        return max(dp)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dec_q = collections.deque()\\n        dp = [0]*len(nums)\\n        \\n        for i,num in enumerate(nums):\\n            if i>k and dp[i-k-1] == dec_q[0]:\\n                dec_q.popleft()\\n            dp[i] = max(dec_q[0] if dec_q else 0,0)+num\\n            while dec_q and dec_q[-1]<dp[i]:\\n                dec_q.pop()\\n            dec_q.append(dp[i])\\n        \\n        return max(dp)",
                "codeTag": "Java"
            },
            {
                "id": 2851583,
                "title": "python-dp-monoqueue-o-n-2-o-n",
                "content": "Use monoqueue to store max(dp[i-k],...dp[i-1])\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # dp[i] = max sum of subseq(nums[:i+1]) s.t. j-i <= k\\n        # dp[i] = max(dp[j]) + nums[i] , j-i <= k\\n        \\n        n = len(nums)\\n        dp = [0 for i in range(n+1)]\\n        q = collections.deque()\\n        res = -math.inf\\n        left = 1\\n        \\n        for i in range(1, n+1):\\n            prev_max = q[0] if q else 0\\n            dp[i] = max(prev_max, 0) + nums[i-1]    # if prev dp is neg, start new subsequence here\\n            res = max(res, dp[i])\\n            \\n            while q and dp[i] > q[-1]:\\n                q.pop()\\n            q.append(dp[i])\\n            \\n            if i - left >= k:\\n                if q[0] == dp[left]:\\n                    q.popleft()\\n                left += 1\\n                       \\n        return res\\n```\\n\\nO(n^2) approach - TLE\\n```\\n for i in range(1, n+1):\\n            tmp = -math.inf\\n            for j in range(i-k, i):\\n                if j >= 0:\\n                    tmp = max(tmp, dp[j])\\n            dp[i] = max(tmp, 0) + nums[i-1]\\n            res = max(res, dp[i])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        # dp[i] = max sum of subseq(nums[:i+1]) s.t. j-i <= k\\n        # dp[i] = max(dp[j]) + nums[i] , j-i <= k\\n        \\n        n = len(nums)\\n        dp = [0 for i in range(n+1)]\\n        q = collections.deque()\\n        res = -math.inf\\n        left = 1\\n        \\n        for i in range(1, n+1):\\n            prev_max = q[0] if q else 0\\n            dp[i] = max(prev_max, 0) + nums[i-1]    # if prev dp is neg, start new subsequence here\\n            res = max(res, dp[i])\\n            \\n            while q and dp[i] > q[-1]:\\n                q.pop()\\n            q.append(dp[i])\\n            \\n            if i - left >= k:\\n                if q[0] == dp[left]:\\n                    q.popleft()\\n                left += 1\\n                       \\n        return res\\n```\n```\\n for i in range(1, n+1):\\n            tmp = -math.inf\\n            for j in range(i-k, i):\\n                if j >= 0:\\n                    tmp = max(tmp, dp[j])\\n            dp[i] = max(tmp, 0) + nums[i-1]\\n            res = max(res, dp[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810907,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        //use  a max heap\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dp(nums.size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //remove the indices which are less than i-k\\n            while(!pq.empty() && pq.top().second<i-k)\\n                pq.pop();\\n            dp[i]=nums[i];\\n            //get the max sum from previous i-k subarray \\n            if(!pq.empty())\\n                dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            \\n            //update the maxi value\\n            maxi=max(maxi,dp[i]);\\n            pq.push({dp[i],i});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        //use  a max heap\\n        priority_queue<pair<int,int>> pq;\\n        vector<int> dp(nums.size());\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //remove the indices which are less than i-k\\n            while(!pq.empty() && pq.top().second<i-k)\\n                pq.pop();\\n            dp[i]=nums[i];\\n            //get the max sum from previous i-k subarray \\n            if(!pq.empty())\\n                dp[i]=max(dp[i],nums[i]+pq.top().first);\\n            \\n            //update the maxi value\\n            maxi=max(maxi,dp[i]);\\n            pq.push({dp[i],i});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755787,
                "title": "c",
                "content": "Runtime: 225 ms, faster than 100.00% of C online submissions for Constrained Subsequence Sum.\\nMemory Usage: 21 MB, less than 100.00% of C online submissions for Constrained Subsequence Sum.\\n```\\nint BSF(int* nums, int n, int val){\\n    int left = 0, right = n-1;\\n    int mid;\\n    while(left < right){\\n        mid = left + (right - left) /2;\\n        if(nums[mid] >= val)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    return left;\\n}\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int max = INT_MIN;\\n    int* queue = malloc((n+1) * sizeof(int) );\\n    int* dp = malloc((n+1) * sizeof(int));\\n    dp[0] = 0;\\n    int head = 0;\\n    int tail = 1;\\n    queue[head] = 0;\\n\\n    for(int i = 1; i <= k; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];   \\n        \\n        max = fmax(max, dp[i]);\\n        if(dp[i] < 0){\\n            continue;\\n        }\\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1] ){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }\\n    }\\n\\n    for(int i = k+1; i <= n; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];\\n        max = fmax(max, dp[i]);\\n        if((queue[head] == dp[i-k]) && (dp[i-k] > 0)){\\n            head++;\\n            if(head == tail){\\n                queue[head] = 0;\\n                tail = head + 1;\\n            }\\n        }\\n        if(dp[i] < 0){\\n            continue;\\n        }         \\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1]){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }        \\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```\\nint BSF(int* nums, int n, int val){\\n    int left = 0, right = n-1;\\n    int mid;\\n    while(left < right){\\n        mid = left + (right - left) /2;\\n        if(nums[mid] >= val)\\n            left = mid + 1;\\n        else\\n            right = mid;\\n    }\\n    return left;\\n}\\n\\nint constrainedSubsetSum(int* nums, int numsSize, int k){\\n    int n = numsSize;\\n    int max = INT_MIN;\\n    int* queue = malloc((n+1) * sizeof(int) );\\n    int* dp = malloc((n+1) * sizeof(int));\\n    dp[0] = 0;\\n    int head = 0;\\n    int tail = 1;\\n    queue[head] = 0;\\n\\n    for(int i = 1; i <= k; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];   \\n        \\n        max = fmax(max, dp[i]);\\n        if(dp[i] < 0){\\n            continue;\\n        }\\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1] ){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }\\n    }\\n\\n    for(int i = k+1; i <= n; i++){\\n        dp[i] = nums[i-1];\\n        if(queue[head] > 0)\\n            dp[i] += queue[head];\\n        max = fmax(max, dp[i]);\\n        if((queue[head] == dp[i-k]) && (dp[i-k] > 0)){\\n            head++;\\n            if(head == tail){\\n                queue[head] = 0;\\n                tail = head + 1;\\n            }\\n        }\\n        if(dp[i] < 0){\\n            continue;\\n        }         \\n        else if(dp[i] > queue[head]){\\n             queue[head] = dp[i];\\n             tail = head + 1;   \\n        }\\n        else if(dp[i] <= queue[tail-1]){\\n            queue[tail] = dp[i];\\n            tail++;\\n        }\\n        else{\\n            int z = BSF(&queue[head], tail - head , dp[i]);\\n            queue[head + z] = dp[i];\\n            tail = head + z+1;\\n        }        \\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753815,
                "title": "maxheap-with-lazy-popping",
                "content": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n     #create a heap with lazy popping\\n    \\n    \\n        myheap = []\\n\\n        dp = defaultdict(lambda : 0)\\n\\n        for i,num in enumerate(nums):\\n            \\n            #lazy popping, any index that is older than i -  k elements back can be popped\\n            while myheap and i - myheap[0][1] > k:\\n                heapq.heappop(myheap)\\n\\n            if myheap:\\n                dp[i] = max( nums[i],nums[i] + (myheap[0][0]*-1) )\\n            else:\\n                dp[i] = nums[i]\\n\\n            heapq.heappush( myheap,(dp[i]*-1,i) )\\n\\n        return max(dp.values())\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n     #create a heap with lazy popping\\n    \\n    \\n        myheap = []\\n\\n        dp = defaultdict(lambda : 0)\\n\\n        for i,num in enumerate(nums):\\n            \\n            #lazy popping, any index that is older than i -  k elements back can be popped\\n            while myheap and i - myheap[0][1] > k:\\n                heapq.heappop(myheap)\\n\\n            if myheap:\\n                dp[i] = max( nums[i],nums[i] + (myheap[0][0]*-1) )\\n            else:\\n                dp[i] = nums[i]\\n\\n            heapq.heappush( myheap,(dp[i]*-1,i) )\\n\\n        return max(dp.values())\\n",
                "codeTag": "Java"
            },
            {
                "id": 2731949,
                "title": "sliding-window-maximum",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque()\\n        for i in range(n):\\n            if len(q) > 0:\\n                nums[i] = max(nums[i], nums[i] + nums[q[0]])\\n            while len(q) > 0 and q[0] <= i - k:\\n                q.popleft()\\n            while len(q) > 0 and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        q = deque()\\n        for i in range(n):\\n            if len(q) > 0:\\n                nums[i] = max(nums[i], nums[i] + nums[q[0]])\\n            while len(q) > 0 and q[0] <= i - k:\\n                q.popleft()\\n            while len(q) > 0 and nums[i] > nums[q[-1]]:\\n                q.pop()\\n            q.append(i)\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725190,
                "title": "monotonic-queue-and-keep-trying-when-tle-intuition-and-explanation",
                "content": "My first intuition was DP, but got me TLE as the `k` is quite huge in this case. It took me really long to come up with a monotonic queue solution. I will describe the thought process below.\\n\\n### Intuition\\nMaximum in a sliding window. \\n\\nNormally when I am struggling out how to keep track of the index of maximum, minumum or any particular item in `O(n)` time, monotonic queue seem to be the solution.\\nThe next is to think hard on how to fit into the intuition.\\n\\n### Explanation\\n\\nIn a monotonic queue problem, there are generally a few steps and patterns to follow.\\n\\nIn our case, the first element should be the maximum value we can obtain so far.\\n\\n**Clear the obsolete**\\nSince it is a sliding window, obsolete item should be cleared, in this case, at index `i` , any item index `< i-k` should be cleared.\\n\\n**Kickout items that need not to be considered**\\nNow every element is in the range, we can consider to add the current element `A[i]`  , making it `A[i]+q[0][0]` or not adding it, making it `A[i]` whichever is larger. After that, the smaller elements need to be kicked out to maintain the tip of the queue is the one we are looking for.\\n\\n**Record the answer**\\nRecord the current max at every index as every sliding window problem does.\\n\\n\\n### Implementation\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\\n        q = deque()\\n        ans = -float(\\'inf\\')\\n        for i, a in enumerate(A):\\n            while q and q[0][1] < i-k:\\n                q.popleft()\\n            v = max(A[i], A[i]+(q[0][0] if q else 0))\\n            while q and q[-1][0] < v:\\n                q.pop()\\n            q.append((v, i))\\n            ans = max(ans, q[0][0])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def constrainedSubsetSum(self, A: List[int], k: int) -> int:\\n        q = deque()\\n        ans = -float(\\'inf\\')\\n        for i, a in enumerate(A):\\n            while q and q[0][1] < i-k:\\n                q.popleft()\\n            v = max(A[i], A[i]+(q[0][0] if q else 0))\\n            while q and q[-1][0] < v:\\n                q.pop()\\n            q.append((v, i))\\n            ans = max(ans, q[0][0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672473,
                "title": "python-deque",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        q = deque()\\n\\n        for i, num in enumerate(nums):\\n            if i > k and q[0] == dp[i-k-1]:\\n                q.popleft()\\n            dp[i] = max(q[0] if q else 0, 0)+num\\n\\n            while q and q[-1] < dp[i]:\\n                q.pop()\\n            q.append(dp[i])\\n        return max(dp)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        q = deque()\\n\\n        for i, num in enumerate(nums):\\n            if i > k and q[0] == dp[i-k-1]:\\n                q.popleft()\\n            dp[i] = max(q[0] if q else 0, 0)+num\\n\\n            while q and q[-1] < dp[i]:\\n                q.pop()\\n            q.append(dp[i])\\n        return max(dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664591,
                "title": "python-monotonic-decreasing-queue-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- similar to 1696, nearly the same\\n- 1696. Jump Game VI\\n```python\\nimport collections\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        n = len(nums)\\n        # store the max value in each index of nums\\n        dp = [nums[0]] * n \\n        # store the index of maximum dp values inside a window of k\\n        mono_dec_q = collections.deque([0]) \\n        for i in range(1, n):\\n            # the first value in queue is maximum\\n            dp[i] = nums[i] + dp[mono_dec_q[0]] \\n            # when iterate to dp[i], if it is higher than the end of queue, delete the end\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]: \\n                mono_dec_q.pop()\\n            # if index out of window, slide the window to the right\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n        return dp[-1]\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmonotonic queue\\n- res is set to nums[0], it may be a result like nums = [-1, -2, -3]\\n- dp[i] = nums[i] + max(0, dp[mono_dec_q[0]]), dp store the max values, the result is the max of dp array\\n- max(0, dp[mono_dec_q[0]]) means the different from 1696, here not start from first jump to last, can start from any place and end to any place, only need to meet the condition of jump within k steps, here is subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp, mono_dec_q, res = [nums[0]] * n, deque([0]), nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + max(0, dp[mono_dec_q[0]])\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]:\\n                mono_dec_q.pop()\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n            res = max(res, dp[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nimport collections\\nclass Solution:\\n    def maxResult(self, nums, k):\\n        n = len(nums)\\n        # store the max value in each index of nums\\n        dp = [nums[0]] * n \\n        # store the index of maximum dp values inside a window of k\\n        mono_dec_q = collections.deque([0]) \\n        for i in range(1, n):\\n            # the first value in queue is maximum\\n            dp[i] = nums[i] + dp[mono_dec_q[0]] \\n            # when iterate to dp[i], if it is higher than the end of queue, delete the end\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]: \\n                mono_dec_q.pop()\\n            # if index out of window, slide the window to the right\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp, mono_dec_q, res = [nums[0]] * n, deque([0]), nums[0]\\n        for i in range(1, n):\\n            dp[i] = nums[i] + max(0, dp[mono_dec_q[0]])\\n            while mono_dec_q and dp[i] >= dp[mono_dec_q[-1]]:\\n                mono_dec_q.pop()\\n            if mono_dec_q and i - mono_dec_q[0] == k:\\n                mono_dec_q.popleft()\\n            mono_dec_q.append(i)\\n            res = max(res, dp[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640009,
                "title": "python-monotonic-queue",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q, r = deque(), -inf\\n        \\n        for i, num in enumerate(nums):     \\n            while q and i - q[0][1] > k: q.popleft()\\n            m = q[0][0] + num if q and q[0][0] > 0 else num\\n            if m > r: r = m\\n            while q and q[-1][0] < m: q.pop()\\n            q.append((m, i))\\n            \\n        return r  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q, r = deque(), -inf\\n        \\n        for i, num in enumerate(nums):     \\n            while q and i - q[0][1] > k: q.popleft()\\n            m = q[0][0] + num if q and q[0][0] > 0 else num\\n            if m > r: r = m\\n            while q and q[-1][0] < m: q.pop()\\n            q.append((m, i))\\n            \\n        return r  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576524,
                "title": "python-3-simple-monotonic-o-n-solution",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        que=deque([])\\n        dp=[0 for i in range(len(nums))]\\n        for i,val in enumerate(nums):\\n            while que and que[0][1] < i-k:\\n                que.popleft()\\n            dp[i]=max(val+(que[0][0] if que else 0),val) \\n            while que and dp[i] >= que[-1][0]:\\n                que.pop()\\n            que.append([dp[i],i])\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        que=deque([])\\n        dp=[0 for i in range(len(nums))]\\n        for i,val in enumerate(nums):\\n            while que and que[0][1] < i-k:\\n                que.popleft()\\n            dp[i]=max(val+(que[0][0] if que else 0),val) \\n            while que and dp[i] >= que[-1][0]:\\n                que.pop()\\n            que.append([dp[i],i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549602,
                "title": "simple-solution-with-explanation-multiset-dp-very-easy",
                "content": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        multiset<int>s;\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        // dp[i]=max sum we can make if we take index i\\n        s.insert(nums[0]);\\n        dp[0]=nums[0];\\n        int mx=dp[0];\\n        for(int i=1;i<n;i++){\\n            if(i<=k){\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            else{\\n                s.erase(s.find(dp[i-k-1]));\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            s.insert(dp[i]);\\n            mx=max(mx,dp[i]);\\n        }\\n        return mx;\\n    }\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint constrainedSubsetSum(vector<int>& nums, int k) {\\n        multiset<int>s;\\n        int n=nums.size();\\n        vector<int>dp(n+1,0);\\n        // dp[i]=max sum we can make if we take index i\\n        s.insert(nums[0]);\\n        dp[0]=nums[0];\\n        int mx=dp[0];\\n        for(int i=1;i<n;i++){\\n            if(i<=k){\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            else{\\n                s.erase(s.find(dp[i-k-1]));\\n                auto x=s.end();\\n                x--;\\n//                 we take the max element of the set\\n                dp[i]=nums[i]+max(0,*x);\\n            }\\n            s.insert(dp[i]);\\n            mx=max(mx,dp[i]);\\n        }\\n        return mx;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2542364,
                "title": "python-two-solutions-max-heap-mono-deque",
                "content": "max_heap solution: Time - O(NlogN)\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = [(-nums[0], 0)], nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\theappop(q)\\n\\t\\tcur = max(nums[i], nums[i]-q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\theappush(q, (-cur, i))\\n\\treturn ans\\n```\\n\\nmono-deque solution: Time - O(N)\\n\\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = deque([(nums[0], 0)]), nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\tq.popleft()\\n\\t\\tcur = max(nums[i], nums[i]+q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\twhile(q and q[-1][0]<=cur):\\n\\t\\t\\tq.pop()\\n\\t\\tq.append((cur, i))\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = [(-nums[0], 0)], nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\theappop(q)\\n\\t\\tcur = max(nums[i], nums[i]-q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\theappush(q, (-cur, i))\\n\\treturn ans\\n```\n```\\ndef constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n\\tq, ans = deque([(nums[0], 0)]), nums[0]\\n\\tfor i in range(1, len(nums)):\\n\\t\\twhile(q and i-q[0][1]>k):\\n\\t\\t\\tq.popleft()\\n\\t\\tcur = max(nums[i], nums[i]+q[0][0])\\n\\t\\tans = max(cur, ans)\\n\\t\\twhile(q and q[-1][0]<=cur):\\n\\t\\t\\tq.pop()\\n\\t\\tq.append((cur, i))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2516511,
                "title": "c-two-approaches-using-set-and-using-monotonic-deque-with-explanation",
                "content": "### Solution using Set\\n\\n```\\n//Time Complexity : O(Nlogk) (Because there are atmost k element in the set)\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            // We will use max_prev to store the previous k sum of subsequences\\n            \\n            set<pair<int, int>> max_prev;\\n            \\n            max_prev.insert({ dp[0], 0 });\\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0)\\n                    max_prev.erase({ dp[i - k - 1],i - k - 1 });\\n\\n                \\n                int mx = max_prev.rbegin()->first; // We find the subsequence with maximum sum\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(mx + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //We will use this value in the future\\n                max_prev.insert({ dp[i],i });\\n            }\\n\\n            return ans;\\n        }\\n};\\n```\\n\\n### Using Monotonic deque\\n\\n```\\n//Time Complexity : O(N) (Because we get maximum element in O(1))\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            \\n            // dq will always store values in non-increasing (descending order)\\n            //So dq.front() will have greatest value in the range\\n            deque<int> dq;\\n            dq.push_back(dp[0]);\\n            \\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0 and dq.front() == dp[i-k-1])\\n                    dq.pop_front();\\n\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(dq.front() + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //If dp[i] is greater then dq.back() then the values in dq wont be non-increasing, so we remove them\\n                while(!dq.empty() and dp[i] > dq.back())\\n                    dq.pop_back();\\n                \\n                dq.push_back(dp[i]);\\n                \\n            }\\n\\n            return ans;\\n        }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Ordered Set",
                    "Monotonic Queue"
                ],
                "code": "```\\n//Time Complexity : O(Nlogk) (Because there are atmost k element in the set)\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            // We will use max_prev to store the previous k sum of subsequences\\n            \\n            set<pair<int, int>> max_prev;\\n            \\n            max_prev.insert({ dp[0], 0 });\\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0)\\n                    max_prev.erase({ dp[i - k - 1],i - k - 1 });\\n\\n                \\n                int mx = max_prev.rbegin()->first; // We find the subsequence with maximum sum\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(mx + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //We will use this value in the future\\n                max_prev.insert({ dp[i],i });\\n            }\\n\\n            return ans;\\n        }\\n};\\n```\n```\\n//Time Complexity : O(N) (Because we get maximum element in O(1))\\n//Spcae complexity: O(N)\\n\\nclass Solution\\n{\\n    public:\\n        int constrainedSubsetSum(vector<int> &nums, int k)\\n        {\\n            const int N = nums.size();\\n            vector<int> dp(N);\\n\\n            /**\\n            * dp[i] = Maximum sum of subsequence if we take the element at index i\\n            */\\n            \\n            dp[0] = nums[0];\\n            \\n            // dq will always store values in non-increasing (descending order)\\n            //So dq.front() will have greatest value in the range\\n            deque<int> dq;\\n            dq.push_back(dp[0]);\\n            \\n            int ans = dp[0];\\n\\n            for (int i = 1; i < N; i++)\\n            {\\n                \\n                // We want elements in the range [i-k , i], since i-k-1 is out of bounds we remove it\\n                if (i - k - 1 >= 0 and dq.front() == dp[i-k-1])\\n                    dq.pop_front();\\n\\n\\n                // Here if we want to append nums[i] to the previous subsequence we will get sum mx + nums[i]\\n                // If we want to start a new subsequence from nums[i] we will get nums[i]\\n                // We take the best of two \\n                \\n                dp[i] = max(dq.front() + nums[i], nums[i]);\\n                ans = max(ans, dp[i]);\\n                \\n                //If dp[i] is greater then dq.back() then the values in dq wont be non-increasing, so we remove them\\n                while(!dq.empty() and dp[i] > dq.back())\\n                    dq.pop_back();\\n                \\n                dq.push_back(dp[i]);\\n                \\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497453,
                "title": "finally-omg",
                "content": "```\\nclass Solution:\\n    def monoque(self, stack, num, index):\\n        while len(stack) > 0 and num > stack[-1][0]:\\n            stack.pop()\\n        stack.append((num, index))\\n    \\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        dp[0] = nums[0]\\n        stack = collections.deque()\\n        stack.append((nums[0],0))\\n        \\n        for i in range(1,n):\\n            if i > stack[0][1] + k:\\n                stack.popleft()\\n                \\n            if stack[0][0] + nums[i] < nums[i]:\\n                dp[i] = nums[i]\\n                self.monoque(stack, nums[i], i)\\n            else:\\n                dp[i] = nums[i]+stack[0][0]\\n                self.monoque(stack, nums[i]+stack[0][0], i)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def monoque(self, stack, num, index):\\n        while len(stack) > 0 and num > stack[-1][0]:\\n            stack.pop()\\n        stack.append((num, index))\\n    \\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0]*n\\n        dp[0] = nums[0]\\n        stack = collections.deque()\\n        stack.append((nums[0],0))\\n        \\n        for i in range(1,n):\\n            if i > stack[0][1] + k:\\n                stack.popleft()\\n                \\n            if stack[0][0] + nums[i] < nums[i]:\\n                dp[i] = nums[i]\\n                self.monoque(stack, nums[i], i)\\n            else:\\n                dp[i] = nums[i]+stack[0][0]\\n                self.monoque(stack, nums[i]+stack[0][0], i)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460030,
                "title": "c-monotonic-queue-deque-solution-in-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        deque<int> dq;\\n        dp[n-1]=a[n-1];\\n        dq.push_back(n-1);\\n       \\n        for(int i=n-2;i>=0;i--)\\n        {\\n           \\n            if(dq.front()-i>k) dq.pop_front();\\n            \\n            dp[i]+=a[i];\\n            dp[i]+=dp[dq.front()];\\n            dp[i]=max(a[i],dp[i]);\\n            while(!dq.empty() and dp[i]>dp[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> dp(n,0);\\n        deque<int> dq;\\n        dp[n-1]=a[n-1];\\n        dq.push_back(n-1);\\n       \\n        for(int i=n-2;i>=0;i--)\\n        {\\n           \\n            if(dq.front()-i>k) dq.pop_front();\\n            \\n            dp[i]+=a[i];\\n            dp[i]+=dp[dq.front()];\\n            dp[i]=max(a[i],dp[i]);\\n            while(!dq.empty() and dp[i]>dp[dq.back()]) dq.pop_back();\\n            dq.push_back(i);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451905,
                "title": "c-solution-98-faster-using-deque",
                "content": "![image](https://assets.leetcode.com/users/images/f10cec1f-8ecb-4ec6-9330-2b8b5d427d66_1660975327.7448714.png)\\n```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MIN;\\n        \\n        vector<int> dp(n);\\n        deque<int> sums;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (sums.front() == i - k - 1) sums.pop_front();\\n            dp[i] = max(nums[i] + (sums.empty() ? 0 : dp[sums.front()]), nums[i]);\\n            res = max(res, dp[i]);\\n            while (!sums.empty() && dp[sums.back()] <= dp[i]) sums.pop_back();\\n            sums.push_back(i);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438433,
                "title": "simple-dp-c-solution-same-as-leetcode-239",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        //here we use leetcode 239 questions concept monotonic queue and simple dp ie kadanes algorithm approach that dp[i] = max((dp[i-k+1],....dp[i-1]),0) + currNum\\n        \\n        deque<int> dq;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(dq.size() and dq.front()==i-k-1) dq.pop_front(); //out of boundary\\n            \\n            dp[i] = nums[i];\\n            if(dq.size())\\n                dp[i] = max(dp[dq.front()]+nums[i],nums[i]);\\n            \\n            while(dq.size() and dp[dq.back()]<=dp[i])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(i);\\n        }\\n        return *max_element(dp,dp+n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        //here we use leetcode 239 questions concept monotonic queue and simple dp ie kadanes algorithm approach that dp[i] = max((dp[i-k+1],....dp[i-1]),0) + currNum\\n        \\n        deque<int> dq;\\n        \\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(dq.size() and dq.front()==i-k-1) dq.pop_front(); //out of boundary\\n            \\n            dp[i] = nums[i];\\n            if(dq.size())\\n                dp[i] = max(dp[dq.front()]+nums[i],nums[i]);\\n            \\n            while(dq.size() and dp[dq.back()]<=dp[i])\\n            {\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(i);\\n        }\\n        return *max_element(dp,dp+n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420628,
                "title": "simple-deque-approach-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& arr, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int n = arr.size();\\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(!dq.empty() && i-dq.front().second>k){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                dq.push_back({arr[i],i});\\n                ans = max(ans, arr[i]);\\n            }\\n            else{\\n                \\n                int x = dq.front().first+arr[i];\\n                x = max(x,arr[i]);\\n                ans = max(ans,x);\\n                while(!dq.empty() && dq.back().first<x)\\n                    dq.pop_back();\\n                dq.push_back({x,i});\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& arr, int k) {\\n        \\n        deque<pair<int,int>> dq;\\n        int n = arr.size();\\n        int ans = INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(!dq.empty() && i-dq.front().second>k){\\n                dq.pop_front();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2420380,
                "title": "python-similar-to-jump-game-vi-notes-dp-heap-beats-68",
                "content": "```\\n/*\\nproblem is very much similar to Jump Game VI\\n\\ncreate a dp[] array where dp[i] dentoes the maximum sum we can have \\nwhen we start from ith position and reach to end\\n\\nLet dp[i] be \"the maximum score to reach the end starting at index i\". \\nThe answer for dp[i] is nums[i] + max{dp[i+j]} for 1 <= j <= k. \\nThat gives an O(n*k) solution.\\n\\nInstead of checking every j for every i, keep track of the largest dp[i] \\nvalues in a heap and calculate dp[i] from right to left. \\nWhen the largest value in the heap is out of bounds of the current index, \\nremove it and keep checking.\\n\\nThe difference of this problem with Jump Game VI is, in the latter problem, we \\nhad to include the last element and the first element. However, in this problem we\\nmay or may not include it as part of the answer. \\n*/\\n```\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        dp[-1] = nums[-1]\\n        heap = []\\n        heapq.heappush(heap, (-nums[-1], len(nums)-1))\\n        for i in range(len(nums)-2, -1, -1):\\n            while True:\\n                if i + k >= heap[0][1]:\\n                    dp[i] = max(nums[i], nums[i] + -1 * heap[0][0])\\n                    heapq.heappush(heap, (-dp[i], i))\\n                    break\\n                else:\\n                    heapq.heappop(heap)\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nproblem is very much similar to Jump Game VI\\n\\ncreate a dp[] array where dp[i] dentoes the maximum sum we can have \\nwhen we start from ith position and reach to end\\n\\nLet dp[i] be \"the maximum score to reach the end starting at index i\". \\nThe answer for dp[i] is nums[i] + max{dp[i+j]} for 1 <= j <= k. \\nThat gives an O(n*k) solution.\\n\\nInstead of checking every j for every i, keep track of the largest dp[i] \\nvalues in a heap and calculate dp[i] from right to left. \\nWhen the largest value in the heap is out of bounds of the current index, \\nremove it and keep checking.\\n\\nThe difference of this problem with Jump Game VI is, in the latter problem, we \\nhad to include the last element and the first element. However, in this problem we\\nmay or may not include it as part of the answer. \\n*/\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [0 for _ in range(len(nums))]\\n        dp[-1] = nums[-1]\\n        heap = []\\n        heapq.heappush(heap, (-nums[-1], len(nums)-1))\\n        for i in range(len(nums)-2, -1, -1):\\n            while True:\\n                if i + k >= heap[0][1]:\\n                    dp[i] = max(nums[i], nums[i] + -1 * heap[0][0])\\n                    heapq.heappush(heap, (-dp[i], i))\\n                    break\\n                else:\\n                    heapq.heappop(heap)\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404742,
                "title": "java-max-heap",
                "content": "At each index `i`, we check the maximum sum subsequence which can be formed by taking the previously formed subsequences within the window `i-k`. We can use a max heap to keep track of the previously formed subsequences, and also keep polling out the elements which are not in the desired window. \\n\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> nums[b] - nums[a]);\\n        \\n        maxHeap.add(0);\\n        int ans = nums[0];\\n        for(int i = 1; i<n;i++) {\\n            while(maxHeap.size() > 0 && maxHeap.peek() < i-k)\\n                maxHeap.poll();\\n            \\n            if(nums[maxHeap.peek()] >= 0)\\n                nums[i] += nums[maxHeap.peek()];\\n            \\n            ans = Math.max(ans, nums[i]);\\n            maxHeap.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b) -> nums[b] - nums[a]);\\n        \\n        maxHeap.add(0);\\n        int ans = nums[0];\\n        for(int i = 1; i<n;i++) {\\n            while(maxHeap.size() > 0 && maxHeap.peek() < i-k)\\n                maxHeap.poll();\\n            \\n            if(nums[maxHeap.peek()] >= 0)\\n                nums[i] += nums[maxHeap.peek()];\\n            \\n            ans = Math.max(ans, nums[i]);\\n            maxHeap.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390232,
                "title": "o-n-solution",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        from collections import deque\\n        dq = deque()\\n        n = len(nums)\\n        \\n        dp = [nums[i - 1] if i > 0 else 0 for i in range(n + 1)]\\n        for i in range(1, n + 1):\\n            while (len(dq) > 0 and i - dq[0] > k):\\n                dq.popleft()\\n            if len(dq) > 0:\\n                dp[i] = max(dp[i], dp[dq[0]] + nums[i - 1])\\n            while (len(dq) > 0 and dp[dq[-1]] <= dp[i]):\\n                dq.pop()\\n            \\n            dq.append(i)\\n            \\n        return max([dp[i] for i in range(1, n + 1)])\\n        \\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        from collections import deque\\n        dq = deque()\\n        n = len(nums)\\n        \\n        dp = [nums[i - 1] if i > 0 else 0 for i in range(n + 1)]\\n        for i in range(1, n + 1):\\n            while (len(dq) > 0 and i - dq[0] > k):\\n                dq.popleft()\\n            if len(dq) > 0:\\n                dp[i] = max(dp[i], dp[dq[0]] + nums[i - 1])\\n            while (len(dq) > 0 and dp[dq[-1]] <= dp[i]):\\n                dq.pop()\\n            \\n            dq.append(i)\\n            \\n        return max([dp[i] for i in range(1, n + 1)])\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384775,
                "title": "heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& ar, int k) {\\n        priority_queue< pair<int,int>,vector< pair<int,int> >  > pq;\\n        int ans =*max_element(ar.begin(),ar.end());\\n        for(int idx=0; idx<ar.size();idx++){\\n            while(pq.size() >0 and idx - pq.top().second > k) pq.pop();\\n            if(pq.size() > 0)  pq.push({pq.top().first + ar[idx],idx});\\n            pq.push({ar[idx],idx});\\n        }\\n        return max(ans,pq.top().first);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& ar, int k) {\\n        priority_queue< pair<int,int>,vector< pair<int,int> >  > pq;\\n        int ans =*max_element(ar.begin(),ar.end());\\n        for(int idx=0; idx<ar.size();idx++){\\n            while(pq.size() >0 and idx - pq.top().second > k) pq.pop();\\n            if(pq.size() > 0)  pq.push({pq.top().first + ar[idx],idx});\\n            pq.push({ar[idx],idx});\\n        }\\n        return max(ans,pq.top().first);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349490,
                "title": "java-dp-optimized-using-priority-queue",
                "content": "```\\nclass Solution {\\n    class pair implements Comparable<pair>{\\n        int ans;\\n        int i;\\n        pair(int ans , int i){\\n            this.ans = ans;\\n            this.i = i;\\n        }\\n        public int compareTo(pair o){\\n            return o.ans - this.ans;\\n        }\\n    }\\n    public int constrainedSubsetSum(int[] a, int k) {\\n        int n = a.length;\\n        int dp[] = new int[n];\\n        PriorityQueue<pair> pq = new PriorityQueue<>();\\n        int max = -1;\\n        for(int i = n - 1; i >= 0; i--){\\n            while(pq.size() > 0 && pq.peek().i > i + k){\\n                pq.poll();\\n            }\\n            if(pq.size() > 0){\\n                pair pp = pq.peek();\\n                dp[i] = a[i] + pq.peek().ans;\\n            }\\n            else{\\n                dp[i] = a[i];\\n            }\\n            if(dp[i] > 0){\\n                pq.add(new pair(dp[i] , i));\\n            }\\n            max = Math.max(max , dp[i]);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    class pair implements Comparable<pair>{\\n        int ans;\\n        int i;\\n        pair(int ans , int i){\\n            this.ans = ans;\\n            this.i = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2345557,
                "title": "understanding-the-assigment",
                "content": "my code:\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if k>1:\\n            k-=1\\n        f=nums[:]\\n        cur =[]\\n        for i in range(len(nums)):\\n            print(i,nums,cur,sum(nums))\\n            if nums[i]<=0:\\n                cur.append((i,nums.pop(i)))\\n                nums.insert(i,0)\\n            else:\\n                if cur and cur[-1][0]-cur[0][0]<=k :\\n                    cur = []\\n                else:\\n                    cur.sort(key = lambda x :x[1])\\n                    while len(cur)>k:\\n                        a,b=cur.pop()\\n                        nums[a]=b\\n                    cur = []\\n        print(nums)\\n        if  not sum(nums):\\n            return max(f)\\n        else:\\n            return sum(nums)\\n```\\n\\'\\'\\'\\n\\n\\n                           \\n\\'\\'\\'\\nIm not sure why is this failing , maybe i dont understand the assigment well enough, but for example \\nwhy for this input :\\n[-8,3,-4,-4,-6,6,-3,9,4,-3]\\n1\\n\\nI should get 16 and not 14 ? \\nIsn\\'t the array we wanna sum will look like that in the end :\\n[0, 3, -4, -4, 0, 6, 0, 9, 4, 0]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        if k>1:\\n            k-=1\\n        f=nums[:]\\n        cur =[]\\n        for i in range(len(nums)):\\n            print(i,nums,cur,sum(nums))\\n            if nums[i]<=0:\\n                cur.append((i,nums.pop(i)))\\n                nums.insert(i,0)\\n            else:\\n                if cur and cur[-1][0]-cur[0][0]<=k :\\n                    cur = []\\n                else:\\n                    cur.sort(key = lambda x :x[1])\\n                    while len(cur)>k:\\n                        a,b=cur.pop()\\n                        nums[a]=b\\n                    cur = []\\n        print(nums)\\n        if  not sum(nums):\\n            return max(f)\\n        else:\\n            return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330842,
                "title": "python3-decreasing-monotonic-deque-without-copying-the-original-array",
                "content": "We maintain a monotonic decreasing deque to store the valid possible sums in the window with length (k-1). Why k-1 instead of k? Because in each iteration, we introduce new candidate, the new candidate along with the k-1 window form our k-length window. \\nAnother implementation trick here is that we store the index and possible sum pair so that we can pop the outdated (invalid) element in the deque. \\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        max_dq = deque()\\n        max_sum = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            local_max = nums[i]\\n            local_max += max_dq[0][1] if max_dq else 0\\n            \\n            max_sum = max(max_sum, local_max)\\n            \\n            while max_dq and max_dq[-1][1] < local_max:\\n                max_dq.pop()\\n            \\n\\t\\t\\t# max_dq can be empty. In this case, the new coming candidate is the new coming number itself\\n            if local_max > 0:\\n                max_dq.append((i, local_max))\\n            \\n\\t\\t\\t# remove updated element\\n            if max_dq and max_dq[0][0] == i-k:\\n                max_dq.popleft()\\n            \\n        return max_sum\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        max_dq = deque()\\n        max_sum = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            local_max = nums[i]\\n            local_max += max_dq[0][1] if max_dq else 0\\n            \\n            max_sum = max(max_sum, local_max)\\n            \\n            while max_dq and max_dq[-1][1] < local_max:\\n                max_dq.pop()\\n            \\n\\t\\t\\t# max_dq can be empty. In this case, the new coming candidate is the new coming number itself\\n            if local_max > 0:\\n                max_dq.append((i, local_max))\\n            \\n\\t\\t\\t# remove updated element\\n            if max_dq and max_dq[0][0] == i-k:\\n                max_dq.popleft()\\n            \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289398,
                "title": "c-o-nlogn-multiset-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n      vector < int > dp(nums.size()  , 0); \\n          multiset < int > st; \\n   int t = 0 , j =0 ; \\n        int mxSum = INT_MIN ; \\n     for(int i = 0 ; i < nums.size(); i++){ \\n         dp[i] = nums[i]; \\n         if(st.size() > 0) { auto it = st.end(); it--; \\n         dp[i] += max(0 , *it); }\\n         t++; \\n         if(t > k){ \\n         auto it = st.find(dp[j]); \\n            st.erase(it); \\n             j++; \\n         }\\n          st.insert(dp[i]); \\n       mxSum = max( mxSum , dp[i]);    \\n     }  \\n        return mxSum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n      vector < int > dp(nums.size()  , 0); \\n          multiset < int > st; \\n   int t = 0 , j =0 ; \\n        int mxSum = INT_MIN ; \\n     for(int i = 0 ; i < nums.size(); i++){ \\n         dp[i] = nums[i]; \\n         if(st.size() > 0) { auto it = st.end(); it--; \\n         dp[i] += max(0 , *it); }\\n         t++; \\n         if(t > k){ \\n         auto it = st.find(dp[j]); \\n            st.erase(it); \\n             j++; \\n         }\\n          st.insert(dp[i]); \\n       mxSum = max( mxSum , dp[i]);    \\n     }  \\n        return mxSum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283151,
                "title": "python-2-solution-heap-and-monotonic-deque",
                "content": "#### Heap Solution:\\n* Time: O(Nlog(k))\\n* Space O(k)\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        hq = [(-nums[0], 0)] # (-dp[j],j) dp[j]: maximum sum until index j including nums[j]  \\n        \\n        for j, num in enumerate(nums[1:], start = 1):\\n    \\n            while hq and hq[0][1] < j-k: heapq.heappop(hq)\\n                \\n            cur = max(-hq[0][0], 0) + num\\n            heapq.heappush(hq,(-cur,j))\\n            res = max(res,cur)\\n\\n        return res\\n```\\n#### Deque Solution:\\n* Time: O(N)\\n* Space: O(k)\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        dq = deque([(0,nums[0])])\\n        \\n        for j, num in enumerate(nums[1:], start =1):\\n            cur = max(0, dq[0][1]) + num\\n            \\n            while dq and dq[-1][1] <= cur: dq.pop()\\n            \\n            dq.append((j, cur))\\n            \\n            if dq and dq[0][0] == j - k: dq.popleft()\\n            \\n            res = max(res,cur)\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        hq = [(-nums[0], 0)] # (-dp[j],j) dp[j]: maximum sum until index j including nums[j]  \\n        \\n        for j, num in enumerate(nums[1:], start = 1):\\n    \\n            while hq and hq[0][1] < j-k: heapq.heappop(hq)\\n                \\n            cur = max(-hq[0][0], 0) + num\\n            heapq.heappush(hq,(-cur,j))\\n            res = max(res,cur)\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        \\n        res = nums[0]\\n        dq = deque([(0,nums[0])])\\n        \\n        for j, num in enumerate(nums[1:], start =1):\\n            cur = max(0, dq[0][1]) + num\\n            \\n            while dq and dq[-1][1] <= cur: dq.pop()\\n            \\n            dq.append((j, cur))\\n            \\n            if dq and dq[0][0] == j - k: dq.popleft()\\n            \\n            res = max(res,cur)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2273270,
                "title": "python3-decreasing-deque-o-n",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sw=deque()\\n        n=len(nums)\\n        currSum=0\\n        ans=-float(\\'inf\\')\\n        for i in range(n):\\n            if sw and i-k>sw[0][0]:\\n                sw.popleft()\\n            if len(sw):\\n                currSum=max(nums[i],nums[i]+sw[0][1])\\n            else:\\n                currSum=nums[i]\\n            #print(currSum,sw)\\n            while sw and sw[-1][1]<=currSum:\\n                sw.pop()\\n            sw.append([i,currSum])\\n            ans=max(ans,currSum)\\n        return ans\\n                    \\n                \\n                \\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        sw=deque()\\n        n=len(nums)\\n        currSum=0\\n        ans=-float(\\'inf\\')\\n        for i in range(n):\\n            if sw and i-k>sw[0][0]:\\n                sw.popleft()\\n            if len(sw):\\n                currSum=max(nums[i],nums[i]+sw[0][1])\\n            else:\\n                currSum=nums[i]\\n            #print(currSum,sw)\\n            while sw and sw[-1][1]<=currSum:\\n                sw.pop()\\n            sw.append([i,currSum])\\n            ans=max(ans,currSum)\\n        return ans\\n                    \\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271735,
                "title": "c-easy-solution-using-double-ended-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        int result=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.front().second<i-k) dq.pop_front();\\n            int item=nums[i];\\n            if(!dq.empty()) item=max(item,nums[i]+dq.front().first);\\n            result=max(result,item);\\n            while(!dq.empty() && dq.back().first<item) dq.pop_back();\\n            dq.push_back({item,i});\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int,int>> dq;\\n        int result=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            while(!dq.empty() && dq.front().second<i-k) dq.pop_front();\\n            int item=nums[i];\\n            if(!dq.empty()) item=max(item,nums[i]+dq.front().first);\\n            result=max(result,item);\\n            while(!dq.empty() && dq.back().first<item) dq.pop_back();\\n            dq.push_back({item,i});\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269353,
                "title": "python3-solution-dp-deque",
                "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(k)`\\n\\n```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        q = collections.deque()\\n        for i in reversed(range(len(A))):\\n            if q and q[-1] > i + k: q.pop()\\n            A[i] += A[q[-1]] if q else 0\\n            while q and A[q[0]] <= A[i]:\\n                q.popleft()\\n            if A[i] > 0: q.appendleft(i)\\n        return max(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, A, k):\\n        q = collections.deque()\\n        for i in reversed(range(len(A))):\\n            if q and q[-1] > i + k: q.pop()\\n            A[i] += A[q[-1]] if q else 0\\n            while q and A[q[0]] <= A[i]:\\n                q.popleft()\\n            if A[i] > 0: q.appendleft(i)\\n        return max(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246143,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int start =0 ,end = 0,ans = Integer.MIN_VALUE ,currSum =0;\\n        List<Integer> prevKSum = new LinkedList<>();\\n        int[] dp = new int[nums.length];\\n        while(end < nums.length){\\n            currSum = Math.max(nums[end],nums[end]+(prevKSum.size()>0 ? prevKSum.get(0):0)); \\n            dp[end]= currSum;\\n            \\n             while(prevKSum.size() > 0 && prevKSum.get(prevKSum.size()-1) < currSum)\\n                prevKSum.remove(prevKSum.size()-1);\\n            \\n            prevKSum.add(currSum);\\n            \\n            if(end-start+1>k){\\n                  if(prevKSum.get(0)==dp[end-k])\\n                    prevKSum.remove(0);\\n            }\\n            ans = Math.max(ans,currSum);\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int start =0 ,end = 0,ans = Integer.MIN_VALUE ,currSum =0;\\n        List<Integer> prevKSum = new LinkedList<>();\\n        int[] dp = new int[nums.length];\\n        while(end < nums.length){\\n            currSum = Math.max(nums[end],nums[end]+(prevKSum.size()>0 ? prevKSum.get(0):0)); \\n            dp[end]= currSum;\\n            \\n             while(prevKSum.size() > 0 && prevKSum.get(prevKSum.size()-1) < currSum)\\n                prevKSum.remove(prevKSum.size()-1);\\n            \\n            prevKSum.add(currSum);\\n            \\n            if(end-start+1>k){\\n                  if(prevKSum.get(0)==dp[end-k])\\n                    prevKSum.remove(0);\\n            }\\n            ans = Math.max(ans,currSum);\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215742,
                "title": "c-monotonic-queue",
                "content": "[self-use]\\nWe use an additional array:\\ndp[i] = maximum sum we can get using A[i] as the ending number of the subsequence.\\nThe subsequence also has to satisfy the condition that it cannot use any number outside of range [i-k,i] as required by the problem.\\n\\nWe use a monotonic q to store non-increasing sequence of sums (dp[i]) to help us derive each dp[i]\\n\\nSay we are at index i:\\n1. The front of the q is the largest sum possible using elements from [i-k, i].\\n2. The back of the q is the smallest sum possible ...\\n3. sum = A[i] + q.front() is the new largest possible sum using element i\\n4. with the monotonic queue logic, we just remove back of the q if sum is greater, since a smaller sum is no longer of interest.\\n\\nFor 1, we have to maintain the property by removing out of range element in the prior end of the loop [sliding window technique].\\nWe also don\\'t want to add negative or zero values to the queue because they don\\'t contribute to a larger sum.\\nAdding zeros to queue can still give a correct output because those values will be poped by the monotonic queue logic.\\nAdding negative values are harmful because it violates 1 mentioned above \"q front should be the largest sum...\". \\n\\nSay A is size of N, K=k\\nTime Complexity: \\nO(N) on average as the q only stores up to k elements (all dp[i]).\\nSpace Complexity:\\nO(N) for the dp.\\nO(K) for the deque.\\n```\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        vector<int> dp(A.size(), 0);\\n        int res = -1;\\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = A[i] + (q.empty() ? 0 : q.front());\\n            res = max(dp[i], res);\\n            while (!q.empty() && dp[i] > q.back()) {\\n                q.pop_back();\\n            }\\n            if (dp[i] > 0) {\\n                q.push_back(dp[i]);\\n            }\\n            //next element cannot use i-k anymore\\n            if (i >= k) {\\n                if (!q.empty() && q.front() == dp[i-k]) {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int constrainedSubsetSum(vector<int>& A, int k) {\\n        deque<int> q;\\n        vector<int> dp(A.size(), 0);\\n        int res = -1;\\n        for (int i = 0; i < A.size(); i++) {\\n            dp[i] = A[i] + (q.empty() ? 0 : q.front());\\n            res = max(dp[i], res);\\n            while (!q.empty() && dp[i] > q.back()) {\\n                q.pop_back();\\n            }\\n            if (dp[i] > 0) {\\n                q.push_back(dp[i]);\\n            }\\n            //next element cannot use i-k anymore\\n            if (i >= k) {\\n                if (!q.empty() && q.front() == dp[i-k]) {\\n                    q.pop_front();\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204689,
                "title": "java-0-n-sliding-window-maxima",
                "content": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        //j-i <= k\\n        //dp(j) =max(dp(j-1),dp(j-2),....dp(j-k))+nums[j]\\n        /*\\n           10 2 -10 5 20\\n           10 12 0  17 37\\n           \\n           //sliding window maximum \\n        */\\n        int maxf=Integer.MIN_VALUE;\\n        List<Integer>l=new ArrayList<>();\\n        int[]dp=new int[nums.length];\\n        \\n        for(int i=0;i<=k-1;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            dp[i]=tmp;\\n                \\n            while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            \\n             while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n            dp[i]=tmp;\\n            \\n            if(l.get(0)==dp[i-k])\\n                l.remove(0);\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        //j-i <= k\\n        //dp(j) =max(dp(j-1),dp(j-2),....dp(j-k))+nums[j]\\n        /*\\n           10 2 -10 5 20\\n           10 12 0  17 37\\n           \\n           //sliding window maximum \\n        */\\n        int maxf=Integer.MIN_VALUE;\\n        List<Integer>l=new ArrayList<>();\\n        int[]dp=new int[nums.length];\\n        \\n        for(int i=0;i<=k-1;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            dp[i]=tmp;\\n                \\n            while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n        }\\n        for(int i=k;i<nums.length;i++){\\n            int tmp=Math.max(nums[i],nums[i]+(l.size()==0?0:l.get(0)));\\n            maxf=Math.max(maxf,tmp);\\n            \\n             while(l.size() > 0 && l.get(l.size()-1) < tmp)\\n                l.remove(l.size()-1);\\n            \\n            l.add(tmp);\\n            dp[i]=tmp;\\n            \\n            if(l.get(0)==dp[i-k])\\n                l.remove(0);\\n        }\\n        return maxf;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194519,
                "title": "python-o-n-monotonic-queue-with-dp-solution-with-explanation",
                "content": "### About brute force with DP\\nthe problem is to find the subsequence sum, so dp is needed.\\n```dp[i]``` is maximum subsequence sum with ```i``` as the end point (must contain ```nums[i]```)\\nstate transition equation is ```dp[i] = max(nums[i], {dp[i-j] + nums[i], j in [1, k], if i-j >= 0})```\\n\\nbrute force with dp array is to use size k sliding window to find its max value, tc is O(kN)\\n\\n### monotonic queue with DP\\nso, we need a data struture to track max value of sliding window, the candidates have max heap (logN) and monotonic queue which is maintained in the decreasing order. the latter is more time efficient.\\n\\nAnd deque is used as monotonic queue\\'s data container, and stores dp array\\'s index instead of value.\\n\\n1. initiate ```dp[i]``` to ```nums[i]``` -> ```currentMaxSum[idx] = n```\\n2. ```dp[i] = nums[i] + max({dp[i-j] + nums[i], j in [1, k], if i-j >= 0}))```, the tail of queue is max value (>0) of sliding window if queue is not empty ->```if monoq: currentMaxSum[idx] += peekTailOfQ()```\\n3. find the max subsequence sum -> ```ans = max(ans, currentMaxSum[idx])```\\n4. start to process information used in ```dp[i+1]```\\n5. remove max value (index, actually) is out of sliding window from the tail (left remove) -> ```if monoq and idx - monoq[0] >= k: monoq.popleft()```\\n6. when ```dp[i]``` is greater than or equals to the top value, remove value from the top to keep the decreasing order -> ```while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()```\\n7. if ```dp[i]``` is greater than 0, put into the queue -> ```if currentMaxSum[idx] > 0: monoq.append(idx)``` (only interested in subsequence sum is >0)\\n\\ntc: O(N) element in dp array pop from/ push into monotonic queue once,  sc:O(N)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        currentMaxSum, monoq, ans = [0]*len(nums), deque(), float(\\'-inf\\')\\n        peekTailOfQ, peekTopOfQ = lambda: currentMaxSum[monoq[0]], lambda: currentMaxSum[monoq[-1]]\\n        for idx, n in enumerate(nums):\\n            currentMaxSum[idx] = n\\n            if monoq: currentMaxSum[idx] += peekTailOfQ()\\n            ans = max(ans, currentMaxSum[idx])\\n            if monoq and idx - monoq[0] >= k: monoq.popleft()\\n            while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()\\n            if currentMaxSum[idx] > 0: monoq.append(idx)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```i```\n```nums[i]```\n```dp[i] = max(nums[i], {dp[i-j] + nums[i], j in [1, k], if i-j >= 0})```\n```dp[i]```\n```nums[i]```\n```currentMaxSum[idx] = n```\n```dp[i] = nums[i] + max({dp[i-j] + nums[i], j in [1, k], if i-j >= 0}))```\n```if monoq: currentMaxSum[idx] += peekTailOfQ()```\n```ans = max(ans, currentMaxSum[idx])```\n```dp[i+1]```\n```if monoq and idx - monoq[0] >= k: monoq.popleft()```\n```dp[i]```\n```while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()```\n```dp[i]```\n```if currentMaxSum[idx] > 0: monoq.append(idx)```\n```\\nfrom collections import deque\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        currentMaxSum, monoq, ans = [0]*len(nums), deque(), float(\\'-inf\\')\\n        peekTailOfQ, peekTopOfQ = lambda: currentMaxSum[monoq[0]], lambda: currentMaxSum[monoq[-1]]\\n        for idx, n in enumerate(nums):\\n            currentMaxSum[idx] = n\\n            if monoq: currentMaxSum[idx] += peekTailOfQ()\\n            ans = max(ans, currentMaxSum[idx])\\n            if monoq and idx - monoq[0] >= k: monoq.popleft()\\n            while monoq and currentMaxSum[idx] >= peekTopOfQ(): monoq.pop()\\n            if currentMaxSum[idx] > 0: monoq.append(idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154322,
                "title": "c-o-nlogk-solution-using-set-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<pair<int,int>> st;\\n        \\n        vector<int> maxPreSum=nums;\\n        \\n        int maxSum=nums[0], start=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                maxPreSum[i]=nums[i];\\n            }\\n            else\\n            {\\n                auto it = st.end();\\n                it--;\\n                \\n                pair<int,int> x = *it;\\n                \\n                maxPreSum[i]=max(maxPreSum[i],nums[i]+x.first);   \\n            }\\n            \\n            st.insert({maxPreSum[i],i});\\n            maxSum=max(maxPreSum[i],maxSum);\\n            \\n            if(st.size()>k)\\n            {\\n                int index = start, val = maxPreSum[start];\\n                start++;\\n                \\n                st.erase({val,index});\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<pair<int,int>> st;\\n        \\n        vector<int> maxPreSum=nums;\\n        \\n        int maxSum=nums[0], start=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty())\\n            {\\n                maxPreSum[i]=nums[i];\\n            }\\n            else\\n            {\\n                auto it = st.end();\\n                it--;\\n                \\n                pair<int,int> x = *it;\\n                \\n                maxPreSum[i]=max(maxPreSum[i],nums[i]+x.first);   \\n            }\\n            \\n            st.insert({maxPreSum[i],i});\\n            maxSum=max(maxPreSum[i],maxSum);\\n            \\n            if(st.size()>k)\\n            {\\n                int index = start, val = maxPreSum[start];\\n                start++;\\n                \\n                st.erase({val,index});\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115333,
                "title": "monotonic-deque",
                "content": "```cpp\\ntypedef int ll;\\n\\nconst ll INF = 0x3f3f3f3f;\\n\\nstruct dq {\\n    ll st = 0;\\n    ll ed = -1;\\n    pair<ll, ll> arr[100001];\\n    \\n    inline bool empty() {\\n        return st > ed;\\n    }\\n    \\n    inline void popf() {\\n        st ++;\\n    }\\n    \\n    inline void popb() {\\n        ed --;\\n    }\\n    \\n    inline void pushb(ll f, ll s) {\\n        arr[++ed] ={f, s};\\n    }\\n    \\n    inline pair<ll, ll> &front() {\\n        return arr[st];\\n    }\\n    \\n    inline pair<ll, ll> &back() {\\n        return arr[ed];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        ll N = nums.size();\\n        \\n        dq q;\\n        q.pushb(0, 0);\\n        \\n        ll ans = -INF;\\n        \\n        for (ll i = 1, v; i <= N; i ++) {\\n            while (!q.empty() && i - q.front().first > k) {\\n                q.popf();\\n            }\\n            v = max(q.front().second + nums[i-1], nums[i-1]);\\n            ans = max(ans, v);\\n            while (!q.empty() && v >= q.back().second) {\\n                q.popb();\\n            }\\n            q.pushb(i, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Monotonic Queue"
                ],
                "code": "```cpp\\ntypedef int ll;\\n\\nconst ll INF = 0x3f3f3f3f;\\n\\nstruct dq {\\n    ll st = 0;\\n    ll ed = -1;\\n    pair<ll, ll> arr[100001];\\n    \\n    inline bool empty() {\\n        return st > ed;\\n    }\\n    \\n    inline void popf() {\\n        st ++;\\n    }\\n    \\n    inline void popb() {\\n        ed --;\\n    }\\n    \\n    inline void pushb(ll f, ll s) {\\n        arr[++ed] ={f, s};\\n    }\\n    \\n    inline pair<ll, ll> &front() {\\n        return arr[st];\\n    }\\n    \\n    inline pair<ll, ll> &back() {\\n        return arr[ed];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        ll N = nums.size();\\n        \\n        dq q;\\n        q.pushb(0, 0);\\n        \\n        ll ans = -INF;\\n        \\n        for (ll i = 1, v; i <= N; i ++) {\\n            while (!q.empty() && i - q.front().first > k) {\\n                q.popf();\\n            }\\n            v = max(q.front().second + nums[i-1], nums[i-1]);\\n            ans = max(ans, v);\\n            while (!q.empty() && v >= q.back().second) {\\n                q.popb();\\n            }\\n            q.pushb(i, v);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081470,
                "title": "java-dp-monotonic-deque-compare-with-two-solutions",
                "content": "1. Index in the monotinic increasing Deque\\nThe first solution is that we add our index to the monotonic index increasing deque, if the distance between i and the smallest index in deque is greater than k, we remove the smallest index out of the deque. In this way, we can make sure that the deque\\'s length will always under k. Besides, we also remove the value which absolutely would not be the biggest subset sum in the deque by removing the last index in the deque that is smaller than current dp value.\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(0);\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        for(int i = 1; i < n; i++){\\n            dp[i] = Math.max(dp[i], nums[i] + dp[window.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while(!window.isEmpty() && i - window.peekFirst() + 1 > k) window.pollFirst();\\n            while(!window.isEmpty() && dp[window.peekLast()] <= dp[i]) window.pollLast();\\n            window.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```\\n2. DP value in the monotonic value decreasing Deque\\nThe second solution is that we add our dp value to the monotonic decreasing deque, if the window length is greater than k we remove the greatest value in the deque, in order to maintain the length of the deque. Besides, we also remove the smallest value in the deque which is smaller than the current dp value, so that we can have the possible biggest subset sum in the deque.\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i - k > 0 && window.peekFirst() == dp[i - k - 1]) window.pollFirst();\\n            dp[i] = Math.max(dp[i], nums[i] + window.peekFirst());\\n            while(!window.isEmpty() && window.peekLast() < dp[i]) window.pollLast();\\n            window.offerLast(dp[i]);\\n            res = Math.max(dp[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(0);\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        for(int i = 1; i < n; i++){\\n            dp[i] = Math.max(dp[i], nums[i] + dp[window.peek()]);\\n            res = Math.max(res, dp[i]);\\n            while(!window.isEmpty() && i - window.peekFirst() + 1 > k) window.pollFirst();\\n            while(!window.isEmpty() && dp[window.peekLast()] <= dp[i]) window.pollLast();\\n            window.offerLast(i);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        int res = nums[0];\\n        for(int i = 0; i < n; i++) dp[i] = nums[i];\\n        Deque<Integer> window = new LinkedList<>();\\n        window.offer(nums[0]);\\n        for(int i = 1; i < n; i++){\\n            if(i - k > 0 && window.peekFirst() == dp[i - k - 1]) window.pollFirst();\\n            dp[i] = Math.max(dp[i], nums[i] + window.peekFirst());\\n            while(!window.isEmpty() && window.peekLast() < dp[i]) window.pollLast();\\n            window.offerLast(dp[i]);\\n            res = Math.max(dp[i], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055188,
                "title": "c-short-deque-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), output = nums[0];\\n        deque<int> dp;\\n        for (int i = 1; i < n; ++i){\\n            while (!dp.empty() && nums[dp.back()] <= nums[i-1]){\\n                dp.pop_back();\\n            }\\n            if (nums[i - 1] > 0){\\n                dp.push_back(i-1);\\n            }\\n            if (!dp.empty()){\\n                nums[i] += nums[dp.front()];\\n                if (i - dp.front() >= k){\\n                    dp.pop_front();\\n                }\\n            }\\n            output = max(output,nums[i]);\\n        }\\n        return output; \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int n = nums.size(), output = nums[0];\\n        deque<int> dp;\\n        for (int i = 1; i < n; ++i){\\n            while (!dp.empty() && nums[dp.back()] <= nums[i-1]){\\n                dp.pop_back();\\n            }\\n            if (nums[i - 1] > 0){\\n                dp.push_back(i-1);\\n            }\\n            if (!dp.empty()){\\n                nums[i] += nums[dp.front()];\\n                if (i - dp.front() >= k){\\n                    dp.pop_front();\\n                }\\n            }\\n            output = max(output,nums[i]);\\n        }\\n        return output; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048733,
                "title": "python-monotonic-deque-solution-faster-than-99-11",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i in range(len(nums)) :\\n            nums[i] += q[0] if q else 0\\n            while q and q[-1] < nums[i] :\\n                q.pop()\\n            if nums[i] > 0 : q.append(nums[i]) \\n            if i >= k and q and q[0] == nums[i-k] :\\n                q.popleft()\\n            # print(nums)\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        q = deque()\\n        for i in range(len(nums)) :\\n            nums[i] += q[0] if q else 0\\n            while q and q[-1] < nums[i] :\\n                q.pop()\\n            if nums[i] > 0 : q.append(nums[i]) \\n            if i >= k and q and q[0] == nums[i-k] :\\n                q.popleft()\\n            # print(nums)\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031318,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int i, j, len = nums.size();\\n        deque<pair<int, int>> dq;\\n        int maxSum = INT_MIN;\\n        \\n        for(i = 0; i < len; i++){\\n            while(!dq.empty() && (i - dq.front().second > k || dq.front().first <= 0)){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                maxSum = max(maxSum, nums[i]);\\n                dq.push_back(make_pair(nums[i], i));\\n                continue;\\n            }\\n            \\n            j = dq.front().first + nums[i];            \\n            while(!dq.empty() && j >= dq.back().first){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(make_pair(j, i));\\n            maxSum = max(maxSum, j);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        int i, j, len = nums.size();\\n        deque<pair<int, int>> dq;\\n        int maxSum = INT_MIN;\\n        \\n        for(i = 0; i < len; i++){\\n            while(!dq.empty() && (i - dq.front().second > k || dq.front().first <= 0)){\\n                dq.pop_front();\\n            }\\n            \\n            if(dq.empty()){\\n                maxSum = max(maxSum, nums[i]);\\n                dq.push_back(make_pair(nums[i], i));\\n                continue;\\n            }\\n            \\n            j = dq.front().first + nums[i];            \\n            while(!dq.empty() && j >= dq.back().first){\\n                dq.pop_back();\\n            }\\n            \\n            dq.push_back(make_pair(j, i));\\n            maxSum = max(maxSum, j);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013384,
                "title": "85-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n       Deque<int[]>queue=new ArrayDeque<>();\\n       int res=Integer.MIN_VALUE;\\n       for(int i=0,j=0;i<nums.length;i++){\\n            while(!queue.isEmpty()&&i-queue.peek()[0]>k)queue.poll();\\n             int val=Math.max(nums[i],nums[i]+(queue.isEmpty() ? 0 : queue.peek()[1]));\\n            while(!queue.isEmpty()&&queue.peekLast()[1]<=val)queue.pollLast();\\n           queue.add(new int[]{i,val});\\n           res=Math.max(res,val);\\n        }\\n        return res;\\n    }\\n}\\n```\\nTime : O(n) linear time\\nSpace: O(k) linear\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int constrainedSubsetSum(int[] nums, int k) {\\n       Deque<int[]>queue=new ArrayDeque<>();\\n       int res=Integer.MIN_VALUE;\\n       for(int i=0,j=0;i<nums.length;i++){\\n            while(!queue.isEmpty()&&i-queue.peek()[0]>k)queue.poll();\\n             int val=Math.max(nums[i],nums[i]+(queue.isEmpty() ? 0 : queue.peek()[1]));\\n            while(!queue.isEmpty()&&queue.peekLast()[1]<=val)queue.pollLast();\\n           queue.add(new int[]{i,val});\\n           res=Math.max(res,val);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972549,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i == 0){\\n                ans = nums[i];  \\n                pq.push({ans, i});\\n            }\\n            else{\\n                if(pq.top().second < i-k){\\n                    while(pq.top().second < i-k)\\n                        pq.pop();\\n                }\\n                if(pq.top().first >= 0){\\n                    pair<int,int> a = pq.top();\\n                    a.first += nums[i];\\n                    a.second = i;\\n                    pq.push(a);\\n                    ans = max(ans, a.first);\\n                }\\n                else{\\n                    ans = max(ans, nums[i]);\\n                    pq.push({nums[i], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        priority_queue<pair<int,int>> pq;\\n        int ans = INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            if(i == 0){\\n                ans = nums[i];  \\n                pq.push({ans, i});\\n            }\\n            else{\\n                if(pq.top().second < i-k){\\n                    while(pq.top().second < i-k)\\n                        pq.pop();\\n                }\\n                if(pq.top().first >= 0){\\n                    pair<int,int> a = pq.top();\\n                    a.first += nums[i];\\n                    a.second = i;\\n                    pq.push(a);\\n                    ans = max(ans, a.first);\\n                }\\n                else{\\n                    ans = max(ans, nums[i]);\\n                    pq.push({nums[i], i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971951,
                "title": "python-deque",
                "content": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [n for n in nums]\\n        res = float(\\'-inf\\')\\n        #dq[0] is the maximum Subsequence Sum before i\\n        dq = collections.deque()\\n        for i in range(len(nums)):\\n            #only keep positive and avaible Subsequence Sum before i\\n            while dq and (dq[0] < i-k or dp[dq[0]] <=0):\\n                dq.popleft()\\n            if dq:\\n                dp[i] = dp[dq[0]] + nums[i] \\n            res = max(res,dp[i])\\n            #update dq to keep it non-decreasing from left to right\\n            while dq and dp[dq[-1]] < dp[i]:\\n                dq.pop()\\n            dq.append(i)    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        dp = [n for n in nums]\\n        res = float(\\'-inf\\')\\n        #dq[0] is the maximum Subsequence Sum before i\\n        dq = collections.deque()\\n        for i in range(len(nums)):\\n            #only keep positive and avaible Subsequence Sum before i\\n            while dq and (dq[0] < i-k or dp[dq[0]] <=0):\\n                dq.popleft()\\n            if dq:\\n                dp[i] = dp[dq[0]] + nums[i] \\n            res = max(res,dp[i])\\n            #update dq to keep it non-decreasing from left to right\\n            while dq and dp[dq[-1]] < dp[i]:\\n                dq.pop()\\n            dq.append(i)    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946350,
                "title": "c-decreasing-deque-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> q;\\n        vector<int> dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        q.push_back(0); int re = dp[0];\\n        for(int i = 1;i<nums.size();++i){\\n            while(!q.empty() && i-q.front()>k) q.pop_front();\\n            if(q.size()) dp[i] = nums[i]+dp[q.front()];\\n            dp[i] = max(nums[i],dp[i]);\\n            while(!q.empty() && dp[q.back()]<=dp[i]) q.pop_back();\\n            q.push_back(i);\\n            re = max(re,dp[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> q;\\n        vector<int> dp(nums.size(),INT_MIN);\\n        dp[0] = nums[0];\\n        q.push_back(0); int re = dp[0];\\n        for(int i = 1;i<nums.size();++i){\\n            while(!q.empty() && i-q.front()>k) q.pop_front();\\n            if(q.size()) dp[i] = nums[i]+dp[q.front()];\\n            dp[i] = max(nums[i],dp[i]);\\n            while(!q.empty() && dp[q.back()]<=dp[i]) q.pop_back();\\n            q.push_back(i);\\n            re = max(re,dp[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784484,
                "title": "python-o-n-dp-sliding-window-explained",
                "content": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        #consider\\n        #[5,-2,-1,-3,-1,-2,-3,4] and k = 3\\n        #[5,-2,-1,-3,-3,-3,4] and k = 3\\n        #[-1000,1,2,3,-1000] and k = 3\\n        \\n        #dp[i] stores max subsq starting from ith index\\n        #window keeps track of max subsq starting from next k elements\\n        \\n        n = len(nums)\\n        dp = [0]*n\\n        \\n        window = deque([[-1, n]])\\n        for i in range(n-1, -1, -1):\\n            #if next k subsq all lead to a negative val, no point combining with current element\\n            dp[i] = max(window[-1][0] + nums[i], nums[i])\\n            \\n            #element no longer belongs in window\\n            if window[-1][-1] - i >= k: window.pop()\\n            #no point keeping smaller subsq in window if latest is better\\n            while window and window[0][0] <= dp[i]: window.popleft()\\n            #include the latest subsq in the window\\n            window.appendleft([dp[i], i])\\n            \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\n    def constrainedSubsetSum(self, nums: List[int], k: int) -> int:\\n        #consider\\n        #[5,-2,-1,-3,-1,-2,-3,4] and k = 3\\n        #[5,-2,-1,-3,-3,-3,4] and k = 3\\n        #[-1000,1,2,3,-1000] and k = 3\\n        \\n        #dp[i] stores max subsq starting from ith index\\n        #window keeps track of max subsq starting from next k elements\\n        \\n        n = len(nums)\\n        dp = [0]*n\\n        \\n        window = deque([[-1, n]])\\n        for i in range(n-1, -1, -1):\\n            #if next k subsq all lead to a negative val, no point combining with current element\\n            dp[i] = max(window[-1][0] + nums[i], nums[i])\\n            \\n            #element no longer belongs in window\\n            if window[-1][-1] - i >= k: window.pop()\\n            #no point keeping smaller subsq in window if latest is better\\n            while window and window[0][0] <= dp[i]: window.popleft()\\n            #include the latest subsq in the window\\n            window.appendleft([dp[i], i])\\n            \\n        return max(dp)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1763690,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dq;\\n        int maxS = nums[0], aux;\\n        dq.push_back(make_pair(maxS, 0));\\n        pair<int, int> p;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            p = dq.front();\\n            if(i - p.second > k)\\n            {\\n                dq.pop_front();\\n                if(dq.empty())\\n                {\\n                    if(nums[i] > maxS)\\n                        maxS = nums[i];\\n                    dq.push_back(make_pair(nums[i], i));\\n                    continue;\\n                }\\n                else\\n                    p = dq.front();\\n            }\\n            aux = max(nums[i], p.first + nums[i]);\\n            if(aux > maxS)\\n                maxS = aux;\\n            \\n            while(!dq.empty() && aux > dq.back().first)\\n            {\\n                dq.pop_back();                \\n            }\\n            dq.push_back(make_pair(aux, i));\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<pair<int, int>> dq;\\n        int maxS = nums[0], aux;\\n        dq.push_back(make_pair(maxS, 0));\\n        pair<int, int> p;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            p = dq.front();\\n            if(i - p.second > k)\\n            {\\n                dq.pop_front();\\n                if(dq.empty())\\n                {\\n                    if(nums[i] > maxS)\\n                        maxS = nums[i];\\n                    dq.push_back(make_pair(nums[i], i));\\n                    continue;\\n                }\\n                else\\n                    p = dq.front();\\n            }\\n            aux = max(nums[i], p.first + nums[i]);\\n            if(aux > maxS)\\n                maxS = aux;\\n            \\n            while(!dq.empty() && aux > dq.back().first)\\n            {\\n                dq.pop_back();                \\n            }\\n            dq.push_back(make_pair(aux, i));\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752322,
                "title": "c-o-n-solution-with-a-maximum-queue",
                "content": "[Source](https://cp-algorithms.com/data_structures/stack_queue_modification.html) about minimum queue, for which the implementation is equivalent to maximum queue.\\n\\n```\\nclass Solution {\\npublic:    \\n    int DP[100010];    \\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> Q;\\n        Q.push_back(0);        \\n        int best = -INT_MAX;        \\n        int r = int(nums.size()) - 1;        \\n        for (int l = int(nums.size()) - 1; l >= 0; l--) {            \\n            DP[l] = nums[l] + max(0, Q.front());\\n            if (int(nums.size()) - l > k && Q.front() == DP[r--])           \\n                Q.pop_front();\\n            while (!Q.empty() && Q.back() < DP[l])\\n                Q.pop_back();\\n            Q.push_back(DP[l]);            \\n            best = max(best, DP[l]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n    int DP[100010];    \\n    \\n    int constrainedSubsetSum(vector<int>& nums, int k) {\\n        deque<int> Q;\\n        Q.push_back(0);        \\n        int best = -INT_MAX;        \\n        int r = int(nums.size()) - 1;        \\n        for (int l = int(nums.size()) - 1; l >= 0; l--) {            \\n            DP[l] = nums[l] + max(0, Q.front());\\n            if (int(nums.size()) - l > k && Q.front() == DP[r--])           \\n                Q.pop_front();\\n            while (!Q.empty() && Q.back() < DP[l])\\n                Q.pop_back();\\n            Q.push_back(DP[l]);            \\n            best = max(best, DP[l]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566602,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1889033,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1573673,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 2063532,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            },
            {
                "id": 1801886,
                "content": [
                    {
                        "username": "AaronHe7",
                        "content": "I\\'m having trouble understanding this because I\\'m used to consecutive meaning the difference between two numbers is one."
                    },
                    {
                        "username": "e8315402",
                        "content": "Although I haven't solved this yet, for those who have trouble understanding the question, I try my best to explain.\n\nThe question requires you to find a subsequence from a given array, whose sum should have a maximum sum.\n\nWhat is a subsequence? Meaning that you can remove any number from the array, or remove none of them, and then you can obtain a new array. This new array is called a subsequence.\nFor example, given an array [1,2,3], the subsequences could be [1, 2, 3] (remove no number), [2, 3] (remove 1), [1, 3] (remove 2), or [1] (remove 2 and 3).\n\nHowever, the subsequences you find from the array should obey a rule: for any two consecutive integers in a subsequence, the difference of their indexes `in the original array` should be less than or equal to k.\nFor example, given an array [1,2,3], k=1, the subsequence [1, 2, 3] is ok because each one has the diff 1 to their neighbors. But the subsequence [1, 3] is not ok because the index of int 1 is 0 and the index of int 3 is `2` and the diff is 2, which is over k.\n\nThe solution should find out what subsequence has a maximum sum. Hope the explanation above helps you."
                    },
                    {
                        "username": "rajeshtomar",
                        "content": "Maintain a sliding window of minimum elements(much like the sliding-window-maximum) problem which will give us the minimum of last k elements.\\n\\nThen, for each element:\\n1. if it\\'s +ve, just add it to the score. +ve element can only increase the score so take all of them.\\n2. if it\\'s -ve, get the minimum of this window and add that to the score.(minimum among last k elements including this one). This keeps the window moving.\\n\\nWill include code later.\\n"
                    },
                    {
                        "username": "Vmilica270",
                        "content": "I thought it would be easy, but then..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "In fact,it is easier than a typical hard.Only a variation of kadane"
                    },
                    {
                        "username": "summi_r",
                        "content": "Can anybody explain how output of below is 2?\\n\\nnums=[-1000,-2000,-3000,-4000,2], k=2\\n\\nExpected O/p: 2\\n\\nI am unable to understand this question completely...Please help !"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "That\\'s the maximum sum, for the subsequence [2], compared to the other subsequences in that array."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Orders in the Backlog",
        "question_content": "<p>You are given a 2D integer array <code>orders</code>, where each <code>orders[i] = [price<sub>i</sub>, amount<sub>i</sub>, orderType<sub>i</sub>]</code> denotes that <code>amount<sub>i</sub></code><sub> </sub>orders have been placed of type <code>orderType<sub>i</sub></code> at the price <code>price<sub>i</sub></code>. The <code>orderType<sub>i</sub></code> is:</p>\r\n\r\n<ul>\r\n\t<li><code>0</code> if it is a batch of <code>buy</code> orders, or</li>\r\n\t<li><code>1</code> if it is a batch of <code>sell</code> orders.</li>\r\n</ul>\r\n\r\n<p>Note that <code>orders[i]</code> represents a batch of <code>amount<sub>i</sub></code> independent orders with the same price and order type. All orders represented by <code>orders[i]</code> will be placed before all orders represented by <code>orders[i+1]</code> for all valid <code>i</code>.</p>\r\n\r\n<p>There is a <strong>backlog</strong> that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:</p>\r\n\r\n<ul>\r\n\t<li>If the order is a <code>buy</code> order, you look at the <code>sell</code> order with the <strong>smallest</strong> price in the backlog. If that <code>sell</code> order&#39;s price is <strong>smaller than or equal to</strong> the current <code>buy</code> order&#39;s price, they will match and be executed, and that <code>sell</code> order will be removed from the backlog. Else, the <code>buy</code> order is added to the backlog.</li>\r\n\t<li>Vice versa, if the order is a <code>sell</code> order, you look at the <code>buy</code> order with the <strong>largest</strong> price in the backlog. If that <code>buy</code> order&#39;s price is <strong>larger than or equal to</strong> the current <code>sell</code> order&#39;s price, they will match and be executed, and that <code>buy</code> order will be removed from the backlog. Else, the <code>sell</code> order is added to the backlog.</li>\r\n</ul>\r\n\r\n<p>Return <em>the total <strong>amount</strong> of orders in the backlog after placing all the orders from the input</em>. Since this number can be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/ex1.png\" style=\"width: 450px; height: 479px;\" />\r\n<pre>\r\n<strong>Input:</strong> orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]\r\n<strong>Output:</strong> 6\r\n<strong>Explanation:</strong> Here is what happens with the orders:\r\n- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.\r\n- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.\r\n- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.\r\n- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3<sup>rd</sup> order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4<sup>th</sup> order is added to the backlog.\r\nFinally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/11/ex2.png\" style=\"width: 450px; height: 584px;\" />\r\n<pre>\r\n<strong>Input:</strong> orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\r\n<strong>Output:</strong> 999999984\r\n<strong>Explanation:</strong> Here is what happens with the orders:\r\n- 10<sup>9</sup> orders of type sell with price 7 are placed. There are no buy orders, so the 10<sup>9</sup> orders are added to the backlog.\r\n- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.\r\n- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.\r\n- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.\r\nFinally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (10<sup>9</sup> + 7).\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= orders.length &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>orders[i].length == 3</code></li>\r\n\t<li><code>1 &lt;= price<sub>i</sub>, amount<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\r\n\t<li><code>orderType<sub>i</sub></code> is either <code>0</code> or <code>1</code>.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 1119992,
                "title": "java-c-python-priority-queue",
                "content": "# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] o : orders) {\\n            if (o[2] == 0)\\n                buy.offer(o);\\n            else\\n                sell.offer(o);\\n            while (!buy.isEmpty() && !sell.isEmpty() && sell.peek()[0] <= buy.peek()[0]) {\\n                int k = Math.min(buy.peek()[1], sell.peek()[1]);\\n                buy.peek()[1] -= k;\\n                sell.peek()[1] -= k;\\n                if (buy.peek()[1] == 0) buy.poll();\\n                if (sell.peek()[1] == 0) sell.poll();\\n            }\\n\\n        }\\n        int res = 0, mod = 1000000007;\\n        for (int[] o : sell)\\n            res = (res + o[1]) % mod;\\n        for (int[] o : buy)\\n            res = (res + o[1]) % mod;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>sell;\\n        for (auto& o : orders) {\\n            if (o[2] == 0)\\n                buy.push(o);\\n            else\\n                sell.push(o);\\n            while (buy.size() && sell.size() && sell.top()[0] <= buy.top()[0]) {\\n                int k = min(buy.top()[1], sell.top()[1]);\\n                vector<int> tmp = buy.top(); buy.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) buy.push(tmp);\\n\\n                tmp = sell.top(); sell.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) sell.push(tmp);\\n            }\\n\\n        }\\n        int res = 0, mod = 1e9 + 7;\\n        while (sell.size())\\n            res = (res + sell.top()[1]) % mod, sell.pop();\\n        while (buy.size())\\n            res = (res + buy.top()[1]) % mod, buy.pop();\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def getNumberOfBacklogOrders(self, orders):\\n        sell, buy = [], []\\n        for p, a, t in orders:\\n            if t == 0:\\n                heapq.heappush(buy, [-p, a])\\n            else:\\n                heapq.heappush(sell, [p, a])\\n            while sell and buy and sell[0][0] <= -buy[0][0]:\\n                k = min(buy[0][1], sell[0][1])\\n                buy[0][1] -= k\\n                sell[0][1] -= k\\n                if buy[0][1] == 0: heapq.heappop(buy)\\n                if sell[0][1] == 0: heapq.heappop(sell)\\n        return sum(a for p, a in buy + sell) % (10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] o : orders) {\\n            if (o[2] == 0)\\n                buy.offer(o);\\n            else\\n                sell.offer(o);\\n            while (!buy.isEmpty() && !sell.isEmpty() && sell.peek()[0] <= buy.peek()[0]) {\\n                int k = Math.min(buy.peek()[1], sell.peek()[1]);\\n                buy.peek()[1] -= k;\\n                sell.peek()[1] -= k;\\n                if (buy.peek()[1] == 0) buy.poll();\\n                if (sell.peek()[1] == 0) sell.poll();\\n            }\\n\\n        }\\n        int res = 0, mod = 1000000007;\\n        for (int[] o : sell)\\n            res = (res + o[1]) % mod;\\n        for (int[] o : buy)\\n            res = (res + o[1]) % mod;\\n        return res;\\n    }\\n```\n```cpp\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>sell;\\n        for (auto& o : orders) {\\n            if (o[2] == 0)\\n                buy.push(o);\\n            else\\n                sell.push(o);\\n            while (buy.size() && sell.size() && sell.top()[0] <= buy.top()[0]) {\\n                int k = min(buy.top()[1], sell.top()[1]);\\n                vector<int> tmp = buy.top(); buy.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) buy.push(tmp);\\n\\n                tmp = sell.top(); sell.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) sell.push(tmp);\\n            }\\n\\n        }\\n        int res = 0, mod = 1e9 + 7;\\n        while (sell.size())\\n            res = (res + sell.top()[1]) % mod, sell.pop();\\n        while (buy.size())\\n            res = (res + buy.top()[1]) % mod, buy.pop();\\n        return res;\\n    }\\n```\n```py\\n    def getNumberOfBacklogOrders(self, orders):\\n        sell, buy = [], []\\n        for p, a, t in orders:\\n            if t == 0:\\n                heapq.heappush(buy, [-p, a])\\n            else:\\n                heapq.heappush(sell, [p, a])\\n            while sell and buy and sell[0][0] <= -buy[0][0]:\\n                k = min(buy[0][1], sell[0][1])\\n                buy[0][1] -= k\\n                sell[0][1] -= k\\n                if buy[0][1] == 0: heapq.heappop(buy)\\n                if sell[0][1] == 0: heapq.heappop(sell)\\n        return sum(a for p, a in buy + sell) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1119654,
                "title": "java-python-heap-solution",
                "content": "If you got WA, you might need to see the following requirements:\\n**If the order is a buy order, you look at the sell order with the smallest price in the backlog.**\\n**if the order is a sell order, you look at the buy order with the largest price in the backlog**\\n\\n**Please upvote for this if you find it is helpful!**\\n\\n**Java:**\\n\\n```\\n    public int getNumberOfBacklogOrders(int[][] orders) {        \\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] o : orders) {\\n            if (o[2] == 0) { // processing buy orders:\\n                    while (!sell.isEmpty() && o[0] >= sell.peek()[0] && o[1] >= sell.peek()[1]) {\\n                        o[1] -= sell.peek()[1];\\n                        sell.poll();\\n                    }\\n                    if (!sell.isEmpty() && o[0] >= sell.peek()[0] && o[1] > 0) {\\n                        sell.peek()[1] -= o[1];\\n                        o[1] = 0;\\n                    }\\n                    if (o[1] > 0) {\\n                        buy.offer(o);\\n                    }\\n            } else { // processing sell orders:\\n                    while (!buy.isEmpty() && o[0] <= buy.peek()[0] && o[1] >= buy.peek()[1]) {\\n                        o[1] -= buy.peek()[1];\\n                        buy.poll();\\n                    }\\n                    if (!buy.isEmpty() && o[0] <= buy.peek()[0] && o[1] > 0) {\\n                        buy.peek()[1] -= o[1];\\n                        o[1] = 0;\\n                    }\\n                    if (o[1] > 0) {\\n                        sell.offer(o);\\n                    }\\n                }                \\n        }\\n        long res = 0;\\n        for (int[] o : sell) {\\n            res += o[1];\\n        }\\n        for (int[] o : buy) {\\n            res += o[1];\\n        }\\n        return (int)(res % 1000000007);\\n    }\\n```\\n\\n**Python:**\\n\\n```\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy = []\\n        sell = []\\n        for price, amount, orderType in orders :\\n            if orderType == 0 :\\n                # buy\\n                while amount > 0 and len(sell) > 0 :\\n                    pt = sell[0]\\n                    if pt[0] > price :\\n                        break\\n                    deal = min(amount, pt[1])\\n                    amount -= deal\\n                    pt[1] -= deal\\n                    if pt[1] == 0 :\\n                        heapq.heappop(sell)\\n                if amount > 0 :\\n                    heapq.heappush(buy, [-price, amount])\\n            else :\\n                # sell\\n                while amount > 0 and len(buy) > 0 :\\n                    pt = buy[0]\\n                    if -pt[0] < price :\\n                        break\\n                    deal = min(amount, pt[1])\\n                    amount -= deal\\n                    pt[1] -= deal\\n                    if pt[1] == 0 :\\n                        heapq.heappop(buy)\\n                if amount > 0 :\\n                    heapq.heappush(sell, [price, amount])\\n        res = sum([t[1] for t in buy]) + sum([t[1] for t in sell])\\n        return res % (10**9+7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int getNumberOfBacklogOrders(int[][] orders) {        \\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> (b[0] - a[0]));\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> (a[0] - b[0]));\\n        for (int[] o : orders) {\\n            if (o[2] == 0) { // processing buy orders:\\n                    while (!sell.isEmpty() && o[0] >= sell.peek()[0] && o[1] >= sell.peek()[1]) {\\n                        o[1] -= sell.peek()[1];\\n                        sell.poll();\\n                    }\\n                    if (!sell.isEmpty() && o[0] >= sell.peek()[0] && o[1] > 0) {\\n                        sell.peek()[1] -= o[1];\\n                        o[1] = 0;\\n                    }\\n                    if (o[1] > 0) {\\n                        buy.offer(o);\\n                    }\\n            } else { // processing sell orders:\\n                    while (!buy.isEmpty() && o[0] <= buy.peek()[0] && o[1] >= buy.peek()[1]) {\\n                        o[1] -= buy.peek()[1];\\n                        buy.poll();\\n                    }\\n                    if (!buy.isEmpty() && o[0] <= buy.peek()[0] && o[1] > 0) {\\n                        buy.peek()[1] -= o[1];\\n                        o[1] = 0;\\n                    }\\n                    if (o[1] > 0) {\\n                        sell.offer(o);\\n                    }\\n                }                \\n        }\\n        long res = 0;\\n        for (int[] o : sell) {\\n            res += o[1];\\n        }\\n        for (int[] o : buy) {\\n            res += o[1];\\n        }\\n        return (int)(res % 1000000007);\\n    }\\n```\n```\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy = []\\n        sell = []\\n        for price, amount, orderType in orders :\\n            if orderType == 0 :\\n                # buy\\n                while amount > 0 and len(sell) > 0 :\\n                    pt = sell[0]\\n                    if pt[0] > price :\\n                        break\\n                    deal = min(amount, pt[1])\\n                    amount -= deal\\n                    pt[1] -= deal\\n                    if pt[1] == 0 :\\n                        heapq.heappop(sell)\\n                if amount > 0 :\\n                    heapq.heappush(buy, [-price, amount])\\n            else :\\n                # sell\\n                while amount > 0 and len(buy) > 0 :\\n                    pt = buy[0]\\n                    if -pt[0] < price :\\n                        break\\n                    deal = min(amount, pt[1])\\n                    amount -= deal\\n                    pt[1] -= deal\\n                    if pt[1] == 0 :\\n                        heapq.heappop(buy)\\n                if amount > 0 :\\n                    heapq.heappush(sell, [price, amount])\\n        res = sum([t[1] for t in buy]) + sum([t[1] for t in sell])\\n        return res % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1122438,
                "title": "c-2-heaps",
                "content": "A practical problem on how to process [level 2 quotes](https://stockstotrade.com/understanding-level-2-quotes-infographic/). It took me a while to implement during the contest.\\n\\nWe can use min (for sell) and max (for buy) heaps.  Note that we do not process an order right away, but just put it into one of the heaps. Then, we just fulfill orders while we can, pulling them from the heads of our heaps.\\n\\nThe intuition here is that, if there are existing orders in the heaps, those are orders that we could not process before.\\n\\n**C++**\\nNote that we are pushing negative prices to `sell` to turn in from max heap to min heap.\\n\\n```cpp\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n    priority_queue<array<int, 2>> buy, sell;\\n    long res = 0;\\n    for (auto &o : orders) {\\n        res += o[1];\\n        if (o[2])\\n            sell.push({-o[0], o[1]});\\n        else\\n            buy.push({o[0], o[1]});\\n        while (!sell.empty() && !buy.empty() && -sell.top()[0] <= buy.top()[0]) {\\n            auto [sell_p, sell_a] = sell.top(); sell.pop();\\n            auto [buy_p, buy_a] = buy.top(); buy.pop();\\n            auto execute = min(sell_a, buy_a);\\n            res -= 2 * execute;\\n            if (sell_a > execute)\\n                sell.push({sell_p, sell_a - execute});\\n            if (buy_a > execute)\\n                buy.push({buy_p, buy_a - execute});   \\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n    priority_queue<array<int, 2>> buy, sell;\\n    long res = 0;\\n    for (auto &o : orders) {\\n        res += o[1];\\n        if (o[2])\\n            sell.push({-o[0], o[1]});\\n        else\\n            buy.push({o[0], o[1]});\\n        while (!sell.empty() && !buy.empty() && -sell.top()[0] <= buy.top()[0]) {\\n            auto [sell_p, sell_a] = sell.top(); sell.pop();\\n            auto [buy_p, buy_a] = buy.top(); buy.pop();\\n            auto execute = min(sell_a, buy_a);\\n            res -= 2 * execute;\\n            if (sell_a > execute)\\n                sell.push({sell_p, sell_a - execute});\\n            if (buy_a > execute)\\n                buy.push({buy_p, buy_a - execute});   \\n        }\\n    }\\n    return res % 1000000007;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119728,
                "title": "c-solution-priority-queues-easy-to-implement-beats-100",
                "content": "we initialise two priority queues, one of buy and other sell, after that we iterate through the orders, \\nfor every order , we have two choices:\\n-> ordertype is `0-buy`, here we check three cases,\\n* \\t\\tif sell.size() ==0, we just push our current order into buy\\n* \\t\\tif sell.top()[0] > p , that means smallest price of sell is greater that current price of buy, so we push into buy\\n* \\t\\tif number of order n>0\\nSame with the case of ordertype 1,  \\n\\nFinally, we count the number of orders left in both `buy` and `sell`\\n\\n**Please Upvote** if you find it helpful.\\n\\n```\\n  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>sell;\\n        for(vector<int>temp : orders){\\n            int p=temp[0], n = temp[1], t = temp[2];\\n            if(t==0){\\n                while(sell.size() && sell.top()[0] <= p && n){\\n                    vector<int>cur = sell.top();\\n                    if(cur[1] > n){\\n                        cur[1] -= n;\\n                        sell.pop();\\n                        sell.push(cur);\\n                        n=0;\\n                    }else{\\n                        n -= cur[1];\\n                        sell.pop();\\n                    }\\n                }\\n                if(n) buy.push({p,n,t});\\n            }\\n            else{\\n                while(buy.size() && buy.top()[0]>=p && n){\\n                vector<int>cur = buy.top();\\n                     if(cur[1] > n){\\n                        cur[1] -= n;\\n                        buy.pop();\\n                        buy.push(cur);\\n                        n=0;\\n                    }else{\\n                        n -= cur[1];\\n                        buy.pop();\\n                    }\\n                }\\n                if(n) sell.push({p,n,t});\\n            }\\n        }  \\n        long long int res=0;\\n        while(buy.size()>0){\\n            res += buy.top()[1];\\n            buy.pop();\\n        }\\n        while(sell.size()>0){\\n            res += sell.top()[1];\\n            sell.pop();\\n        }\\n        return res%1000000007;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>sell;\\n        for(vector<int>temp : orders){\\n            int p=temp[0], n = temp[1], t = temp[2];\\n            if(t==0){\\n                while(sell.size() && sell.top()[0] <= p && n){\\n                    vector<int>cur = sell.top();\\n                    if(cur[1] > n){\\n                        cur[1] -= n;\\n                        sell.pop();\\n                        sell.push(cur);\\n                        n=0;\\n                    }else{\\n                        n -= cur[1];\\n                        sell.pop();\\n                    }\\n                }\\n                if(n) buy.push({p,n,t});\\n            }\\n            else{\\n                while(buy.size() && buy.top()[0]>=p && n){\\n                vector<int>cur = buy.top();\\n                     if(cur[1] > n){\\n                        cur[1] -= n;\\n                        buy.pop();\\n                        buy.push(cur);\\n                        n=0;\\n                    }else{\\n                        n -= cur[1];\\n                        buy.pop();\\n                    }\\n                }\\n                if(n) sell.push({p,n,t});\\n            }\\n        }  \\n        long long int res=0;\\n        while(buy.size()>0){\\n            res += buy.top()[1];\\n            buy.pop();\\n        }\\n        while(sell.size()>0){\\n            res += sell.top()[1];\\n            sell.pop();\\n        }\\n        return res%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119714,
                "title": "heap-pq-solution-with-logic-python",
                "content": "Logic is:\\n* Since we need to do a lot of **find min/max** operations: use 2 heaps:\\n\\t* max-heap `b` for buy, min-heap `s` for sell\\n\\t* So, max buy offer is on top of heap `b`\\n\\t* Min sell offer is on top of heap `s`\\n* Each element of heap is an array: `[price, amount]`\\n* *For* each buy/sell order:\\n\\t* Check for the **good** condition\\n\\t\\t* Good condition is when:\\n\\t\\t\\t* Both `b` and `s` are non-empty\\n\\t\\t\\t* Top elements satisfy: `s[0][0] <= -b[0][0]` - means `sell price <= buy price`\\n\\t\\t\\t* If **good** condition is true: a *sale* will definitely happen\\n\\t* *While* condition stays **good**, keep performing *sales*\\n\\t\\t* A *sale* means:\\n\\t\\t\\t* Pick the top element of both heaps\\n\\t\\t\\t* Call their amounts `a1` and `a2`\\n\\t\\t\\t* Reduce `a1` and `a2` until one of them becomes `0`\\n\\t\\t\\t* If either `a1` or `a2` becomes `0`, pop the heap to which it belongs\\n\\t\\t* Check if the new top of the heap satisfies **good** condition\\n* Count the sum of amounts in each heap\\n\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        b, s = [], []\\n        heapq.heapify(b)\\n        heapq.heapify(s)\\n        \\n        for p,a,o in orders:\\n            if o == 0:\\n                heapq.heappush(b, [-p, a])\\n                \\n            elif o == 1:\\n                heapq.heappush(s, [p, a])\\n            \\n            # Check \"good\" condition\\n            while s and b and s[0][0] <= -b[0][0]:\\n                a1, a2 = b[0][1], s[0][1]\\n                \\n                if a1 > a2:\\n                    b[0][1] -= a2\\n                    heapq.heappop(s)\\n                elif a1 < a2:\\n                    s[0][1] -= a1\\n                    heapq.heappop(b)\\n                else:\\n                    heapq.heappop(b)\\n                    heapq.heappop(s)\\n                    \\n        count = sum([a for p,a in b]) + sum([a for p,a in s])\\n        return count % (10**9 + 7)\\n ```               \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        b, s = [], []\\n        heapq.heapify(b)\\n        heapq.heapify(s)\\n        \\n        for p,a,o in orders:\\n            if o == 0:\\n                heapq.heappush(b, [-p, a])\\n                \\n            elif o == 1:\\n                heapq.heappush(s, [p, a])\\n            \\n            # Check \"good\" condition\\n            while s and b and s[0][0] <= -b[0][0]:\\n                a1, a2 = b[0][1], s[0][1]\\n                \\n                if a1 > a2:\\n                    b[0][1] -= a2\\n                    heapq.heappop(s)\\n                elif a1 < a2:\\n                    s[0][1] -= a1\\n                    heapq.heappop(b)\\n                else:\\n                    heapq.heappop(b)\\n                    heapq.heappop(s)\\n                    \\n        count = sum([a for p,a in b]) + sum([a for p,a in s])\\n        return count % (10**9 + 7)\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1119692,
                "title": "python3-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ans = 0\\n        buy, sell = [], [] # max-heap & min-heap \\n        \\n        for p, q, t in orders: \\n            ans += q\\n            if t: # sell order\\n                while q and buy and -buy[0][0] >= p: # match \\n                    pb, qb = heappop(buy)\\n                    ans -= 2*min(q, qb)\\n                    if q < qb: \\n                        heappush(buy, (pb, qb-q))\\n                        q = 0 \\n                    else: q -= qb \\n                if q: heappush(sell, (p, q))\\n            else: # buy order \\n                while q and sell and sell[0][0] <= p: # match \\n                    ps, qs = heappop(sell)\\n                    ans -= 2*min(q, qs)\\n                    if q < qs: \\n                        heappush(sell, (ps, qs-q))\\n                        q = 0 \\n                    else: q -= qs \\n                if q: heappush(buy, (-p, q))\\n            \\n        return ans % 1_000_000_007\\n```\\n\\nA conciser implementation by @lee215\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], [] # max-heap & min-heap \\n        for p, q, t in orders: \\n            if t: heappush(sell, [p, q])\\n            else: heappush(buy, [-p, q])\\n            \\n            while buy and sell and -buy[0][0] >= sell[0][0]: \\n                qty = min(buy[0][1], sell[0][1])\\n                buy[0][1] -= qty\\n                sell[0][1] -= qty\\n                if not buy[0][1]: heappop(buy)\\n                if not sell[0][1]: heappop(sell)\\n        return (sum(q for _, q in sell) + sum(q for _, q in buy)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        ans = 0\\n        buy, sell = [], [] # max-heap & min-heap \\n        \\n        for p, q, t in orders: \\n            ans += q\\n            if t: # sell order\\n                while q and buy and -buy[0][0] >= p: # match \\n                    pb, qb = heappop(buy)\\n                    ans -= 2*min(q, qb)\\n                    if q < qb: \\n                        heappush(buy, (pb, qb-q))\\n                        q = 0 \\n                    else: q -= qb \\n                if q: heappush(sell, (p, q))\\n            else: # buy order \\n                while q and sell and sell[0][0] <= p: # match \\n                    ps, qs = heappop(sell)\\n                    ans -= 2*min(q, qs)\\n                    if q < qs: \\n                        heappush(sell, (ps, qs-q))\\n                        q = 0 \\n                    else: q -= qs \\n                if q: heappush(buy, (-p, q))\\n            \\n        return ans % 1_000_000_007\\n```\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], [] # max-heap & min-heap \\n        for p, q, t in orders: \\n            if t: heappush(sell, [p, q])\\n            else: heappush(buy, [-p, q])\\n            \\n            while buy and sell and -buy[0][0] >= sell[0][0]: \\n                qty = min(buy[0][1], sell[0][1])\\n                buy[0][1] -= qty\\n                sell[0][1] -= qty\\n                if not buy[0][1]: heappop(buy)\\n                if not sell[0][1]: heappop(sell)\\n        return (sum(q for _, q in sell) + sum(q for _, q in buy)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975718,
                "title": "python-concise-heap-implementation",
                "content": "### Introduction\\n\\nWe need to find the total amount of orders that remain un-executed in the backlog of orders after a series of buy and sell orders have passed. A buy order is executed if there exists a sell order in the backlog that has a selling price lower than or equal to the buying price, and a sell order is executed if there exists a buy order in the backlog that has a buying price greater than or equal to the selling price. Each time a buy/sell order comes, we need to compare its price with the sell/buy order with the smallest/greatest price, respectively.\\n\\nSince we need to obtain the smallest/greatest prices per order, a heap (priority queue) data structure is ideal for this task. For the buy order log, we require a max heap to obtain the greatest buying price; for the sell order log, we require a min heap to obtain the smallest buying price. Note that Python\\'s `heapq` library implements a min heap, hence, to maintain a max heap, we need to **negate the buying prices**.\\n\\nTherefore, each time a buy/sell order with a given buying/selling price and the amount of orders is processed, we retrieve the sell/buy order with the smallest/largest price and execute the orders if the criteria (as mentioned above) is met. We continue to retrieve the sell/buy orders until;\\n\\n1. The criteria for executing the orders is no longer met.\\n2. There are no more orders in the backlog to execute.\\n3. There are no more orders in the current order to execute.\\n\\nAfter which, any remaining un-executed orders gets appended to its corresponding backlog.\\n\\n---\\n\\n### Base Implementation\\n\\nThis implementation features heavily on readability, and is meant to provide readers with a good understanding of how the code should work. If anything here is unclear or could be written better, please let me know in the comments.\\n\\n```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # note that: buy_log - max heap; sell_log - min heap\\n        buy_log, sell_log = [], []\\n        for price, amount, order_type in orders:\\n            target_log = buy_log if order_type else sell_log\\n            while amount and target_log:\\n                # check that the appropriate buy/sell order fits the criteria\\n                # if order type is sell, ensure buy order price >= current price\\n                # else if order type is buy, ensure sell order price <= current price\\n                if (order_type and abs(target_log[0][0]) < price) or \\\\\\n                        (not order_type and target_log[0][0] > price):\\n                    break\\n                current_price, current_amount = heappop(target_log)\\n                # cancel buy and sell orders\\n                min_amount = min(amount, current_amount)\\n                amount -= min_amount\\n                current_amount -= min_amount\\n                # check if there are remaining target orders\\n                if current_amount:\\n                    heappush(target_log, (current_price, current_amount))\\n            # check if there are remaining current orders\\n            if amount:\\n                heappush(sell_log if order_type else buy_log,\\n                         # negate price if order type is buy\\n                         # so as to maintain a max heap for buy orders\\n                         (price if order_type else -price, amount))\\n        return (sum(log_amount for _, log_amount in buy_log) + \\\\\\n                sum(log_amount for _, log_amount in sell_log))%int(1e9+7)\\n```\\n\\n---\\n\\n### Concise Implementation\\n\\nInstead of having two separate heaps to manage the buy and sell logs, we can combine them into one tuple and use the order type to access the proper logs. If implemented correctly, taking the different comparison operators / min/max heap into account, we can save a lot of lines because none of the code is repeated.\\n\\nThe following code has been revised for readability, as suggested by [@daBozz](https://leetcode.com/daBozz/).\\n\\n```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        backlog = ([], [])  # (buy (max-heap), sell (min-heap))\\n        for price, amount, order_type in orders:\\n            # check that the appropriate buy/sell order fits the criteria in the while loop\\n            # note that le, ge come from the Python operator library\\n            # equivalent to: le - lambda a, b: a <= b\\n            #                ge - lambda a, b: a >= b\\n            while amount > 0 and \\\\\\n                    (target_log := backlog[1-order_type]) and \\\\\\n                    (le, ge)[order_type](abs(target_log[0][0]), price):\\n                curr_price, curr_amount = heappop(target_log)\\n                if (amount := amount-curr_amount) < 0:  # there are remaining target orders\\n                    heappush(target_log, (curr_price, -amount))\\n            if amount > 0:  # there are remaining current orders\\n                heappush(backlog[order_type], (price if order_type else -price, amount))\\n        # note that itemgetter comes from the Python operator library\\n        # equivalent to: lambda t: t[1]\\n        return sum(sum(map(itemgetter(1), log)) for log in backlog)%int(1e9+7)\\n```\\n\\n**TC: O(nlogk)**, where `n` is the number of orders and `k` is the maximum length of either the buy or sell backlogs.\\n**SC: O(n)**, taking both backlogs into account.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # note that: buy_log - max heap; sell_log - min heap\\n        buy_log, sell_log = [], []\\n        for price, amount, order_type in orders:\\n            target_log = buy_log if order_type else sell_log\\n            while amount and target_log:\\n                # check that the appropriate buy/sell order fits the criteria\\n                # if order type is sell, ensure buy order price >= current price\\n                # else if order type is buy, ensure sell order price <= current price\\n                if (order_type and abs(target_log[0][0]) < price) or \\\\\\n                        (not order_type and target_log[0][0] > price):\\n                    break\\n                current_price, current_amount = heappop(target_log)\\n                # cancel buy and sell orders\\n                min_amount = min(amount, current_amount)\\n                amount -= min_amount\\n                current_amount -= min_amount\\n                # check if there are remaining target orders\\n                if current_amount:\\n                    heappush(target_log, (current_price, current_amount))\\n            # check if there are remaining current orders\\n            if amount:\\n                heappush(sell_log if order_type else buy_log,\\n                         # negate price if order type is buy\\n                         # so as to maintain a max heap for buy orders\\n                         (price if order_type else -price, amount))\\n        return (sum(log_amount for _, log_amount in buy_log) + \\\\\\n                sum(log_amount for _, log_amount in sell_log))%int(1e9+7)\\n```\n```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        backlog = ([], [])  # (buy (max-heap), sell (min-heap))\\n        for price, amount, order_type in orders:\\n            # check that the appropriate buy/sell order fits the criteria in the while loop\\n            # note that le, ge come from the Python operator library\\n            # equivalent to: le - lambda a, b: a <= b\\n            #                ge - lambda a, b: a >= b\\n            while amount > 0 and \\\\\\n                    (target_log := backlog[1-order_type]) and \\\\\\n                    (le, ge)[order_type](abs(target_log[0][0]), price):\\n                curr_price, curr_amount = heappop(target_log)\\n                if (amount := amount-curr_amount) < 0:  # there are remaining target orders\\n                    heappush(target_log, (curr_price, -amount))\\n            if amount > 0:  # there are remaining current orders\\n                heappush(backlog[order_type], (price if order_type else -price, amount))\\n        # note that itemgetter comes from the Python operator library\\n        # equivalent to: lambda t: t[1]\\n        return sum(sum(map(itemgetter(1), log)) for log in backlog)%int(1e9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1134286,
                "title": "java-simple-and-easy-solution-using-priority-queue-t-o-n-log-n-s-o-n-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    PriorityQueue<Order> buyBackLog;\\n    PriorityQueue<Order> sellBackLog;\\n    \\n    static int MOD = 1_000_000_007;\\n    \\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        //max heap, heapify on price\\n        buyBackLog = new PriorityQueue<Order>((a, b) -> (b.price - a.price));\\n        //min heap, heapify on price\\n        sellBackLog = new PriorityQueue<Order>((a, b) -> (a.price - b.price));\\n        \\n        \\n        //handle all order\\n        for(int[] order : orders){\\n            int price     = order[0];\\n            int quantity  = order[1];\\n            int orderType = order[2];\\n            \\n            if(orderType == 0){\\n                //buy order \\n                handleBuyOrder(new Order(price, quantity));\\n                \\n            }else if(orderType == 1){ \\n                //sell order\\n                handleSellOrder(new Order(price, quantity));\\n            }\\n        }\\n        \\n        long counts = 0L;\\n        \\n        //count buy backlog\\n        while(!buyBackLog.isEmpty()){\\n            counts += buyBackLog.remove().quantity; \\n            counts %= MOD;\\n        }\\n        \\n        //count sell backlog\\n        while(!sellBackLog.isEmpty()){\\n            counts += sellBackLog.remove().quantity; \\n            counts %= MOD;\\n        }\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n    \\n    \\n    \\n    \\n    private void handleBuyOrder(Order buyOrder){\\n        //just add buyorder, if there is no sell back log\\n        if(sellBackLog.isEmpty()){\\n            buyBackLog.add(buyOrder);\\n            return;\\n        }\\n        \\n        \\n        while(!sellBackLog.isEmpty() && buyOrder.price >= sellBackLog.peek().price && buyOrder.quantity > 0){\\n            //selloder with minumum price\\n            Order sellOrder = sellBackLog.remove();\\n            \\n            if(buyOrder.quantity >= sellOrder.quantity){\\n                buyOrder.quantity -= sellOrder.quantity;\\n                sellOrder.quantity = 0;\\n            } else {\\n                //decrement sell order, add remaining sellorder\\n                sellOrder.quantity -= buyOrder.quantity;\\n                sellBackLog.add(sellOrder);\\n                \\n                buyOrder.quantity = 0;\\n            }\\n        }\\n        \\n        //add reaming buyorder\\n        if(buyOrder.quantity > 0){\\n            buyBackLog.add(buyOrder);\\n        }\\n    }\\n    \\n    \\n    private void handleSellOrder(Order sellOrder){\\n        //just add sell order, if there is no buy backlog\\n        if(buyBackLog.isEmpty()){\\n            sellBackLog.add(sellOrder);\\n            return;\\n        }\\n        \\n        \\n        while(!buyBackLog.isEmpty() && buyBackLog.peek().price >= sellOrder.price && sellOrder.quantity > 0){\\n            //buy order with maximum price\\n            Order buyOrder = buyBackLog.remove();\\n            \\n            if(sellOrder.quantity >= buyOrder.quantity){\\n                sellOrder.quantity -= buyOrder.quantity;\\n                buyOrder.quantity = 0;\\n                \\n            }else{\\n                //decrement buy order quantity, add remaining buyorder\\n                buyOrder.quantity -= sellOrder.quantity;\\n                buyBackLog.add(buyOrder);\\n                \\n                sellOrder.quantity = 0;\\n            }\\n        }\\n        \\n        //add remaining sell order\\n        if(sellOrder.quantity > 0){\\n            sellBackLog.add(sellOrder);\\n        }\\n    }\\n}\\n\\nclass Order{\\n    int price;\\n    int quantity;\\n    \\n    public Order(int price, int quantity){\\n        this.price = price;\\n        this.quantity = quantity;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Order> buyBackLog;\\n    PriorityQueue<Order> sellBackLog;\\n    \\n    static int MOD = 1_000_000_007;\\n    \\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        //max heap, heapify on price\\n        buyBackLog = new PriorityQueue<Order>((a, b) -> (b.price - a.price));\\n        //min heap, heapify on price\\n        sellBackLog = new PriorityQueue<Order>((a, b) -> (a.price - b.price));\\n        \\n        \\n        //handle all order\\n        for(int[] order : orders){\\n            int price     = order[0];\\n            int quantity  = order[1];\\n            int orderType = order[2];\\n            \\n            if(orderType == 0){\\n                //buy order \\n                handleBuyOrder(new Order(price, quantity));\\n                \\n            }else if(orderType == 1){ \\n                //sell order\\n                handleSellOrder(new Order(price, quantity));\\n            }\\n        }\\n        \\n        long counts = 0L;\\n        \\n        //count buy backlog\\n        while(!buyBackLog.isEmpty()){\\n            counts += buyBackLog.remove().quantity; \\n            counts %= MOD;\\n        }\\n        \\n        //count sell backlog\\n        while(!sellBackLog.isEmpty()){\\n            counts += sellBackLog.remove().quantity; \\n            counts %= MOD;\\n        }\\n        \\n        \\n        return (int) (counts % MOD);\\n    }\\n    \\n    \\n    \\n    \\n    private void handleBuyOrder(Order buyOrder){\\n        //just add buyorder, if there is no sell back log\\n        if(sellBackLog.isEmpty()){\\n            buyBackLog.add(buyOrder);\\n            return;\\n        }\\n        \\n        \\n        while(!sellBackLog.isEmpty() && buyOrder.price >= sellBackLog.peek().price && buyOrder.quantity > 0){\\n            //selloder with minumum price\\n            Order sellOrder = sellBackLog.remove();\\n            \\n            if(buyOrder.quantity >= sellOrder.quantity){\\n                buyOrder.quantity -= sellOrder.quantity;\\n                sellOrder.quantity = 0;\\n            } else {\\n                //decrement sell order, add remaining sellorder\\n                sellOrder.quantity -= buyOrder.quantity;\\n                sellBackLog.add(sellOrder);\\n                \\n                buyOrder.quantity = 0;\\n            }\\n        }\\n        \\n        //add reaming buyorder\\n        if(buyOrder.quantity > 0){\\n            buyBackLog.add(buyOrder);\\n        }\\n    }\\n    \\n    \\n    private void handleSellOrder(Order sellOrder){\\n        //just add sell order, if there is no buy backlog\\n        if(buyBackLog.isEmpty()){\\n            sellBackLog.add(sellOrder);\\n            return;\\n        }\\n        \\n        \\n        while(!buyBackLog.isEmpty() && buyBackLog.peek().price >= sellOrder.price && sellOrder.quantity > 0){\\n            //buy order with maximum price\\n            Order buyOrder = buyBackLog.remove();\\n            \\n            if(sellOrder.quantity >= buyOrder.quantity){\\n                sellOrder.quantity -= buyOrder.quantity;\\n                buyOrder.quantity = 0;\\n                \\n            }else{\\n                //decrement buy order quantity, add remaining buyorder\\n                buyOrder.quantity -= sellOrder.quantity;\\n                buyBackLog.add(buyOrder);\\n                \\n                sellOrder.quantity = 0;\\n            }\\n        }\\n        \\n        //add remaining sell order\\n        if(sellOrder.quantity > 0){\\n            sellBackLog.add(sellOrder);\\n        }\\n    }\\n}\\n\\nclass Order{\\n    int price;\\n    int quantity;\\n    \\n    public Order(int price, int quantity){\\n        this.price = price;\\n        this.quantity = quantity;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994427,
                "title": "python-3-9-lines-w-explanation-t-m-89-49",
                "content": "Here\\'s the plan:\\n1. Establish maxheap `buy` for buy orders and minheap `sell` for sell orders.\\n2. Iterate through `orders`. Push each element onto the appropriate heap.\\n3. During each iteration, peak at the heads of each list and determine whether they allow a transaction. If so, pop both heads, and if one has a positive amount after the transaction, push it back on its heap, and check the new heads (lather, rinse, repeat... `while`)\\n4. After the iteration,`return`the sum of`amt`in the heaps.\\n\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\n        buy,sell  = [], []                                                              # <-- 1\\n\\n        for price,amt,order in orders:                                                  # <-- 2\\n            if order: heappush(sell, ( price, amt))                                     #\\n            else    : heappush(buy , (-price, amt))                                     #\\n            \\n            while buy and sell and -buy[0][0] >= sell[0][0]:                            # <-- 3\\n                                                                                        #\\n                (buyPrice,buyAmt), (sellPrice,sellAmt) = heappop(buy), heappop(sell)    #\\n                                                                                        #\\n                if   buyAmt > sellAmt: heappush(buy , (buyPrice , buyAmt -sellAmt))     #\\n                elif buyAmt < sellAmt: heappush(sell, (sellPrice, sellAmt- buyAmt))     #\\n\\n        return sum(amt for _,amt in buy+sell)% (1000000007)                             # <-- 4\\n```\\n[https://leetcode.com/problems/number-of-orders-in-the-backlog/submissions/870707453/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\n        buy,sell  = [], []                                                              # <-- 1\\n\\n        for price,amt,order in orders:                                                  # <-- 2\\n            if order: heappush(sell, ( price, amt))                                     #\\n            else    : heappush(buy , (-price, amt))                                     #\\n            \\n            while buy and sell and -buy[0][0] >= sell[0][0]:                            # <-- 3\\n                                                                                        #\\n                (buyPrice,buyAmt), (sellPrice,sellAmt) = heappop(buy), heappop(sell)    #\\n                                                                                        #\\n                if   buyAmt > sellAmt: heappush(buy , (buyPrice , buyAmt -sellAmt))     #\\n                elif buyAmt < sellAmt: heappush(sell, (sellPrice, sellAmt- buyAmt))     #\\n\\n        return sum(amt for _,amt in buy+sell)% (1000000007)                             # <-- 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224200,
                "title": "python-2-heaps-readable-code-with-dataclass",
                "content": "The readability of your code is as important as the correctness of your solution.\\n\\nWhenever possible, I like to convert input arrays into custom objects with readable field names.\\n\\n```Python\\nfrom enum import IntEnum\\nfrom dataclasses import dataclass, field\\n\\nclass oType(IntEnum):\\n    BUY = 0\\n    SELL = 1\\n\\n# Sort based on price. (Other fields not used in compare).\\n@dataclass(order = True)\\nclass Order:\\n    price: int\\n    amount: int = field(compare = False)\\n    orderType: oType = field(compare = False)\\n\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        orders = [Order(*o) for o in orders]\\n        \\n        buyHeap: Order = []\\n        sellHeap: Order = []\\n        \\n        for incomingOrder in orders:\\n            if incomingOrder.orderType == oType.BUY:\\n                while sellHeap and sellHeap[0].price <= incomingOrder.price:\\n                    sellOrder = heapq.heappop(sellHeap)\\n                    if sellOrder.amount < incomingOrder.amount:\\n                        incomingOrder.amount -= sellOrder.amount\\n                    elif sellOrder.amount == incomingOrder.amount:\\n                        incomingOrder.amount = 0\\n                        break\\n                    elif sellOrder.amount > incomingOrder.amount:\\n                        sellOrder.amount = sellOrder.amount - incomingOrder.amount\\n                        incomingOrder.amount = 0\\n                        heapq.heappush(sellHeap, sellOrder)\\n                        break\\n                if incomingOrder.amount > 0:\\n                    # negate for max heap\\n                    incomingOrder.price = -incomingOrder.price\\n                    heapq.heappush(buyHeap, incomingOrder)\\n            elif incomingOrder.orderType == oType.SELL:\\n                while buyHeap and -buyHeap[0].price >= incomingOrder.price:\\n                    buyOrder = heapq.heappop(buyHeap)\\n                    if buyOrder.amount < incomingOrder.amount:\\n                        incomingOrder.amount -= buyOrder.amount\\n                    elif buyOrder.amount == incomingOrder.amount:\\n                        incomingOrder.amount = 0\\n                        break\\n                    elif buyOrder.amount > incomingOrder.amount:\\n                        buyOrder.amount = buyOrder.amount - incomingOrder.amount\\n                        incomingOrder.amount = 0\\n                        heapq.heappush(buyHeap, buyOrder)\\n                        break\\n                if incomingOrder.amount > 0:\\n                    heapq.heappush(sellHeap, incomingOrder)\\n            \\n        buySum = sum([order.amount for order in buyHeap])\\n        sellSum = sum([order.amount for order in sellHeap])\\n        return (buySum + sellSum) % (10**9 + 7)\\n```\\n                    \\n                    \\n                        \\n",
                "solutionTags": [],
                "code": "```Python\\nfrom enum import IntEnum\\nfrom dataclasses import dataclass, field\\n\\nclass oType(IntEnum):\\n    BUY = 0\\n    SELL = 1\\n\\n# Sort based on price. (Other fields not used in compare).\\n@dataclass(order = True)\\nclass Order:\\n    price: int\\n    amount: int = field(compare = False)\\n    orderType: oType = field(compare = False)\\n\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        orders = [Order(*o) for o in orders]\\n        \\n        buyHeap: Order = []\\n        sellHeap: Order = []\\n        \\n        for incomingOrder in orders:\\n            if incomingOrder.orderType == oType.BUY:\\n                while sellHeap and sellHeap[0].price <= incomingOrder.price:\\n                    sellOrder = heapq.heappop(sellHeap)\\n                    if sellOrder.amount < incomingOrder.amount:\\n                        incomingOrder.amount -= sellOrder.amount\\n                    elif sellOrder.amount == incomingOrder.amount:\\n                        incomingOrder.amount = 0\\n                        break\\n                    elif sellOrder.amount > incomingOrder.amount:\\n                        sellOrder.amount = sellOrder.amount - incomingOrder.amount\\n                        incomingOrder.amount = 0\\n                        heapq.heappush(sellHeap, sellOrder)\\n                        break\\n                if incomingOrder.amount > 0:\\n                    # negate for max heap\\n                    incomingOrder.price = -incomingOrder.price\\n                    heapq.heappush(buyHeap, incomingOrder)\\n            elif incomingOrder.orderType == oType.SELL:\\n                while buyHeap and -buyHeap[0].price >= incomingOrder.price:\\n                    buyOrder = heapq.heappop(buyHeap)\\n                    if buyOrder.amount < incomingOrder.amount:\\n                        incomingOrder.amount -= buyOrder.amount\\n                    elif buyOrder.amount == incomingOrder.amount:\\n                        incomingOrder.amount = 0\\n                        break\\n                    elif buyOrder.amount > incomingOrder.amount:\\n                        buyOrder.amount = buyOrder.amount - incomingOrder.amount\\n                        incomingOrder.amount = 0\\n                        heapq.heappush(buyHeap, buyOrder)\\n                        break\\n                if incomingOrder.amount > 0:\\n                    heapq.heappush(sellHeap, incomingOrder)\\n            \\n        buySum = sum([order.amount for order in buyHeap])\\n        sellSum = sum([order.amount for order in sellHeap])\\n        return (buySum + sellSum) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120405,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>>buy;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell;\\n        for(auto x : orders)\\n        {\\n            int cnt = x[1];\\n            if(x[2]==1)\\n            {                               \\n                while(!buy.empty() && cnt)\\n                {                                       // if orderType is sell, then we look for\\n                    int f = buy.top().first;            //all largest value in buy, and decrease the amount  \\n                    if(f>=x[0])\\n                    {\\n                        int s = buy.top().second;\\n                        buy.pop();\\n                        int  mn = min(s, cnt);           \\n                        s -= mn;\\n                        cnt -=mn; \\n                        if(s) buy.push({f, s});\\n                    }else break; \\n                }\\n                if(cnt) sell.push({x[0], cnt}); // if still amount is left we push into sell heap\\n            }\\n            else\\n            {\\n                while(!sell.empty() && cnt)\\n                {                                       // if orderType is buy, then we look for\\n                    int f = sell.top().first;          //all smallest value in sell, and decrease the amount  \\n                    if(f<=x[0])\\n                    {\\n                        int s = sell.top().second;  \\n                        sell.pop();    \\n                        int  mn = min(s, cnt);        \\n                        s -= mn;\\n                        cnt -=mn; \\n                        if(s) sell.push({f, s});\\n                    }else break;\\n                }\\n                if(cnt) buy.push({x[0], cnt});  // if still amount is left we push into buy heap\\n            }\\n        }\\n        // calculating remaining orders\\n        int ans = 0;\\n        while(!sell.empty())\\n        {\\n            ans = (ans + sell.top().second)%mod;\\n            sell.pop();\\n        }\\n         while(!buy.empty())\\n        {\\n            ans = (ans + buy.top().second)%mod;\\n            buy.pop();\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>>buy;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell;\\n        for(auto x : orders)\\n        {\\n            int cnt = x[1];\\n            if(x[2]==1)\\n            {                               \\n                while(!buy.empty() && cnt)\\n                {                                       // if orderType is sell, then we look for\\n                    int f = buy.top().first;            //all largest value in buy, and decrease the amount  \\n                    if(f>=x[0])\\n                    {\\n                        int s = buy.top().second;\\n                        buy.pop();\\n                        int  mn = min(s, cnt);           \\n                        s -= mn;\\n                        cnt -=mn; \\n                        if(s) buy.push({f, s});\\n                    }else break; \\n                }\\n                if(cnt) sell.push({x[0], cnt}); // if still amount is left we push into sell heap\\n            }\\n            else\\n            {\\n                while(!sell.empty() && cnt)\\n                {                                       // if orderType is buy, then we look for\\n                    int f = sell.top().first;          //all smallest value in sell, and decrease the amount  \\n                    if(f<=x[0])\\n                    {\\n                        int s = sell.top().second;  \\n                        sell.pop();    \\n                        int  mn = min(s, cnt);        \\n                        s -= mn;\\n                        cnt -=mn; \\n                        if(s) sell.push({f, s});\\n                    }else break;\\n                }\\n                if(cnt) buy.push({x[0], cnt});  // if still amount is left we push into buy heap\\n            }\\n        }\\n        // calculating remaining orders\\n        int ans = 0;\\n        while(!sell.empty())\\n        {\\n            ans = (ans + sell.top().second)%mod;\\n            sell.pop();\\n        }\\n         while(!buy.empty())\\n        {\\n            ans = (ans + buy.top().second)%mod;\\n            buy.pop();\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119724,
                "title": "python-heapq",
                "content": "Buy list order by negative price so that it can be from greater to smaller.\\n\\n```python\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n        sells = []\\n        buys = []\\n        for p,a,t in orders:\\n            if t == 0:\\n                while sells:\\n                    p_, a_ = heapq.heappop(sells)\\n                    if p_ <= p:\\n                        if a >= a_:\\n                            a -= a_\\n                        else:\\n                            heapq.heappush(sells, (p_, a_-a))\\n                            a = 0\\n                            break\\n                    else:\\n                        heapq.heappush(sells, (p_, a_))\\n                        break\\n                if a:\\n                    heapq.heappush(buys, (-p, a))\\n            else:\\n                while buys:\\n                    p_, a_ = heapq.heappop(buys)\\n                    p_ = -p_\\n                    if p_ >= p:\\n                        if a >= a_:\\n                            a -= a_\\n                        else:\\n                            heapq.heappush(buys, (-p_, a_-a))\\n                            a = 0\\n                            break\\n                    else:\\n                        heapq.heappush(buys, (-p_, a_))\\n                        break\\n                if a:\\n                    heapq.heappush(sells, (p, a))\\n        return (sum(x[1] for x in sells) + sum(x[1] for x in buys)) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        import heapq\\n        sells = []\\n        buys = []\\n        for p,a,t in orders:\\n            if t == 0:\\n                while sells:\\n                    p_, a_ = heapq.heappop(sells)\\n                    if p_ <= p:\\n                        if a >= a_:\\n                            a -= a_\\n                        else:\\n                            heapq.heappush(sells, (p_, a_-a))\\n                            a = 0\\n                            break\\n                    else:\\n                        heapq.heappush(sells, (p_, a_))\\n                        break\\n                if a:\\n                    heapq.heappush(buys, (-p, a))\\n            else:\\n                while buys:\\n                    p_, a_ = heapq.heappop(buys)\\n                    p_ = -p_\\n                    if p_ >= p:\\n                        if a >= a_:\\n                            a -= a_\\n                        else:\\n                            heapq.heappush(buys, (-p_, a_-a))\\n                            a = 0\\n                            break\\n                    else:\\n                        heapq.heappush(buys, (-p_, a_))\\n                        break\\n                if a:\\n                    heapq.heappush(sells, (p, a))\\n        return (sum(x[1] for x in sells) + sum(x[1] for x in buys)) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1119644,
                "title": "java-treemap",
                "content": "```\\npublic int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer, Long> buy = new TreeMap();\\n        TreeMap<Integer, Long> sell = new TreeMap();\\n        for(int []order: orders){\\n            long orderCount = order[1];\\n            if(order[2] == 0){\\n                while(true){\\n                    Map.Entry<Integer, Long> me = sell.firstEntry();\\n                    if(orderCount == 0 || me == null || me.getKey() > order[0]){\\n                        break;\\n                    }\\n                    if(me.getValue() <= orderCount){\\n                        sell.remove(me.getKey());\\n                    }else{\\n                        sell.put(me.getKey(), me.getValue() - orderCount);\\n                    }\\n                    orderCount = Math.max(0, orderCount - me.getValue());\\n                }\\n                if(orderCount != 0)\\n                    buy.put(order[0], buy.getOrDefault(order[0], 0L) + orderCount);\\n            }else{\\n                while(true){\\n                    Map.Entry<Integer, Long> me = buy.lastEntry();\\n                    if(orderCount == 0 || me == null || me.getKey() < order[0]){\\n                        break;\\n                    }\\n                    if(me.getValue() <= orderCount){\\n                        buy.remove(me.getKey());\\n                    }else{\\n                        buy.put(me.getKey(), me.getValue() - orderCount);\\n                    }\\n                    orderCount = Math.max(0, orderCount - me.getValue());\\n                }\\n                if(orderCount != 0)\\n                    sell.put(order[0], sell.getOrDefault(order[0], 0L) + orderCount);\\n            }\\n        }\\n        long ans = 0;\\n        for(Long i: buy.values()){\\n            ans += i;\\n        }\\n        for(Long i: sell.values()){\\n            ans += i;\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer, Long> buy = new TreeMap();\\n        TreeMap<Integer, Long> sell = new TreeMap();\\n        for(int []order: orders){\\n            long orderCount = order[1];\\n            if(order[2] == 0){\\n                while(true){\\n                    Map.Entry<Integer, Long> me = sell.firstEntry();\\n                    if(orderCount == 0 || me == null || me.getKey() > order[0]){\\n                        break;\\n                    }\\n                    if(me.getValue() <= orderCount){\\n                        sell.remove(me.getKey());\\n                    }else{\\n                        sell.put(me.getKey(), me.getValue() - orderCount);\\n                    }\\n                    orderCount = Math.max(0, orderCount - me.getValue());\\n                }\\n                if(orderCount != 0)\\n                    buy.put(order[0], buy.getOrDefault(order[0], 0L) + orderCount);\\n            }else{\\n                while(true){\\n                    Map.Entry<Integer, Long> me = buy.lastEntry();\\n                    if(orderCount == 0 || me == null || me.getKey() < order[0]){\\n                        break;\\n                    }\\n                    if(me.getValue() <= orderCount){\\n                        buy.remove(me.getKey());\\n                    }else{\\n                        buy.put(me.getKey(), me.getValue() - orderCount);\\n                    }\\n                    orderCount = Math.max(0, orderCount - me.getValue());\\n                }\\n                if(orderCount != 0)\\n                    sell.put(order[0], sell.getOrDefault(order[0], 0L) + orderCount);\\n            }\\n        }\\n        long ans = 0;\\n        for(Long i: buy.values()){\\n            ans += i;\\n        }\\n        for(Long i: sell.values()){\\n            ans += i;\\n        }\\n        return (int)(ans % 1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945792,
                "title": "java-2-priority-queues-1ms-beats-90",
                "content": "```\\nclass Order implements Comparable<Order> {\\n    int price, amount, orderType;\\n    Order(int price, int amount, int orderType) {\\n        this.price = price;\\n        this.amount = amount;\\n        this.orderType = orderType;\\n    }\\n    \\n    @Override\\n    public int compareTo(Order order) {\\n        return this.price - order.price;\\n    }\\n}\\n\\nclass Solution {\\n    static final int  BUY = 0, SELL = 1, mod = 1000000007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sellBacklog = new PriorityQueue<>();\\n        PriorityQueue<Order> buyBacklog = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int[] order: orders) {\\n            int price = order[0], amount = order[1], orderType = order[2];\\n            Order orderInstance = new Order(price, amount, orderType);\\n            if(orderType == SELL) {\\n                Order topBuy = buyBacklog.peek();\\n                while(topBuy != null && \\n                      topBuy.price >= orderInstance.price && \\n                      orderInstance.amount > 0) {\\n                    int buysRemaining = Math.max(0, topBuy.amount - orderInstance.amount);\\n                    int orderRemainig = Math.max(0, orderInstance.amount - topBuy.amount);\\n                    topBuy.amount = buysRemaining;\\n                    if(buysRemaining == 0) {\\n                        buyBacklog.poll();\\n                    }\\n                    orderInstance.amount = orderRemainig;    \\n                    topBuy = buyBacklog.peek();\\n                }\\n                if(orderInstance.amount > 0) {\\n                    sellBacklog.add(orderInstance);\\n                }\\n            } else {\\n                Order topSell = sellBacklog.peek();\\n                while(topSell != null && \\n                      topSell.price <= orderInstance.price && \\n                      orderInstance.amount > 0) {\\n                    int sellsRemaining = Math.max(0, topSell.amount - orderInstance.amount);\\n                    int orderRemaining = Math.max(0, orderInstance.amount - topSell.amount);\\n                    topSell.amount = sellsRemaining;\\n                    if(sellsRemaining == 0) {\\n                        sellBacklog.poll();\\n                    }\\n                    orderInstance.amount = orderRemaining;\\n                    topSell = sellBacklog.peek();\\n                }\\n                if(orderInstance.amount > 0) {\\n                    buyBacklog.add(orderInstance);\\n                }\\n            }\\n        }\\n        int total = 0;\\n        while(!sellBacklog.isEmpty()) {\\n            Order sell = sellBacklog.poll();\\n            total = (total + sell.amount) % mod;\\n        }\\n        while (!buyBacklog.isEmpty()) {\\n            Order buy = buyBacklog.poll();\\n            total = (total + buy.amount) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Order implements Comparable<Order> {\\n    int price, amount, orderType;\\n    Order(int price, int amount, int orderType) {\\n        this.price = price;\\n        this.amount = amount;\\n        this.orderType = orderType;\\n    }\\n    \\n    @Override\\n    public int compareTo(Order order) {\\n        return this.price - order.price;\\n    }\\n}\\n\\nclass Solution {\\n    static final int  BUY = 0, SELL = 1, mod = 1000000007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sellBacklog = new PriorityQueue<>();\\n        PriorityQueue<Order> buyBacklog = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int[] order: orders) {\\n            int price = order[0], amount = order[1], orderType = order[2];\\n            Order orderInstance = new Order(price, amount, orderType);\\n            if(orderType == SELL) {\\n                Order topBuy = buyBacklog.peek();\\n                while(topBuy != null && \\n                      topBuy.price >= orderInstance.price && \\n                      orderInstance.amount > 0) {\\n                    int buysRemaining = Math.max(0, topBuy.amount - orderInstance.amount);\\n                    int orderRemainig = Math.max(0, orderInstance.amount - topBuy.amount);\\n                    topBuy.amount = buysRemaining;\\n                    if(buysRemaining == 0) {\\n                        buyBacklog.poll();\\n                    }\\n                    orderInstance.amount = orderRemainig;    \\n                    topBuy = buyBacklog.peek();\\n                }\\n                if(orderInstance.amount > 0) {\\n                    sellBacklog.add(orderInstance);\\n                }\\n            } else {\\n                Order topSell = sellBacklog.peek();\\n                while(topSell != null && \\n                      topSell.price <= orderInstance.price && \\n                      orderInstance.amount > 0) {\\n                    int sellsRemaining = Math.max(0, topSell.amount - orderInstance.amount);\\n                    int orderRemaining = Math.max(0, orderInstance.amount - topSell.amount);\\n                    topSell.amount = sellsRemaining;\\n                    if(sellsRemaining == 0) {\\n                        sellBacklog.poll();\\n                    }\\n                    orderInstance.amount = orderRemaining;\\n                    topSell = sellBacklog.peek();\\n                }\\n                if(orderInstance.amount > 0) {\\n                    buyBacklog.add(orderInstance);\\n                }\\n            }\\n        }\\n        int total = 0;\\n        while(!sellBacklog.isEmpty()) {\\n            Order sell = sellBacklog.poll();\\n            total = (total + sell.amount) % mod;\\n        }\\n        while (!buyBacklog.isEmpty()) {\\n            Order buy = buyBacklog.poll();\\n            total = (total + buy.amount) % mod;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346875,
                "title": "c-2-heaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n = orders.size();\\n        //0 - buy  , 1 - sell; \\n        priority_queue<vector<int>> buyBacklog;\\n        priority_queue<vector<int> , vector<vector<int>> , greater<vector<int>>> sellBacklog;\\n        \\n        for(auto order : orders) {\\n            if(order[2] == 0) \\n                buyBacklog.push(order);\\n            else \\n                sellBacklog.push(order);\\n            \\n            while(!buyBacklog.empty() && !sellBacklog.empty() && sellBacklog.top()[0] <= buyBacklog.top()[0])  {\\n                auto btop = buyBacklog.top();\\n                buyBacklog.pop();\\n                auto stop = sellBacklog.top();\\n                sellBacklog.pop();\\n                int diff = btop[1] - stop[1];\\n                if(diff > 0) {\\n                    btop[1] = diff;\\n                    buyBacklog.push(btop);\\n                }\\n                else if(diff<0) {\\n                    stop[1] = abs(diff);\\n                    sellBacklog.push(stop);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0 , mod = 1e9+7;\\n        while(!buyBacklog.empty()){\\n            ans = (ans +buyBacklog.top()[1])%mod;\\n            buyBacklog.pop();\\n        }\\n        while(!sellBacklog.empty()){\\n            ans = (ans+ sellBacklog.top()[1])%mod;\\n            sellBacklog.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n = orders.size();\\n        //0 - buy  , 1 - sell; \\n        priority_queue<vector<int>> buyBacklog;\\n        priority_queue<vector<int> , vector<vector<int>> , greater<vector<int>>> sellBacklog;\\n        \\n        for(auto order : orders) {\\n            if(order[2] == 0) \\n                buyBacklog.push(order);\\n            else \\n                sellBacklog.push(order);\\n            \\n            while(!buyBacklog.empty() && !sellBacklog.empty() && sellBacklog.top()[0] <= buyBacklog.top()[0])  {\\n                auto btop = buyBacklog.top();\\n                buyBacklog.pop();\\n                auto stop = sellBacklog.top();\\n                sellBacklog.pop();\\n                int diff = btop[1] - stop[1];\\n                if(diff > 0) {\\n                    btop[1] = diff;\\n                    buyBacklog.push(btop);\\n                }\\n                else if(diff<0) {\\n                    stop[1] = abs(diff);\\n                    sellBacklog.push(stop);\\n                }\\n            }\\n        }\\n        \\n        int ans = 0 , mod = 1e9+7;\\n        while(!buyBacklog.empty()){\\n            ans = (ans +buyBacklog.top()[1])%mod;\\n            buyBacklog.pop();\\n        }\\n        while(!sellBacklog.empty()){\\n            ans = (ans+ sellBacklog.top()[1])%mod;\\n            sellBacklog.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259846,
                "title": "c-1801-number-of-orders-in-the-backlog",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>> buy; // max-heap \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> sell; // min-heap \\n        \\n        for (auto& order : orders) {\\n            auto price = order[0], qty = order[1], type = order[2]; \\n            if (type == 0) buy.emplace(price, qty); \\n            else sell.emplace(price, qty); \\n            \\n            while (size(buy) && size(sell) && buy.top().first >= sell.top().first) {\\n                auto [bp, bq] = buy.top(); buy.pop(); \\n                auto [sp, sq] = sell.top(); sell.pop(); \\n                if (bq > sq) {\\n                    bq -= sq; \\n                    buy.emplace(bp, bq); \\n                } else if (bq < sq) {\\n                    sq -= bq; \\n                    sell.emplace(sp, sq); \\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        while (size(buy)) { ans = (ans + buy.top().second) % 1\\'000\\'000\\'007; buy.pop(); }\\n        while (size(sell)) { ans = (ans + sell.top().second) % 1\\'000\\'000\\'007; sell.pop(); }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>> buy; // max-heap \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> sell; // min-heap \\n        \\n        for (auto& order : orders) {\\n            auto price = order[0], qty = order[1], type = order[2]; \\n            if (type == 0) buy.emplace(price, qty); \\n            else sell.emplace(price, qty); \\n            \\n            while (size(buy) && size(sell) && buy.top().first >= sell.top().first) {\\n                auto [bp, bq] = buy.top(); buy.pop(); \\n                auto [sp, sq] = sell.top(); sell.pop(); \\n                if (bq > sq) {\\n                    bq -= sq; \\n                    buy.emplace(bp, bq); \\n                } else if (bq < sq) {\\n                    sq -= bq; \\n                    sell.emplace(sp, sq); \\n                }\\n            }\\n        }\\n        \\n        int ans = 0; \\n        while (size(buy)) { ans = (ans + buy.top().second) % 1\\'000\\'000\\'007; buy.pop(); }\\n        while (size(sell)) { ans = (ans + sell.top().second) % 1\\'000\\'000\\'007; sell.pop(); }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120063,
                "title": "python-priority-queue-solution-o-nlogn",
                "content": "Maintain two priority queues. One for the buy orders and the other for the sell orders\\n```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_q = PriorityQueue()\\n        sell_q = PriorityQueue()\\n\\n        for odr in orders:\\n            if odr[2] == 1:  #sell\\n                while buy_q.qsize()>0 and odr[1] > 0: #while there is backlog and odr[1]!=0\\n                    price, quant = buy_q.get()                      \\n                    if -price < odr[0]:              #if the highest order price in buy_q is less than current order price\\n                        buy_q.put((price,quant))\\n                        break\\n                        \\n                    deal = min(quant, odr[1])    #max buy backlog that can be removed from buy\\n                    odr[1] -= deal                #subract from the current sell quantity\\n                    \\n                    if deal != quant: buy_q.put((price, quant - deal))  #push the remaining buy backlog the the buy_q\\n \\n                if odr[1]>0:\\n                    sell_q.put((odr[0], odr[1]))   #push the remaning sell items to the sell_q\\n         \\n            else:  #buy\\n                while sell_q.qsize()>0 and odr[1] > 0: #while there is backlog and odr[1]!=0\\n                    price, quant = sell_q.get()   \\n                    if price > odr[0]:     #if the lowest order price in sell_q is less than current order price\\n                        sell_q.put((price,quant))\\n                        break\\n                        \\n                    deal = min(quant, odr[1]) #max sell backlog that can be removed from sell\\n                    odr[1] -= deal   #subract from the current buy quantity\\n                    \\n                    if deal != quant: sell_q.put((price, quant - deal)) #push the remaining sell backlog the the sell_q\\n                \\n                if odr[1]>0:\\n                    buy_q.put((-odr[0], odr[1])) #push the remaning buy items to the buy_q\\n              \\n        total_back = 0   #total backlog\\n        while sell_q.qsize()>0:\\n            total_back += sell_q.get()[1]\\n\\n        while buy_q.qsize() > 0:\\n            total_back += buy_q.get()[1]\\n        \\n        return total_back%(10**9 + 7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_q = PriorityQueue()\\n        sell_q = PriorityQueue()\\n\\n        for odr in orders:\\n            if odr[2] == 1:  #sell\\n                while buy_q.qsize()>0 and odr[1] > 0: #while there is backlog and odr[1]!=0\\n                    price, quant = buy_q.get()                      \\n                    if -price < odr[0]:              #if the highest order price in buy_q is less than current order price\\n                        buy_q.put((price,quant))\\n                        break\\n                        \\n                    deal = min(quant, odr[1])    #max buy backlog that can be removed from buy\\n                    odr[1] -= deal                #subract from the current sell quantity\\n                    \\n                    if deal != quant: buy_q.put((price, quant - deal))  #push the remaining buy backlog the the buy_q\\n \\n                if odr[1]>0:\\n                    sell_q.put((odr[0], odr[1]))   #push the remaning sell items to the sell_q\\n         \\n            else:  #buy\\n                while sell_q.qsize()>0 and odr[1] > 0: #while there is backlog and odr[1]!=0\\n                    price, quant = sell_q.get()   \\n                    if price > odr[0]:     #if the lowest order price in sell_q is less than current order price\\n                        sell_q.put((price,quant))\\n                        break\\n                        \\n                    deal = min(quant, odr[1]) #max sell backlog that can be removed from sell\\n                    odr[1] -= deal   #subract from the current buy quantity\\n                    \\n                    if deal != quant: sell_q.put((price, quant - deal)) #push the remaining sell backlog the the sell_q\\n                \\n                if odr[1]>0:\\n                    buy_q.put((-odr[0], odr[1])) #push the remaning buy items to the buy_q\\n              \\n        total_back = 0   #total backlog\\n        while sell_q.qsize()>0:\\n            total_back += sell_q.get()[1]\\n\\n        while buy_q.qsize() > 0:\\n            total_back += buy_q.get()[1]\\n        \\n        return total_back%(10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119921,
                "title": "python-max-min-heap",
                "content": "Buy orders are ranked from largest to smallest in price.\\nSell orders are ranked from smallest to largest in price.\\nWe add the orders in the order they arrive,\\nwhen there is a match in prices we do the transaction.\\n\\n```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        maxhp = []\\n        minhp = []\\n        for x,y,z in orders:\\n            if z==0: #buy\\n                heapq.heappush(maxhp, (-x, y))\\n            else: #sell\\n                heapq.heappush(minhp, (x, y))\\n            \\n            #if there is match, do the transaction\\n            while maxhp and minhp and -maxhp[0][0] >= minhp[0][0]:\\n                xbuy, ybuy = heapq.heappop(maxhp)\\n                xsell, ysell = heapq.heappop(minhp)\\n                if ybuy > ysell:\\n                    heapq.heappush(maxhp, (xbuy, ybuy-ysell))\\n                elif ybuy < ysell:\\n                    heapq.heappush(minhp, (xsell, ysell-ybuy))\\n        \\n        ans = sum(y for _,y in maxhp) + sum(y for _,y in minhp)\\n        ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        maxhp = []\\n        minhp = []\\n        for x,y,z in orders:\\n            if z==0: #buy\\n                heapq.heappush(maxhp, (-x, y))\\n            else: #sell\\n                heapq.heappush(minhp, (x, y))\\n            \\n            #if there is match, do the transaction\\n            while maxhp and minhp and -maxhp[0][0] >= minhp[0][0]:\\n                xbuy, ybuy = heapq.heappop(maxhp)\\n                xsell, ysell = heapq.heappop(minhp)\\n                if ybuy > ysell:\\n                    heapq.heappush(maxhp, (xbuy, ybuy-ysell))\\n                elif ybuy < ysell:\\n                    heapq.heappush(minhp, (xsell, ysell-ybuy))\\n        \\n        ans = sum(y for _,y in maxhp) + sum(y for _,y in minhp)\\n        ans = ans % (10**9 + 7)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119828,
                "title": "c-solution-with-two-priority-queues",
                "content": "Idea:\\nThis problem is like a trading system. With a bunch of sell orders, when a buying order comes in, the system would match the buying order with the selling orders whose prices is less than or equal to the buying prices. Same thing goes with the buy orders. In order to find which one is the best match, or there is no match at all, we can use the priority_queue(heap) to simulate the process.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, BuyComp> buy;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, SellComp> sell;\\n        long res = 0;\\n        \\n        for (vector<int>& order : orders) {\\n            int sum = order[1];\\n            // buy order\\n            if (order.back() == 0) {\\n                while (!sell.empty() && sell.top().first <= order[0] && order[1]) {\\n                    int amount = min(order[1], sell.top().second);\\n                    if (sell.top().second == amount) {\\n                        sell.pop();\\n                    } else {\\n                        pair<int,int> cur = sell.top();\\n                        sell.pop();\\n                        cur.second -= amount;\\n                        sell.push(cur);\\n                    }\\n                    order[1] -= amount;\\n                }\\n                if (order[1] > 0) {\\n                    buy.push(make_pair(order[0], order[1]));\\n                }\\n\\t\\t\\t// sell order\\n            } else {\\n                while (!buy.empty() && buy.top().first >= order[0] && order[1]) {\\n                    int amount = min(order[1], buy.top().second);\\n                    if (buy.top().second == amount) {\\n                        buy.pop();\\n                    } else {\\n                        pair<int,int> cur = buy.top();\\n                        buy.pop();\\n                        cur.second -= amount;\\n                        buy.push(cur);\\n                    }\\n                    order[1] -= amount;\\n                }\\n                if (order[1] > 0) {\\n                    sell.push(make_pair(order[0], order[1]));\\n                }\\n            }\\n            res += order[1]*2 - sum;\\n        }\\n        return res%mod;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    \\n    // price, amount\\n    struct BuyComp {\\n        bool operator() (pair<int,int>& a, pair<int,int>& b) {\\n            return a.first < b.first;\\n        }\\n    };\\n    \\n    struct SellComp {\\n        bool operator() (pair<int,int>& a, pair<int,int>& b) {\\n            return a.first > b.first;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, BuyComp> buy;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, SellComp> sell;\\n        long res = 0;\\n        \\n        for (vector<int>& order : orders) {\\n            int sum = order[1];\\n            // buy order\\n            if (order.back() == 0) {\\n                while (!sell.empty() && sell.top().first <= order[0] && order[1]) {\\n                    int amount = min(order[1], sell.top().second);\\n                    if (sell.top().second == amount) {\\n                        sell.pop();\\n                    } else {\\n                        pair<int,int> cur = sell.top();\\n                        sell.pop();\\n                        cur.second -= amount;\\n                        sell.push(cur);\\n                    }\\n                    order[1] -= amount;\\n                }\\n                if (order[1] > 0) {\\n                    buy.push(make_pair(order[0], order[1]));\\n                }\\n\\t\\t\\t// sell order\\n            } else {\\n                while (!buy.empty() && buy.top().first >= order[0] && order[1]) {\\n                    int amount = min(order[1], buy.top().second);\\n                    if (buy.top().second == amount) {\\n                        buy.pop();\\n                    } else {\\n                        pair<int,int> cur = buy.top();\\n                        buy.pop();\\n                        cur.second -= amount;\\n                        buy.push(cur);\\n                    }\\n                    order[1] -= amount;\\n                }\\n                if (order[1] > 0) {\\n                    sell.push(make_pair(order[0], order[1]));\\n                }\\n            }\\n            res += order[1]*2 - sum;\\n        }\\n        return res%mod;\\n    }\\nprivate:\\n    const int mod = 1e9+7;\\n    \\n    // price, amount\\n    struct BuyComp {\\n        bool operator() (pair<int,int>& a, pair<int,int>& b) {\\n            return a.first < b.first;\\n        }\\n    };\\n    \\n    struct SellComp {\\n        bool operator() (pair<int,int>& a, pair<int,int>& b) {\\n            return a.first > b.first;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119826,
                "title": "ruby-keep-sorted-queues-for-buy-and-sell-orders",
                "content": "Keep buy queue sorted by price descending.\\nKeep sell queue sorted by price ascending.\\nBuy by the best price (minimum price - first in the sell queue) while can.\\nSell by the best price (maximum price - first in the buy queue) while can.\\n\\n```ruby\\ndef get_number_of_backlog_orders(orders)\\n  bq = []; sq = [] # buy queue and sell queue\\n  for price, amount, order_type in orders\\n    if order_type == 0 # buy\\n      amount -= sq.shift[1] while amount > 0 && sq.any? && sq[0][0] <= price && sq[0][1] <= amount\\n      if sq.any? && sq[0][0] <= price\\n        sq[0][1] -= amount\\n      else\\n        bq.insert(bq.bsearch_index { |p,| p <= price } || bq.size, [price, amount]) if amount > 0\\n      end\\n    else # sell\\n      amount -= bq.shift[1] while amount > 0 && bq.any? && bq[0][0] >= price && bq[0][1] <= amount\\n      if bq.any? && bq[0][0] >= price\\n        bq[0][1] -= amount\\n      else\\n        sq.insert(sq.bsearch_index { |p,| p >= price } || sq.size, [price, amount]) if amount > 0\\n      end\\n    end\\n  end\\n  (bq.sum(&:last) + sq.sum(&:last)) % 1000000007\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```ruby\\ndef get_number_of_backlog_orders(orders)\\n  bq = []; sq = [] # buy queue and sell queue\\n  for price, amount, order_type in orders\\n    if order_type == 0 # buy\\n      amount -= sq.shift[1] while amount > 0 && sq.any? && sq[0][0] <= price && sq[0][1] <= amount\\n      if sq.any? && sq[0][0] <= price\\n        sq[0][1] -= amount\\n      else\\n        bq.insert(bq.bsearch_index { |p,| p <= price } || bq.size, [price, amount]) if amount > 0\\n      end\\n    else # sell\\n      amount -= bq.shift[1] while amount > 0 && bq.any? && bq[0][0] >= price && bq[0][1] <= amount\\n      if bq.any? && bq[0][0] >= price\\n        bq[0][1] -= amount\\n      else\\n        sq.insert(sq.bsearch_index { |p,| p >= price } || sq.size, [price, amount]) if amount > 0\\n      end\\n    end\\n  end\\n  (bq.sum(&:last) + sq.sum(&:last)) % 1000000007\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1119697,
                "title": "c-beats-100",
                "content": "Used two maps for each of the buys and sells; and using the iterator pointers, I would decrement the necessary map values.\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<int,long> mpBuy;\\n        map<int,long> mpSell;\\n        int count = 0;\\n        for (int i = 0;i<orders.size();i++){\\n            if (orders[i][2]==0 && mpBuy.find(orders[i][0])!=mpBuy.end()){\\n                mpBuy[orders[i][0]] += orders[i][1];\\n                continue;\\n            }\\n            if (orders[i][2]==1 && mpSell.find(orders[i][0])!=mpSell.end()){\\n                mpSell[orders[i][0]] += orders[i][1];\\n                continue;\\n            }\\n            if (orders[i][2]==0){\\n                if (mpSell.size()==0){\\n                    mpBuy[orders[i][0]] += orders[i][1];\\n                    continue;\\n                }\\n                auto it = mpSell.begin();\\n                count = orders[i][1];\\n                while(count>0){\\n                    if ((*it).first<=orders[i][0] && (*it).second>count){\\n                        (*it).second -= count;\\n                        count = 0;\\n                        break;\\n                    }\\n                    if ((*it).first<=orders[i][0] && (*it).second<=count){\\n                        count -= (*it).second;\\n                        auto it2 = it;\\n                        it++;\\n                        mpSell.erase((*it2).first);\\n                    }\\n                    if (mpSell.size()==0){\\n                        break;\\n                    }\\n                    if ((*it).first>orders[i][0]){\\n                        break;\\n                    }\\n                }\\n                if (count!=0){\\n                    mpBuy[orders[i][0]] += count;\\n                }\\n                continue;\\n            }\\n            if (orders[i][2]==1){\\n                if (mpBuy.size()==0){\\n                    mpSell[orders[i][0]] += orders[i][1];\\n                    continue;\\n                }\\n                auto it = mpBuy.end();\\n                it--;\\n                count = orders[i][1];\\n                while(count>0){\\n                    if ((*it).first>=orders[i][0] && (*it).second>count){\\n                        (*it).second -= count;\\n                        count = 0;\\n                        break;\\n                    }\\n                    if ((*it).first>=orders[i][0] && (*it).second<=count){\\n                        count -= (*it).second;\\n                        auto it2 = it;\\n                        it--;\\n                        mpBuy.erase((*it2).first);\\n                    }\\n                    if (mpBuy.size()==0){\\n                        break;\\n                    }\\n                    if ((*it).first<orders[i][0]){\\n                        break;\\n                    }\\n                }\\n                if (count!=0){\\n                    mpSell[orders[i][0]] += count;\\n                }\\n                continue;\\n            }\\n        }\\n        long sum = 0;\\n        for (auto it = mpBuy.begin();it!=mpBuy.end();++it){\\n            sum += (*it).second;\\n        }\\n        for (auto it = mpSell.begin();it!=mpSell.end();++it){\\n            sum += (*it).second;\\n        }\\n        sum %= (int)1e9+7;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<int,long> mpBuy;\\n        map<int,long> mpSell;\\n        int count = 0;\\n        for (int i = 0;i<orders.size();i++){\\n            if (orders[i][2]==0 && mpBuy.find(orders[i][0])!=mpBuy.end()){\\n                mpBuy[orders[i][0]] += orders[i][1];\\n                continue;\\n            }\\n            if (orders[i][2]==1 && mpSell.find(orders[i][0])!=mpSell.end()){\\n                mpSell[orders[i][0]] += orders[i][1];\\n                continue;\\n            }\\n            if (orders[i][2]==0){\\n                if (mpSell.size()==0){\\n                    mpBuy[orders[i][0]] += orders[i][1];\\n                    continue;\\n                }\\n                auto it = mpSell.begin();\\n                count = orders[i][1];\\n                while(count>0){\\n                    if ((*it).first<=orders[i][0] && (*it).second>count){\\n                        (*it).second -= count;\\n                        count = 0;\\n                        break;\\n                    }\\n                    if ((*it).first<=orders[i][0] && (*it).second<=count){\\n                        count -= (*it).second;\\n                        auto it2 = it;\\n                        it++;\\n                        mpSell.erase((*it2).first);\\n                    }\\n                    if (mpSell.size()==0){\\n                        break;\\n                    }\\n                    if ((*it).first>orders[i][0]){\\n                        break;\\n                    }\\n                }\\n                if (count!=0){\\n                    mpBuy[orders[i][0]] += count;\\n                }\\n                continue;\\n            }\\n            if (orders[i][2]==1){\\n                if (mpBuy.size()==0){\\n                    mpSell[orders[i][0]] += orders[i][1];\\n                    continue;\\n                }\\n                auto it = mpBuy.end();\\n                it--;\\n                count = orders[i][1];\\n                while(count>0){\\n                    if ((*it).first>=orders[i][0] && (*it).second>count){\\n                        (*it).second -= count;\\n                        count = 0;\\n                        break;\\n                    }\\n                    if ((*it).first>=orders[i][0] && (*it).second<=count){\\n                        count -= (*it).second;\\n                        auto it2 = it;\\n                        it--;\\n                        mpBuy.erase((*it2).first);\\n                    }\\n                    if (mpBuy.size()==0){\\n                        break;\\n                    }\\n                    if ((*it).first<orders[i][0]){\\n                        break;\\n                    }\\n                }\\n                if (count!=0){\\n                    mpSell[orders[i][0]] += count;\\n                }\\n                continue;\\n            }\\n        }\\n        long sum = 0;\\n        for (auto it = mpBuy.begin();it!=mpBuy.end();++it){\\n            sum += (*it).second;\\n        }\\n        for (auto it = mpSell.begin();it!=mpSell.end();++it){\\n            sum += (*it).second;\\n        }\\n        sum %= (int)1e9+7;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119681,
                "title": "python3-clean-and-clear-two-heaps",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell, MOD = [], [], 10**9 + 7\\n        \\n        def process_buy(buy_price, buy_amount):\\n            while buy_amount > 0:\\n                if not sell:\\n                    break\\n                sell_price, sell_amount = heapq.heappop(sell)\\n                if sell_price > buy_price:\\n                    heapq.heappush(sell, (sell_price, sell_amount))\\n                    break\\n                \\n                if sell_amount - buy_amount > 0:\\n                    heapq.heappush(sell, (sell_price, sell_amount - buy_amount))\\n                buy_amount -= sell_amount\\n            if buy_amount > 0:\\n                heapq.heappush(buy, (-buy_price, buy_amount))\\n            \\n        def process_sell(sell_price, sell_amount):\\n            while sell_amount > 0:\\n                if not buy:\\n                    break\\n                buy_price, buy_amount = heapq.heappop(buy)\\n                buy_price *= -1 # min heap only in Python\\n                if sell_price > buy_price:\\n                    heapq.heappush(buy, (-buy_price, buy_amount))\\n                    break\\n                \\n                if buy_amount - sell_amount > 0:\\n                    heapq.heappush(buy, (-buy_price, buy_amount - sell_amount))\\n                sell_amount -= buy_amount\\n            if sell_amount > 0:\\n                heapq.heappush(sell, (sell_price, sell_amount))\\n    \\n        for price, amount, order_type in orders:\\n            if order_type == 0:\\n                process_buy(price, amount)\\n            else:\\n                process_sell(price, amount)\\n\\n        return (sum([x[1] for x in buy]) + sum([x[1] for x in sell])) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell, MOD = [], [], 10**9 + 7\\n        \\n        def process_buy(buy_price, buy_amount):\\n            while buy_amount > 0:\\n                if not sell:\\n                    break\\n                sell_price, sell_amount = heapq.heappop(sell)\\n                if sell_price > buy_price:\\n                    heapq.heappush(sell, (sell_price, sell_amount))\\n                    break\\n                \\n                if sell_amount - buy_amount > 0:\\n                    heapq.heappush(sell, (sell_price, sell_amount - buy_amount))\\n                buy_amount -= sell_amount\\n            if buy_amount > 0:\\n                heapq.heappush(buy, (-buy_price, buy_amount))\\n            \\n        def process_sell(sell_price, sell_amount):\\n            while sell_amount > 0:\\n                if not buy:\\n                    break\\n                buy_price, buy_amount = heapq.heappop(buy)\\n                buy_price *= -1 # min heap only in Python\\n                if sell_price > buy_price:\\n                    heapq.heappush(buy, (-buy_price, buy_amount))\\n                    break\\n                \\n                if buy_amount - sell_amount > 0:\\n                    heapq.heappush(buy, (-buy_price, buy_amount - sell_amount))\\n                sell_amount -= buy_amount\\n            if sell_amount > 0:\\n                heapq.heappush(sell, (sell_price, sell_amount))\\n    \\n        for price, amount, order_type in orders:\\n            if order_type == 0:\\n                process_buy(price, amount)\\n            else:\\n                process_sell(price, amount)\\n\\n        return (sum([x[1] for x in buy]) + sum([x[1] for x in sell])) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986818,
                "title": "heap-cpp",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        struct cmp\\n        {\\n            bool operator()(pair<int, int> a, pair<int, int> b)\\n            {\\n                return a.first > b.first;\\n            }\\n        };\\n    void fun(priority_queue<pair<int, int>, vector< pair<int, int>>, cmp> &sell, priority_queue< pair<int, int>> &buy)\\n    {\\n        while (buy.size() and sell.size() and buy.top().first >= sell.top().first)\\n        {\\n            auto x = buy.top();\\n            auto y = sell.top();\\n            buy.pop();\\n            sell.pop();\\n            if (x.second < y.second)\\n            {\\n                y.second -= x.second;\\n                x.second = 0;\\n                sell.push(y);\\n            }\\n            else if (y.second < x.second)\\n            {\\n                x.second -= y.second;\\n                y.second = 0;\\n                buy.push(x);\\n            }\\n            else\\n            {\\n                x.second = 0;\\n                y.second = 0;\\n            }\\n        }\\n    }\\n    int getNumberOfBacklogOrders(vector<vector < int>> &orders)\\n    {\\n        int mod = 1e9 + 7;\\n        priority_queue<pair<int, int>, vector< pair<int, int>>, cmp> sell;\\n        priority_queue<pair<int, int>> buy;\\n        long ans = 0;\\n        for (int x = 0; x < orders.size(); x++)\\n        {\\n            if (orders[x][2] == 1) sell.push({ orders[x][0],orders[x][1] });\\n            else buy.push({ orders[x][0],orders[x][1] });\\n\\n            fun(sell, buy);\\n        }\\n        fun(sell, buy);\\n        while (buy.size())\\n        {\\n            ans = (ans + buy.top().second) % mod;\\n            buy.pop();\\n        }\\n        while (sell.size())\\n        {\\n            ans = (ans + sell.top().second) % mod;\\n            sell.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        struct cmp\\n        {\\n            bool operator()(pair<int, int> a, pair<int, int> b)\\n            {\\n                return a.first > b.first;\\n            }\\n        };\\n    void fun(priority_queue<pair<int, int>, vector< pair<int, int>>, cmp> &sell, priority_queue< pair<int, int>> &buy)\\n    {\\n        while (buy.size() and sell.size() and buy.top().first >= sell.top().first)\\n        {\\n            auto x = buy.top();\\n            auto y = sell.top();\\n            buy.pop();\\n            sell.pop();\\n            if (x.second < y.second)\\n            {\\n                y.second -= x.second;\\n                x.second = 0;\\n                sell.push(y);\\n            }\\n            else if (y.second < x.second)\\n            {\\n                x.second -= y.second;\\n                y.second = 0;\\n                buy.push(x);\\n            }\\n            else\\n            {\\n                x.second = 0;\\n                y.second = 0;\\n            }\\n        }\\n    }\\n    int getNumberOfBacklogOrders(vector<vector < int>> &orders)\\n    {\\n        int mod = 1e9 + 7;\\n        priority_queue<pair<int, int>, vector< pair<int, int>>, cmp> sell;\\n        priority_queue<pair<int, int>> buy;\\n        long ans = 0;\\n        for (int x = 0; x < orders.size(); x++)\\n        {\\n            if (orders[x][2] == 1) sell.push({ orders[x][0],orders[x][1] });\\n            else buy.push({ orders[x][0],orders[x][1] });\\n\\n            fun(sell, buy);\\n        }\\n        fun(sell, buy);\\n        while (buy.size())\\n        {\\n            ans = (ans + buy.top().second) % mod;\\n            buy.pop();\\n        }\\n        while (sell.size())\\n        {\\n            ans = (ans + sell.top().second) % mod;\\n            sell.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978840,
                "title": "java-sol-number-of-orders-in-the-backlog",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nminHeap for sell.\\nmaxHeap for buy.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    final static int MOD = (int) (1e9 + 7);\\n    class Order{\\n        int price;\\n        int amount;\\n        Order(int price, int amount){\\n            this.price = price;\\n            this.amount = amount;\\n        }\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sell = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o1.price - o2.price;\\n        });\\n        PriorityQueue<Order> buy = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o2.price - o1.price;\\n        });\\n\\n        boolean flag;\\n        for(int[] ord : orders){\\n            int amount = ord[1];\\n            int price = ord[0];\\n            if(ord[2] == 0){ //buy\\n                while(amount>0 && !sell.isEmpty() && sell.peek().price<=price){\\n                    Order front = sell.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  sell.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;          \\n                }\\n                if(amount > 0)  buy.add(new Order(price, amount));\\n            }else{ //sell\\n                while(amount>0 && !buy.isEmpty() && buy.peek().price>=price){\\n                    Order front = buy.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  buy.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;         \\n                }\\n                if(amount > 0)  sell.add(new Order(price, amount));\\n            }\\n        }\\n        long ans = 0;\\n        while(!sell.isEmpty())\\n            ans= (ans + sell.poll().amount) % MOD;\\n        \\n        while(!buy.isEmpty())\\n            ans= (ans + buy.poll().amount) % MOD;\\n\\n        return (int) ans%MOD;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final static int MOD = (int) (1e9 + 7);\\n    class Order{\\n        int price;\\n        int amount;\\n        Order(int price, int amount){\\n            this.price = price;\\n            this.amount = amount;\\n        }\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sell = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o1.price - o2.price;\\n        });\\n        PriorityQueue<Order> buy = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o2.price - o1.price;\\n        });\\n\\n        boolean flag;\\n        for(int[] ord : orders){\\n            int amount = ord[1];\\n            int price = ord[0];\\n            if(ord[2] == 0){ //buy\\n                while(amount>0 && !sell.isEmpty() && sell.peek().price<=price){\\n                    Order front = sell.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  sell.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;          \\n                }\\n                if(amount > 0)  buy.add(new Order(price, amount));\\n            }else{ //sell\\n                while(amount>0 && !buy.isEmpty() && buy.peek().price>=price){\\n                    Order front = buy.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  buy.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;         \\n                }\\n                if(amount > 0)  sell.add(new Order(price, amount));\\n            }\\n        }\\n        long ans = 0;\\n        while(!sell.isEmpty())\\n            ans= (ans + sell.poll().amount) % MOD;\\n        \\n        while(!buy.isEmpty())\\n            ans= (ans + buy.poll().amount) % MOD;\\n\\n        return (int) ans%MOD;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835129,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>sell;\\n        for (auto& o : orders) {\\n            if (o[2] == 0)\\n                buy.push(o);\\n            else\\n                sell.push(o);\\n            while (buy.size() && sell.size() && sell.top()[0] <= buy.top()[0]) {\\n                int k = min(buy.top()[1], sell.top()[1]);\\n                vector<int> tmp = buy.top(); buy.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) buy.push(tmp);\\n\\n                tmp = sell.top(); sell.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) sell.push(tmp);\\n            }\\n\\n        }\\n        int res = 0, mod = 1e9 + 7;\\n        while (sell.size())\\n            res = (res + sell.top()[1]) % mod, sell.pop();\\n        while (buy.size())\\n            res = (res + buy.top()[1]) % mod, buy.pop();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<vector<int>>buy;\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>sell;\\n        for (auto& o : orders) {\\n            if (o[2] == 0)\\n                buy.push(o);\\n            else\\n                sell.push(o);\\n            while (buy.size() && sell.size() && sell.top()[0] <= buy.top()[0]) {\\n                int k = min(buy.top()[1], sell.top()[1]);\\n                vector<int> tmp = buy.top(); buy.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) buy.push(tmp);\\n\\n                tmp = sell.top(); sell.pop();\\n                tmp[1] -= k;\\n                if (tmp[1]) sell.push(tmp);\\n            }\\n\\n        }\\n        int res = 0, mod = 1e9 + 7;\\n        while (sell.size())\\n            res = (res + sell.top()[1]) % mod, sell.pop();\\n        while (buy.size())\\n            res = (res + buy.top()[1]) % mod, buy.pop();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368730,
                "title": "c-two-priority-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& nums) {\\n        priority_queue<pair<int,long long int>>buy;\\n        priority_queue<pair<int,long long int>,vector<pair<int,long long int>>,greater<pair<int,long long int>>>sell;\\n        int maxi1=0,maxi2=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i][2]==0){//buy\\n                bool b=false;\\n                \\n                while(!sell.empty() and sell.top().first<=nums[i][0] and nums[i][1]>0){\\n                    pair<int,long long int>p=sell.top();\\n                    sell.pop();\\n                    if(p.second>nums[i][1]){\\n                        b=true;\\n                        sell.push({p.first,p.second-nums[i][1]});\\n                            break;\\n                    }\\n                    nums[i][1]=abs(p.second - nums[i][1]);\\n                }\\n                if(b){continue;}\\n                \\n                if(nums[i][1]>0 ){\\n                    maxi1=nums[i][1];\\n                    buy.push({nums[i][0],nums[i][1]});\\n                }\\n            }\\n            else{//sell\\n                bool b=false;\\n                \\n                while(!buy.empty() and buy.top().first>=nums[i][0] and nums[i][1]>0){\\n                    pair<int,long long int>p=buy.top();\\n                    buy.pop();\\n                    if(p.second>nums[i][1]){\\n                        b=true;\\n                        buy.push({p.first,p.second-nums[i][1]});\\n                            break;\\n                    }\\n                    nums[i][1]=abs(p.second - nums[i][1]);\\n                }\\n                if(b){continue;}\\n                \\n                if(nums[i][1]>0 ){\\n                    maxi2=nums[i][1];\\n                    sell.push({nums[i][0],nums[i][1]});\\n                }\\n                \\n            }\\n        }\\n        \\n        int cnt=0;\\n        while(!sell.empty()){\\n            cnt=(cnt+((sell.top().second % mod)))%mod;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            cnt=(cnt+((buy.top().second % mod)))%mod;\\n            buy.pop();\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& nums) {\\n        priority_queue<pair<int,long long int>>buy;\\n        priority_queue<pair<int,long long int>,vector<pair<int,long long int>>,greater<pair<int,long long int>>>sell;\\n        int maxi1=0,maxi2=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i][2]==0){//buy\\n                bool b=false;\\n                \\n                while(!sell.empty() and sell.top().first<=nums[i][0] and nums[i][1]>0){\\n                    pair<int,long long int>p=sell.top();\\n                    sell.pop();\\n                    if(p.second>nums[i][1]){\\n                        b=true;\\n                        sell.push({p.first,p.second-nums[i][1]});\\n                            break;\\n                    }\\n                    nums[i][1]=abs(p.second - nums[i][1]);\\n                }\\n                if(b){continue;}\\n                \\n                if(nums[i][1]>0 ){\\n                    maxi1=nums[i][1];\\n                    buy.push({nums[i][0],nums[i][1]});\\n                }\\n            }\\n            else{//sell\\n                bool b=false;\\n                \\n                while(!buy.empty() and buy.top().first>=nums[i][0] and nums[i][1]>0){\\n                    pair<int,long long int>p=buy.top();\\n                    buy.pop();\\n                    if(p.second>nums[i][1]){\\n                        b=true;\\n                        buy.push({p.first,p.second-nums[i][1]});\\n                            break;\\n                    }\\n                    nums[i][1]=abs(p.second - nums[i][1]);\\n                }\\n                if(b){continue;}\\n                \\n                if(nums[i][1]>0 ){\\n                    maxi2=nums[i][1];\\n                    sell.push({nums[i][0],nums[i][1]});\\n                }\\n                \\n            }\\n        }\\n        \\n        int cnt=0;\\n        while(!sell.empty()){\\n            cnt=(cnt+((sell.top().second % mod)))%mod;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            cnt=(cnt+((buy.top().second % mod)))%mod;\\n            buy.pop();\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909930,
                "title": "multiset-solution-clean-code-easy-to-understand",
                "content": "**Idea?**\\n* Track the pairs **{price,amount**} for sell orders and buy orders seperately in a **multiset**.\\n* Whenever we have a *buy orde*r, **keep popping out the selling orders** present in the backlog that are less than or equal to current price and number of orders left is still positive.\\n* Also, Whenever we have a *sell orde*r, **keep popping out the buying orders** present in the backlog that are greater than or equal to current price and number of orders is still positive.\\n* Finally, add all the number of amounts that are present in the selling as well as buying backlog.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// Time Complexity:- O(NlogN)\\n\\t// Space Complexity:- O(N)\\n    #define ll long long\\n    #define MOD 1000000007\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        ll ans = 0;\\n        multiset<pair<int,int>> sell;\\n        multiset<pair<int,int>,greater<pair<int,int>>> buy;\\n        for(auto& order:orders){\\n            int price = order[0],amount = order[1],orderType = order[2];\\n            if(orderType==0){\\n                while(!sell.empty() and amount>0 and sell.begin()->first<=price){\\n                    int available_price = sell.begin()->first;\\n                    int available_amount = sell.begin()->second;\\n                    sell.erase(sell.begin());\\n                    \\n                    int take = min(amount,available_amount);\\n                    \\n                    amount -= take;\\n                    available_amount -= take;\\n                    \\n                    if(available_amount){\\n                        sell.insert({available_price,available_amount});\\n                    }\\n                }\\n                \\n                if(amount){\\n                    buy.insert({price,amount});\\n                }\\n            }\\n            else{\\n                while(!buy.empty() and amount>0 and buy.begin()->first>=price){\\n                    int available_price = buy.begin()->first;\\n                    int available_amount = buy.begin()->second;\\n                    buy.erase(buy.begin());\\n                    \\n                    int take = min(amount,available_amount);\\n                    \\n                    amount -= take;\\n                    available_amount -= take;\\n                    \\n                    if(available_amount){\\n                        buy.insert({available_price,available_amount});\\n                    }\\n                }\\n                \\n                if(amount){\\n                    sell.insert({price,amount});\\n                }\\n            }\\n        }\\n        for(auto& x:buy){\\n            ans += x.second;\\n            ans %= MOD;\\n        }\\n        for(auto& x:sell){\\n            ans += x.second;\\n            ans %= MOD;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```\\n**DOn\\'t Forget to Upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Time Complexity:- O(NlogN)\\n\\t// Space Complexity:- O(N)\\n    #define ll long long\\n    #define MOD 1000000007\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        ll ans = 0;\\n        multiset<pair<int,int>> sell;\\n        multiset<pair<int,int>,greater<pair<int,int>>> buy;\\n        for(auto& order:orders){\\n            int price = order[0],amount = order[1],orderType = order[2];\\n            if(orderType==0){\\n                while(!sell.empty() and amount>0 and sell.begin()->first<=price){\\n                    int available_price = sell.begin()->first;\\n                    int available_amount = sell.begin()->second;\\n                    sell.erase(sell.begin());\\n                    \\n                    int take = min(amount,available_amount);\\n                    \\n                    amount -= take;\\n                    available_amount -= take;\\n                    \\n                    if(available_amount){\\n                        sell.insert({available_price,available_amount});\\n                    }\\n                }\\n                \\n                if(amount){\\n                    buy.insert({price,amount});\\n                }\\n            }\\n            else{\\n                while(!buy.empty() and amount>0 and buy.begin()->first>=price){\\n                    int available_price = buy.begin()->first;\\n                    int available_amount = buy.begin()->second;\\n                    buy.erase(buy.begin());\\n                    \\n                    int take = min(amount,available_amount);\\n                    \\n                    amount -= take;\\n                    available_amount -= take;\\n                    \\n                    if(available_amount){\\n                        buy.insert({available_price,available_amount});\\n                    }\\n                }\\n                \\n                if(amount){\\n                    sell.insert({price,amount});\\n                }\\n            }\\n        }\\n        for(auto& x:buy){\\n            ans += x.second;\\n            ans %= MOD;\\n        }\\n        for(auto& x:sell){\\n            ans += x.second;\\n            ans %= MOD;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614107,
                "title": "modular-good-for-interviews-simulating-stock-market-matching-engine-with-min-and-max-heaps",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\nclass MatchingEngine(object):\\n    \\n    def __init__(self):\\n        self.buy_orders = []  # Max heap\\n        self.sell_orders = [] # Min heap \\n    \\n    def buy(self, buy_price, quantity):\\n        while len(self.sell_orders) > 0 and buy_price >= self.sell_orders[0][0] and quantity > 0:\\n            sell_price, sell_quantity = heappop(self.sell_orders)\\n            if sell_quantity > quantity:\\n                heappush(self.sell_orders, (sell_price, sell_quantity - quantity))\\n                quantity = 0\\n            else:\\n                quantity -= sell_quantity\\n        if quantity != 0:\\n            heappush(self.buy_orders, (-buy_price, quantity))\\n    \\n    def sell(self, sell_price, quantity):\\n        while len(self.buy_orders) > 0 and sell_price <= -self.buy_orders[0][0] and quantity > 0:\\n            buy_price, buy_quantity = heappop(self.buy_orders)\\n            if buy_quantity > quantity:\\n                heappush(self.buy_orders, (buy_price, buy_quantity - quantity))\\n                quantity = 0\\n            else:\\n                quantity -= buy_quantity\\n        if quantity != 0:\\n            heappush(self.sell_orders, (sell_price, quantity))\\n            \\n    def get_pending_orders(self):\\n        pending = lambda arr : sum(map(lambda item: item[1], arr))\\n        return (pending(self.buy_orders) + pending(self.sell_orders)) % (10**9 + 7)\\n    \\n\\nclass Solution(object):\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        engine = MatchingEngine()\\n        \\n        for price, quantity, oType in orders:\\n            if oType == 0:\\n                engine.buy(price, quantity)\\n            else:\\n                engine.sell(price, quantity)\\n        \\n        return engine.get_pending_orders()\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass MatchingEngine(object):\\n    \\n    def __init__(self):\\n        self.buy_orders = []  # Max heap\\n        self.sell_orders = [] # Min heap \\n    \\n    def buy(self, buy_price, quantity):\\n        while len(self.sell_orders) > 0 and buy_price >= self.sell_orders[0][0] and quantity > 0:\\n            sell_price, sell_quantity = heappop(self.sell_orders)\\n            if sell_quantity > quantity:\\n                heappush(self.sell_orders, (sell_price, sell_quantity - quantity))\\n                quantity = 0\\n            else:\\n                quantity -= sell_quantity\\n        if quantity != 0:\\n            heappush(self.buy_orders, (-buy_price, quantity))\\n    \\n    def sell(self, sell_price, quantity):\\n        while len(self.buy_orders) > 0 and sell_price <= -self.buy_orders[0][0] and quantity > 0:\\n            buy_price, buy_quantity = heappop(self.buy_orders)\\n            if buy_quantity > quantity:\\n                heappush(self.buy_orders, (buy_price, buy_quantity - quantity))\\n                quantity = 0\\n            else:\\n                quantity -= buy_quantity\\n        if quantity != 0:\\n            heappush(self.sell_orders, (sell_price, quantity))\\n            \\n    def get_pending_orders(self):\\n        pending = lambda arr : sum(map(lambda item: item[1], arr))\\n        return (pending(self.buy_orders) + pending(self.sell_orders)) % (10**9 + 7)\\n    \\n\\nclass Solution(object):\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        engine = MatchingEngine()\\n        \\n        for price, quantity, oType in orders:\\n            if oType == 0:\\n                engine.buy(price, quantity)\\n            else:\\n                engine.sell(price, quantity)\\n        \\n        return engine.get_pending_orders()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562010,
                "title": "python-solution-using-minheap-and-maxheap",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        2D array orders \\n        orders[i] = [price, amount, orderType]\\n        0 = buy\\n        1 = sell\\n        \\n        backlog = []\\n        \\n        if order == buy:\\n            if any get the sell_order with smallest price. \\n                - sell removed from the backlog\\n            else:\\n                - buy is added to the backlog\\n        if sell:\\n            if any get the buy_order with largest price,\\n                - buy order is removed from the backlog\\n            else:\\n                - sell is added to the backlog\\n            \\n        \\'\\'\\'\\n        minheap = []\\n        maxheap = []\\n        \\n        BUY, SELL = 0, 1\\n        \\n        for price, order, typ in orders:\\n            consume = 0\\n            if typ is BUY:\\n                while minheap and order and minheap[0][0] <= price:\\n                    sellPrice, sellOrder = heappop(minheap)\\n                    consume = min(order, sellOrder)\\n                    sellOrder -= consume\\n                    order -= consume\\n                    if sellOrder:\\n                        heappush(minheap, (sellPrice, sellOrder))\\n                 \\n                if order: #if any buy orders are remaining\\n                    heappush(maxheap, (-price, order))\\n                    \\n            else: #order is SELL\\n                while maxheap and order and -maxheap[0][0] >= price:\\n                    buyPrice, buyOrder = heappop(maxheap)\\n                    consume = min(order, buyOrder)\\n                    buyOrder -= consume\\n                    order -= consume\\n                    if buyOrder:\\n                        heappush(maxheap, (buyPrice, buyOrder))\\n                 \\n                if order: #if any sell orders are remaining\\n                    heappush(minheap, (price, order))\\n        \\n        totorder = 0\\n        for _,order in minheap:\\n            totorder += order\\n            \\n        for _,order in maxheap:\\n            totorder += order\\n            \\n        return totorder % (10**9 + 7)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        2D array orders \\n        orders[i] = [price, amount, orderType]\\n        0 = buy\\n        1 = sell\\n        \\n        backlog = []\\n        \\n        if order == buy:\\n            if any get the sell_order with smallest price. \\n                - sell removed from the backlog\\n            else:\\n                - buy is added to the backlog\\n        if sell:\\n            if any get the buy_order with largest price,\\n                - buy order is removed from the backlog\\n            else:\\n                - sell is added to the backlog\\n            \\n        \\'\\'\\'\\n        minheap = []\\n        maxheap = []\\n        \\n        BUY, SELL = 0, 1\\n        \\n        for price, order, typ in orders:\\n            consume = 0\\n            if typ is BUY:\\n                while minheap and order and minheap[0][0] <= price:\\n                    sellPrice, sellOrder = heappop(minheap)\\n                    consume = min(order, sellOrder)\\n                    sellOrder -= consume\\n                    order -= consume\\n                    if sellOrder:\\n                        heappush(minheap, (sellPrice, sellOrder))\\n                 \\n                if order: #if any buy orders are remaining\\n                    heappush(maxheap, (-price, order))\\n                    \\n            else: #order is SELL\\n                while maxheap and order and -maxheap[0][0] >= price:\\n                    buyPrice, buyOrder = heappop(maxheap)\\n                    consume = min(order, buyOrder)\\n                    buyOrder -= consume\\n                    order -= consume\\n                    if buyOrder:\\n                        heappush(maxheap, (buyPrice, buyOrder))\\n                 \\n                if order: #if any sell orders are remaining\\n                    heappush(minheap, (price, order))\\n        \\n        totorder = 0\\n        for _,order in minheap:\\n            totorder += order\\n            \\n        for _,order in maxheap:\\n            totorder += order\\n            \\n        return totorder % (10**9 + 7)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397971,
                "title": "c-priority-queue-based-solution-beginner-friendly-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>> > buy; //max queue for buy\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >sell;//min queue for sell\\n        \\n        for(auto x:orders){\\n            \\n            if(x[2]==0){\\n                buy.push({x[0],x[1]});\\n                int flag=0;\\n                while(sell.size()>0 && sell.top().first<=x[0] && x[1]>0){\\n                    flag=1;\\n                    buy.pop();\\n                    auto t = sell.top();\\n                    sell.pop();\\n                    if(t.second<x[1]){\\n                        \\n                        buy.push({x[0],x[1]-t.second});\\n                        x[1] = x[1] - t.second;//decrease the size of remaining items as well\\n                        \\n                    }\\n                    else{\\n                        sell.push({t.first,t.second-x[1]});\\n                        x[1] = 0;//all the items got finished\\n                    }\\n                }\\n                \\n                \\n                    \\n                \\n                \\n            }\\n            \\n            if(x[2]==1){\\n                \\n                int flag=0;\\n                sell.push({x[0],x[1]});\\n                while(buy.size()>0 && buy.top().first>=x[0] && x[1]>0){\\n                    flag=1;\\n                    auto t = buy.top();\\n                    sell.pop();\\n                    buy.pop();\\n                    if(t.second<x[1]){\\n                        \\n                        sell.push({x[0],x[1]-t.second});\\n                        x[1]= x[1] -t.second;//decrement the remaining item\\n                    }\\n                    else{\\n                        buy.push({t.first,t.second-x[1]});\\n                        x[1] = 0;//all the item got finished\\n                    }\\n                }\\n                \\n                \\n                    \\n                \\n                \\n            }\\n            \\n        }\\n\\t\\t//now count the number of items remaining in the queues;\\n        int count =0;\\n        while(buy.size()){\\n            \\n            count = (count + buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        \\n         while(sell.size()){\\n            \\n            count = (count + sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```\\n\\n**Hit like if you liked:: ,, Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<pair<int,int>,vector<pair<int,int>> > buy; //max queue for buy\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >sell;//min queue for sell\\n        \\n        for(auto x:orders){\\n            \\n            if(x[2]==0){\\n                buy.push({x[0],x[1]});\\n                int flag=0;\\n                while(sell.size()>0 && sell.top().first<=x[0] && x[1]>0){\\n                    flag=1;\\n                    buy.pop();\\n                    auto t = sell.top();\\n                    sell.pop();\\n                    if(t.second<x[1]){\\n                        \\n                        buy.push({x[0],x[1]-t.second});\\n                        x[1] = x[1] - t.second;//decrease the size of remaining items as well\\n                        \\n                    }\\n                    else{\\n                        sell.push({t.first,t.second-x[1]});\\n                        x[1] = 0;//all the items got finished\\n                    }\\n                }\\n                \\n                \\n                    \\n                \\n                \\n            }\\n            \\n            if(x[2]==1){\\n                \\n                int flag=0;\\n                sell.push({x[0],x[1]});\\n                while(buy.size()>0 && buy.top().first>=x[0] && x[1]>0){\\n                    flag=1;\\n                    auto t = buy.top();\\n                    sell.pop();\\n                    buy.pop();\\n                    if(t.second<x[1]){\\n                        \\n                        sell.push({x[0],x[1]-t.second});\\n                        x[1]= x[1] -t.second;//decrement the remaining item\\n                    }\\n                    else{\\n                        buy.push({t.first,t.second-x[1]});\\n                        x[1] = 0;//all the item got finished\\n                    }\\n                }\\n                \\n                \\n                    \\n                \\n                \\n            }\\n            \\n        }\\n\\t\\t//now count the number of items remaining in the queues;\\n        int count =0;\\n        while(buy.size()){\\n            \\n            count = (count + buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        \\n         while(sell.size()){\\n            \\n            count = (count + sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348780,
                "title": "c-196ms-99-two-maps",
                "content": "Runtime: 196 ms, faster than 98.82% of C++ online submissions for Number of Orders in the Backlog.\\nMemory Usage: 64.5 MB, less than 39.53% of C++ online submissions for Number of Orders in the Backlog.\\n```\\nclass Solution {\\npublic:\\n  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n    map<int, long> buy, sell;\\n    \\n    for(auto &it: orders) \\n      if(it[2]){                                             //buy\\n        auto b = buy.rbegin();\\n        while(b != buy.rend() && it[0] <= b->first){         //if we can buy\\n          it[1] -= b->second;\\n          if(it[1] <  0) {b->second = -it[1]; break;}\\n          \\n          int tmp = b->first; \\n          b++;                                          \\n          buy.erase(tmp);\\n          if(it[1] == 0) break;\\n        }\\n        if(it[1] > 0) sell[it[0]] += it[1];\\n      }\\n      else {                                                 //sell\\n        auto s = sell.begin();\\n        while(s != sell.end() && it[0] >= s->first){         //if we can sell\\n          it[1] -= s->second;\\n          if(it[1] <  0) {s->second = -it[1]; break;}\\n          \\n          int tmp = s->first;\\n          s++;\\n          sell.erase(tmp);\\n          if(it[1] == 0) break;\\n        }\\n        if(it[1] > 0) buy[it[0]] += it[1];\\n      } \\n      \\n    \\n    long answer = 0;\\n    for(auto &it: buy ) answer += it.second;\\n    for(auto &it: sell) answer += it.second;\\n    \\n    return answer % 1000000007;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n    map<int, long> buy, sell;\\n    \\n    for(auto &it: orders) \\n      if(it[2]){                                             //buy\\n        auto b = buy.rbegin();\\n        while(b != buy.rend() && it[0] <= b->first){         //if we can buy\\n          it[1] -= b->second;\\n          if(it[1] <  0) {b->second = -it[1]; break;}\\n          \\n          int tmp = b->first; \\n          b++;                                          \\n          buy.erase(tmp);\\n          if(it[1] == 0) break;\\n        }\\n        if(it[1] > 0) sell[it[0]] += it[1];\\n      }\\n      else {                                                 //sell\\n        auto s = sell.begin();\\n        while(s != sell.end() && it[0] >= s->first){         //if we can sell\\n          it[1] -= s->second;\\n          if(it[1] <  0) {s->second = -it[1]; break;}\\n          \\n          int tmp = s->first;\\n          s++;\\n          sell.erase(tmp);\\n          if(it[1] == 0) break;\\n        }\\n        if(it[1] > 0) buy[it[0]] += it[1];\\n      } \\n      \\n    \\n    long answer = 0;\\n    for(auto &it: buy ) answer += it.second;\\n    for(auto &it: sell) answer += it.second;\\n    \\n    return answer % 1000000007;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123048,
                "title": "java-priority-queue",
                "content": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<BO> pqBo = new PriorityQueue(new BOComp());\\n        PriorityQueue<SO> pqSo = new PriorityQueue(new SOComp());\\n        // IF BUY CHECK SMALLEST SELL, SELL SHOULD BE LESS\\n        // IF SELL CHECK LARGEST BUY, BUY SHOULD BE MORE\\n        for(int[] item : orders){\\n            boolean isBo = false;\\n            BO buyBlog = null;\\n            SO sellBlog = null;\\n            if(item[2] == 0){\\n                buyBlog = new BO(item[0], item[1]);\\n                if(pqSo.peek() == null){\\n                     pqBo.add(buyBlog);\\n                }else{\\n                    sellBlog = pqSo.poll();\\n                }\\n                isBo = true;\\n            }else{\\n                sellBlog = new SO(item[0], item[1]);\\n                if(pqBo.peek() == null){\\n                     pqSo.add(sellBlog);\\n                }else{\\n                    buyBlog = pqBo.poll();\\n                }\\n            }\\n            if(buyBlog == null || sellBlog == null) continue;\\n            if(isBo == true){\\n                if(sellBlog.getPrice() <= buyBlog.getPrice()){\\n                    if(sellBlog.getQty() >= buyBlog.getQty()){\\n                        sellBlog.setQty(sellBlog.getQty() - buyBlog.getQty());\\n                        if(sellBlog.getQty() > 0){\\n                            pqSo.add(sellBlog);\\n                        }\\n                    }else{\\n                        buyBlog.setQty(buyBlog.getQty() - sellBlog.getQty());\\n                        while(buyBlog.getQty() > 0 && pqSo.peek() != null && pqSo.peek().getPrice() <= buyBlog.getPrice()){\\n                            if(buyBlog.getQty() > pqSo.peek().getQty()){\\n                                buyBlog.setQty(buyBlog.getQty() - pqSo.poll().getQty());\\n                            }else{\\n                                pqSo.peek().setQty(pqSo.peek().getQty() - buyBlog.getQty() );\\n                                buyBlog.setQty(0);\\n                            }\\n                            \\n                        }\\n                        if(buyBlog.getQty() > 0){\\n                            pqBo.add(buyBlog);\\n                        }\\n                    }\\n                }else{\\n                    pqSo.add(sellBlog);\\n                    pqBo.add(buyBlog);\\n                }\\n            }else{\\n                \\n                if(sellBlog.getPrice() <= buyBlog.getPrice()){\\n                    if(sellBlog.getQty() >= buyBlog.getQty()){\\n                        sellBlog.setQty(sellBlog.getQty() - buyBlog.getQty());\\n                        \\n                        while(sellBlog.getQty() > 0 && pqBo.peek() != null && pqBo.peek().getPrice() >= sellBlog.getPrice()){\\n                            \\n                            if(sellBlog.getQty() > pqBo.peek().getQty()){\\n                                sellBlog.setQty(sellBlog.getQty() - pqBo.poll().getQty());\\n                            }else{\\n                                pqBo.peek().setQty(pqBo.peek().getQty() - sellBlog.getQty() );\\n                                sellBlog.setQty(0);\\n                            }\\n                            \\n                        }\\n                        \\n                        if(sellBlog.getQty() > 0){\\n                            pqSo.add(sellBlog);\\n                        }\\n                    }else{\\n                        buyBlog.setQty(buyBlog.getQty() - sellBlog.getQty());\\n                        if(buyBlog.getQty() > 0){\\n                            pqBo.add(buyBlog);\\n                        }\\n                    }\\n                }else{\\n                    pqBo.add(buyBlog);\\n                    pqSo.add(sellBlog);\\n                }\\n            }\\n        }\\n        BO buyBlog = null;\\n        SO sellBlog = null;\\n        int blogQty = 0;\\n        int max = (int )(Math.pow(10,9) + 7);\\n        while(!pqBo.isEmpty()){\\n            buyBlog = pqBo.poll();\\n            blogQty = (blogQty + buyBlog.getQty()) % max;\\n        }\\n        while(!pqSo.isEmpty()){\\n            sellBlog = pqSo.poll();\\n            blogQty = (blogQty + sellBlog.getQty()) % max;\\n        }\\n        return blogQty;\\n    }\\n    \\n}\\n\\nclass BO {\\n    private int price;\\n    private int qty;\\n    public BO(int price, int qty){\\n        this.price = price;\\n        this.qty = qty;\\n    }\\n    public int getPrice(){\\n        return this.price;\\n    }\\n    public int getQty(){\\n        return this.qty;\\n    }\\n    public void setQty(int qty){\\n        this.qty = qty;\\n    }\\n    @Override\\n    public String toString(){\\n        return \"Price is \" + this.getPrice() + \" Qty is \" + this.getQty();\\n    }\\n}\\n\\nclass SO {\\n    private int price;\\n    private int qty;\\n    public SO(int price, int qty){\\n        this.price = price;\\n        this.qty = qty;\\n    }\\n    public int getPrice(){\\n        return this.price;\\n    }\\n    public int getQty(){\\n        return this.qty;\\n    }\\n    public void setQty(int qty){\\n        this.qty = qty;\\n    }\\n    @Override\\n    public String toString(){\\n        return \"Price is \" + this.getPrice() + \" Qty is \" + this.getQty();\\n    }\\n}\\n\\nclass BOComp implements Comparator<BO>{\\n    public int compare(BO itemA,BO itemB){\\n        return itemA.getPrice() < itemB.getPrice()? 1: -1;\\n    }\\n}\\n\\nclass SOComp implements Comparator<SO>{\\n    public int compare(SO itemA,SO itemB){\\n        return itemA.getPrice() > itemB.getPrice()? 1: -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<BO> pqBo = new PriorityQueue(new BOComp());\\n        PriorityQueue<SO> pqSo = new PriorityQueue(new SOComp());\\n        // IF BUY CHECK SMALLEST SELL, SELL SHOULD BE LESS\\n        // IF SELL CHECK LARGEST BUY, BUY SHOULD BE MORE\\n        for(int[] item : orders){\\n            boolean isBo = false;\\n            BO buyBlog = null;\\n            SO sellBlog = null;\\n            if(item[2] == 0){\\n                buyBlog = new BO(item[0], item[1]);\\n                if(pqSo.peek() == null){\\n                     pqBo.add(buyBlog);\\n                }else{\\n                    sellBlog = pqSo.poll();\\n                }\\n                isBo = true;\\n            }else{\\n                sellBlog = new SO(item[0], item[1]);\\n                if(pqBo.peek() == null){\\n                     pqSo.add(sellBlog);\\n                }else{\\n                    buyBlog = pqBo.poll();\\n                }\\n            }\\n            if(buyBlog == null || sellBlog == null) continue;\\n            if(isBo == true){\\n                if(sellBlog.getPrice() <= buyBlog.getPrice()){\\n                    if(sellBlog.getQty() >= buyBlog.getQty()){\\n                        sellBlog.setQty(sellBlog.getQty() - buyBlog.getQty());\\n                        if(sellBlog.getQty() > 0){\\n                            pqSo.add(sellBlog);\\n                        }\\n                    }else{\\n                        buyBlog.setQty(buyBlog.getQty() - sellBlog.getQty());\\n                        while(buyBlog.getQty() > 0 && pqSo.peek() != null && pqSo.peek().getPrice() <= buyBlog.getPrice()){\\n                            if(buyBlog.getQty() > pqSo.peek().getQty()){\\n                                buyBlog.setQty(buyBlog.getQty() - pqSo.poll().getQty());\\n                            }else{\\n                                pqSo.peek().setQty(pqSo.peek().getQty() - buyBlog.getQty() );\\n                                buyBlog.setQty(0);\\n                            }\\n                            \\n                        }\\n                        if(buyBlog.getQty() > 0){\\n                            pqBo.add(buyBlog);\\n                        }\\n                    }\\n                }else{\\n                    pqSo.add(sellBlog);\\n                    pqBo.add(buyBlog);\\n                }\\n            }else{\\n                \\n                if(sellBlog.getPrice() <= buyBlog.getPrice()){\\n                    if(sellBlog.getQty() >= buyBlog.getQty()){\\n                        sellBlog.setQty(sellBlog.getQty() - buyBlog.getQty());\\n                        \\n                        while(sellBlog.getQty() > 0 && pqBo.peek() != null && pqBo.peek().getPrice() >= sellBlog.getPrice()){\\n                            \\n                            if(sellBlog.getQty() > pqBo.peek().getQty()){\\n                                sellBlog.setQty(sellBlog.getQty() - pqBo.poll().getQty());\\n                            }else{\\n                                pqBo.peek().setQty(pqBo.peek().getQty() - sellBlog.getQty() );\\n                                sellBlog.setQty(0);\\n                            }\\n                            \\n                        }\\n                        \\n                        if(sellBlog.getQty() > 0){\\n                            pqSo.add(sellBlog);\\n                        }\\n                    }else{\\n                        buyBlog.setQty(buyBlog.getQty() - sellBlog.getQty());\\n                        if(buyBlog.getQty() > 0){\\n                            pqBo.add(buyBlog);\\n                        }\\n                    }\\n                }else{\\n                    pqBo.add(buyBlog);\\n                    pqSo.add(sellBlog);\\n                }\\n            }\\n        }\\n        BO buyBlog = null;\\n        SO sellBlog = null;\\n        int blogQty = 0;\\n        int max = (int )(Math.pow(10,9) + 7);\\n        while(!pqBo.isEmpty()){\\n            buyBlog = pqBo.poll();\\n            blogQty = (blogQty + buyBlog.getQty()) % max;\\n        }\\n        while(!pqSo.isEmpty()){\\n            sellBlog = pqSo.poll();\\n            blogQty = (blogQty + sellBlog.getQty()) % max;\\n        }\\n        return blogQty;\\n    }\\n    \\n}\\n\\nclass BO {\\n    private int price;\\n    private int qty;\\n    public BO(int price, int qty){\\n        this.price = price;\\n        this.qty = qty;\\n    }\\n    public int getPrice(){\\n        return this.price;\\n    }\\n    public int getQty(){\\n        return this.qty;\\n    }\\n    public void setQty(int qty){\\n        this.qty = qty;\\n    }\\n    @Override\\n    public String toString(){\\n        return \"Price is \" + this.getPrice() + \" Qty is \" + this.getQty();\\n    }\\n}\\n\\nclass SO {\\n    private int price;\\n    private int qty;\\n    public SO(int price, int qty){\\n        this.price = price;\\n        this.qty = qty;\\n    }\\n    public int getPrice(){\\n        return this.price;\\n    }\\n    public int getQty(){\\n        return this.qty;\\n    }\\n    public void setQty(int qty){\\n        this.qty = qty;\\n    }\\n    @Override\\n    public String toString(){\\n        return \"Price is \" + this.getPrice() + \" Qty is \" + this.getQty();\\n    }\\n}\\n\\nclass BOComp implements Comparator<BO>{\\n    public int compare(BO itemA,BO itemB){\\n        return itemA.getPrice() < itemB.getPrice()? 1: -1;\\n    }\\n}\\n\\nclass SOComp implements Comparator<SO>{\\n    public int compare(SO itemA,SO itemB){\\n        return itemA.getPrice() > itemB.getPrice()? 1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121545,
                "title": "c-sortedset-o-n-logn-time",
                "content": "SortedSet works as a priority queue here. SortedSet.Min, SortedSet.Max, SortedSet.Add and SortedSet.Remove methods take LogN time each which leads to O(NLogN) time complexity overall.\\nWe need method AddOrder because SortedSet doesn\\'t allow to store duplicates.\\n```\\npublic class Solution\\n{\\n    public int GetNumberOfBacklogOrders(int[][] orders)\\n    {\\n        var buyQueue = new SortedSet<Tuple<int, int>>();\\n        var sellQueue = new SortedSet<Tuple<int, int>>();\\n        for (int i = 0; i < orders.Length; i++)\\n        {\\n            var price = orders[i][0];\\n            var amount = orders[i][1];\\n            if (orders[i][2] == 0)\\n            {\\n                while (amount > 0 && sellQueue.Count > 0)\\n                {\\n                    var min = sellQueue.Min;\\n                    var minPrice = min.Item1;\\n                    if (minPrice > price)\\n                        break;\\n                    amount = DecreaseAmount(amount, sellQueue, min);\\n                }\\n                if (amount > 0)\\n                    AddOrder(price, amount, buyQueue);\\n            }\\n            else\\n            {\\n                while (amount > 0 && buyQueue.Count > 0)\\n                {\\n                    var max = buyQueue.Max;\\n                    var maxPrice = max.Item1;\\n                    if (maxPrice < price)\\n                        break;\\n                    amount = DecreaseAmount(amount, buyQueue, max);\\n                }\\n                if (amount > 0)\\n                    AddOrder(price, amount, sellQueue);\\n            }\\n        }\\n        var result = 0;\\n        foreach (var item in buyQueue)\\n            result = (result + item.Item2) % (int)(1e9 + 7);\\n        foreach (var item in sellQueue)\\n            result = (result + item.Item2) % (int)(1e9 + 7);\\n        return result;\\n    }\\n    \\n    private int DecreaseAmount(int amount, SortedSet<Tuple<int, int>> queue, Tuple<int, int> order)\\n    {\\n        queue.Remove(order);\\n        var orderPrice = order.Item1;\\n        var orderAmount = order.Item2;\\n        if (orderAmount > amount)\\n        {\\n            AddOrder(orderPrice, orderAmount - amount, queue);\\n            return 0;\\n        }\\n        return amount - orderAmount;\\n    }\\n    \\n    private void AddOrder(int price, int amount, SortedSet<Tuple<int, int>> queue)\\n    {\\n        var order = Tuple.Create(price, amount);\\n        while (queue.Contains(order))\\n        {\\n            queue.Remove(order);\\n            order = Tuple.Create(price, order.Item2 * 2);\\n        }\\n        queue.Add(order);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int GetNumberOfBacklogOrders(int[][] orders)\\n    {\\n        var buyQueue = new SortedSet<Tuple<int, int>>();\\n        var sellQueue = new SortedSet<Tuple<int, int>>();\\n        for (int i = 0; i < orders.Length; i++)\\n        {\\n            var price = orders[i][0];\\n            var amount = orders[i][1];\\n            if (orders[i][2] == 0)\\n            {\\n                while (amount > 0 && sellQueue.Count > 0)\\n                {\\n                    var min = sellQueue.Min;\\n                    var minPrice = min.Item1;\\n                    if (minPrice > price)\\n                        break;\\n                    amount = DecreaseAmount(amount, sellQueue, min);\\n                }\\n                if (amount > 0)\\n                    AddOrder(price, amount, buyQueue);\\n            }\\n            else\\n            {\\n                while (amount > 0 && buyQueue.Count > 0)\\n                {\\n                    var max = buyQueue.Max;\\n                    var maxPrice = max.Item1;\\n                    if (maxPrice < price)\\n                        break;\\n                    amount = DecreaseAmount(amount, buyQueue, max);\\n                }\\n                if (amount > 0)\\n                    AddOrder(price, amount, sellQueue);\\n            }\\n        }\\n        var result = 0;\\n        foreach (var item in buyQueue)\\n            result = (result + item.Item2) % (int)(1e9 + 7);\\n        foreach (var item in sellQueue)\\n            result = (result + item.Item2) % (int)(1e9 + 7);\\n        return result;\\n    }\\n    \\n    private int DecreaseAmount(int amount, SortedSet<Tuple<int, int>> queue, Tuple<int, int> order)\\n    {\\n        queue.Remove(order);\\n        var orderPrice = order.Item1;\\n        var orderAmount = order.Item2;\\n        if (orderAmount > amount)\\n        {\\n            AddOrder(orderPrice, orderAmount - amount, queue);\\n            return 0;\\n        }\\n        return amount - orderAmount;\\n    }\\n    \\n    private void AddOrder(int price, int amount, SortedSet<Tuple<int, int>> queue)\\n    {\\n        var order = Tuple.Create(price, amount);\\n        while (queue.Contains(order))\\n        {\\n            queue.Remove(order);\\n            order = Tuple.Create(price, order.Item2 * 2);\\n        }\\n        queue.Add(order);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121199,
                "title": "java-solution-with-priority-queue",
                "content": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        Queue<int[]> buyBacklog = new PriorityQueue<>((a,b) -> b[0]-a[0]);\\n        Queue<int[]> sellBacklog = new PriorityQueue<>((a,b) -> a[0]-b[0]);\\n        \\n        \\n        \\n        for(int[] order: orders) {\\n            if(order[2] == 0) { // buy\\n                while (!sellBacklog.isEmpty() && sellBacklog.peek()[0] <= order[0]) {\\n                    int [] minSell = sellBacklog.peek();\\n                    \\n                    if(minSell[1] > order[1]) {\\n                        // more to sell than buy\\n                        minSell[1] -= order[1];\\n                        order[1] = 0;\\n                        break;\\n                    } else if(minSell[1] == order[1]) {\\n                        // buy quantity and sell quantity are same\\n                        sellBacklog.remove();\\n                        order[1] = 0;\\n                        break;\\n                    } else{\\n                        // buy more quantity than this batch has to sell\\n                        order[1] -= minSell[1];\\n                        sellBacklog.remove();\\n                    }\\n                } // while\\n                if(order[1] > 0) {\\n                    buyBacklog.add(order);\\n                }\\n            } else { // sell\\n                while(!buyBacklog.isEmpty() && buyBacklog.peek()[0] >= order[0]) {\\n                    int[] maxBuy = buyBacklog.peek();\\n                    \\n                    if(maxBuy[1] > order[1]) {\\n                        // more buy than sell\\n                        maxBuy[1] -= order[1];\\n                        order[1] = 0;\\n                        break;\\n                    } else if (maxBuy[1] == order[1]) {\\n                        // equal buy and sell\\n                        order[1] = 0;\\n                        buyBacklog.remove();\\n                        break;\\n                    } else {\\n                        // less to buy than sell\\n                        order[1] -= maxBuy[1];\\n                        buyBacklog.remove();\\n                    }\\n                } // while\\n                if(order[1] > 0) {\\n                    sellBacklog.add(order);\\n                }\\n            }\\n        } // for\\n        long batch = 0;\\n        \\n        for(int[] buy: buyBacklog) batch = (batch+buy[1])%mod;\\n        for(int[] sell: sellBacklog) batch = (batch+sell[1])%mod;\\n        \\n        return (int) batch;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int mod = 1000000007;\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        Queue<int[]> buyBacklog = new PriorityQueue<>((a,b) -> b[0]-a[0]);\\n        Queue<int[]> sellBacklog = new PriorityQueue<>((a,b) -> a[0]-b[0]);\\n        \\n        \\n        \\n        for(int[] order: orders) {\\n            if(order[2] == 0) { // buy\\n                while (!sellBacklog.isEmpty() && sellBacklog.peek()[0] <= order[0]) {\\n                    int [] minSell = sellBacklog.peek();\\n                    \\n                    if(minSell[1] > order[1]) {\\n                        // more to sell than buy\\n                        minSell[1] -= order[1];\\n                        order[1] = 0;\\n                        break;\\n                    } else if(minSell[1] == order[1]) {\\n                        // buy quantity and sell quantity are same\\n                        sellBacklog.remove();\\n                        order[1] = 0;\\n                        break;\\n                    } else{\\n                        // buy more quantity than this batch has to sell\\n                        order[1] -= minSell[1];\\n                        sellBacklog.remove();\\n                    }\\n                } // while\\n                if(order[1] > 0) {\\n                    buyBacklog.add(order);\\n                }\\n            } else { // sell\\n                while(!buyBacklog.isEmpty() && buyBacklog.peek()[0] >= order[0]) {\\n                    int[] maxBuy = buyBacklog.peek();\\n                    \\n                    if(maxBuy[1] > order[1]) {\\n                        // more buy than sell\\n                        maxBuy[1] -= order[1];\\n                        order[1] = 0;\\n                        break;\\n                    } else if (maxBuy[1] == order[1]) {\\n                        // equal buy and sell\\n                        order[1] = 0;\\n                        buyBacklog.remove();\\n                        break;\\n                    } else {\\n                        // less to buy than sell\\n                        order[1] -= maxBuy[1];\\n                        buyBacklog.remove();\\n                    }\\n                } // while\\n                if(order[1] > 0) {\\n                    sellBacklog.add(order);\\n                }\\n            }\\n        } // for\\n        long batch = 0;\\n        \\n        for(int[] buy: buyBacklog) batch = (batch+buy[1])%mod;\\n        for(int[] sell: sellBacklog) batch = (batch+sell[1])%mod;\\n        \\n        return (int) batch;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120215,
                "title": "java-runtime-and-memory-100",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public void insert(int elem, ArrayList<Integer> backlog, int[][] orders) {\\n        int left = 0, right = backlog.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (orders[elem][0] > orders[backlog.get(mid)][0])\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        backlog.add(left, elem);\\n    }\\n    \\n    public void buy(int i, ArrayList<Integer> buy_backlog, ArrayList<Integer> sell_backlog, int[][] orders) {\\n        while (orders[i][1] > 0 && sell_backlog.size() > 0) {\\n            int min_sell = sell_backlog.get(0);\\n            if (orders[min_sell][0] > orders[i][0]) break;\\n        \\n            int delete = Math.min(orders[min_sell][1], orders[i][1]);\\n            orders[min_sell][1] -= delete;\\n            orders[i][1] -= delete;\\n            if (orders[min_sell][1] == 0) sell_backlog.remove(0);\\n        }\\n                \\n        if (orders[i][1] != 0) insert(i, buy_backlog, orders);\\n    }\\n    \\n    public void sell(int i, ArrayList<Integer> buy_backlog, ArrayList<Integer> sell_backlog, int[][] orders) {\\n        while (orders[i][1] > 0 && buy_backlog.size() > 0) {\\n            int n = buy_backlog.size() - 1;\\n            int max_buy = buy_backlog.get(n);\\n            if (orders[max_buy][0] < orders[i][0]) break;\\n        \\n            int delete = Math.min(orders[max_buy][1], orders[i][1]);\\n            orders[max_buy][1] -= delete;\\n            orders[i][1] -= delete;\\n            if (orders[max_buy][1] == 0) buy_backlog.remove(n);\\n        }\\n        if (orders[i][1] != 0) insert(i, sell_backlog, orders);\\n    }\\n\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        ArrayList<Integer> buy_backlog = new ArrayList<>();\\n        ArrayList<Integer> sell_backlog = new ArrayList<>();\\n\\n        for (int i=0; i<orders.length; i++) {\\n            if (orders[i][2] == 0)\\n                buy(i, buy_backlog, sell_backlog, orders);\\n            else\\n                sell(i, buy_backlog, sell_backlog, orders);\\n        }\\n        \\n        int ct = 0;\\n        for (int i : buy_backlog) ct = (ct + orders[i][1]) % MOD;\\n        for (int i : sell_backlog) ct = (ct + orders[i][1]) % MOD;\\n        \\n        return ct;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public void insert(int elem, ArrayList<Integer> backlog, int[][] orders) {\\n        int left = 0, right = backlog.size();\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (orders[elem][0] > orders[backlog.get(mid)][0])\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        backlog.add(left, elem);\\n    }\\n    \\n    public void buy(int i, ArrayList<Integer> buy_backlog, ArrayList<Integer> sell_backlog, int[][] orders) {\\n        while (orders[i][1] > 0 && sell_backlog.size() > 0) {\\n            int min_sell = sell_backlog.get(0);\\n            if (orders[min_sell][0] > orders[i][0]) break;\\n        \\n            int delete = Math.min(orders[min_sell][1], orders[i][1]);\\n            orders[min_sell][1] -= delete;\\n            orders[i][1] -= delete;\\n            if (orders[min_sell][1] == 0) sell_backlog.remove(0);\\n        }\\n                \\n        if (orders[i][1] != 0) insert(i, buy_backlog, orders);\\n    }\\n    \\n    public void sell(int i, ArrayList<Integer> buy_backlog, ArrayList<Integer> sell_backlog, int[][] orders) {\\n        while (orders[i][1] > 0 && buy_backlog.size() > 0) {\\n            int n = buy_backlog.size() - 1;\\n            int max_buy = buy_backlog.get(n);\\n            if (orders[max_buy][0] < orders[i][0]) break;\\n        \\n            int delete = Math.min(orders[max_buy][1], orders[i][1]);\\n            orders[max_buy][1] -= delete;\\n            orders[i][1] -= delete;\\n            if (orders[max_buy][1] == 0) buy_backlog.remove(n);\\n        }\\n        if (orders[i][1] != 0) insert(i, sell_backlog, orders);\\n    }\\n\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        ArrayList<Integer> buy_backlog = new ArrayList<>();\\n        ArrayList<Integer> sell_backlog = new ArrayList<>();\\n\\n        for (int i=0; i<orders.length; i++) {\\n            if (orders[i][2] == 0)\\n                buy(i, buy_backlog, sell_backlog, orders);\\n            else\\n                sell(i, buy_backlog, sell_backlog, orders);\\n        }\\n        \\n        int ct = 0;\\n        for (int i : buy_backlog) ct = (ct + orders[i][1]) % MOD;\\n        for (int i : sell_backlog) ct = (ct + orders[i][1]) % MOD;\\n        \\n        return ct;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120051,
                "title": "java-priorityqueue-simple-and-straightforward",
                "content": "Idea is very simple. Maintain a min heap for sell backlogs and maxHeap for buy backlogs.\\nWhen order is sell order we will tye to fullfill it from buy backlog with making sure conditions are met and vice versa.\\n\\nAt the end go through both the backlogs and compute total backlogs orders\\n\\nMore commets and explaination inline\\n```\\n public int getNumberOfBacklogOrders(int[][] orders) {        \\n\\t\\tQueue<int[]> sellBacklog = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n\\t\\tQueue<int[]> buyBacklog = new PriorityQueue<int[]>((a, b) -> b[0] - a[0]);\\n\\n\\t\\tfor (int[] order : orders) {\\n\\t\\t\\tint price = order[0], amt = order[1], type = order[2];\\n\\t\\t\\tif (type == 0) { // buy order\\n\\t\\t\\t\\twhile (!sellBacklog.isEmpty() && sellBacklog.peek()[0] <= price && amt > 0) {\\n\\t\\t\\t\\t\\tif (sellBacklog.peek()[1] > amt) {\\n\\t\\t\\t\\t\\t\\t// we have more than required for current buy order so update this sell order and this order is fully completed\\n\\t\\t\\t\\t\\t\\tsellBacklog.peek()[1] -= amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// this whole sell order will be used to fullfil this buy order\\n\\t\\t\\t\\t\\t\\tamt -= sellBacklog.remove()[1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we still have few more order to fullfil so add it to buy backlog\\n\\t\\t\\t\\tif (amt > 0) {\\n\\t\\t\\t\\t\\tbuyBacklog.add(new int[] { price, amt });\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else { // sell order\\n\\t\\t\\t\\twhile (!buyBacklog.isEmpty() && buyBacklog.peek()[0] >= price && amt > 0) {\\n\\t\\t\\t\\t\\tif (buyBacklog.peek()[1] > amt) {\\n\\t\\t\\t\\t\\t\\t// we have more than required for current sell order so update this buy order and this sell order is fully completed\\n\\t\\t\\t\\t\\t\\tbuyBacklog.peek()[1] -= amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// this whole buy order will be used to fullfil current sell order\\n\\t\\t\\t\\t\\t\\tamt -= buyBacklog.remove()[1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we still have few more order to fullfil so add it to sell backlog\\n\\t\\t\\t\\tif (amt > 0) {\\n\\t\\t\\t\\t\\tsellBacklog.add(new int[] { price, amt });\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n       // compute total backlog\\n\\t\\tlong result = 0;\\n\\t\\tfor (int[] order : sellBacklog) result += order[1];\\t\\t\\n\\t\\tfor (int[] order : buyBacklog) result += order[1];\\n\\t\\t\\n\\t\\treturn (int)(result % 1000000007);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int getNumberOfBacklogOrders(int[][] orders) {        \\n\\t\\tQueue<int[]> sellBacklog = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\\n\\t\\tQueue<int[]> buyBacklog = new PriorityQueue<int[]>((a, b) -> b[0] - a[0]);\\n\\n\\t\\tfor (int[] order : orders) {\\n\\t\\t\\tint price = order[0], amt = order[1], type = order[2];\\n\\t\\t\\tif (type == 0) { // buy order\\n\\t\\t\\t\\twhile (!sellBacklog.isEmpty() && sellBacklog.peek()[0] <= price && amt > 0) {\\n\\t\\t\\t\\t\\tif (sellBacklog.peek()[1] > amt) {\\n\\t\\t\\t\\t\\t\\t// we have more than required for current buy order so update this sell order and this order is fully completed\\n\\t\\t\\t\\t\\t\\tsellBacklog.peek()[1] -= amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// this whole sell order will be used to fullfil this buy order\\n\\t\\t\\t\\t\\t\\tamt -= sellBacklog.remove()[1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we still have few more order to fullfil so add it to buy backlog\\n\\t\\t\\t\\tif (amt > 0) {\\n\\t\\t\\t\\t\\tbuyBacklog.add(new int[] { price, amt });\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else { // sell order\\n\\t\\t\\t\\twhile (!buyBacklog.isEmpty() && buyBacklog.peek()[0] >= price && amt > 0) {\\n\\t\\t\\t\\t\\tif (buyBacklog.peek()[1] > amt) {\\n\\t\\t\\t\\t\\t\\t// we have more than required for current sell order so update this buy order and this sell order is fully completed\\n\\t\\t\\t\\t\\t\\tbuyBacklog.peek()[1] -= amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// this whole buy order will be used to fullfil current sell order\\n\\t\\t\\t\\t\\t\\tamt -= buyBacklog.remove()[1];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we still have few more order to fullfil so add it to sell backlog\\n\\t\\t\\t\\tif (amt > 0) {\\n\\t\\t\\t\\t\\tsellBacklog.add(new int[] { price, amt });\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n       // compute total backlog\\n\\t\\tlong result = 0;\\n\\t\\tfor (int[] order : sellBacklog) result += order[1];\\t\\t\\n\\t\\tfor (int[] order : buyBacklog) result += order[1];\\n\\t\\t\\n\\t\\treturn (int)(result % 1000000007);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120032,
                "title": "the-example-to-practice-dry",
                "content": "\\n```\\nclass Order {\\npublic:\\n    int price;\\n    int amount;\\n};\\n\\nenum COMP { GREATER, LESS };\\n\\ntemplate <COMP op>\\nclass OrderComp {\\npublic:\\n    bool operator() (const Order& lhs, const Order& rhs) {\\n        if (op == GREATER) {\\n            return lhs.price > rhs.price;\\n        }\\n        return lhs.price < rhs.price;\\n    }\\n};\\n\\n\\nclass Solution {\\nprivate:\\n    template<typename T1, typename T2>\\n    void processOrder(T1& q1, T2& q2, COMP op, int price, int amount, string n1=\"q1\", string n2=\"q2\") {\\n        if (q2.size() == 0) {\\n            q1.push(Order{price, amount});\\n            return;\\n        }\\n        \\n        while(!q2.empty() && amount > 0  ){\\n            Order order = q2.top(); \\n            if (op == GREATER && order.price > price ) break;\\n            if (op == LESS && order.price < price) break;\\n\\n            q2.pop();\\n            //cout << \"=> deQueue(\"<< n2 << \"): \" << order.price << \", \"<< order.amount << endl;\\n\\n            int amt = min(order.amount, amount);\\n            order.amount -= amt;\\n            amount -= amt;\\n            if (order.amount > 0) {\\n                //cout << \"<= enQueue(\"<< n2 <<\"): \" << order.price << \", \"<< order.amount << endl;\\n                q2.push(order);\\n            }\\n        }\\n        if (amount > 0) {\\n            //cout << \"<= enQueue(\"<< n1 <<\"): \" << price << \", \"<< amount << endl;\\n            q1.push(Order{price, amount});\\n        }\\n    }\\n    \\n    template<typename T>\\n    void countQ(T& q, int& amount){\\n        while(!q.empty()) {\\n            amount = (amount + q.top().amount) % 1000000007;\\n            q.pop();\\n        }\\n    }\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<Order, vector<Order>, OrderComp<GREATER>> sell;\\n        priority_queue<Order, vector<Order>, OrderComp<LESS>> buy;\\n        \\n        for (auto& order : orders) {\\n            int& price = order[0];\\n            int& amount = order[1];\\n            \\n            if (order[2] == 0)  { //buy order\\n                processOrder(buy, sell, GREATER, price, amount, \"buy\", \"sell\");\\n            }else { // sell order\\n                processOrder(sell, buy, LESS, price, amount, \"sell\", \"buy\");\\n            }\\n        }\\n        \\n        int amount = 0;\\n        countQ(sell, amount);\\n        countQ(buy, amount);\\n        return amount ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Order {\\npublic:\\n    int price;\\n    int amount;\\n};\\n\\nenum COMP { GREATER, LESS };\\n\\ntemplate <COMP op>\\nclass OrderComp {\\npublic:\\n    bool operator() (const Order& lhs, const Order& rhs) {\\n        if (op == GREATER) {\\n            return lhs.price > rhs.price;\\n        }\\n        return lhs.price < rhs.price;\\n    }\\n};\\n\\n\\nclass Solution {\\nprivate:\\n    template<typename T1, typename T2>\\n    void processOrder(T1& q1, T2& q2, COMP op, int price, int amount, string n1=\"q1\", string n2=\"q2\") {\\n        if (q2.size() == 0) {\\n            q1.push(Order{price, amount});\\n            return;\\n        }\\n        \\n        while(!q2.empty() && amount > 0  ){\\n            Order order = q2.top(); \\n            if (op == GREATER && order.price > price ) break;\\n            if (op == LESS && order.price < price) break;\\n\\n            q2.pop();\\n            //cout << \"=> deQueue(\"<< n2 << \"): \" << order.price << \", \"<< order.amount << endl;\\n\\n            int amt = min(order.amount, amount);\\n            order.amount -= amt;\\n            amount -= amt;\\n            if (order.amount > 0) {\\n                //cout << \"<= enQueue(\"<< n2 <<\"): \" << order.price << \", \"<< order.amount << endl;\\n                q2.push(order);\\n            }\\n        }\\n        if (amount > 0) {\\n            //cout << \"<= enQueue(\"<< n1 <<\"): \" << price << \", \"<< amount << endl;\\n            q1.push(Order{price, amount});\\n        }\\n    }\\n    \\n    template<typename T>\\n    void countQ(T& q, int& amount){\\n        while(!q.empty()) {\\n            amount = (amount + q.top().amount) % 1000000007;\\n            q.pop();\\n        }\\n    }\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<Order, vector<Order>, OrderComp<GREATER>> sell;\\n        priority_queue<Order, vector<Order>, OrderComp<LESS>> buy;\\n        \\n        for (auto& order : orders) {\\n            int& price = order[0];\\n            int& amount = order[1];\\n            \\n            if (order[2] == 0)  { //buy order\\n                processOrder(buy, sell, GREATER, price, amount, \"buy\", \"sell\");\\n            }else { // sell order\\n                processOrder(sell, buy, LESS, price, amount, \"sell\", \"buy\");\\n            }\\n        }\\n        \\n        int amount = 0;\\n        countQ(sell, amount);\\n        countQ(buy, amount);\\n        return amount ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1120018,
                "title": "javascript-2-heap-solution-w-explanation",
                "content": "```javascript\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const buyHeap = new Heap((child, parent) => child.price > parent.price)\\n    const sellHeap = new Heap((child, parent) => child.price < parent.price)\\n    \\n    for (let [price, amount, orderType] of orders) {\\n        \\n        // sell\\n        if (orderType) {\\n            \\n            // while there are amount to be decremented from the sell,\\n            // orders to in the buy backlog, and the price of the largest\\n            // price is greater than the sell price decrement the\\n            // amount of the order with the largest price by the amount\\n            while (amount > 0 && buyHeap.peak() && buyHeap.peak().price >= price) {\\n                if (buyHeap.peak().amount > amount) {\\n                    buyHeap.peak().amount -= amount\\n                    amount = 0\\n                } else {\\n                    amount -= buyHeap.pop().amount\\n                }\\n            }\\n            \\n            // if there is any amount left, add it to the sale backlog\\n            if (amount) {\\n                sellHeap.push({ price, amount })\\n            }\\n\\n        // buy\\n        } else {\\n            \\n            // while there are amount to be decremented from the buy,\\n            // orders to in the sell backlog, and the price of the smallest\\n            // price is less than the buy price decrement the\\n            // amount of the order with the smallest price by the amount\\n            while (amount > 0 && sellHeap.peak() && sellHeap.peak().price <= price) {\\n                if (sellHeap.peak().amount > amount) {\\n                    sellHeap.peak().amount -= amount\\n                    amount = 0\\n                } else {\\n                    amount -= sellHeap.pop().amount;\\n                }\\n            }\\n            \\n            // if there is any amount left, add it to the buy backlog\\n            if (amount) {\\n                buyHeap.push({ price, amount })\\n            }\\n        }\\n    }\\n    \\n    // total all of the amounts in both backlogs and return the result\\n    let accumultiveAmount = 0;\\n    for (const { amount } of buyHeap.store) {\\n        accumultiveAmount += amount;\\n    }\\n    for (const { amount } of sellHeap.store) {\\n        accumultiveAmount += amount;\\n    }\\n    return accumultiveAmount % 1000000007\\n};\\n\\nclass Heap {\\n    constructor(fn) {\\n        this.store = [];\\n        this.fn = fn;\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        return child && this.fn(this.store[child], this.store[parent]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const buyHeap = new Heap((child, parent) => child.price > parent.price)\\n    const sellHeap = new Heap((child, parent) => child.price < parent.price)\\n    \\n    for (let [price, amount, orderType] of orders) {\\n        \\n        // sell\\n        if (orderType) {\\n            \\n            // while there are amount to be decremented from the sell,\\n            // orders to in the buy backlog, and the price of the largest\\n            // price is greater than the sell price decrement the\\n            // amount of the order with the largest price by the amount\\n            while (amount > 0 && buyHeap.peak() && buyHeap.peak().price >= price) {\\n                if (buyHeap.peak().amount > amount) {\\n                    buyHeap.peak().amount -= amount\\n                    amount = 0\\n                } else {\\n                    amount -= buyHeap.pop().amount\\n                }\\n            }\\n            \\n            // if there is any amount left, add it to the sale backlog\\n            if (amount) {\\n                sellHeap.push({ price, amount })\\n            }\\n\\n        // buy\\n        } else {\\n            \\n            // while there are amount to be decremented from the buy,\\n            // orders to in the sell backlog, and the price of the smallest\\n            // price is less than the buy price decrement the\\n            // amount of the order with the smallest price by the amount\\n            while (amount > 0 && sellHeap.peak() && sellHeap.peak().price <= price) {\\n                if (sellHeap.peak().amount > amount) {\\n                    sellHeap.peak().amount -= amount\\n                    amount = 0\\n                } else {\\n                    amount -= sellHeap.pop().amount;\\n                }\\n            }\\n            \\n            // if there is any amount left, add it to the buy backlog\\n            if (amount) {\\n                buyHeap.push({ price, amount })\\n            }\\n        }\\n    }\\n    \\n    // total all of the amounts in both backlogs and return the result\\n    let accumultiveAmount = 0;\\n    for (const { amount } of buyHeap.store) {\\n        accumultiveAmount += amount;\\n    }\\n    for (const { amount } of sellHeap.store) {\\n        accumultiveAmount += amount;\\n    }\\n    return accumultiveAmount % 1000000007\\n};\\n\\nclass Heap {\\n    constructor(fn) {\\n        this.store = [];\\n        this.fn = fn;\\n    }\\n    \\n    peak() {\\n        return this.store[0];\\n    }\\n    \\n    size() {\\n        return this.store.length;\\n    }\\n    \\n    pop() {\\n        if (this.store.length < 2) {\\n            return this.store.pop();\\n        }\\n        const result = this.store[0];\\n        this.store[0] = this.store.pop();\\n        this.heapifyDown(0);\\n        return result;\\n    }\\n    \\n    push(val) {\\n        this.store.push(val);\\n        this.heapifyUp(this.store.length - 1);\\n    }\\n    \\n    heapifyUp(child) {\\n        while (child) {\\n            const parent = Math.floor((child - 1) / 2);\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                child = parent;\\n            } else {\\n                return child;\\n            }\\n        }\\n    }\\n    \\n    heapifyDown(parent) {\\n        while (true) {\\n            let [child, child2] = [1,2].map((x) => parent * 2 + x).filter((x) => x < this.size());\\n            if (this.shouldSwap(child2, child)) {\\n                child = child2\\n            }\\n            if (this.shouldSwap(child, parent)) {\\n                [this.store[child], this.store[parent]] = [this.store[parent], this.store[child]]\\n                parent = child;\\n            } else {\\n                return parent;\\n            }\\n        }\\n    }\\n    \\n    shouldSwap(child, parent) {\\n        return child && this.fn(this.store[child], this.store[parent]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119864,
                "title": "python-3-heap-and-dictionary",
                "content": "We use two heaps:\\n```logBuy``` is storing MINUS prices, because we will need the highest price first.\\n```logSell``` is storing prices, because we will need the lowest price first.\\n\\nWe use two dictonaries:\\n```dictBuy[k]``` is number of prices ```-k``` in ```Buy Backlog```\\n```dictSell[k]``` is number of prices ```k``` in ```Sell Backlog```\\n\\nFirst we are iterating over ```orders``` and updating heaps and dictionaries.\\nFinally we are counting, how many items is in Backlogs and return that value.\\n\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        logBuy=[]\\n        dictBuy={}\\n        logSell=[]\\n        dictSell={}\\n        #   price,amount,type\\n        for p,a,t in orders:\\n            if t: # type=1 = SELL\\n                dictSell[p]=dictSell.get(p,0) + a\\n                heapq.heappush(logSell,p) \\n            else: # type=0 = BUY\\n                dictBuy[-p]=dictBuy.get(-p,0) + a\\n                heapq.heappush(logBuy,-p)\\n            ok=1\\n            while ok and logBuy and logSell:\\n                ok=0\\n                buy=heapq.heappop(logBuy)\\n                sell=heapq.heappop(logSell)\\n                b=dictBuy[buy]\\n                s=dictSell[sell]\\n                if b and s and -buy>=sell:\\n                    ok=1\\n                    amount=min(b,s)\\n                    dictBuy[buy]-=amount\\n                    dictSell[sell]-=amount\\n                if dictBuy[buy]:\\n                    heapq.heappush(logBuy,buy)\\n                if dictSell[sell]:\\n                    heapq.heappush(logSell,sell)                        \\n        return (sum(v for k,v in dictBuy.items()) + sum(v for k,v in dictSell.items())) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```logBuy```\n```logSell```\n```dictBuy[k]```\n```-k```\n```Buy Backlog```\n```dictSell[k]```\n```k```\n```Sell Backlog```\n```orders```\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        logBuy=[]\\n        dictBuy={}\\n        logSell=[]\\n        dictSell={}\\n        #   price,amount,type\\n        for p,a,t in orders:\\n            if t: # type=1 = SELL\\n                dictSell[p]=dictSell.get(p,0) + a\\n                heapq.heappush(logSell,p) \\n            else: # type=0 = BUY\\n                dictBuy[-p]=dictBuy.get(-p,0) + a\\n                heapq.heappush(logBuy,-p)\\n            ok=1\\n            while ok and logBuy and logSell:\\n                ok=0\\n                buy=heapq.heappop(logBuy)\\n                sell=heapq.heappop(logSell)\\n                b=dictBuy[buy]\\n                s=dictSell[sell]\\n                if b and s and -buy>=sell:\\n                    ok=1\\n                    amount=min(b,s)\\n                    dictBuy[buy]-=amount\\n                    dictSell[sell]-=amount\\n                if dictBuy[buy]:\\n                    heapq.heappush(logBuy,buy)\\n                if dictSell[sell]:\\n                    heapq.heappush(logSell,sell)                        \\n        return (sum(v for k,v in dictBuy.items()) + sum(v for k,v in dictSell.items())) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119853,
                "title": "c-map-solution-question-explained",
                "content": "The description of the question is quite difficult to understand. I\\'ll put it in an easier way:\\n\\n1. when you buy (stock), you buy from the lowest sell orders up to your limit price, until everything available is exhausted;\\n2. when you sell (stock), you sell to the highest buy orders to until your own limit price, until everything higher (or equal) than your limit price is exhausted.\\n\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {        \\n        map<int, long> buys, sells;\\n        for (auto& order : orders) {\\n            if (order[2] == 0) { // buy order\\n                int amount = order[1];\\n                while (amount > 0 && !sells.empty() && sells.begin()->first <= order[0]) {\\n                    auto it = sells.begin();\\n                    int have = it->second;\\n                    it->second -= amount;\\n                    amount -= have;\\n                    if (it->second <= 0) {\\n                        sells.erase(it);\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    if (buys.find(order[0]) == buys.end()) {\\n                        buys[order[0]] = amount;\\n                    } else {\\n                        buys[order[0]] += amount;\\n                    }\\n                } \\n            } else { // sell order\\n                int amount = order[1];\\n                while (amount > 0 && !buys.empty() && buys.rbegin()->first >= order[0]) {\\n                    auto it = prev(buys.end());\\n                    int have = it->second;\\n                    it->second -= amount;\\n                    amount -= have;\\n                    if (it->second <= 0) {\\n                        buys.erase(it);\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    if (sells.find(order[0]) == sells.end()) {\\n                        sells[order[0]] = amount;\\n                    } else {\\n                        sells[order[0]] += amount;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0, MOD = 1000000007;\\n        for (auto it = buys.begin(); it != buys.end(); it++) {\\n            res += it->second;\\n            res %= MOD;\\n        }\\n        \\n        for (auto it = sells.begin(); it != sells.end(); it++) {\\n            res += it->second;\\n            res %= MOD;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {        \\n        map<int, long> buys, sells;\\n        for (auto& order : orders) {\\n            if (order[2] == 0) { // buy order\\n                int amount = order[1];\\n                while (amount > 0 && !sells.empty() && sells.begin()->first <= order[0]) {\\n                    auto it = sells.begin();\\n                    int have = it->second;\\n                    it->second -= amount;\\n                    amount -= have;\\n                    if (it->second <= 0) {\\n                        sells.erase(it);\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    if (buys.find(order[0]) == buys.end()) {\\n                        buys[order[0]] = amount;\\n                    } else {\\n                        buys[order[0]] += amount;\\n                    }\\n                } \\n            } else { // sell order\\n                int amount = order[1];\\n                while (amount > 0 && !buys.empty() && buys.rbegin()->first >= order[0]) {\\n                    auto it = prev(buys.end());\\n                    int have = it->second;\\n                    it->second -= amount;\\n                    amount -= have;\\n                    if (it->second <= 0) {\\n                        buys.erase(it);\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    if (sells.find(order[0]) == sells.end()) {\\n                        sells[order[0]] = amount;\\n                    } else {\\n                        sells[order[0]] += amount;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int res = 0, MOD = 1000000007;\\n        for (auto it = buys.begin(); it != buys.end(); it++) {\\n            res += it->second;\\n            res %= MOD;\\n        }\\n        \\n        for (auto it = sells.begin(); it != sells.end(); it++) {\\n            res += it->second;\\n            res %= MOD;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119776,
                "title": "python3-simple-solution-with-priority-queue-100-time-space-efficiency",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        \\n        for order in orders:\\n            if order[2] == 0:\\n                while len(sell) > 0:\\n                    if 0 >= len(sell) or 0 == order[1]: break\\n\\n                    se = heapq.heappop(sell)\\n                    if order[0] >= se[0]:\\n                        t = min(order[1], se[1])\\n                        order[1] -= t\\n                        se[1] -= t\\n                        \\n                        if se[1] != 0:\\n                            heapq.heappush(sell, se)\\n                            break\\n                    else:\\n                        heapq.heappush(sell, se)\\n                        break\\n                \\n                if order[1] != 0:\\n                    order[0] = -order[0]\\n                    heapq.heappush(buy, order)\\n                \\n            else:\\n                while len(buy) > 0:\\n                    if 0 >= len(buy) or 0 == order[1]: break\\n                    \\n                    bu = heapq.heappop(buy)\\n                    if order[0] <= (bu[0] * -1):\\n                        t = min(order[1], bu[1])\\n                        order[1] -= t\\n                        bu[1] -= t\\n                        \\n                        if bu[1] != 0:\\n                            heapq.heappush(buy, bu)\\n                            break\\n                    else:\\n                        heapq.heappush(buy, bu)\\n                        break\\n                \\n                if order[1] != 0:\\n                    heapq.heappush(sell, order)\\n\\n\\n        x = 0        \\n        for b in buy:\\n            x += b[1]\\n            x %= (1000000000 + 7)\\n            \\n        for s in sell:\\n            x += s[1]\\n            x %= (1000000000 + 7)\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        \\n        for order in orders:\\n            if order[2] == 0:\\n                while len(sell) > 0:\\n                    if 0 >= len(sell) or 0 == order[1]: break\\n\\n                    se = heapq.heappop(sell)\\n                    if order[0] >= se[0]:\\n                        t = min(order[1], se[1])\\n                        order[1] -= t\\n                        se[1] -= t\\n                        \\n                        if se[1] != 0:\\n                            heapq.heappush(sell, se)\\n                            break\\n                    else:\\n                        heapq.heappush(sell, se)\\n                        break\\n                \\n                if order[1] != 0:\\n                    order[0] = -order[0]\\n                    heapq.heappush(buy, order)\\n                \\n            else:\\n                while len(buy) > 0:\\n                    if 0 >= len(buy) or 0 == order[1]: break\\n                    \\n                    bu = heapq.heappop(buy)\\n                    if order[0] <= (bu[0] * -1):\\n                        t = min(order[1], bu[1])\\n                        order[1] -= t\\n                        bu[1] -= t\\n                        \\n                        if bu[1] != 0:\\n                            heapq.heappush(buy, bu)\\n                            break\\n                    else:\\n                        heapq.heappush(buy, bu)\\n                        break\\n                \\n                if order[1] != 0:\\n                    heapq.heappush(sell, order)\\n\\n\\n        x = 0        \\n        for b in buy:\\n            x += b[1]\\n            x %= (1000000000 + 7)\\n            \\n        for s in sell:\\n            x += s[1]\\n            x %= (1000000000 + 7)\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119731,
                "title": "c-priority-queue",
                "content": "\\n\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        std::priority_queue<vector<int>, vector<vector<int>>> buy;\\n        auto cmp = [](vector<int>& a, vector<int>& b) {return a[0] > b[0];};\\n        std::priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> sell(cmp);\\n        int mod = 1e9 + 7;\\n        for(auto& o : orders) {\\n            if (o[2] == 0) { // buy option, looking for smallest in sell queue, the price has to be <= \\n                \\n                int price = o[0];\\n                int amount = o[1];\\n                \\n                while(!sell.empty() && amount > 0) {\\n                    auto cur = sell.top();\\n                    \\n                    if (cur[0] <= o[0]) {\\n                        int cnt = cur[1];\\n                        \\n                        if (cnt >= amount) {\\n                            cnt -= amount;\\n                            amount = 0;\\n                            sell.pop();\\n                            if (cnt > 0) {\\n                                sell.push({cur[0], cnt, 1});\\n                            }\\n                        } else {\\n                            amount -= cnt;\\n                            sell.pop();\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    buy.push({price, amount, 0});\\n                    amount = 0;\\n                }\\n                \\n            } else { // sell, looking for larest buy, >= \\n                int price = o[0];\\n                int amount = o[1];\\n                \\n                while(!buy.empty() && amount > 0) {\\n                    auto cur = buy.top();\\n                    \\n                    if (cur[0] >= price) {\\n                        int cnt = cur[1];\\n                        \\n                        if (cnt >= amount) {\\n                            cnt -= amount;\\n                            amount = 0;\\n                            buy.pop();\\n                            if (cnt > 0) {\\n                                buy.push({cur[0], cnt, 0});\\n                            }\\n                        } else {\\n                            amount -= cnt;\\n                            buy.pop();\\n                        }\\n                        \\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    sell.push({price, amount, 1});\\n                    amount = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        while(!buy.empty()) {\\n            auto cur = buy.top();\\n            buy.pop();\\n            \\n            res += cur[1];\\n        }\\n        \\n        while(!sell.empty()) {\\n            auto cur = sell.top();\\n            sell.pop();\\n            \\n            res += cur[1];\\n        }\\n        \\n        return res % mod;\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        std::priority_queue<vector<int>, vector<vector<int>>> buy;\\n        auto cmp = [](vector<int>& a, vector<int>& b) {return a[0] > b[0];};\\n        std::priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> sell(cmp);\\n        int mod = 1e9 + 7;\\n        for(auto& o : orders) {\\n            if (o[2] == 0) { // buy option, looking for smallest in sell queue, the price has to be <= \\n                \\n                int price = o[0];\\n                int amount = o[1];\\n                \\n                while(!sell.empty() && amount > 0) {\\n                    auto cur = sell.top();\\n                    \\n                    if (cur[0] <= o[0]) {\\n                        int cnt = cur[1];\\n                        \\n                        if (cnt >= amount) {\\n                            cnt -= amount;\\n                            amount = 0;\\n                            sell.pop();\\n                            if (cnt > 0) {\\n                                sell.push({cur[0], cnt, 1});\\n                            }\\n                        } else {\\n                            amount -= cnt;\\n                            sell.pop();\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    buy.push({price, amount, 0});\\n                    amount = 0;\\n                }\\n                \\n            } else { // sell, looking for larest buy, >= \\n                int price = o[0];\\n                int amount = o[1];\\n                \\n                while(!buy.empty() && amount > 0) {\\n                    auto cur = buy.top();\\n                    \\n                    if (cur[0] >= price) {\\n                        int cnt = cur[1];\\n                        \\n                        if (cnt >= amount) {\\n                            cnt -= amount;\\n                            amount = 0;\\n                            buy.pop();\\n                            if (cnt > 0) {\\n                                buy.push({cur[0], cnt, 0});\\n                            }\\n                        } else {\\n                            amount -= cnt;\\n                            buy.pop();\\n                        }\\n                        \\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                if (amount > 0) {\\n                    sell.push({price, amount, 1});\\n                    amount = 0;\\n                }\\n                \\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        while(!buy.empty()) {\\n            auto cur = buy.top();\\n            buy.pop();\\n            \\n            res += cur[1];\\n        }\\n        \\n        while(!sell.empty()) {\\n            auto cur = sell.top();\\n            sell.pop();\\n            \\n            res += cur[1];\\n        }\\n        \\n        return res % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1119700,
                "title": "typescript-skew-heap",
                "content": "I like Skew Heap. It\\'s much simpler than usual healps and easy to customise.\\n\\n```typescript\\nconst MOD = 10 ** 9 + 7;\\n\\nclass Node {\\n    constructor(\\n        public price: number,\\n        public amount: number,\\n        public left: Node | null = null,\\n        public right: Node | null = null\\n    ) { };\\n}\\n\\n// Skew Heap\\nfunction meld(a: Node | null, b: Node | null, maxheap: boolean): Node | null {\\n    if (!a) return b;\\n    if (!b) return a;\\n    const cmp: boolean = maxheap ? a.price < b.price : a.price > b.price\\n    if (cmp) [b, a] = [a, b];\\t\\t\\n    a.right = meld(a.right, b, maxheap);\\n    [a.left, a.right] = [a.right, a.left];\\n    return a;\\n}\\n\\nfunction getNumberOfBacklogOrders(orders: number[][]): number {\\n    let buyBacklog: Node | null = null;\\n    let sellBacklog: Node | null = null;\\n\\n    for (let [price, amount, orderType] of orders) {\\n        if (orderType == 0) {\\n            // buy order\\n            while (amount > 0) {\\n                if (!sellBacklog || sellBacklog.price > price) {\\n                    buyBacklog = meld(buyBacklog, new Node(price, amount), true);\\n                    break;\\n                }\\n                else {\\n                    const am = Math.min(amount, sellBacklog.amount);\\n                    amount -= am;\\n                    const cur = new Node(sellBacklog.price, sellBacklog.amount - am);\\n                    sellBacklog = meld(sellBacklog.left, sellBacklog.right, false)\\n                    if (cur.amount > 0) {\\n                        sellBacklog = meld(sellBacklog, cur, false);\\n                    }\\n                }\\n            }\\n        } else if (orderType == 1) {\\n            // sell order\\n            while (amount > 0) {\\n                if (!buyBacklog || buyBacklog.price < price) {\\n                    sellBacklog = meld(sellBacklog, new Node(price, amount), false);\\n                    break;\\n                }\\n                else {\\n                    const am = Math.min(amount, buyBacklog.amount);\\n                    amount -= am;\\n                    const cur = new Node(buyBacklog.price, buyBacklog.amount - am);\\n                    buyBacklog = meld(buyBacklog.left, buyBacklog.right, true)\\n                    if (cur.amount > 0) {\\n                        buyBacklog = meld(buyBacklog, cur, true);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // console.log({ buyBacklog, sellBacklog })\\n\\n    const countHeap = (n: Node | null): number => {\\n        if (!n) return 0;\\n        let amount = n.amount;\\n        amount += countHeap(n.left) + countHeap(n.right);\\n        amount %= MOD;\\n        return amount;\\n    }\\n\\n    return (countHeap(buyBacklog) + countHeap(sellBacklog)) % MOD;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```typescript\\nconst MOD = 10 ** 9 + 7;\\n\\nclass Node {\\n    constructor(\\n        public price: number,\\n        public amount: number,\\n        public left: Node | null = null,\\n        public right: Node | null = null\\n    ) { };\\n}\\n\\n// Skew Heap\\nfunction meld(a: Node | null, b: Node | null, maxheap: boolean): Node | null {\\n    if (!a) return b;\\n    if (!b) return a;\\n    const cmp: boolean = maxheap ? a.price < b.price : a.price > b.price\\n    if (cmp) [b, a] = [a, b];\\t\\t\\n    a.right = meld(a.right, b, maxheap);\\n    [a.left, a.right] = [a.right, a.left];\\n    return a;\\n}\\n\\nfunction getNumberOfBacklogOrders(orders: number[][]): number {\\n    let buyBacklog: Node | null = null;\\n    let sellBacklog: Node | null = null;\\n\\n    for (let [price, amount, orderType] of orders) {\\n        if (orderType == 0) {\\n            // buy order\\n            while (amount > 0) {\\n                if (!sellBacklog || sellBacklog.price > price) {\\n                    buyBacklog = meld(buyBacklog, new Node(price, amount), true);\\n                    break;\\n                }\\n                else {\\n                    const am = Math.min(amount, sellBacklog.amount);\\n                    amount -= am;\\n                    const cur = new Node(sellBacklog.price, sellBacklog.amount - am);\\n                    sellBacklog = meld(sellBacklog.left, sellBacklog.right, false)\\n                    if (cur.amount > 0) {\\n                        sellBacklog = meld(sellBacklog, cur, false);\\n                    }\\n                }\\n            }\\n        } else if (orderType == 1) {\\n            // sell order\\n            while (amount > 0) {\\n                if (!buyBacklog || buyBacklog.price < price) {\\n                    sellBacklog = meld(sellBacklog, new Node(price, amount), false);\\n                    break;\\n                }\\n                else {\\n                    const am = Math.min(amount, buyBacklog.amount);\\n                    amount -= am;\\n                    const cur = new Node(buyBacklog.price, buyBacklog.amount - am);\\n                    buyBacklog = meld(buyBacklog.left, buyBacklog.right, true)\\n                    if (cur.amount > 0) {\\n                        buyBacklog = meld(buyBacklog, cur, true);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    // console.log({ buyBacklog, sellBacklog })\\n\\n    const countHeap = (n: Node | null): number => {\\n        if (!n) return 0;\\n        let amount = n.amount;\\n        amount += countHeap(n.left) + countHeap(n.right);\\n        amount %= MOD;\\n        return amount;\\n    }\\n\\n    return (countHeap(buyBacklog) + countHeap(sellBacklog)) % MOD;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119665,
                "title": "c-priority-queue-solution",
                "content": "The problem description is really confusing.\\n\\n**Intuition**:\\n\\nDo what the description states.\\n\\nUsing a priority queue to store buy and sell respectively, sell sorted from smallest to largest, buy sorted from largest to smallest.\\n\\nA very important insight is that do not store individual orders, instead, store the **number of orders** in that particular amount in total.\\n\\nThen every time grab the top element and compare.\\n\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        // value, amount (buy smallest in sell, sell largest in buy), sell sorted from smallest to largest, buy sorted from largest to smallest\\n        long ans = 0;\\n        priority_queue<pair<int,long>, vector<pair<int,long>>, greater<pair<int,long>>> sell;\\n        priority_queue<pair<int,long>> buy;\\n        for(vector<int> order:orders){\\n            if(order[2]){\\n                if(buy.empty() || buy.top().first < order[0]){\\n                    sell.push(make_pair(order[0],order[1]));\\n                    continue;\\n                }\\n                while(!buy.empty() && order[1] > 0 && buy.top().first >= order[0]){\\n                    if(buy.top().second >= order[1]){\\n                        pair<int,long> cur = buy.top();\\n                        cur.second -= order[1];\\n                        buy.pop();\\n                        buy.push(cur);\\n                        order[1] = 0;\\n                        break;\\n                    }\\n                    order[1] -= buy.top().second;\\n                    buy.pop();\\n                }\\n                if(order[1] > 0) sell.push(make_pair(order[0],order[1]));\\n            } else{\\n                if(sell.empty() || sell.top().first > order[0]){\\n                    buy.push(make_pair(order[0],order[1]));\\n                    continue;\\n                }\\n                while(!sell.empty() && order[1] > 0 && sell.top().first <= order[0]){\\n                    if(sell.top().second >= order[1]){\\n                        pair<int,long> cur = sell.top();\\n                        cur.second -= order[1];\\n                        sell.pop();\\n                        sell.push(cur); \\n                        order[1] = 0;\\n                        break;\\n                    }\\n                    order[1] -= sell.top().second;\\n                    sell.pop();\\n                }\\n                if(order[1] > 0) buy.push(make_pair(order[0],order[1]));\\n            }\\n        }\\n        while(!sell.empty()){\\n            ans += sell.top().second; sell.pop();\\n        }\\n        ans %= 1000000007;\\n        while(!buy.empty()){\\n            ans += buy.top().second; buy.pop();\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        // value, amount (buy smallest in sell, sell largest in buy), sell sorted from smallest to largest, buy sorted from largest to smallest\\n        long ans = 0;\\n        priority_queue<pair<int,long>, vector<pair<int,long>>, greater<pair<int,long>>> sell;\\n        priority_queue<pair<int,long>> buy;\\n        for(vector<int> order:orders){\\n            if(order[2]){\\n                if(buy.empty() || buy.top().first < order[0]){\\n                    sell.push(make_pair(order[0],order[1]));\\n                    continue;\\n                }\\n                while(!buy.empty() && order[1] > 0 && buy.top().first >= order[0]){\\n                    if(buy.top().second >= order[1]){\\n                        pair<int,long> cur = buy.top();\\n                        cur.second -= order[1];\\n                        buy.pop();\\n                        buy.push(cur);\\n                        order[1] = 0;\\n                        break;\\n                    }\\n                    order[1] -= buy.top().second;\\n                    buy.pop();\\n                }\\n                if(order[1] > 0) sell.push(make_pair(order[0],order[1]));\\n            } else{\\n                if(sell.empty() || sell.top().first > order[0]){\\n                    buy.push(make_pair(order[0],order[1]));\\n                    continue;\\n                }\\n                while(!sell.empty() && order[1] > 0 && sell.top().first <= order[0]){\\n                    if(sell.top().second >= order[1]){\\n                        pair<int,long> cur = sell.top();\\n                        cur.second -= order[1];\\n                        sell.pop();\\n                        sell.push(cur); \\n                        order[1] = 0;\\n                        break;\\n                    }\\n                    order[1] -= sell.top().second;\\n                    sell.pop();\\n                }\\n                if(order[1] > 0) buy.push(make_pair(order[0],order[1]));\\n            }\\n        }\\n        while(!sell.empty()){\\n            ans += sell.top().second; sell.pop();\\n        }\\n        ans %= 1000000007;\\n        while(!buy.empty()){\\n            ans += buy.top().second; buy.pop();\\n        }\\n        return ans % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119660,
                "title": "min-and-max-heap",
                "content": "\\tclass Solution(object):\\n\\t\\tdef getNumberOfBacklogOrders(self, orders):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type orders: List[List[int]]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tbuy = []\\n\\t\\t\\tsell = []\\n\\t\\t\\tfor i in range(len(orders)):\\n\\t\\t\\t\\torder = orders[i]\\n\\t\\t\\t\\tif order[2] == 0:\\n\\t\\t\\t\\t\\twhile sell and sell[0][0] <= order[0] and order[1] > 0:\\n\\t\\t\\t\\t\\t\\tnode = heapq.heappop(sell)\\n\\t\\t\\t\\t\\t\\tif node[1] >= order[1]:\\n\\t\\t\\t\\t\\t\\t\\tnode[1] -= order[1]\\n\\t\\t\\t\\t\\t\\t\\torder[1] = 0\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(sell, ([node[0], node[1]]))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\torder[1] -= node[1]\\n\\t\\t\\t\\t\\tif order[1] > 0:\\n\\t\\t\\t\\t\\t\\theapq.heappush(buy, ([-order[0], order[1]]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\twhile buy and abs(buy[0][0]) >= order[0] and order[1] > 0:\\n\\t\\t\\t\\t\\t\\tnode = heapq.heappop(buy)\\n\\t\\t\\t\\t\\t\\tif node[1] >= order[1]:\\n\\t\\t\\t\\t\\t\\t\\tnode[1] -= order[1]\\n\\t\\t\\t\\t\\t\\t\\torder[1] = 0\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(buy, ([node[0], node[1]]))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\torder[1] -= node[1]\\n\\t\\t\\t\\t\\tif order[1] > 0:\\n\\t\\t\\t\\t\\t\\theapq.heappush(sell, ([order[0], order[1]]))\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor a, b in buy:\\n\\t\\t\\t\\tres += b\\n\\t\\t\\tfor a, b in sell:\\n\\t\\t\\t\\tres += b\\n\\t\\t\\treturn res % (10**9 + 7)",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef getNumberOfBacklogOrders(self, orders):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type orders: List[List[int]]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tbuy = []\\n\\t\\t\\tsell = []\\n\\t\\t\\tfor i in range(len(orders)):\\n\\t\\t\\t\\torder = orders[i]\\n\\t\\t\\t\\tif order[2] == 0:\\n\\t\\t\\t\\t\\twhile sell and sell[0][0] <= order[0] and order[1] > 0:\\n\\t\\t\\t\\t\\t\\tnode = heapq.heappop(sell)\\n\\t\\t\\t\\t\\t\\tif node[1] >= order[1]:\\n\\t\\t\\t\\t\\t\\t\\tnode[1] -= order[1]\\n\\t\\t\\t\\t\\t\\t\\torder[1] = 0\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(sell, ([node[0], node[1]]))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\torder[1] -= node[1]\\n\\t\\t\\t\\t\\tif order[1] > 0:\\n\\t\\t\\t\\t\\t\\theapq.heappush(buy, ([-order[0], order[1]]))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\twhile buy and abs(buy[0][0]) >= order[0] and order[1] > 0:\\n\\t\\t\\t\\t\\t\\tnode = heapq.heappop(buy)\\n\\t\\t\\t\\t\\t\\tif node[1] >= order[1]:\\n\\t\\t\\t\\t\\t\\t\\tnode[1] -= order[1]\\n\\t\\t\\t\\t\\t\\t\\torder[1] = 0\\n\\t\\t\\t\\t\\t\\t\\theapq.heappush(buy, ([node[0], node[1]]))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\torder[1] -= node[1]\\n\\t\\t\\t\\t\\tif order[1] > 0:\\n\\t\\t\\t\\t\\t\\theapq.heappush(sell, ([order[0], order[1]]))\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor a, b in buy:\\n\\t\\t\\t\\tres += b\\n\\t\\t\\tfor a, b in sell:\\n\\t\\t\\t\\tres += b\\n\\t\\t\\treturn res % (10**9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 4083730,
                "title": "python-maxheap-for-buy-backlog-minheap-for-sell-backlog",
                "content": "As the problem statement says, if there is a Buy order, we want to quickly get the sell order with the smallest price currently in the backlog, if it exists. If the price of that sell order is <= the price of buy order, we can execute the order. Again, it is not necessary that all the buy orders get executed with the smallest sell order in the backlog. It is possible that only some orders get executed and in that case, we then have to quickly get the next smallest sell order and do the same thing until we can no longer execute further or if all orders are executed.\\n\\nSimilarly, in case of a sell order, we want to quickly get the buy order with the smallest price currently in the backlog, if it exists. If the price of that buy order is >= the price of sell order, we can execute the order. Again, it is not necessary that all the sell orders get executed with the largest buy order in the backlog. It is possible that only some orders get executed and in that case, we then have to quickly get the next largest buy order and do the same thing until we can no longer execute further or if all orders are executed.\\n\\nTo quickly get the Smallest Sell Order at any time, we can use a minHeap for the Sell Backlog.\\n\\nSimilarly, to get the largest buy order at any time, we use a maxHeap for the Buy Backlog.\\n\\nThe rest is pretty straightforward.\\n\\n\\n```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # We want a maxHeap for the buy backlog and a minHeap for the sell backlog\\n        buyBacklog = []\\n        sellBacklog = []\\n        \\n        # Go over the orders\\n        for price,amount,orderType in orders:\\n            \\n            # If the order is a buy order\\n            if orderType == 0:\\n                \\n                # The order on top of sellBacklog will have the smallest price\\n                # So, if the price of that sell order is <= price of the current buy order\\n                while sellBacklog and sellBacklog[0][0] <= price:\\n                    top = heappop(sellBacklog)\\n                    \\n                    # Execute the order accordingly\\n                    if amount > top[1]:\\n                        amount -= top[1]\\n                    else:\\n                        top[1] -= amount\\n                        amount = 0\\n                        heappush(sellBacklog, top)\\n                        break\\n                \\n                # If we couldn\\'t execute all the Buy orders, put the remaining orders in the buyBacklog\\n                if amount > 0: heappush(buyBacklog, [-price,amount,orderType])\\n\\n            # If the order is a sell order\\n            else:\\n                \\n                # The order on top of buyBacklog will have the largest price\\n                # So, if the price of that buy order is >= price of the current sell order\\n                while buyBacklog and -buyBacklog[0][0] >= price:\\n                    top = heappop(buyBacklog)\\n                    \\n                    # Execute the order accordingly\\n                    if amount > top[1]:\\n                        amount -= top[1]\\n                    else:\\n                        top[1] -= amount\\n                        amount = 0\\n                        heappush(buyBacklog, top)\\n                        break\\n                        \\n                # If we couldn\\'t execute all the Sell orders, put the remaining orders in the sellBacklog\\n                if amount > 0: heappush(sellBacklog, [price,amount,orderType])\\n                    \\n        # How many orders are left in backlog\\n        ordersLeft = 0\\n        \\n        while buyBacklog: ordersLeft += heappop(buyBacklog)[1]\\n        while sellBacklog: ordersLeft += heappop(sellBacklog)[1]\\n        \\n        # Finally, return the Number of orders left in the backlog\\n        return ordersLeft % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        # Mod\\n        mod = 10**9 + 7\\n        \\n        # We want a maxHeap for the buy backlog and a minHeap for the sell backlog\\n        buyBacklog = []\\n        sellBacklog = []\\n        \\n        # Go over the orders\\n        for price,amount,orderType in orders:\\n            \\n            # If the order is a buy order\\n            if orderType == 0:\\n                \\n                # The order on top of sellBacklog will have the smallest price\\n                # So, if the price of that sell order is <= price of the current buy order\\n                while sellBacklog and sellBacklog[0][0] <= price:\\n                    top = heappop(sellBacklog)\\n                    \\n                    # Execute the order accordingly\\n                    if amount > top[1]:\\n                        amount -= top[1]\\n                    else:\\n                        top[1] -= amount\\n                        amount = 0\\n                        heappush(sellBacklog, top)\\n                        break\\n                \\n                # If we couldn\\'t execute all the Buy orders, put the remaining orders in the buyBacklog\\n                if amount > 0: heappush(buyBacklog, [-price,amount,orderType])\\n\\n            # If the order is a sell order\\n            else:\\n                \\n                # The order on top of buyBacklog will have the largest price\\n                # So, if the price of that buy order is >= price of the current sell order\\n                while buyBacklog and -buyBacklog[0][0] >= price:\\n                    top = heappop(buyBacklog)\\n                    \\n                    # Execute the order accordingly\\n                    if amount > top[1]:\\n                        amount -= top[1]\\n                    else:\\n                        top[1] -= amount\\n                        amount = 0\\n                        heappush(buyBacklog, top)\\n                        break\\n                        \\n                # If we couldn\\'t execute all the Sell orders, put the remaining orders in the sellBacklog\\n                if amount > 0: heappush(sellBacklog, [price,amount,orderType])\\n                    \\n        # How many orders are left in backlog\\n        ordersLeft = 0\\n        \\n        while buyBacklog: ordersLeft += heappop(buyBacklog)[1]\\n        while sellBacklog: ordersLeft += heappop(sellBacklog)[1]\\n        \\n        # Finally, return the Number of orders left in the backlog\\n        return ordersLeft % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4070654,
                "title": "rust-binary-heap-oop-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\nconst MOD: usize = 1_000_000_007;\\n\\nuse std::collections::BinaryHeap as MaxHeap;\\nuse std::cmp::Reverse as Rev;\\n\\n#[derive(Default, Debug)]\\npub struct Backlog {\\n    heap_int: MaxHeap<(u32, usize)>,\\n    heap_ext: MaxHeap<Rev<(u32, usize)>>,\\n}\\n\\nimpl Backlog {\\n    pub fn buy(&mut self, weight: u32, count: usize) {\\n        if count < 1 { return; } // fulfilled\\n\\n        if self.heap_ext.peek()\\n            .map(|&Rev((w0, _))| w0)\\n            .unwrap_or(u32::MAX) > weight {\\n            return self.heap_int.push((weight, count));\\n        }\\n\\n        let Rev((w0, c0)) = self.heap_ext.pop().unwrap();\\n        if c0 > count { self.heap_ext.push(Rev((w0, c0 - count))); }\\n        \\n        let count_next = count - c0.min(count);\\n        self.buy(weight, count_next);\\n    }\\n\\n    pub fn sell(&mut self, weight: u32, count: usize) {\\n        if count < 1 { return; } // fulfilled\\n\\n        if self.heap_int.peek()\\n            .map(|&(w0, _)| w0)\\n            .unwrap_or(u32::MIN) < weight {\\n            return self.heap_ext.push(Rev((weight, count)));\\n        }\\n\\n        let (w0, c0) = self.heap_int.pop().unwrap();\\n        if c0 > count { self.heap_int.push((w0, c0 - count)); }\\n\\n        let count_next = count - c0.min(count);\\n        self.sell(weight, count_next);\\n    }\\n\\n    pub fn drain(self) -> usize {\\n        let mut ret = usize::MIN;\\n        for (_, count) in self.heap_int.into_iter() {\\n            ret += count;\\n            ret %= MOD;\\n        }\\n        for Rev((_, count)) in self.heap_ext.into_iter() {\\n            ret += count;\\n            ret %= MOD;\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\\n        let orders = orders.into_iter()\\n            .map(|v| (\\n                v[0] as u32,\\n                v[1] as usize,\\n                v[2] > 0,\\n            ))\\n            .collect::<Vec<_>>();\\n\\n        let mut backlog = Backlog::default();\\n        for (weight, mut count, type_id) in orders {\\n            if type_id {\\n                backlog.sell(weight, count);\\n            } else { backlog.buy(weight, count); }\\n        }\\n\\n        backlog.drain() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nconst MOD: usize = 1_000_000_007;\\n\\nuse std::collections::BinaryHeap as MaxHeap;\\nuse std::cmp::Reverse as Rev;\\n\\n#[derive(Default, Debug)]\\npub struct Backlog {\\n    heap_int: MaxHeap<(u32, usize)>,\\n    heap_ext: MaxHeap<Rev<(u32, usize)>>,\\n}\\n\\nimpl Backlog {\\n    pub fn buy(&mut self, weight: u32, count: usize) {\\n        if count < 1 { return; } // fulfilled\\n\\n        if self.heap_ext.peek()\\n            .map(|&Rev((w0, _))| w0)\\n            .unwrap_or(u32::MAX) > weight {\\n            return self.heap_int.push((weight, count));\\n        }\\n\\n        let Rev((w0, c0)) = self.heap_ext.pop().unwrap();\\n        if c0 > count { self.heap_ext.push(Rev((w0, c0 - count))); }\\n        \\n        let count_next = count - c0.min(count);\\n        self.buy(weight, count_next);\\n    }\\n\\n    pub fn sell(&mut self, weight: u32, count: usize) {\\n        if count < 1 { return; } // fulfilled\\n\\n        if self.heap_int.peek()\\n            .map(|&(w0, _)| w0)\\n            .unwrap_or(u32::MIN) < weight {\\n            return self.heap_ext.push(Rev((weight, count)));\\n        }\\n\\n        let (w0, c0) = self.heap_int.pop().unwrap();\\n        if c0 > count { self.heap_int.push((w0, c0 - count)); }\\n\\n        let count_next = count - c0.min(count);\\n        self.sell(weight, count_next);\\n    }\\n\\n    pub fn drain(self) -> usize {\\n        let mut ret = usize::MIN;\\n        for (_, count) in self.heap_int.into_iter() {\\n            ret += count;\\n            ret %= MOD;\\n        }\\n        for Rev((_, count)) in self.heap_ext.into_iter() {\\n            ret += count;\\n            ret %= MOD;\\n        }\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\\n        let orders = orders.into_iter()\\n            .map(|v| (\\n                v[0] as u32,\\n                v[1] as usize,\\n                v[2] > 0,\\n            ))\\n            .collect::<Vec<_>>();\\n\\n        let mut backlog = Backlog::default();\\n        for (weight, mut count, type_id) in orders {\\n            if type_id {\\n                backlog.sell(weight, count);\\n            } else { backlog.buy(weight, count); }\\n        }\\n\\n        backlog.drain() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025868,
                "title": "priority-queue-with-intuition-and-approach-explained",
                "content": "# Intuition\\nWe want to find a way to match the best sell orders with the best buy orders, and vice versa. Since this matching requires us to think about the \"minimum\" price of the sell orders, and the \"maximum\" price of the buy orders in the backlog, we know we should use some form of heap or priority queue in order to **think** about accessing the maximum/minimum sells/buy orders.\\n\\n# Approach\\nSo from reading this problem, I started by thinking about how I would count the amount of orders in the backlog, and how I would track these orders. So I started by keeping track of an `ans` variable, which allowed me to track the backlog amount. Each time I added something to the backlog, I would increment this variable, and each time I removed something I would decrement it.\\n\\nMoving on to actually handling the backlog, from reading the problem I determined how I should be programming the \"buy\" and \"sell\" order matching. Basically go through all the orders in the backlog, and try to match them with the current order. Once all of the possible orders have been matched, I would append the rest of the current order into it\\'s respective backlog.\\n\\nI think figured out the best storage system for the backlog to be a heap, since I needed to easily be able to pull minimums and maximums, while also adding data.\\n\\n# Complexity\\n- Time complexity: `O(n)` to loop through all the queries, and `O(log(n))` to access the minimum and maximum orders in the heap, means that our total time complexity is `O(nlogn)`.\\n\\n- Space complexity: `O(n)` This is because we need to store all the orders in the heap that we\\'re saving into the backlog.\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyBacklog = []\\n        sellBacklog = []\\n        ans = 0\\n        for price, amount, orderType in orders:\\n            if orderType == 0:  # Buy order\\n                while sellBacklog and amount > 0:\\n                    sellPrice, sellAmount = heapq.heappop(sellBacklog)\\n                    if sellPrice <= price:\\n                        if sellAmount > amount:\\n                            sellAmount -= amount\\n                            ans -= amount\\n                            amount = 0\\n                            heapq.heappush(sellBacklog, (sellPrice, sellAmount))\\n                        else:\\n                            amount -= sellAmount\\n                            ans -= sellAmount\\n                    else:\\n                        heapq.heappush(sellBacklog, (sellPrice, sellAmount))\\n                        break\\n                if amount != 0:\\n                    ans += amount\\n                    heapq.heappush(buyBacklog, (-price, amount))\\n\\n            else:\\n                while buyBacklog and amount > 0:\\n                    buyPrice, buyAmount = heapq.heappop(buyBacklog)\\n                    buyPrice *= -1\\n                    if buyPrice >= price:\\n                        if buyAmount > amount:\\n                            buyAmount -= amount\\n                            ans -= amount\\n                            amount = 0\\n                            heapq.heappush(buyBacklog, (-buyPrice, buyAmount))\\n                        else:\\n                            amount -= buyAmount\\n                            ans -= buyAmount\\n                    else:\\n                        heapq.heappush(buyBacklog, (-buyPrice, buyAmount))\\n                        break\\n                \\n                if amount != 0:\\n                    ans += amount\\n                    heapq.heappush(sellBacklog, (price, amount))\\n\\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyBacklog = []\\n        sellBacklog = []\\n        ans = 0\\n        for price, amount, orderType in orders:\\n            if orderType == 0:  # Buy order\\n                while sellBacklog and amount > 0:\\n                    sellPrice, sellAmount = heapq.heappop(sellBacklog)\\n                    if sellPrice <= price:\\n                        if sellAmount > amount:\\n                            sellAmount -= amount\\n                            ans -= amount\\n                            amount = 0\\n                            heapq.heappush(sellBacklog, (sellPrice, sellAmount))\\n                        else:\\n                            amount -= sellAmount\\n                            ans -= sellAmount\\n                    else:\\n                        heapq.heappush(sellBacklog, (sellPrice, sellAmount))\\n                        break\\n                if amount != 0:\\n                    ans += amount\\n                    heapq.heappush(buyBacklog, (-price, amount))\\n\\n            else:\\n                while buyBacklog and amount > 0:\\n                    buyPrice, buyAmount = heapq.heappop(buyBacklog)\\n                    buyPrice *= -1\\n                    if buyPrice >= price:\\n                        if buyAmount > amount:\\n                            buyAmount -= amount\\n                            ans -= amount\\n                            amount = 0\\n                            heapq.heappush(buyBacklog, (-buyPrice, buyAmount))\\n                        else:\\n                            amount -= buyAmount\\n                            ans -= buyAmount\\n                    else:\\n                        heapq.heappush(buyBacklog, (-buyPrice, buyAmount))\\n                        break\\n                \\n                if amount != 0:\\n                    ans += amount\\n                    heapq.heappush(sellBacklog, (price, amount))\\n\\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917561,
                "title": "c-faster-than-90-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain two maps one for buy orders and one for sell orders every time we found a buy order we will perform one operation and every time we found a sell order we will perform the other operation. \\n        map<int, int> mpBuy;\\n        map<int, int> mpSell;\\n\\n        for(auto &order : orders){\\n            int price = order[0];\\n            int amount = order[1];\\n            int type = order[2];\\n            if(type == 0){\\n                if(mpSell.empty()){\\n                    mpBuy[price] += amount;\\n                }\\n                else{\\n                    auto itr = mpSell.begin();\\n                    int size = mpSell.size();\\n                    while(amount > 0 and itr->first <= price){\\n\\n                        if(mpSell[itr->first] > amount){\\n                            mpSell[itr->first] -= amount;\\n                            amount = 0;\\n                        }\\n\\n                        else{\\n                            amount -= mpSell[itr->first];\\n                            mpSell.erase(itr->first);\\n                        }\\n\\n                        size -= 1;\\n                        if(size == 0) break;\\n                        itr++;\\n                    }\\n                    if(amount != 0) mpBuy[price] += amount;\\n                }\\n            }\\n            else{\\n                if(mpBuy.empty()){\\n                    mpSell[price] += amount;\\n                }\\n                else{\\n                    auto itr = mpBuy.rbegin();\\n                    int size = mpBuy.size();\\n                    while(amount > 0 and itr->first >= price){   \\n                        if(mpBuy[itr->first] > amount){\\n                            mpBuy[itr->first] -= amount;\\n                            amount = 0;\\n                            break;\\n                        }\\n\\n                        else{\\n                            amount -= mpBuy[itr->first];\\n                            mpBuy.erase(itr->first);\\n                        }\\n                        size -= 1;\\n                        if(size == 0) break;\\n                    }\\n                    if(amount != 0) mpSell[price] += amount;\\n                }\\n            }\\n        }\\n\\n        int mod = 1e9 + 7;\\n        long long answer = 0;\\n\\n\\n        for(auto itr = mpBuy.begin() ; itr != mpBuy.end() ; itr++)\\n            answer = (answer + itr->second) % mod;\\n        \\n        for(auto itr = mpSell.begin() ; itr != mpSell.end() ; itr++)\\n            answer = (answer + itr->second) % mod;\\n\\n        answer %= mod;\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        // Intution\\n        // The idea in here is really very simple. We will maintain two maps one for buy orders and one for sell orders every time we found a buy order we will perform one operation and every time we found a sell order we will perform the other operation. \\n        map<int, int> mpBuy;\\n        map<int, int> mpSell;\\n\\n        for(auto &order : orders){\\n            int price = order[0];\\n            int amount = order[1];\\n            int type = order[2];\\n            if(type == 0){\\n                if(mpSell.empty()){\\n                    mpBuy[price] += amount;\\n                }\\n                else{\\n                    auto itr = mpSell.begin();\\n                    int size = mpSell.size();\\n                    while(amount > 0 and itr->first <= price){\\n\\n                        if(mpSell[itr->first] > amount){\\n                            mpSell[itr->first] -= amount;\\n                            amount = 0;\\n                        }\\n\\n                        else{\\n                            amount -= mpSell[itr->first];\\n                            mpSell.erase(itr->first);\\n                        }\\n\\n                        size -= 1;\\n                        if(size == 0) break;\\n                        itr++;\\n                    }\\n                    if(amount != 0) mpBuy[price] += amount;\\n                }\\n            }\\n            else{\\n                if(mpBuy.empty()){\\n                    mpSell[price] += amount;\\n                }\\n                else{\\n                    auto itr = mpBuy.rbegin();\\n                    int size = mpBuy.size();\\n                    while(amount > 0 and itr->first >= price){   \\n                        if(mpBuy[itr->first] > amount){\\n                            mpBuy[itr->first] -= amount;\\n                            amount = 0;\\n                            break;\\n                        }\\n\\n                        else{\\n                            amount -= mpBuy[itr->first];\\n                            mpBuy.erase(itr->first);\\n                        }\\n                        size -= 1;\\n                        if(size == 0) break;\\n                    }\\n                    if(amount != 0) mpSell[price] += amount;\\n                }\\n            }\\n        }\\n\\n        int mod = 1e9 + 7;\\n        long long answer = 0;\\n\\n\\n        for(auto itr = mpBuy.begin() ; itr != mpBuy.end() ; itr++)\\n            answer = (answer + itr->second) % mod;\\n        \\n        for(auto itr = mpSell.begin() ; itr != mpSell.end() ; itr++)\\n            answer = (answer + itr->second) % mod;\\n\\n        answer %= mod;\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833234,
                "title": "treemaps-to-create-a-backlog",
                "content": "# Intuition\\nUsing a map to store the backlogs, since arrays, lists, or sets would consume a lot of time and space\\n\\n# Approach\\nusing two TreeMaps for sell backlog and buy backlog, with price as the key and amount as the value. Map.firstKey() and Map.lastKey() to be used now for getting the chapest and most expensive price in the backlogs.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        TreeMap<Integer, Integer> sell = new TreeMap<Integer, Integer>();\\n        TreeMap<Integer, Integer> buy = new TreeMap<Integer, Integer>();\\n        \\n        for(int i = 0; i < orders.length; i++)\\n        {\\n            int type = orders[i][2];\\n            int price = orders[i][0];\\n            int amt = orders[i][1];\\n\\n            if(type == 0)\\n            {\\n                while(amt!= 0)\\n                {                    \\n                    if(sell.isEmpty() || sell.firstKey() > price)\\n                    {\\n                        if(buy.containsKey(price))\\n                            buy.put(price, (buy.get(price) + amt));\\n                        else\\n                            buy.put(price, amt);\\n                        break;\\n                    }\\n\\n\\n                    int sellPrice = sell.firstKey();\\n                    int sellAmt = sell.get(sellPrice);\\n\\n                    if(sellAmt <= amt)\\n                    {\\n                        amt -= sellAmt;\\n                        sell.remove(sellPrice);\\n                    }\\n\\n                    else\\n                    {\\n                        sellAmt -= amt;\\n                        sell.put(sellPrice, sellAmt);\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            else\\n            {\\n                while(amt!= 0)\\n                {                    \\n                    if(buy.isEmpty() || buy.lastKey() < price)\\n                    {\\n                        if(sell.containsKey(price))\\n                            sell.put(price, (sell.get(price) + amt));\\n                        else\\n                            sell.put(price, amt);\\n                        break;\\n                    }\\n\\n                    int buyPrice = buy.lastKey();\\n                    int buyAmt = buy.get(buyPrice);\\n\\n                    if(buyAmt < amt)\\n                    {\\n                        amt -= buyAmt;\\n                        buy.remove(buyPrice);\\n                    }\\n\\n                    else\\n                    {\\n                        buyAmt -= amt;\\n                        buy.put(buyPrice, buyAmt);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(int a: sell.values())\\n            ans+=a;\\n        \\n        for(int a: buy.values())\\n            ans+=a;\\n\\n        return (int)(ans % (int)(Math.pow(10, 9) + 7));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        TreeMap<Integer, Integer> sell = new TreeMap<Integer, Integer>();\\n        TreeMap<Integer, Integer> buy = new TreeMap<Integer, Integer>();\\n        \\n        for(int i = 0; i < orders.length; i++)\\n        {\\n            int type = orders[i][2];\\n            int price = orders[i][0];\\n            int amt = orders[i][1];\\n\\n            if(type == 0)\\n            {\\n                while(amt!= 0)\\n                {                    \\n                    if(sell.isEmpty() || sell.firstKey() > price)\\n                    {\\n                        if(buy.containsKey(price))\\n                            buy.put(price, (buy.get(price) + amt));\\n                        else\\n                            buy.put(price, amt);\\n                        break;\\n                    }\\n\\n\\n                    int sellPrice = sell.firstKey();\\n                    int sellAmt = sell.get(sellPrice);\\n\\n                    if(sellAmt <= amt)\\n                    {\\n                        amt -= sellAmt;\\n                        sell.remove(sellPrice);\\n                    }\\n\\n                    else\\n                    {\\n                        sellAmt -= amt;\\n                        sell.put(sellPrice, sellAmt);\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            else\\n            {\\n                while(amt!= 0)\\n                {                    \\n                    if(buy.isEmpty() || buy.lastKey() < price)\\n                    {\\n                        if(sell.containsKey(price))\\n                            sell.put(price, (sell.get(price) + amt));\\n                        else\\n                            sell.put(price, amt);\\n                        break;\\n                    }\\n\\n                    int buyPrice = buy.lastKey();\\n                    int buyAmt = buy.get(buyPrice);\\n\\n                    if(buyAmt < amt)\\n                    {\\n                        amt -= buyAmt;\\n                        buy.remove(buyPrice);\\n                    }\\n\\n                    else\\n                    {\\n                        buyAmt -= amt;\\n                        buy.put(buyPrice, buyAmt);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(int a: sell.values())\\n            ans+=a;\\n        \\n        for(int a: buy.values())\\n            ans+=a;\\n\\n        return (int)(ans % (int)(Math.pow(10, 9) + 7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752068,
                "title": "python3-two-heap",
                "content": "# Code\\n```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int: \\n        buyQ = []\\n        sellQ = []\\n\\n        for o in orders:\\n            price = o[0]\\n            amount = o[1]\\n            if o[2]==0:\\n                # buy\\n                while amount > 0 and len(sellQ) > 0:\\n                    if sellQ[0][0] > price:\\n                        break\\n                    sellElement = heapq.heappop(sellQ)\\n                    tradeQauntity = min(sellElement[1], amount)\\n                    amount -= tradeQauntity\\n                    sellElement[1] -= tradeQauntity\\n\\n                    if sellElement[1]>0:\\n                        heapq.heappush(sellQ, sellElement)\\n\\n                if amount > 0:\\n                    heapq.heappush(buyQ, [-price, amount])\\n\\n            else:\\n                # sell\\n                while amount > 0 and len(buyQ) > 0:\\n                    if -buyQ[0][0] < price:\\n                        break\\n                    buyElement = heapq.heappop(buyQ)\\n                    tradeQauntity = min(buyElement[1], amount)\\n                    amount -= tradeQauntity\\n                    buyElement[1] -= tradeQauntity\\n\\n                    if buyElement[1]>0:\\n                        heapq.heappush(buyQ, buyElement)\\n\\n                if amount > 0:\\n                    heapq.heappush(sellQ, [price, amount])\\n\\n        MOD = int(1e9)+7\\n        ans = 0\\n        while len(buyQ)>0:\\n            cur = heapq.heappop(buyQ)\\n            ans = (ans + cur[1]) % MOD\\n        while len(sellQ)>0:\\n            cur = heapq.heappop(sellQ)\\n            ans = (ans + cur[1]) % MOD\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int: \\n        buyQ = []\\n        sellQ = []\\n\\n        for o in orders:\\n            price = o[0]\\n            amount = o[1]\\n            if o[2]==0:\\n                # buy\\n                while amount > 0 and len(sellQ) > 0:\\n                    if sellQ[0][0] > price:\\n                        break\\n                    sellElement = heapq.heappop(sellQ)\\n                    tradeQauntity = min(sellElement[1], amount)\\n                    amount -= tradeQauntity\\n                    sellElement[1] -= tradeQauntity\\n\\n                    if sellElement[1]>0:\\n                        heapq.heappush(sellQ, sellElement)\\n\\n                if amount > 0:\\n                    heapq.heappush(buyQ, [-price, amount])\\n\\n            else:\\n                # sell\\n                while amount > 0 and len(buyQ) > 0:\\n                    if -buyQ[0][0] < price:\\n                        break\\n                    buyElement = heapq.heappop(buyQ)\\n                    tradeQauntity = min(buyElement[1], amount)\\n                    amount -= tradeQauntity\\n                    buyElement[1] -= tradeQauntity\\n\\n                    if buyElement[1]>0:\\n                        heapq.heappush(buyQ, buyElement)\\n\\n                if amount > 0:\\n                    heapq.heappush(sellQ, [price, amount])\\n\\n        MOD = int(1e9)+7\\n        ans = 0\\n        while len(buyQ)>0:\\n            cur = heapq.heappop(buyQ)\\n            ans = (ans + cur[1]) % MOD\\n        while len(sellQ)>0:\\n            cur = heapq.heappop(sellQ)\\n            ans = (ans + cur[1]) % MOD\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675086,
                "title": "java-heap-just-do-what-it-says",
                "content": "# Intuition\\nJust add the orders immediately and remove as much of them as you can\\n\\n# Approach\\nTwo heaps or used \\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        final int MOD = 100_000_000_7;\\n        int answer = 0;\\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            int[] newOrder = new int[]{price, amount};\\n            if (orderType == 0) buy.add(newOrder);\\n            else sell.add(newOrder);\\n            while (!sell.isEmpty() && !buy.isEmpty() && sell.peek()[0] <= buy.peek()[0]) {\\n                int k = Math.min(buy.peek()[1], sell.peek()[1]);\\n                buy.peek()[1] -= k;\\n                sell.peek()[1] -= k;\\n                if (buy.peek()[1] == 0) buy.poll();\\n                if (sell.peek()[1] == 0) sell.poll();\\n            }\\n        }\\n\\n        for (int[] sellOrder : sell) {\\n            answer = (answer + sellOrder[1]) % MOD;\\n        }\\n        for (int[] buyOrder : buy) {\\n            answer = (answer + buyOrder[1]) % MOD;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public static int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        final int MOD = 100_000_000_7;\\n        int answer = 0;\\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            int[] newOrder = new int[]{price, amount};\\n            if (orderType == 0) buy.add(newOrder);\\n            else sell.add(newOrder);\\n            while (!sell.isEmpty() && !buy.isEmpty() && sell.peek()[0] <= buy.peek()[0]) {\\n                int k = Math.min(buy.peek()[1], sell.peek()[1]);\\n                buy.peek()[1] -= k;\\n                sell.peek()[1] -= k;\\n                if (buy.peek()[1] == 0) buy.poll();\\n                if (sell.peek()[1] == 0) sell.poll();\\n            }\\n        }\\n\\n        for (int[] sellOrder : sell) {\\n            answer = (answer + sellOrder[1]) % MOD;\\n        }\\n        for (int[] buyOrder : buy) {\\n            answer = (answer + buyOrder[1]) % MOD;\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654144,
                "title": "just-clean-and-readable-code",
                "content": "# Approach\\nWe represent the backlog as tuple of two heaps (or alternatively sorted arrays or priority queues) - one for buy orders (reversed) and one for sell orders. This way if any orders can match they will be at the top. This way we get all $$m$$ matches in the backlog in $$O(m)$$ steps.\\n\\n# Complexity\\n$$n = len(orders)$$\\n- Time complexity: $$O(nlogn)$$ - amortized analysis of match_and_execute()\\n\\n- Space complexity: $$O(n)$$ - space for backlog\\n\\n# Code\\n```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        M = 10**9+7\\n\\n        def match_and_execute(backlog):\\n            buy, sell = backlog\\n\\n            while sell and buy:\\n                p1, a1 = sell[0]\\n                p2, a2 = buy[0]\\n                if not(p1 <= -p2):\\n                    break  # no more matches left in backlog\\n            \\n                if a1 == a2:    \\n                    heappop(sell) \\n                    heappop(buy) \\n                elif a1 < a2:    \\n                    heappop(sell) \\n                    buy[0] = (p2, a2-a1)\\n                else:           \\n                    sell[0] = (p1, a1-a2)\\n                    heappop(buy)\\n\\n            return backlog\\n        \\n        def simulate_stock(orders, backlog):\\n            sell, buy = backlog\\n            for p, a, t in orders:\\n                if t == 1:  \\n                    heappush(sell, (p, a))\\n                else:       \\n                    heappush(buy, (-p, a))\\n                match_and_execute(backlog)\\n            return backlog\\n\\n\\n        backlog = simulate_stock(orders, ([], []))\\n        res = 0\\n        for log in backlog:\\n            for _, a in log:\\n                res = (res + a) % M\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        M = 10**9+7\\n\\n        def match_and_execute(backlog):\\n            buy, sell = backlog\\n\\n            while sell and buy:\\n                p1, a1 = sell[0]\\n                p2, a2 = buy[0]\\n                if not(p1 <= -p2):\\n                    break  # no more matches left in backlog\\n            \\n                if a1 == a2:    \\n                    heappop(sell) \\n                    heappop(buy) \\n                elif a1 < a2:    \\n                    heappop(sell) \\n                    buy[0] = (p2, a2-a1)\\n                else:           \\n                    sell[0] = (p1, a1-a2)\\n                    heappop(buy)\\n\\n            return backlog\\n        \\n        def simulate_stock(orders, backlog):\\n            sell, buy = backlog\\n            for p, a, t in orders:\\n                if t == 1:  \\n                    heappush(sell, (p, a))\\n                else:       \\n                    heappush(buy, (-p, a))\\n                match_and_execute(backlog)\\n            return backlog\\n\\n\\n        backlog = simulate_stock(orders, ([], []))\\n        res = 0\\n        for log in backlog:\\n            for _, a in log:\\n                res = (res + a) % M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645258,
                "title": "heap-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: heap, \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        sell_log = []\\n        buy_log = []\\n        in_log = 0\\n        \\n        for order in orders:\\n            price, amount, order_type = order\\n            amount %= MOD\\n            if order_type == 0:\\n                while amount > 0 and sell_log and sell_log[0][0] <= price:\\n                    sell_price, sell_amount = heapq.heappop(sell_log)\\n                    left_sell = max(0, sell_amount-amount)\\n                    if left_sell > 0:\\n                        heapq.heappush(sell_log, (sell_price, left_sell))\\n                    in_log -= min(amount, sell_amount)\\n                    amount = max(0, amount-sell_amount)\\n                if amount > 0:\\n                    heapq.heappush(buy_log, (-price, amount))\\n                    in_log += amount\\n            else:\\n                while amount > 0 and buy_log and -buy_log[0][0] >= price:\\n                    buy_price, buy_amount = heapq.heappop(buy_log)\\n                    left_buy = max(0, buy_amount-amount)\\n                    if left_buy > 0:\\n                        heapq.heappush(buy_log, (buy_price, left_buy))\\n                    in_log -= min(amount, buy_amount)\\n                    amount = max(0, amount-buy_amount)\\n                if amount > 0:\\n                    heapq.heappush(sell_log, (price, amount))\\n                    in_log += amount\\n\\n        return in_log % MOD\\n     \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # O(nlogn) time,\\n    # O(n) space,\\n    # Approach: heap, \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        sell_log = []\\n        buy_log = []\\n        in_log = 0\\n        \\n        for order in orders:\\n            price, amount, order_type = order\\n            amount %= MOD\\n            if order_type == 0:\\n                while amount > 0 and sell_log and sell_log[0][0] <= price:\\n                    sell_price, sell_amount = heapq.heappop(sell_log)\\n                    left_sell = max(0, sell_amount-amount)\\n                    if left_sell > 0:\\n                        heapq.heappush(sell_log, (sell_price, left_sell))\\n                    in_log -= min(amount, sell_amount)\\n                    amount = max(0, amount-sell_amount)\\n                if amount > 0:\\n                    heapq.heappush(buy_log, (-price, amount))\\n                    in_log += amount\\n            else:\\n                while amount > 0 and buy_log and -buy_log[0][0] >= price:\\n                    buy_price, buy_amount = heapq.heappop(buy_log)\\n                    left_buy = max(0, buy_amount-amount)\\n                    if left_buy > 0:\\n                        heapq.heappush(buy_log, (buy_price, left_buy))\\n                    in_log -= min(amount, buy_amount)\\n                    amount = max(0, amount-buy_amount)\\n                if amount > 0:\\n                    heapq.heappush(sell_log, (price, amount))\\n                    in_log += amount\\n\\n        return in_log % MOD\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514964,
                "title": "number-of-orders-in-backlogs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    final static int MOD = (int) (1e9 + 7);\\n    class Order{\\n        int price;\\n        int amount;\\n        Order(int price, int amount){\\n            this.price = price;\\n            this.amount = amount;\\n        }\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sell = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o1.price - o2.price;\\n        });\\n        PriorityQueue<Order> buy = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o2.price - o1.price;\\n        });\\n\\n        boolean flag;\\n        for(int[] ord : orders){\\n            int amount = ord[1];\\n            int price = ord[0];\\n            if(ord[2] == 0){ //buy\\n                while(amount>0 && !sell.isEmpty() && sell.peek().price<=price){\\n                    Order front = sell.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  sell.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;          \\n                }\\n                if(amount > 0)  buy.add(new Order(price, amount));\\n            }else{ //sell\\n                while(amount>0 && !buy.isEmpty() && buy.peek().price>=price){\\n                    Order front = buy.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  buy.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;         \\n                }\\n                if(amount > 0)  sell.add(new Order(price, amount));\\n            }\\n        }\\n        long ans = 0;\\n        while(!sell.isEmpty())\\n            ans= (ans + sell.poll().amount) % MOD;\\n        \\n        while(!buy.isEmpty())\\n            ans= (ans + buy.poll().amount) % MOD;\\n\\n        return (int) ans%MOD;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    final static int MOD = (int) (1e9 + 7);\\n    class Order{\\n        int price;\\n        int amount;\\n        Order(int price, int amount){\\n            this.price = price;\\n            this.amount = amount;\\n        }\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sell = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o1.price - o2.price;\\n        });\\n        PriorityQueue<Order> buy = new PriorityQueue<>((Order o1,Order o2)->{\\n            return o2.price - o1.price;\\n        });\\n\\n        boolean flag;\\n        for(int[] ord : orders){\\n            int amount = ord[1];\\n            int price = ord[0];\\n            if(ord[2] == 0){ //buy\\n                while(amount>0 && !sell.isEmpty() && sell.peek().price<=price){\\n                    Order front = sell.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  sell.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;          \\n                }\\n                if(amount > 0)  buy.add(new Order(price, amount));\\n            }else{ //sell\\n                while(amount>0 && !buy.isEmpty() && buy.peek().price>=price){\\n                    Order front = buy.poll();\\n                    if(front.amount>=amount){\\n                        front.amount = front.amount - amount;\\n                        amount = 0;\\n                        if(front.amount>0)  buy.add(front);\\n                    }    \\n                    else\\n                        amount = amount - front.amount;         \\n                }\\n                if(amount > 0)  sell.add(new Order(price, amount));\\n            }\\n        }\\n        long ans = 0;\\n        while(!sell.isEmpty())\\n            ans= (ans + sell.poll().amount) % MOD;\\n        \\n        while(!buy.isEmpty())\\n            ans= (ans + buy.poll().amount) % MOD;\\n\\n        return (int) ans%MOD;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466080,
                "title": "min-max-priority-queue-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> sell;\\n        priority_queue<pair<int,int>> buy;\\n        for(auto order: orders)\\n        {\\n            if(order[2]==0) // buy\\n            {\\n                if(sell.empty())\\n                {\\n                    buy.push({order[0],order[1]});\\n                    continue;\\n                }\\n                int price=order[0], quantity=order[1];\\n                while(!sell.empty() && quantity)\\n                {\\n                    int sellPrice=sell.top().first, sellQuan=sell.top().second;\\n                    if(sellPrice<=price)\\n                    {\\n                        sell.pop();\\n                        if(sellQuan>=quantity)\\n                        {\\n                            sellQuan-=quantity;\\n                            quantity=0;\\n                            if(sellQuan) sell.push({sellPrice,sellQuan});\\n                        }\\n                        else\\n                        {\\n                            quantity-=sellQuan;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        buy.push({price,quantity});\\n                        quantity=0;\\n                        break;\\n                    }\\n                }\\n                if(quantity) buy.push({price,quantity});\\n            }\\n            else\\n            {\\n                if(buy.empty()) // sell\\n                {\\n                    sell.push({order[0],order[1]});\\n                    continue;\\n                }\\n                int price=order[0], quantity=order[1];\\n                while(!buy.empty() && quantity)\\n                {\\n                    int buyPrice=buy.top().first, buyQuan=buy.top().second;\\n                    if(buyPrice>=price)\\n                    {\\n                        buy.pop();\\n                        if(buyQuan>=quantity)\\n                        {\\n                            buyQuan-=quantity;\\n                            quantity=0;\\n                            if(buyQuan) buy.push({buyPrice,buyQuan});\\n                        }\\n                        else\\n                        {\\n                            quantity-=buyQuan;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        sell.push({price,quantity});\\n                        quantity=0;\\n                        break;\\n                    }\\n                }\\n                if(quantity) sell.push({price,quantity});\\n            }\\n        }\\n        int ans=0, mod=1e9+7;\\n        while(!sell.empty())\\n        {\\n            ans=(ans+sell.top().second)%mod;\\n            sell.pop();\\n        }\\n        while(!buy.empty())\\n        {\\n            ans=(ans+buy.top().second)%mod;\\n            buy.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) \\n    {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> sell;\\n        priority_queue<pair<int,int>> buy;\\n        for(auto order: orders)\\n        {\\n            if(order[2]==0) // buy\\n            {\\n                if(sell.empty())\\n                {\\n                    buy.push({order[0],order[1]});\\n                    continue;\\n                }\\n                int price=order[0], quantity=order[1];\\n                while(!sell.empty() && quantity)\\n                {\\n                    int sellPrice=sell.top().first, sellQuan=sell.top().second;\\n                    if(sellPrice<=price)\\n                    {\\n                        sell.pop();\\n                        if(sellQuan>=quantity)\\n                        {\\n                            sellQuan-=quantity;\\n                            quantity=0;\\n                            if(sellQuan) sell.push({sellPrice,sellQuan});\\n                        }\\n                        else\\n                        {\\n                            quantity-=sellQuan;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        buy.push({price,quantity});\\n                        quantity=0;\\n                        break;\\n                    }\\n                }\\n                if(quantity) buy.push({price,quantity});\\n            }\\n            else\\n            {\\n                if(buy.empty()) // sell\\n                {\\n                    sell.push({order[0],order[1]});\\n                    continue;\\n                }\\n                int price=order[0], quantity=order[1];\\n                while(!buy.empty() && quantity)\\n                {\\n                    int buyPrice=buy.top().first, buyQuan=buy.top().second;\\n                    if(buyPrice>=price)\\n                    {\\n                        buy.pop();\\n                        if(buyQuan>=quantity)\\n                        {\\n                            buyQuan-=quantity;\\n                            quantity=0;\\n                            if(buyQuan) buy.push({buyPrice,buyQuan});\\n                        }\\n                        else\\n                        {\\n                            quantity-=buyQuan;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        sell.push({price,quantity});\\n                        quantity=0;\\n                        break;\\n                    }\\n                }\\n                if(quantity) sell.push({price,quantity});\\n            }\\n        }\\n        int ans=0, mod=1e9+7;\\n        while(!sell.empty())\\n        {\\n            ans=(ans+sell.top().second)%mod;\\n            sell.pop();\\n        }\\n        while(!buy.empty())\\n        {\\n            ans=(ans+buy.top().second)%mod;\\n            buy.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399069,
                "title": "python-sortedcontainers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Order:\\n    def __init__(self, price, amount, order_type):\\n        self.price = price\\n        self.amount = amount\\n        self.order_type = order_type \\n    \\n    def __lt__(self, other):\\n        if self.price < other.price:\\n            return self.order_type == 1 \\n        if self.price > other.price:\\n            return self.order_type == 0 \\n        return self.amount < other.amount\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        order_list = [SortedList(), SortedList()] \\n        tot_amount = 0\\n        for price, amount, order_type in orders:\\n            order_list[order_type].add(Order(price, amount, order_type))\\n            tot_amount += amount\\n            buy_list, sell_list = order_list\\n            while buy_list and sell_list and buy_list[0].price >= sell_list[0].price:\\n                top_buy, top_sell = buy_list[0], sell_list[0] \\n                amount = min(top_buy.amount, top_sell.amount)\\n                top_buy.amount -= amount\\n                top_sell.amount -= amount\\n                tot_amount -= amount + amount\\n                if not top_buy.amount:\\n                    buy_list.pop(0)\\n                if not top_sell.amount:\\n                    sell_list.pop(0)\\n        return tot_amount % 1000000007\\n```\\n\\n\\n\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        total_amount = 0\\n        buys, sells = [], []\\n        for price, amount, order_type in orders:\\n            if order_type == 0:\\n                while sells:\\n                    sell_price, sell_amount = sells[0]\\n                    if sell_price > price:\\n                        break\\n                    if amount >= sell_amount:\\n                        amount -= sell_amount\\n                        total_amount = (total_amount - sell_amount) % 1000000007\\n                        heappop(sells)\\n                        continue\\n                    sells[0][1] -= amount\\n                    total_amount = (total_amount - amount) % 1000000007\\n                    amount = 0\\n                    break\\n                if amount:\\n                    total_amount = (total_amount + amount) % 1000000007\\n                    heappush(buys, [-price, amount])\\n            elif order_type == 1:\\n                while buys:\\n                    buy_price, buy_amount = buys[0]\\n                    buy_price = -buy_price\\n                    if buy_price < price:\\n                        break\\n                    if amount >= buy_amount:\\n                        amount -= buy_amount\\n                        total_amount = (total_amount - buy_amount) % 1000000007\\n                        heappop(buys)\\n                        continue\\n                    buys[0][1] -= amount\\n                    total_amount = (total_amount - amount) % 1000000007\\n                    amount = 0\\n                    break                \\n                if amount:\\n                    total_amount = (total_amount + amount) % 1000000007\\n                    heappush(sells, [price, amount])\\n        return total_amount\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Order:\\n    def __init__(self, price, amount, order_type):\\n        self.price = price\\n        self.amount = amount\\n        self.order_type = order_type \\n    \\n    def __lt__(self, other):\\n        if self.price < other.price:\\n            return self.order_type == 1 \\n        if self.price > other.price:\\n            return self.order_type == 0 \\n        return self.amount < other.amount\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        order_list = [SortedList(), SortedList()] \\n        tot_amount = 0\\n        for price, amount, order_type in orders:\\n            order_list[order_type].add(Order(price, amount, order_type))\\n            tot_amount += amount\\n            buy_list, sell_list = order_list\\n            while buy_list and sell_list and buy_list[0].price >= sell_list[0].price:\\n                top_buy, top_sell = buy_list[0], sell_list[0] \\n                amount = min(top_buy.amount, top_sell.amount)\\n                top_buy.amount -= amount\\n                top_sell.amount -= amount\\n                tot_amount -= amount + amount\\n                if not top_buy.amount:\\n                    buy_list.pop(0)\\n                if not top_sell.amount:\\n                    sell_list.pop(0)\\n        return tot_amount % 1000000007\\n```\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        total_amount = 0\\n        buys, sells = [], []\\n        for price, amount, order_type in orders:\\n            if order_type == 0:\\n                while sells:\\n                    sell_price, sell_amount = sells[0]\\n                    if sell_price > price:\\n                        break\\n                    if amount >= sell_amount:\\n                        amount -= sell_amount\\n                        total_amount = (total_amount - sell_amount) % 1000000007\\n                        heappop(sells)\\n                        continue\\n                    sells[0][1] -= amount\\n                    total_amount = (total_amount - amount) % 1000000007\\n                    amount = 0\\n                    break\\n                if amount:\\n                    total_amount = (total_amount + amount) % 1000000007\\n                    heappush(buys, [-price, amount])\\n            elif order_type == 1:\\n                while buys:\\n                    buy_price, buy_amount = buys[0]\\n                    buy_price = -buy_price\\n                    if buy_price < price:\\n                        break\\n                    if amount >= buy_amount:\\n                        amount -= buy_amount\\n                        total_amount = (total_amount - buy_amount) % 1000000007\\n                        heappop(buys)\\n                        continue\\n                    buys[0][1] -= amount\\n                    total_amount = (total_amount - amount) % 1000000007\\n                    amount = 0\\n                    break                \\n                if amount:\\n                    total_amount = (total_amount + amount) % 1000000007\\n                    heappush(sells, [price, amount])\\n        return total_amount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387504,
                "title": "simple-hava-2-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sell= new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        PriorityQueue<int[]> buy= new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        for(int [] order : orders){\\n            if(order[2]==0){\\n                int n = order[1];\\n                    while(n>0){\\n                        if(!sell.isEmpty() && sell.peek()[0] <= order[0]){\\n                            int[] val = sell.poll();\\n                            if((val[1]-n)>0) {\\n                                sell.add(new int[]{val[0], val[1]-n, val[2]});\\n                                n=0;   \\n                            } else {\\n                                n=n-val[1];\\n                            }\\n                        } else {\\n                            buy.add(new int[]{order[0], n, order[1]});\\n                            n=0;\\n                        }\\n                    }\\n            } else {\\n                int n = order[1];\\n                    while(n>0){\\n                        if(!buy.isEmpty() && buy.peek()[0] >= order[0]){\\n                            int[] val = buy.poll();\\n                            if((val[1]-n)>0) {\\n                                buy.add(new int[]{val[0], val[1]-n, val[2]});\\n                                n=0;   \\n                            } else {\\n                                n=n-val[1];\\n                            }\\n                        } else {\\n                            sell.add(new int[]{order[0], n, order[1]});\\n                            n=0;\\n                        }\\n                    }\\n            }\\n        }\\n        int res = 0, mod = 1000000007;\\n        for (int[] o : sell)\\n            res = (res + o[1]) % mod;\\n        for (int[] o : buy)\\n            res = (res + o[1]) % mod;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sell= new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        PriorityQueue<int[]> buy= new PriorityQueue<>((a,b)->(b[0]-a[0]));\\n        for(int [] order : orders){\\n            if(order[2]==0){\\n                int n = order[1];\\n                    while(n>0){\\n                        if(!sell.isEmpty() && sell.peek()[0] <= order[0]){\\n                            int[] val = sell.poll();\\n                            if((val[1]-n)>0) {\\n                                sell.add(new int[]{val[0], val[1]-n, val[2]});\\n                                n=0;   \\n                            } else {\\n                                n=n-val[1];\\n                            }\\n                        } else {\\n                            buy.add(new int[]{order[0], n, order[1]});\\n                            n=0;\\n                        }\\n                    }\\n            } else {\\n                int n = order[1];\\n                    while(n>0){\\n                        if(!buy.isEmpty() && buy.peek()[0] >= order[0]){\\n                            int[] val = buy.poll();\\n                            if((val[1]-n)>0) {\\n                                buy.add(new int[]{val[0], val[1]-n, val[2]});\\n                                n=0;   \\n                            } else {\\n                                n=n-val[1];\\n                            }\\n                        } else {\\n                            sell.add(new int[]{order[0], n, order[1]});\\n                            n=0;\\n                        }\\n                    }\\n            }\\n        }\\n        int res = 0, mod = 1000000007;\\n        for (int[] o : sell)\\n            res = (res + o[1]) % mod;\\n        for (int[] o : buy)\\n            res = (res + o[1]) % mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318609,
                "title": "python-heap-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nuse priority queue to track the smallest price of sell order (min heap) and the largest price of buy order (max heap) in backlog\\ntc is O(nlogn), sc is O(n)\\n\\'\\'\\'\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        modula = 10 ** 9 + 7\\n        maxHeapBuy = []\\n        minHeapSell = []\\n        checkMinSellPrice = lambda: minHeapSell[0][0]\\n        checkMaxBuyPrice = lambda: -maxHeapBuy[0][0]\\n        for pr, am, ty in orders:\\n            if ty == 0:\\n\\t\\t\\t    # take the smallest price of sell order from backlog until current amount of order is 0 or the smallest price of sell order > current price\\n                while minHeapSell and checkMinSellPrice() <= pr and am > 0:\\n                    priceSell, amountSell = heappop(minHeapSell)\\n                    if amountSell > am:\\n                        amountSell -= am\\n                        am = 0\\n                        heappush(minHeapSell, [priceSell, amountSell])\\n                    else: am -= amountSell\\n                if am > 0: heappush(maxHeapBuy, [-pr, am])\\n            else:\\n\\t\\t\\t\\t# take the largest price of buy order from backlog until current amount of order is 0 or the largest price of sell order < current price\\n                while maxHeapBuy and checkMaxBuyPrice() >= pr and am > 0:\\n                    priceBuy, amountBuy = heappop(maxHeapBuy)\\n                    if amountBuy > am:\\n                        amountBuy -= am\\n                        am = 0\\n                        heappush(maxHeapBuy, [priceBuy, amountBuy])\\n                    else: am -= amountBuy\\n                if am > 0: heappush(minHeapSell, [pr, am])\\n        ans = 0\\n        for _, am in maxHeapBuy + minHeapSell:\\n            ans += am\\n            if ans >= modula: ans %= modula\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n\\'\\'\\'\\nuse priority queue to track the smallest price of sell order (min heap) and the largest price of buy order (max heap) in backlog\\ntc is O(nlogn), sc is O(n)\\n\\'\\'\\'\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        modula = 10 ** 9 + 7\\n        maxHeapBuy = []\\n        minHeapSell = []\\n        checkMinSellPrice = lambda: minHeapSell[0][0]\\n        checkMaxBuyPrice = lambda: -maxHeapBuy[0][0]\\n        for pr, am, ty in orders:\\n            if ty == 0:\\n\\t\\t\\t    # take the smallest price of sell order from backlog until current amount of order is 0 or the smallest price of sell order > current price\\n                while minHeapSell and checkMinSellPrice() <= pr and am > 0:\\n                    priceSell, amountSell = heappop(minHeapSell)\\n                    if amountSell > am:\\n                        amountSell -= am\\n                        am = 0\\n                        heappush(minHeapSell, [priceSell, amountSell])\\n                    else: am -= amountSell\\n                if am > 0: heappush(maxHeapBuy, [-pr, am])\\n            else:\\n\\t\\t\\t\\t# take the largest price of buy order from backlog until current amount of order is 0 or the largest price of sell order < current price\\n                while maxHeapBuy and checkMaxBuyPrice() >= pr and am > 0:\\n                    priceBuy, amountBuy = heappop(maxHeapBuy)\\n                    if amountBuy > am:\\n                        amountBuy -= am\\n                        am = 0\\n                        heappush(maxHeapBuy, [priceBuy, amountBuy])\\n                    else: am -= amountBuy\\n                if am > 0: heappush(minHeapSell, [pr, am])\\n        ans = 0\\n        for _, am in maxHeapBuy + minHeapSell:\\n            ans += am\\n            if ans >= modula: ans %= modula\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306061,
                "title": "scala-solution-min-and-max-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport scala.collection.mutable.PriorityQueue\\n\\ncase class Order(price: Int, var amount: Int, isBuy: Boolean)\\n\\nobject Solution {\\n\\n    def handleBuyOrder(orderObj: Order, buyHeap: PriorityQueue[Order], sellHeap: PriorityQueue[Order]): Unit = {\\n        // if sellHeap is empty or top of heap price > orderObj.price then ignore\\n        if (sellHeap.isEmpty || sellHeap.head.price > orderObj.price) {\\n            // add orderObj to buy heap\\n            buyHeap.enqueue(orderObj)\\n        } else {\\n            var topOfSell = sellHeap.head\\n            while (!sellHeap.isEmpty && orderObj.amount > 0 && topOfSell.price <= orderObj.price && topOfSell.amount > 0) {\\n                // handle if top has more amount than order or vice versa\\n                if (orderObj.amount >= topOfSell.amount) {\\n                    orderObj.amount -= topOfSell.amount\\n                    topOfSell.amount = 0\\n                } else {\\n                    topOfSell.amount = topOfSell.amount - orderObj.amount\\n                    orderObj.amount = 0\\n                }\\n\\n                if (topOfSell.amount == 0) {\\n                    sellHeap.dequeue()\\n                    if (!sellHeap.isEmpty)\\n                        topOfSell = sellHeap.head\\n                }\\n            }\\n            if (orderObj.amount > 0) {\\n                // add remainder to buy heap\\n                buyHeap.enqueue(orderObj)\\n            }\\n        }\\n    }\\n\\n    def handleSellOrder(orderObj: Order, buyHeap: PriorityQueue[Order], sellHeap: PriorityQueue[Order]): Unit = {\\n        // if buyHeap is empty or top of heap price < orderObj.price then ignore\\n        if (buyHeap.isEmpty || buyHeap.head.price < orderObj.price) {\\n            // add orderObj to buy heap\\n            sellHeap.enqueue(orderObj)\\n        } else {\\n            var topOfBuy = buyHeap.head\\n            while (!buyHeap.isEmpty && orderObj.amount > 0 && topOfBuy.price >= orderObj.price && topOfBuy.amount > 0) {\\n                \\n                // handle if top has more amount than order or vice versa\\n                if (orderObj.amount >= topOfBuy.amount) {\\n                    orderObj.amount -= topOfBuy.amount\\n                    topOfBuy.amount = 0\\n                } else {\\n                    topOfBuy.amount -= orderObj.amount\\n                    orderObj.amount = 0\\n                }\\n\\n                // if top is empty, remove from queue and update with another top \\n                if (topOfBuy.amount == 0) {\\n                    buyHeap.dequeue()\\n                    if (!buyHeap.isEmpty)\\n                        topOfBuy = buyHeap.head\\n                }\\n            }\\n            if (orderObj.amount > 0) {\\n                // add remainder to buy heap\\n                sellHeap.enqueue(orderObj)\\n            }\\n        }\\n    }\\n\\n    def buyHeapOrdering(order: Order) = order.price\\n\\n    def sellHeapOrdering(order: Order) = -order.price\\n\\n    def getNumberOfBacklogOrders(orders: Array[Array[Int]]): Int = {\\n        \\n        // this is max heap\\n        var buyHeap = new PriorityQueue[Order]()(Ordering.by(buyHeapOrdering))\\n        \\n        // this is min heap\\n        var sellHeap = new PriorityQueue[Order]()(Ordering.by(sellHeapOrdering))\\n\\n        for (order <- orders) {\\n            val price = order.head\\n            val amount = order(1)\\n            val isBuy = if (order.last == 0) true else false\\n            val orderObj = Order(price, amount, isBuy)\\n\\n            isBuy match {\\n                case true => handleBuyOrder(orderObj, buyHeap, sellHeap)\\n                case false => handleSellOrder(orderObj, buyHeap, sellHeap)\\n            }\\n        }\\n        // This is imp below to take % mod for each entry as well as total sum else if sum goes out of bound of Int, it becomes -ve\\n        val mod = Math.pow(10, 9) + 7\\n        ((buyHeap.map(x => x.amount % mod).sum % mod + sellHeap.map(_.amount % mod).sum) % mod).toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable.PriorityQueue\\n\\ncase class Order(price: Int, var amount: Int, isBuy: Boolean)\\n\\nobject Solution {\\n\\n    def handleBuyOrder(orderObj: Order, buyHeap: PriorityQueue[Order], sellHeap: PriorityQueue[Order]): Unit = {\\n        // if sellHeap is empty or top of heap price > orderObj.price then ignore\\n        if (sellHeap.isEmpty || sellHeap.head.price > orderObj.price) {\\n            // add orderObj to buy heap\\n            buyHeap.enqueue(orderObj)\\n        } else {\\n            var topOfSell = sellHeap.head\\n            while (!sellHeap.isEmpty && orderObj.amount > 0 && topOfSell.price <= orderObj.price && topOfSell.amount > 0) {\\n                // handle if top has more amount than order or vice versa\\n                if (orderObj.amount >= topOfSell.amount) {\\n                    orderObj.amount -= topOfSell.amount\\n                    topOfSell.amount = 0\\n                } else {\\n                    topOfSell.amount = topOfSell.amount - orderObj.amount\\n                    orderObj.amount = 0\\n                }\\n\\n                if (topOfSell.amount == 0) {\\n                    sellHeap.dequeue()\\n                    if (!sellHeap.isEmpty)\\n                        topOfSell = sellHeap.head\\n                }\\n            }\\n            if (orderObj.amount > 0) {\\n                // add remainder to buy heap\\n                buyHeap.enqueue(orderObj)\\n            }\\n        }\\n    }\\n\\n    def handleSellOrder(orderObj: Order, buyHeap: PriorityQueue[Order], sellHeap: PriorityQueue[Order]): Unit = {\\n        // if buyHeap is empty or top of heap price < orderObj.price then ignore\\n        if (buyHeap.isEmpty || buyHeap.head.price < orderObj.price) {\\n            // add orderObj to buy heap\\n            sellHeap.enqueue(orderObj)\\n        } else {\\n            var topOfBuy = buyHeap.head\\n            while (!buyHeap.isEmpty && orderObj.amount > 0 && topOfBuy.price >= orderObj.price && topOfBuy.amount > 0) {\\n                \\n                // handle if top has more amount than order or vice versa\\n                if (orderObj.amount >= topOfBuy.amount) {\\n                    orderObj.amount -= topOfBuy.amount\\n                    topOfBuy.amount = 0\\n                } else {\\n                    topOfBuy.amount -= orderObj.amount\\n                    orderObj.amount = 0\\n                }\\n\\n                // if top is empty, remove from queue and update with another top \\n                if (topOfBuy.amount == 0) {\\n                    buyHeap.dequeue()\\n                    if (!buyHeap.isEmpty)\\n                        topOfBuy = buyHeap.head\\n                }\\n            }\\n            if (orderObj.amount > 0) {\\n                // add remainder to buy heap\\n                sellHeap.enqueue(orderObj)\\n            }\\n        }\\n    }\\n\\n    def buyHeapOrdering(order: Order) = order.price\\n\\n    def sellHeapOrdering(order: Order) = -order.price\\n\\n    def getNumberOfBacklogOrders(orders: Array[Array[Int]]): Int = {\\n        \\n        // this is max heap\\n        var buyHeap = new PriorityQueue[Order]()(Ordering.by(buyHeapOrdering))\\n        \\n        // this is min heap\\n        var sellHeap = new PriorityQueue[Order]()(Ordering.by(sellHeapOrdering))\\n\\n        for (order <- orders) {\\n            val price = order.head\\n            val amount = order(1)\\n            val isBuy = if (order.last == 0) true else false\\n            val orderObj = Order(price, amount, isBuy)\\n\\n            isBuy match {\\n                case true => handleBuyOrder(orderObj, buyHeap, sellHeap)\\n                case false => handleSellOrder(orderObj, buyHeap, sellHeap)\\n            }\\n        }\\n        // This is imp below to take % mod for each entry as well as total sum else if sum goes out of bound of Int, it becomes -ve\\n        val mod = Math.pow(10, 9) + 7\\n        ((buyHeap.map(x => x.amount % mod).sum % mod + sellHeap.map(_.amount % mod).sum) % mod).toInt\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271056,
                "title": "python-using-heap-t-o-nlogn-s-o-n",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        buy_orders = []\\n        sell_orders = []\\n        \\n        for price, amount, order_type in orders:\\n            if order_type == 0:  # buy order\\n                while sell_orders and sell_orders[0][0] <= price and amount > 0:\\n                    sell_price, sell_amount = heapq.heappop(sell_orders)\\n                    matched_amount = min(amount, sell_amount)\\n                    amount -= matched_amount\\n                    sell_amount -= matched_amount\\n                    if sell_amount > 0:\\n                        heapq.heappush(sell_orders, (sell_price, sell_amount))\\n                if amount > 0:\\n                    heapq.heappush(buy_orders, (-price, amount))\\n            else:  # sell order\\n                while buy_orders and -buy_orders[0][0] >= price and amount > 0:\\n                    buy_price, buy_amount = heapq.heappop(buy_orders)\\n                    matched_amount = min(amount, buy_amount)\\n                    amount -= matched_amount\\n                    buy_amount -= matched_amount\\n                    if buy_amount > 0:\\n                        heapq.heappush(buy_orders, (buy_price, buy_amount))\\n                if amount > 0:\\n                    heapq.heappush(sell_orders, (price, amount))\\n        \\n        total_backlog = sum(amount for _, amount in buy_orders) + sum(amount for _, amount in sell_orders)\\n        return total_backlog % MOD\\n\\n\\n\\n\\n        \\n\\'\\'\\'\\nImagine you are at a toy store and want to buy a toy. The toy store has a bunch of toys with different prices, and you have some money to spend.\\n\\nOther people also want to buy toys at the same store, and some of them want to sell toys they already have. The store keeps track of all these orders in a notebook.\\n\\nWhen you want to buy a toy, the store checks if anyone is selling a toy for a price you can afford. If they find someone selling a toy at that price, you can buy the toy from them. If no one is selling a toy at that price, the store writes down your order in their notebook and waits for someone to sell a toy at that price.\\n\\nThe same thing happens if someone wants to sell a toy - the store checks if anyone wants to buy a toy at that price, and if so, they match the buyer and seller and the sale is made. If no one wants to buy a toy at that price, the store writes down the order in their notebook and waits for someone to buy a toy at that price.\\n\\nAt the end of the day, the store counts how many orders they have left in their notebook that they haven\\'t been able to match yet. This is called the backlog.\\n\\nThe problem you are given is to write a computer program that does this toy store order matching automatically, and tells you how many orders are left in the notebook at the end.\\n\\'\\'\\'\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        MOD = 10**9 + 7\\n        buy_orders = []\\n        sell_orders = []\\n        \\n        for price, amount, order_type in orders:\\n            if order_type == 0:  # buy order\\n                while sell_orders and sell_orders[0][0] <= price and amount > 0:\\n                    sell_price, sell_amount = heapq.heappop(sell_orders)\\n                    matched_amount = min(amount, sell_amount)\\n                    amount -= matched_amount\\n                    sell_amount -= matched_amount\\n                    if sell_amount > 0:\\n                        heapq.heappush(sell_orders, (sell_price, sell_amount))\\n                if amount > 0:\\n                    heapq.heappush(buy_orders, (-price, amount))\\n            else:  # sell order\\n                while buy_orders and -buy_orders[0][0] >= price and amount > 0:\\n                    buy_price, buy_amount = heapq.heappop(buy_orders)\\n                    matched_amount = min(amount, buy_amount)\\n                    amount -= matched_amount\\n                    buy_amount -= matched_amount\\n                    if buy_amount > 0:\\n                        heapq.heappush(buy_orders, (buy_price, buy_amount))\\n                if amount > 0:\\n                    heapq.heappush(sell_orders, (price, amount))\\n        \\n        total_backlog = sum(amount for _, amount in buy_orders) + sum(amount for _, amount in sell_orders)\\n        return total_backlog % MOD\\n\\n\\n\\n\\n        \\n\\'\\'\\'\\nImagine you are at a toy store and want to buy a toy. The toy store has a bunch of toys with different prices, and you have some money to spend.\\n\\nOther people also want to buy toys at the same store, and some of them want to sell toys they already have. The store keeps track of all these orders in a notebook.\\n\\nWhen you want to buy a toy, the store checks if anyone is selling a toy for a price you can afford. If they find someone selling a toy at that price, you can buy the toy from them. If no one is selling a toy at that price, the store writes down your order in their notebook and waits for someone to sell a toy at that price.\\n\\nThe same thing happens if someone wants to sell a toy - the store checks if anyone wants to buy a toy at that price, and if so, they match the buyer and seller and the sale is made. If no one wants to buy a toy at that price, the store writes down the order in their notebook and waits for someone to buy a toy at that price.\\n\\nAt the end of the day, the store counts how many orders they have left in their notebook that they haven\\'t been able to match yet. This is called the backlog.\\n\\nThe problem you are given is to write a computer program that does this toy store order matching automatically, and tells you how many orders are left in the notebook at the end.\\n\\'\\'\\'\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260351,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        sell, buy, mod = [], [], 10**9+7\\n\\n        for i,j,l in orders:\\n            if l == 0:\\n                heapq.heappush(buy,[-i,j])\\n            else:\\n                heapq.heappush(sell,[i,j])\\n                \\n            while buy and sell and sell[0][0] <= -buy[0][0]:\\n                k = min(sell[0][1],buy[0][1])\\n                sell[0][1] -= k\\n                buy[0][1] -= k\\n                if buy[0][1] == 0: heapq.heappop(buy)\\n                if sell[0][1] == 0: heapq.heappop(sell)\\n\\n        return sum([j for i,j in buy + sell])%mod\\n\\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders):\\n        sell, buy, mod = [], [], 10**9+7\\n\\n        for i,j,l in orders:\\n            if l == 0:\\n                heapq.heappush(buy,[-i,j])\\n            else:\\n                heapq.heappush(sell,[i,j])\\n                \\n            while buy and sell and sell[0][0] <= -buy[0][0]:\\n                k = min(sell[0][1],buy[0][1])\\n                sell[0][1] -= k\\n                buy[0][1] -= k\\n                if buy[0][1] == 0: heapq.heappop(buy)\\n                if sell[0][1] == 0: heapq.heappop(sell)\\n\\n        return sum([j for i,j in buy + sell])%mod\\n\\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225011,
                "title": "python-faster-solution-easy-to-understand",
                "content": "# Please Upvote If It\\'s Helpful :)\\n\\n# Intuition\\nWe keep min heap for selling because we look for the smallest price when there is buying input. And, we also keep max heap for buying because we look for the biggest price when there is selling input. If it is buying, while length of min heap bigger than 0 and amount of bought item bigger than 0, we pop the first element of min heap and decrease it\\'s amount if the price condition is fullfilled. If amount of buying has not been reached, we add the buying input to the max heap after we multiply the price with -1 because it\\'s a max heap. We are doing the same thing for selling. \\n\\nAt the end, we pop each element from both max and min heap and take the sum of amounts.\\n\\n# Complexity\\n- Time complexity: O(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # (price, amount)\\n        max_heap_for_buy = []\\n        heapify(max_heap_for_buy)\\n        min_heap_for_sell = []\\n        heapify(min_heap_for_sell)\\n\\n        for i in orders:\\n            if i[2] == 0:\\n                if len(min_heap_for_sell) > 0:\\n                    amount_wanted_bought = i[1]\\n                    while len(min_heap_for_sell)>0 and amount_wanted_bought>0:\\n                        if min_heap_for_sell[0][0] <= i[0]:\\n                            current_amount = min_heap_for_sell[0][1]\\n                            if current_amount <= amount_wanted_bought:\\n                                amount_wanted_bought -= min_heap_for_sell[0][1]\\n                                heappop(min_heap_for_sell)\\n                            else:\\n                                popped = heappop(min_heap_for_sell)\\n                                price, amount = popped[0], popped[1]\\n                                amount -= amount_wanted_bought\\n                                popped = (price, amount)\\n                                heappush(min_heap_for_sell, popped)\\n                                amount_wanted_bought = 0\\n                                break\\n                        else:\\n                            break\\n                    if amount_wanted_bought != 0:\\n                        heappush(max_heap_for_buy, (i[0]*-1, amount_wanted_bought))\\n\\n                else:\\n                    heappush(max_heap_for_buy, (i[0]*-1, i[1]))\\n            \\n            else:\\n                if len(max_heap_for_buy) > 0:\\n                    amount_wanted_selled = i[1]\\n                    while len(max_heap_for_buy) > 0 and amount_wanted_selled > 0:\\n                        if i[0] <= (max_heap_for_buy[0][0]*-1):\\n                            current_amount = max_heap_for_buy[0][1]\\n                            if current_amount <= amount_wanted_selled:\\n                                amount_wanted_selled -= max_heap_for_buy[0][1]\\n                                heappop(max_heap_for_buy)\\n                            else:\\n                                popped = heappop(max_heap_for_buy)\\n                                price, amount = popped[0], popped[1]\\n                                popped = (price, amount-amount_wanted_selled)\\n                                heappush(max_heap_for_buy, popped)\\n                                amount_wanted_selled = 0\\n                                break\\n                        else:\\n                            break\\n                    if amount_wanted_selled != 0:\\n                        heappush(min_heap_for_sell, (i[0], amount_wanted_selled))\\n\\n                else:\\n                    heappush(min_heap_for_sell, (i[0], i[1]))\\n        \\n        ans = 0\\n        while min_heap_for_sell:\\n            popped = heappop(min_heap_for_sell)\\n            ans += (popped[1])\\n\\n        while max_heap_for_buy:\\n            popped = heappop(max_heap_for_buy)\\n            ans += popped[1]\\n        \\n        return (ans% (pow(10, 9) + 7))\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # (price, amount)\\n        max_heap_for_buy = []\\n        heapify(max_heap_for_buy)\\n        min_heap_for_sell = []\\n        heapify(min_heap_for_sell)\\n\\n        for i in orders:\\n            if i[2] == 0:\\n                if len(min_heap_for_sell) > 0:\\n                    amount_wanted_bought = i[1]\\n                    while len(min_heap_for_sell)>0 and amount_wanted_bought>0:\\n                        if min_heap_for_sell[0][0] <= i[0]:\\n                            current_amount = min_heap_for_sell[0][1]\\n                            if current_amount <= amount_wanted_bought:\\n                                amount_wanted_bought -= min_heap_for_sell[0][1]\\n                                heappop(min_heap_for_sell)\\n                            else:\\n                                popped = heappop(min_heap_for_sell)\\n                                price, amount = popped[0], popped[1]\\n                                amount -= amount_wanted_bought\\n                                popped = (price, amount)\\n                                heappush(min_heap_for_sell, popped)\\n                                amount_wanted_bought = 0\\n                                break\\n                        else:\\n                            break\\n                    if amount_wanted_bought != 0:\\n                        heappush(max_heap_for_buy, (i[0]*-1, amount_wanted_bought))\\n\\n                else:\\n                    heappush(max_heap_for_buy, (i[0]*-1, i[1]))\\n            \\n            else:\\n                if len(max_heap_for_buy) > 0:\\n                    amount_wanted_selled = i[1]\\n                    while len(max_heap_for_buy) > 0 and amount_wanted_selled > 0:\\n                        if i[0] <= (max_heap_for_buy[0][0]*-1):\\n                            current_amount = max_heap_for_buy[0][1]\\n                            if current_amount <= amount_wanted_selled:\\n                                amount_wanted_selled -= max_heap_for_buy[0][1]\\n                                heappop(max_heap_for_buy)\\n                            else:\\n                                popped = heappop(max_heap_for_buy)\\n                                price, amount = popped[0], popped[1]\\n                                popped = (price, amount-amount_wanted_selled)\\n                                heappush(max_heap_for_buy, popped)\\n                                amount_wanted_selled = 0\\n                                break\\n                        else:\\n                            break\\n                    if amount_wanted_selled != 0:\\n                        heappush(min_heap_for_sell, (i[0], amount_wanted_selled))\\n\\n                else:\\n                    heappush(min_heap_for_sell, (i[0], i[1]))\\n        \\n        ans = 0\\n        while min_heap_for_sell:\\n            popped = heappop(min_heap_for_sell)\\n            ans += (popped[1])\\n\\n        while max_heap_for_buy:\\n            popped = heappop(max_heap_for_buy)\\n            ans += popped[1]\\n        \\n        return (ans% (pow(10, 9) + 7))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224777,
                "title": "java-approach-using-tree-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int mod=1000000000+7;\\n        TreeMap<Integer,Integer> mapBuy=new TreeMap<>();\\n        TreeMap<Integer,Integer> mapSell=new TreeMap<>();\\n        for (int i=0;i<orders.length;i++){\\n            if(orders[i][2]==0){\\n                orderCheckingForBuy(orders[i], mapBuy, mapSell );\\n            }else {\\n                orderCheckingForSell(orders[i], mapBuy, mapSell);\\n            }\\n        }\\n        int count=0;\\n        for (int val:mapBuy.values()){\\n            count=(count+val)%mod;\\n        }\\n        for (int val:mapSell.values()){\\n            count=(count+val)%mod;\\n        }\\n        return count;\\n    }\\n\\n    private void orderCheckingForSell(int[] orders, TreeMap<Integer, Integer> mapBuy, TreeMap<Integer, Integer> mapSell) {\\n        int orderCount= orders[1];\\n        Map.Entry<Integer,Integer> entry=null;\\n        while (orderCount!=0 && (entry= mapBuy.lastEntry())!=null && entry.getKey()>= orders[0]){\\n            if(entry.getValue()>orderCount){\\n                mapBuy.put(entry.getKey(),entry.getValue()-orderCount);\\n                orderCount=0;\\n                break;\\n            }else {\\n                orderCount-=entry.getValue();\\n                mapBuy.remove(entry.getKey());\\n            }\\n        }\\n        if(orderCount>0){\\n            mapSell.merge(orders[0], orderCount,Integer::sum);\\n        }\\n    }\\n\\n    private static void orderCheckingForBuy(int[] orders, TreeMap<Integer, Integer> mapBuy, TreeMap<Integer, Integer> mapSell) {\\n        int orderCount= orders[1];\\n        Map.Entry<Integer,Integer> entry=null;\\n        while (orderCount!=0 && (entry= mapSell.firstEntry())!=null && entry.getKey()<= orders[0]){\\n            if(entry.getValue()>orderCount){\\n                mapSell.put(entry.getKey(),entry.getValue()-orderCount);\\n                orderCount=0;\\n                break;\\n            }else {\\n                orderCount-=entry.getValue();\\n                mapSell.remove(entry.getKey());\\n            }\\n        }\\n        if(orderCount>0){\\n            mapBuy.merge(orders[0], orderCount,Integer::sum);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int mod=1000000000+7;\\n        TreeMap<Integer,Integer> mapBuy=new TreeMap<>();\\n        TreeMap<Integer,Integer> mapSell=new TreeMap<>();\\n        for (int i=0;i<orders.length;i++){\\n            if(orders[i][2]==0){\\n                orderCheckingForBuy(orders[i], mapBuy, mapSell );\\n            }else {\\n                orderCheckingForSell(orders[i], mapBuy, mapSell);\\n            }\\n        }\\n        int count=0;\\n        for (int val:mapBuy.values()){\\n            count=(count+val)%mod;\\n        }\\n        for (int val:mapSell.values()){\\n            count=(count+val)%mod;\\n        }\\n        return count;\\n    }\\n\\n    private void orderCheckingForSell(int[] orders, TreeMap<Integer, Integer> mapBuy, TreeMap<Integer, Integer> mapSell) {\\n        int orderCount= orders[1];\\n        Map.Entry<Integer,Integer> entry=null;\\n        while (orderCount!=0 && (entry= mapBuy.lastEntry())!=null && entry.getKey()>= orders[0]){\\n            if(entry.getValue()>orderCount){\\n                mapBuy.put(entry.getKey(),entry.getValue()-orderCount);\\n                orderCount=0;\\n                break;\\n            }else {\\n                orderCount-=entry.getValue();\\n                mapBuy.remove(entry.getKey());\\n            }\\n        }\\n        if(orderCount>0){\\n            mapSell.merge(orders[0], orderCount,Integer::sum);\\n        }\\n    }\\n\\n    private static void orderCheckingForBuy(int[] orders, TreeMap<Integer, Integer> mapBuy, TreeMap<Integer, Integer> mapSell) {\\n        int orderCount= orders[1];\\n        Map.Entry<Integer,Integer> entry=null;\\n        while (orderCount!=0 && (entry= mapSell.firstEntry())!=null && entry.getKey()<= orders[0]){\\n            if(entry.getValue()>orderCount){\\n                mapSell.put(entry.getKey(),entry.getValue()-orderCount);\\n                orderCount=0;\\n                break;\\n            }else {\\n                orderCount-=entry.getValue();\\n                mapSell.remove(entry.getKey());\\n            }\\n        }\\n        if(orderCount>0){\\n            mapBuy.merge(orders[0], orderCount,Integer::sum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162234,
                "title": "python3-solution-beats-97-explained",
                "content": "# Intuition\\nMy first thought was to use a greedy approach. For each order, we can check if the order can be fulfilled by a previous order. If not, we can add it to a heap to track the backlog orders.\\n\\n# Approach\\nWe can use two heaps to track all the buy and sell orders. We iterate through the orders and check if the order can be fulfilled by a previous order. If so, we reduce the amount from the previous order, otherwise, we add it to the heap.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy = []\\n        sell = []\\n        for o in orders:\\n            if o[2] == 0:\\n                while sell and sell[0][0] <= o[0] and o[1] > 0:\\n                    if sell[0][1] <= o[1]:\\n                        o[1] -= sell[0][1]\\n                        heapq.heappop(sell)\\n                    else:\\n                        sell[0][1] -= o[1]\\n                        o[1] = 0\\n                if o[1] > 0:\\n                    heapq.heappush(buy, [-o[0], o[1]])\\n            else:\\n                while buy and -buy[0][0] >= o[0] and o[1] > 0:\\n                    if buy[0][1] <= o[1]:\\n                        o[1] -= buy[0][1]\\n                        heapq.heappop(buy)\\n                    else:\\n                        buy[0][1] -= o[1]\\n                        o[1] = 0\\n                if o[1] > 0:\\n                    heapq.heappush(sell, [o[0], o[1]])\\n        return (sum([o[1] for o in buy]) + sum([o[1] for o in sell])) % (10 ** 9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy = []\\n        sell = []\\n        for o in orders:\\n            if o[2] == 0:\\n                while sell and sell[0][0] <= o[0] and o[1] > 0:\\n                    if sell[0][1] <= o[1]:\\n                        o[1] -= sell[0][1]\\n                        heapq.heappop(sell)\\n                    else:\\n                        sell[0][1] -= o[1]\\n                        o[1] = 0\\n                if o[1] > 0:\\n                    heapq.heappush(buy, [-o[0], o[1]])\\n            else:\\n                while buy and -buy[0][0] >= o[0] and o[1] > 0:\\n                    if buy[0][1] <= o[1]:\\n                        o[1] -= buy[0][1]\\n                        heapq.heappop(buy)\\n                    else:\\n                        buy[0][1] -= o[1]\\n                        o[1] = 0\\n                if o[1] > 0:\\n                    heapq.heappush(sell, [o[0], o[1]])\\n        return (sum([o[1] for o in buy]) + sum([o[1] for o in sell])) % (10 ** 9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153345,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;\\n\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<PII, vector<PII>, less<>> buy ;  //\\u8CB7\\u50F9\\u6700\\u9AD8\\n        priority_queue<PII, vector<PII>, greater<>> sell ;  //\\u8CE3\\u50F9\\u6700\\u4F4E\\n        int M = 1e9 + 7 ;\\n        for(auto order : orders)\\n        {\\n            if(order[2] == 0)  // buy find \\u8CE3\\u50F9\\u6700\\u4F4E \\n            {\\n                while(order[1] > 0 && !sell.empty() && sell.top().first <= order[0])\\n                {\\n                    auto [price, amount] = sell.top() ;\\n                    sell.pop() ;\\n                    int deal = min(amount, order[1]) ;\\n                    amount -= deal ;\\n                    order[1] -= deal ;\\n                    if(amount > 0)\\n                        sell.push({price, amount}) ;\\n                }\\n                if(order[1] > 0)\\n                    buy.push({order[0], order[1]}) ;\\n            }\\n            else{  // sell find \\u8CB7\\u50F9\\u6700\\u9AD8\\n                while(order[1] > 0 && !buy.empty() && buy.top().first >= order[0])\\n                {\\n                    auto [price, amount] = buy.top() ;\\n                    buy.pop() ;\\n                    int deal = min(amount, order[1]) ;\\n                    amount -= deal ;\\n                    order[1] -= deal ;\\n                    if(amount > 0)\\n                        buy.push({price, amount}) ;\\n                }\\n                if(order[1] > 0)\\n                    sell.push({order[0], order[1]}) ;\\n            }\\n        }\\n        long long ans = 0;\\n        while(!sell.empty())\\n        {\\n            ans = (ans + sell.top().second) % M ;\\n            sell.pop() ;\\n        }\\n        \\n        while(!buy.empty())\\n        {\\n            ans = (ans + buy.top().second) % M ;\\n            buy.pop() ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing PII = pair<int, int> ;\\n\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<PII, vector<PII>, less<>> buy ;  //\\u8CB7\\u50F9\\u6700\\u9AD8\\n        priority_queue<PII, vector<PII>, greater<>> sell ;  //\\u8CE3\\u50F9\\u6700\\u4F4E\\n        int M = 1e9 + 7 ;\\n        for(auto order : orders)\\n        {\\n            if(order[2] == 0)  // buy find \\u8CE3\\u50F9\\u6700\\u4F4E \\n            {\\n                while(order[1] > 0 && !sell.empty() && sell.top().first <= order[0])\\n                {\\n                    auto [price, amount] = sell.top() ;\\n                    sell.pop() ;\\n                    int deal = min(amount, order[1]) ;\\n                    amount -= deal ;\\n                    order[1] -= deal ;\\n                    if(amount > 0)\\n                        sell.push({price, amount}) ;\\n                }\\n                if(order[1] > 0)\\n                    buy.push({order[0], order[1]}) ;\\n            }\\n            else{  // sell find \\u8CB7\\u50F9\\u6700\\u9AD8\\n                while(order[1] > 0 && !buy.empty() && buy.top().first >= order[0])\\n                {\\n                    auto [price, amount] = buy.top() ;\\n                    buy.pop() ;\\n                    int deal = min(amount, order[1]) ;\\n                    amount -= deal ;\\n                    order[1] -= deal ;\\n                    if(amount > 0)\\n                        buy.push({price, amount}) ;\\n                }\\n                if(order[1] > 0)\\n                    sell.push({order[0], order[1]}) ;\\n            }\\n        }\\n        long long ans = 0;\\n        while(!sell.empty())\\n        {\\n            ans = (ans + sell.top().second) % M ;\\n            sell.pop() ;\\n        }\\n        \\n        while(!buy.empty())\\n        {\\n            ans = (ans + buy.top().second) % M ;\\n            buy.pop() ;\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052277,
                "title": "python-easy-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        for p, a, t in orders:\\n            if t == 0:\\n                while a and sell and sell[0][0] <= p:\\n                    x, y = heappop(sell)\\n                    if a >= y:\\n                        a -= y\\n                    else:\\n                        heappush(sell, (x, y - a))\\n                        a = 0\\n                if a:\\n                    heappush(buy, (-p, a))\\n            else:\\n                while a and buy and -buy[0][0] >= p:\\n                    x, y = heappop(buy)\\n                    if a >= y:\\n                        a -= y\\n                    else:\\n                        heappush(buy, (x, y - a))\\n                        a = 0\\n                if a:\\n                    heappush(sell, (p, a))\\n        mod = 10**9 + 7\\n        return sum(v[1] for v in buy + sell) % mod\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        for p, a, t in orders:\\n            if t == 0:\\n                while a and sell and sell[0][0] <= p:\\n                    x, y = heappop(sell)\\n                    if a >= y:\\n                        a -= y\\n                    else:\\n                        heappush(sell, (x, y - a))\\n                        a = 0\\n                if a:\\n                    heappush(buy, (-p, a))\\n            else:\\n                while a and buy and -buy[0][0] >= p:\\n                    x, y = heappop(buy)\\n                    if a >= y:\\n                        a -= y\\n                    else:\\n                        heappush(buy, (x, y - a))\\n                        a = 0\\n                if a:\\n                    heappush(sell, (p, a))\\n        mod = 10**9 + 7\\n        return sum(v[1] for v in buy + sell) % mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003100,
                "title": "scala-recursion-with-priorityqueue-s",
                "content": "# Intuition\\nbacklog is two priority queues with opposote orderings\\n\\n# Approach\\n- try to match orders from backlog\\n- add new order to backlog\\n- count orders in backlog\\n\\n# Code\\n```\\nobject Solution {\\n  val MOD = 1_000_000_007\\n  def getNumberOfBacklogOrders(orders: Array[Array[Int]]): Int = {\\n    val sides = Vector(\\n      collection.mutable.PriorityQueue.empty[(Int,Long)],\\n      collection.mutable.PriorityQueue.empty[(Int,Long)]\\n        (Ordering.by[(Int, Long), Int](_._1).reverse)\\n    )\\n    def matchOrders(): Unit = {\\n      if(sides.forall(_.nonEmpty)) {\\n        val b = sides(0).dequeue\\n        val s = sides(1).dequeue\\n        // println(s\"    b=$b : s=$s\")\\n        if(b._1 < s._1) {\\n          sides(0).enqueue(b)\\n          sides(1).enqueue(s)\\n        } else {\\n          lazy val q = b._2 min s._2\\n          if(b._2 > q) { sides(0).enqueue((b._1, b._2 - q)) }\\n          if(s._2 > q) { sides(1).enqueue((s._1, s._2 - q)) }\\n          matchOrders()\\n        }\\n      }\\n    }\\n    def impl(seq: Seq[Seq[Int]]): Unit = {\\n      // println(s\"  impl($seq) : $sides\")\\n      matchOrders()\\n      if(seq.nonEmpty) {\\n        lazy val Seq(p,q,side) = seq.head\\n        sides(side).enqueue((p,q))\\n        impl(seq.tail)\\n      }\\n    }\\n    impl(orders.iterator.map(_.toSeq).toList)\\n    (sides.map(_.map(_._2).sum).sum % MOD).toInt\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  val MOD = 1_000_000_007\\n  def getNumberOfBacklogOrders(orders: Array[Array[Int]]): Int = {\\n    val sides = Vector(\\n      collection.mutable.PriorityQueue.empty[(Int,Long)],\\n      collection.mutable.PriorityQueue.empty[(Int,Long)]\\n        (Ordering.by[(Int, Long), Int](_._1).reverse)\\n    )\\n    def matchOrders(): Unit = {\\n      if(sides.forall(_.nonEmpty)) {\\n        val b = sides(0).dequeue\\n        val s = sides(1).dequeue\\n        // println(s\"    b=$b : s=$s\")\\n        if(b._1 < s._1) {\\n          sides(0).enqueue(b)\\n          sides(1).enqueue(s)\\n        } else {\\n          lazy val q = b._2 min s._2\\n          if(b._2 > q) { sides(0).enqueue((b._1, b._2 - q)) }\\n          if(s._2 > q) { sides(1).enqueue((s._1, s._2 - q)) }\\n          matchOrders()\\n        }\\n      }\\n    }\\n    def impl(seq: Seq[Seq[Int]]): Unit = {\\n      // println(s\"  impl($seq) : $sides\")\\n      matchOrders()\\n      if(seq.nonEmpty) {\\n        lazy val Seq(p,q,side) = seq.head\\n        sides(side).enqueue((p,q))\\n        impl(seq.tail)\\n      }\\n    }\\n    impl(orders.iterator.map(_.toSeq).toList)\\n    (sides.map(_.map(_._2).sum).sum % MOD).toInt\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2992369,
                "title": "python3-commented-sortedlist-better-space-efficiency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe definetely need some kind of data structure where we can quickly access the minimum/maximum sales price of the orders.\\n\\nTherefore we could use Min/Maxheaps or a SortedList.\\nMy first intuition is to to use a SortedList as we then can also update buy/sell orders of the same price if multiple leftover orders have the same price.\\n\\nWe can access the smalles element instantly and update prices in logN time.\\n\\nAlso we keep orders of equal price and type together in the queue by keeping and amount of orders with a certain price.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use the SortedList of the sortedcontainers library, as it provides convenience implementations for several methods we want to use (binary search, inserting and popping)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) as we might need to insert all orders (worst case only buy orders)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) as in the worst case all orders are buy/sell orders and have different prices.\\n\\nBut using the SortedList instead of the heap allows us to also find orders with an equal price and update the amount of those. Therefore in cases where there are a lot of orders with the same price, we use less space compared to the heap solutions.\\n\\n**I stand to be corrected on that one. Would love for hints, in case I\\'m wrong.**\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\n        # we use sorted lists for the buy and sell backlog\\n        #\\n        # when receiving a BUY ORDER we look at the minimum price\\n        # of the sell queue and subtract everything below that.\\n        # If something is left we try to find an equal price in the buy queue\\n        # and add to it or we insert into the buy queue\\n        #\\n        # when receiving a SELL ORDER we look at the maximum buy price\\n        # and subtract everything below that\\n        # If something is left we try to find an equal sell price in the sell\\n        # back log and add to it or we insert into the buy queue\\n        \\n        # make the sorted lists\\n        sell = SortedList(key=lambda x: x[0])\\n        buy = SortedList(key=lambda x: x[0])\\n\\n        # go through each of the orders and process them\\n        for price, amount, order_type in orders:\\n\\n            # check which type of order we have to process\\n            if order_type  == 0:  # buy order\\n\\n                # check the lowest sell orders we have in the backlog\\n                while sell and price >= sell[0][0] and amount >= sell[0][1]:\\n                    \\n                    # pop the lowest sell orders\\n                    _, sell_amount = sell.pop(0)\\n\\n                    # decrease the amount of buy orders\\n                    amount -= sell_amount\\n                \\n                # check whether we have more buy orders for a price than sell orders\\n                if (not sell or price < sell[0][0]) and amount:\\n\\n                    # find the right place in the buy queue\\n                    idx = buy.bisect((price, amount))\\n\\n                    # check whether we have similar prices\\n                    if idx > 0 and buy[idx-1] == price:\\n                        buy[idx] += amount\\n                    else:\\n                        buy.add([price, amount])\\n                \\n                # we have more sell orders for this price\\n                else:\\n                    sell[0][1] -= amount\\n\\n            elif order_type == 1:  # sell order\\n\\n                # check the lowest sell orders we have in the backlog\\n                while buy and price <= buy[-1][0] and amount >= buy[-1][1]:\\n                    \\n                    # pop the lowest sell orders\\n                    _, buy_amount = buy.pop()\\n\\n                    # decrease the amount of buy orders\\n                    amount -= buy_amount\\n                \\n                # check whether we have more sell orders for a price than buy orders\\n                if (not buy or price > buy[-1][0]) and amount:\\n\\n                    # find the right place in the sell queue\\n                    idx = sell.bisect((price, amount))\\n\\n                    # check whether we have similar prices\\n                    if idx > 0 and sell[idx-1] == price:\\n                        sell[idx] += amount\\n                    else:\\n                        sell.add([price, amount])\\n                \\n                # we have more buy orders for this price\\n                else:\\n                    buy[-1][1] -= amount\\n            else:\\n                raise NotImplementedError\\n\\n        # compute the result with the modulo\\n        MOD = 1_000_000_007\\n        result = 0\\n        for _, amount in sell:\\n            result = (result + amount) % MOD\\n        for _, amount in buy:\\n            result = (result + amount) % MOD\\n        return result \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\n        # we use sorted lists for the buy and sell backlog\\n        #\\n        # when receiving a BUY ORDER we look at the minimum price\\n        # of the sell queue and subtract everything below that.\\n        # If something is left we try to find an equal price in the buy queue\\n        # and add to it or we insert into the buy queue\\n        #\\n        # when receiving a SELL ORDER we look at the maximum buy price\\n        # and subtract everything below that\\n        # If something is left we try to find an equal sell price in the sell\\n        # back log and add to it or we insert into the buy queue\\n        \\n        # make the sorted lists\\n        sell = SortedList(key=lambda x: x[0])\\n        buy = SortedList(key=lambda x: x[0])\\n\\n        # go through each of the orders and process them\\n        for price, amount, order_type in orders:\\n\\n            # check which type of order we have to process\\n            if order_type  == 0:  # buy order\\n\\n                # check the lowest sell orders we have in the backlog\\n                while sell and price >= sell[0][0] and amount >= sell[0][1]:\\n                    \\n                    # pop the lowest sell orders\\n                    _, sell_amount = sell.pop(0)\\n\\n                    # decrease the amount of buy orders\\n                    amount -= sell_amount\\n                \\n                # check whether we have more buy orders for a price than sell orders\\n                if (not sell or price < sell[0][0]) and amount:\\n\\n                    # find the right place in the buy queue\\n                    idx = buy.bisect((price, amount))\\n\\n                    # check whether we have similar prices\\n                    if idx > 0 and buy[idx-1] == price:\\n                        buy[idx] += amount\\n                    else:\\n                        buy.add([price, amount])\\n                \\n                # we have more sell orders for this price\\n                else:\\n                    sell[0][1] -= amount\\n\\n            elif order_type == 1:  # sell order\\n\\n                # check the lowest sell orders we have in the backlog\\n                while buy and price <= buy[-1][0] and amount >= buy[-1][1]:\\n                    \\n                    # pop the lowest sell orders\\n                    _, buy_amount = buy.pop()\\n\\n                    # decrease the amount of buy orders\\n                    amount -= buy_amount\\n                \\n                # check whether we have more sell orders for a price than buy orders\\n                if (not buy or price > buy[-1][0]) and amount:\\n\\n                    # find the right place in the sell queue\\n                    idx = sell.bisect((price, amount))\\n\\n                    # check whether we have similar prices\\n                    if idx > 0 and sell[idx-1] == price:\\n                        sell[idx] += amount\\n                    else:\\n                        sell.add([price, amount])\\n                \\n                # we have more buy orders for this price\\n                else:\\n                    buy[-1][1] -= amount\\n            else:\\n                raise NotImplementedError\\n\\n        # compute the result with the modulo\\n        MOD = 1_000_000_007\\n        result = 0\\n        for _, amount in sell:\\n            result = (result + amount) % MOD\\n        for _, amount in buy:\\n            result = (result + amount) % MOD\\n        return result \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982623,
                "title": "c-two-priority-queue-and-simply-following-the-logic-the-problem-states",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell;\\n        priority_queue<pair<int, int>> buy;\\n        int res = 0, mod = 1e9+7;\\n\\n        for(auto o: orders){\\n            // if it is a buy order\\n            if(o[2] == 0){\\n                if(sell.empty() || (!sell.empty() && sell.top().first > o[0])){\\n                    buy.push({o[0], o[1]});\\n                }else{\\n                    while(!sell.empty() && sell.top().first <= o[0] && sell.top().second <= o[1]){\\n                        o[1] -= sell.top().second;\\n                        sell.pop();\\n                    }\\n\\n                    while(!sell.empty() && sell.top().first <= o[0] && sell.top().second > o[1] && o[1] > 0){\\n                        int price = sell.top().first, amount = sell.top().second - o[1];\\n                        o[1] = 0;\\n                        sell.pop();\\n                        sell.push({price, amount});\\n                    }\\n                    if(o[1] > 0){\\n                        buy.push({o[0], o[1]});\\n                    }\\n                }\\n            }\\n\\n            // if it is a sell order\\n            if(o[2] == 1){\\n                if(buy.empty() || (!buy.empty() && buy.top().first < o[0])){\\n                    sell.push(make_pair(o[0], o[1]));\\n                }else{\\n                    while(!buy.empty() && buy.top().first >= o[0] && buy.top().second <= o[1]){\\n                        o[1] -= buy.top().second;\\n                        buy.pop();\\n                    }\\n\\n                    while(!buy.empty() && buy.top().first >= o[0] && buy.top().second > o[1] && o[1] > 0){\\n                        int price = buy.top().first, amount = buy.top().second - o[1];\\n                        o[1] = 0;\\n                        buy.pop();\\n                        buy.push({price, amount});\\n                    }\\n                    if(o[1] > 0){\\n                        sell.push({o[0], o[1]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!buy.empty()){\\n            res = (res + buy.top().second) % mod;\\n            buy.pop();\\n        }\\n\\n        while(!sell.empty()){\\n            res = (res + sell.top().second) % mod;\\n            sell.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell;\\n        priority_queue<pair<int, int>> buy;\\n        int res = 0, mod = 1e9+7;\\n\\n        for(auto o: orders){\\n            // if it is a buy order\\n            if(o[2] == 0){\\n                if(sell.empty() || (!sell.empty() && sell.top().first > o[0])){\\n                    buy.push({o[0], o[1]});\\n                }else{\\n                    while(!sell.empty() && sell.top().first <= o[0] && sell.top().second <= o[1]){\\n                        o[1] -= sell.top().second;\\n                        sell.pop();\\n                    }\\n\\n                    while(!sell.empty() && sell.top().first <= o[0] && sell.top().second > o[1] && o[1] > 0){\\n                        int price = sell.top().first, amount = sell.top().second - o[1];\\n                        o[1] = 0;\\n                        sell.pop();\\n                        sell.push({price, amount});\\n                    }\\n                    if(o[1] > 0){\\n                        buy.push({o[0], o[1]});\\n                    }\\n                }\\n            }\\n\\n            // if it is a sell order\\n            if(o[2] == 1){\\n                if(buy.empty() || (!buy.empty() && buy.top().first < o[0])){\\n                    sell.push(make_pair(o[0], o[1]));\\n                }else{\\n                    while(!buy.empty() && buy.top().first >= o[0] && buy.top().second <= o[1]){\\n                        o[1] -= buy.top().second;\\n                        buy.pop();\\n                    }\\n\\n                    while(!buy.empty() && buy.top().first >= o[0] && buy.top().second > o[1] && o[1] > 0){\\n                        int price = buy.top().first, amount = buy.top().second - o[1];\\n                        o[1] = 0;\\n                        buy.pop();\\n                        buy.push({price, amount});\\n                    }\\n                    if(o[1] > 0){\\n                        sell.push({o[0], o[1]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        while(!buy.empty()){\\n            res = (res + buy.top().second) % mod;\\n            buy.pop();\\n        }\\n\\n        while(!sell.empty()){\\n            res = (res + sell.top().second) % mod;\\n            sell.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974759,
                "title": "1-min-heap-and-1-max-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n=orders.size();\\n        priority_queue<pair<int,int>>buy;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                while(sell.size()>0 and sell.top().first<=orders[i][0] and orders[i][1]!=0)\\n                {\\n                    int val=sell.top().second;\\n                    if(orders[i][1]<=sell.top().second)\\n                    {\\n                        val=val-orders[i][1];\\n                        int f=sell.top().first;\\n                        sell.pop();\\n                        sell.push({f,val});\\n                        orders[i][1]=0;\\n                    }\\n                    else{\\n                        orders[i][1]-=val;\\n                        sell.pop();\\n                    }\\n                }\\n                if(orders[i][1]!=0)\\n                buy.push({orders[i][0],orders[i][1]});\\n            }\\n            else{\\n                while(buy.size()>0 and buy.top().first>=orders[i][0] and orders[i][1]!=0)\\n                {\\n                   int val=buy.top().second; \\n                   if(orders[i][1]<=buy.top().second)\\n                   {\\n                       val-=orders[i][1]; \\n                       int f=buy.top().first;\\n                       buy.pop(); \\n                       buy.push({f,val});\\n                       orders[i][1]=0;\\n                   }\\n                    else{\\n                        orders[i][1]-=val;\\n                        buy.pop();\\n                    }\\n                }\\n                if(orders[i][1]!=0)\\n                sell.push({orders[i][0],orders[i][1]});\\n            }\\n        }\\n        int ans=0;\\n        while(!sell.empty()){\\n            ans=(ans+sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            ans=(ans+buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n=orders.size();\\n        priority_queue<pair<int,int>>buy;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                while(sell.size()>0 and sell.top().first<=orders[i][0] and orders[i][1]!=0)\\n                {\\n                    int val=sell.top().second;\\n                    if(orders[i][1]<=sell.top().second)\\n                    {\\n                        val=val-orders[i][1];\\n                        int f=sell.top().first;\\n                        sell.pop();\\n                        sell.push({f,val});\\n                        orders[i][1]=0;\\n                    }\\n                    else{\\n                        orders[i][1]-=val;\\n                        sell.pop();\\n                    }\\n                }\\n                if(orders[i][1]!=0)\\n                buy.push({orders[i][0],orders[i][1]});\\n            }\\n            else{\\n                while(buy.size()>0 and buy.top().first>=orders[i][0] and orders[i][1]!=0)\\n                {\\n                   int val=buy.top().second; \\n                   if(orders[i][1]<=buy.top().second)\\n                   {\\n                       val-=orders[i][1]; \\n                       int f=buy.top().first;\\n                       buy.pop(); \\n                       buy.push({f,val});\\n                       orders[i][1]=0;\\n                   }\\n                    else{\\n                        orders[i][1]-=val;\\n                        buy.pop();\\n                    }\\n                }\\n                if(orders[i][1]!=0)\\n                sell.push({orders[i][0],orders[i][1]});\\n            }\\n        }\\n        int ans=0;\\n        while(!sell.empty()){\\n            ans=(ans+sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            ans=(ans+buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        return ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970150,
                "title": "python-priority-q",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \"\"\"\\n            . balance buy order with sell when possible and return backlog after finish\\n            \\n            we can use 2 PQ and balance them ?\\n        \"\"\"\\n        \\n        \\n        \\n        pq_b = [] # (price, count) heaps data\\n        pq_s = []\\n        \\n        # cant heapify before since we need rolling comuptation\\n        \\n        \\n        for price, amount, otype in orders:\\n            \\n            if otype == 1: # sell order\\n                \\n                # pop until orders are satified, append rest to pq_b\\n                while pq_b and -pq_b[0][0] >= price and amount > 0:\\n                    last = heappop(pq_b)\\n                    if amount >= last[1]: \\n                        amount -= last[1]\\n                    else:\\n                        heappush(pq_b, (last[0], last[1] - amount))\\n                        amount = 0\\n\\n                if amount > 0:\\n                    heappush(pq_s, (price, amount))\\n                    \\n            else: # buy order\\n                while pq_s and pq_s[0][0] <= price and amount > 0:\\n                    last = heappop(pq_s)\\n                    if amount >= last[1]:\\n                        amount -= last[1]\\n                    else:\\n                        heappush(pq_s, (last[0], last[1] - amount))\\n                        amount = 0\\n                \\n                if amount > 0:\\n                    heappush(pq_b, (-price, amount))\\n        \\n        res = 0\\n        MOD = 1_000_000_007\\n        for order in pq_b + pq_s:\\n            res += order[1] \\n        \\n        return  res % MOD\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \"\"\"\\n            . balance buy order with sell when possible and return backlog after finish\\n            \\n            we can use 2 PQ and balance them ?\\n        \"\"\"\\n        \\n        \\n        \\n        pq_b = [] # (price, count) heaps data\\n        pq_s = []\\n        \\n        # cant heapify before since we need rolling comuptation\\n        \\n        \\n        for price, amount, otype in orders:\\n            \\n            if otype == 1: # sell order\\n                \\n                # pop until orders are satified, append rest to pq_b\\n                while pq_b and -pq_b[0][0] >= price and amount > 0:\\n                    last = heappop(pq_b)\\n                    if amount >= last[1]: \\n                        amount -= last[1]\\n                    else:\\n                        heappush(pq_b, (last[0], last[1] - amount))\\n                        amount = 0\\n\\n                if amount > 0:\\n                    heappush(pq_s, (price, amount))\\n                    \\n            else: # buy order\\n                while pq_s and pq_s[0][0] <= price and amount > 0:\\n                    last = heappop(pq_s)\\n                    if amount >= last[1]:\\n                        amount -= last[1]\\n                    else:\\n                        heappush(pq_s, (last[0], last[1] - amount))\\n                        amount = 0\\n                \\n                if amount > 0:\\n                    heappush(pq_b, (-price, amount))\\n        \\n        res = 0\\n        MOD = 1_000_000_007\\n        for order in pq_b + pq_s:\\n            res += order[1] \\n        \\n        return  res % MOD\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953451,
                "title": "python-heap-o-nlogn",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyBacklog = []\\n        sellBacklog = []\\n        for p, amount, t in orders:\\n            if t:\\n                while amount and buyBacklog and -buyBacklog[0][0] >= p:\\n                    bp, ba = heappop(buyBacklog)\\n                    base = min(amount, ba)\\n                    amount -= base\\n                    ba -= base\\n                    if ba:\\n                        heappush(buyBacklog, (bp, ba))\\n                if amount:\\n                    heappush(sellBacklog, (p,amount))\\n            else:\\n                while amount and sellBacklog and sellBacklog[0][0] <= p:\\n                    sp, sa = heappop(sellBacklog)\\n                    base = min(amount, sa)\\n                    amount -= base\\n                    sa -= base\\n                    if sa:\\n                        heappush(sellBacklog, (sp, sa)) \\n                if amount:\\n                    heappush(buyBacklog, (-p, amount))\\n        return (sum([ba for bp, ba in buyBacklog]) + sum([sa for sp, sa in sellBacklog]))%(10**9 + 7)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyBacklog = []\\n        sellBacklog = []\\n        for p, amount, t in orders:\\n            if t:\\n                while amount and buyBacklog and -buyBacklog[0][0] >= p:\\n                    bp, ba = heappop(buyBacklog)\\n                    base = min(amount, ba)\\n                    amount -= base\\n                    ba -= base\\n                    if ba:\\n                        heappush(buyBacklog, (bp, ba))\\n                if amount:\\n                    heappush(sellBacklog, (p,amount))\\n            else:\\n                while amount and sellBacklog and sellBacklog[0][0] <= p:\\n                    sp, sa = heappop(sellBacklog)\\n                    base = min(amount, sa)\\n                    amount -= base\\n                    sa -= base\\n                    if sa:\\n                        heappush(sellBacklog, (sp, sa)) \\n                if amount:\\n                    heappush(buyBacklog, (-p, amount))\\n        return (sum([ba for bp, ba in buyBacklog]) + sum([sa for sp, sa in sellBacklog]))%(10**9 + 7)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876347,
                "title": "go-use-two-heaps",
                "content": "# Intuition\\n\\nThis is a typical use case to find maximum and minimum elements with heap. The buy orders are the ones which we would like to find its highest price at any point of time, and thus is a maximum heap, and similarly, the sell orders are the ones which we would like to find its lowest price at any point of time, and thus is a minimum heap.\\n\\n# Approach\\n\\n1. For any new buy order, we look at: a) whethere there is any sell orders, if no, push into buy orders heap. b) is the sell order within the price range, if no, push into buy orders heap. c) if it is within the range, then simply update the amount in the corresponding sell order, and pop it up if it is 100% fullfilled. d) if this buy order is not 100% fullfilled, continue to the next loop\\n2. For any new sell order, we look at: a) whethere there is any buy orders, if no, push into sell orders heap. b) is the buy order within the price range, if no, push into sell orders heap. c) if it is within the range, then simply update the amount in the corresponding buy order, and pop it up if it is 100% fullfilled. d) if this sell order is not 100% fullfilled, continue to the next loop.\\n\\n# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    var sells = &sellAsc{}\\n\\tvar buys = &buyDesc{}\\n\\n\\tfor i, o := range orders {\\n\\t\\tif o[2] == 0 {\\n\\t\\t\\t// this is a buy order, find the smallest sell order\\n\\t\\t\\tfor {\\n\\n\\t\\t\\t\\tif len(*sells) == 0 {\\n\\t\\t\\t\\t\\theap.Push(buys, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpeek := (*sells)[0]\\n\\t\\t\\t\\tif peek.price > o[0] {\\n\\t\\t\\t\\t\\theap.Push(buys, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// can be fullfilled\\n\\t\\t\\t\\tif peek.amount > o[1] {\\n\\t\\t\\t\\t\\t(*sells)[0].amount = peek.amount - o[1]\\n\\t\\t\\t\\t\\to[1] = 0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theap.Pop(sells)\\n\\t\\t\\t\\t\\to[1] = o[1] - peek.amount\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif o[1] == 0 {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// this is a sell order, find the largest buy order\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tif len(*buys) == 0 {\\n\\t\\t\\t\\t\\theap.Push(sells, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpeek := (*buys)[0]\\n\\t\\t\\t\\tif peek.price < o[0] {\\n\\t\\t\\t\\t\\theap.Push(sells, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// can be fullfilled\\n\\t\\t\\t\\tif peek.amount > o[1] {\\n\\t\\t\\t\\t\\t(*buys)[0].amount = peek.amount - o[1]\\n\\t\\t\\t\\t\\to[1] = 0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theap.Pop(buys)\\n\\t\\t\\t\\t\\to[1] = o[1] - peek.amount\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif o[1] == 0 {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar left int\\n\\tfor _, o := range *buys {\\n\\t\\tleft = left + o.amount\\n\\t\\tif left >= 1000000007 {\\n\\t\\t\\tleft = left % 1000000007\\n\\t\\t}\\n\\t}\\n\\tfor _, o := range *sells {\\n\\t\\tleft = left + o.amount\\n\\t\\tif left >= 1000000007 {\\n\\t\\t\\tleft = left % 1000000007\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n\\ntype order struct {\\n\\tamount int\\n\\tprice  int\\n\\tterm   int\\n}\\n\\ntype sellAsc []order\\n\\nfunc (s sellAsc) Len() int {\\n\\treturn len(s)\\n}\\n\\nfunc (s sellAsc) Less(i, j int) bool {\\n\\tif s[i].price < s[j].price {\\n\\t\\treturn true\\n\\t}\\n\\tif s[i].price > s[j].price {\\n\\t\\treturn false\\n\\t}\\n\\treturn s[i].term < s[j].term\\n}\\n\\nfunc (s sellAsc) Swap(i, j int) {\\n\\ts[i], s[j] = s[j], s[i]\\n}\\n\\nfunc (s *sellAsc) Push(x interface{}) {\\n\\t*s = append(*s, x.(order))\\n}\\n\\nfunc (s *sellAsc) Pop() interface{} {\\n\\told := *s\\n\\tn := len(old)\\n\\to := old[n-1]\\n\\t*s = old[:n-1]\\n\\treturn o\\n}\\n\\ntype buyDesc []order\\n\\nfunc (b buyDesc) Len() int {\\n\\treturn len(b)\\n}\\n\\nfunc (b buyDesc) Less(i, j int) bool {\\n\\tif b[i].price > b[j].price {\\n\\t\\treturn true\\n\\t}\\n\\tif b[i].price < b[j].price {\\n\\t\\treturn false\\n\\t}\\n\\treturn b[i].term < b[j].term\\n}\\n\\nfunc (b buyDesc) Swap(i, j int) {\\n\\tb[i], b[j] = b[j], b[i]\\n}\\n\\nfunc (b *buyDesc) Push(x interface{}) {\\n\\t*b = append(*b, x.(order))\\n}\\n\\nfunc (b *buyDesc) Pop() interface{} {\\n\\told := *b\\n\\tn := len(old)\\n\\to := old[n-1]\\n\\t*b = old[:n-1]\\n\\treturn o\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    var sells = &sellAsc{}\\n\\tvar buys = &buyDesc{}\\n\\n\\tfor i, o := range orders {\\n\\t\\tif o[2] == 0 {\\n\\t\\t\\t// this is a buy order, find the smallest sell order\\n\\t\\t\\tfor {\\n\\n\\t\\t\\t\\tif len(*sells) == 0 {\\n\\t\\t\\t\\t\\theap.Push(buys, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpeek := (*sells)[0]\\n\\t\\t\\t\\tif peek.price > o[0] {\\n\\t\\t\\t\\t\\theap.Push(buys, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// can be fullfilled\\n\\t\\t\\t\\tif peek.amount > o[1] {\\n\\t\\t\\t\\t\\t(*sells)[0].amount = peek.amount - o[1]\\n\\t\\t\\t\\t\\to[1] = 0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theap.Pop(sells)\\n\\t\\t\\t\\t\\to[1] = o[1] - peek.amount\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif o[1] == 0 {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// this is a sell order, find the largest buy order\\n\\t\\t\\tfor {\\n\\t\\t\\t\\tif len(*buys) == 0 {\\n\\t\\t\\t\\t\\theap.Push(sells, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpeek := (*buys)[0]\\n\\t\\t\\t\\tif peek.price < o[0] {\\n\\t\\t\\t\\t\\theap.Push(sells, order{price: o[0], amount: o[1], term: i})\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// can be fullfilled\\n\\t\\t\\t\\tif peek.amount > o[1] {\\n\\t\\t\\t\\t\\t(*buys)[0].amount = peek.amount - o[1]\\n\\t\\t\\t\\t\\to[1] = 0\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theap.Pop(buys)\\n\\t\\t\\t\\t\\to[1] = o[1] - peek.amount\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif o[1] == 0 {\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvar left int\\n\\tfor _, o := range *buys {\\n\\t\\tleft = left + o.amount\\n\\t\\tif left >= 1000000007 {\\n\\t\\t\\tleft = left % 1000000007\\n\\t\\t}\\n\\t}\\n\\tfor _, o := range *sells {\\n\\t\\tleft = left + o.amount\\n\\t\\tif left >= 1000000007 {\\n\\t\\t\\tleft = left % 1000000007\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n\\ntype order struct {\\n\\tamount int\\n\\tprice  int\\n\\tterm   int\\n}\\n\\ntype sellAsc []order\\n\\nfunc (s sellAsc) Len() int {\\n\\treturn len(s)\\n}\\n\\nfunc (s sellAsc) Less(i, j int) bool {\\n\\tif s[i].price < s[j].price {\\n\\t\\treturn true\\n\\t}\\n\\tif s[i].price > s[j].price {\\n\\t\\treturn false\\n\\t}\\n\\treturn s[i].term < s[j].term\\n}\\n\\nfunc (s sellAsc) Swap(i, j int) {\\n\\ts[i], s[j] = s[j], s[i]\\n}\\n\\nfunc (s *sellAsc) Push(x interface{}) {\\n\\t*s = append(*s, x.(order))\\n}\\n\\nfunc (s *sellAsc) Pop() interface{} {\\n\\told := *s\\n\\tn := len(old)\\n\\to := old[n-1]\\n\\t*s = old[:n-1]\\n\\treturn o\\n}\\n\\ntype buyDesc []order\\n\\nfunc (b buyDesc) Len() int {\\n\\treturn len(b)\\n}\\n\\nfunc (b buyDesc) Less(i, j int) bool {\\n\\tif b[i].price > b[j].price {\\n\\t\\treturn true\\n\\t}\\n\\tif b[i].price < b[j].price {\\n\\t\\treturn false\\n\\t}\\n\\treturn b[i].term < b[j].term\\n}\\n\\nfunc (b buyDesc) Swap(i, j int) {\\n\\tb[i], b[j] = b[j], b[i]\\n}\\n\\nfunc (b *buyDesc) Push(x interface{}) {\\n\\t*b = append(*b, x.(order))\\n}\\n\\nfunc (b *buyDesc) Pop() interface{} {\\n\\told := *b\\n\\tn := len(old)\\n\\to := old[n-1]\\n\\t*b = old[:n-1]\\n\\treturn o\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849375,
                "title": "c-2-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    map<int, ll> buy, sell;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        ll res = 0, mod = 1e9+7;\\n        for(auto & e : orders) {\\n            res = (res + e[1])%mod;\\n            vector<int> to_del;\\n            if(e[2]) {\\n                for(auto it = buy.rbegin();  it != buy.rend() && e[1] && it->first >= e[0]; it++) {\\n                    ll done = min(it->second, (ll)e[1]);\\n                    e[1] -= done;\\n                    it->second -= done;\\n                    if(it->second == 0) to_del.push_back(it->first);\\n                    res = (res - 2*done + mod)%mod;\\n                }\\n                for(auto k : to_del) buy.erase(k);\\n                if(e[1]) sell[e[0]] += e[1];\\n            } else {\\n                for(auto it = sell.begin(); it != sell.end() && e[1] && it->first <= e[0]; it++) {\\n                    ll done = min(it->second, (ll)e[1]);\\n                    e[1] -= done;\\n                    it->second -= done;\\n                    if(it->second == 0) to_del.push_back(it->first);\\n                    res = (res - 2*done + mod)%mod;\\n                }\\n                for(auto k : to_del) sell.erase(k);\\n                if(e[1]) buy[e[0]] += e[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    map<int, ll> buy, sell;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        ll res = 0, mod = 1e9+7;\\n        for(auto & e : orders) {\\n            res = (res + e[1])%mod;\\n            vector<int> to_del;\\n            if(e[2]) {\\n                for(auto it = buy.rbegin();  it != buy.rend() && e[1] && it->first >= e[0]; it++) {\\n                    ll done = min(it->second, (ll)e[1]);\\n                    e[1] -= done;\\n                    it->second -= done;\\n                    if(it->second == 0) to_del.push_back(it->first);\\n                    res = (res - 2*done + mod)%mod;\\n                }\\n                for(auto k : to_del) buy.erase(k);\\n                if(e[1]) sell[e[0]] += e[1];\\n            } else {\\n                for(auto it = sell.begin(); it != sell.end() && e[1] && it->first <= e[0]; it++) {\\n                    ll done = min(it->second, (ll)e[1]);\\n                    e[1] -= done;\\n                    it->second -= done;\\n                    if(it->second == 0) to_del.push_back(it->first);\\n                    res = (res - 2*done + mod)%mod;\\n                }\\n                for(auto k : to_del) sell.erase(k);\\n                if(e[1]) buy[e[0]] += e[1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815536,
                "title": "kotlin-100-100-solution",
                "content": "```\\nclass Solution {\\n \\n    data class Order(\\n        val price: Int,\\n        val amount: Int\\n    )\\n    \\n    fun IntArray.toOrder(): Order {\\n        return Order(price = this[0], amount = this[1])\\n    }\\n    \\n    val sellsBacklog = PriorityQueue<Order>(compareBy { it.price } )\\n    val buysBacklog = PriorityQueue<Order>(compareByDescending { it.price } )\\n    \\n    fun getNumberOfBacklogOrders(orders: Array<IntArray>): Int {\\n        for (array in orders) {\\n            when (array[2]) {\\n                0 -> buysBacklog.add(array.toOrder())\\n                1 -> sellsBacklog.add(array.toOrder())\\n                else -> throw IllegalArgumentException()\\n            }\\n            processOrders()\\n        }\\n        \\n        return countBacklogOrders(sellsBacklog)\\n            .plusModulo(countBacklogOrders(buysBacklog))\\n    }\\n    \\n    private fun processOrders() {\\n        while (sellsBacklog.isNotEmpty()\\n               && buysBacklog.isNotEmpty()\\n               && buysBacklog.peek().price >= sellsBacklog.peek().price ) {\\n            // Match found. Find the minimum amount matched.\\n            val sell = sellsBacklog.remove()\\n            val buy = buysBacklog.remove()\\n            val minMatched = Math.min(buy.amount, sell.amount)\\n            // Put back the remainder, if any\\n            if (sell.amount > minMatched) {\\n                sellsBacklog.add(sell.copy(amount = sell.amount - minMatched))\\n            } else if (buy.amount > minMatched) {\\n                buysBacklog.add(buy.copy(amount = buy.amount - minMatched))\\n            }\\n\\n        }\\n    }\\n    \\n    private fun countBacklogOrders(backlog: PriorityQueue<Order>): Int {\\n        var count = 0\\n        while (backlog.isNotEmpty()) {\\n            val order = backlog.remove()\\n            count = count.plusModulo(order.amount)\\n        }\\n        return count\\n    }\\n    \\n    private fun Int.plusModulo(add: Int, mod: Int = 1000000007): Int {\\n        return ((this.toLong() + add.toLong()) % mod).toInt()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n \\n    data class Order(\\n        val price: Int,\\n        val amount: Int\\n    )\\n    \\n    fun IntArray.toOrder(): Order {\\n        return Order(price = this[0], amount = this[1])\\n    }\\n    \\n    val sellsBacklog = PriorityQueue<Order>(compareBy { it.price } )\\n    val buysBacklog = PriorityQueue<Order>(compareByDescending { it.price } )\\n    \\n    fun getNumberOfBacklogOrders(orders: Array<IntArray>): Int {\\n        for (array in orders) {\\n            when (array[2]) {\\n                0 -> buysBacklog.add(array.toOrder())\\n                1 -> sellsBacklog.add(array.toOrder())\\n                else -> throw IllegalArgumentException()\\n            }\\n            processOrders()\\n        }\\n        \\n        return countBacklogOrders(sellsBacklog)\\n            .plusModulo(countBacklogOrders(buysBacklog))\\n    }\\n    \\n    private fun processOrders() {\\n        while (sellsBacklog.isNotEmpty()\\n               && buysBacklog.isNotEmpty()\\n               && buysBacklog.peek().price >= sellsBacklog.peek().price ) {\\n            // Match found. Find the minimum amount matched.\\n            val sell = sellsBacklog.remove()\\n            val buy = buysBacklog.remove()\\n            val minMatched = Math.min(buy.amount, sell.amount)\\n            // Put back the remainder, if any\\n            if (sell.amount > minMatched) {\\n                sellsBacklog.add(sell.copy(amount = sell.amount - minMatched))\\n            } else if (buy.amount > minMatched) {\\n                buysBacklog.add(buy.copy(amount = buy.amount - minMatched))\\n            }\\n\\n        }\\n    }\\n    \\n    private fun countBacklogOrders(backlog: PriorityQueue<Order>): Int {\\n        var count = 0\\n        while (backlog.isNotEmpty()) {\\n            val order = backlog.remove()\\n            count = count.plusModulo(order.amount)\\n        }\\n        return count\\n    }\\n    \\n    private fun Int.plusModulo(add: Int, mod: Int = 1000000007): Int {\\n        return ((this.toLong() + add.toLong()) % mod).toInt()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811912,
                "title": "simple-java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        // Create a sell orders minHeap\\n        PriorityQueue<int[]> sellOrdersHeap = new PriorityQueue<>((order1, order2) -> {\\n            return Integer.compare(order1[0], order2[0]);\\n        });\\n\\n        // Create a buy orders maxHeap\\n        PriorityQueue<int[]> buyOrdersHeap = new PriorityQueue<>((order1, order2) -> {\\n            return Integer.compare(order2[0], order1[0]);\\n        });\\n\\n        // Iterate through the orders, add to heap and match with corresponding buy or sell orders\\n        for(int[] order: orders) {\\n            if(order[2] == 1) {\\n                sellOrdersHeap.offer(order);\\n            } else if(order[2] == 0) {\\n                buyOrdersHeap.offer(order);\\n            }\\n            while(!buyOrdersHeap.isEmpty() && !sellOrdersHeap.isEmpty() \\n                && buyOrdersHeap.peek()[0] >= sellOrdersHeap.peek()[0]) {\\n                matchOrders(buyOrdersHeap, sellOrdersHeap);\\n            }\\n        }\\n        // Return the outstanding offers adding both from buy and sell orders heap\\n        return outstandingOrders(buyOrdersHeap, sellOrdersHeap);\\n    }\\n\\n    private void matchOrders(PriorityQueue<int[]> buyOrdersHeap, PriorityQueue<int[]> sellOrdersHeap) {\\n        int matchedOrders = Math.min(buyOrdersHeap.peek()[1], sellOrdersHeap.peek()[1]);\\n        buyOrdersHeap.peek()[1] -= matchedOrders;\\n        sellOrdersHeap.peek()[1] -= matchedOrders;\\n        if(buyOrdersHeap.peek()[1] == 0) {\\n            buyOrdersHeap.poll();\\n        }\\n        if(sellOrdersHeap.peek()[1] == 0) {\\n            sellOrdersHeap.poll();\\n        }\\n    }\\n\\n    private int outstandingOrders(PriorityQueue<int[]> buyOrdersHeap, PriorityQueue<int[]> sellOrdersHeap) {\\n        int outstandingOrders = 0;\\n        int moduloValue = 1000000007;\\n        for(int[] order: buyOrdersHeap) {\\n            outstandingOrders = (outstandingOrders + order[1]) % moduloValue;\\n        }\\n        for(int[] order: sellOrdersHeap) {\\n            outstandingOrders = (outstandingOrders + order[1]) % moduloValue;\\n        }\\n        return outstandingOrders;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        // Create a sell orders minHeap\\n        PriorityQueue<int[]> sellOrdersHeap = new PriorityQueue<>((order1, order2) -> {\\n            return Integer.compare(order1[0], order2[0]);\\n        });\\n\\n        // Create a buy orders maxHeap\\n        PriorityQueue<int[]> buyOrdersHeap = new PriorityQueue<>((order1, order2) -> {\\n            return Integer.compare(order2[0], order1[0]);\\n        });\\n\\n        // Iterate through the orders, add to heap and match with corresponding buy or sell orders\\n        for(int[] order: orders) {\\n            if(order[2] == 1) {\\n                sellOrdersHeap.offer(order);\\n            } else if(order[2] == 0) {\\n                buyOrdersHeap.offer(order);\\n            }\\n            while(!buyOrdersHeap.isEmpty() && !sellOrdersHeap.isEmpty() \\n                && buyOrdersHeap.peek()[0] >= sellOrdersHeap.peek()[0]) {\\n                matchOrders(buyOrdersHeap, sellOrdersHeap);\\n            }\\n        }\\n        // Return the outstanding offers adding both from buy and sell orders heap\\n        return outstandingOrders(buyOrdersHeap, sellOrdersHeap);\\n    }\\n\\n    private void matchOrders(PriorityQueue<int[]> buyOrdersHeap, PriorityQueue<int[]> sellOrdersHeap) {\\n        int matchedOrders = Math.min(buyOrdersHeap.peek()[1], sellOrdersHeap.peek()[1]);\\n        buyOrdersHeap.peek()[1] -= matchedOrders;\\n        sellOrdersHeap.peek()[1] -= matchedOrders;\\n        if(buyOrdersHeap.peek()[1] == 0) {\\n            buyOrdersHeap.poll();\\n        }\\n        if(sellOrdersHeap.peek()[1] == 0) {\\n            sellOrdersHeap.poll();\\n        }\\n    }\\n\\n    private int outstandingOrders(PriorityQueue<int[]> buyOrdersHeap, PriorityQueue<int[]> sellOrdersHeap) {\\n        int outstandingOrders = 0;\\n        int moduloValue = 1000000007;\\n        for(int[] order: buyOrdersHeap) {\\n            outstandingOrders = (outstandingOrders + order[1]) % moduloValue;\\n        }\\n        for(int[] order: sellOrdersHeap) {\\n            outstandingOrders = (outstandingOrders + order[1]) % moduloValue;\\n        }\\n        return outstandingOrders;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762438,
                "title": "easy-solution-c-with-2-priority-queues",
                "content": "```\\n  class Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        const int MOD = 1e9 + 7;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell_backlog;\\n        priority_queue<pair<int, int>> buy_backlog;\\n        \\n        for (const auto &order : orders) {\\n            int price = order[0], amount = order[1], orderType = order[2];\\n            if (orderType == 0) {\\n                // buy order\\n                while (amount > 0 && !sell_backlog.empty() \\n                       && sell_backlog.top().first <= price) {\\n                    auto [matching_price, matching_amount] = sell_backlog.top();\\n                    sell_backlog.pop();\\n                    int min_amount = min(amount, matching_amount);\\n                    amount -= min_amount;\\n                    matching_amount -= min_amount;\\n                    if (matching_amount > 0) \\n                        sell_backlog.push(make_pair(matching_price, matching_amount));\\n                }\\n                if (amount > 0) buy_backlog.push(make_pair(price, amount));\\n            } else {\\n                // sell order\\n                while (amount > 0 && !buy_backlog.empty() \\n                       && buy_backlog.top().first >= price) {\\n                    auto [matching_price, matching_amount] = buy_backlog.top();\\n                    buy_backlog.pop();\\n                    int min_amount = min(amount, matching_amount);\\n                    amount -= min_amount;\\n                    matching_amount -= min_amount;\\n                    if (matching_amount > 0) \\n                        buy_backlog.push(make_pair(matching_price, matching_amount));\\n                }\\n                if (amount > 0) sell_backlog.push(make_pair(price, amount));\\n            }\\n        }\\n        \\n        long long total_amount = 0;\\n        // cout << \"Buy Backlog: \\\\n\";\\n        while (!buy_backlog.empty()) {\\n            auto [_price, amount] = buy_backlog.top();\\n            // cout << _price << \" \" << amount << endl; \\n            buy_backlog.pop();\\n            total_amount = (total_amount + static_cast<long long>(amount)) % MOD;\\n        }\\n        // cout << \"Sell Backlog: \\\\n\";\\n        while (!sell_backlog.empty()) {\\n            auto [_price, amount] = sell_backlog.top();\\n            // cout << _price << \" \" << amount << endl;\\n            sell_backlog.pop();\\n            total_amount = (total_amount + static_cast<long long>(amount)) % MOD;\\n        }\\n        \\n        return total_amount;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        const int MOD = 1e9 + 7;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sell_backlog;\\n        priority_queue<pair<int, int>> buy_backlog;\\n        \\n        for (const auto &order : orders) {\\n            int price = order[0], amount = order[1], orderType = order[2];\\n            if (orderType == 0) {\\n                // buy order\\n                while (amount > 0 && !sell_backlog.empty() \\n                       && sell_backlog.top().first <= price) {\\n                    auto [matching_price, matching_amount] = sell_backlog.top();\\n                    sell_backlog.pop();\\n                    int min_amount = min(amount, matching_amount);\\n                    amount -= min_amount;\\n                    matching_amount -= min_amount;\\n                    if (matching_amount > 0) \\n                        sell_backlog.push(make_pair(matching_price, matching_amount));\\n                }\\n                if (amount > 0) buy_backlog.push(make_pair(price, amount));\\n            } else {\\n                // sell order\\n                while (amount > 0 && !buy_backlog.empty() \\n                       && buy_backlog.top().first >= price) {\\n                    auto [matching_price, matching_amount] = buy_backlog.top();\\n                    buy_backlog.pop();\\n                    int min_amount = min(amount, matching_amount);\\n                    amount -= min_amount;\\n                    matching_amount -= min_amount;\\n                    if (matching_amount > 0) \\n                        buy_backlog.push(make_pair(matching_price, matching_amount));\\n                }\\n                if (amount > 0) sell_backlog.push(make_pair(price, amount));\\n            }\\n        }\\n        \\n        long long total_amount = 0;\\n        // cout << \"Buy Backlog: \\\\n\";\\n        while (!buy_backlog.empty()) {\\n            auto [_price, amount] = buy_backlog.top();\\n            // cout << _price << \" \" << amount << endl; \\n            buy_backlog.pop();\\n            total_amount = (total_amount + static_cast<long long>(amount)) % MOD;\\n        }\\n        // cout << \"Sell Backlog: \\\\n\";\\n        while (!sell_backlog.empty()) {\\n            auto [_price, amount] = sell_backlog.top();\\n            // cout << _price << \" \" << amount << endl;\\n            sell_backlog.pop();\\n            total_amount = (total_amount + static_cast<long long>(amount)) % MOD;\\n        }\\n        \\n        return total_amount;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2728313,
                "title": "python-heap-solution-commented-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # Initialising the buy order heap, the sell order heap and the result variable\\n        buyOrderHeap, sellOrderHeap, remainingOrders = [], [], 0\\n        # Iterate through all the orders which are placed in our little stock market simulation\\n        for price, numOrders, orderType in orders:\\n            # First, result variable will be incremented by the number of orders in the current order\\n            remainingOrders += numOrders\\n            # If the order is a sell order, store it in the sell order min heap\\n            if orderType:\\n                heappush(sellOrderHeap, (price, numOrders))\\n            # If the order is a buy order, store it in the buy order max heap\\n            else:\\n                heappush(buyOrderHeap, (-price, numOrders))\\n            # Run this loop as long as matching orders are found\\n            while sellOrderHeap and buyOrderHeap and sellOrderHeap[0][0] <= -buyOrderHeap[0][0]:\\n                # Pop the matching sell order from the sell order heap\\n                sellPrice, numSellOrders = heappop(sellOrderHeap)\\n                # Pop the matching buy order from the buy order heap\\n                buyPrice, numBuyOrders = heappop(buyOrderHeap)\\n                # Execute the orders\\n                executedOrders = min(numSellOrders, numBuyOrders)\\n                # Decrement the amount of executed orders from the result variable\\n                # Since buy orders amount and sell orders amount are both decremented by the number of executed orders\\n                # we decrement 2 * executed orders from the result variable\\n                remainingOrders -= (2 * executedOrders)\\n                # If sell orders were more than buy orders, we push the remaining sell orders in the sell order heap\\n                if numSellOrders > executedOrders:\\n                    heappush(sellOrderHeap, (sellPrice, numSellOrders - executedOrders))\\n                # If buy orders were more than sell orders, we push the remaining buy orders in the buy order heap\\n                if numBuyOrders > executedOrders:\\n                    heappush(buyOrderHeap, (buyPrice, numBuyOrders - executedOrders))\\n        # Return the remaining backlog orders\\n        return remainingOrders % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        # Initialising the buy order heap, the sell order heap and the result variable\\n        buyOrderHeap, sellOrderHeap, remainingOrders = [], [], 0\\n        # Iterate through all the orders which are placed in our little stock market simulation\\n        for price, numOrders, orderType in orders:\\n            # First, result variable will be incremented by the number of orders in the current order\\n            remainingOrders += numOrders\\n            # If the order is a sell order, store it in the sell order min heap\\n            if orderType:\\n                heappush(sellOrderHeap, (price, numOrders))\\n            # If the order is a buy order, store it in the buy order max heap\\n            else:\\n                heappush(buyOrderHeap, (-price, numOrders))\\n            # Run this loop as long as matching orders are found\\n            while sellOrderHeap and buyOrderHeap and sellOrderHeap[0][0] <= -buyOrderHeap[0][0]:\\n                # Pop the matching sell order from the sell order heap\\n                sellPrice, numSellOrders = heappop(sellOrderHeap)\\n                # Pop the matching buy order from the buy order heap\\n                buyPrice, numBuyOrders = heappop(buyOrderHeap)\\n                # Execute the orders\\n                executedOrders = min(numSellOrders, numBuyOrders)\\n                # Decrement the amount of executed orders from the result variable\\n                # Since buy orders amount and sell orders amount are both decremented by the number of executed orders\\n                # we decrement 2 * executed orders from the result variable\\n                remainingOrders -= (2 * executedOrders)\\n                # If sell orders were more than buy orders, we push the remaining sell orders in the sell order heap\\n                if numSellOrders > executedOrders:\\n                    heappush(sellOrderHeap, (sellPrice, numSellOrders - executedOrders))\\n                # If buy orders were more than sell orders, we push the remaining buy orders in the buy order heap\\n                if numBuyOrders > executedOrders:\\n                    heappush(buyOrderHeap, (buyPrice, numBuyOrders - executedOrders))\\n        # Return the remaining backlog orders\\n        return remainingOrders % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726652,
                "title": "readable-python-2-heaps",
                "content": "\\t\\t\\tbuyOrders = [] # max heap\\n\\t\\t\\tsellOrders = [] # min heap\\n\\t\\t\\t# iterate through orders \\n\\t\\t\\tfor price, amount, orderType in orders:\\n\\t\\t\\t\\tif orderType == 0: # buy order \\n\\t\\t\\t\\t\\theappush(buyOrders, (-price, amount))\\n\\t\\t\\t\\telse: # sell order \\n\\t\\t\\t\\t\\theappush(sellOrders, (price, amount))\\n\\t\\t\\t\\t# match orders\\n\\t\\t\\t\\twhile buyOrders and sellOrders and -buyOrders[0][0] >= sellOrders[0][0]:\\n\\t\\t\\t\\t\\tbuyPrice, buyAmount = heappop(buyOrders)\\n\\t\\t\\t\\t\\tsellPrice, sellAmount = heappop(sellOrders)\\n\\t\\t\\t\\t\\tif buyAmount < sellAmount:\\n\\t\\t\\t\\t\\t\\theappush(sellOrders, (sellPrice, sellAmount - buyAmount))\\n\\t\\t\\t\\t\\telif buyAmount > sellAmount:\\n\\t\\t\\t\\t\\t\\theappush(buyOrders, (buyPrice, buyAmount - sellAmount))\\n\\t\\t\\t# return amount of backlog buy and sell orders \\n\\t\\t\\treturn (sum(x[1] for x in sellOrders) + sum(x[1] for x in buyOrders)) % (10**9+7)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\t\\t\\tbuyOrders = [] # max heap\\n\\t\\t\\tsellOrders = [] # min heap\\n\\t\\t\\t# iterate through orders \\n\\t\\t\\tfor price, amount, orderType in orders:\\n\\t\\t\\t\\tif orderType == 0: # buy order \\n\\t\\t\\t\\t\\theappush(buyOrders, (-price, amount))\\n\\t\\t\\t\\telse: # sell order \\n\\t\\t\\t\\t\\theappush(sellOrders, (price, amount))\\n\\t\\t\\t\\t# match orders\\n\\t\\t\\t\\twhile buyOrders and sellOrders and -buyOrders[0][0] >= sellOrders[0][0]:\\n\\t\\t\\t\\t\\tbuyPrice, buyAmount = heappop(buyOrders)\\n\\t\\t\\t\\t\\tsellPrice, sellAmount = heappop(sellOrders)\\n\\t\\t\\t\\t\\tif buyAmount < sellAmount:\\n\\t\\t\\t\\t\\t\\theappush(sellOrders, (sellPrice, sellAmount - buyAmount))\\n\\t\\t\\t\\t\\telif buyAmount > sellAmount:\\n\\t\\t\\t\\t\\t\\theappush(buyOrders, (buyPrice, buyAmount - sellAmount))\\n\\t\\t\\t# return amount of backlog buy and sell orders \\n\\t\\t\\treturn (sum(x[1] for x in sellOrders) + sum(x[1] for x in buyOrders)) % (10**9+7)",
                "codeTag": "Unknown"
            },
            {
                "id": 2684963,
                "title": "golang-priority-queue",
                "content": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buyBacklog := MaxHeap{}\\n    sellBacklog := MinHeap{}\\n    \\n    for _, order := range orders{\\n        price := order[0]\\n        amount := order[1]\\n        orderType := order[2]\\n        \\n        if orderType == 0 {\\n            for amount > 0 && len(sellBacklog) > 0 && sellBacklog[0][0] <= price {\\n                item := heap.Pop(&sellBacklog).([2]int)\\n                \\n                item[1] -= amount\\n                if item[1] <= 0 {\\n                    amount = -item[1]\\n                    item[1] = 0\\n                } else {\\n                    amount = 0\\n                    heap.Push(&sellBacklog, item)\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                heap.Push(&buyBacklog, [2]int{price, amount})\\n            }\\n        } else {\\n            for amount > 0 && len(buyBacklog) > 0 && buyBacklog[0][0] >= price {\\n                item := heap.Pop(&buyBacklog).([2]int)\\n                \\n                item[1] -= amount\\n                if item[1] <= 0 {\\n                    amount = -item[1]\\n                    item[1] = 0\\n                } else {\\n                    amount = 0\\n                    heap.Push(&buyBacklog, item)\\n                }\\n                \\n            }\\n            \\n            if amount > 0 {\\n                heap.Push(&sellBacklog, [2]int{price, amount})\\n            }\\n        }\\n    }\\n    \\n    total := 0\\n    for _, x := range buyBacklog{\\n        total += x[1]\\n    }\\n    for _, x := range sellBacklog{\\n        total += x[1]\\n    }\\n    \\n    return total % 1000000007\\n}\\n\\ntype MaxHeap [][2]int\\n\\nfunc (h MaxHeap) Len() int            { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool  { return h[i][0] > h[j][0] }\\nfunc (h MaxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n\\tx := (*h)[len(*h)-1]\\n\\t*h = (*h)[0 : len(*h)-1]\\n\\treturn x\\n}\\n\\ntype MinHeap [][2]int\\n\\nfunc (h MinHeap) Len() int            { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MinHeap) Pop() interface{} {\\n\\tx := (*h)[len(*h)-1]\\n\\t*h = (*h)[0 : len(*h)-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buyBacklog := MaxHeap{}\\n    sellBacklog := MinHeap{}\\n    \\n    for _, order := range orders{\\n        price := order[0]\\n        amount := order[1]\\n        orderType := order[2]\\n        \\n        if orderType == 0 {\\n            for amount > 0 && len(sellBacklog) > 0 && sellBacklog[0][0] <= price {\\n                item := heap.Pop(&sellBacklog).([2]int)\\n                \\n                item[1] -= amount\\n                if item[1] <= 0 {\\n                    amount = -item[1]\\n                    item[1] = 0\\n                } else {\\n                    amount = 0\\n                    heap.Push(&sellBacklog, item)\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                heap.Push(&buyBacklog, [2]int{price, amount})\\n            }\\n        } else {\\n            for amount > 0 && len(buyBacklog) > 0 && buyBacklog[0][0] >= price {\\n                item := heap.Pop(&buyBacklog).([2]int)\\n                \\n                item[1] -= amount\\n                if item[1] <= 0 {\\n                    amount = -item[1]\\n                    item[1] = 0\\n                } else {\\n                    amount = 0\\n                    heap.Push(&buyBacklog, item)\\n                }\\n                \\n            }\\n            \\n            if amount > 0 {\\n                heap.Push(&sellBacklog, [2]int{price, amount})\\n            }\\n        }\\n    }\\n    \\n    total := 0\\n    for _, x := range buyBacklog{\\n        total += x[1]\\n    }\\n    for _, x := range sellBacklog{\\n        total += x[1]\\n    }\\n    \\n    return total % 1000000007\\n}\\n\\ntype MaxHeap [][2]int\\n\\nfunc (h MaxHeap) Len() int            { return len(h) }\\nfunc (h MaxHeap) Less(i, j int) bool  { return h[i][0] > h[j][0] }\\nfunc (h MaxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MaxHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MaxHeap) Pop() interface{} {\\n\\tx := (*h)[len(*h)-1]\\n\\t*h = (*h)[0 : len(*h)-1]\\n\\treturn x\\n}\\n\\ntype MinHeap [][2]int\\n\\nfunc (h MinHeap) Len() int            { return len(h) }\\nfunc (h MinHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h MinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *MinHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *MinHeap) Pop() interface{} {\\n\\tx := (*h)[len(*h)-1]\\n\\t*h = (*h)[0 : len(*h)-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682844,
                "title": "golang-binary-search",
                "content": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buyBacklog := [][2]int{}\\n    sellBacklog := [][2]int{}\\n    total := 0\\n    \\n    for _, order := range orders{\\n        price := order[0]\\n        amount := order[1]\\n        orderType := order[2]\\n        \\n        if orderType == 0 {\\n            for amount > 0 && len(sellBacklog) > 0 && sellBacklog[0][0] <= price {\\n                if amount < sellBacklog[0][1] {\\n                    total -= amount\\n                    sellBacklog[0][1] -= amount\\n                    amount = 0\\n                } else {\\n                    total -= sellBacklog[0][1]\\n                    amount -= sellBacklog[0][1]\\n                    sellBacklog = sellBacklog[1:]\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                total += amount\\n                insertSorted(&buyBacklog, [2]int{price, amount})\\n            }\\n        } else {\\n            for amount > 0 && len(buyBacklog) > 0 && buyBacklog[len(buyBacklog)-1][0] >= price {\\n                if amount < buyBacklog[len(buyBacklog)-1][1] {\\n                    total -= amount\\n                    buyBacklog[len(buyBacklog)-1][1] -= amount\\n                    amount = 0\\n                } else {\\n                    total -= buyBacklog[len(buyBacklog)-1][1]\\n                    amount -= buyBacklog[len(buyBacklog)-1][1]\\n                    buyBacklog = buyBacklog[0:len(buyBacklog)-1]\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                total += amount\\n                insertSorted(&sellBacklog, [2]int{price, amount})\\n            }\\n        }\\n    }\\n    \\n    return total % 1000000007\\n}\\n\\nfunc binarySearch(A [][2]int, K int) int {\\n\\tleft := 0\\n\\tright := len(A) - 1\\n\\n\\tfor left <= right {\\n\\t\\tmid := left + (right-left) / 2\\n\\n\\t\\tif K == A[mid][0] {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\n\\t\\tif K < A[mid][0] {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc insertSorted(A *[][2]int, x [2]int) {\\n\\ti := binarySearch(*A, x[0])\\n\\n    if i < len(*A) && (*A)[i][0] == x[0] {\\n\\t\\t(*A)[i][1] += x[1]\\n\\t} else {\\n\\t\\tleft := (*A)[0:i]\\n\\t\\tright := (*A)[i:]\\n\\t\\t(*A) = append(left, append([][2]int{x}, right...)...)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search Tree"
                ],
                "code": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buyBacklog := [][2]int{}\\n    sellBacklog := [][2]int{}\\n    total := 0\\n    \\n    for _, order := range orders{\\n        price := order[0]\\n        amount := order[1]\\n        orderType := order[2]\\n        \\n        if orderType == 0 {\\n            for amount > 0 && len(sellBacklog) > 0 && sellBacklog[0][0] <= price {\\n                if amount < sellBacklog[0][1] {\\n                    total -= amount\\n                    sellBacklog[0][1] -= amount\\n                    amount = 0\\n                } else {\\n                    total -= sellBacklog[0][1]\\n                    amount -= sellBacklog[0][1]\\n                    sellBacklog = sellBacklog[1:]\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                total += amount\\n                insertSorted(&buyBacklog, [2]int{price, amount})\\n            }\\n        } else {\\n            for amount > 0 && len(buyBacklog) > 0 && buyBacklog[len(buyBacklog)-1][0] >= price {\\n                if amount < buyBacklog[len(buyBacklog)-1][1] {\\n                    total -= amount\\n                    buyBacklog[len(buyBacklog)-1][1] -= amount\\n                    amount = 0\\n                } else {\\n                    total -= buyBacklog[len(buyBacklog)-1][1]\\n                    amount -= buyBacklog[len(buyBacklog)-1][1]\\n                    buyBacklog = buyBacklog[0:len(buyBacklog)-1]\\n                }\\n            }\\n            \\n            if amount > 0 {\\n                total += amount\\n                insertSorted(&sellBacklog, [2]int{price, amount})\\n            }\\n        }\\n    }\\n    \\n    return total % 1000000007\\n}\\n\\nfunc binarySearch(A [][2]int, K int) int {\\n\\tleft := 0\\n\\tright := len(A) - 1\\n\\n\\tfor left <= right {\\n\\t\\tmid := left + (right-left) / 2\\n\\n\\t\\tif K == A[mid][0] {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\n\\t\\tif K < A[mid][0] {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn left\\n}\\n\\nfunc insertSorted(A *[][2]int, x [2]int) {\\n\\ti := binarySearch(*A, x[0])\\n\\n    if i < len(*A) && (*A)[i][0] == x[0] {\\n\\t\\t(*A)[i][1] += x[1]\\n\\t} else {\\n\\t\\tleft := (*A)[0:i]\\n\\t\\tright := (*A)[i:]\\n\\t\\t(*A) = append(left, append([][2]int{x}, right...)...)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512359,
                "title": "c-priority-queue",
                "content": "```\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n = orders.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> sell;\\n        priority_queue<pi> buy;\\n        for(int i=0; i<n; i++){\\n            ll price1 = orders[i][0];\\n            ll amnt1 = orders[i][1];\\n            ll type = orders[i][2];\\n            if(type == 0){\\n                while(!sell.empty() && sell.top().first <= price1 && amnt1){\\n                    auto [price2, amnt2] = sell.top();\\n                    sell.pop();\\n                    ll a1 = amnt1, a2 = amnt2;\\n\\t\\t\\t\\t\\t// reduce the amnt1 max possible, but can\\'t go below zero\\n                    amnt1 = max<ll>(0, amnt1 - a2);\\n\\t\\t\\t\\t\\t// reduce the amnt2 to 0 if possible\\n                    amnt2 = max<ll>(0, amnt2 - a1);\\n                    if(amnt2 > 0) sell.push({price2, amnt2});\\n                }\\n\\t\\t\\t\\t// if orders left, push them to buy bbacklog\\n                if(amnt1 > 0) buy.push({price1, amnt1});\\n            }\\n            else{\\n                while(!buy.empty() && buy.top().first >= price1 && amnt1){\\n                    auto [price2, amnt2] = buy.top();\\n                    buy.pop();\\n                    ll a1 = amnt1, a2 = amnt2;\\n\\t\\t\\t\\t\\t// same for type 1 case\\n                    amnt1 = max<ll>(0, amnt1 - a2);\\n                    amnt2 = max<ll>(0, amnt2 - a1);\\n                    if(amnt2 > 0) buy.push({price2, amnt2});\\n                }\\n\\t\\t\\t\\t// if orders left, push them to sell backlog\\n                if(amnt1 > 0) sell.push({price1, amnt1});\\n            }\\n        }\\n        ll backlog = 0;\\n        while(!sell.empty()){\\n            backlog += sell.top().second;\\n            backlog %= M;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            backlog += buy.top().second;\\n            backlog %= M;\\n            buy.pop();\\n        }\\n        return backlog;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef long long ll;\\ntypedef pair<ll, ll> pi;\\nclass Solution {\\npublic:\\n    ll M = 1e9+7;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int n = orders.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> sell;\\n        priority_queue<pi> buy;\\n        for(int i=0; i<n; i++){\\n            ll price1 = orders[i][0];\\n            ll amnt1 = orders[i][1];\\n            ll type = orders[i][2];\\n            if(type == 0){\\n                while(!sell.empty() && sell.top().first <= price1 && amnt1){\\n                    auto [price2, amnt2] = sell.top();\\n                    sell.pop();\\n                    ll a1 = amnt1, a2 = amnt2;\\n\\t\\t\\t\\t\\t// reduce the amnt1 max possible, but can\\'t go below zero\\n                    amnt1 = max<ll>(0, amnt1 - a2);\\n\\t\\t\\t\\t\\t// reduce the amnt2 to 0 if possible\\n                    amnt2 = max<ll>(0, amnt2 - a1);\\n                    if(amnt2 > 0) sell.push({price2, amnt2});\\n                }\\n\\t\\t\\t\\t// if orders left, push them to buy bbacklog\\n                if(amnt1 > 0) buy.push({price1, amnt1});\\n            }\\n            else{\\n                while(!buy.empty() && buy.top().first >= price1 && amnt1){\\n                    auto [price2, amnt2] = buy.top();\\n                    buy.pop();\\n                    ll a1 = amnt1, a2 = amnt2;\\n\\t\\t\\t\\t\\t// same for type 1 case\\n                    amnt1 = max<ll>(0, amnt1 - a2);\\n                    amnt2 = max<ll>(0, amnt2 - a1);\\n                    if(amnt2 > 0) buy.push({price2, amnt2});\\n                }\\n\\t\\t\\t\\t// if orders left, push them to sell backlog\\n                if(amnt1 > 0) sell.push({price1, amnt1});\\n            }\\n        }\\n        ll backlog = 0;\\n        while(!sell.empty()){\\n            backlog += sell.top().second;\\n            backlog %= M;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            backlog += buy.top().second;\\n            backlog %= M;\\n            buy.pop();\\n        }\\n        return backlog;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484932,
                "title": "python3-clean-2-heaps-solution",
                "content": "Idea:\\n- two heaps: `max heap` for buy orders and `min heap` for sell orders\\n- iterate through each order\\n\\t- sell order: look at the top of buy order heap. \\n\\t\\t- Pop if necessary\\n\\t\\t- leftover: add to sell heap\\n\\t- buy order: look at the top of sell order heap.\\n\\t\\t- Pop if necessary\\n\\t\\t- leftover: add to buy heap\\n\\nTime: `O(n log n)` for heap operations within the for loop\\nSpace: `O(n)` for storing all orders in the heaps\\n\\n```\\nMODULE = 10 ** 9 + 7\\n        BUY, SELL = 0, 1\\n        \\n        # buy heap = maxHeap, sell heap = minHeap\\n        buyHeap, sellHeap = [], []\\n        \\n        for price, amount, orderType in orders:\\n            if orderType == BUY:\\n                while amount and sellHeap and sellHeap[0][0] <= price:\\n                    sellPrice, sellAmount = sellHeap[0]\\n                    \\n                    if sellAmount > amount:\\n                        sellHeap[0] = (sellPrice, sellAmount - amount)\\n                        amount = 0\\n                    else:\\n                        heapq.heappop(sellHeap)\\n                        amount -= sellAmount\\n                    \\n                if amount:\\n                    heapq.heappush(buyHeap, (-price, amount))\\n                    \\n            elif orderType == SELL:\\n                while amount and buyHeap and -buyHeap[0][0] >= price:\\n                    buyPrice, buyAmount = buyHeap[0]\\n                    \\n                    if buyAmount > amount:\\n                        buyHeap[0] = (buyPrice, buyAmount - amount)\\n                        amount = 0\\n                    else:\\n                        heapq.heappop(buyHeap)\\n                        amount -= buyAmount\\n                if amount:\\n                    heapq.heappush(sellHeap, (price, amount))\\n\\n        return (functools.reduce(lambda accum, curr: accum + curr[1], buyHeap + sellHeap, 0)) % MODULE\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Idea:\\n- two heaps: `max heap` for buy orders and `min heap` for sell orders\\n- iterate through each order\\n\\t- sell order: look at the top of buy order heap. \\n\\t\\t- Pop if necessary\\n\\t\\t- leftover: add to sell heap\\n\\t- buy order: look at the top of sell order heap.\\n\\t\\t- Pop if necessary\\n\\t\\t- leftover: add to buy heap\\n\\nTime: `O(n log n)` for heap operations within the for loop\\nSpace: `O(n)` for storing all orders in the heaps\\n\\n```\\nMODULE = 10 ** 9 + 7\\n        BUY, SELL = 0, 1\\n        \\n        # buy heap = maxHeap, sell heap = minHeap\\n        buyHeap, sellHeap = [], []\\n        \\n        for price, amount, orderType in orders:\\n            if orderType == BUY:\\n                while amount and sellHeap and sellHeap[0][0] <= price:\\n                    sellPrice, sellAmount = sellHeap[0]\\n                    \\n                    if sellAmount > amount:\\n                        sellHeap[0] = (sellPrice, sellAmount - amount)\\n                        amount = 0\\n                    else:\\n                        heapq.heappop(sellHeap)\\n                        amount -= sellAmount\\n                    \\n                if amount:\\n                    heapq.heappush(buyHeap, (-price, amount))\\n                    \\n            elif orderType == SELL:\\n                while amount and buyHeap and -buyHeap[0][0] >= price:\\n                    buyPrice, buyAmount = buyHeap[0]\\n                    \\n                    if buyAmount > amount:\\n                        buyHeap[0] = (buyPrice, buyAmount - amount)\\n                        amount = 0\\n                    else:\\n                        heapq.heappop(buyHeap)\\n                        amount -= buyAmount\\n                if amount:\\n                    heapq.heappush(sellHeap, (price, amount))\\n\\n        return (functools.reduce(lambda accum, curr: accum + curr[1], buyHeap + sellHeap, 0)) % MODULE\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2472773,
                "title": "python-2-heaps-faster-than-99",
                "content": "```\\n#baraa\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_heap = []\\n        sell_heap = []\\n        mod = 10 ** 9 + 7\\n        for price, amount, type in orders:\\n            if type == 0:\\n                while amount > 0 and sell_heap and sell_heap[0][0] <= price:\\n                    if amount >= sell_heap[0][1]:\\n                        amount -= sell_heap[0][1]\\n                        heapq.heappop(sell_heap)\\n                    else:\\n                        sell_heap[0] = [sell_heap[0][0], sell_heap[0][1] - amount]\\n                        amount = 0\\n                if amount:\\n                    heapq.heappush(buy_heap, [-price, amount])\\n            else:\\n                while amount > 0 and buy_heap and -1 * buy_heap[0][0] >= price:\\n                    if amount >= buy_heap[0][1]:\\n                        amount -= buy_heap[0][1]\\n                        heapq.heappop(buy_heap)\\n                    else:\\n                        buy_heap[0] = [buy_heap[0][0], buy_heap[0][1] - amount]\\n                        amount = 0   \\n                if amount:\\n                    heapq.heappush(sell_heap, [price, amount])\\n                \\n                    \\n        s = 0\\n        for _, i in buy_heap:\\n            s += i\\n            s %= mod\\n        for _, i in sell_heap:\\n            s += i\\n            s %= mod\\n        return s % mod",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#baraa\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_heap = []\\n        sell_heap = []\\n        mod = 10 ** 9 + 7\\n        for price, amount, type in orders:\\n            if type == 0:\\n                while amount > 0 and sell_heap and sell_heap[0][0] <= price:\\n                    if amount >= sell_heap[0][1]:\\n                        amount -= sell_heap[0][1]\\n                        heapq.heappop(sell_heap)\\n                    else:\\n                        sell_heap[0] = [sell_heap[0][0], sell_heap[0][1] - amount]\\n                        amount = 0\\n                if amount:\\n                    heapq.heappush(buy_heap, [-price, amount])\\n            else:\\n                while amount > 0 and buy_heap and -1 * buy_heap[0][0] >= price:\\n                    if amount >= buy_heap[0][1]:\\n                        amount -= buy_heap[0][1]\\n                        heapq.heappop(buy_heap)\\n                    else:\\n                        buy_heap[0] = [buy_heap[0][0], buy_heap[0][1] - amount]\\n                        amount = 0   \\n                if amount:\\n                    heapq.heappush(sell_heap, [price, amount])\\n                \\n                    \\n        s = 0\\n        for _, i in buy_heap:\\n            s += i\\n            s %= mod\\n        for _, i in sell_heap:\\n            s += i\\n            s %= mod\\n        return s % mod",
                "codeTag": "Java"
            },
            {
                "id": 2465430,
                "title": "easy-cpp",
                "content": "class Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& v) {\\n        priority_queue<pair<int,int>>p;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i][2]==0)\\n            {\\n              p.push({v[i][0],v[i][1]});\\n            }\\n            else\\n            {\\n                q.push({v[i][0],v[i][1]});\\n            }\\n            while(!q.empty()&&!p.empty())\\n        {\\n            \\n                   pair<int,int>w=q.top();\\n                   pair<int,int>ww=p.top();\\n                    if(w.first<=ww.first)\\n                    {\\n                        if(w.second>ww.second)\\n                        {\\n                            q.pop();\\n                            p.pop();\\n                            q.push({w.first,w.second-ww.second});\\n                        }\\n                        else\\n                        {\\n                            q.pop();\\n                            p.pop();\\n                            if(w.second<ww.second)\\n                            {\\n                                p.push({ww.first,ww.second-w.second});\\n                            }\\n                        }\\n                    }\\n                    else\\n                    {\\n                         break;\\n                    }\\n                \\n            \\n        }\\n        }\\n       \\n     \\n        long long  int ans=0;\\n        while(!q.empty())\\n        {\\n             pair<int,int>w=q.top();\\n            q.pop();\\n           \\n            ans+=(w.second);\\n        }\\n         while(!p.empty())\\n        {\\n             pair<int,int>w=p.top();\\n            p.pop();\\n          \\n            ans+=(w.second);\\n        }\\n        ans=ans%(1000000007);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& v) {\\n        priority_queue<pair<int,int>>p;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i][2]==0)\\n            {\\n              p.push({v[i][0],v[i][1]}",
                "codeTag": "Java"
            },
            {
                "id": 2216293,
                "title": "double-priority-queue",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy,sell=[],[]\\n        n=len(orders)\\n        for price,amount,type in orders:\\n            if type==0:\\n                if sell and price>=sell[0][0]:\\n                    if amount==sell[0][1]:\\n                        heapq.heappop(sell)\\n                    elif sell[0][1]>amount:\\n                        sell[0][1]=sell[0][1]-amount\\n                    else:\\n                        amount-=sell[0][1]\\n                        heapq.heappop(sell)\\n                        while sell and price>=sell[0][0] and amount-sell[0][1]>=0:\\n                            amount-=sell[0][1]\\n                            heapq.heappop(sell)\\n                        if sell and price>=sell[0][0] and amount>0 and amount-sell[0][1]<0:\\n                            sell[0][1]-=amount\\n                        elif sell and price<sell[0][0] and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                        elif not sell and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                else:\\n                    heapq.heappush(buy,[-price,amount])\\n            else:\\n                if buy and price<=(-buy[0][0]):\\n                    if amount==buy[0][1]:\\n                        heapq.heappop(buy)\\n                    elif buy[0][1]>amount:\\n                        buy[0][1]=buy[0][1]-amount\\n                    else:\\n                        amount-=buy[0][1]\\n                        heapq.heappop(buy)\\n                        while buy and price<=(-buy[0][0]) and amount-buy[0][1]>=0:\\n                            amount-=buy[0][1]\\n                            heapq.heappop(buy)\\n                        if buy and price<=(-buy[0][0]) and amount>0 and amount-buy[0][1]<0:\\n                            buy[0][1]-=amount\\n                        elif buy and price>(-buy[0][0]) and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                        elif not buy and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                else:\\n                    heapq.heappush(sell,[price,amount])\\n        ans=0\\n        for _,amt in buy:\\n            ans+=amt\\n        for _,amt in sell:\\n            ans+=amt\\n        return ans%(10**9+7)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy,sell=[],[]\\n        n=len(orders)\\n        for price,amount,type in orders:\\n            if type==0:\\n                if sell and price>=sell[0][0]:\\n                    if amount==sell[0][1]:\\n                        heapq.heappop(sell)\\n                    elif sell[0][1]>amount:\\n                        sell[0][1]=sell[0][1]-amount\\n                    else:\\n                        amount-=sell[0][1]\\n                        heapq.heappop(sell)\\n                        while sell and price>=sell[0][0] and amount-sell[0][1]>=0:\\n                            amount-=sell[0][1]\\n                            heapq.heappop(sell)\\n                        if sell and price>=sell[0][0] and amount>0 and amount-sell[0][1]<0:\\n                            sell[0][1]-=amount\\n                        elif sell and price<sell[0][0] and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                        elif not sell and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                else:\\n                    heapq.heappush(buy,[-price,amount])\\n            else:\\n                if buy and price<=(-buy[0][0]):\\n                    if amount==buy[0][1]:\\n                        heapq.heappop(buy)\\n                    elif buy[0][1]>amount:\\n                        buy[0][1]=buy[0][1]-amount\\n                    else:\\n                        amount-=buy[0][1]\\n                        heapq.heappop(buy)\\n                        while buy and price<=(-buy[0][0]) and amount-buy[0][1]>=0:\\n                            amount-=buy[0][1]\\n                            heapq.heappop(buy)\\n                        if buy and price<=(-buy[0][0]) and amount>0 and amount-buy[0][1]<0:\\n                            buy[0][1]-=amount\\n                        elif buy and price>(-buy[0][0]) and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                        elif not buy and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                else:\\n                    heapq.heappush(sell,[price,amount])\\n        ans=0\\n        for _,amt in buy:\\n            ans+=amt\\n        for _,amt in sell:\\n            ans+=amt\\n        return ans%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152711,
                "title": "simple-python-solution-using-heaps-faster-than-91",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        \\n        for price, amount, order_type in orders:\\n            # print(buy, sell)\\n            if order_type == 0:\\n                while sell:\\n                    sell_price, sell_amount = sell[0][0], sell[0][1]\\n                    \\n                    if sell_price > price:\\n                        break\\n                    \\n                    heapq.heappop(sell)\\n                    amount -= sell_amount\\n                    if amount == 0:\\n                        break\\n                    if amount < 0:\\n                        heapq.heappush(sell, (sell_price, -amount))\\n                        break\\n                \\n                if amount > 0:\\n                    heapq.heappush(buy, (-price, amount))\\n            else:\\n                while buy:\\n                    buy_price, buy_amount = -buy[0][0], buy[0][1]\\n                    if buy_price < price:\\n                        break\\n                    \\n                    heapq.heappop(buy)\\n                    amount -= buy_amount\\n                    if amount == 0:\\n                        break\\n                    if amount < 0:\\n                        heapq.heappush(buy, (-buy_price, -amount))\\n                        break\\n                \\n                if amount > 0:\\n                    heapq.heappush(sell, (price, amount))\\n        \\n        # print(buy, sell)\\n        result = 0\\n        while buy:\\n            result = (result + heapq.heappop(buy)[1]) % (10**9+7)\\n        \\n        while sell:\\n            result = (result + heapq.heappop(sell)[1]) % (10**9+7)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy, sell = [], []\\n        \\n        for price, amount, order_type in orders:\\n            # print(buy, sell)\\n            if order_type == 0:\\n                while sell:\\n                    sell_price, sell_amount = sell[0][0], sell[0][1]\\n                    \\n                    if sell_price > price:\\n                        break\\n                    \\n                    heapq.heappop(sell)\\n                    amount -= sell_amount\\n                    if amount == 0:\\n                        break\\n                    if amount < 0:\\n                        heapq.heappush(sell, (sell_price, -amount))\\n                        break\\n                \\n                if amount > 0:\\n                    heapq.heappush(buy, (-price, amount))\\n            else:\\n                while buy:\\n                    buy_price, buy_amount = -buy[0][0], buy[0][1]\\n                    if buy_price < price:\\n                        break\\n                    \\n                    heapq.heappop(buy)\\n                    amount -= buy_amount\\n                    if amount == 0:\\n                        break\\n                    if amount < 0:\\n                        heapq.heappush(buy, (-buy_price, -amount))\\n                        break\\n                \\n                if amount > 0:\\n                    heapq.heappush(sell, (price, amount))\\n        \\n        # print(buy, sell)\\n        result = 0\\n        while buy:\\n            result = (result + heapq.heappop(buy)[1]) % (10**9+7)\\n        \\n        while sell:\\n            result = (result + heapq.heappop(sell)[1]) % (10**9+7)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022840,
                "title": "clear-but-lengthy-with-2-priority-queues",
                "content": "This code is lengthy, still trying to find a more elegant way to put 2 priority queues under the same data structure, array or vector, maybe,\\nso that the code can be reduced by half.\\nNevertheless, the logic is crystal clear.\\n\\n```cpp\\nint m = 1e9 + 7;\\n// {price, amount}\\npriority_queue<pair<int, int>> buylog;\\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> selllog;\\n\\nfor (auto &o : orders)\\n{\\n\\t// buy\\n\\tif (o[2] == 0)\\n\\t{\\n\\t\\t// if the smallest price in sell log is smaller or equal to the current buy price\\n\\t\\twhile (selllog.size() && selllog.top().first <= o[0] && o[1])\\n\\t\\t{\\n\\t\\t\\t// if the amount of the smalllest sell log is larger than the amount of the current buy order\\n\\t\\t\\tif (selllog.top().second > o[1])\\n\\t\\t\\t{\\n\\t\\t\\t\\t// remove enough amount and update the sell log\\n\\t\\t\\t\\tauto t = selllog.top();\\n\\t\\t\\t\\tselllog.pop();\\n\\t\\t\\t\\tselllog.push({t.first, t.second - o[1]});\\n\\t\\t\\t\\to[1] = 0;\\n\\t\\t\\t}\\n\\t\\t\\t// if the amount of the smalllest sell log is not enough for the current buy order\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// remove enough amount of buy order and then remove the smallest price sell order, because its amount has become 0.\\n\\t\\t\\t\\to[1] -= selllog.top().second;\\n\\t\\t\\t\\tselllog.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if there are any buy order left, put them into buy log\\n\\t\\tif (o[1])\\n\\t\\t\\tbuylog.push({o[0], o[1]});\\n\\t}\\n\\t// sell, vice versa\\n\\telse\\n\\t{\\n\\t\\twhile (buylog.size() && buylog.top().first >= o[0] && o[1])\\n\\t\\t{\\n\\t\\t\\tif (buylog.top().second > o[1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto t = buylog.top();\\n\\t\\t\\t\\tbuylog.pop();\\n\\t\\t\\t\\tbuylog.push({t.first, t.second - o[1]});\\n\\t\\t\\t\\to[1] = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\to[1] -= buylog.top().second;\\n\\t\\t\\t\\tbuylog.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (o[1])\\n\\t\\t\\tselllog.push({o[0], o[1]});\\n\\t}\\n}\\n\\n// collect the suspending amounts\\nlong long ret = 0;\\n\\nwhile (selllog.size())\\n{\\n\\tret += selllog.top().second;\\n\\tret %= m;\\n\\tselllog.pop();\\n}\\n\\nwhile (buylog.size())\\n{\\n\\tret += buylog.top().second;\\n\\tret %= m;\\n\\tbuylog.pop();\\n}\\n\\nreturn ret;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Simulation"
                ],
                "code": "```cpp\\nint m = 1e9 + 7;\\n// {price, amount}\\npriority_queue<pair<int, int>> buylog;\\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> selllog;\\n\\nfor (auto &o : orders)\\n{\\n\\t// buy\\n\\tif (o[2] == 0)\\n\\t{\\n\\t\\t// if the smallest price in sell log is smaller or equal to the current buy price\\n\\t\\twhile (selllog.size() && selllog.top().first <= o[0] && o[1])\\n\\t\\t{\\n\\t\\t\\t// if the amount of the smalllest sell log is larger than the amount of the current buy order\\n\\t\\t\\tif (selllog.top().second > o[1])\\n\\t\\t\\t{\\n\\t\\t\\t\\t// remove enough amount and update the sell log\\n\\t\\t\\t\\tauto t = selllog.top();\\n\\t\\t\\t\\tselllog.pop();\\n\\t\\t\\t\\tselllog.push({t.first, t.second - o[1]});\\n\\t\\t\\t\\to[1] = 0;\\n\\t\\t\\t}\\n\\t\\t\\t// if the amount of the smalllest sell log is not enough for the current buy order\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\t// remove enough amount of buy order and then remove the smallest price sell order, because its amount has become 0.\\n\\t\\t\\t\\to[1] -= selllog.top().second;\\n\\t\\t\\t\\tselllog.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// if there are any buy order left, put them into buy log\\n\\t\\tif (o[1])\\n\\t\\t\\tbuylog.push({o[0], o[1]});\\n\\t}\\n\\t// sell, vice versa\\n\\telse\\n\\t{\\n\\t\\twhile (buylog.size() && buylog.top().first >= o[0] && o[1])\\n\\t\\t{\\n\\t\\t\\tif (buylog.top().second > o[1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto t = buylog.top();\\n\\t\\t\\t\\tbuylog.pop();\\n\\t\\t\\t\\tbuylog.push({t.first, t.second - o[1]});\\n\\t\\t\\t\\to[1] = 0;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\to[1] -= buylog.top().second;\\n\\t\\t\\t\\tbuylog.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (o[1])\\n\\t\\t\\tselllog.push({o[0], o[1]});\\n\\t}\\n}\\n\\n// collect the suspending amounts\\nlong long ret = 0;\\n\\nwhile (selllog.size())\\n{\\n\\tret += selllog.top().second;\\n\\tret %= m;\\n\\tselllog.pop();\\n}\\n\\nwhile (buylog.size())\\n{\\n\\tret += buylog.top().second;\\n\\tret %= m;\\n\\tbuylog.pop();\\n}\\n\\nreturn ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918569,
                "title": "c-map-the-waters-some-more",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<int, int> buy;\\n        map<int, int> sell;\\n        long long res = 0;\\n        for (auto& o : orders) {\\n            if (o[2] == 0) { // buy order\\n                auto iter = sell.begin();\\n                while (iter != sell.end() && o[1] > 0 && iter->first <= o[0]) {\\n                    int avail = min(iter->second, o[1]);\\n                    o[1] -= avail;\\n                    iter->second -= avail;\\n                    res -= avail;\\n                    if (iter->second == 0) {\\n                        int price = iter->first;\\n                        iter = next(iter);\\n                        sell.erase(price);\\n                    } else {\\n                        iter++;\\n                    }\\n                }\\n                if (o[1]) {\\n                    buy[o[0]] += o[1];\\n                    res += o[1];\\n                }\\n            } else { // sell order\\n                auto iter = buy.rbegin();\\n                while (iter != buy.rend() && o[1] > 0 && iter->first >= o[0]) {\\n                    int avail = min(iter->second, o[1]);\\n                    iter->second -= avail;\\n                    o[1] -= avail;\\n                    res -= avail;\\n                    if (iter->second == 0) {\\n                        int price = iter->first;\\n                        iter = next(iter);\\n                        buy.erase(price);\\n                    } else {\\n                        iter++;\\n                    }\\n                }\\n                if (o[1]) {\\n                    sell[o[0]] += o[1];\\n                    res += o[1];\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<int, int> buy;\\n        map<int, int> sell;\\n        long long res = 0;\\n        for (auto& o : orders) {\\n            if (o[2] == 0) { // buy order\\n                auto iter = sell.begin();\\n                while (iter != sell.end() && o[1] > 0 && iter->first <= o[0]) {\\n                    int avail = min(iter->second, o[1]);\\n                    o[1] -= avail;\\n                    iter->second -= avail;\\n                    res -= avail;\\n                    if (iter->second == 0) {\\n                        int price = iter->first;\\n                        iter = next(iter);\\n                        sell.erase(price);\\n                    } else {\\n                        iter++;\\n                    }\\n                }\\n                if (o[1]) {\\n                    buy[o[0]] += o[1];\\n                    res += o[1];\\n                }\\n            } else { // sell order\\n                auto iter = buy.rbegin();\\n                while (iter != buy.rend() && o[1] > 0 && iter->first >= o[0]) {\\n                    int avail = min(iter->second, o[1]);\\n                    iter->second -= avail;\\n                    o[1] -= avail;\\n                    res -= avail;\\n                    if (iter->second == 0) {\\n                        int price = iter->first;\\n                        iter = next(iter);\\n                        buy.erase(price);\\n                    } else {\\n                        iter++;\\n                    }\\n                }\\n                if (o[1]) {\\n                    sell[o[0]] += o[1];\\n                    res += o[1];\\n                }\\n            }\\n        }\\n        return res % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918071,
                "title": "java-priorityqueue",
                "content": "```\\nclass Solution {\\n    \\n\\n    \\n    static final int SELL = 1;\\n    static final int BUY = 0;\\n    \\n    static int mod = 1_000_000_007;\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sells = new PriorityQueue<>();\\n        PriorityQueue<Order> buys = new PriorityQueue<>(20, Collections.reverseOrder());\\n        \\n        for (int[] order: orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            \\n            Order o = new Order(price, amount, orderType);\\n            if (orderType==SELL) {\\n                Order topBuy = buys.peek();\\n                while (topBuy!=null && topBuy.price >=o.price && o.amount > 0) {\\n                        int buysRem = Math.max(0, topBuy.amount - o.amount);\\n                        int oRem = Math.max(0, o.amount - topBuy.amount);\\n\\n                        topBuy.amount = buysRem;\\n                        if (buysRem==0) {\\n                            buys.poll();\\n                        }\\n                        o.amount = oRem;\\n                        \\n                    topBuy = buys.peek();\\n                }\\n                if (o.amount > 0) {\\n                    sells.add(o);\\n                }\\n            } else {// BUY ORDER\\n                Order topSell = sells.peek();\\n                while (topSell!=null && topSell.price <=o.price && o.amount > 0) {\\n                        int sellsRem = Math.max(0, topSell.amount - o.amount);\\n                        int oRem = Math.max(0, o.amount - topSell.amount);\\n\\n                        topSell.amount = sellsRem;\\n                        if (sellsRem==0) {\\n                            sells.poll();\\n                        }\\n                        o.amount = oRem;\\n                        \\n                    topSell = sells.peek();\\n                }\\n                if (o.amount > 0) {\\n                    buys.add(o);\\n                }\\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        while (!sells.isEmpty()) {\\n            Order sell = sells.poll();\\n            total = (total + sell.amount) % mod;\\n        }\\n        while (!buys.isEmpty()) {\\n            Order buy = buys.poll();\\n            total = (total + buy.amount) % mod;\\n        }\\n        return total;\\n    }\\n    \\n    \\n    \\n    class Order implements Comparable<Order> {\\n        int price;\\n        int amount;\\n        int orderType;\\n        \\n        public Order(int price, int amount, int orderType) {\\n            this.price = price;\\n            this.amount = amount;\\n            this.orderType = orderType;\\n        }\\n        \\n        public int compareTo(Order o) {\\n            return this.price - o.price;\\n        }\\n        \\n        public String toString() {\\n            return \"price: \" + this.price + \", amount: \" + amount + \", type \" + orderType;\\n        }\\n        \\n\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\n    \\n    static final int SELL = 1;\\n    static final int BUY = 0;\\n    \\n    static int mod = 1_000_000_007;\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sells = new PriorityQueue<>();\\n        PriorityQueue<Order> buys = new PriorityQueue<>(20, Collections.reverseOrder());\\n        \\n        for (int[] order: orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            \\n            Order o = new Order(price, amount, orderType);\\n            if (orderType==SELL) {\\n                Order topBuy = buys.peek();\\n                while (topBuy!=null && topBuy.price >=o.price && o.amount > 0) {\\n                        int buysRem = Math.max(0, topBuy.amount - o.amount);\\n                        int oRem = Math.max(0, o.amount - topBuy.amount);\\n\\n                        topBuy.amount = buysRem;\\n                        if (buysRem==0) {\\n                            buys.poll();\\n                        }\\n                        o.amount = oRem;\\n                        \\n                    topBuy = buys.peek();\\n                }\\n                if (o.amount > 0) {\\n                    sells.add(o);\\n                }\\n            } else {// BUY ORDER\\n                Order topSell = sells.peek();\\n                while (topSell!=null && topSell.price <=o.price && o.amount > 0) {\\n                        int sellsRem = Math.max(0, topSell.amount - o.amount);\\n                        int oRem = Math.max(0, o.amount - topSell.amount);\\n\\n                        topSell.amount = sellsRem;\\n                        if (sellsRem==0) {\\n                            sells.poll();\\n                        }\\n                        o.amount = oRem;\\n                        \\n                    topSell = sells.peek();\\n                }\\n                if (o.amount > 0) {\\n                    buys.add(o);\\n                }\\n            }\\n        }\\n        \\n        int total = 0;\\n        \\n        while (!sells.isEmpty()) {\\n            Order sell = sells.poll();\\n            total = (total + sell.amount) % mod;\\n        }\\n        while (!buys.isEmpty()) {\\n            Order buy = buys.poll();\\n            total = (total + buy.amount) % mod;\\n        }\\n        return total;\\n    }\\n    \\n    \\n    \\n    class Order implements Comparable<Order> {\\n        int price;\\n        int amount;\\n        int orderType;\\n        \\n        public Order(int price, int amount, int orderType) {\\n            this.price = price;\\n            this.amount = amount;\\n            this.orderType = orderType;\\n        }\\n        \\n        public int compareTo(Order o) {\\n            return this.price - o.price;\\n        }\\n        \\n        public String toString() {\\n            return \"price: \" + this.price + \", amount: \" + amount + \", type \" + orderType;\\n        }\\n        \\n\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914483,
                "title": "c-using-heaps",
                "content": "Naming convention almost explains algo so not writing anything.\\n```\\nclass Solution {\\npublic:\\n    struct mincost {\\n        bool operator()(const pair<int,int> &a, const pair<int,int> &b) {\\n            return a.first > b.first;\\n        }\\n    };\\n    struct maxcost {\\n        bool operator()(const pair<int,int> &a, const pair<int,int> &b) {\\n            return a.first < b.first;\\n        }\\n    };\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, mincost> min_heap_sell_order;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, maxcost> max_heap_buy_order;\\n        \\n        int backlog_orders = 0;\\n        const int mod = 1000000007;\\n        for (auto order : orders) {\\n            if (order[2] == 0) {\\n                max_heap_buy_order.push(make_pair(order[0], order[1]));\\n            } else {\\n                min_heap_sell_order.push(make_pair(order[0], order[1]));\\n            }\\n            \\n            while ((!min_heap_sell_order.empty() && !max_heap_buy_order.empty()) && (max_heap_buy_order.top().first >= min_heap_sell_order.top().first)) {\\n                auto buy_order = max_heap_buy_order.top();\\n                auto sell_order = min_heap_sell_order.top();\\n                max_heap_buy_order.pop();\\n                min_heap_sell_order.pop();\\n                // if we can match all match\\n                if (buy_order.second > sell_order.second) {\\n                    buy_order.second -= sell_order.second;\\n                    max_heap_buy_order.push(buy_order);\\n                } else if (buy_order.second < sell_order.second) {\\n                    sell_order.second -= buy_order.second;\\n                    min_heap_sell_order.push(sell_order);\\n                }\\n            }\\n        }\\n        \\n        while (!min_heap_sell_order.empty()) {\\n            backlog_orders = (backlog_orders + min_heap_sell_order.top().second)%mod;\\n            min_heap_sell_order.pop();\\n        }\\n        \\n        while (!max_heap_buy_order.empty()) {\\n            backlog_orders = (backlog_orders + max_heap_buy_order.top().second)%mod;\\n            max_heap_buy_order.pop();\\n        }\\n        return backlog_orders;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct mincost {\\n        bool operator()(const pair<int,int> &a, const pair<int,int> &b) {\\n            return a.first > b.first;\\n        }\\n    };\\n    struct maxcost {\\n        bool operator()(const pair<int,int> &a, const pair<int,int> &b) {\\n            return a.first < b.first;\\n        }\\n    };\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, mincost> min_heap_sell_order;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, maxcost> max_heap_buy_order;\\n        \\n        int backlog_orders = 0;\\n        const int mod = 1000000007;\\n        for (auto order : orders) {\\n            if (order[2] == 0) {\\n                max_heap_buy_order.push(make_pair(order[0], order[1]));\\n            } else {\\n                min_heap_sell_order.push(make_pair(order[0], order[1]));\\n            }\\n            \\n            while ((!min_heap_sell_order.empty() && !max_heap_buy_order.empty()) && (max_heap_buy_order.top().first >= min_heap_sell_order.top().first)) {\\n                auto buy_order = max_heap_buy_order.top();\\n                auto sell_order = min_heap_sell_order.top();\\n                max_heap_buy_order.pop();\\n                min_heap_sell_order.pop();\\n                // if we can match all match\\n                if (buy_order.second > sell_order.second) {\\n                    buy_order.second -= sell_order.second;\\n                    max_heap_buy_order.push(buy_order);\\n                } else if (buy_order.second < sell_order.second) {\\n                    sell_order.second -= buy_order.second;\\n                    min_heap_sell_order.push(sell_order);\\n                }\\n            }\\n        }\\n        \\n        while (!min_heap_sell_order.empty()) {\\n            backlog_orders = (backlog_orders + min_heap_sell_order.top().second)%mod;\\n            min_heap_sell_order.pop();\\n        }\\n        \\n        while (!max_heap_buy_order.empty()) {\\n            backlog_orders = (backlog_orders + max_heap_buy_order.top().second)%mod;\\n            max_heap_buy_order.pop();\\n        }\\n        return backlog_orders;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843412,
                "title": "python3-heap-and-simulation",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_heap = []\\n        sell_heap =[]\\n        \\n        BUY = 0\\n        SELL = 1\\n        \\n        for order in orders:\\n            price, amount, order_type = order[::]\\n            \\n            if order_type == BUY:\\n                # see if there is a sell order\\n                while amount:\\n                    if not sell_heap:\\n                        # No sell orders to match the buy amount so add\\n                        # the buy order to the buy heap\\n                        heapq.heappush(buy_heap, (-price, amount))\\n                        break\\n\\n                    sell_price, sell_amount = heapq.heappop(sell_heap)\\n                \\n                    if sell_price <=  price:\\n                        if sell_amount == amount:\\n                            # Both orders are removed from the backlog\\n                            amount = 0\\n                            break\\n                        elif sell_amount < amount:\\n                            # Sell order can be removed, but there are still some\\n                            # buy orders that need to be sold so add those to the\\n                            # buy heap\\n                            amount -= sell_amount\\n                        elif sell_amount > amount:\\n                            # All buy orders can be fulfilled but there are still\\n                            # some sell orders so add those back to the sell_heap\\n                            sell_amount -= amount\\n                            amount  = 0\\n                            heapq.heappush(sell_heap, (sell_price, sell_amount))\\n                    else:\\n                        # sell_price is higher than buy amount so they don\\'t match\\n                        # add the buy to the buy_heap\\n                        heapq.heappush(buy_heap, (-price, amount))\\n                        heapq.heappush(sell_heap, (sell_price, sell_amount))\\n                        break\\n            elif order_type == SELL:\\n                while amount:\\n                    # See if there is a buy order\\n                    if not buy_heap:\\n                        # No buy orders to match sell so add sell order to sell_heap\\n                        heapq.heappush(sell_heap, (price, amount))\\n                        break\\n\\n                    buy_price, buy_amount = heapq.heappop(buy_heap)\\n                    buy_price = abs(buy_price)\\n\\n                    if buy_price >= price:\\n                        if buy_amount == amount:\\n                            break\\n                        elif buy_amount < amount:\\n                            amount -= buy_amount\\n                        elif buy_amount > amount:\\n                            buy_amount -= amount\\n                            amount = 0\\n                            heapq.heappush(buy_heap, (-buy_price, buy_amount))\\n                    else:\\n                        heapq.heappush(sell_heap, (price, amount))\\n                        heapq.heappush(buy_heap, (-buy_price, buy_amount))\\n                        break\\n        \\n        return sum([amount for _, amount in buy_heap + sell_heap]) % (pow(10, 9) + 7)\\n                \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_heap = []\\n        sell_heap =[]\\n        \\n        BUY = 0\\n        SELL = 1\\n        \\n        for order in orders:\\n            price, amount, order_type = order[::]\\n            \\n            if order_type == BUY:\\n                # see if there is a sell order\\n                while amount:\\n                    if not sell_heap:\\n                        # No sell orders to match the buy amount so add\\n                        # the buy order to the buy heap\\n                        heapq.heappush(buy_heap, (-price, amount))\\n                        break\\n\\n                    sell_price, sell_amount = heapq.heappop(sell_heap)\\n                \\n                    if sell_price <=  price:\\n                        if sell_amount == amount:\\n                            # Both orders are removed from the backlog\\n                            amount = 0\\n                            break\\n                        elif sell_amount < amount:\\n                            # Sell order can be removed, but there are still some\\n                            # buy orders that need to be sold so add those to the\\n                            # buy heap\\n                            amount -= sell_amount\\n                        elif sell_amount > amount:\\n                            # All buy orders can be fulfilled but there are still\\n                            # some sell orders so add those back to the sell_heap\\n                            sell_amount -= amount\\n                            amount  = 0\\n                            heapq.heappush(sell_heap, (sell_price, sell_amount))\\n                    else:\\n                        # sell_price is higher than buy amount so they don\\'t match\\n                        # add the buy to the buy_heap\\n                        heapq.heappush(buy_heap, (-price, amount))\\n                        heapq.heappush(sell_heap, (sell_price, sell_amount))\\n                        break\\n            elif order_type == SELL:\\n                while amount:\\n                    # See if there is a buy order\\n                    if not buy_heap:\\n                        # No buy orders to match sell so add sell order to sell_heap\\n                        heapq.heappush(sell_heap, (price, amount))\\n                        break\\n\\n                    buy_price, buy_amount = heapq.heappop(buy_heap)\\n                    buy_price = abs(buy_price)\\n\\n                    if buy_price >= price:\\n                        if buy_amount == amount:\\n                            break\\n                        elif buy_amount < amount:\\n                            amount -= buy_amount\\n                        elif buy_amount > amount:\\n                            buy_amount -= amount\\n                            amount = 0\\n                            heapq.heappush(buy_heap, (-buy_price, buy_amount))\\n                    else:\\n                        heapq.heappush(sell_heap, (price, amount))\\n                        heapq.heappush(buy_heap, (-buy_price, buy_amount))\\n                        break\\n        \\n        return sum([amount for _, amount in buy_heap + sell_heap]) % (pow(10, 9) + 7)\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840886,
                "title": "java-heaps-simulation",
                "content": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        // min heap\\n        Queue<Order> sellBacklog = new PriorityQueue<>((a, b) -> (a.price - b.price));\\n        \\n        // max heap\\n        Queue<Order> buyBacklog = new PriorityQueue<>((a, b) -> (b.price - a.price));\\n        \\n        for(int[] order : orders) {\\n            \\n            int orderPrice = order[0];\\n            int orderAmount = order[1];\\n            int orderType = order[2];\\n            \\n            // simulate buy case\\n            if(orderType == 0) {\\n                while(!sellBacklog.isEmpty() && sellBacklog.peek().price <= orderPrice && orderAmount>0) {\\n                    Order sellOrder = sellBacklog.peek();\\n                    \\n                    // remove the min of these\\n                    int toRemove = Math.min(orderAmount, sellOrder.amount);\\n                    sellOrder.amount = sellOrder.amount - toRemove;\\n                    \\n                    // remove from sell backlog if the amount is 0\\n                    if(sellOrder.amount == 0) {\\n                        sellBacklog.poll();\\n                    }\\n                    \\n                    orderAmount = orderAmount - toRemove;\\n                }\\n                \\n                if(orderAmount > 0) {\\n                    buyBacklog.offer(new Order(orderPrice, orderAmount));\\n                }\\n                \\n            } else {\\n                \\n                // simulate sell case\\n                while(!buyBacklog.isEmpty() && buyBacklog.peek().price >= orderPrice && orderAmount>0) {\\n                    Order buyOrder = buyBacklog.peek();\\n                    \\n                    // remove the min of these\\n                    int toRemove = Math.min(orderAmount, buyOrder.amount);\\n                    buyOrder.amount = buyOrder.amount - toRemove;\\n                    \\n                    // remove from buy backlog if the amount is 0\\n                    if(buyOrder.amount == 0) {\\n                        buyBacklog.poll();\\n                    }\\n                    \\n                    orderAmount = orderAmount - toRemove;\\n                    \\n                }\\n                \\n                 if(orderAmount > 0) {\\n                    sellBacklog.offer(new Order(orderPrice, orderAmount));\\n                }\\n            }\\n        }\\n        \\n        long backLogOrdersAmount = 0;\\n        for(Order order: buyBacklog) {\\n            backLogOrdersAmount = backLogOrdersAmount + order.amount;\\n        }\\n        \\n        for(Order order: sellBacklog) {\\n            backLogOrdersAmount = backLogOrdersAmount + order.amount;\\n        }\\n        \\n        return (int) (backLogOrdersAmount % 1000000007L);\\n\\n    }\\n}\\n\\nclass Order {\\n    \\n    int price;\\n    int amount;\\n    \\n    public Order(int price, int amount) {\\n        this.price = price;\\n        this.amount = amount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        \\n        // min heap\\n        Queue<Order> sellBacklog = new PriorityQueue<>((a, b) -> (a.price - b.price));\\n        \\n        // max heap\\n        Queue<Order> buyBacklog = new PriorityQueue<>((a, b) -> (b.price - a.price));\\n        \\n        for(int[] order : orders) {\\n            \\n            int orderPrice = order[0];\\n            int orderAmount = order[1];\\n            int orderType = order[2];\\n            \\n            // simulate buy case\\n            if(orderType == 0) {\\n                while(!sellBacklog.isEmpty() && sellBacklog.peek().price <= orderPrice && orderAmount>0) {\\n                    Order sellOrder = sellBacklog.peek();\\n                    \\n                    // remove the min of these\\n                    int toRemove = Math.min(orderAmount, sellOrder.amount);\\n                    sellOrder.amount = sellOrder.amount - toRemove;\\n                    \\n                    // remove from sell backlog if the amount is 0\\n                    if(sellOrder.amount == 0) {\\n                        sellBacklog.poll();\\n                    }\\n                    \\n                    orderAmount = orderAmount - toRemove;\\n                }\\n                \\n                if(orderAmount > 0) {\\n                    buyBacklog.offer(new Order(orderPrice, orderAmount));\\n                }\\n                \\n            } else {\\n                \\n                // simulate sell case\\n                while(!buyBacklog.isEmpty() && buyBacklog.peek().price >= orderPrice && orderAmount>0) {\\n                    Order buyOrder = buyBacklog.peek();\\n                    \\n                    // remove the min of these\\n                    int toRemove = Math.min(orderAmount, buyOrder.amount);\\n                    buyOrder.amount = buyOrder.amount - toRemove;\\n                    \\n                    // remove from buy backlog if the amount is 0\\n                    if(buyOrder.amount == 0) {\\n                        buyBacklog.poll();\\n                    }\\n                    \\n                    orderAmount = orderAmount - toRemove;\\n                    \\n                }\\n                \\n                 if(orderAmount > 0) {\\n                    sellBacklog.offer(new Order(orderPrice, orderAmount));\\n                }\\n            }\\n        }\\n        \\n        long backLogOrdersAmount = 0;\\n        for(Order order: buyBacklog) {\\n            backLogOrdersAmount = backLogOrdersAmount + order.amount;\\n        }\\n        \\n        for(Order order: sellBacklog) {\\n            backLogOrdersAmount = backLogOrdersAmount + order.amount;\\n        }\\n        \\n        return (int) (backLogOrdersAmount % 1000000007L);\\n\\n    }\\n}\\n\\nclass Order {\\n    \\n    int price;\\n    int amount;\\n    \\n    public Order(int price, int amount) {\\n        this.price = price;\\n        this.amount = amount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834542,
                "title": "java-priority-queue-simple-100",
                "content": "```\\nclass Solution {\\n    private class Order{\\n        int price;\\n        int qty;\\n        \\n        Order(int price,int qty){\\n            this.price=price;\\n            this.qty=qty;\\n        }\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sell=new PriorityQueue<Order>((a,b)->a.price-b.price);\\n        PriorityQueue<Order> buy=new PriorityQueue<Order>((a,b)->b.price-a.price);\\n        for(int[] order:orders){\\n            int price=order[0];\\n            int amount=order[1];\\n            int type=order[2];\\n            if(type==0){//buy\\n                while(!sell.isEmpty() && sell.peek().price<=price && amount>0){\\n                    Order ord=sell.peek();\\n                    //cant execute more than what was put in queue or current amount\\n                    int toRemove=Math.min(amount,ord.qty);\\n                    ord.qty-=toRemove;\\n                    amount-=toRemove;\\n                    if(ord.qty==0){\\n                        sell.poll();\\n                    }\\n                }\\n                if(amount>0){\\n                    buy.add(new Order(price,amount));\\n                }\\n            }\\n            else{\\n                //sell\\n                while(!buy.isEmpty() && buy.peek().price>=price && amount>0){\\n                    Order ord=buy.peek();\\n                    int toRemove=Math.min(amount,ord.qty);\\n                    ord.qty-=toRemove;\\n                    amount-=toRemove;\\n                    if(ord.qty==0){\\n                        buy.poll();\\n                    }\\n                }\\n                if(amount>0){\\n                    sell.add(new Order(price,amount));\\n                }\\n            }\\n        }\\n        long sellCount=0;\\n        for(Order ord:sell){\\n            sellCount+=ord.qty;\\n        }\\n        long buyCount=0;\\n        for(Order ord:buy){\\n            buyCount+=ord.qty;\\n        }\\n        long total=sellCount+buyCount;\\n        return (int)(total%1000000007L);\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    private class Order{\\n        int price;\\n        int qty;\\n        \\n        Order(int price,int qty){\\n            this.price=price;\\n            this.qty=qty;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1826690,
                "title": "c-using-priority-queue",
                "content": "C# version of - https://leetcode.com/problems/number-of-orders-in-the-backlog/discuss/1119992/JavaC%2B%2BPython-Priority-Queue\\n\\n```\\npublic class Solution \\n{\\n    public int GetNumberOfBacklogOrders(int[][] orders) \\n    {\\n        const int kMod = (int)1e9 + 7;\\n        int ans = 0;\\n\\n        var buysMaxHeap = new PriorityQueue<int[], int[]>(new ComparerDesc());\\n        var sellsMinHeap = new PriorityQueue<int[], int[]>(new ComparerAsc());\\n\\n        // 1. We are iterating through the orders array.\\n        foreach (var order in orders)\\n        {\\n            // 2. If the order is a buy order, we are adding it to the buysMaxHeap.\\n            if (order[2] == 0)\\n            {\\n                buysMaxHeap.Enqueue(order, order);\\n            } \\n            // 3. If the order is a sell order, we are adding it to the sellsMinHeap.\\n            else\\n            {\\n                sellsMinHeap.Enqueue(order, order);\\n            }\\n\\n            // 4. We are checking if the buysMaxHeap and sellsMinHeap are empty or not.\\n            // 5. If they are not empty, \\n                // we are checking if the top of the buysMaxHeap is greater than the top of the sellsMinHeap.\\n            while (buysMaxHeap.Count > 0 && sellsMinHeap.Count > 0 &&\\n                     buysMaxHeap.Peek()[0] >= sellsMinHeap.Peek()[0])\\n            {\\n                // 6. If the condition is true, \\n                    // we are taking the minimum of the two top elements and adding it to the ans variable.\\n                int minAmount = Math.Min(buysMaxHeap.Peek()[1], sellsMinHeap.Peek()[1]);\\n                // 7. We are also subtracting the minimum amount from the top of the heap.\\n                buysMaxHeap.Peek()[1] -= minAmount;\\n                sellsMinHeap.Peek()[1] -= minAmount;\\n                \\n                // 8. If the top of the heap is empty, we are removing it from the heap.\\n                if (buysMaxHeap.Peek()[1] == 0)\\n                    buysMaxHeap.Dequeue();\\n                \\n                // 9. We are doing the same for the sellsMinHeap.\\n                if (sellsMinHeap.Peek()[1] == 0)\\n                    sellsMinHeap.Dequeue();\\n            }\\n        }\\n        \\n        while (buysMaxHeap.Count > 0)\\n        {\\n            ans += buysMaxHeap.Dequeue()[1];\\n            ans %= kMod;\\n        }\\n\\n        \\n        while (sellsMinHeap.Count > 0)\\n        {\\n            ans += sellsMinHeap.Dequeue()[1];\\n            ans %= kMod;\\n        }\\n\\n        // 10. return ans.\\n        return ans;        \\n    }\\n}\\n\\npublic class ComparerDesc : IComparer<int[]>\\n{\\n    // highest to lowest\\n    public int Compare(int[] x, int[] y) =>  y[0] - x[0];\\n}\\npublic class ComparerAsc : IComparer<int[]>\\n{\\n    // lowest to highest\\n    public int Compare(int[] x, int[] y) =>  x[0] - y[0];\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int GetNumberOfBacklogOrders(int[][] orders) \\n    {\\n        const int kMod = (int)1e9 + 7;\\n        int ans = 0;\\n\\n        var buysMaxHeap = new PriorityQueue<int[], int[]>(new ComparerDesc());\\n        var sellsMinHeap = new PriorityQueue<int[], int[]>(new ComparerAsc());\\n\\n        // 1. We are iterating through the orders array.\\n        foreach (var order in orders)\\n        {\\n            // 2. If the order is a buy order, we are adding it to the buysMaxHeap.\\n            if (order[2] == 0)\\n            {\\n                buysMaxHeap.Enqueue(order, order);\\n            } \\n            // 3. If the order is a sell order, we are adding it to the sellsMinHeap.\\n            else\\n            {\\n                sellsMinHeap.Enqueue(order, order);\\n            }\\n\\n            // 4. We are checking if the buysMaxHeap and sellsMinHeap are empty or not.\\n            // 5. If they are not empty, \\n                // we are checking if the top of the buysMaxHeap is greater than the top of the sellsMinHeap.\\n            while (buysMaxHeap.Count > 0 && sellsMinHeap.Count > 0 &&\\n                     buysMaxHeap.Peek()[0] >= sellsMinHeap.Peek()[0])\\n            {\\n                // 6. If the condition is true, \\n                    // we are taking the minimum of the two top elements and adding it to the ans variable.\\n                int minAmount = Math.Min(buysMaxHeap.Peek()[1], sellsMinHeap.Peek()[1]);\\n                // 7. We are also subtracting the minimum amount from the top of the heap.\\n                buysMaxHeap.Peek()[1] -= minAmount;\\n                sellsMinHeap.Peek()[1] -= minAmount;\\n                \\n                // 8. If the top of the heap is empty, we are removing it from the heap.\\n                if (buysMaxHeap.Peek()[1] == 0)\\n                    buysMaxHeap.Dequeue();\\n                \\n                // 9. We are doing the same for the sellsMinHeap.\\n                if (sellsMinHeap.Peek()[1] == 0)\\n                    sellsMinHeap.Dequeue();\\n            }\\n        }\\n        \\n        while (buysMaxHeap.Count > 0)\\n        {\\n            ans += buysMaxHeap.Dequeue()[1];\\n            ans %= kMod;\\n        }\\n\\n        \\n        while (sellsMinHeap.Count > 0)\\n        {\\n            ans += sellsMinHeap.Dequeue()[1];\\n            ans %= kMod;\\n        }\\n\\n        // 10. return ans.\\n        return ans;        \\n    }\\n}\\n\\npublic class ComparerDesc : IComparer<int[]>\\n{\\n    // highest to lowest\\n    public int Compare(int[] x, int[] y) =>  y[0] - x[0];\\n}\\npublic class ComparerAsc : IComparer<int[]>\\n{\\n    // lowest to highest\\n    public int Compare(int[] x, int[] y) =>  x[0] - y[0];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743580,
                "title": "kotlin-priorityqueue-and-hashmap",
                "content": "This is really a system design question of how to implement an order book.\\nSimple solution to follow along. Some code can be refactored but loses simplicity.\\n\\n```\\nclass OrderBookSolution {\\n    fun getNumberOfBacklogOrders(orders: Array<IntArray>): Int {\\n        val mod = 1_000_000_007L\\n\\t\\t\\n\\t\\t// Map of buy Price to Quantity\\n        val mapBuyPriceQuantity = mutableMapOf<Int, Int>()\\n\\t\\t// max heap, always want the highest buy order price first\\n        val pqBuyPrice = PriorityQueue<Int> { a, b -> b - a}\\n\\n\\t\\t// Map of sell Price to Quantity\\n        val mapSellPriceQuantity = mutableMapOf<Int, Int>()\\n\\t\\t// min heap, always want the lowest sell order price first\\n        val pqSellPrice = PriorityQueue<Int>()\\n\\t\\t\\n        orders.forEach {\\n            addToOrderBook(\\n                it,\\n                mapBuyPriceQuantity,\\n                pqBuyPrice,\\n                mapSellPriceQuantity,\\n                pqSellPrice\\n            )\\n        }\\n\\t\\t\\n        var remainingOrders: Long = 0\\n        mapBuyPriceQuantity.values.forEach {\\n            remainingOrders += it\\n        }\\n        mapSellPriceQuantity.values.forEach {\\n            remainingOrders += it\\n        }\\n\\n        return (remainingOrders % mod).toInt()\\n    }\\n\\n\\t// Add buy/sell orders\\n    fun addToOrderBook(\\n        nums: IntArray,\\n        mapBuyPriceQuantity: MutableMap<Int, Int>,\\n        pqBuyPrice: PriorityQueue<Int>,\\n        mapSellPriceQuantity: MutableMap<Int, Int>,\\n        pqSellPrice: PriorityQueue<Int>\\n    ) {\\n        val price = nums[0]\\n        val quantity = nums[1]\\n        val isBuying = nums[2] == 0\\n\\n        if (isBuying) {\\n            mapBuyPriceQuantity[price]?.let { currentQuantity ->\\n                mapBuyPriceQuantity[price] = currentQuantity + quantity\\n            } ?: run {\\n                pqBuyPrice.add(price)\\n                mapBuyPriceQuantity[price] = quantity\\n            }\\n\\n        } else {\\n            mapSellPriceQuantity[price]?.let { currentQuantity ->\\n                mapSellPriceQuantity[price] = currentQuantity + quantity\\n            } ?: run {\\n                pqSellPrice.add(price)\\n                mapSellPriceQuantity[price] = quantity\\n            }\\n        }\\n\\n\\t\\t// match orders\\n        executeAnyOrders(\\n            mapBuyPriceQuantity,\\n            pqBuyPrice,\\n            mapSellPriceQuantity,\\n            pqSellPrice\\n        )\\n    }\\n\\n    fun executeAnyOrders(\\n        mapBuyPriceQuantity: MutableMap<Int, Int>,\\n        pqBuyPrice: PriorityQueue<Int>,\\n        mapSellPriceQuantity: MutableMap<Int, Int>,\\n        pqSellPrice: PriorityQueue<Int>\\n    ) {\\n        var anyTradesExecuted = true\\n\\n        while (anyTradesExecuted) {\\n            anyTradesExecuted = false\\n            // Check if buys or sells are empty\\n            if (pqSellPrice.isEmpty() || pqBuyPrice.isEmpty()) return\\n\\n            val lowestSellPrice = pqSellPrice.peek()\\n            val highestBuyPrice = pqBuyPrice.peek()\\n\\n            if (lowestSellPrice <= highestBuyPrice) {\\n                val lowestSellQuantity = mapSellPriceQuantity[lowestSellPrice] ?: 0\\n                val highestBuyQuantity = mapBuyPriceQuantity[highestBuyPrice] ?: 0\\n\\n                // if any quantity available to buy and sell\\n                if (lowestSellQuantity > 0 && highestBuyQuantity > 0) {\\n                    anyTradesExecuted = true\\n                    val remainingSharesAvailableToSell = lowestSellQuantity - highestBuyQuantity\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// buy and sell orders fulfilled\\n                    if (remainingSharesAvailableToSell == 0) {\\n                        pqSellPrice.poll()\\n                        mapSellPriceQuantity.remove(lowestSellPrice)\\n\\n                        pqBuyPrice.poll()\\n                        mapBuyPriceQuantity.remove(highestBuyPrice)\\n                    }\\n\\t\\t\\t\\t\\t// sell orders remaining\\n\\t\\t\\t\\t\\telse if (remainingSharesAvailableToSell > 0) {\\n                        pqBuyPrice.poll()\\n                        mapBuyPriceQuantity.remove(highestBuyPrice)\\n                        mapSellPriceQuantity[lowestSellPrice] = Math.abs(remainingSharesAvailableToSell)\\n                    }\\n\\t\\t\\t\\t\\t// buy orders remaining\\n\\t\\t\\t\\t\\telse {\\n                        pqSellPrice.poll()\\n                        mapSellPriceQuantity.remove(lowestSellPrice)\\n                        mapBuyPriceQuantity[highestBuyPrice] = Math.abs(remainingSharesAvailableToSell)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass OrderBookSolution {\\n    fun getNumberOfBacklogOrders(orders: Array<IntArray>): Int {\\n        val mod = 1_000_000_007L\\n\\t\\t\\n\\t\\t// Map of buy Price to Quantity\\n        val mapBuyPriceQuantity = mutableMapOf<Int, Int>()\\n\\t\\t// max heap, always want the highest buy order price first\\n        val pqBuyPrice = PriorityQueue<Int> { a, b -> b - a}\\n\\n\\t\\t// Map of sell Price to Quantity\\n        val mapSellPriceQuantity = mutableMapOf<Int, Int>()\\n\\t\\t// min heap, always want the lowest sell order price first\\n        val pqSellPrice = PriorityQueue<Int>()\\n\\t\\t\\n        orders.forEach {\\n            addToOrderBook(\\n                it,\\n                mapBuyPriceQuantity,\\n                pqBuyPrice,\\n                mapSellPriceQuantity,\\n                pqSellPrice\\n            )\\n        }\\n\\t\\t\\n        var remainingOrders: Long = 0\\n        mapBuyPriceQuantity.values.forEach {\\n            remainingOrders += it\\n        }\\n        mapSellPriceQuantity.values.forEach {\\n            remainingOrders += it\\n        }\\n\\n        return (remainingOrders % mod).toInt()\\n    }\\n\\n\\t// Add buy/sell orders\\n    fun addToOrderBook(\\n        nums: IntArray,\\n        mapBuyPriceQuantity: MutableMap<Int, Int>,\\n        pqBuyPrice: PriorityQueue<Int>,\\n        mapSellPriceQuantity: MutableMap<Int, Int>,\\n        pqSellPrice: PriorityQueue<Int>\\n    ) {\\n        val price = nums[0]\\n        val quantity = nums[1]\\n        val isBuying = nums[2] == 0\\n\\n        if (isBuying) {\\n            mapBuyPriceQuantity[price]?.let { currentQuantity ->\\n                mapBuyPriceQuantity[price] = currentQuantity + quantity\\n            } ?: run {\\n                pqBuyPrice.add(price)\\n                mapBuyPriceQuantity[price] = quantity\\n            }\\n\\n        } else {\\n            mapSellPriceQuantity[price]?.let { currentQuantity ->\\n                mapSellPriceQuantity[price] = currentQuantity + quantity\\n            } ?: run {\\n                pqSellPrice.add(price)\\n                mapSellPriceQuantity[price] = quantity\\n            }\\n        }\\n\\n\\t\\t// match orders\\n        executeAnyOrders(\\n            mapBuyPriceQuantity,\\n            pqBuyPrice,\\n            mapSellPriceQuantity,\\n            pqSellPrice\\n        )\\n    }\\n\\n    fun executeAnyOrders(\\n        mapBuyPriceQuantity: MutableMap<Int, Int>,\\n        pqBuyPrice: PriorityQueue<Int>,\\n        mapSellPriceQuantity: MutableMap<Int, Int>,\\n        pqSellPrice: PriorityQueue<Int>\\n    ) {\\n        var anyTradesExecuted = true\\n\\n        while (anyTradesExecuted) {\\n            anyTradesExecuted = false\\n            // Check if buys or sells are empty\\n            if (pqSellPrice.isEmpty() || pqBuyPrice.isEmpty()) return\\n\\n            val lowestSellPrice = pqSellPrice.peek()\\n            val highestBuyPrice = pqBuyPrice.peek()\\n\\n            if (lowestSellPrice <= highestBuyPrice) {\\n                val lowestSellQuantity = mapSellPriceQuantity[lowestSellPrice] ?: 0\\n                val highestBuyQuantity = mapBuyPriceQuantity[highestBuyPrice] ?: 0\\n\\n                // if any quantity available to buy and sell\\n                if (lowestSellQuantity > 0 && highestBuyQuantity > 0) {\\n                    anyTradesExecuted = true\\n                    val remainingSharesAvailableToSell = lowestSellQuantity - highestBuyQuantity\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// buy and sell orders fulfilled\\n                    if (remainingSharesAvailableToSell == 0) {\\n                        pqSellPrice.poll()\\n                        mapSellPriceQuantity.remove(lowestSellPrice)\\n\\n                        pqBuyPrice.poll()\\n                        mapBuyPriceQuantity.remove(highestBuyPrice)\\n                    }\\n\\t\\t\\t\\t\\t// sell orders remaining\\n\\t\\t\\t\\t\\telse if (remainingSharesAvailableToSell > 0) {\\n                        pqBuyPrice.poll()\\n                        mapBuyPriceQuantity.remove(highestBuyPrice)\\n                        mapSellPriceQuantity[lowestSellPrice] = Math.abs(remainingSharesAvailableToSell)\\n                    }\\n\\t\\t\\t\\t\\t// buy orders remaining\\n\\t\\t\\t\\t\\telse {\\n                        pqSellPrice.poll()\\n                        mapSellPriceQuantity.remove(lowestSellPrice)\\n                        mapBuyPriceQuantity[highestBuyPrice] = Math.abs(remainingSharesAvailableToSell)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720095,
                "title": "java-simple-solution-using-min-max-heap",
                "content": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a,b) -> -Integer.compare(a[0], b[0]));\\n        \\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a,b) -> Integer.compare(a[0], b[0]));\\n        \\n        for(int[] order: orders){\\n            if(order[2] == 0){\\n                if(sell.isEmpty())\\n                    buy.offer(order);\\n                else if(sell.peek()[0] <= order[0]){\\n                    if(sell.peek()[1] > order[1])\\n                        sell.peek()[1] -= order[1];\\n                    \\n                    else if(sell.peek()[1] == order[1])\\n                        sell.poll();\\n                    \\n                    else if(sell.peek()[1] < order[1]){\\n                        while(order[1] != 0 && !sell.isEmpty() && order[0] >= sell.peek()[0]){\\n                            if(order[1] >= sell.peek()[1])\\n                                order[1] -= sell.poll()[1];\\n                            else{\\n                                sell.peek()[1] -= order[1];\\n                                order[1] = 0;\\n                            }\\n                        }\\n                        if(order[1] != 0)\\n                            buy.offer(order);\\n                    }\\n                }\\n                else\\n                    buy.offer(order);\\n            }\\n            else{\\n                if(buy.isEmpty())\\n                    sell.offer(order);\\n                else if(buy.peek()[0] >= order[0]){\\n                    if(buy.peek()[1] > order[1])\\n                        buy.peek()[1] -= order[1];\\n                    \\n                    else if(buy.peek()[1] == order[1])\\n                        buy.poll();\\n                    \\n                    else if(buy.peek()[1] < order[1]){\\n                        while(order[1] != 0 && !buy.isEmpty() && buy.peek()[0] >= order[0]){\\n                            if(order[1] >= buy.peek()[1])\\n                                order[1] -= buy.poll()[1];\\n                            else{\\n                                buy.peek()[1] -= order[1];\\n                                order[1] = 0;\\n                            }\\n                        }\\n                        if(order[1] != 0)\\n                            sell.offer(order);\\n                    }\\n                }\\n                else\\n                    sell.offer(order);\\n            }\\n        }\\n        int count = 0;\\n        \\n        while(!buy.isEmpty())\\n            count = (count%1000000007 + buy.poll()[1]%1000000007)%1000000007;\\n        \\n        while(!sell.isEmpty())\\n            count = (count%1000000007 + sell.poll()[1]%1000000007)%1000000007;\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> buy = new PriorityQueue<>((a,b) -> -Integer.compare(a[0], b[0]));\\n        \\n        PriorityQueue<int[]> sell = new PriorityQueue<>((a,b) -> Integer.compare(a[0], b[0]));\\n        \\n        for(int[] order: orders){\\n            if(order[2] == 0){\\n                if(sell.isEmpty())\\n                    buy.offer(order);\\n                else if(sell.peek()[0] <= order[0]){\\n                    if(sell.peek()[1] > order[1])\\n                        sell.peek()[1] -= order[1];\\n                    \\n                    else if(sell.peek()[1] == order[1])\\n                        sell.poll();\\n                    \\n                    else if(sell.peek()[1] < order[1]){\\n                        while(order[1] != 0 && !sell.isEmpty() && order[0] >= sell.peek()[0]){\\n                            if(order[1] >= sell.peek()[1])\\n                                order[1] -= sell.poll()[1];\\n                            else{\\n                                sell.peek()[1] -= order[1];\\n                                order[1] = 0;\\n                            }\\n                        }\\n                        if(order[1] != 0)\\n                            buy.offer(order);\\n                    }\\n                }\\n                else\\n                    buy.offer(order);\\n            }\\n            else{\\n                if(buy.isEmpty())\\n                    sell.offer(order);\\n                else if(buy.peek()[0] >= order[0]){\\n                    if(buy.peek()[1] > order[1])\\n                        buy.peek()[1] -= order[1];\\n                    \\n                    else if(buy.peek()[1] == order[1])\\n                        buy.poll();\\n                    \\n                    else if(buy.peek()[1] < order[1]){\\n                        while(order[1] != 0 && !buy.isEmpty() && buy.peek()[0] >= order[0]){\\n                            if(order[1] >= buy.peek()[1])\\n                                order[1] -= buy.poll()[1];\\n                            else{\\n                                buy.peek()[1] -= order[1];\\n                                order[1] = 0;\\n                            }\\n                        }\\n                        if(order[1] != 0)\\n                            sell.offer(order);\\n                    }\\n                }\\n                else\\n                    sell.offer(order);\\n            }\\n        }\\n        int count = 0;\\n        \\n        while(!buy.isEmpty())\\n            count = (count%1000000007 + buy.poll()[1]%1000000007)%1000000007;\\n        \\n        while(!sell.isEmpty())\\n            count = (count%1000000007 + sell.poll()[1]%1000000007)%1000000007;\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705847,
                "title": "python-heap",
                "content": "```\\nimport heapq as hq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyHeap = []\\n        sellHeap = []\\n        \\n        ans = 0\\n        for order in orders:\\n            if order[2] == 0:\\n                buyPrice, buyAmount = order[0], order[1]\\n                if len(sellHeap) > 0:\\n                    while sellHeap:\\n                        sellPrice, sellAmount = hq.heappop(sellHeap)\\n                        sellAmount = -1 * sellAmount\\n\\n                        if sellPrice <= buyPrice:\\n                            if sellAmount < buyAmount:\\n                                buyAmount -= sellAmount\\n                                sellAmount = 0\\n                            elif sellAmount > buyAmount:\\n                                sellAmount -= buyAmount\\n                                buyAmount = 0\\n                                hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                                break\\n                            else:\\n                                buyAmount = 0\\n                                sellAmount = 0\\n                        else:\\n                            hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                            break\\n                    if buyAmount:        \\n                        hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                        \\n                else:\\n                    hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                    \\n            else:\\n                sellPrice, sellAmount = order[0], order[1]\\n                if len(buyHeap) > 0:\\n                    while buyHeap:\\n                        buyPrice, buyAmount = hq.heappop(buyHeap)\\n                        buyPrice = -1 * buyPrice\\n                        buyAmount = -1 * buyAmount\\n\\n                        if sellPrice <= buyPrice:\\n                            if sellAmount < buyAmount:\\n                                buyAmount -= sellAmount\\n                                sellAmount = 0\\n                                hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                                break\\n                            elif sellAmount > buyAmount:\\n                                sellAmount -= buyAmount\\n                                buyAmount = 0\\n                            else:\\n                                buyAmount = 0\\n                                sellAmount = 0\\n                        else:\\n                            hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                            break\\n                    \\n                    if sellAmount:\\n                        hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                        \\n                else:\\n                    hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                    \\n        while buyHeap:\\n            price, amount = hq.heappop(buyHeap)\\n            ans += (-1 * amount)\\n            \\n        while sellHeap:\\n            price, amount = hq.heappop(sellHeap)\\n            ans += (-1 * amount)\\n            \\n        return ans % (pow(10, 9) + 7)\\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq as hq\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyHeap = []\\n        sellHeap = []\\n        \\n        ans = 0\\n        for order in orders:\\n            if order[2] == 0:\\n                buyPrice, buyAmount = order[0], order[1]\\n                if len(sellHeap) > 0:\\n                    while sellHeap:\\n                        sellPrice, sellAmount = hq.heappop(sellHeap)\\n                        sellAmount = -1 * sellAmount\\n\\n                        if sellPrice <= buyPrice:\\n                            if sellAmount < buyAmount:\\n                                buyAmount -= sellAmount\\n                                sellAmount = 0\\n                            elif sellAmount > buyAmount:\\n                                sellAmount -= buyAmount\\n                                buyAmount = 0\\n                                hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                                break\\n                            else:\\n                                buyAmount = 0\\n                                sellAmount = 0\\n                        else:\\n                            hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                            break\\n                    if buyAmount:        \\n                        hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                        \\n                else:\\n                    hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                    \\n            else:\\n                sellPrice, sellAmount = order[0], order[1]\\n                if len(buyHeap) > 0:\\n                    while buyHeap:\\n                        buyPrice, buyAmount = hq.heappop(buyHeap)\\n                        buyPrice = -1 * buyPrice\\n                        buyAmount = -1 * buyAmount\\n\\n                        if sellPrice <= buyPrice:\\n                            if sellAmount < buyAmount:\\n                                buyAmount -= sellAmount\\n                                sellAmount = 0\\n                                hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                                break\\n                            elif sellAmount > buyAmount:\\n                                sellAmount -= buyAmount\\n                                buyAmount = 0\\n                            else:\\n                                buyAmount = 0\\n                                sellAmount = 0\\n                        else:\\n                            hq.heappush(buyHeap, (-1 * buyPrice, -1 * buyAmount))\\n                            break\\n                    \\n                    if sellAmount:\\n                        hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                        \\n                else:\\n                    hq.heappush(sellHeap, (sellPrice, -1 * sellAmount))\\n                    \\n        while buyHeap:\\n            price, amount = hq.heappop(buyHeap)\\n            ans += (-1 * amount)\\n            \\n        while sellHeap:\\n            price, amount = hq.heappop(sellHeap)\\n            ans += (-1 * amount)\\n            \\n        return ans % (pow(10, 9) + 7)\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657622,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    final int mod = (int) 1e9+7;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int n = orders.length;\\n        // for the buy orders place the larger value first\\n        PriorityQueue<int[]> buy_orders = new PriorityQueue<>((a, b) -> {\\n            return b[0] - a[0];\\n        });\\n        // for the sell orders place the smaller value first\\n        PriorityQueue<int[]> sell_orders = new PriorityQueue<>((a, b) -> {\\n            return a[0] - b[0];\\n        });\\n        long total = 0;\\n        for (int [] nxt : orders) {\\n            if (nxt[2]==0) {\\n                while (!sell_orders.isEmpty() && sell_orders.peek()[0]<=nxt[0]) {\\n                    int [] smaller = sell_orders.poll();\\n                    if (smaller[1]<nxt[1]) {\\n                        nxt[1]-=smaller[1];\\n                        total-=smaller[1];\\n                    }\\n                    else if (smaller[1]>=nxt[1]) {\\n                        smaller[1]-=nxt[1];\\n                        total-=nxt[1];\\n                        if (smaller[1]>0) sell_orders.add(smaller);\\n                        nxt[1]=0;\\n                        break;\\n                    }\\n                }\\n                total+=nxt[1];\\n                if (nxt[1]>0) buy_orders.add(nxt);\\n            }\\n            else {\\n                while (!buy_orders.isEmpty() && buy_orders.peek()[0]>=nxt[0]) {\\n                    int [] larger = buy_orders.poll();\\n                    if (larger[1]<nxt[1]) {\\n                        nxt[1]-=larger[1];\\n                        total-=larger[1];\\n                    }\\n                    else if (larger[1]>=nxt[1]) {\\n                        larger[1]-=nxt[1];\\n                        total-=nxt[1];\\n                        if (larger[1]>0) buy_orders.add(larger);\\n                        nxt[1]=0;\\n                        break;\\n                    }\\n                }\\n                total+=nxt[1];\\n                if (nxt[1]>0) sell_orders.add(nxt);\\n            }\\n        }\\n        return (int) (total%mod);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int mod = (int) 1e9+7;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int n = orders.length;\\n        // for the buy orders place the larger value first\\n        PriorityQueue<int[]> buy_orders = new PriorityQueue<>((a, b) -> {\\n            return b[0] - a[0];\\n        });\\n        // for the sell orders place the smaller value first\\n        PriorityQueue<int[]> sell_orders = new PriorityQueue<>((a, b) -> {\\n            return a[0] - b[0];\\n        });\\n        long total = 0;\\n        for (int [] nxt : orders) {\\n            if (nxt[2]==0) {\\n                while (!sell_orders.isEmpty() && sell_orders.peek()[0]<=nxt[0]) {\\n                    int [] smaller = sell_orders.poll();\\n                    if (smaller[1]<nxt[1]) {\\n                        nxt[1]-=smaller[1];\\n                        total-=smaller[1];\\n                    }\\n                    else if (smaller[1]>=nxt[1]) {\\n                        smaller[1]-=nxt[1];\\n                        total-=nxt[1];\\n                        if (smaller[1]>0) sell_orders.add(smaller);\\n                        nxt[1]=0;\\n                        break;\\n                    }\\n                }\\n                total+=nxt[1];\\n                if (nxt[1]>0) buy_orders.add(nxt);\\n            }\\n            else {\\n                while (!buy_orders.isEmpty() && buy_orders.peek()[0]>=nxt[0]) {\\n                    int [] larger = buy_orders.poll();\\n                    if (larger[1]<nxt[1]) {\\n                        nxt[1]-=larger[1];\\n                        total-=larger[1];\\n                    }\\n                    else if (larger[1]>=nxt[1]) {\\n                        larger[1]-=nxt[1];\\n                        total-=nxt[1];\\n                        if (larger[1]>0) buy_orders.add(larger);\\n                        nxt[1]=0;\\n                        break;\\n                    }\\n                }\\n                total+=nxt[1];\\n                if (nxt[1]>0) sell_orders.add(nxt);\\n            }\\n        }\\n        return (int) (total%mod);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632510,
                "title": "python-min-max-heap",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        buy, sell = [],[]\\n        for p,q,t in orders:\\n            if t==0:\\n                while q and sell and p>=sell[0][0]:\\n                    pt,qt = heapq.heappop(sell)\\n                    if q>=qt: q-=qt\\n                    else: heapq.heappush(sell, (pt,qt-q)); q=0\\n                if q: heapq.heappush(buy,(-p,q))\\n            else:\\n                while q and buy and p<=-buy[0][0]:\\n                    pt,qt = heapq.heappop(buy)\\n                    if q>=qt: q-=qt\\n                    else: heapq.heappush(buy, (pt,qt-q)); q=0\\n                if q: heapq.heappush(sell,(p,q))\\n        ans = sum([x for _,x in buy])+sum([x for _,x in sell])\\n        return ans%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        buy, sell = [],[]\\n        for p,q,t in orders:\\n            if t==0:\\n                while q and sell and p>=sell[0][0]:\\n                    pt,qt = heapq.heappop(sell)\\n                    if q>=qt: q-=qt\\n                    else: heapq.heappush(sell, (pt,qt-q)); q=0\\n                if q: heapq.heappush(buy,(-p,q))\\n            else:\\n                while q and buy and p<=-buy[0][0]:\\n                    pt,qt = heapq.heappop(buy)\\n                    if q>=qt: q-=qt\\n                    else: heapq.heappush(buy, (pt,qt-q)); q=0\\n                if q: heapq.heappush(sell,(p,q))\\n        ans = sum([x for _,x in buy])+sum([x for _,x in sell])\\n        return ans%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620940,
                "title": "python-2-heaps",
                "content": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, o: List[List[int]]) -> int:\\n        bb=[];sb=[]\\n        for i in range(len(o)):\\n            if o[i][2]==0:\\n                c=o[i][1]\\n                while sb and c>0 and sb[0][0]<=o[i][0]:\\n                    v=heapq.heappop(sb)\\n                    if v[1]>c:\\n                        heapq.heappush(sb,(v[0],v[1]-c))\\n                        c=0\\n                        break\\n                    else:c-=v[1] \\n                if c>0:heapq.heappush(bb,(-o[i][0],c))\\n            else:                        \\n                c=o[i][1]\\n                while bb and c>0 and -bb[0][0]>=o[i][0]:\\n                    v=heapq.heappop(bb)\\n                    if -v[0]>=o[i][0]:\\n                        if v[1]>c:\\n                            heapq.heappush(bb,(v[0],v[1]-c))\\n                            c=0\\n                            break\\n                        else:c-=v[1]\\n                if c>0:heapq.heappush(sb,(o[i][0],c))\\n            \\n        r=0\\n        for e in bb:r+=e[1]\\n        for e in sb:r+=e[1]\\n        return r%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, o: List[List[int]]) -> int:\\n        bb=[];sb=[]\\n        for i in range(len(o)):\\n            if o[i][2]==0:\\n                c=o[i][1]\\n                while sb and c>0 and sb[0][0]<=o[i][0]:\\n                    v=heapq.heappop(sb)\\n                    if v[1]>c:\\n                        heapq.heappush(sb,(v[0],v[1]-c))\\n                        c=0\\n                        break\\n                    else:c-=v[1] \\n                if c>0:heapq.heappush(bb,(-o[i][0],c))\\n            else:                        \\n                c=o[i][1]\\n                while bb and c>0 and -bb[0][0]>=o[i][0]:\\n                    v=heapq.heappop(bb)\\n                    if -v[0]>=o[i][0]:\\n                        if v[1]>c:\\n                            heapq.heappush(bb,(v[0],v[1]-c))\\n                            c=0\\n                            break\\n                        else:c-=v[1]\\n                if c>0:heapq.heappush(sb,(o[i][0],c))\\n            \\n        r=0\\n        for e in bb:r+=e[1]\\n        for e in sb:r+=e[1]\\n        return r%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585810,
                "title": "golang-two-heaps-beat-100",
                "content": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buy, sell := make(maxPrice, 0, len(orders) >> 3), make(minPrice, 0, len(orders) >> 3)\\n    for _, ord := range orders {\\n        switch ord[2] {\\n            case 0: // buying\\n                // check selling backlog\\n                for sell.Len() > 0 && ord[1] > 0 && sell[0].price <= ord[0] {\\n                    if sell[0].amount > ord[1] {\\n                        sell[0].amount -= ord[1]\\n                        ord[1] = 0\\n                        break \\n                    }\\n\\n                    ord[1] -= sell[0].amount\\n                    heap.Pop(&sell)\\n                }\\n           \\n                if ord[1] > 0 {\\n                    heap.Push(&buy, order{price: ord[0], amount: ord[1]})\\n                }\\n            \\n            default: // selling\\n                // check buying backlog \\n                for buy.Len() > 0 && ord[1] > 0 && buy[0].price >= ord[0] {\\n                    if buy[0].amount > ord[1] {\\n                        buy[0].amount -= ord[1]\\n                        ord[1] = 0\\n                        break \\n                    }\\n\\n                    ord[1] -= buy[0].amount\\n                    heap.Pop(&buy)\\n                }\\n            \\n                if ord[1] > 0 {\\n                    heap.Push(&sell, order{price: ord[0], amount: ord[1]})\\n                }\\n        }\\n    } \\n   \\n    ans := 0\\n    for i := range buy {\\n        ans += buy[i].amount\\n    }\\n    for i := range sell {\\n        ans += sell[i].amount\\n    }\\n    \\n    return ans % 1_000_000_007\\n}\\n\\ntype order struct {\\n    price int\\n    amount int\\n}\\n\\ntype minPrice []order\\n\\nfunc (m minPrice) Less(i, j int) bool { return m[i].price < m[j].price }\\nfunc (m minPrice) Len() int  { return len(m) }\\nfunc (m minPrice) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *minPrice) Push(x interface{}) {\\n    *m = append(*m, x.(order))\\n}\\n\\nfunc (m *minPrice) Pop() interface{} {\\n    old := *m\\n    n := len(old)\\n    x := old[n-1]\\n    *m = old[:n-1]\\n    return x\\n}\\n\\ntype maxPrice []order\\n\\nfunc (m maxPrice) Less(i, j int) bool { return m[i].price >= m[j].price }\\nfunc (m maxPrice) Len() int {return len(m) }\\nfunc (m maxPrice) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *maxPrice) Push(x interface{}) {\\n    *m = append(*m, x.(order))\\n}\\n\\nfunc (m *maxPrice) Pop() interface{} {\\n    old := *m\\n    n := len(old)\\n    x := old[n-1]\\n    *m = old[:n-1]\\n    return x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getNumberOfBacklogOrders(orders [][]int) int {\\n    buy, sell := make(maxPrice, 0, len(orders) >> 3), make(minPrice, 0, len(orders) >> 3)\\n    for _, ord := range orders {\\n        switch ord[2] {\\n            case 0: // buying\\n                // check selling backlog\\n                for sell.Len() > 0 && ord[1] > 0 && sell[0].price <= ord[0] {\\n                    if sell[0].amount > ord[1] {\\n                        sell[0].amount -= ord[1]\\n                        ord[1] = 0\\n                        break \\n                    }\\n\\n                    ord[1] -= sell[0].amount\\n                    heap.Pop(&sell)\\n                }\\n           \\n                if ord[1] > 0 {\\n                    heap.Push(&buy, order{price: ord[0], amount: ord[1]})\\n                }\\n            \\n            default: // selling\\n                // check buying backlog \\n                for buy.Len() > 0 && ord[1] > 0 && buy[0].price >= ord[0] {\\n                    if buy[0].amount > ord[1] {\\n                        buy[0].amount -= ord[1]\\n                        ord[1] = 0\\n                        break \\n                    }\\n\\n                    ord[1] -= buy[0].amount\\n                    heap.Pop(&buy)\\n                }\\n            \\n                if ord[1] > 0 {\\n                    heap.Push(&sell, order{price: ord[0], amount: ord[1]})\\n                }\\n        }\\n    } \\n   \\n    ans := 0\\n    for i := range buy {\\n        ans += buy[i].amount\\n    }\\n    for i := range sell {\\n        ans += sell[i].amount\\n    }\\n    \\n    return ans % 1_000_000_007\\n}\\n\\ntype order struct {\\n    price int\\n    amount int\\n}\\n\\ntype minPrice []order\\n\\nfunc (m minPrice) Less(i, j int) bool { return m[i].price < m[j].price }\\nfunc (m minPrice) Len() int  { return len(m) }\\nfunc (m minPrice) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *minPrice) Push(x interface{}) {\\n    *m = append(*m, x.(order))\\n}\\n\\nfunc (m *minPrice) Pop() interface{} {\\n    old := *m\\n    n := len(old)\\n    x := old[n-1]\\n    *m = old[:n-1]\\n    return x\\n}\\n\\ntype maxPrice []order\\n\\nfunc (m maxPrice) Less(i, j int) bool { return m[i].price >= m[j].price }\\nfunc (m maxPrice) Len() int {return len(m) }\\nfunc (m maxPrice) Swap(i, j int) {\\n    m[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m *maxPrice) Push(x interface{}) {\\n    *m = append(*m, x.(order))\\n}\\n\\nfunc (m *maxPrice) Pop() interface{} {\\n    old := *m\\n    n := len(old)\\n    x := old[n-1]\\n    *m = old[:n-1]\\n    return x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567945,
                "title": "solution-using-two-heaps-faster-than-75",
                "content": "\\n        priority_queue<pair<long long int,long long int> > buy;\\n        priority_queue<pair<long long int,long long int>,vector< pair<long long int,long long int> >,greater< pair<long long int,long long int>> > sell;\\n        \\n        for(int i=0;i<orders.size();i++)\\n        {\\n        \\n         if(orders[i][2]==0)\\n         {\\n             long long int a,b;\\n             while(!sell.empty() && sell.top().first<=orders[i][0] && orders[i][1]>0)\\n             {\\n                //cout<<\"hi\"<<endl;\\n                a=sell.top().first;\\n                b=sell.top().second;\\n                \\n                long long int res=orders[i][1]-b;\\n                long long int res1=b-orders[i][1];\\n                 \\n                orders[i][1]=res>0?res:0;\\n                \\n                b=res1>0?res1:0;\\n                \\n                sell.pop();\\n                 \\n                if(b>0)\\n                {\\n                    sell.push({a,b});\\n                }\\n                \\n             }\\n             if(orders[i][1]>0)    \\n             buy.push({orders[i][0],orders[i][1]}); \\n         }\\n         \\n         if(orders[i][2]==1)\\n         {\\n             long long int a,b;\\n             while(!buy.empty() && buy.top().first>=orders[i][0] && orders[i][1]>0)\\n             {\\n                //cout<<\"hello*\"<<endl;\\n                a=buy.top().first;\\n                b=buy.top().second;\\n                 \\n                long long int res=orders[i][1]-b;\\n                long long int res1=b-orders[i][1];\\n                 \\n                orders[i][1]=res>0?res:0;\\n                \\n                b=res1>0?res1:0;\\n                \\n                buy.pop();\\n                 \\n                if(b>0)\\n                {\\n                    buy.push({a,b});\\n                }\\n             }\\n             if(orders[i][1]>0)    \\n             sell.push({orders[i][0],orders[i][1]}); \\n         }\\n         \\n        }\\n        long long int sum=0;\\n        \\n        while(buy.size()>0)\\n        {\\n            sum+=buy.top().second;\\n            buy.pop();\\n        }\\n        while(sell.size()>0)\\n        {\\n            sum+=sell.top().second;\\n            sell.pop();\\n        }\\n        return (sum%1000000007);",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n        priority_queue<pair<long long int,long long int> > buy;\\n        priority_queue<pair<long long int,long long int>,vector< pair<long long int,long long int> >,greater< pair<long long int,long long int>> > sell;\\n        \\n        for(int i=0;i<orders.size();i++)\\n        {\\n        \\n         if(orders[i][2]==0)\\n         {\\n             long long int a,b;\\n             while(!sell.empty() && sell.top().first<=orders[i][0] && orders[i][1]>0)\\n             {\\n                //cout<<\"hi\"<<endl;\\n                a=sell.top().first;\\n                b=sell.top().second;\\n                \\n                long long int res=orders[i][1]-b;\\n                long long int res1=b-orders[i][1];\\n                 \\n                orders[i][1]=res>0?res:0;\\n                \\n                b=res1>0?res1:0;\\n                \\n                sell.pop();\\n                 \\n                if(b>0)\\n                {\\n                    sell.push({a,b});\\n                }\\n                \\n             }\\n             if(orders[i][1]>0)    \\n             buy.push({orders[i][0],orders[i][1]}); \\n         }\\n         \\n         if(orders[i][2]==1)\\n         {\\n             long long int a,b;\\n             while(!buy.empty() && buy.top().first>=orders[i][0] && orders[i][1]>0)\\n             {\\n                //cout<<\"hello*\"<<endl;\\n                a=buy.top().first;\\n                b=buy.top().second;\\n                 \\n                long long int res=orders[i][1]-b;\\n                long long int res1=b-orders[i][1];\\n                 \\n                orders[i][1]=res>0?res:0;\\n                \\n                b=res1>0?res1:0;\\n                \\n                buy.pop();\\n                 \\n                if(b>0)\\n                {\\n                    buy.push({a,b});\\n                }\\n             }\\n             if(orders[i][1]>0)    \\n             sell.push({orders[i][0],orders[i][1]}); \\n         }\\n         \\n        }\\n        long long int sum=0;\\n        \\n        while(buy.size()>0)\\n        {\\n            sum+=buy.top().second;\\n            buy.pop();\\n        }\\n        while(sell.size()>0)\\n        {\\n            sum+=sell.top().second;\\n            sell.pop();\\n        }\\n        return (sum%1000000007);",
                "codeTag": "C++"
            },
            {
                "id": 1562971,
                "title": "2-heap-python-3-solution-min-heap-and-max-heap",
                "content": "```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\tbuy_backlog, sell_backlog = [], []\\n\\n\\tl = len(orders)\\n\\n\\tfor i in range(0, l):\\n\\t\\tif orders[i][2]==0:\\n\\t\\t\\twhile sell_backlog and sell_backlog[0][0]<=orders[i][0]:\\n\\t\\t\\t\\tp, q = heapq.heappop(sell_backlog)\\n\\t\\t\\t\\t#print(\"buy\", p, q, orders[i])\\n\\t\\t\\t\\tif q>orders[i][1]:\\n\\t\\t\\t\\t\\theapq.heappush(sell_backlog, (p, q-orders[i][1]))\\n\\t\\t\\t\\t\\torders[i][1] = 0\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif q<=orders[i][1]:\\n\\t\\t\\t\\t\\torders[i][1]-=q\\n\\t\\t\\tif orders[i][1]:\\n\\t\\t\\t\\t#print(\"here\")\\n\\t\\t\\t\\theapq.heappush(buy_backlog, (-orders[i][0], orders[i][1]))\\n\\t\\telse:\\n\\t\\t\\twhile buy_backlog and abs(buy_backlog[0][0])>=orders[i][0]:\\n\\t\\t\\t\\tp, q = heapq.heappop(buy_backlog)\\n\\t\\t\\t\\t#print(\"sell\", p, q, orders[i])\\n\\t\\t\\t\\tif q>orders[i][1]:\\n\\t\\t\\t\\t\\theapq.heappush(buy_backlog, (p, q-orders[i][1]))\\n\\t\\t\\t\\t\\torders[i][1] = 0\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif q<=orders[i][1]:\\n\\t\\t\\t\\t\\torders[i][1]-=q\\n\\t\\t\\tif orders[i][1]:\\n\\t\\t\\t\\theapq.heappush(sell_backlog, (orders[i][0], orders[i][1]))\\n\\t\\t#print(buy_backlog, sell_backlog)\\n\\n\\ttotal = 0\\n\\n\\twhile buy_backlog:\\n\\t\\ttotal = (total+heapq.heappop(buy_backlog)[1])%1000000007\\n\\n\\twhile sell_backlog:\\n\\t\\ttotal = (total+heapq.heappop(sell_backlog)[1])%1000000007\\n\\n\\treturn total\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n\\tbuy_backlog, sell_backlog = [], []\\n\\n\\tl = len(orders)\\n\\n\\tfor i in range(0, l):\\n\\t\\tif orders[i][2]==0:\\n\\t\\t\\twhile sell_backlog and sell_backlog[0][0]<=orders[i][0]:\\n\\t\\t\\t\\tp, q = heapq.heappop(sell_backlog)\\n\\t\\t\\t\\t#print(\"buy\", p, q, orders[i])\\n\\t\\t\\t\\tif q>orders[i][1]:\\n\\t\\t\\t\\t\\theapq.heappush(sell_backlog, (p, q-orders[i][1]))\\n\\t\\t\\t\\t\\torders[i][1] = 0\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif q<=orders[i][1]:\\n\\t\\t\\t\\t\\torders[i][1]-=q\\n\\t\\t\\tif orders[i][1]:\\n\\t\\t\\t\\t#print(\"here\")\\n\\t\\t\\t\\theapq.heappush(buy_backlog, (-orders[i][0], orders[i][1]))\\n\\t\\telse:\\n\\t\\t\\twhile buy_backlog and abs(buy_backlog[0][0])>=orders[i][0]:\\n\\t\\t\\t\\tp, q = heapq.heappop(buy_backlog)\\n\\t\\t\\t\\t#print(\"sell\", p, q, orders[i])\\n\\t\\t\\t\\tif q>orders[i][1]:\\n\\t\\t\\t\\t\\theapq.heappush(buy_backlog, (p, q-orders[i][1]))\\n\\t\\t\\t\\t\\torders[i][1] = 0\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif q<=orders[i][1]:\\n\\t\\t\\t\\t\\torders[i][1]-=q\\n\\t\\t\\tif orders[i][1]:\\n\\t\\t\\t\\theapq.heappush(sell_backlog, (orders[i][0], orders[i][1]))\\n\\t\\t#print(buy_backlog, sell_backlog)\\n\\n\\ttotal = 0\\n\\n\\twhile buy_backlog:\\n\\t\\ttotal = (total+heapq.heappop(buy_backlog)[1])%1000000007\\n\\n\\twhile sell_backlog:\\n\\t\\ttotal = (total+heapq.heappop(sell_backlog)[1])%1000000007\\n\\n\\treturn total\\n                    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1540545,
                "title": "javascript-solution-min-and-max-heap",
                "content": "```\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const MOD = 1e9 + 7;\\n    const n = orders.length;\\n   \\n    const buys = new MaxPriorityQueue({ priority: x => x[0] });\\n    const sells = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let [currPrice, currAmount, currType] of orders) {\\n        if (currType === 0) { // current is a buy\\n            while (!sells.isEmpty() && currAmount > 0) {\\n                let [sellPrice, sellAmount] = sells.dequeue().element;\\n                \\n                if (sellPrice > currPrice) {\\n                    sells.enqueue([sellPrice, sellAmount]);\\n                    break;\\n                } \\n               \\n                if (sellAmount > currAmount) {\\n                    sellAmount -= currAmount;\\n                    currAmount = 0;\\n                    sells.enqueue([sellPrice, sellAmount]);\\n                }\\n                else if (sellAmount <= currAmount){\\n                    currAmount -= sellAmount;\\n                }\\n            }\\n            \\n            if (currAmount > 0) buys.enqueue([currPrice, currAmount]);\\n        }\\n        else if (currType === 1) {\\n            while (!buys.isEmpty() && currAmount > 0) {\\n                let [buyPrice, buyAmount] = buys.dequeue().element;\\n                \\n                if (buyPrice < currPrice) {\\n                    buys.enqueue([buyPrice, buyAmount]);\\n                    break;\\n                }\\n                \\n                if (buyAmount > currAmount) {\\n                    buyAmount -= currAmount;\\n                    currAmount = 0;\\n                    buys.enqueue([buyPrice, buyAmount]);\\n                }\\n                else if (buyAmount <= currAmount){\\n                    currAmount -= buyAmount;\\n                }\\n            }\\n            \\n            if (currAmount > 0) sells.enqueue([currPrice, currAmount]);\\n        }\\n    }\\n    \\n    let count = 0;\\n    \\n    while (!buys.isEmpty()) {\\n        const [price, amount] = buys.dequeue().element;\\n        count += amount;\\n    }\\n    \\n    while (!sells.isEmpty()) {\\n        const [price, amount] = sells.dequeue().element;\\n        count += amount;\\n    }\\n    \\n    return count % MOD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const MOD = 1e9 + 7;\\n    const n = orders.length;\\n   \\n    const buys = new MaxPriorityQueue({ priority: x => x[0] });\\n    const sells = new MinPriorityQueue({ priority: x => x[0] });\\n    \\n    for (let [currPrice, currAmount, currType] of orders) {\\n        if (currType === 0) { // current is a buy\\n            while (!sells.isEmpty() && currAmount > 0) {\\n                let [sellPrice, sellAmount] = sells.dequeue().element;\\n                \\n                if (sellPrice > currPrice) {\\n                    sells.enqueue([sellPrice, sellAmount]);\\n                    break;\\n                } \\n               \\n                if (sellAmount > currAmount) {\\n                    sellAmount -= currAmount;\\n                    currAmount = 0;\\n                    sells.enqueue([sellPrice, sellAmount]);\\n                }\\n                else if (sellAmount <= currAmount){\\n                    currAmount -= sellAmount;\\n                }\\n            }\\n            \\n            if (currAmount > 0) buys.enqueue([currPrice, currAmount]);\\n        }\\n        else if (currType === 1) {\\n            while (!buys.isEmpty() && currAmount > 0) {\\n                let [buyPrice, buyAmount] = buys.dequeue().element;\\n                \\n                if (buyPrice < currPrice) {\\n                    buys.enqueue([buyPrice, buyAmount]);\\n                    break;\\n                }\\n                \\n                if (buyAmount > currAmount) {\\n                    buyAmount -= currAmount;\\n                    currAmount = 0;\\n                    buys.enqueue([buyPrice, buyAmount]);\\n                }\\n                else if (buyAmount <= currAmount){\\n                    currAmount -= buyAmount;\\n                }\\n            }\\n            \\n            if (currAmount > 0) sells.enqueue([currPrice, currAmount]);\\n        }\\n    }\\n    \\n    let count = 0;\\n    \\n    while (!buys.isEmpty()) {\\n        const [price, amount] = buys.dequeue().element;\\n        count += amount;\\n    }\\n    \\n    while (!sells.isEmpty()) {\\n        const [price, amount] = sells.dequeue().element;\\n        count += amount;\\n    }\\n    \\n    return count % MOD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1518264,
                "title": "java-fast-solution-using-priority-queue-beats-99",
                "content": "Maintain two heaps that represent the buy and sell backlogs. Try to match each order with the item at the top of the heap. If not possible, its gets added to the heap as well. \\n\\nOne improvement w.r.t. speed is to have a running total of all order quantities that are currently in backlog. Add to this variable when adding to backlog, subtract when removing from backlog. This way, you don\\'t have to do separate passes to examine the contents of the heaps.\\n\\nNote the extensive use of modulus operator every time we add/remove from `backlogOrderAmount` to ensure we never exceed the bounds.\\n\\n```java\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sellBacklog = new PriorityQueue<>((a, b) -> a[0] - b[0]), buyBacklog = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        \\n        int backlogOrderAmount = 0, ptr = 0;\\n        final int MOD = 1_000_000_007;\\n        \\n        while (ptr < orders.length) {\\n            int[] order = orders[ptr];\\n            \\n            // buy\\n            if (0 == order[2]) {\\n                if (sellBacklog.size() > 0 && sellBacklog.peek()[0] <= order[0]) {\\n                    int[] sellOrder = sellBacklog.peek();\\n                    int orderQty = Math.min(order[1], sellOrder[1]);\\n                    \\n                    sellOrder[1] -= orderQty;\\n                    order[1] -= orderQty;\\n                    \\n                    backlogOrderAmount -= orderQty;\\n                    backlogOrderAmount += MOD;\\n                    backlogOrderAmount %= MOD;\\n                    \\n                    if (0 == sellOrder[1])\\n                        sellBacklog.remove();\\n                    if (0 == order[1])\\n                        ++ptr;\\n                }\\n                else {\\n                    buyBacklog.add(order);\\n                    ++ptr;\\n                    \\n                    backlogOrderAmount += order[1] % MOD;\\n                    backlogOrderAmount %= MOD;\\n                }\\n            }\\n            \\n            // sell\\n            else if (1 == order[2]) {\\n                if (buyBacklog.size() > 0 && buyBacklog.peek()[0] >= order[0]) {\\n                    int[] buyOrder = buyBacklog.peek();\\n                    int orderQty = Math.min(order[1], buyOrder[1]);\\n                    \\n                    buyOrder[1] -= orderQty;\\n                    order[1] -= orderQty;\\n                    \\n                    backlogOrderAmount -= orderQty;\\n                    backlogOrderAmount += MOD;\\n                    backlogOrderAmount %= MOD;\\n                    \\n                    if (0 == buyOrder[1])\\n                        buyBacklog.remove();\\n                    if (0 == order[1])\\n                        ++ptr;\\n                }\\n                else {\\n                    sellBacklog.add(order);\\n                    ++ptr;\\n                    \\n                    backlogOrderAmount += order[1] % MOD;\\n                    backlogOrderAmount %= MOD;\\n                }\\n            }\\n        }\\n      \\n        return backlogOrderAmount;\\n    }\\n}\\n```\\n\\n**Time Complexity**\\n\\n`O(NlogN)`\\n\\n**Space Complexity**\\n\\n`O(N)`",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<int[]> sellBacklog = new PriorityQueue<>((a, b) -> a[0] - b[0]), buyBacklog = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        \\n        int backlogOrderAmount = 0, ptr = 0;\\n        final int MOD = 1_000_000_007;\\n        \\n        while (ptr < orders.length) {\\n            int[] order = orders[ptr];\\n            \\n            // buy\\n            if (0 == order[2]) {\\n                if (sellBacklog.size() > 0 && sellBacklog.peek()[0] <= order[0]) {\\n                    int[] sellOrder = sellBacklog.peek();\\n                    int orderQty = Math.min(order[1], sellOrder[1]);\\n                    \\n                    sellOrder[1] -= orderQty;\\n                    order[1] -= orderQty;\\n                    \\n                    backlogOrderAmount -= orderQty;\\n                    backlogOrderAmount += MOD;\\n                    backlogOrderAmount %= MOD;\\n                    \\n                    if (0 == sellOrder[1])\\n                        sellBacklog.remove();\\n                    if (0 == order[1])\\n                        ++ptr;\\n                }\\n                else {\\n                    buyBacklog.add(order);\\n                    ++ptr;\\n                    \\n                    backlogOrderAmount += order[1] % MOD;\\n                    backlogOrderAmount %= MOD;\\n                }\\n            }\\n            \\n            // sell\\n            else if (1 == order[2]) {\\n                if (buyBacklog.size() > 0 && buyBacklog.peek()[0] >= order[0]) {\\n                    int[] buyOrder = buyBacklog.peek();\\n                    int orderQty = Math.min(order[1], buyOrder[1]);\\n                    \\n                    buyOrder[1] -= orderQty;\\n                    order[1] -= orderQty;\\n                    \\n                    backlogOrderAmount -= orderQty;\\n                    backlogOrderAmount += MOD;\\n                    backlogOrderAmount %= MOD;\\n                    \\n                    if (0 == buyOrder[1])\\n                        buyBacklog.remove();\\n                    if (0 == order[1])\\n                        ++ptr;\\n                }\\n                else {\\n                    sellBacklog.add(order);\\n                    ++ptr;\\n                    \\n                    backlogOrderAmount += order[1] % MOD;\\n                    backlogOrderAmount %= MOD;\\n                }\\n            }\\n        }\\n      \\n        return backlogOrderAmount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504737,
                "title": "java-solution-using-max-and-min-heaps",
                "content": "\\tclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) \\n    {\\n        int mod = 1000000007;\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        \\n        for(int[] order : orders)\\n        {\\n            if(order[2] == 0)\\n            {\\n                maxHeap.add(order);    \\n            }\\n            else\\n            {\\n                minHeap.add(order);\\n            }\\n            \\n            while(!maxHeap.isEmpty() && !minHeap.isEmpty())\\n            {\\n                if(maxHeap.peek()[0] >= minHeap.peek()[0])\\n                {\\n                    int[] buyOrder = maxHeap.poll();\\n                    int[] sellOrder = minHeap.poll();\\n                    \\n                    if(buyOrder[1] > sellOrder[1])\\n                    {\\n                        buyOrder[1] -= sellOrder[1];\\n                        maxHeap.add(buyOrder);\\n                    }\\n                    else if(buyOrder[1] < sellOrder[1])\\n                    {\\n                        sellOrder[1] -= buyOrder[1];\\n                        minHeap.add(sellOrder);\\n                    }\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        while(!maxHeap.isEmpty() && !minHeap.isEmpty())\\n        {\\n            if(maxHeap.peek()[0] >= minHeap.peek()[0])\\n            {\\n                int[] buyOrder = maxHeap.poll();\\n                int[] sellOrder = minHeap.poll();\\n                    \\n                if(buyOrder[1] > sellOrder[1])\\n                {\\n                    buyOrder[1] -= sellOrder[1];\\n                    maxHeap.add(buyOrder);\\n                }\\n                else if(buyOrder[1] < sellOrder[1])\\n                {\\n                    sellOrder[1] -= buyOrder[1];\\n                    minHeap.add(sellOrder);\\n                }\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        int result = 0;\\n        while(!minHeap.isEmpty())\\n        {\\n            result = (result + minHeap.poll()[1])%mod;\\n        }\\n        \\n        while(!maxHeap.isEmpty())\\n        {\\n            result = (result + maxHeap.poll()[1])%mod;\\n        }\\n        \\n        return result;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) \\n    {\\n        int mod = 1000000007;\\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        \\n        for(int[] order : orders)\\n        {\\n            if(order[2] == 0)\\n            {\\n                maxHeap.add(order);    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1504300,
                "title": "java-priority-queue-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        // Max Queue for Buy order to identify maximum buy order\\'s value;\\n        PriorityQueue<int[]> buyMaxHeap = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] i1, int[] i2) {\\n                return Integer.compare(i2[0], i1[0]);\\n            }\\n        });\\n\\n        // Min Queue for Sell order to identify minimum sell order\\'s value;\\n        PriorityQueue<int[]> sellMinHeap = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] i1, int[] i2) {\\n                return Integer.compare(i1[0], i2[0]);\\n            }\\n        });\\n\\n        // Input array is modified in the following code. If that is noto feasible,\\n        // we can define a separate container class and work on those objects in PriorityQueue.\\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int totalOrders = order[1];\\n            int type = order[2];            \\n\\n            // Buy Order\\n            if (type == 0) {\\n                while (!sellMinHeap.isEmpty() && sellMinHeap.peek()[0] <= price && totalOrders > 0) {\\n                    int[] sellOrder = sellMinHeap.peek();\\n\\n                    // If current Buy total orders count is greater than what is matched with the current Sell order,\\n                    // we can consume all of Sell orders i.e. poll from Sell queue.\\n                    // Update total Buy order count accordingly.\\n                    if (totalOrders >= sellOrder[1]) {\\n                        sellMinHeap.poll();\\n                        totalOrders -= sellOrder[1];\\n                    } else {\\n                        // There are more Sell orders than the current Buy order. Buy order can be consumed fully i.e.\\n                        // Set the current Buy order\\'s total order count to 0.\\n                        // Update current Sell order\\'s count accordingly\\n                        sellOrder[1] -= totalOrders;\\n                        totalOrders = 0;\\n                    }\\n                }\\n\\n                // If total Buy order count is still remaining, that means, either there are no Sell orders, or\\n                // No Sell order currently has lower amount than the current Buy order.\\n                // So, we update the total order count and insert the current order to Buy Queue.\\n                if (totalOrders != 0) {\\n                    order[1] = totalOrders;\\n                    buyMaxHeap.offer(order);\\n                }\\n                // Sell Order\\n            } else if (type == 1) {\\n                while (!buyMaxHeap.isEmpty() && buyMaxHeap.peek()[0] >= price && totalOrders > 0) {\\n                    int[] buyOrder = buyMaxHeap.peek();\\n\\n                    // If current Sell total orders count is greater than what is matched with the current Buy order,\\n                    // we can consume all of Buy orders i.e. poll from Buy queue.\\n                    // Update total Sell order count accordingly.\\n                    if (totalOrders >= buyOrder[1]) {\\n                        buyMaxHeap.poll();\\n                        totalOrders -= buyOrder[1];\\n                    } else {\\n                        // There are more Buy order counts than the current Sell order.\\n                        // Sell order can be consumed fully i.e.\\n                        // Set the current Sell order\\'s total order count to 0.\\n                        // Update current Buy order\\'s count accordingly\\n                        buyOrder[1] -= totalOrders;\\n                        totalOrders = 0;\\n                    }\\n                }\\n\\n                // If total Sell order count is still remaining, that means, either there are no Buy orders, or\\n                // No Buy order currently has higher amount than the current Sell order.\\n                // So, we update the total order count and insert the current order to Sell Queue.\\n                if (totalOrders != 0) {\\n                    order[1] = totalOrders;\\n                    sellMinHeap.offer(order);\\n                }\\n            } else {\\n                // Throw invalid input exception\\n            }\\n        }\\n\\n        long count = 0;\\n        while (!buyMaxHeap.isEmpty()) {\\n            count += buyMaxHeap.poll()[1];\\n        }\\n\\n        while (!sellMinHeap.isEmpty()) {\\n            count += sellMinHeap.poll()[1];\\n        }\\n\\n        return (int) (count % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        // Max Queue for Buy order to identify maximum buy order\\'s value;\\n        PriorityQueue<int[]> buyMaxHeap = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] i1, int[] i2) {\\n                return Integer.compare(i2[0], i1[0]);\\n            }\\n        });\\n\\n        // Min Queue for Sell order to identify minimum sell order\\'s value;\\n        PriorityQueue<int[]> sellMinHeap = new PriorityQueue<>(new Comparator<>() {\\n            @Override\\n            public int compare(int[] i1, int[] i2) {\\n                return Integer.compare(i1[0], i2[0]);\\n            }\\n        });\\n\\n        // Input array is modified in the following code. If that is noto feasible,\\n        // we can define a separate container class and work on those objects in PriorityQueue.\\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int totalOrders = order[1];\\n            int type = order[2];            \\n\\n            // Buy Order\\n            if (type == 0) {\\n                while (!sellMinHeap.isEmpty() && sellMinHeap.peek()[0] <= price && totalOrders > 0) {\\n                    int[] sellOrder = sellMinHeap.peek();\\n\\n                    // If current Buy total orders count is greater than what is matched with the current Sell order,\\n                    // we can consume all of Sell orders i.e. poll from Sell queue.\\n                    // Update total Buy order count accordingly.\\n                    if (totalOrders >= sellOrder[1]) {\\n                        sellMinHeap.poll();\\n                        totalOrders -= sellOrder[1];\\n                    } else {\\n                        // There are more Sell orders than the current Buy order. Buy order can be consumed fully i.e.\\n                        // Set the current Buy order\\'s total order count to 0.\\n                        // Update current Sell order\\'s count accordingly\\n                        sellOrder[1] -= totalOrders;\\n                        totalOrders = 0;\\n                    }\\n                }\\n\\n                // If total Buy order count is still remaining, that means, either there are no Sell orders, or\\n                // No Sell order currently has lower amount than the current Buy order.\\n                // So, we update the total order count and insert the current order to Buy Queue.\\n                if (totalOrders != 0) {\\n                    order[1] = totalOrders;\\n                    buyMaxHeap.offer(order);\\n                }\\n                // Sell Order\\n            } else if (type == 1) {\\n                while (!buyMaxHeap.isEmpty() && buyMaxHeap.peek()[0] >= price && totalOrders > 0) {\\n                    int[] buyOrder = buyMaxHeap.peek();\\n\\n                    // If current Sell total orders count is greater than what is matched with the current Buy order,\\n                    // we can consume all of Buy orders i.e. poll from Buy queue.\\n                    // Update total Sell order count accordingly.\\n                    if (totalOrders >= buyOrder[1]) {\\n                        buyMaxHeap.poll();\\n                        totalOrders -= buyOrder[1];\\n                    } else {\\n                        // There are more Buy order counts than the current Sell order.\\n                        // Sell order can be consumed fully i.e.\\n                        // Set the current Sell order\\'s total order count to 0.\\n                        // Update current Buy order\\'s count accordingly\\n                        buyOrder[1] -= totalOrders;\\n                        totalOrders = 0;\\n                    }\\n                }\\n\\n                // If total Sell order count is still remaining, that means, either there are no Buy orders, or\\n                // No Buy order currently has higher amount than the current Sell order.\\n                // So, we update the total order count and insert the current order to Sell Queue.\\n                if (totalOrders != 0) {\\n                    order[1] = totalOrders;\\n                    sellMinHeap.offer(order);\\n                }\\n            } else {\\n                // Throw invalid input exception\\n            }\\n        }\\n\\n        long count = 0;\\n        while (!buyMaxHeap.isEmpty()) {\\n            count += buyMaxHeap.poll()[1];\\n        }\\n\\n        while (!sellMinHeap.isEmpty()) {\\n            count += sellMinHeap.poll()[1];\\n        }\\n\\n        return (int) (count % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500029,
                "title": "rust-2-heaps-runtime-21-ms-faster-than-100-00",
                "content": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\\n        #[derive(Eq, Debug, Clone)]\\n        struct Order {\\n            price: i32,\\n            amount: i32,\\n            order_type: i32,\\n        }\\n\\n        impl Order {\\n            fn new(mut price: i32, amount: i32, order_type: i32) -> Self {\\n                if order_type == 1 {\\n                    price *= -1;\\n                }\\n\\n                Self { price, amount, order_type }\\n            }\\n        }\\n\\n        impl Ord for Order {\\n            fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n                self.price.cmp(&other.price)\\n            }\\n        }\\n\\n        impl PartialOrd for Order {\\n            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n                Some(self.cmp(other))\\n            }\\n        }\\n\\n        impl PartialEq for Order {\\n            fn eq(&self, other: &Self) -> bool {\\n                self.price == other.price\\n            }\\n        }\\n\\n        let base: i32 = 10;\\n        let modulo: f64 = (base.pow(9) + 7) as f64;\\n\\n        let mut buy_backlog: BinaryHeap<Order> = BinaryHeap::new();\\n        let mut sell_backlog: BinaryHeap<Order> = BinaryHeap::new();\\n\\n        for order in orders.iter() {\\n            let mut o = Order::new(order[0], order[1], order[2]);\\n\\n            while o.amount > 0 {\\n                if o.order_type == 0 {\\n                    if !sell_backlog.is_empty() && sell_backlog.peek().unwrap().price * -1 <= o.price {\\n                        let mut sell_order = sell_backlog.pop().unwrap();\\n                        let amount = i32::min(sell_order.amount, o.amount);\\n                        o.amount -= amount;\\n                        sell_order.amount -= amount;\\n\\n                        if sell_order.amount > 0 {\\n                            sell_backlog.push(sell_order);\\n                        }\\n                    } else {\\n                        buy_backlog.push(o.clone());\\n                        break;\\n                    }\\n                } else {\\n                    if !buy_backlog.is_empty() && buy_backlog.peek().unwrap().price >= o.price * -1 {\\n                        let mut buy_order = buy_backlog.pop().unwrap();\\n                        let amount = i32::min(buy_order.amount, o.amount);\\n                        o.amount -= amount;\\n                        buy_order.amount -= amount;\\n\\n                        if buy_order.amount > 0 {\\n                            buy_backlog.push(buy_order);\\n                        }\\n                    } else {\\n                        sell_backlog.push(o.clone());\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        ((buy_backlog.iter().map(|order| order.amount as f64).sum::<f64>() + sell_backlog.iter().map(|order| order.amount as f64).sum::<f64>()) % modulo) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\\n        #[derive(Eq, Debug, Clone)]\\n        struct Order {\\n            price: i32,\\n            amount: i32,\\n            order_type: i32,\\n        }\\n\\n        impl Order {\\n            fn new(mut price: i32, amount: i32, order_type: i32) -> Self {\\n                if order_type == 1 {\\n                    price *= -1;\\n                }\\n\\n                Self { price, amount, order_type }\\n            }\\n        }\\n\\n        impl Ord for Order {\\n            fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n                self.price.cmp(&other.price)\\n            }\\n        }\\n\\n        impl PartialOrd for Order {\\n            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n                Some(self.cmp(other))\\n            }\\n        }\\n\\n        impl PartialEq for Order {\\n            fn eq(&self, other: &Self) -> bool {\\n                self.price == other.price\\n            }\\n        }\\n\\n        let base: i32 = 10;\\n        let modulo: f64 = (base.pow(9) + 7) as f64;\\n\\n        let mut buy_backlog: BinaryHeap<Order> = BinaryHeap::new();\\n        let mut sell_backlog: BinaryHeap<Order> = BinaryHeap::new();\\n\\n        for order in orders.iter() {\\n            let mut o = Order::new(order[0], order[1], order[2]);\\n\\n            while o.amount > 0 {\\n                if o.order_type == 0 {\\n                    if !sell_backlog.is_empty() && sell_backlog.peek().unwrap().price * -1 <= o.price {\\n                        let mut sell_order = sell_backlog.pop().unwrap();\\n                        let amount = i32::min(sell_order.amount, o.amount);\\n                        o.amount -= amount;\\n                        sell_order.amount -= amount;\\n\\n                        if sell_order.amount > 0 {\\n                            sell_backlog.push(sell_order);\\n                        }\\n                    } else {\\n                        buy_backlog.push(o.clone());\\n                        break;\\n                    }\\n                } else {\\n                    if !buy_backlog.is_empty() && buy_backlog.peek().unwrap().price >= o.price * -1 {\\n                        let mut buy_order = buy_backlog.pop().unwrap();\\n                        let amount = i32::min(buy_order.amount, o.amount);\\n                        o.amount -= amount;\\n                        buy_order.amount -= amount;\\n\\n                        if buy_order.amount > 0 {\\n                            buy_backlog.push(buy_order);\\n                        }\\n                    } else {\\n                        sell_backlog.push(o.clone());\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        ((buy_backlog.iter().map(|order| order.amount as f64).sum::<f64>() + sell_backlog.iter().map(|order| order.amount as f64).sum::<f64>()) % modulo) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391457,
                "title": "python-heapq-beats-95",
                "content": "Quite a long code but takes care of all the cases.Systematic approach with 2 clean priority queues.\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy,sell=[],[]\\n        n=len(orders)\\n        for price,amount,type in orders:\\n            if type==0:\\n                if sell and price>=sell[0][0]:\\n                    if amount==sell[0][1]:\\n                        heapq.heappop(sell)\\n                    elif sell[0][1]>amount:\\n                        sell[0][1]=sell[0][1]-amount\\n                    else:\\n                        amount-=sell[0][1]\\n                        heapq.heappop(sell)\\n                        while sell and price>=sell[0][0] and amount-sell[0][1]>=0:\\n                            amount-=sell[0][1]\\n                            heapq.heappop(sell)\\n                        if sell and price>=sell[0][0] and amount>0 and amount-sell[0][1]<0:\\n                            sell[0][1]-=amount\\n                        elif sell and price<sell[0][0] and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                        elif not sell and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                else:\\n                    heapq.heappush(buy,[-price,amount])\\n            else:\\n                if buy and price<=(-buy[0][0]):\\n                    if amount==buy[0][1]:\\n                        heapq.heappop(buy)\\n                    elif buy[0][1]>amount:\\n                        buy[0][1]=buy[0][1]-amount\\n                    else:\\n                        amount-=buy[0][1]\\n                        heapq.heappop(buy)\\n                        while buy and price<=(-buy[0][0]) and amount-buy[0][1]>=0:\\n                            amount-=buy[0][1]\\n                            heapq.heappop(buy)\\n                        if buy and price<=(-buy[0][0]) and amount>0 and amount-buy[0][1]<0:\\n                            buy[0][1]-=amount\\n                        elif buy and price>(-buy[0][0]) and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                        elif not buy and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                else:\\n                    heapq.heappush(sell,[price,amount])\\n        ans=0\\n        for _,amt in buy:\\n            ans+=amt\\n        for _,amt in sell:\\n            ans+=amt\\n        return ans%(10**9+7)\\n                \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy,sell=[],[]\\n        n=len(orders)\\n        for price,amount,type in orders:\\n            if type==0:\\n                if sell and price>=sell[0][0]:\\n                    if amount==sell[0][1]:\\n                        heapq.heappop(sell)\\n                    elif sell[0][1]>amount:\\n                        sell[0][1]=sell[0][1]-amount\\n                    else:\\n                        amount-=sell[0][1]\\n                        heapq.heappop(sell)\\n                        while sell and price>=sell[0][0] and amount-sell[0][1]>=0:\\n                            amount-=sell[0][1]\\n                            heapq.heappop(sell)\\n                        if sell and price>=sell[0][0] and amount>0 and amount-sell[0][1]<0:\\n                            sell[0][1]-=amount\\n                        elif sell and price<sell[0][0] and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                        elif not sell and amount>0:\\n                            heapq.heappush(buy,[-price,amount])\\n                else:\\n                    heapq.heappush(buy,[-price,amount])\\n            else:\\n                if buy and price<=(-buy[0][0]):\\n                    if amount==buy[0][1]:\\n                        heapq.heappop(buy)\\n                    elif buy[0][1]>amount:\\n                        buy[0][1]=buy[0][1]-amount\\n                    else:\\n                        amount-=buy[0][1]\\n                        heapq.heappop(buy)\\n                        while buy and price<=(-buy[0][0]) and amount-buy[0][1]>=0:\\n                            amount-=buy[0][1]\\n                            heapq.heappop(buy)\\n                        if buy and price<=(-buy[0][0]) and amount>0 and amount-buy[0][1]<0:\\n                            buy[0][1]-=amount\\n                        elif buy and price>(-buy[0][0]) and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                        elif not buy and amount>0:\\n                            heapq.heappush(sell,[price,amount])\\n                else:\\n                    heapq.heappush(sell,[price,amount])\\n        ans=0\\n        for _,amt in buy:\\n            ans+=amt\\n        for _,amt in sell:\\n            ans+=amt\\n        return ans%(10**9+7)\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376379,
                "title": "easy-to-understand-java-solution-with-comments",
                "content": "```\\npublic class Solution {\\n\\n\\t/*\\n\\t * Time Complexity: O(NlogN), N = the length of the orders array\\n\\t *\\n\\t * Space Complexity: O(N)\\n\\t *\\n\\t */\\n\\n\\tclass Order {\\n\\t\\tint price;\\n\\t\\tint amount;\\n\\n\\t\\tpublic Order(int p, int a) {\\n\\t\\t\\tthis.price = p;\\n\\t\\t\\tthis.amount = a;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tPriorityQueue<Order> buy = new PriorityQueue<Order>((o1, o2) -> o2.price - o1.price);\\n\\t\\tPriorityQueue<Order> sell = new PriorityQueue<Order>((o1, o2) -> o1.price - o2.price);\\n\\t\\tbuy.add(new Order(-1, 0));\\n\\t\\tsell.add(new Order(Integer.MAX_VALUE, 0));\\n\\t\\tfor (int[] order : orders) {\\n\\t\\t\\tif (order[2] == 0) {\\n\\t\\t\\t\\t// handle the buy order, match from existed sell order in the sell queue,\\n\\t\\t\\t\\t// if the amount is not enough, add new buy order into buy queue\\n\\t\\t\\t\\twhile (order[1] > 0 && sell.peek().price <= order[0]) {\\n\\t\\t\\t\\t\\tif (sell.peek().amount <= order[1]) {\\n\\t\\t\\t\\t\\t\\torder[1] -= sell.poll().amount;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tsell.peek().amount -= order[1];\\n\\t\\t\\t\\t\\t\\torder[1] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (order[1] > 0)\\n\\t\\t\\t\\t\\tbuy.add(new Order(order[0], order[1]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// handle the sell order, match from existed buy order in the buy queue,\\n\\t\\t\\t\\t// if the amount is not enough, add new sell order into sell queue\\n\\t\\t\\t\\twhile (order[1] > 0 && buy.peek().price >= order[0]) {\\n\\t\\t\\t\\t\\tif (buy.peek().amount <= order[1]) {\\n\\t\\t\\t\\t\\t\\torder[1] -= buy.poll().amount;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbuy.peek().amount -= order[1];\\n\\t\\t\\t\\t\\t\\torder[1] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (order[1] > 0)\\n\\t\\t\\t\\t\\tsell.add(new Order(order[0], order[1]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tLong ans = 0L;\\n\\t\\twhile (buy.size() > 0)\\n\\t\\t\\tans += buy.poll().amount;\\n\\t\\twhile (sell.size() > 0)\\n\\t\\t\\tans += sell.poll().amount;\\n\\t\\tans %= 1000000007;\\n\\t\\treturn ans.intValue();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n\\n\\t/*\\n\\t * Time Complexity: O(NlogN), N = the length of the orders array\\n\\t *\\n\\t * Space Complexity: O(N)\\n\\t *\\n\\t */\\n\\n\\tclass Order {\\n\\t\\tint price;\\n\\t\\tint amount;\\n\\n\\t\\tpublic Order(int p, int a) {\\n\\t\\t\\tthis.price = p;\\n\\t\\t\\tthis.amount = a;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tPriorityQueue<Order> buy = new PriorityQueue<Order>((o1, o2) -> o2.price - o1.price);\\n\\t\\tPriorityQueue<Order> sell = new PriorityQueue<Order>((o1, o2) -> o1.price - o2.price);\\n\\t\\tbuy.add(new Order(-1, 0));\\n\\t\\tsell.add(new Order(Integer.MAX_VALUE, 0));\\n\\t\\tfor (int[] order : orders) {\\n\\t\\t\\tif (order[2] == 0) {\\n\\t\\t\\t\\t// handle the buy order, match from existed sell order in the sell queue,\\n\\t\\t\\t\\t// if the amount is not enough, add new buy order into buy queue\\n\\t\\t\\t\\twhile (order[1] > 0 && sell.peek().price <= order[0]) {\\n\\t\\t\\t\\t\\tif (sell.peek().amount <= order[1]) {\\n\\t\\t\\t\\t\\t\\torder[1] -= sell.poll().amount;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tsell.peek().amount -= order[1];\\n\\t\\t\\t\\t\\t\\torder[1] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (order[1] > 0)\\n\\t\\t\\t\\t\\tbuy.add(new Order(order[0], order[1]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// handle the sell order, match from existed buy order in the buy queue,\\n\\t\\t\\t\\t// if the amount is not enough, add new sell order into sell queue\\n\\t\\t\\t\\twhile (order[1] > 0 && buy.peek().price >= order[0]) {\\n\\t\\t\\t\\t\\tif (buy.peek().amount <= order[1]) {\\n\\t\\t\\t\\t\\t\\torder[1] -= buy.poll().amount;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbuy.peek().amount -= order[1];\\n\\t\\t\\t\\t\\t\\torder[1] = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (order[1] > 0)\\n\\t\\t\\t\\t\\tsell.add(new Order(order[0], order[1]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tLong ans = 0L;\\n\\t\\twhile (buy.size() > 0)\\n\\t\\t\\tans += buy.poll().amount;\\n\\t\\twhile (sell.size() > 0)\\n\\t\\t\\tans += sell.poll().amount;\\n\\t\\tans %= 1000000007;\\n\\t\\treturn ans.intValue();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361134,
                "title": "java-clean-solution-with-treemap",
                "content": "```\\nclass Solution {\\n    \\n    private static int MOD = (int) (1E9 + 7);\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer, Integer> buys = new TreeMap<>();\\n        TreeMap<Integer, Integer> sells = new TreeMap<>();\\n        \\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int remainingOrders = order[1];\\n            \\n            // Handle buy\\n            if (order[2] == 0) {                \\n                while (remainingOrders != 0 && !sells.isEmpty() && sells.firstKey() <= price) {\\n                    Map.Entry<Integer, Integer> entry = sells.firstEntry();\\n                    if (remainingOrders < entry.getValue()) {\\n                        sells.put(entry.getKey(), entry.getValue() - remainingOrders);\\n                        remainingOrders = 0;                        \\n                    } else {\\n                        remainingOrders -= entry.getValue();\\n                        sells.remove(entry.getKey());\\n                    }\\n                }\\n                if (remainingOrders > 0) {\\n                    buys.put(price, remainingOrders + buys.getOrDefault(price, 0));\\n                }\\n            }\\n            \\n            // Handle sell\\n            if (order[2] == 1) {                                \\n                while (remainingOrders != 0 && !buys.isEmpty() && buys.lastKey() >= price) {\\n                    Map.Entry<Integer, Integer> entry = buys.lastEntry();\\n                    if (remainingOrders < entry.getValue()) {\\n                        buys.put(entry.getKey(), entry.getValue() - remainingOrders);\\n                        remainingOrders = 0;                        \\n                    } else {\\n                        remainingOrders -= entry.getValue();\\n                        buys.remove(entry.getKey());\\n                    }\\n                }\\n                if (remainingOrders > 0) {\\n                    sells.put(price, remainingOrders + sells.getOrDefault(price, 0));\\n                }                \\n            }\\n        }\\n        \\n        int sum = 0;\\n        for (int amount : buys.values()) {\\n            sum = (sum + amount) % MOD;\\n        }\\n        for (int amount : sells.values()) {\\n            sum = (sum + amount) % MOD;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static int MOD = (int) (1E9 + 7);\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer, Integer> buys = new TreeMap<>();\\n        TreeMap<Integer, Integer> sells = new TreeMap<>();\\n        \\n        for (int[] order : orders) {\\n            int price = order[0];\\n            int remainingOrders = order[1];\\n            \\n            // Handle buy\\n            if (order[2] == 0) {                \\n                while (remainingOrders != 0 && !sells.isEmpty() && sells.firstKey() <= price) {\\n                    Map.Entry<Integer, Integer> entry = sells.firstEntry();\\n                    if (remainingOrders < entry.getValue()) {\\n                        sells.put(entry.getKey(), entry.getValue() - remainingOrders);\\n                        remainingOrders = 0;                        \\n                    } else {\\n                        remainingOrders -= entry.getValue();\\n                        sells.remove(entry.getKey());\\n                    }\\n                }\\n                if (remainingOrders > 0) {\\n                    buys.put(price, remainingOrders + buys.getOrDefault(price, 0));\\n                }\\n            }\\n            \\n            // Handle sell\\n            if (order[2] == 1) {                                \\n                while (remainingOrders != 0 && !buys.isEmpty() && buys.lastKey() >= price) {\\n                    Map.Entry<Integer, Integer> entry = buys.lastEntry();\\n                    if (remainingOrders < entry.getValue()) {\\n                        buys.put(entry.getKey(), entry.getValue() - remainingOrders);\\n                        remainingOrders = 0;                        \\n                    } else {\\n                        remainingOrders -= entry.getValue();\\n                        buys.remove(entry.getKey());\\n                    }\\n                }\\n                if (remainingOrders > 0) {\\n                    sells.put(price, remainingOrders + sells.getOrDefault(price, 0));\\n                }                \\n            }\\n        }\\n        \\n        int sum = 0;\\n        for (int amount : buys.values()) {\\n            sum = (sum + amount) % MOD;\\n        }\\n        for (int amount : sells.values()) {\\n            sum = (sum + amount) % MOD;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360428,
                "title": "c-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        for(auto& v : orders){\\n            int p = v[0], q = v[1];\\n            if(v[2] == 0) buys[p] += q;\\n            else sells[p] += q;\\n            while(match()){};\\n        }\\n        auto res = 0LL;\\n        for(auto [p, q] : buys) res+=q;\\n        for(auto [p, q] : sells) res+=q;\\n        return res % 1000000007;\\n    }\\n    \\n    bool match(){\\n        if(buys.empty() || sells.empty()) return false;\\n        auto& [p1, q1] = *buys.begin();\\n        auto& [p2, q2] = *sells.begin();\\n        if(p1<p2) return false;\\n        int q = min(q1, q2);\\n        q1 -= q;\\n        q2 -= q;\\n        if(q1 == 0) buys.erase(buys.begin());\\n        if(q2 == 0) sells.erase(sells.begin());\\n        return true;\\n    }\\n    \\n    map<int, long long, greater<int>> buys;\\n    map<int, long long> sells;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        for(auto& v : orders){\\n            int p = v[0], q = v[1];\\n            if(v[2] == 0) buys[p] += q;\\n            else sells[p] += q;\\n            while(match()){}",
                "codeTag": "Java"
            },
            {
                "id": 1347703,
                "title": "java-clean-o-n-logn-time-priorityqueue-solution",
                "content": "```\\nclass Solution {\\n    // max queue storing {price, amount, type}\\n    private PriorityQueue<int[]> buy = new PriorityQueue<>((a,b) -> b[0] - a[0]);\\n    \\n    // min queue storing {price, amount, type}\\n    private PriorityQueue<int[]> sell = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n    \\n    private static final int MOD = 1_000_000_007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        for (int[] order : orders) {\\n            // Step 1). add order into corresponding heap\\n            if (order[2] == 0) buy.add(order);\\n            else sell.add(order);\\n            \\n            // Step 2). try matching from the top of heap\\n            match();\\n        }\\n        \\n        int res = 0;\\n        for (int[] b : buy) res = (res + b[1]) % MOD;\\n        for (int[] s : sell) res = (res + s[1]) % MOD;\\n        \\n        return res;\\n    }\\n    \\n    private void match() {\\n        while (!buy.isEmpty() && !sell.isEmpty()) {\\n            if (buy.peek()[0] < sell.peek()[0]) break;\\n            \\n            int curr = Math.min(buy.peek()[1], sell.peek()[1]);\\n            \\n            if (buy.peek()[1] == curr) buy.poll();\\n            else buy.peek()[1] -= curr;\\n            \\n            if (sell.peek()[1] == curr) sell.poll();\\n            else sell.peek()[1] -= curr;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    // max queue storing {price, amount, type}\\n    private PriorityQueue<int[]> buy = new PriorityQueue<>((a,b) -> b[0] - a[0]);\\n    \\n    // min queue storing {price, amount, type}\\n    private PriorityQueue<int[]> sell = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n    \\n    private static final int MOD = 1_000_000_007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        for (int[] order : orders) {\\n            // Step 1). add order into corresponding heap\\n            if (order[2] == 0) buy.add(order);\\n            else sell.add(order);\\n            \\n            // Step 2). try matching from the top of heap\\n            match();\\n        }\\n        \\n        int res = 0;\\n        for (int[] b : buy) res = (res + b[1]) % MOD;\\n        for (int[] s : sell) res = (res + s[1]) % MOD;\\n        \\n        return res;\\n    }\\n    \\n    private void match() {\\n        while (!buy.isEmpty() && !sell.isEmpty()) {\\n            if (buy.peek()[0] < sell.peek()[0]) break;\\n            \\n            int curr = Math.min(buy.peek()[1], sell.peek()[1]);\\n            \\n            if (buy.peek()[1] == curr) buy.poll();\\n            else buy.peek()[1] -= curr;\\n            \\n            if (sell.peek()[1] == curr) sell.poll();\\n            else sell.peek()[1] -= curr;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346115,
                "title": "two-heaps-76-speed",
                "content": "Runtime: 788 ms, faster than 76.13%\\nMemory Usage: 54.1 MB, less than 10.36%\\n```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_log = []\\n        sell_log = []\\n        for price, amount, order_type in orders:\\n            if order_type:\\n                while buy_log and amount:\\n                    buy_price, buy_amount = heappop(buy_log)\\n                    if -buy_price >= price:\\n                        if buy_amount <= amount:\\n                            amount -= buy_amount\\n                        else:\\n                            buy_amount -= amount\\n                            heappush(buy_log, (buy_price, buy_amount))\\n                            amount = 0\\n                    else:\\n                        heappush(buy_log, (buy_price, buy_amount))\\n                        break\\n                if amount:\\n                    heappush(sell_log, (price, amount))\\n            else:\\n                while sell_log and amount:\\n                    sell_price, sell_amount = heappop(sell_log)\\n                    if sell_price <= price:\\n                        if sell_amount <= amount:\\n                            amount -= sell_amount\\n                        else:\\n                            sell_amount -= amount\\n                            heappush(sell_log, (sell_price, sell_amount))\\n                            amount = 0\\n                    else:\\n                        heappush(sell_log, (sell_price, sell_amount))\\n                        break\\n                if amount:\\n                    heappush(buy_log, (-price, amount))\\n        return (sum(amount for _, amount in buy_log) +\\n                sum(amount for _, amount in sell_log)) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buy_log = []\\n        sell_log = []\\n        for price, amount, order_type in orders:\\n            if order_type:\\n                while buy_log and amount:\\n                    buy_price, buy_amount = heappop(buy_log)\\n                    if -buy_price >= price:\\n                        if buy_amount <= amount:\\n                            amount -= buy_amount\\n                        else:\\n                            buy_amount -= amount\\n                            heappush(buy_log, (buy_price, buy_amount))\\n                            amount = 0\\n                    else:\\n                        heappush(buy_log, (buy_price, buy_amount))\\n                        break\\n                if amount:\\n                    heappush(sell_log, (price, amount))\\n            else:\\n                while sell_log and amount:\\n                    sell_price, sell_amount = heappop(sell_log)\\n                    if sell_price <= price:\\n                        if sell_amount <= amount:\\n                            amount -= sell_amount\\n                        else:\\n                            sell_amount -= amount\\n                            heappush(sell_log, (sell_price, sell_amount))\\n                            amount = 0\\n                    else:\\n                        heappush(sell_log, (sell_price, sell_amount))\\n                        break\\n                if amount:\\n                    heappush(buy_log, (-price, amount))\\n        return (sum(amount for _, amount in buy_log) +\\n                sum(amount for _, amount in sell_log)) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333633,
                "title": "simple-java",
                "content": "This idea is based on the fact that we only need to match one type order.\\n```\\nclass Solution {\\n    class Order {\\n        public final int price;\\n        public int amount;\\n        public final int type;\\n        public Order(final int p, final int a, final int t){\\n            price = p;\\n            amount = a;\\n            type = t;\\n        }\\n    }\\n    \\n    public void match(PriorityQueue<Order> buys, PriorityQueue<Order> sells){\\n        while(!buys.isEmpty() && !sells.isEmpty()){\\n            Order buy = buys.peek();\\n            Order sell = sells.peek();\\n            if(sell.price <= buy.price){\\n                int sellAmount = sell.amount;\\n                int buyAmount = buy.amount;\\n                sell.amount -= buyAmount;\\n                buy.amount -= sellAmount;\\n                if(buy.amount <= 0)buys.poll();\\n                if(sell.amount <= 0)sells.poll();\\n            }\\n            else break;\\n        }\\n    }\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sells = new PriorityQueue<>((a, b) -> a.price - b.price);\\n        PriorityQueue<Order> buys = new PriorityQueue<>((a, b) -> b.price - a.price);\\n        final int BUY = 0;\\n        final int SELL = 1;\\n        for(int[] o : orders){\\n            Order order = new Order(o[0], o[1], o[2]);\\n            if(order.type == BUY)buys.add(order);\\n            if(order.type == SELL)sells.add(order);\\n            match(buys, sells);\\n        }\\n        \\n        int totalBacklog = 0;\\n        final int MOD = 1_000_000_000 + 7;\\n        \\n        while(!sells.isEmpty()){\\n            Order o = sells.poll();\\n            totalBacklog = (totalBacklog + o.amount) % MOD;\\n        }\\n        \\n        while(!buys.isEmpty()){\\n            Order o = buys.poll();\\n            totalBacklog = (totalBacklog + o.amount) % MOD;\\n        }\\n        \\n        return totalBacklog;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Order {\\n        public final int price;\\n        public int amount;\\n        public final int type;\\n        public Order(final int p, final int a, final int t){\\n            price = p;\\n            amount = a;\\n            type = t;\\n        }\\n    }\\n    \\n    public void match(PriorityQueue<Order> buys, PriorityQueue<Order> sells){\\n        while(!buys.isEmpty() && !sells.isEmpty()){\\n            Order buy = buys.peek();\\n            Order sell = sells.peek();\\n            if(sell.price <= buy.price){\\n                int sellAmount = sell.amount;\\n                int buyAmount = buy.amount;\\n                sell.amount -= buyAmount;\\n                buy.amount -= sellAmount;\\n                if(buy.amount <= 0)buys.poll();\\n                if(sell.amount <= 0)sells.poll();\\n            }\\n            else break;\\n        }\\n    }\\n    \\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        PriorityQueue<Order> sells = new PriorityQueue<>((a, b) -> a.price - b.price);\\n        PriorityQueue<Order> buys = new PriorityQueue<>((a, b) -> b.price - a.price);\\n        final int BUY = 0;\\n        final int SELL = 1;\\n        for(int[] o : orders){\\n            Order order = new Order(o[0], o[1], o[2]);\\n            if(order.type == BUY)buys.add(order);\\n            if(order.type == SELL)sells.add(order);\\n            match(buys, sells);\\n        }\\n        \\n        int totalBacklog = 0;\\n        final int MOD = 1_000_000_000 + 7;\\n        \\n        while(!sells.isEmpty()){\\n            Order o = sells.poll();\\n            totalBacklog = (totalBacklog + o.amount) % MOD;\\n        }\\n        \\n        while(!buys.isEmpty()){\\n            Order o = buys.poll();\\n            totalBacklog = (totalBacklog + o.amount) % MOD;\\n        }\\n        \\n        return totalBacklog;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319418,
                "title": "c-ordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    using ll=unsigned long long;\\n    void processBuy(map<ll, ll> &m1, map<ll, ll> &m2, vector<int> &o)\\n    {\\n        ll amt=o[1];\\n        auto itr=m2.begin();\\n        while(itr!=m2.end() && amt>0 && (*itr).first<=o[0])\\n        {\\n            if((*itr).second>amt)\\n            {\\n                m2[(*itr).first]=(*itr).second-amt;\\n                amt=0;\\n            }\\n            else if((*itr).second==amt)\\n            {\\n                m2.erase((*itr).first);\\n                amt=0;\\n            }\\n            else\\n            {\\n                amt-=(*itr).second;\\n                int k=(*itr).first;\\n                m2.erase(k);\\n            }\\n            itr++;\\n        }\\n        if(amt>0)\\n        {\\n            m1[o[0]]+=amt;\\n        }\\n    }\\n    void processSell(map<ll, ll> &m1, map<ll, ll> &m2, vector<int> &o)\\n    {\\n        ll amt=o[1];\\n        auto itr=m2.end();\\n        while(itr!=m2.begin() && amt>0)\\n        {\\n            itr--;\\n            if((*itr).first>=o[0])\\n            {\\n                if((*itr).second>amt)\\n                {\\n                    m2[(*itr).first]=(*itr).second-amt;\\n                    amt=0;\\n                }\\n                else if((*itr).second==amt)\\n                {\\n                    m2.erase((*itr).first);\\n                    amt=0;\\n                }\\n                else\\n                {\\n                    amt-=(*itr).second;\\n                    int k=(*itr).first;\\n                    m2.erase(k);\\n                }   \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(amt>0)\\n        {\\n            m1[o[0]]+=amt;\\n        }\\n    }\\n    ll getBackLogs(map<ll, ll> &m)\\n    {\\n        ll ans=0;\\n        for(auto i:m)\\n        {\\n            ans+=i.second;\\n        }\\n        return ans;\\n    }\\n    void printBackLogs(map<ll, ll> &m)\\n    {\\n        for(auto i:m)\\n        {\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n        }\\n    }\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<ll, ll> buy; \\n        map<ll, ll> sell;        \\n        for(int i=0; i<orders.size(); i++)\\n        {\\n            // if(1)\\n            // {\\n            //     cout<<\"buy:\"<<endl;\\n            //     printBackLogs(buy);\\n            //     cout<<\"sell:\"<<endl;\\n            //     printBackLogs(sell);\\n            // }\\n            if(orders[i][2]==0)//buy\\n            {\\n                processBuy(buy, sell, orders[i]);\\n            }\\n            else\\n            {\\n                processSell(sell, buy, orders[i]);\\n            }\\n        }\\n        // cout<<\"buy:\"<<endl;\\n        // printBackLogs(buy);\\n        // cout<<\"sell:\"<<endl;\\n        // printBackLogs(sell);\\n        \\n        ll ans=0;\\n        //iterate map and count values\\n        ans+=getBackLogs(buy)%mod;\\n        ans=(ans+getBackLogs(sell))%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    using ll=unsigned long long;\\n    void processBuy(map<ll, ll> &m1, map<ll, ll> &m2, vector<int> &o)\\n    {\\n        ll amt=o[1];\\n        auto itr=m2.begin();\\n        while(itr!=m2.end() && amt>0 && (*itr).first<=o[0])\\n        {\\n            if((*itr).second>amt)\\n            {\\n                m2[(*itr).first]=(*itr).second-amt;\\n                amt=0;\\n            }\\n            else if((*itr).second==amt)\\n            {\\n                m2.erase((*itr).first);\\n                amt=0;\\n            }\\n            else\\n            {\\n                amt-=(*itr).second;\\n                int k=(*itr).first;\\n                m2.erase(k);\\n            }\\n            itr++;\\n        }\\n        if(amt>0)\\n        {\\n            m1[o[0]]+=amt;\\n        }\\n    }\\n    void processSell(map<ll, ll> &m1, map<ll, ll> &m2, vector<int> &o)\\n    {\\n        ll amt=o[1];\\n        auto itr=m2.end();\\n        while(itr!=m2.begin() && amt>0)\\n        {\\n            itr--;\\n            if((*itr).first>=o[0])\\n            {\\n                if((*itr).second>amt)\\n                {\\n                    m2[(*itr).first]=(*itr).second-amt;\\n                    amt=0;\\n                }\\n                else if((*itr).second==amt)\\n                {\\n                    m2.erase((*itr).first);\\n                    amt=0;\\n                }\\n                else\\n                {\\n                    amt-=(*itr).second;\\n                    int k=(*itr).first;\\n                    m2.erase(k);\\n                }   \\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(amt>0)\\n        {\\n            m1[o[0]]+=amt;\\n        }\\n    }\\n    ll getBackLogs(map<ll, ll> &m)\\n    {\\n        ll ans=0;\\n        for(auto i:m)\\n        {\\n            ans+=i.second;\\n        }\\n        return ans;\\n    }\\n    void printBackLogs(map<ll, ll> &m)\\n    {\\n        for(auto i:m)\\n        {\\n            cout<<i.first<<\" \"<<i.second<<endl;\\n        }\\n    }\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        map<ll, ll> buy; \\n        map<ll, ll> sell;        \\n        for(int i=0; i<orders.size(); i++)\\n        {\\n            // if(1)\\n            // {\\n            //     cout<<\"buy:\"<<endl;\\n            //     printBackLogs(buy);\\n            //     cout<<\"sell:\"<<endl;\\n            //     printBackLogs(sell);\\n            // }\\n            if(orders[i][2]==0)//buy\\n            {\\n                processBuy(buy, sell, orders[i]);\\n            }\\n            else\\n            {\\n                processSell(sell, buy, orders[i]);\\n            }\\n        }\\n        // cout<<\"buy:\"<<endl;\\n        // printBackLogs(buy);\\n        // cout<<\"sell:\"<<endl;\\n        // printBackLogs(sell);\\n        \\n        ll ans=0;\\n        //iterate map and count values\\n        ans+=getBackLogs(buy)%mod;\\n        ans=(ans+getBackLogs(sell))%mod;\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1318524,
                "title": "c-2-heaps-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<vector<long>> buy;\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> sell;\\n        \\n        for(auto v : orders){\\n            long p = v[0];\\n            long a = v[1];\\n            int t = v[2];\\n            \\n            if(t == 0){ //buy\\n                \\n                while(!sell.empty() && p >= sell.top()[0] && a > 0){\\n                    vector<long> t = sell.top();\\n                    sell.pop();\\n                    if(a < t[1]){\\n                        t[1] -= a;\\n                        sell.push(t);\\n                        a = 0;\\n                    }\\n                    else{\\n                        a -= t[1];\\n                    }\\n                }\\n                \\n                if(a > 0){\\n                    buy.push({p,a});\\n                }\\n            }\\n            else{//sell\\n                \\n                while(!buy.empty() && p <= buy.top()[0] && a > 0){\\n                    \\n                    vector<long> t = buy.top();\\n                    buy.pop();\\n                    if(a < t[1]){\\n                        t[1] -= a;\\n                        buy.push(t);\\n                        a = 0;\\n                    }\\n                    else{\\n                        a -= t[1];\\n                    }\\n                }\\n                \\n                if(a > 0){\\n                    sell.push({p,a});\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        int M = 1e9 + 7;\\n        while(!buy.empty()){\\n            ans = ((long)ans + (long)buy.top()[1])%M;\\n            buy.pop();\\n        }\\n        \\n        while(!sell.empty()){\\n            ans = ((long)ans + (long)sell.top()[1])%M;\\n            sell.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue<vector<long>> buy;\\n        priority_queue<vector<long>, vector<vector<long>>, greater<vector<long>>> sell;\\n        \\n        for(auto v : orders){\\n            long p = v[0];\\n            long a = v[1];\\n            int t = v[2];\\n            \\n            if(t == 0){ //buy\\n                \\n                while(!sell.empty() && p >= sell.top()[0] && a > 0){\\n                    vector<long> t = sell.top();\\n                    sell.pop();\\n                    if(a < t[1]){\\n                        t[1] -= a;\\n                        sell.push(t);\\n                        a = 0;\\n                    }\\n                    else{\\n                        a -= t[1];\\n                    }\\n                }\\n                \\n                if(a > 0){\\n                    buy.push({p,a});\\n                }\\n            }\\n            else{//sell\\n                \\n                while(!buy.empty() && p <= buy.top()[0] && a > 0){\\n                    \\n                    vector<long> t = buy.top();\\n                    buy.pop();\\n                    if(a < t[1]){\\n                        t[1] -= a;\\n                        buy.push(t);\\n                        a = 0;\\n                    }\\n                    else{\\n                        a -= t[1];\\n                    }\\n                }\\n                \\n                if(a > 0){\\n                    sell.push({p,a});\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        int M = 1e9 + 7;\\n        while(!buy.empty()){\\n            ans = ((long)ans + (long)buy.top()[1])%M;\\n            buy.pop();\\n        }\\n        \\n        while(!sell.empty()){\\n            ans = ((long)ans + (long)sell.top()[1])%M;\\n            sell.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317714,
                "title": "c-easy-solution-95-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>>buy;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;\\n        long long ans=0;\\n        for(int i=0;i<orders.size();i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                bool ff=false;\\n                while(!sell.empty() && sell.top().first<=orders[i][0])\\n                {\\n                    if(orders[i][1]>sell.top().second)\\n                    {\\n                        orders[i][1]-=sell.top().second;\\n                        sell.pop();\\n                    }\\n                    else\\n                    {\\n                        pair<int,int>p=sell.top();\\n                        p.second-=orders[i][1];\\n                        sell.pop();\\n                        ff=true;\\n                        if(p.second!=0)\\n                        {\\n                            sell.push(p);\\n                        }\\n                        break;\\n                    }\\n                }\\n                if(ff==false && orders[i][1]!=0)\\n                {\\n                    buy.push({orders[i][0],orders[i][1]});\\n                }\\n            }\\n            else\\n            {\\n                bool ff=false;\\n                while(!buy.empty() && buy.top().first>=orders[i][0])\\n                {\\n                    if(orders[i][1]>buy.top().second)\\n                    {\\n                        orders[i][1]-=buy.top().second;\\n                        buy.pop();\\n                    }\\n                    else\\n                    {\\n                        pair<int,int>p=buy.top();\\n                        p.second-=orders[i][1];\\n                        buy.pop();\\n                        ff=true;\\n                        if(p.second!=0)\\n                        {\\n                            buy.push(p);\\n                        }\\n                        break;\\n                    }\\n                }\\n                if(ff==false && orders[i][1]!=0)\\n                {\\n                    sell.push({orders[i][0],orders[i][1]});\\n                }\\n            }\\n        }\\n        while(!sell.empty())\\n        {\\n            ans+=sell.top().second;\\n            sell.pop();\\n        }\\n        while(!buy.empty())\\n        {\\n            ans+=buy.top().second;\\n            buy.pop();\\n        }\\n        long long h = 1e9+7;\\n        return ans%h;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,int>>buy;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;\\n        long long ans=0;\\n        for(int i=0;i<orders.size();i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                bool ff=false;\\n                while(!sell.empty() && sell.top().first<=orders[i][0])\\n                {\\n                    if(orders[i][1]>sell.top().second)\\n                    {\\n                        orders[i][1]-=sell.top().second;\\n                        sell.pop();\\n                    }\\n                    else\\n                    {\\n                        pair<int,int>p=sell.top();\\n                        p.second-=orders[i][1];\\n                        sell.pop();\\n                        ff=true;\\n                        if(p.second!=0)\\n                        {\\n                            sell.push(p);\\n                        }\\n                        break;\\n                    }\\n                }\\n                if(ff==false && orders[i][1]!=0)\\n                {\\n                    buy.push({orders[i][0],orders[i][1]});\\n                }\\n            }\\n            else\\n            {\\n                bool ff=false;\\n                while(!buy.empty() && buy.top().first>=orders[i][0])\\n                {\\n                    if(orders[i][1]>buy.top().second)\\n                    {\\n                        orders[i][1]-=buy.top().second;\\n                        buy.pop();\\n                    }\\n                    else\\n                    {\\n                        pair<int,int>p=buy.top();\\n                        p.second-=orders[i][1];\\n                        buy.pop();\\n                        ff=true;\\n                        if(p.second!=0)\\n                        {\\n                            buy.push(p);\\n                        }\\n                        break;\\n                    }\\n                }\\n                if(ff==false && orders[i][1]!=0)\\n                {\\n                    sell.push({orders[i][0],orders[i][1]});\\n                }\\n            }\\n        }\\n        while(!sell.empty())\\n        {\\n            ans+=sell.top().second;\\n            sell.pop();\\n        }\\n        while(!buy.empty())\\n        {\\n            ans+=buy.top().second;\\n            buy.pop();\\n        }\\n        long long h = 1e9+7;\\n        return ans%h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275912,
                "title": "my-c-simple-solution-priority-queue",
                "content": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>>buy;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>>sell;\\n           \\n        for (auto& order : orders) {\\n            if (order[2] == 0)\\n                buy.push({order[0], order[1]});\\n            else\\n                sell.push({order[0], order[1]});\\n            \\n            while (buy.size() && sell.size() && sell.top().first <= buy.top().first) {\\n                \\n                if(buy.top().second > sell.top().second) {\\n                    auto temp = buy.top();\\n                    buy.pop();\\n                    temp.second = temp.second - sell.top().second;\\n                    buy.push(temp);\\n                    sell.pop();\\n                }\\n                else if(buy.top().second < sell.top().second) {\\n                    auto temp = sell.top();\\n                    sell.pop();\\n                    temp.second = temp.second - buy.top().second;\\n                    sell.push(temp);\\n                    buy.pop();\\n                }\\n                else {\\n                    sell.pop();\\n                    buy.pop();\\n                }\\n            }\\n\\n        }\\n           \\n        unsigned long long int  res = 0, mod = 1e9 + 7;\\n        while (sell.size()) {\\n            res += sell.top().second;\\n            sell.pop();\\n        }\\n           \\n        while (buy.size()){ \\n            res += buy.top().second;\\n            buy.pop();\\n        }\\n           \\n        return res % mod;\\n    }",
                "solutionTags": [],
                "code": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int, int>>buy;\\n        priority_queue<pair<int,int>, vector<pair<int, int>>, greater<pair<int, int>>>sell;\\n           \\n        for (auto& order : orders) {\\n            if (order[2] == 0)\\n                buy.push({order[0], order[1]});\\n            else\\n                sell.push({order[0], order[1]});\\n            \\n            while (buy.size() && sell.size() && sell.top().first <= buy.top().first) {\\n                \\n                if(buy.top().second > sell.top().second) {\\n                    auto temp = buy.top();\\n                    buy.pop();\\n                    temp.second = temp.second - sell.top().second;\\n                    buy.push(temp);\\n                    sell.pop();\\n                }\\n                else if(buy.top().second < sell.top().second) {\\n                    auto temp = sell.top();\\n                    sell.pop();\\n                    temp.second = temp.second - buy.top().second;\\n                    sell.push(temp);\\n                    buy.pop();\\n                }\\n                else {\\n                    sell.pop();\\n                    buy.pop();\\n                }\\n            }\\n\\n        }\\n           \\n        unsigned long long int  res = 0, mod = 1e9 + 7;\\n        while (sell.size()) {\\n            res += sell.top().second;\\n            sell.pop();\\n        }\\n           \\n        while (buy.size()){ \\n            res += buy.top().second;\\n            buy.pop();\\n        }\\n           \\n        return res % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1207275,
                "title": "2-priority-queues-fewer-enqueues-fewer-iteration-java",
                "content": "A little bit optimization\\n\\n```\\nclass Solution {\\n\\n    private static final int MOD = 1_000_000_007;\\n\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        if (orders == null || orders.length == 0) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<int[]> sells = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        PriorityQueue<int[]> buys = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));\\n        long totalOrders = 0;\\n        long deals = 0;\\n        for (int[] order : orders) {\\n            totalOrders += order[1];\\n            PriorityQueue<int[]> trades = order[2] == 0 ? sells : buys;\\n            PriorityQueue<int[]> passes = order[2] == 0 ? buys : sells;\\n            while (order[1] > 0 &&\\n                    !trades.isEmpty() &&\\n                    (order[2] == 0 ?\\n                            (trades.peek()[0] <= order[0]) :\\n                            (trades.peek()[0] >= order[0]))) {\\n                int[] trade = trades.peek();\\n                int deal = Math.min(trade[1], order[1]);\\n                order[1] -= deal;\\n                trade[1] -= deal;\\n                if (trade[1] == 0) {\\n                    trades.poll();\\n                }\\n                deals += deal;\\n            }\\n            if (order[1] > 0) {\\n                passes.offer(order);\\n            }\\n        }\\n\\n        totalOrders -= deals * 2;\\n\\n        return (int) (totalOrders % MOD);\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private static final int MOD = 1_000_000_007;\\n\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        if (orders == null || orders.length == 0) {\\n            return 0;\\n        }\\n\\n        PriorityQueue<int[]> sells = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        PriorityQueue<int[]> buys = new PriorityQueue<>((a, b) -> Integer.compare(b[0], a[0]));\\n        long totalOrders = 0;\\n        long deals = 0;\\n        for (int[] order : orders) {\\n            totalOrders += order[1];\\n            PriorityQueue<int[]> trades = order[2] == 0 ? sells : buys;\\n            PriorityQueue<int[]> passes = order[2] == 0 ? buys : sells;\\n            while (order[1] > 0 &&\\n                    !trades.isEmpty() &&\\n                    (order[2] == 0 ?\\n                            (trades.peek()[0] <= order[0]) :\\n                            (trades.peek()[0] >= order[0]))) {\\n                int[] trade = trades.peek();\\n                int deal = Math.min(trade[1], order[1]);\\n                order[1] -= deal;\\n                trade[1] -= deal;\\n                if (trade[1] == 0) {\\n                    trades.poll();\\n                }\\n                deals += deal;\\n            }\\n            if (order[1] > 0) {\\n                passes.offer(order);\\n            }\\n        }\\n\\n        totalOrders -= deals * 2;\\n\\n        return (int) (totalOrders % MOD);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178396,
                "title": "max-heap-for-buy-and-min-heap-for-sell-simple-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        \\n        priority_queue<vector<int>>buy;\\n        \\n        priority_queue <vector<int>, vector<vector<int>>, greater<vector<int>> > sell;\\n        \\n        \\n        for(int i=0;i<orders.size();i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                if(sell.size()==0)\\n                {\\n                    buy.push(orders[i]);\\n                    continue;\\n                }\\n                while(sell.size()>0&&sell.top()[0]<=orders[i][0]&&orders[i][1]>0)\\n                {\\n                    auto v=sell.top();\\n                    sell.pop();\\n                    int p=v[0];\\n                    int a=v[1];\\n                    if(a>orders[i][1])\\n                    {\\n                        a-=orders[i][1];\\n                        orders[i][1]=0;\\n                        v[1]=a;\\n                        sell.push(v);\\n                    }\\n                    else\\n                    {\\n                        orders[i][1]-=a;\\n                    }\\n                }\\n                if(orders[i][1]>0)\\n                    buy.push(orders[i]);\\n                \\n            }\\n            else\\n            {\\n                if(buy.size()==0)\\n                {\\n                    sell.push(orders[i]);\\n                    continue;\\n                }\\n                while(buy.size()>0&&buy.top()[0]>=orders[i][0]&&orders[i][1]>0)\\n                {\\n                    auto v=buy.top();\\n                    buy.pop();\\n                    int p=v[0];\\n                    int a=v[1];\\n                    if(a>orders[i][1])\\n                    {\\n                        a-=orders[i][1];\\n                        orders[i][1]=0;\\n                        v[1]=a;\\n                        buy.push(v);\\n                    }\\n                    else\\n                    {\\n                        orders[i][1]-=a;\\n                    }\\n                    \\n                }\\n                if(orders[i][1]>0)\\n                    sell.push(orders[i]);\\n            }\\n            \\n        }\\n        int mod=1000000007;\\n        int ans=0;\\n        while(!buy.empty())\\n        {\\n            auto x=buy.top();\\n            buy.pop();\\n            ans+=x[1];\\n            ans%=1000000007;\\n        }\\n        while(!sell.empty())\\n        {\\n            auto x=sell.top();\\n            sell.pop();\\n            ans+=x[1];\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        \\n        priority_queue<vector<int>>buy;\\n        \\n        priority_queue <vector<int>, vector<vector<int>>, greater<vector<int>> > sell;\\n        \\n        \\n        for(int i=0;i<orders.size();i++)\\n        {\\n            if(orders[i][2]==0)\\n            {\\n                if(sell.size()==0)\\n                {\\n                    buy.push(orders[i]);\\n                    continue;\\n                }\\n                while(sell.size()>0&&sell.top()[0]<=orders[i][0]&&orders[i][1]>0)\\n                {\\n                    auto v=sell.top();\\n                    sell.pop();\\n                    int p=v[0];\\n                    int a=v[1];\\n                    if(a>orders[i][1])\\n                    {\\n                        a-=orders[i][1];\\n                        orders[i][1]=0;\\n                        v[1]=a;\\n                        sell.push(v);\\n                    }\\n                    else\\n                    {\\n                        orders[i][1]-=a;\\n                    }\\n                }\\n                if(orders[i][1]>0)\\n                    buy.push(orders[i]);\\n                \\n            }\\n            else\\n            {\\n                if(buy.size()==0)\\n                {\\n                    sell.push(orders[i]);\\n                    continue;\\n                }\\n                while(buy.size()>0&&buy.top()[0]>=orders[i][0]&&orders[i][1]>0)\\n                {\\n                    auto v=buy.top();\\n                    buy.pop();\\n                    int p=v[0];\\n                    int a=v[1];\\n                    if(a>orders[i][1])\\n                    {\\n                        a-=orders[i][1];\\n                        orders[i][1]=0;\\n                        v[1]=a;\\n                        buy.push(v);\\n                    }\\n                    else\\n                    {\\n                        orders[i][1]-=a;\\n                    }\\n                    \\n                }\\n                if(orders[i][1]>0)\\n                    sell.push(orders[i]);\\n            }\\n            \\n        }\\n        int mod=1000000007;\\n        int ans=0;\\n        while(!buy.empty())\\n        {\\n            auto x=buy.top();\\n            buy.pop();\\n            ans+=x[1];\\n            ans%=1000000007;\\n        }\\n        while(!sell.empty())\\n        {\\n            auto x=sell.top();\\n            sell.pop();\\n            ans+=x[1];\\n            ans%=1000000007;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175526,
                "title": "java-heap-o-nlgn-beats-99",
                "content": "```\\nimport java.util.*;\\n\\n\\nclass Order {\\n    int amount;\\n    int price;\\n    Order(int amount, int price) {\\n        this.amount = amount;\\n        this.price = price;\\n    }\\n}\\n    \\n    \\n\\nclass Solution {\\n    int modMe = 1000000007;\\n    PriorityQueue<Order> buyHeap;\\n    PriorityQueue<Order> sellHeap;\\n    int merge(Order order, PriorityQueue<Order> friends, PriorityQueue<Order> enemies) {\\n        int result = 0;\\n        while (enemies.size() > 0 && order.amount > 0) {\\n            Order top = enemies.peek();\\n            if (enemies == sellHeap) { // when buy order vs sellHeap\\n                if (order.price < top.price)\\n                    break;\\n            } else { // when sell order vs buyHeap\\n                if (order.price > top.price)\\n                    break;\\n            }  \\n            \\n            if (order.amount > top.amount) {\\n                result += top.amount * 2;\\n                order.amount -= top.amount;\\n                enemies.poll();\\n            } else {\\n                result += order.amount * 2;\\n                if (order.amount == top.amount)\\n                    enemies.poll();\\n                else\\n                    top.amount -= order.amount;\\n                order.amount = 0;\\n            }\\n        }\\n        \\n        if (order.amount > 0)\\n            friends.offer(order);\\n            \\n        return result;\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int len = orders.length;\\n        buyHeap = new PriorityQueue<Order>(len, new Comparator<Order>() {\\n            public int compare(Order orderA, Order orderB) {\\n                return orderB.price - orderA.price;\\n            }\\n        });\\n        sellHeap = new PriorityQueue<Order>(len, new Comparator<Order>() {\\n            public int compare(Order orderA, Order orderB) {\\n                return orderA.price - orderB.price;\\n            }\\n        });\\n        \\n        \\n        int result = 0;\\n        for (int i = 0; i < len; i++) {\\n            int[] orderArr = orders[i];\\n            int price = orderArr[0], amount = orderArr[1], type = orderArr[2];\\n            Order order = new Order(amount, price);\\n            int cancelOutBy = 0;\\n            if (type == 0) {\\n                cancelOutBy = merge(order, buyHeap, sellHeap);\\n            } else {\\n                cancelOutBy = merge(order, sellHeap, buyHeap);\\n            }\\n            \\n            int outcome = amount - cancelOutBy;\\n            result += outcome;\\n            if (result < 0) result += modMe;\\n            result %= modMe;\\n        }\\n\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\n\\nclass Order {\\n    int amount;\\n    int price;\\n    Order(int amount, int price) {\\n        this.amount = amount;\\n        this.price = price;\\n    }\\n}\\n    \\n    \\n\\nclass Solution {\\n    int modMe = 1000000007;\\n    PriorityQueue<Order> buyHeap;\\n    PriorityQueue<Order> sellHeap;\\n    int merge(Order order, PriorityQueue<Order> friends, PriorityQueue<Order> enemies) {\\n        int result = 0;\\n        while (enemies.size() > 0 && order.amount > 0) {\\n            Order top = enemies.peek();\\n            if (enemies == sellHeap) { // when buy order vs sellHeap\\n                if (order.price < top.price)\\n                    break;\\n            } else { // when sell order vs buyHeap\\n                if (order.price > top.price)\\n                    break;\\n            }  \\n            \\n            if (order.amount > top.amount) {\\n                result += top.amount * 2;\\n                order.amount -= top.amount;\\n                enemies.poll();\\n            } else {\\n                result += order.amount * 2;\\n                if (order.amount == top.amount)\\n                    enemies.poll();\\n                else\\n                    top.amount -= order.amount;\\n                order.amount = 0;\\n            }\\n        }\\n        \\n        if (order.amount > 0)\\n            friends.offer(order);\\n            \\n        return result;\\n    }\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int len = orders.length;\\n        buyHeap = new PriorityQueue<Order>(len, new Comparator<Order>() {\\n            public int compare(Order orderA, Order orderB) {\\n                return orderB.price - orderA.price;\\n            }\\n        });\\n        sellHeap = new PriorityQueue<Order>(len, new Comparator<Order>() {\\n            public int compare(Order orderA, Order orderB) {\\n                return orderA.price - orderB.price;\\n            }\\n        });\\n        \\n        \\n        int result = 0;\\n        for (int i = 0; i < len; i++) {\\n            int[] orderArr = orders[i];\\n            int price = orderArr[0], amount = orderArr[1], type = orderArr[2];\\n            Order order = new Order(amount, price);\\n            int cancelOutBy = 0;\\n            if (type == 0) {\\n                cancelOutBy = merge(order, buyHeap, sellHeap);\\n            } else {\\n                cancelOutBy = merge(order, sellHeap, buyHeap);\\n            }\\n            \\n            int outcome = amount - cancelOutBy;\\n            result += outcome;\\n            if (result < 0) result += modMe;\\n            result %= modMe;\\n        }\\n\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171177,
                "title": "c-using-std-set-beats-85",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        unsigned long long backlogs{0};\\n        set< pair<long long ,long long> ,greater<> > buy_stock;\\n        set<pair<long long ,long long > > sell_stock;\\n        for(auto &i: orders)\\n        {\\n            if(i[2]==0)  //buy order\\n            {\\n                long long temp=i[1];\\n                while(!sell_stock.empty() and sell_stock.begin()->first<=i[0])\\n                {\\n                    if(sell_stock.begin()->second>=i[1])\\n                    {\\n                        auto it=sell_stock.begin();\\n                        backlogs-=i[1];\\n                        long long lmao=it->first;\\n                        long long lol =it->second-i[1];\\n                        sell_stock.erase(it);\\n                        if(lol!=0) sell_stock.insert({lmao,lol});\\n                        i[1]=0;\\n                        break;\\n                        \\n                    }\\n                    else\\n                    {\\n                        backlogs-=sell_stock.begin()->second;\\n                        i[1]-=sell_stock.begin()->second;\\n                        sell_stock.erase(sell_stock.begin());\\n                    }\\n                }\\n                if(i[1]!=0) \\n                {\\n                    backlogs+=i[1];\\n                    buy_stock.insert({i[0],i[1]});\\n                }\\n            }\\n            else    //sell order\\n            {\\n                long long temp=i[1];\\n                while(!buy_stock.empty() and buy_stock.begin()->first>=i[0])\\n                {\\n                    if(buy_stock.begin()->second>=i[1])\\n                    {\\n                        auto it=buy_stock.begin();\\n                        backlogs-=i[1];\\n                        long long lmao=it->first;\\n                        long long lol= it->second-i[1];\\n                        buy_stock.erase(it);\\n                        if(lol!=0) buy_stock.insert({lmao,lol});\\n                        i[1]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        backlogs-=buy_stock.begin()->second;\\n                        i[1]-=buy_stock.begin()->second;\\n                        buy_stock.erase(buy_stock.begin());\\n                    }\\n                }\\n                if(i[1]!=0)\\n                {\\n                    backlogs+=i[1];\\n                    sell_stock.insert({i[0],i[1]});\\n                }\\n            }\\n        }\\n        return backlogs%1000000007;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        unsigned long long backlogs{0};\\n        set< pair<long long ,long long> ,greater<> > buy_stock;\\n        set<pair<long long ,long long > > sell_stock;\\n        for(auto &i: orders)\\n        {\\n            if(i[2]==0)  //buy order\\n            {\\n                long long temp=i[1];\\n                while(!sell_stock.empty() and sell_stock.begin()->first<=i[0])\\n                {\\n                    if(sell_stock.begin()->second>=i[1])\\n                    {\\n                        auto it=sell_stock.begin();\\n                        backlogs-=i[1];\\n                        long long lmao=it->first;\\n                        long long lol =it->second-i[1];\\n                        sell_stock.erase(it);\\n                        if(lol!=0) sell_stock.insert({lmao,lol});\\n                        i[1]=0;\\n                        break;\\n                        \\n                    }\\n                    else\\n                    {\\n                        backlogs-=sell_stock.begin()->second;\\n                        i[1]-=sell_stock.begin()->second;\\n                        sell_stock.erase(sell_stock.begin());\\n                    }\\n                }\\n                if(i[1]!=0) \\n                {\\n                    backlogs+=i[1];\\n                    buy_stock.insert({i[0],i[1]});\\n                }\\n            }\\n            else    //sell order\\n            {\\n                long long temp=i[1];\\n                while(!buy_stock.empty() and buy_stock.begin()->first>=i[0])\\n                {\\n                    if(buy_stock.begin()->second>=i[1])\\n                    {\\n                        auto it=buy_stock.begin();\\n                        backlogs-=i[1];\\n                        long long lmao=it->first;\\n                        long long lol= it->second-i[1];\\n                        buy_stock.erase(it);\\n                        if(lol!=0) buy_stock.insert({lmao,lol});\\n                        i[1]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        backlogs-=buy_stock.begin()->second;\\n                        i[1]-=buy_stock.begin()->second;\\n                        buy_stock.erase(buy_stock.begin());\\n                    }\\n                }\\n                if(i[1]!=0)\\n                {\\n                    backlogs+=i[1];\\n                    sell_stock.insert({i[0],i[1]});\\n                }\\n            }\\n        }\\n        return backlogs%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165887,
                "title": "multiset-solution-in-c",
                "content": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders){\\n\\tconst int mod = 1e9 + 7;\\n\\tmultiset<pair<int,int>,greater<pair<int,int>>> cost;\\n\\tmultiset<pair<int,int>> sell;\\n\\tfor(auto v : orders){\\n\\t\\tif(v[2] == 0){\\n\\t\\t\\tint p = v[0], amt = v[1];\\n\\t\\t\\tauto it = sell.begin();\\n\\t\\t\\twhile(amt != 0 && it != sell.end()){\\n\\t\\t\\t\\tif((*it).first <= p){\\n\\t\\t\\t\\t\\tif(amt >= (*it).second){\\n\\t\\t\\t\\t\\t\\tamt = amt-(*it).second;\\n\\t\\t\\t\\t\\t\\tsell.erase(it);\\n\\t\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint temp1 = (*it).first, temp2 = (*it).second - amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t\\tsell.erase(it);\\n\\t\\t\\t\\t\\t\\tsell.insert(make_pair(temp1,temp2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(amt != 0)\\n\\t\\t\\t\\tcost.insert(make_pair(p,amt));\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tint p = v[0], amt = v[1];\\n\\t\\t\\tauto it = cost.begin();\\n\\t\\t\\twhile(amt != 0 && it != cost.end()){\\n\\t\\t\\t\\tif((*it).first >= p){\\n\\t\\t\\t\\t\\tif(amt >= (*it).second){\\n\\t\\t\\t\\t\\t\\tamt = amt-(*it).second;\\n\\t\\t\\t\\t\\t\\tcost.erase(it);\\n\\t\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint temp1 = (*it).first, temp2 = (*it).second - amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t\\tcost.erase(it);\\n\\t\\t\\t\\t\\t\\tcost.insert(make_pair(temp1,temp2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(amt != 0)\\n\\t\\t\\t\\tsell.insert(make_pair(p,amt));\\n\\t\\t}\\n\\t}\\n\\tlong long cmt = 0;\\n\\tfor(auto i : sell){\\n\\t\\tcmt = (cmt + i.second)%mod;\\n\\t}\\n\\tfor(auto i : cost){\\n\\t\\tcmt = (cmt + i.second)%mod;\\n\\t}\\n\\treturn (int)cmt;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders){\\n\\tconst int mod = 1e9 + 7;\\n\\tmultiset<pair<int,int>,greater<pair<int,int>>> cost;\\n\\tmultiset<pair<int,int>> sell;\\n\\tfor(auto v : orders){\\n\\t\\tif(v[2] == 0){\\n\\t\\t\\tint p = v[0], amt = v[1];\\n\\t\\t\\tauto it = sell.begin();\\n\\t\\t\\twhile(amt != 0 && it != sell.end()){\\n\\t\\t\\t\\tif((*it).first <= p){\\n\\t\\t\\t\\t\\tif(amt >= (*it).second){\\n\\t\\t\\t\\t\\t\\tamt = amt-(*it).second;\\n\\t\\t\\t\\t\\t\\tsell.erase(it);\\n\\t\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint temp1 = (*it).first, temp2 = (*it).second - amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t\\tsell.erase(it);\\n\\t\\t\\t\\t\\t\\tsell.insert(make_pair(temp1,temp2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(amt != 0)\\n\\t\\t\\t\\tcost.insert(make_pair(p,amt));\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tint p = v[0], amt = v[1];\\n\\t\\t\\tauto it = cost.begin();\\n\\t\\t\\twhile(amt != 0 && it != cost.end()){\\n\\t\\t\\t\\tif((*it).first >= p){\\n\\t\\t\\t\\t\\tif(amt >= (*it).second){\\n\\t\\t\\t\\t\\t\\tamt = amt-(*it).second;\\n\\t\\t\\t\\t\\t\\tcost.erase(it);\\n\\t\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tint temp1 = (*it).first, temp2 = (*it).second - amt;\\n\\t\\t\\t\\t\\t\\tamt = 0;\\n\\t\\t\\t\\t\\t\\tcost.erase(it);\\n\\t\\t\\t\\t\\t\\tcost.insert(make_pair(temp1,temp2));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(amt != 0)\\n\\t\\t\\t\\tsell.insert(make_pair(p,amt));\\n\\t\\t}\\n\\t}\\n\\tlong long cmt = 0;\\n\\tfor(auto i : sell){\\n\\t\\tcmt = (cmt + i.second)%mod;\\n\\t}\\n\\tfor(auto i : cost){\\n\\t\\tcmt = (cmt + i.second)%mod;\\n\\t}\\n\\treturn (int)cmt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1145711,
                "title": "c-heap-max-heap-for-buy-min-heap-for-sell",
                "content": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        typedef pair<int, int> Order; // <price, amount>\\n\\n        auto compBuy = [](const Order& o1, const Order& o2) {\\n            return less<int>()(o1.first, o2.first);\\n        };\\n        auto compSell = [](const Order& o1, const Order& o2) {\\n            return greater<int>()(o1.first, o2.first);\\n        };\\n        priority_queue<Order, vector<Order>, decltype(compBuy)> pqBuy(compBuy); // max_heap\\n        priority_queue<Order, vector<Order>, decltype(compSell)> pqSell(compSell); // min_heap\\n\\n        for (vector<int>& o : orders) {\\n            int price = o[0];\\n            int amount = o[1];\\n            if (o[2] == 0) { // buy\\n                while (!pqSell.empty() && pqSell.top().first <= price && 0 < amount) {\\n                    Order order = pqSell.top();\\n                    pqSell.pop();\\n\\n                    int decAmount = min(order.second, amount);\\n                    order.second -= decAmount;\\n                    amount -= decAmount;\\n\\n                    if (0 < order.second) {\\n                        pqSell.push(order);\\n                    }\\n                }\\n                if (0 < amount) {\\n                    pqBuy.emplace(price, amount);\\n                }\\n            }\\n            else { // sell\\n                while (!pqBuy.empty() && price <= pqBuy.top().first && 0 < amount) {\\n                    Order order = pqBuy.top();\\n                    pqBuy.pop();\\n\\n                    int decAmount = min(order.second, amount);\\n                    order.second -= decAmount;\\n                    amount -= decAmount;\\n\\n                    if (0 < order.second) {\\n                        pqBuy.push(order);\\n                    }\\n                }\\n                if (0 < amount) {\\n                    pqSell.emplace(price, amount);\\n                }\\n            }\\n\\n        }\\n\\n        int amount = 0;\\n        for (; !pqBuy.empty(); pqBuy.pop()) {\\n            //amount += pqBuy.top().second;\\n\\n            amount += (pqBuy.top().second % 1000000007);\\n            amount %= (1000000007);\\n        }\\n        for (; !pqSell.empty(); pqSell.pop()) {\\n            //amount += pqSell.top().second ;\\n\\n            amount += (pqSell.top().second % 1000000007);\\n            amount %= (1000000007);\\n        }\\n        return amount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        typedef pair<int, int> Order; // <price, amount>\\n\\n        auto compBuy = [](const Order& o1, const Order& o2) {\\n            return less<int>()(o1.first, o2.first);\\n        };\\n        auto compSell = [](const Order& o1, const Order& o2) {\\n            return greater<int>()(o1.first, o2.first);\\n        };\\n        priority_queue<Order, vector<Order>, decltype(compBuy)> pqBuy(compBuy); // max_heap\\n        priority_queue<Order, vector<Order>, decltype(compSell)> pqSell(compSell); // min_heap\\n\\n        for (vector<int>& o : orders) {\\n            int price = o[0];\\n            int amount = o[1];\\n            if (o[2] == 0) { // buy\\n                while (!pqSell.empty() && pqSell.top().first <= price && 0 < amount) {\\n                    Order order = pqSell.top();\\n                    pqSell.pop();\\n\\n                    int decAmount = min(order.second, amount);\\n                    order.second -= decAmount;\\n                    amount -= decAmount;\\n\\n                    if (0 < order.second) {\\n                        pqSell.push(order);\\n                    }\\n                }\\n                if (0 < amount) {\\n                    pqBuy.emplace(price, amount);\\n                }\\n            }\\n            else { // sell\\n                while (!pqBuy.empty() && price <= pqBuy.top().first && 0 < amount) {\\n                    Order order = pqBuy.top();\\n                    pqBuy.pop();\\n\\n                    int decAmount = min(order.second, amount);\\n                    order.second -= decAmount;\\n                    amount -= decAmount;\\n\\n                    if (0 < order.second) {\\n                        pqBuy.push(order);\\n                    }\\n                }\\n                if (0 < amount) {\\n                    pqSell.emplace(price, amount);\\n                }\\n            }\\n\\n        }\\n\\n        int amount = 0;\\n        for (; !pqBuy.empty(); pqBuy.pop()) {\\n            //amount += pqBuy.top().second;\\n\\n            amount += (pqBuy.top().second % 1000000007);\\n            amount %= (1000000007);\\n        }\\n        for (; !pqSell.empty(); pqSell.pop()) {\\n            //amount += pqSell.top().second ;\\n\\n            amount += (pqSell.top().second % 1000000007);\\n            amount %= (1000000007);\\n        }\\n        return amount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135867,
                "title": "c-solution-use-priority-queue",
                "content": "```\\npriority_queue<pair<int,int>> buy; // price, amount\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > sell;\\n        for(auto o:orders)\\n        {\\n            if(o[2]==1) //sell\\n            {\\n                pair<int,int> p={o[0],o[1]};\\n                if(buy.size()==0)\\n                    sell.push(p);\\n                else\\n                {\\n                    while(buy.size() && p.second>0 && buy.top().first>=p.first)\\n                    {\\n                        if(p.second-buy.top().second<0)\\n                        {\\n                            auto t=buy.top();\\n                            buy.pop();\\n                            t.second-=p.second;\\n                            p.second=0;\\n                            buy.push(t);\\n                            break;\\n                        }\\n                        p.second-=buy.top().second;\\n                        buy.pop();\\n                    }\\n                    if(p.second>0)\\n                        sell.push(p);\\n                }\\n            }\\n            else\\n            {\\n                pair<int,int> p={o[0],o[1]};\\n                if(sell.size()==0)\\n                    buy.push(p);\\n                else\\n                {\\n                    while(sell.size() && p.second>0 && sell.top().first<=p.first)\\n                    {\\n                        if(p.second-sell.top().second<0)\\n                        {\\n                            auto t=sell.top();\\n                            sell.pop();\\n                            t.second-=p.second;\\n                            p.second=0;\\n                            sell.push(t);\\n                            break;\\n                        }\\n                        p.second-=sell.top().second;\\n                        sell.pop();\\n                    }\\n                    if(p.second>0)\\n                        buy.push(p);\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        while(sell.size())\\n        {\\n            ans=((long)ans+(long)sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        cout<<ans<<\" \";\\n        while(buy.size())\\n        {\\n            ans=((long)ans+(long)buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\npriority_queue<pair<int,int>> buy; // price, amount\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > sell;\\n        for(auto o:orders)\\n        {\\n            if(o[2]==1) //sell\\n            {\\n                pair<int,int> p={o[0],o[1]};\\n                if(buy.size()==0)\\n                    sell.push(p);\\n                else\\n                {\\n                    while(buy.size() && p.second>0 && buy.top().first>=p.first)\\n                    {\\n                        if(p.second-buy.top().second<0)\\n                        {\\n                            auto t=buy.top();\\n                            buy.pop();\\n                            t.second-=p.second;\\n                            p.second=0;\\n                            buy.push(t);\\n                            break;\\n                        }\\n                        p.second-=buy.top().second;\\n                        buy.pop();\\n                    }\\n                    if(p.second>0)\\n                        sell.push(p);\\n                }\\n            }\\n            else\\n            {\\n                pair<int,int> p={o[0],o[1]};\\n                if(sell.size()==0)\\n                    buy.push(p);\\n                else\\n                {\\n                    while(sell.size() && p.second>0 && sell.top().first<=p.first)\\n                    {\\n                        if(p.second-sell.top().second<0)\\n                        {\\n                            auto t=sell.top();\\n                            sell.pop();\\n                            t.second-=p.second;\\n                            p.second=0;\\n                            sell.push(t);\\n                            break;\\n                        }\\n                        p.second-=sell.top().second;\\n                        sell.pop();\\n                    }\\n                    if(p.second>0)\\n                        buy.push(p);\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        while(sell.size())\\n        {\\n            ans=((long)ans+(long)sell.top().second)%1000000007;\\n            sell.pop();\\n        }\\n        cout<<ans<<\" \";\\n        while(buy.size())\\n        {\\n            ans=((long)ans+(long)buy.top().second)%1000000007;\\n            buy.pop();\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1132278,
                "title": "clean-java-solution",
                "content": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer,Integer> buy = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> sell = new TreeMap<>();\\n        for(int[] order: orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            if(orderType == 0) {\\n                while(sell.size() != 0 && sell.firstKey() <= price && amount > 0) amount = findMatch(sell, amount, price);\\n                pushToBacklog(buy, price, amount);\\n            } else {\\n                while(buy.size() != 0 && buy.firstKey() >= price && amount > 0) amount = findMatch(buy, amount, price);\\n                pushToBacklog(sell, price, amount);\\n            }\\n        }\\n        \\n        return computeAmounts(buy, sell);\\n    }\\n    \\n    int findMatch(TreeMap<Integer,Integer> map, int amount, int price) {\\n        int backlogPrice = map.firstKey();\\n        int backlogAmount = map.get(backlogPrice);\\n        if(backlogAmount > amount) {\\n            map.put(backlogPrice, backlogAmount - amount);\\n            amount = 0;\\n        } else {\\n            map.remove(backlogPrice);\\n            amount -= backlogAmount;\\n        }\\n        return amount;\\n    }\\n    \\n    void pushToBacklog(TreeMap<Integer,Integer> map, int price, int amount) {\\n        if(amount > 0)\\n            map.put(price, map.getOrDefault(price, 0) + amount);\\n    }\\n    \\n    int computeAmounts(TreeMap<Integer, Integer> buy, TreeMap<Integer, Integer> sell) {\\n        int sum = 0;\\n        for(int amount: buy.values()) {\\n            sum = (sum + amount) % 1000000007;\\n        }\\n        for(int amount: sell.values()) {\\n            sum = (sum + amount) % 1000000007;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer,Integer> buy = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> sell = new TreeMap<>();\\n        for(int[] order: orders) {\\n            int price = order[0];\\n            int amount = order[1];\\n            int orderType = order[2];\\n            if(orderType == 0) {\\n                while(sell.size() != 0 && sell.firstKey() <= price && amount > 0) amount = findMatch(sell, amount, price);\\n                pushToBacklog(buy, price, amount);\\n            } else {\\n                while(buy.size() != 0 && buy.firstKey() >= price && amount > 0) amount = findMatch(buy, amount, price);\\n                pushToBacklog(sell, price, amount);\\n            }\\n        }\\n        \\n        return computeAmounts(buy, sell);\\n    }\\n    \\n    int findMatch(TreeMap<Integer,Integer> map, int amount, int price) {\\n        int backlogPrice = map.firstKey();\\n        int backlogAmount = map.get(backlogPrice);\\n        if(backlogAmount > amount) {\\n            map.put(backlogPrice, backlogAmount - amount);\\n            amount = 0;\\n        } else {\\n            map.remove(backlogPrice);\\n            amount -= backlogAmount;\\n        }\\n        return amount;\\n    }\\n    \\n    void pushToBacklog(TreeMap<Integer,Integer> map, int price, int amount) {\\n        if(amount > 0)\\n            map.put(price, map.getOrDefault(price, 0) + amount);\\n    }\\n    \\n    int computeAmounts(TreeMap<Integer, Integer> buy, TreeMap<Integer, Integer> sell) {\\n        int sum = 0;\\n        for(int amount: buy.values()) {\\n            sum = (sum + amount) % 1000000007;\\n        }\\n        for(int amount: sell.values()) {\\n            sum = (sum + amount) % 1000000007;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130808,
                "title": "java-solution-two-treemap",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer,Integer> buy_backlog = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer,Integer> sell_backlog = new TreeMap<>();\\n        for(int[] order:orders){\\n            if(order[2] == 0){\\n                boolean flag = true;\\n                while(flag){\\n                if(!sell_backlog.isEmpty() && sell_backlog.firstKey()<=order[0]){\\n                    int lowest_price = sell_backlog.firstKey();\\n                    int shares_at_lowest_price = sell_backlog.getOrDefault(lowest_price,0);\\n                    if(order[1]==shares_at_lowest_price){\\n                        sell_backlog.remove(lowest_price);\\n                        flag = false;\\n                    }\\n                    else if(order[1]<shares_at_lowest_price){\\n                        sell_backlog.put(lowest_price,shares_at_lowest_price-order[1]);\\n                        flag = false;\\n                    }\\n                    else{\\n                        sell_backlog.remove(lowest_price);\\n                        order[1] = order[1]-shares_at_lowest_price;\\n                    }\\n                }\\n                else{\\n                    buy_backlog.put(order[0],buy_backlog.getOrDefault(order[0],0)+order[1]);\\n                    flag = false;\\n                }\\n                }\\n            }\\n            else{\\n                boolean flag = true;\\n                while(flag){\\n                if(!buy_backlog.isEmpty() && buy_backlog.firstKey()>=order[0]){\\n                    int high_price = buy_backlog.firstKey();\\n                    int shares_at_high_price = buy_backlog.getOrDefault(high_price,0);\\n                    if(order[1]==shares_at_high_price){\\n                        buy_backlog.remove(high_price);\\n                        flag = false;\\n                    }\\n                    else if(order[1]<shares_at_high_price){\\n                        buy_backlog.put(high_price,shares_at_high_price-order[1]);\\n                        flag = false;\\n                    }\\n                    else{\\n                        buy_backlog.remove(high_price);\\n                        order[1] = order[1]-shares_at_high_price;\\n                    }\\n                }\\n                else{\\n                    sell_backlog.put(order[0],sell_backlog.getOrDefault(order[0],0)+order[1]);\\n                    flag = false;\\n                }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int value:buy_backlog.values()){\\n            ans = (ans+value)%mod;\\n        }\\n        for(int value:sell_backlog.values()){\\n            ans = (ans+value)%mod;\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        TreeMap<Integer,Integer> buy_backlog = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer,Integer> sell_backlog = new TreeMap<>();\\n        for(int[] order:orders){\\n            if(order[2] == 0){\\n                boolean flag = true;\\n                while(flag){\\n                if(!sell_backlog.isEmpty() && sell_backlog.firstKey()<=order[0]){\\n                    int lowest_price = sell_backlog.firstKey();\\n                    int shares_at_lowest_price = sell_backlog.getOrDefault(lowest_price,0);\\n                    if(order[1]==shares_at_lowest_price){\\n                        sell_backlog.remove(lowest_price);\\n                        flag = false;\\n                    }\\n                    else if(order[1]<shares_at_lowest_price){\\n                        sell_backlog.put(lowest_price,shares_at_lowest_price-order[1]);\\n                        flag = false;\\n                    }\\n                    else{\\n                        sell_backlog.remove(lowest_price);\\n                        order[1] = order[1]-shares_at_lowest_price;\\n                    }\\n                }\\n                else{\\n                    buy_backlog.put(order[0],buy_backlog.getOrDefault(order[0],0)+order[1]);\\n                    flag = false;\\n                }\\n                }\\n            }\\n            else{\\n                boolean flag = true;\\n                while(flag){\\n                if(!buy_backlog.isEmpty() && buy_backlog.firstKey()>=order[0]){\\n                    int high_price = buy_backlog.firstKey();\\n                    int shares_at_high_price = buy_backlog.getOrDefault(high_price,0);\\n                    if(order[1]==shares_at_high_price){\\n                        buy_backlog.remove(high_price);\\n                        flag = false;\\n                    }\\n                    else if(order[1]<shares_at_high_price){\\n                        buy_backlog.put(high_price,shares_at_high_price-order[1]);\\n                        flag = false;\\n                    }\\n                    else{\\n                        buy_backlog.remove(high_price);\\n                        order[1] = order[1]-shares_at_high_price;\\n                    }\\n                }\\n                else{\\n                    sell_backlog.put(order[0],sell_backlog.getOrDefault(order[0],0)+order[1]);\\n                    flag = false;\\n                }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int value:buy_backlog.values()){\\n            ans = (ans+value)%mod;\\n        }\\n        for(int value:sell_backlog.values()){\\n            ans = (ans+value)%mod;\\n        }\\n        return ans%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128830,
                "title": "c-in-two-heaps-but-i-dont-like-this-question",
                "content": "```\\nclass Solution {\\npublic:\\n\\n#define pa std::pair<int, int>\\n#define mp std::make_pair\\n#define ll long long\\nint getNumberOfBacklogOrders(vector<vector<int>> &orders)\\n{\\n    auto cmpmin = [](pa &a, pa &b) -> bool { return a.first > b.first; };\\n    auto cmpmax = [](pa &a, pa &b) -> bool { return a.first < b.first; };\\n    std::priority_queue<pa, vector<pa>, decltype(cmpmin)> sq(cmpmin);\\n    std::priority_queue<pa, vector<pa>, decltype(cmpmax)> bq(cmpmax);\\n    ll ss = 0, bs = 0;\\n    ll mod = std::pow(10, 9) + 7;\\n    for (auto &o : orders)\\n    {\\n        auto size = o[1], price = o[0], type = o[2];\\n        if (type == 0)\\n        {\\n            if (sq.size() == 0 || (sq.size() > 0 && sq.top().first > price))\\n            {\\n                bq.push(mp(price, size));\\n                bs += (ll)size;\\n            }\\n            else\\n            {\\n                while (sq.size() > 0 && sq.top().first <= price)\\n                {\\n                    pa curr = sq.top();\\n                    sq.pop();\\n                   \\n                    if (curr.second <= size)\\n                    {\\n                        size -= curr.second;\\n                        ss -= curr.second;\\n                    }\\n                    else\\n                    {\\n                        ss -= size;\\n                        sq.push(mp(curr.first, curr.second - size));\\n                        size = 0; \\n                        break;\\n                    }\\n                }\\n                if (size > 0)\\n                {\\n                    bq.push(mp(price, size));\\n                    bs += size;\\n                }\\n            }\\n        }\\n        else\\n        {\\n\\n            if (bq.size() == 0 || (bq.size() > 0 && bq.top().first < price))\\n            {\\n                sq.push(mp(price, size));\\n                ss += (ll)size;\\n            }\\n            else\\n            {\\n                while (bq.size() > 0 && bq.top().first >= price)\\n                {\\n                    pa curr = bq.top();\\n                    bq.pop();\\n                    \\n                    if (curr.second <= size)\\n                    {\\n                        size -= curr.second;\\n                        bs -= curr.second;\\n                    }\\n                    else\\n                    {\\n                        bs -= size;\\n                        bq.push(mp(curr.first, curr.second - size));\\n                        size = 0; \\n                           break;\\n                    }\\n                }\\n                if (size > 0)\\n                {\\n                    sq.push(mp(price, size));\\n                    ss += size;\\n                }\\n            }\\n        }\\n    \\n    }\\n    return (int)((ss + bs) % mod);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n#define pa std::pair<int, int>\\n#define mp std::make_pair\\n#define ll long long\\nint getNumberOfBacklogOrders(vector<vector<int>> &orders)\\n{\\n    auto cmpmin = [](pa &a, pa &b) -> bool { return a.first > b.first; };\\n    auto cmpmax = [](pa &a, pa &b) -> bool { return a.first < b.first; };\\n    std::priority_queue<pa, vector<pa>, decltype(cmpmin)> sq(cmpmin);\\n    std::priority_queue<pa, vector<pa>, decltype(cmpmax)> bq(cmpmax);\\n    ll ss = 0, bs = 0;\\n    ll mod = std::pow(10, 9) + 7;\\n    for (auto &o : orders)\\n    {\\n        auto size = o[1], price = o[0], type = o[2];\\n        if (type == 0)\\n        {\\n            if (sq.size() == 0 || (sq.size() > 0 && sq.top().first > price))\\n            {\\n                bq.push(mp(price, size));\\n                bs += (ll)size;\\n            }\\n            else\\n            {\\n                while (sq.size() > 0 && sq.top().first <= price)\\n                {\\n                    pa curr = sq.top();\\n                    sq.pop();\\n                   \\n                    if (curr.second <= size)\\n                    {\\n                        size -= curr.second;\\n                        ss -= curr.second;\\n                    }\\n                    else\\n                    {\\n                        ss -= size;\\n                        sq.push(mp(curr.first, curr.second - size));\\n                        size = 0; \\n                        break;\\n                    }\\n                }\\n                if (size > 0)\\n                {\\n                    bq.push(mp(price, size));\\n                    bs += size;\\n                }\\n            }\\n        }\\n        else\\n        {\\n\\n            if (bq.size() == 0 || (bq.size() > 0 && bq.top().first < price))\\n            {\\n                sq.push(mp(price, size));\\n                ss += (ll)size;\\n            }\\n            else\\n            {\\n                while (bq.size() > 0 && bq.top().first >= price)\\n                {\\n                    pa curr = bq.top();\\n                    bq.pop();\\n                    \\n                    if (curr.second <= size)\\n                    {\\n                        size -= curr.second;\\n                        bs -= curr.second;\\n                    }\\n                    else\\n                    {\\n                        bs -= size;\\n                        bq.push(mp(curr.first, curr.second - size));\\n                        size = 0; \\n                           break;\\n                    }\\n                }\\n                if (size > 0)\\n                {\\n                    sq.push(mp(price, size));\\n                    ss += size;\\n                }\\n            }\\n        }\\n    \\n    }\\n    return (int)((ss + bs) % mod);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128553,
                "title": "easy-c-heap",
                "content": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        //Compute sizes alongside push pop to avoid iterating queue later\\n\\t\\tlong buySize=0,sellSize=0; \\n        priority_queue<pair<int,int>> buy; //Max heap\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;//Min heap\\n        \\n        for(auto order:orders){\\n            if(order[2]==0){//Buying\\n                long amount=order[1];\\n                while(!sell.empty() && sell.top().first<=order[0] && amount){\\n                    long x = sell.top().second;\\n                    if(x>amount){\\n                        amount = x-amount;\\n                        int price = sell.top().first;\\n                        sell.pop();\\n                        sellSize-=x;\\n                        sell.push({price,amount});\\n                        sellSize+=amount;\\n                        amount=0;\\n                    }\\n                    else{\\n                        amount-=x;\\n                        sell.pop();\\n                        sellSize-=x;\\n                    }\\n                }\\n                if(amount>0){\\n                    buy.push({order[0],amount});\\n                    buySize+=amount;\\n                }\\n            }\\n            else{\\n\\t\\t\\t\\t//Selling\\n                long amount=order[1];\\n                while(!buy.empty() && buy.top().first>=order[0] && amount){\\n                    long x = buy.top().second;\\n                    if(x>amount){\\n                        amount = x-amount;\\n                        int price = buy.top().first;\\n                        buy.pop();\\n                        buySize-=x;\\n                        buy.push({price,amount});\\n                        buySize+=amount;\\n                        amount=0;\\n                    }\\n                    else{\\n                        amount-=x;\\n                        buy.pop();\\n                        buySize-=x;\\n                    }\\n                }\\n                if(amount>0){\\n                    sell.push({order[0],amount});\\n                    sellSize+=amount;\\n                }   \\n            }\\n        }\\n        return (buySize%1000000007+sellSize%1000000007)%1000000007;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        //Compute sizes alongside push pop to avoid iterating queue later\\n\\t\\tlong buySize=0,sellSize=0; \\n        priority_queue<pair<int,int>> buy; //Max heap\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>sell;//Min heap\\n        \\n        for(auto order:orders){\\n            if(order[2]==0){//Buying\\n                long amount=order[1];\\n                while(!sell.empty() && sell.top().first<=order[0] && amount){\\n                    long x = sell.top().second;\\n                    if(x>amount){\\n                        amount = x-amount;\\n                        int price = sell.top().first;\\n                        sell.pop();\\n                        sellSize-=x;\\n                        sell.push({price,amount});\\n                        sellSize+=amount;\\n                        amount=0;\\n                    }\\n                    else{\\n                        amount-=x;\\n                        sell.pop();\\n                        sellSize-=x;\\n                    }\\n                }\\n                if(amount>0){\\n                    buy.push({order[0],amount});\\n                    buySize+=amount;\\n                }\\n            }\\n            else{\\n\\t\\t\\t\\t//Selling\\n                long amount=order[1];\\n                while(!buy.empty() && buy.top().first>=order[0] && amount){\\n                    long x = buy.top().second;\\n                    if(x>amount){\\n                        amount = x-amount;\\n                        int price = buy.top().first;\\n                        buy.pop();\\n                        buySize-=x;\\n                        buy.push({price,amount});\\n                        buySize+=amount;\\n                        amount=0;\\n                    }\\n                    else{\\n                        amount-=x;\\n                        buy.pop();\\n                        buySize-=x;\\n                    }\\n                }\\n                if(amount>0){\\n                    sell.push({order[0],amount});\\n                    sellSize+=amount;\\n                }   \\n            }\\n        }\\n        return (buySize%1000000007+sellSize%1000000007)%1000000007;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127481,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\ntypealias Order = (Int, Int)\\nclass Solution {\\n    func getNumberOfBacklogOrders(_ orders: [[Int]]) -> Int {\\n        var buyHeap = Heap<Order>(sort: { $0.0 > $1.0 }), sellHeap = Heap<Order>(sort: { $0.0 < $1.0 })\\n        for item in orders {\\n            var order = (item[0], item[1])\\n            while order.1 > 0 { // amount > 0\\n                var amount = 0\\n                switch item[2] {\\n                case 0: // buy\\n                    if !sellHeap.isEmpty {\\n                        var minSellOrder = sellHeap.remove()!\\n                        if minSellOrder.0 <= order.0 {\\n                            amount = min(order.1, minSellOrder.1)\\n                            minSellOrder.1 -= amount\\n                        }\\n                        if minSellOrder.1 > 0 {\\n                            sellHeap.insert(minSellOrder)\\n                        }\\n                    }\\n                default: // sell\\n                    if !buyHeap.isEmpty {\\n                        var maxBuyOrder = buyHeap.remove()!\\n                        if maxBuyOrder.0 >= order.0 {\\n                            amount = min(order.1, maxBuyOrder.1)\\n                            maxBuyOrder.1 -= amount\\n                        }\\n                        if maxBuyOrder.1 > 0 {\\n                            buyHeap.insert(maxBuyOrder)\\n                        }\\n                    }\\n                }\\n                if amount > 0 {\\n                    order.1 -= amount\\n                } else {\\n                    break // while order\\n                }\\n            }\\n            if order.1 > 0 { // amount is still > 0\\n                switch item[2] {\\n                case 0: buyHeap.insert(order)\\n                default: sellHeap.insert(order)\\n                }\\n            }\\n        }\\n        return (sellHeap.nodes.reduce(into: Int(0), { $0 += $1.1 }) + buyHeap.nodes.reduce(into: Int(0), { $0 += $1.1 })) % 1_000_000_007\\n    }\\n}\\n\\n//  https://github.com/raywenderlich/swift-algorithm-club/blob/master/Heap/Heap.swift\\n//  Written for the Swift Algorithm Club by Kevin Randrup and Matthijs Hollemans\\n\\npublic struct Heap<T> {\\n  \\n  var nodes = [T]()\\n  \\n  private var orderCriteria: (T, T) -> Bool\\n  \\n  public init(sort: @escaping (T, T) -> Bool) { self.orderCriteria = sort }\\n  \\n  public init(array: [T], sort: @escaping (T, T) -> Bool) {\\n    self.orderCriteria = sort\\n    configureHeap(from: array)\\n  }\\n  \\n  private mutating func configureHeap(from array: [T]) {\\n    nodes = array\\n    for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n      shiftDown(i)\\n    }\\n  }\\n  \\n  public var isEmpty: Bool { return nodes.isEmpty }\\n  \\n  public var count: Int { return nodes.count }\\n  \\n  @inline(__always) internal func parentIndex(ofIndex i: Int) -> Int { return (i - 1) / 2 }\\n  @inline(__always) internal func leftChildIndex(ofIndex i: Int) -> Int { return 2 * i + 1 }\\n  @inline(__always) internal func rightChildIndex(ofIndex i: Int) -> Int { return 2 * i + 2 }\\n  \\n  public func peek() -> T? { return nodes.first }\\n  \\n  public mutating func insert(_ value: T) {\\n    nodes.append(value)\\n    shiftUp(nodes.count - 1)\\n  }\\n  \\n  public mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n    for value in sequence {\\n      insert(value)\\n    }\\n  }\\n  \\n  public mutating func replace(index i: Int, value: T) {\\n    guard i < nodes.count else { return }\\n    remove(at: i)\\n    insert(value)\\n  }\\n  \\n  @discardableResult public mutating func remove() -> T? {\\n    guard !nodes.isEmpty else { return nil }\\n    if nodes.count == 1 {\\n      return nodes.removeLast()\\n    } else {\\n      let value = nodes[0]\\n      nodes[0] = nodes.removeLast()\\n      shiftDown(0)\\n      return value\\n    }\\n  }\\n  \\n  @discardableResult public mutating func remove(at index: Int) -> T? {\\n    guard index < nodes.count else { return nil }\\n    let size = nodes.count - 1\\n    if index != size {\\n      nodes.swapAt(index, size)\\n      shiftDown(from: index, until: size)\\n      shiftUp(index)\\n    }\\n    return nodes.removeLast()\\n  }\\n  \\n  internal mutating func shiftUp(_ index: Int) {\\n    var childIndex = index\\n    let child = nodes[childIndex]\\n    var parentIndex = self.parentIndex(ofIndex: childIndex)\\n    while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n      nodes[childIndex] = nodes[parentIndex]\\n      childIndex = parentIndex\\n      parentIndex = self.parentIndex(ofIndex: childIndex)\\n    }\\n    nodes[childIndex] = child\\n  }\\n  \\n  internal mutating func shiftDown(from index: Int, until endIndex: Int) {\\n    let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n    let rightChildIndex = leftChildIndex + 1\\n    var first = index\\n    if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n      first = leftChildIndex\\n    }\\n    if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n      first = rightChildIndex\\n    }\\n    if first == index { return }\\n    nodes.swapAt(index, first)\\n    shiftDown(from: first, until: endIndex)\\n  }\\n  \\n  internal mutating func shiftDown(_ index: Int) { shiftDown(from: index, until: nodes.count) }\\n  \\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\ntypealias Order = (Int, Int)\\nclass Solution {\\n    func getNumberOfBacklogOrders(_ orders: [[Int]]) -> Int {\\n        var buyHeap = Heap<Order>(sort: { $0.0 > $1.0 }), sellHeap = Heap<Order>(sort: { $0.0 < $1.0 })\\n        for item in orders {\\n            var order = (item[0], item[1])\\n            while order.1 > 0 { // amount > 0\\n                var amount = 0\\n                switch item[2] {\\n                case 0: // buy\\n                    if !sellHeap.isEmpty {\\n                        var minSellOrder = sellHeap.remove()!\\n                        if minSellOrder.0 <= order.0 {\\n                            amount = min(order.1, minSellOrder.1)\\n                            minSellOrder.1 -= amount\\n                        }\\n                        if minSellOrder.1 > 0 {\\n                            sellHeap.insert(minSellOrder)\\n                        }\\n                    }\\n                default: // sell\\n                    if !buyHeap.isEmpty {\\n                        var maxBuyOrder = buyHeap.remove()!\\n                        if maxBuyOrder.0 >= order.0 {\\n                            amount = min(order.1, maxBuyOrder.1)\\n                            maxBuyOrder.1 -= amount\\n                        }\\n                        if maxBuyOrder.1 > 0 {\\n                            buyHeap.insert(maxBuyOrder)\\n                        }\\n                    }\\n                }\\n                if amount > 0 {\\n                    order.1 -= amount\\n                } else {\\n                    break // while order\\n                }\\n            }\\n            if order.1 > 0 { // amount is still > 0\\n                switch item[2] {\\n                case 0: buyHeap.insert(order)\\n                default: sellHeap.insert(order)\\n                }\\n            }\\n        }\\n        return (sellHeap.nodes.reduce(into: Int(0), { $0 += $1.1 }) + buyHeap.nodes.reduce(into: Int(0), { $0 += $1.1 })) % 1_000_000_007\\n    }\\n}\\n\\n//  https://github.com/raywenderlich/swift-algorithm-club/blob/master/Heap/Heap.swift\\n//  Written for the Swift Algorithm Club by Kevin Randrup and Matthijs Hollemans\\n\\npublic struct Heap<T> {\\n  \\n  var nodes = [T]()\\n  \\n  private var orderCriteria: (T, T) -> Bool\\n  \\n  public init(sort: @escaping (T, T) -> Bool) { self.orderCriteria = sort }\\n  \\n  public init(array: [T], sort: @escaping (T, T) -> Bool) {\\n    self.orderCriteria = sort\\n    configureHeap(from: array)\\n  }\\n  \\n  private mutating func configureHeap(from array: [T]) {\\n    nodes = array\\n    for i in stride(from: (nodes.count/2-1), through: 0, by: -1) {\\n      shiftDown(i)\\n    }\\n  }\\n  \\n  public var isEmpty: Bool { return nodes.isEmpty }\\n  \\n  public var count: Int { return nodes.count }\\n  \\n  @inline(__always) internal func parentIndex(ofIndex i: Int) -> Int { return (i - 1) / 2 }\\n  @inline(__always) internal func leftChildIndex(ofIndex i: Int) -> Int { return 2 * i + 1 }\\n  @inline(__always) internal func rightChildIndex(ofIndex i: Int) -> Int { return 2 * i + 2 }\\n  \\n  public func peek() -> T? { return nodes.first }\\n  \\n  public mutating func insert(_ value: T) {\\n    nodes.append(value)\\n    shiftUp(nodes.count - 1)\\n  }\\n  \\n  public mutating func insert<S: Sequence>(_ sequence: S) where S.Iterator.Element == T {\\n    for value in sequence {\\n      insert(value)\\n    }\\n  }\\n  \\n  public mutating func replace(index i: Int, value: T) {\\n    guard i < nodes.count else { return }\\n    remove(at: i)\\n    insert(value)\\n  }\\n  \\n  @discardableResult public mutating func remove() -> T? {\\n    guard !nodes.isEmpty else { return nil }\\n    if nodes.count == 1 {\\n      return nodes.removeLast()\\n    } else {\\n      let value = nodes[0]\\n      nodes[0] = nodes.removeLast()\\n      shiftDown(0)\\n      return value\\n    }\\n  }\\n  \\n  @discardableResult public mutating func remove(at index: Int) -> T? {\\n    guard index < nodes.count else { return nil }\\n    let size = nodes.count - 1\\n    if index != size {\\n      nodes.swapAt(index, size)\\n      shiftDown(from: index, until: size)\\n      shiftUp(index)\\n    }\\n    return nodes.removeLast()\\n  }\\n  \\n  internal mutating func shiftUp(_ index: Int) {\\n    var childIndex = index\\n    let child = nodes[childIndex]\\n    var parentIndex = self.parentIndex(ofIndex: childIndex)\\n    while childIndex > 0 && orderCriteria(child, nodes[parentIndex]) {\\n      nodes[childIndex] = nodes[parentIndex]\\n      childIndex = parentIndex\\n      parentIndex = self.parentIndex(ofIndex: childIndex)\\n    }\\n    nodes[childIndex] = child\\n  }\\n  \\n  internal mutating func shiftDown(from index: Int, until endIndex: Int) {\\n    let leftChildIndex = self.leftChildIndex(ofIndex: index)\\n    let rightChildIndex = leftChildIndex + 1\\n    var first = index\\n    if leftChildIndex < endIndex && orderCriteria(nodes[leftChildIndex], nodes[first]) {\\n      first = leftChildIndex\\n    }\\n    if rightChildIndex < endIndex && orderCriteria(nodes[rightChildIndex], nodes[first]) {\\n      first = rightChildIndex\\n    }\\n    if first == index { return }\\n    nodes.swapAt(index, first)\\n    shiftDown(from: first, until: endIndex)\\n  }\\n  \\n  internal mutating func shiftDown(_ index: Int) { shiftDown(from: index, until: nodes.count) }\\n  \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125948,
                "title": "python-easy-to-understand-with-comments-heaps",
                "content": "A simple implmentation using Heaps (creds to ye15 for a guideline)\\n\\n```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n    buy_heap, sell_heap = [], [] #max heap for buy order, min heap for sell orders\\n    \\n    for p, a, t in orders:\\n        #sell order\\n        if t:\\n            #while the quantity of the sell order is not satisfied and there is a match\\n            while a and buy_heap and -buy_heap[0][0] >= p:\\n                #quantity of the best buy order avialable\\n                buy_amount = buy_heap[0][1]\\n                #if there is enough buy_amount, we can execute this sell order and exit the loop\\n                if buy_amount > a:\\n                    #assign new amount after sell order\\n                    buy_heap[0][1] -= a\\n                    a = 0\\n                #there is not enough of the best buy order to execute the sell order\\n                else:\\n                    #remove the current buy order (alredy used) and work with the next best buy order\\n                    heapq.heappop(buy_heap)\\n                    #update the remaining sell order\\n                    a -= buy_amount\\n            #if the sell order is not fulfilled, add it to the sell backlog (sell heap)\\n            if a > 0:\\n                heapq.heappush(sell_heap, [p, a])\\n        #buy order    \\n        else:\\n            #same idea for buy order\\n            while a and sell_heap and sell_heap[0][0] <= p:\\n                sell_amount = sell_heap[0][1]\\n                if(sell_amount > a):\\n                    sell_heap[0][1] -= a\\n                    a = 0\\n                else:\\n                    heapq.heappop(sell_heap)\\n                    a-=sell_amount\\n            if(a > 0):\\n                heapq.heappush(buy_heap, [-p, a])\\n    \\n    #return the remaining orders in the backlog\\n    return sum(a for _, a in buy_heap+sell_heap) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n    buy_heap, sell_heap = [], [] #max heap for buy order, min heap for sell orders\\n    \\n    for p, a, t in orders:\\n        #sell order\\n        if t:\\n            #while the quantity of the sell order is not satisfied and there is a match\\n            while a and buy_heap and -buy_heap[0][0] >= p:\\n                #quantity of the best buy order avialable\\n                buy_amount = buy_heap[0][1]\\n                #if there is enough buy_amount, we can execute this sell order and exit the loop\\n                if buy_amount > a:\\n                    #assign new amount after sell order\\n                    buy_heap[0][1] -= a\\n                    a = 0\\n                #there is not enough of the best buy order to execute the sell order\\n                else:\\n                    #remove the current buy order (alredy used) and work with the next best buy order\\n                    heapq.heappop(buy_heap)\\n                    #update the remaining sell order\\n                    a -= buy_amount\\n            #if the sell order is not fulfilled, add it to the sell backlog (sell heap)\\n            if a > 0:\\n                heapq.heappush(sell_heap, [p, a])\\n        #buy order    \\n        else:\\n            #same idea for buy order\\n            while a and sell_heap and sell_heap[0][0] <= p:\\n                sell_amount = sell_heap[0][1]\\n                if(sell_amount > a):\\n                    sell_heap[0][1] -= a\\n                    a = 0\\n                else:\\n                    heapq.heappop(sell_heap)\\n                    a-=sell_amount\\n            if(a > 0):\\n                heapq.heappush(buy_heap, [-p, a])\\n    \\n    #return the remaining orders in the backlog\\n    return sum(a for _, a in buy_heap+sell_heap) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1123466,
                "title": "c-using-heaps-of-pair",
                "content": "**Time Complexity = O(NlogN)**\\n\\n**Space Complexity = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct myComp { \\n    constexpr bool operator()( \\n        pair<int, int> const& a, \\n        pair<int, int> const& b) \\n        const noexcept \\n    { \\n        return a.first > b.first; \\n    } \\n}; \\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue< pair<int,int> > buy_log;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>>, myComp > sell_log;\\n       \\n        for(int i=0;i<orders.size();i++){\\n            int price = orders[i][0];\\n            int amount = orders[i][1];\\n            int type = orders[i][2];\\n            /*  If Type=0 ( Buy ) then we have to check sell log\\n\\t\\t\\t              find lowest price  in the heap\\n \\t\\t\\t*/\\n            if(type==0){\\n                while(!sell_log.empty() && amount >0 && sell_log.top().first<=price){\\n                    pair<int,int> temp = sell_log.top();\\n                    sell_log.pop();\\n                    if(temp.second > amount){\\n                        temp.second = temp.second - amount;\\n                        amount=0;\\n                        sell_log.push(make_pair(temp.first,temp.second));\\n                    }else{\\n                        amount = amount - temp.second;\\n                    }   \\n                }\\n                if(amount>0){\\n                    buy_log.push(make_pair(price,amount));\\n                }\\n                \\n            }\\n\\t\\t\\t/*  If Type=1 ( Sell ) then we have to check Buy log\\n\\t\\t\\t              find Highest price  \\n \\t\\t\\t*/\\n\\t\\t\\telse if(type==1){\\n                \\n                while(!buy_log.empty() && amount>0 && buy_log.top().first >= price){\\n                    pair<int,int> temp = buy_log.top();\\n                    buy_log.pop();\\n                    \\n                    if(temp.second > amount){\\n                        temp.second = temp.second - amount;\\n                        amount = 0;\\n                        buy_log.push(make_pair(temp.first,temp.second));\\n                        \\n                    }else{\\n                        amount = amount - temp.second;\\n                    }\\n                }\\n                \\n                \\n                if(amount>0){\\n                    sell_log.push(make_pair(price,amount));\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans=0;\\n        int mod = 1e9 + 7;\\n        pair<int,int> temp;\\n        while(!buy_log.empty()){\\n            temp = buy_log.top();\\n            buy_log.pop();\\n            ans = (ans % mod + temp.second % mod)%mod;\\n        }\\n        while(!sell_log.empty()){\\n            temp = sell_log.top();\\n            sell_log.pop();\\n            ans = (ans % mod + temp.second % mod )%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct myComp { \\n    constexpr bool operator()( \\n        pair<int, int> const& a, \\n        pair<int, int> const& b) \\n        const noexcept \\n    { \\n        return a.first > b.first; \\n    } \\n}; \\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        \\n        priority_queue< pair<int,int> > buy_log;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>>, myComp > sell_log;\\n       \\n        for(int i=0;i<orders.size();i++){\\n            int price = orders[i][0];\\n            int amount = orders[i][1];\\n            int type = orders[i][2];\\n            /*  If Type=0 ( Buy ) then we have to check sell log\\n\\t\\t\\t              find lowest price  in the heap\\n \\t\\t\\t*/\\n            if(type==0){\\n                while(!sell_log.empty() && amount >0 && sell_log.top().first<=price){\\n                    pair<int,int> temp = sell_log.top();\\n                    sell_log.pop();\\n                    if(temp.second > amount){\\n                        temp.second = temp.second - amount;\\n                        amount=0;\\n                        sell_log.push(make_pair(temp.first,temp.second));\\n                    }else{\\n                        amount = amount - temp.second;\\n                    }   \\n                }\\n                if(amount>0){\\n                    buy_log.push(make_pair(price,amount));\\n                }\\n                \\n            }\\n\\t\\t\\t/*  If Type=1 ( Sell ) then we have to check Buy log\\n\\t\\t\\t              find Highest price  \\n \\t\\t\\t*/\\n\\t\\t\\telse if(type==1){\\n                \\n                while(!buy_log.empty() && amount>0 && buy_log.top().first >= price){\\n                    pair<int,int> temp = buy_log.top();\\n                    buy_log.pop();\\n                    \\n                    if(temp.second > amount){\\n                        temp.second = temp.second - amount;\\n                        amount = 0;\\n                        buy_log.push(make_pair(temp.first,temp.second));\\n                        \\n                    }else{\\n                        amount = amount - temp.second;\\n                    }\\n                }\\n                \\n                \\n                if(amount>0){\\n                    sell_log.push(make_pair(price,amount));\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans=0;\\n        int mod = 1e9 + 7;\\n        pair<int,int> temp;\\n        while(!buy_log.empty()){\\n            temp = buy_log.top();\\n            buy_log.pop();\\n            ans = (ans % mod + temp.second % mod)%mod;\\n        }\\n        while(!sell_log.empty()){\\n            temp = sell_log.top();\\n            sell_log.pop();\\n            ans = (ans % mod + temp.second % mod )%mod;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121808,
                "title": "24-69-test-cases-passing-help-needed",
                "content": "My code is passing 24/69 test cases can anyone help me in finding the error in my code will be very thankful !!\\n```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,long int>> buy;    // creating pair<price,no. of units>\\n        priority_queue<pair<int,long int>,vector<pair<int,long int>>,greater<pair<int,long int>>> sell;\\n         for(int i=0;i<orders.size();i++){\\n              if(orders[i][2]==0){\\n                  if(sell.empty() || sell.top().first>orders[i][0]){\\n                      buy.push(make_pair(orders[i][0],orders[i][1]));\\n                  }\\n                  else{\\n                      long int freqineed=orders[i][1];\\n                      while(!sell.empty() && sell.top().first<=orders[i][0] && freqineed>0){\\n                          if(sell.top().second>=orders[i][1]){\\n                             long int cf=sell.top().second;\\n                            long   int cp=sell.top().first;\\n                              cf=cf-orders[i][1];\\n                              sell.pop();\\n                              sell.push(make_pair(cp,cf));\\n                              freqineed=0;\\n                          }\\n                          else{\\n                              freqineed-=sell.top().second;\\n                              sell.pop();\\n                          }\\n                      }\\n                  }\\n              }\\n             else{\\n                 if(buy.empty() || buy.top().first<orders[i][0]){\\n                      sell.push(make_pair(orders[i][0],orders[i][1]));\\n                  }\\n                  else{\\n                      long int freqineed=orders[i][1];\\n                      while(!buy.empty() && buy.top().first>=orders[i][0] && freqineed>0){\\n                          if(buy.top().second>=orders[i][1]){\\n                              long int cf=buy.top().second;\\n                              long int cp=buy.top().first;\\n                              cf=cf-orders[i][1];\\n                              buy.pop();\\n                              buy.push(make_pair(cp,cf));\\n                              freqineed=0;\\n                          }\\n                          else{\\n                              freqineed-=buy.top().second;\\n                              buy.pop();\\n                          }\\n                      }\\n                  }\\n             }\\n         }\\n        long int ans=0;\\n        while(!sell.empty()){\\n            ans+=sell.top().second;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            ans+=buy.top().second;\\n            buy.pop();\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const unsigned int M = 1000000007;\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        priority_queue<pair<int,long int>> buy;    // creating pair<price,no. of units>\\n        priority_queue<pair<int,long int>,vector<pair<int,long int>>,greater<pair<int,long int>>> sell;\\n         for(int i=0;i<orders.size();i++){\\n              if(orders[i][2]==0){\\n                  if(sell.empty() || sell.top().first>orders[i][0]){\\n                      buy.push(make_pair(orders[i][0],orders[i][1]));\\n                  }\\n                  else{\\n                      long int freqineed=orders[i][1];\\n                      while(!sell.empty() && sell.top().first<=orders[i][0] && freqineed>0){\\n                          if(sell.top().second>=orders[i][1]){\\n                             long int cf=sell.top().second;\\n                            long   int cp=sell.top().first;\\n                              cf=cf-orders[i][1];\\n                              sell.pop();\\n                              sell.push(make_pair(cp,cf));\\n                              freqineed=0;\\n                          }\\n                          else{\\n                              freqineed-=sell.top().second;\\n                              sell.pop();\\n                          }\\n                      }\\n                  }\\n              }\\n             else{\\n                 if(buy.empty() || buy.top().first<orders[i][0]){\\n                      sell.push(make_pair(orders[i][0],orders[i][1]));\\n                  }\\n                  else{\\n                      long int freqineed=orders[i][1];\\n                      while(!buy.empty() && buy.top().first>=orders[i][0] && freqineed>0){\\n                          if(buy.top().second>=orders[i][1]){\\n                              long int cf=buy.top().second;\\n                              long int cp=buy.top().first;\\n                              cf=cf-orders[i][1];\\n                              buy.pop();\\n                              buy.push(make_pair(cp,cf));\\n                              freqineed=0;\\n                          }\\n                          else{\\n                              freqineed-=buy.top().second;\\n                              buy.pop();\\n                          }\\n                      }\\n                  }\\n             }\\n         }\\n        long int ans=0;\\n        while(!sell.empty()){\\n            ans+=sell.top().second;\\n            sell.pop();\\n        }\\n        while(!buy.empty()){\\n            ans+=buy.top().second;\\n            buy.pop();\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121741,
                "title": "java-two-treemap-increase-decrease-order-54ms-javascript-version-340ms",
                "content": "```\\nclass Solution {\\n    private final long MOD = 1000000007L;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tTreeMap<Integer, Integer> sell = new TreeMap<>();\\n\\t\\tTreeMap<Integer, Integer> buy = new TreeMap<>(Collections.reverseOrder());\\n\\t\\tfor (int[] e : orders) {\\n\\t\\t\\tint price = e[0];\\n\\t\\t\\tint amount = e[1];\\n\\t\\t\\tint type = e[2];\\n\\t\\t\\tif (type == 0) {\\n\\t\\t\\t\\twhile (amount > 0 && !sell.isEmpty()) {\\n\\t\\t\\t\\t\\tint k = sell.firstKey();\\n\\t\\t\\t\\t\\tint v = sell.firstEntry().getValue();\\n\\t\\t\\t\\t\\tif (k <= price) {\\n\\t\\t\\t\\t\\t\\tint take = Math.min(v, amount);\\n\\t\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\t\\tv -= take;\\n\\t\\t\\t\\t\\t\\tsell.put(k, v);\\n\\t\\t\\t\\t\\t\\tif (v == 0)\\n\\t\\t\\t\\t\\t\\t\\tsell.remove(k);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tbuy.put(price, buy.getOrDefault(price, 0) + amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (amount > 0 && !buy.isEmpty()) {\\n\\t\\t\\t\\t\\tint k = buy.firstKey();\\n\\t\\t\\t\\t\\tint v = buy.firstEntry().getValue();\\n\\t\\t\\t\\t\\tif (k >= price) {\\n\\t\\t\\t\\t\\t\\tint take = Math.min(v, amount);\\n\\t\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\t\\tv -= take;\\n\\t\\t\\t\\t\\t\\tbuy.put(k, v);\\n\\t\\t\\t\\t\\t\\tif (v == 0)\\n\\t\\t\\t\\t\\t\\t\\tbuy.remove(k);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tsell.put(price, sell.getOrDefault(price, 0) + amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong res = 0L;\\n\\t\\tfor (long v : buy.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\tfor (long v : sell.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\treturn (int) (res % MOD);\\n\\t}\\n}\\n```\\nimprove: 48ms. Let buy map still be increasing, access the max from the end with lastKey()/lastEntry()\\n```\\nclass Solution {\\n    private final long MOD = 1000000007L;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tTreeMap<Integer, Integer> sell = new TreeMap<>();\\n\\t\\tTreeMap<Integer, Integer> buy = new TreeMap<>();  // difference\\n\\t\\tfor (int[] e : orders) {\\n\\t\\t\\tint price = e[0];\\n\\t\\t\\tint amount = e[1];\\n\\t\\t\\tint type = e[2];\\n\\t\\t\\tif (type == 0) {\\n\\t\\t\\t\\twhile (amount > 0 && sell.size() > 0) {\\n\\t\\t\\t\\t\\tint k = sell.firstKey();\\n\\t\\t\\t\\t\\tif (k > price)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tint v = sell.firstEntry().getValue();\\n\\t\\t\\t\\t\\tint take = Math.min(amount, v);\\n\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\tsell.put(k, v - take);\\n\\t\\t\\t\\t\\tif (v - take == 0)\\n\\t\\t\\t\\t\\t\\tsell.remove(k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tbuy.put(price, buy.getOrDefault(price, 0) + amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (amount > 0 && buy.size() > 0) {\\n\\t\\t\\t\\t\\tint k = buy.lastKey();  // difference\\n\\t\\t\\t\\t\\tif (k < price)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tint v = buy.lastEntry().getValue();  // difference\\n\\t\\t\\t\\t\\tint take = Math.min(amount, v);\\n\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\tbuy.put(k, v - take);\\n\\t\\t\\t\\t\\tif (v - take == 0)\\n\\t\\t\\t\\t\\t\\tbuy.remove(k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tsell.put(price, sell.getOrDefault(price, 0) + amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong res = 0L;\\n\\t\\tfor (long v : buy.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\tfor (long v : sell.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\treturn (int) (res % MOD);\\n\\t}\\n}\\n```\\njavascript version: 340ms\\nreference: https://github.com/awstuff/TreeMap.js\\n```\\nfunction TreeMap() {\\n    let root = null;\\n    let keyType = void 0;\\n    let length = 0;\\n    return {\\n        forEach: forEach,\\n        set: set,\\n        get: get,\\n        getTree: getTree,\\n        size: size,\\n        maxKey: maxKey,\\n        minKey: minKey,\\n        remove: remove\\n    };\\n\\n    function checkKey(key, checkKeyType) {\\n        let localKeyType = typeof key;\\n        if (localKeyType !== \"number\" && localKeyType !== \"string\" && localKeyType !== \"boolean\") throw new Error(\"\\'key\\' must be a number, a string or a boolean\");\\n        if (checkKeyType === true && localKeyType !== keyType) throw new Error(\"All keys must be of the same type\");\\n        return localKeyType;\\n    }\\n\\n    function call(callback) {\\n        let args = Array.prototype.slice.call(arguments, 1);\\n        if (typeof callback === \"function\") callback.apply(void 0, args);\\n    }\\n\\n    function getTree() {\\n        return root;\\n    }\\n\\n    function size() {\\n        return length;\\n    }\\n\\n    function forEach(callback) {\\n        internalEach(root, callback);\\n    }\\n\\n    function internalEach(node, callback, internalCallback) {\\n        if (node === null) return call(internalCallback);\\n        internalEach(node.left, callback, () => {\\n            call(callback, node.value, node.key);\\n            internalEach(node.right, callback, () => {\\n                call(internalCallback);\\n            })\\n        });\\n    }\\n\\n    function get(key) {\\n        checkKey(key);\\n        return internalGet(key, root);\\n    }\\n\\n    function internalGet(key, node) {\\n        if (node === null) return void 0;\\n        if (key < node.key) {\\n            return internalGet(key, node.left);\\n        } else if (key > node.key) {\\n            return internalGet(key, node.right);\\n        } else {\\n            return node.value;\\n        }\\n    }\\n\\n    function set(key, value) {\\n        root == null ? keyType = checkKey(key) : checkKey(key, true);\\n        root = internalSet(key, value, root);\\n    }\\n\\n    function internalSet(key, value, node) {\\n        if (node === null) {\\n            length++;\\n            return { key: key, value: value, left: null, right: null };\\n        }\\n        if (key < node.key) {\\n            node.left = internalSet(key, value, node.left);\\n        } else if (key > node.key) {\\n            node.right = internalSet(key, value, node.right);\\n        } else {\\n            node.value = value;\\n        }\\n        return node;\\n    }\\n\\n    function maxKey() {\\n        let maxNode = getMaxNode(root);\\n        if (maxNode !== null) return maxNode.key;\\n        return maxNode;\\n    }\\n\\n    function minKey() {\\n        let minNode = getMinNode(root);\\n        if (minNode !== null) return minNode.key;\\n        return minNode;\\n    }\\n\\n    function getMaxNode(node) {\\n        while (node !== null && node.right !== null) node = node.right;\\n        return node;\\n    }\\n\\n    function getMinNode(node) {\\n        while (node !== null && node.left !== null) node = node.left;\\n        return node;\\n    }\\n\\n    function remove(key) {\\n        checkKey(key);\\n        root = internalRemove(key, root);\\n    }\\n\\n    function internalRemove(key, node) {\\n        if (node === null) return null;\\n        if (key < node.key) {\\n            node.left = internalRemove(key, node.left);\\n        } else if (key > node.key) {\\n            node.right = internalRemove(key, node.right);\\n        } else {\\n            if (node.left !== null && node.right !== null) {\\n                let maxNode = getMaxNode(node.left);\\n                let maxNodeKey = maxNode.key;\\n                let maxNodeValue = maxNode.value;\\n                maxNode.key = node.key;\\n                maxNode.value = node.value;\\n                node.key = maxNodeKey;\\n                node.value = maxNodeValue;\\n                node.left = internalRemove(key, node.left);\\n            } else if (node.left !== null) {\\n                length--;\\n                return node.left;\\n            } else if (node.right !== null) {\\n                length--;\\n                return node.right;\\n            } else {\\n                length--;\\n                return null;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nconst MOD = 1e9 + 7;\\nconst mi = Math.min;\\nconst getNumberOfBacklogOrders = (orders) => {\\n    let sell = new TreeMap();\\n    let buy = new TreeMap();\\n    for (const e of orders) {\\n        let price = e[0];\\n        let amount = e[1];\\n        let type = e[2];\\n        if (type == 0) {\\n            while (amount > 0 && sell.size() > 0) {\\n                let k = sell.minKey();\\n                let v = sell.get(k);\\n                if (k <= price) {\\n                    let take = mi(v, amount);\\n                    amount -= take;\\n                    v -= take;\\n                    sell.set(k, v);\\n                    if (v == 0) sell.remove(k);\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (amount > 0) buy.set(price, buy.get(price) + amount || amount);\\n        } else {\\n            while (amount > 0 && buy.size() > 0) {\\n                let k = buy.maxKey();\\n                let v = buy.get(k);\\n                if (k >= price) {\\n                    let take = mi(v, amount);\\n                    amount -= take;\\n                    v -= take;\\n                    buy.set(k, v);\\n                    if (v == 0) buy.remove(k);\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (amount > 0) sell.set(price, sell.get(price) + amount || amount);\\n        }\\n    }\\n    let res = 0;\\n    buy.forEach((v, k) => res += v);\\n    sell.forEach((v, k) => res += v);\\n    return res % MOD;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    private final long MOD = 1000000007L;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tTreeMap<Integer, Integer> sell = new TreeMap<>();\\n\\t\\tTreeMap<Integer, Integer> buy = new TreeMap<>(Collections.reverseOrder());\\n\\t\\tfor (int[] e : orders) {\\n\\t\\t\\tint price = e[0];\\n\\t\\t\\tint amount = e[1];\\n\\t\\t\\tint type = e[2];\\n\\t\\t\\tif (type == 0) {\\n\\t\\t\\t\\twhile (amount > 0 && !sell.isEmpty()) {\\n\\t\\t\\t\\t\\tint k = sell.firstKey();\\n\\t\\t\\t\\t\\tint v = sell.firstEntry().getValue();\\n\\t\\t\\t\\t\\tif (k <= price) {\\n\\t\\t\\t\\t\\t\\tint take = Math.min(v, amount);\\n\\t\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\t\\tv -= take;\\n\\t\\t\\t\\t\\t\\tsell.put(k, v);\\n\\t\\t\\t\\t\\t\\tif (v == 0)\\n\\t\\t\\t\\t\\t\\t\\tsell.remove(k);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tbuy.put(price, buy.getOrDefault(price, 0) + amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (amount > 0 && !buy.isEmpty()) {\\n\\t\\t\\t\\t\\tint k = buy.firstKey();\\n\\t\\t\\t\\t\\tint v = buy.firstEntry().getValue();\\n\\t\\t\\t\\t\\tif (k >= price) {\\n\\t\\t\\t\\t\\t\\tint take = Math.min(v, amount);\\n\\t\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\t\\tv -= take;\\n\\t\\t\\t\\t\\t\\tbuy.put(k, v);\\n\\t\\t\\t\\t\\t\\tif (v == 0)\\n\\t\\t\\t\\t\\t\\t\\tbuy.remove(k);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tsell.put(price, sell.getOrDefault(price, 0) + amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong res = 0L;\\n\\t\\tfor (long v : buy.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\tfor (long v : sell.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\treturn (int) (res % MOD);\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    private final long MOD = 1000000007L;\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n\\t\\tTreeMap<Integer, Integer> sell = new TreeMap<>();\\n\\t\\tTreeMap<Integer, Integer> buy = new TreeMap<>();  // difference\\n\\t\\tfor (int[] e : orders) {\\n\\t\\t\\tint price = e[0];\\n\\t\\t\\tint amount = e[1];\\n\\t\\t\\tint type = e[2];\\n\\t\\t\\tif (type == 0) {\\n\\t\\t\\t\\twhile (amount > 0 && sell.size() > 0) {\\n\\t\\t\\t\\t\\tint k = sell.firstKey();\\n\\t\\t\\t\\t\\tif (k > price)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tint v = sell.firstEntry().getValue();\\n\\t\\t\\t\\t\\tint take = Math.min(amount, v);\\n\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\tsell.put(k, v - take);\\n\\t\\t\\t\\t\\tif (v - take == 0)\\n\\t\\t\\t\\t\\t\\tsell.remove(k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tbuy.put(price, buy.getOrDefault(price, 0) + amount);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile (amount > 0 && buy.size() > 0) {\\n\\t\\t\\t\\t\\tint k = buy.lastKey();  // difference\\n\\t\\t\\t\\t\\tif (k < price)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tint v = buy.lastEntry().getValue();  // difference\\n\\t\\t\\t\\t\\tint take = Math.min(amount, v);\\n\\t\\t\\t\\t\\tamount -= take;\\n\\t\\t\\t\\t\\tbuy.put(k, v - take);\\n\\t\\t\\t\\t\\tif (v - take == 0)\\n\\t\\t\\t\\t\\t\\tbuy.remove(k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (amount > 0)\\n\\t\\t\\t\\t\\tsell.put(price, sell.getOrDefault(price, 0) + amount);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlong res = 0L;\\n\\t\\tfor (long v : buy.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\tfor (long v : sell.values()) {\\n\\t\\t\\tres += v;\\n\\t\\t}\\n\\t\\treturn (int) (res % MOD);\\n\\t}\\n}\\n```\n```\\nfunction TreeMap() {\\n    let root = null;\\n    let keyType = void 0;\\n    let length = 0;\\n    return {\\n        forEach: forEach,\\n        set: set,\\n        get: get,\\n        getTree: getTree,\\n        size: size,\\n        maxKey: maxKey,\\n        minKey: minKey,\\n        remove: remove\\n    };\\n\\n    function checkKey(key, checkKeyType) {\\n        let localKeyType = typeof key;\\n        if (localKeyType !== \"number\" && localKeyType !== \"string\" && localKeyType !== \"boolean\") throw new Error(\"\\'key\\' must be a number, a string or a boolean\");\\n        if (checkKeyType === true && localKeyType !== keyType) throw new Error(\"All keys must be of the same type\");\\n        return localKeyType;\\n    }\\n\\n    function call(callback) {\\n        let args = Array.prototype.slice.call(arguments, 1);\\n        if (typeof callback === \"function\") callback.apply(void 0, args);\\n    }\\n\\n    function getTree() {\\n        return root;\\n    }\\n\\n    function size() {\\n        return length;\\n    }\\n\\n    function forEach(callback) {\\n        internalEach(root, callback);\\n    }\\n\\n    function internalEach(node, callback, internalCallback) {\\n        if (node === null) return call(internalCallback);\\n        internalEach(node.left, callback, () => {\\n            call(callback, node.value, node.key);\\n            internalEach(node.right, callback, () => {\\n                call(internalCallback);\\n            })\\n        });\\n    }\\n\\n    function get(key) {\\n        checkKey(key);\\n        return internalGet(key, root);\\n    }\\n\\n    function internalGet(key, node) {\\n        if (node === null) return void 0;\\n        if (key < node.key) {\\n            return internalGet(key, node.left);\\n        } else if (key > node.key) {\\n            return internalGet(key, node.right);\\n        } else {\\n            return node.value;\\n        }\\n    }\\n\\n    function set(key, value) {\\n        root == null ? keyType = checkKey(key) : checkKey(key, true);\\n        root = internalSet(key, value, root);\\n    }\\n\\n    function internalSet(key, value, node) {\\n        if (node === null) {\\n            length++;\\n            return { key: key, value: value, left: null, right: null };\\n        }\\n        if (key < node.key) {\\n            node.left = internalSet(key, value, node.left);\\n        } else if (key > node.key) {\\n            node.right = internalSet(key, value, node.right);\\n        } else {\\n            node.value = value;\\n        }\\n        return node;\\n    }\\n\\n    function maxKey() {\\n        let maxNode = getMaxNode(root);\\n        if (maxNode !== null) return maxNode.key;\\n        return maxNode;\\n    }\\n\\n    function minKey() {\\n        let minNode = getMinNode(root);\\n        if (minNode !== null) return minNode.key;\\n        return minNode;\\n    }\\n\\n    function getMaxNode(node) {\\n        while (node !== null && node.right !== null) node = node.right;\\n        return node;\\n    }\\n\\n    function getMinNode(node) {\\n        while (node !== null && node.left !== null) node = node.left;\\n        return node;\\n    }\\n\\n    function remove(key) {\\n        checkKey(key);\\n        root = internalRemove(key, root);\\n    }\\n\\n    function internalRemove(key, node) {\\n        if (node === null) return null;\\n        if (key < node.key) {\\n            node.left = internalRemove(key, node.left);\\n        } else if (key > node.key) {\\n            node.right = internalRemove(key, node.right);\\n        } else {\\n            if (node.left !== null && node.right !== null) {\\n                let maxNode = getMaxNode(node.left);\\n                let maxNodeKey = maxNode.key;\\n                let maxNodeValue = maxNode.value;\\n                maxNode.key = node.key;\\n                maxNode.value = node.value;\\n                node.key = maxNodeKey;\\n                node.value = maxNodeValue;\\n                node.left = internalRemove(key, node.left);\\n            } else if (node.left !== null) {\\n                length--;\\n                return node.left;\\n            } else if (node.right !== null) {\\n                length--;\\n                return node.right;\\n            } else {\\n                length--;\\n                return null;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nconst MOD = 1e9 + 7;\\nconst mi = Math.min;\\nconst getNumberOfBacklogOrders = (orders) => {\\n    let sell = new TreeMap();\\n    let buy = new TreeMap();\\n    for (const e of orders) {\\n        let price = e[0];\\n        let amount = e[1];\\n        let type = e[2];\\n        if (type == 0) {\\n            while (amount > 0 && sell.size() > 0) {\\n                let k = sell.minKey();\\n                let v = sell.get(k);\\n                if (k <= price) {\\n                    let take = mi(v, amount);\\n                    amount -= take;\\n                    v -= take;\\n                    sell.set(k, v);\\n                    if (v == 0) sell.remove(k);\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (amount > 0) buy.set(price, buy.get(price) + amount || amount);\\n        } else {\\n            while (amount > 0 && buy.size() > 0) {\\n                let k = buy.maxKey();\\n                let v = buy.get(k);\\n                if (k >= price) {\\n                    let take = mi(v, amount);\\n                    amount -= take;\\n                    v -= take;\\n                    buy.set(k, v);\\n                    if (v == 0) buy.remove(k);\\n                } else {\\n                    break;\\n                }\\n            }\\n            if (amount > 0) sell.set(price, sell.get(price) + amount || amount);\\n        }\\n    }\\n    let res = 0;\\n    buy.forEach((v, k) => res += v);\\n    sell.forEach((v, k) => res += v);\\n    return res % MOD;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121703,
                "title": "java-solution-treemap-priorityqueue-betas-100",
                "content": "### PriorityQueue\\n\\n```java\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        final int MOD = 1000000007;\\n        Comparator<Pair<Integer, Integer>> sortPairByKeyInAscend = Comparator.comparing(Pair::getKey);\\n        PriorityQueue<Pair<Integer, Integer>> sell = new PriorityQueue<>(sortPairByKeyInAscend);\\n        PriorityQueue<Pair<Integer, Integer>> buy = new PriorityQueue<>(sortPairByKeyInAscend.reversed());\\n        for (int[] order : orders) {\\n            if (order[2] == 0) {\\n                int buyPrice = order[0];\\n                int buyCount = order[1];\\n                while (!sell.isEmpty() && buyCount > 0) {\\n                    Pair<Integer, Integer> smallestSell = sell.peek();\\n                    if (smallestSell.getKey() <= buyPrice) {\\n                        sell.poll();\\n                        int countDiff = buyCount - smallestSell.getValue();\\n                        if (countDiff < 0) {\\n                            sell.add(new Pair<>(smallestSell.getKey(), -1 * countDiff));\\n                        }\\n                        buyCount = countDiff;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (buyCount > 0) {\\n                    buy.add(new Pair<>(buyPrice, buyCount));\\n                }\\n            } else {\\n               int sellPrice = order[0];\\n               int sellCount = order[1];\\n               while (!buy.isEmpty() && sellCount > 0) {\\n                   Pair<Integer, Integer> biggestBuy = buy.peek();\\n                   if (biggestBuy.getKey() >= sellPrice) {\\n                       buy.poll();\\n                       int countDiff = sellCount - biggestBuy.getValue();\\n                       if (countDiff < 0) {\\n                           buy.add(new Pair<>(biggestBuy.getKey(), -1 * countDiff));\\n                       }\\n                       sellCount = countDiff;\\n                   } else {\\n                       break;\\n                   }\\n               }\\n               if (sellCount > 0) {\\n                   sell.add(new Pair<>(sellPrice, sellCount));\\n               }\\n            }\\n        }\\n        long res = 0;\\n        while(!sell.isEmpty() || !buy.isEmpty()) {\\n            if (!sell.isEmpty()) {\\n                res += sell.poll().getValue();\\n            }\\n            if (!buy.isEmpty()) {\\n                res += buy.poll().getValue();\\n            }\\n        }\\n        return (int)(res % MOD);\\n    }\\n}\\n```\\n\\n### TreeMap\\n```java\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        final int MOD = 1000000007;\\n        TreeMap<Integer, Integer> buyPriceMap = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> sellPriceMap = new TreeMap<>();\\n        for (int i = 0; i < orders.length; i++) {\\n            int[] curOrder = orders[i];\\n            if (curOrder[2] == 0) {\\n                int buyPrice = curOrder[0];\\n                int buyCount = curOrder[1];        \\n                Iterator<Entry<Integer, Integer>> it = sellPriceMap.entrySet().iterator();\\n                while(it.hasNext() && buyCount > 0) {\\n                    Entry<Integer, Integer> itEntry = it.next();\\n                    int sellPrice = itEntry.getKey();\\n                    int sellCount = itEntry.getValue();\\n                    if (sellPrice <= buyPrice) {\\n                        buyCount -= sellCount;\\n                        if (buyCount >= 0) {\\n                            it.remove();\\n                        } else {\\n                            itEntry.setValue(-1 * buyCount);\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (buyCount > 0) {\\n                    int originalCount = buyPriceMap.getOrDefault(buyPrice, 0);\\n                    buyPriceMap.put(buyPrice, buyCount+originalCount);\\n                }\\n\\n            } else {\\n                int sellPrice = curOrder[0];\\n                int sellCount = curOrder[1];        \\n                Iterator<Entry<Integer, Integer>> it = buyPriceMap.entrySet().iterator();\\n                while(it.hasNext() && sellCount > 0) {\\n                    Entry<Integer, Integer> itEntry = it.next();\\n                    int buyPrice = itEntry.getKey();\\n                    int buyCount = itEntry.getValue();\\n                    if (sellPrice <= buyPrice) {\\n                        sellCount -= buyCount;\\n                        if (sellCount >= 0) {\\n                            it.remove();\\n                        } else {\\n                            itEntry.setValue(-1 * sellCount);\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (sellCount > 0) {\\n                    int originalCount = sellPriceMap.getOrDefault(sellPrice, 0);\\n                    sellPriceMap.put(sellPrice, sellCount + originalCount);\\n                }\\n            }\\n        }\\n        \\n        long res = 0;\\n        for (int value : buyPriceMap.values()) {\\n            res += value;\\n        }\\n        for (int value : sellPriceMap.values()) {\\n            res += value;\\n        }\\n        \\n        return (int)(res % MOD);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        final int MOD = 1000000007;\\n        Comparator<Pair<Integer, Integer>> sortPairByKeyInAscend = Comparator.comparing(Pair::getKey);\\n        PriorityQueue<Pair<Integer, Integer>> sell = new PriorityQueue<>(sortPairByKeyInAscend);\\n        PriorityQueue<Pair<Integer, Integer>> buy = new PriorityQueue<>(sortPairByKeyInAscend.reversed());\\n        for (int[] order : orders) {\\n            if (order[2] == 0) {\\n                int buyPrice = order[0];\\n                int buyCount = order[1];\\n                while (!sell.isEmpty() && buyCount > 0) {\\n                    Pair<Integer, Integer> smallestSell = sell.peek();\\n                    if (smallestSell.getKey() <= buyPrice) {\\n                        sell.poll();\\n                        int countDiff = buyCount - smallestSell.getValue();\\n                        if (countDiff < 0) {\\n                            sell.add(new Pair<>(smallestSell.getKey(), -1 * countDiff));\\n                        }\\n                        buyCount = countDiff;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (buyCount > 0) {\\n                    buy.add(new Pair<>(buyPrice, buyCount));\\n                }\\n            } else {\\n               int sellPrice = order[0];\\n               int sellCount = order[1];\\n               while (!buy.isEmpty() && sellCount > 0) {\\n                   Pair<Integer, Integer> biggestBuy = buy.peek();\\n                   if (biggestBuy.getKey() >= sellPrice) {\\n                       buy.poll();\\n                       int countDiff = sellCount - biggestBuy.getValue();\\n                       if (countDiff < 0) {\\n                           buy.add(new Pair<>(biggestBuy.getKey(), -1 * countDiff));\\n                       }\\n                       sellCount = countDiff;\\n                   } else {\\n                       break;\\n                   }\\n               }\\n               if (sellCount > 0) {\\n                   sell.add(new Pair<>(sellPrice, sellCount));\\n               }\\n            }\\n        }\\n        long res = 0;\\n        while(!sell.isEmpty() || !buy.isEmpty()) {\\n            if (!sell.isEmpty()) {\\n                res += sell.poll().getValue();\\n            }\\n            if (!buy.isEmpty()) {\\n                res += buy.poll().getValue();\\n            }\\n        }\\n        return (int)(res % MOD);\\n    }\\n}\\n```\n```java\\nimport java.util.Map.Entry;\\n\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        final int MOD = 1000000007;\\n        TreeMap<Integer, Integer> buyPriceMap = new TreeMap<>(Collections.reverseOrder());\\n        TreeMap<Integer, Integer> sellPriceMap = new TreeMap<>();\\n        for (int i = 0; i < orders.length; i++) {\\n            int[] curOrder = orders[i];\\n            if (curOrder[2] == 0) {\\n                int buyPrice = curOrder[0];\\n                int buyCount = curOrder[1];        \\n                Iterator<Entry<Integer, Integer>> it = sellPriceMap.entrySet().iterator();\\n                while(it.hasNext() && buyCount > 0) {\\n                    Entry<Integer, Integer> itEntry = it.next();\\n                    int sellPrice = itEntry.getKey();\\n                    int sellCount = itEntry.getValue();\\n                    if (sellPrice <= buyPrice) {\\n                        buyCount -= sellCount;\\n                        if (buyCount >= 0) {\\n                            it.remove();\\n                        } else {\\n                            itEntry.setValue(-1 * buyCount);\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (buyCount > 0) {\\n                    int originalCount = buyPriceMap.getOrDefault(buyPrice, 0);\\n                    buyPriceMap.put(buyPrice, buyCount+originalCount);\\n                }\\n\\n            } else {\\n                int sellPrice = curOrder[0];\\n                int sellCount = curOrder[1];        \\n                Iterator<Entry<Integer, Integer>> it = buyPriceMap.entrySet().iterator();\\n                while(it.hasNext() && sellCount > 0) {\\n                    Entry<Integer, Integer> itEntry = it.next();\\n                    int buyPrice = itEntry.getKey();\\n                    int buyCount = itEntry.getValue();\\n                    if (sellPrice <= buyPrice) {\\n                        sellCount -= buyCount;\\n                        if (sellCount >= 0) {\\n                            it.remove();\\n                        } else {\\n                            itEntry.setValue(-1 * sellCount);\\n                        }\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (sellCount > 0) {\\n                    int originalCount = sellPriceMap.getOrDefault(sellPrice, 0);\\n                    sellPriceMap.put(sellPrice, sellCount + originalCount);\\n                }\\n            }\\n        }\\n        \\n        long res = 0;\\n        for (int value : buyPriceMap.values()) {\\n            res += value;\\n        }\\n        for (int value : sellPriceMap.values()) {\\n            res += value;\\n        }\\n        \\n        return (int)(res % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1121368,
                "title": "c-short-map-solution",
                "content": "Run-time is `O(NlogN)`, space is `O(N)`. \\n\\n```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        std::map<int,int> buy, sell;\\n        for(const auto& o: orders) {\\n            int price{o[0]}, amount{o[1]}, type{o[2]};\\n            if(type == 0) {\\n                while(!sell.empty()) {\\n                    auto& [p, a]{*sell.begin()};\\n                    if(p > price) break;\\n                    if(a > amount) {\\n                        a -= amount;\\n                        amount = 0;\\n                        break;\\n                    } else if(a == amount) {\\n                        sell.erase(sell.begin());\\n                        amount = 0;\\n                        break;\\n                    } else {\\n                        amount -= a;\\n                        sell.erase(sell.begin());\\n                    }\\n                }\\n                \\n                if(amount) buy[price] += amount;\\n            } else {\\n                while(!buy.empty()) {\\n                    auto& [p, a]{*(--buy.end())};\\n                    if(p < price) break;\\n                    if(a > amount) {\\n                        a -= amount;\\n                        amount = 0;\\n                        break;\\n                    } else if(a == amount) {\\n                        buy.erase(--buy.end());\\n                        amount = 0;\\n                        break;\\n                    } else {\\n                        amount -= a;\\n                        buy.erase(--buy.end());\\n                    }\\n                }\\n                \\n                if(amount) sell[price] += amount;\\n            }\\n        }\\n        \\n        int64_t total{0};\\n        for(const auto &[_, a]: buy) total = (total + a) % MOD;\\n        for(const auto &[_, a]: sell) total = (total+a) % MOD;\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        std::map<int,int> buy, sell;\\n        for(const auto& o: orders) {\\n            int price{o[0]}, amount{o[1]}, type{o[2]};\\n            if(type == 0) {\\n                while(!sell.empty()) {\\n                    auto& [p, a]{*sell.begin()};\\n                    if(p > price) break;\\n                    if(a > amount) {\\n                        a -= amount;\\n                        amount = 0;\\n                        break;\\n                    } else if(a == amount) {\\n                        sell.erase(sell.begin());\\n                        amount = 0;\\n                        break;\\n                    } else {\\n                        amount -= a;\\n                        sell.erase(sell.begin());\\n                    }\\n                }\\n                \\n                if(amount) buy[price] += amount;\\n            } else {\\n                while(!buy.empty()) {\\n                    auto& [p, a]{*(--buy.end())};\\n                    if(p < price) break;\\n                    if(a > amount) {\\n                        a -= amount;\\n                        amount = 0;\\n                        break;\\n                    } else if(a == amount) {\\n                        buy.erase(--buy.end());\\n                        amount = 0;\\n                        break;\\n                    } else {\\n                        amount -= a;\\n                        buy.erase(--buy.end());\\n                    }\\n                }\\n                \\n                if(amount) sell[price] += amount;\\n            }\\n        }\\n        \\n        int64_t total{0};\\n        for(const auto &[_, a]: buy) total = (total + a) % MOD;\\n        for(const auto &[_, a]: sell) total = (total+a) % MOD;\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120793,
                "title": "python-accepted",
                "content": "- We use `-price` for the `self.buy` backlog, as, python defaults `heapq` to a min heap, and we want `self.buy` to be a max heap.\\n\\n```python\\nimport heapq\\n\\n\\nclass Solution:\\n    \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        self.buy, self.sell = [], []\\n        \\n        for order in orders:\\n            if not order[-1]:\\n                self.handle_buy_order(order[0], order[1])\\n            else:\\n                self.handle_sell_order(order[0], order[1])\\n                \\n        return sum(map(lambda x: sum([i[1] for i in x]), (self.buy, self.sell))) % MOD\\n        \\n\\t\\t\\n    def handle_buy_order(self, price, amount):\\n        \\n        while self.sell:\\n            sell_price, quantity = heapq.heappop(self.sell)\\n            \\n            if sell_price > price:\\n                heapq.heappush(self.sell, (sell_price, quantity))\\n                break\\n                \\n            x = min(quantity, amount)\\n            quantity -= x\\n            amount -= x\\n            \\n            if quantity > 0:\\n                heapq.heappush(self.sell, (sell_price, quantity))\\n                break\\n                \\n            if amount == 0:\\n                break\\n            \\n        if amount > 0:\\n            heapq.heappush(self.buy, (-price, amount))\\n            \\n    \\n    def handle_sell_order(self, price, amount):\\n        \\n        while self.buy:\\n            buy_price, quantity = heapq.heappop(self.buy)\\n                    \\n            if -buy_price < price:\\n                heapq.heappush(self.buy, (buy_price, quantity))\\n                break\\n                \\n            x = min(quantity, amount)\\n            quantity -= x\\n            amount -= x\\n            \\n            if quantity > 0:\\n                heapq.heappush(self.buy, (buy_price, quantity))\\n                break\\n                \\n            if amount == 0:\\n                break\\n            \\n        if amount > 0:\\n            heapq.heappush(self.sell, (price, amount))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport heapq\\n\\n\\nclass Solution:\\n    \\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        \\n        MOD = 10**9 + 7\\n        self.buy, self.sell = [], []\\n        \\n        for order in orders:\\n            if not order[-1]:\\n                self.handle_buy_order(order[0], order[1])\\n            else:\\n                self.handle_sell_order(order[0], order[1])\\n                \\n        return sum(map(lambda x: sum([i[1] for i in x]), (self.buy, self.sell))) % MOD\\n        \\n\\t\\t\\n    def handle_buy_order(self, price, amount):\\n        \\n        while self.sell:\\n            sell_price, quantity = heapq.heappop(self.sell)\\n            \\n            if sell_price > price:\\n                heapq.heappush(self.sell, (sell_price, quantity))\\n                break\\n                \\n            x = min(quantity, amount)\\n            quantity -= x\\n            amount -= x\\n            \\n            if quantity > 0:\\n                heapq.heappush(self.sell, (sell_price, quantity))\\n                break\\n                \\n            if amount == 0:\\n                break\\n            \\n        if amount > 0:\\n            heapq.heappush(self.buy, (-price, amount))\\n            \\n    \\n    def handle_sell_order(self, price, amount):\\n        \\n        while self.buy:\\n            buy_price, quantity = heapq.heappop(self.buy)\\n                    \\n            if -buy_price < price:\\n                heapq.heappush(self.buy, (buy_price, quantity))\\n                break\\n                \\n            x = min(quantity, amount)\\n            quantity -= x\\n            amount -= x\\n            \\n            if quantity > 0:\\n                heapq.heappush(self.buy, (buy_price, quantity))\\n                break\\n                \\n            if amount == 0:\\n                break\\n            \\n        if amount > 0:\\n            heapq.heappush(self.sell, (price, amount))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120741,
                "title": "python3-heapq-solution-for-reference",
                "content": "Using a min heap with prices and maxheap with the 0-prices list, one can keep track of max and min. Only a min-max heap solution in my exp, can be handled with the 100000 input tests. The code below could be improvised a bit and the order class is probably not required but that accidentally made the code clean. \\n\\n```\\nclass order:\\n    def __init__(self, price: int, amount: int):\\n        self.price = price\\n        self.amount = amount\\n    def __repr__(self):\\n        return f\\'Node value: {self.price, self.amount}\\'\\n    def __lt__(self, other):\\n        return self.price < other.price\\n    \\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyorders = []\\n        sellorders = []\\n        \\n        heapq.heapify(buyorders)\\n        heapq.heapify(sellorders)\\n        \\n        for o in orders:     \\n            price, amount, orderType = o\\n            \\n            if orderType == 0:\\n                if not sellorders:\\n                    heapq.heappush(buyorders, order(-price, amount))\\n                else:\\n                    idx = 0\\n                    while sellorders and amount and sellorders[idx].price <= price:\\n                        sorder = sellorders[idx]\\n                        if sorder.amount <= amount:\\n                            oobj = heapq.heappop(sellorders)\\n                            amount -= oobj.amount\\n                        else:\\n                            sorder.amount -= amount\\n                            amount = 0\\n                    if amount:\\n                        heapq.heappush(buyorders, order(-price, amount))\\n            else:\\n                if not buyorders:\\n                    heapq.heappush(sellorders, order(price, amount))\\n                else:\\n                    idx = 0\\n                    while buyorders and amount and (0-buyorders[idx].price) >= price:\\n                        border = buyorders[idx]\\n                        if border.amount <= amount:\\n                            oobj = heapq.heappop(buyorders)\\n                            amount -= oobj.amount\\n                        else:\\n                            border.amount -= amount\\n                            amount = 0\\n                    if amount:\\n                        heapq.heappush(sellorders, order(price, amount))\\n                        \\n        return (sum([i.amount for i in buyorders]) + sum([i.amount for i in sellorders])) % (10**9+7)\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "Using a min heap with prices and maxheap with the 0-prices list, one can keep track of max and min. Only a min-max heap solution in my exp, can be handled with the 100000 input tests. The code below could be improvised a bit and the order class is probably not required but that accidentally made the code clean. \\n\\n```\\nclass order:\\n    def __init__(self, price: int, amount: int):\\n        self.price = price\\n        self.amount = amount\\n    def __repr__(self):\\n        return f\\'Node value: {self.price, self.amount}\\'\\n    def __lt__(self, other):\\n        return self.price < other.price\\n    \\nclass Solution:\\n    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:\\n        buyorders = []\\n        sellorders = []\\n        \\n        heapq.heapify(buyorders)\\n        heapq.heapify(sellorders)\\n        \\n        for o in orders:     \\n            price, amount, orderType = o\\n            \\n            if orderType == 0:\\n                if not sellorders:\\n                    heapq.heappush(buyorders, order(-price, amount))\\n                else:\\n                    idx = 0\\n                    while sellorders and amount and sellorders[idx].price <= price:\\n                        sorder = sellorders[idx]\\n                        if sorder.amount <= amount:\\n                            oobj = heapq.heappop(sellorders)\\n                            amount -= oobj.amount\\n                        else:\\n                            sorder.amount -= amount\\n                            amount = 0\\n                    if amount:\\n                        heapq.heappush(buyorders, order(-price, amount))\\n            else:\\n                if not buyorders:\\n                    heapq.heappush(sellorders, order(price, amount))\\n                else:\\n                    idx = 0\\n                    while buyorders and amount and (0-buyorders[idx].price) >= price:\\n                        border = buyorders[idx]\\n                        if border.amount <= amount:\\n                            oobj = heapq.heappop(buyorders)\\n                            amount -= oobj.amount\\n                        else:\\n                            border.amount -= amount\\n                            amount = 0\\n                    if amount:\\n                        heapq.heappush(sellorders, order(price, amount))\\n                        \\n        return (sum([i.amount for i in buyorders]) + sum([i.amount for i in sellorders])) % (10**9+7)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1120737,
                "title": "javascript-using-priority-queue",
                "content": "```\\n/**\\n * @param {number[][]} orders\\n * @return {number}\\n */\\nvar getNumberOfBacklogOrders = function(orders) {\\n    let buyBucket = new MaxPriorityQueue({\\n        priority: x => x[0]\\n    });\\n    let sellBucket = new MaxPriorityQueue({\\n        priority: x => 1/x[0]\\n    });\\n \\n    for(let [price, amt, type] of orders){\\n        if(type === 0 ) {  // buy \\n            let tempAmt = amt;\\n            let flag = false;\\n            while(sellBucket.size() > 0) { \\n                let [sellPrice, sellAmt] = sellBucket.dequeue().element;\\n                if(sellPrice > price ){\\n                    sellBucket.enqueue([sellPrice, sellAmt]);                    \\n                    break;\\n                } \\n                flag = true;               \\n                if(tempAmt === sellAmt)\\n                    break;\\n                else if(tempAmt < sellAmt){\\n                    sellBucket.enqueue([sellPrice, sellAmt - tempAmt]);\\n                    break;\\n                }else{\\n                    tempAmt -= sellAmt;\\n                    flag = false;\\n                }\\n            }\\n            if(!flag)    \\n                buyBucket.enqueue([price, tempAmt]);\\n        }else{  // sell            \\n            let tempSellQt = amt;\\n            let flag = false;\\n            while(buyBucket.size() > 0){\\n                let [buyPrice, buyQt] = buyBucket.dequeue().element;\\n                if(buyPrice <  price ){\\n                    buyBucket.enqueue([buyPrice, buyQt]);\\n                    break;\\n                }\\n                flag = true;\\n                if(tempSellQt === buyQt)\\n                    break;\\n                else if(tempSellQt < buyQt){\\n                    buyBucket.enqueue([buyPrice, buyQt - tempSellQt]);\\n                    break;\\n                }else{\\n                    tempSellQt -= buyQt;\\n                    flag = false;\\n                }  \\n            }\\n            if(!flag)\\n             sellBucket.enqueue([price, tempSellQt]);\\n        }  \\n    } \\n    \\n    let ans = 0;\\n    while(sellBucket.size() > 0){\\n        let [sellPrice, sellAmt] = sellBucket.dequeue().element;\\n        ans = (ans + sellAmt) % (Math.pow(10,9) + 7);\\n    }\\n    while(buyBucket.size() > 0){\\n        let [buyPrice, buyAmt] = buyBucket.dequeue().element;\\n        ans = (ans + buyAmt) % (Math.pow(10,9) + 7);\\n    }\\n    return ans;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} orders\\n * @return {number}\\n */\\nvar getNumberOfBacklogOrders = function(orders) {\\n    let buyBucket = new MaxPriorityQueue({\\n        priority: x => x[0]\\n    });\\n    let sellBucket = new MaxPriorityQueue({\\n        priority: x => 1/x[0]\\n    });\\n \\n    for(let [price, amt, type] of orders){\\n        if(type === 0 ) {  // buy \\n            let tempAmt = amt;\\n            let flag = false;\\n            while(sellBucket.size() > 0) { \\n                let [sellPrice, sellAmt] = sellBucket.dequeue().element;\\n                if(sellPrice > price ){\\n                    sellBucket.enqueue([sellPrice, sellAmt]);                    \\n                    break;\\n                } \\n                flag = true;               \\n                if(tempAmt === sellAmt)\\n                    break;\\n                else if(tempAmt < sellAmt){\\n                    sellBucket.enqueue([sellPrice, sellAmt - tempAmt]);\\n                    break;\\n                }else{\\n                    tempAmt -= sellAmt;\\n                    flag = false;\\n                }\\n            }\\n            if(!flag)    \\n                buyBucket.enqueue([price, tempAmt]);\\n        }else{  // sell            \\n            let tempSellQt = amt;\\n            let flag = false;\\n            while(buyBucket.size() > 0){\\n                let [buyPrice, buyQt] = buyBucket.dequeue().element;\\n                if(buyPrice <  price ){\\n                    buyBucket.enqueue([buyPrice, buyQt]);\\n                    break;\\n                }\\n                flag = true;\\n                if(tempSellQt === buyQt)\\n                    break;\\n                else if(tempSellQt < buyQt){\\n                    buyBucket.enqueue([buyPrice, buyQt - tempSellQt]);\\n                    break;\\n                }else{\\n                    tempSellQt -= buyQt;\\n                    flag = false;\\n                }  \\n            }\\n            if(!flag)\\n             sellBucket.enqueue([price, tempSellQt]);\\n        }  \\n    } \\n    \\n    let ans = 0;\\n    while(sellBucket.size() > 0){\\n        let [sellPrice, sellAmt] = sellBucket.dequeue().element;\\n        ans = (ans + sellAmt) % (Math.pow(10,9) + 7);\\n    }\\n    while(buyBucket.size() > 0){\\n        let [buyPrice, buyAmt] = buyBucket.dequeue().element;\\n        ans = (ans + buyAmt) % (Math.pow(10,9) + 7);\\n    }\\n    return ans;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120507,
                "title": "c-map-beat-100",
                "content": "```\\nclass Solution {\\n    map<int,int> buy;\\n    map<int,int> sell;\\n    void execute(map<int,int>& array, map<int,int>& parray, vector<int>& order, map<int,int>::iterator it, int v)\\n    {\\n        int c = order[1];\\n        map<int,int>::iterator its = it, ite = array.end();\\n        while (it != array.end() && it->first <= v)\\n        {\\n            int mv = min(it->second, c);\\n            it->second -= mv;\\n            c -= mv;\\n            if (it->second == 0)\\n            {\\n                ite = it;\\n                it++;\\n            }\\n            else\\n                break;\\n        }\\n        if (ite != array.end())\\n            array.erase(its,ite);\\n        if (c > 0)\\n        {\\n            v = -v;\\n            if (!parray.count(v))\\n                parray[v] = c;\\n            else\\n                parray[v] += c;\\n        }\\n    }\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        for (auto& order : orders)\\n        {\\n            if (order[2] == 0)\\n                execute(sell, buy, order, sell.begin(), order[0]);\\n            else\\n                execute(buy, sell, order, buy.begin(), -order[0]);\\n        }\\n        int sum = 0; \\n        for(auto& it: buy) sum = (sum + it.second) % 1000000007;  \\n        for(auto& it: sell) sum = (sum + it.second) % 1000000007;  \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    map<int,int> buy;\\n    map<int,int> sell;\\n    void execute(map<int,int>& array, map<int,int>& parray, vector<int>& order, map<int,int>::iterator it, int v)\\n    {\\n        int c = order[1];\\n        map<int,int>::iterator its = it, ite = array.end();\\n        while (it != array.end() && it->first <= v)\\n        {\\n            int mv = min(it->second, c);\\n            it->second -= mv;\\n            c -= mv;\\n            if (it->second == 0)\\n            {\\n                ite = it;\\n                it++;\\n            }\\n            else\\n                break;\\n        }\\n        if (ite != array.end())\\n            array.erase(its,ite);\\n        if (c > 0)\\n        {\\n            v = -v;\\n            if (!parray.count(v))\\n                parray[v] = c;\\n            else\\n                parray[v] += c;\\n        }\\n    }\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        for (auto& order : orders)\\n        {\\n            if (order[2] == 0)\\n                execute(sell, buy, order, sell.begin(), order[0]);\\n            else\\n                execute(buy, sell, order, buy.begin(), -order[0]);\\n        }\\n        int sum = 0; \\n        for(auto& it: buy) sum = (sum + it.second) % 1000000007;  \\n        for(auto& it: sell) sum = (sum + it.second) % 1000000007;  \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120487,
                "title": "python-beats-100",
                "content": "Use two heaps to record the buy and sell orders. \\n```\\nclass Solution(object):\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        bu,se = [], []\\n        for x in orders:\\n            a,b,t = x[0],x[1],x[2]\\n            n = b\\n            if t == 0:\\n                while n > 0 and se:\\n                    p,num = heapq.heappop(se)\\n                    if p > a:\\n                        heapq.heappush(se, [p, num])\\n                        break\\n                    if num <= n:\\n                        n -= num\\n                    else:\\n                        heapq.heappush(se, [p, num-n])\\n                        n = 0\\n                if n > 0:\\n                    heapq.heappush(bu,[-a,n])\\n            else:\\n                while n > 0 and bu:\\n                    p, num = heapq.heappop(bu)\\n                    if -p < a:\\n                        heapq.heappush(bu, [p, num])\\n                        break\\n                    if num <= n:\\n                        n -= num\\n                    else:\\n                        heapq.heappush(bu, [p, num-n])\\n                        n = 0\\n                if n > 0:\\n                    heapq.heappush(se,[a,n])\\n        r = 0\\n        for x in bu:\\n            r += x[1]\\n        for x in se:\\n            r += x[1]\\n        return r % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getNumberOfBacklogOrders(self, orders):\\n        \"\"\"\\n        :type orders: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        bu,se = [], []\\n        for x in orders:\\n            a,b,t = x[0],x[1],x[2]\\n            n = b\\n            if t == 0:\\n                while n > 0 and se:\\n                    p,num = heapq.heappop(se)\\n                    if p > a:\\n                        heapq.heappush(se, [p, num])\\n                        break\\n                    if num <= n:\\n                        n -= num\\n                    else:\\n                        heapq.heappush(se, [p, num-n])\\n                        n = 0\\n                if n > 0:\\n                    heapq.heappush(bu,[-a,n])\\n            else:\\n                while n > 0 and bu:\\n                    p, num = heapq.heappop(bu)\\n                    if -p < a:\\n                        heapq.heappush(bu, [p, num])\\n                        break\\n                    if num <= n:\\n                        n -= num\\n                    else:\\n                        heapq.heappush(bu, [p, num-n])\\n                        n = 0\\n                if n > 0:\\n                    heapq.heappush(se,[a,n])\\n        r = 0\\n        for x in bu:\\n            r += x[1]\\n        for x in se:\\n            r += x[1]\\n        return r % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120443,
                "title": "c-100-faster-using-priorityqueues-min-and-max",
                "content": "```\\n// orders will be matched only if price of best buy order is greater or equal to price of best sell order\\n// best buy order : buy order with max buying price\\n// best sell order : sell order with least selling price\\nclass Solution {\\nprivate :\\n    priority_queue<std::pair<int,int>, std::vector<std::pair<int,int>>, greater<std::pair<int,int>>> sellQueue;\\n    priority_queue<std::pair<int,int>, std::vector<std::pair<int,int>>, less<std::pair<int,int>> > buyQueue;\\n    void updateBuyQueue(std::pair<int,int> &pair)\\n    {\\n        while (!buyQueue.empty() && pair.first <= buyQueue.top().first && pair.second)\\n        {\\n              auto buyOrder = buyQueue.top();\\n              buyQueue.pop();\\n              int min = std::min(buyOrder.second,pair.second);\\n              buyOrder.second -= min;\\n              pair.second -= min;\\n              if (buyOrder.second) buyQueue.push(buyOrder);\\n        }            \\n    }\\n    void updateSellQueue(std::pair<int,int> &pair)\\n    {\\n        while (!sellQueue.empty() && pair.first >= sellQueue.top().first && pair.second)\\n        {\\n              auto sellOrder = sellQueue.top();\\n              sellQueue.pop();\\n              int min = std::min(sellOrder.second,pair.second);\\n              sellOrder.second -= min;\\n              pair.second -= min;\\n              if (sellOrder.second) sellQueue.push(sellOrder);\\n        }  \\n    }\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n\\n         int mod = 1000000007;\\n         for (auto &x : orders)\\n         {\\n             if (x[2] == 0)\\n             {\\n                 auto buyOrder = std::make_pair(x[0],x[1]);\\n                 updateSellQueue(buyOrder);\\n                 if (buyOrder.second) buyQueue.push(buyOrder);\\n             }else\\n             {\\n                 auto sellOrder = std::make_pair(x[0],x[1]);\\n                 updateBuyQueue(sellOrder);\\n                 if (sellOrder.second) sellQueue.push(sellOrder);\\n             }\\n         }\\n        \\n        long totalOrder = 0;\\n        while (!sellQueue.empty())\\n        {\\n            auto &x = sellQueue.top();\\n            totalOrder += x.second;\\n            totalOrder %= mod;\\n            sellQueue.pop();\\n        }\\n        while (!buyQueue.empty())\\n        {\\n            auto &x = buyQueue.top();\\n            totalOrder += x.second;\\n            totalOrder %= mod;\\n            buyQueue.pop();\\n        }\\n        return totalOrder;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate :\\n    priority_queue<std::pair<int,int>, std::vector<std::pair<int,int>>, greater<std::pair<int,int>>> sellQueue;\\n    priority_queue<std::pair<int,int>, std::vector<std::pair<int,int>>, less<std::pair<int,int>> > buyQueue;\\n    void updateBuyQueue(std::pair<int,int> &pair)\\n    {\\n        while (!buyQueue.empty() && pair.first <= buyQueue.top().first && pair.second)\\n        {\\n              auto buyOrder = buyQueue.top();\\n              buyQueue.pop();\\n              int min = std::min(buyOrder.second,pair.second);\\n              buyOrder.second -= min;\\n              pair.second -= min;\\n              if (buyOrder.second) buyQueue.push(buyOrder);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1120357,
                "title": "can-somebody-help",
                "content": "**Can you please help me to figure out why my Code is not working on this tc :** \\n  [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]\\n `Expected : 999999984\\n Myoutput 999999992`\\n ```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int mod=(int)Math.pow(10,9) + 7;\\n        \\n         PriorityQueue<int[]> buy=new PriorityQueue<>(new maxComparator());\\n         PriorityQueue<int[]> sell=new PriorityQueue<>(new minComparator());\\n        \\n         for(int[] order:orders){\\n             if(order[2]==0){\\n                 buy.add(order);\\n             }else{\\n                 sell.add(order);\\n             }\\n             \\n           while(buy.size()>0 && sell.size()>0 && buy.peek()[0]<=sell.peek()[0]){\\n               int commonAmount=Math.min(buy.peek()[1],sell.peek()[1]);\\n               \\n               buy.peek()[1]-=commonAmount;\\n               sell.peek()[1]-=commonAmount;\\n               \\n               if(buy.peek()[1]==0) buy.remove();\\n               if(sell.peek()[1]==0) sell.remove();\\n           }  \\n        }\\n        \\n        int result=0;\\n        while(buy.size()>0){\\n            int[] block=buy.remove();\\n            result =(result + block[1])%mod;\\n        }\\n        \\n        while(sell.size()>0){\\n             int[] block=sell.remove();\\n            result= (result+ block[1])%mod;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class maxComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            return two[0]-one[0];\\n        } \\n    }\\n    \\n    public class minComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            return one[0] -two[0];\\n        }\\n    }\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getNumberOfBacklogOrders(int[][] orders) {\\n        int mod=(int)Math.pow(10,9) + 7;\\n        \\n         PriorityQueue<int[]> buy=new PriorityQueue<>(new maxComparator());\\n         PriorityQueue<int[]> sell=new PriorityQueue<>(new minComparator());\\n        \\n         for(int[] order:orders){\\n             if(order[2]==0){\\n                 buy.add(order);\\n             }else{\\n                 sell.add(order);\\n             }\\n             \\n           while(buy.size()>0 && sell.size()>0 && buy.peek()[0]<=sell.peek()[0]){\\n               int commonAmount=Math.min(buy.peek()[1],sell.peek()[1]);\\n               \\n               buy.peek()[1]-=commonAmount;\\n               sell.peek()[1]-=commonAmount;\\n               \\n               if(buy.peek()[1]==0) buy.remove();\\n               if(sell.peek()[1]==0) sell.remove();\\n           }  \\n        }\\n        \\n        int result=0;\\n        while(buy.size()>0){\\n            int[] block=buy.remove();\\n            result =(result + block[1])%mod;\\n        }\\n        \\n        while(sell.size()>0){\\n             int[] block=sell.remove();\\n            result= (result+ block[1])%mod;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class maxComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            return two[0]-one[0];\\n        } \\n    }\\n    \\n    public class minComparator implements Comparator<int[]>{\\n        @Override\\n        public int compare(int[] one,int[] two){\\n            return one[0] -two[0];\\n        }\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120109,
                "title": "beats-100-c-video-explanation",
                "content": "Video Explanation\\nhttps://youtu.be/b1sDgaLstd0\\n```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int M=1e9+7;\\n        priority_queue<vector<int>>bpq;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>spq;\\n        for(int i=0;i<orders.size();i++)\\n        {\\n            vector<int>order=orders[i];\\n            if(order[2]==0)\\n            {\\n                while(!spq.empty() && spq.top()[0]<=order[0])\\n                {\\n                    vector<int>sellingBatch=spq.top();spq.pop();\\n                    if(sellingBatch[1]>=order[1])\\n                    {\\n                        sellingBatch[1]-=order[1];\\n                        order[1]=0;\\n                        if(sellingBatch[1]>0)\\n                            spq.push(sellingBatch);\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        order[1]-=sellingBatch[1];\\n                    }\\n                }\\n                if(order[1]>0)\\n                    bpq.push(order);\\n                    \\n            }\\n            else\\n            {\\n                while(!bpq.empty() && bpq.top()[0]>=order[0])\\n                {\\n                    vector<int>buyingBatch=bpq.top();bpq.pop();\\n                    if(buyingBatch[1]>=order[1])\\n                    {\\n                        buyingBatch[1]-=order[1];\\n                        order[1]=0;\\n                        if(buyingBatch[1]>0)\\n                            bpq.push(buyingBatch);\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        order[1]-=buyingBatch[1];\\n                    }\\n                }\\n                if(order[1]>0)\\n                    spq.push(order);\\n                    \\n            }\\n        }\\n        int res=0;\\n        while(!bpq.empty())\\n        {\\n            res=(res%M + bpq.top()[1]%M)%M;\\n            bpq.pop();\\n        }\\n        \\n        while(!spq.empty())\\n        {\\n            res=(res%M + spq.top()[1]%M)%M;\\n            spq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\\n        int M=1e9+7;\\n        priority_queue<vector<int>>bpq;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>spq;\\n        for(int i=0;i<orders.size();i++)\\n        {\\n            vector<int>order=orders[i];\\n            if(order[2]==0)\\n            {\\n                while(!spq.empty() && spq.top()[0]<=order[0])\\n                {\\n                    vector<int>sellingBatch=spq.top();spq.pop();\\n                    if(sellingBatch[1]>=order[1])\\n                    {\\n                        sellingBatch[1]-=order[1];\\n                        order[1]=0;\\n                        if(sellingBatch[1]>0)\\n                            spq.push(sellingBatch);\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        order[1]-=sellingBatch[1];\\n                    }\\n                }\\n                if(order[1]>0)\\n                    bpq.push(order);\\n                    \\n            }\\n            else\\n            {\\n                while(!bpq.empty() && bpq.top()[0]>=order[0])\\n                {\\n                    vector<int>buyingBatch=bpq.top();bpq.pop();\\n                    if(buyingBatch[1]>=order[1])\\n                    {\\n                        buyingBatch[1]-=order[1];\\n                        order[1]=0;\\n                        if(buyingBatch[1]>0)\\n                            bpq.push(buyingBatch);\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        order[1]-=buyingBatch[1];\\n                    }\\n                }\\n                if(order[1]>0)\\n                    spq.push(order);\\n                    \\n            }\\n        }\\n        int res=0;\\n        while(!bpq.empty())\\n        {\\n            res=(res%M + bpq.top()[1]%M)%M;\\n            bpq.pop();\\n        }\\n        \\n        while(!spq.empty())\\n        {\\n            res=(res%M + spq.top()[1]%M)%M;\\n            spq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120096,
                "title": "my-javascript-solution-using-priority-queue-276-ms",
                "content": "Not optimal as I do enqueue/dequeue more times, but easier to read:\\n```\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const mod = 1e9 + 7;\\n    const sell = new MinPriorityQueue();\\n    const buy = new MaxPriorityQueue();\\n    let result = 0;\\n    let sellElement;\\n    let buyElement;\\n    \\n    for (let i = 0; i < orders.length; ++i) {\\n        result += orders[i][1];\\n        if (orders[i][2] === 0) { // buy\\n            buy.enqueue(orders[i][1], orders[i][0]);\\n        } else {\\n            sell.enqueue(orders[i][1], orders[i][0]);\\n        }\\n        \\n        while (!sell.isEmpty() && !buy.isEmpty() && sell.front().priority <= buy.front().priority) {\\n            sellElement = sell.dequeue();\\n            buyElement = buy.dequeue();\\n            if (sellElement.element < buyElement.element) {\\n                buy.enqueue(buyElement.element - sellElement.element, buyElement.priority);\\n                result -= 2 * sellElement.element;\\n            } else if (sellElement.element > buyElement.element) {\\n                sell.enqueue(sellElement.element - buyElement.element, sellElement.priority);\\n                result -= 2 * buyElement.element;\\n            } else {\\n                result -= 2 * buyElement.element;\\n            }\\n        }\\n    }\\n    \\n    return result % mod;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const mod = 1e9 + 7;\\n    const sell = new MinPriorityQueue();\\n    const buy = new MaxPriorityQueue();\\n    let result = 0;\\n    let sellElement;\\n    let buyElement;\\n    \\n    for (let i = 0; i < orders.length; ++i) {\\n        result += orders[i][1];\\n        if (orders[i][2] === 0) { // buy\\n            buy.enqueue(orders[i][1], orders[i][0]);\\n        } else {\\n            sell.enqueue(orders[i][1], orders[i][0]);\\n        }\\n        \\n        while (!sell.isEmpty() && !buy.isEmpty() && sell.front().priority <= buy.front().priority) {\\n            sellElement = sell.dequeue();\\n            buyElement = buy.dequeue();\\n            if (sellElement.element < buyElement.element) {\\n                buy.enqueue(buyElement.element - sellElement.element, buyElement.priority);\\n                result -= 2 * sellElement.element;\\n            } else if (sellElement.element > buyElement.element) {\\n                sell.enqueue(sellElement.element - buyElement.element, sellElement.priority);\\n                result -= 2 * buyElement.element;\\n            } else {\\n                result -= 2 * buyElement.element;\\n            }\\n        }\\n    }\\n    \\n    return result % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120069,
                "title": "javascript-faster-than-100-of-the-solutions-using-heaps",
                "content": "```\\n/**\\n * @param {number[][]} orders\\n * @return {number}\\n */\\nclass Heap {\\n    constructor (heapFn = (child, parent) => child > parent) {\\n        this.heap = [];\\n        this.heapFn = heapFn;\\n    }\\n    \\n    exchange (index1, index2) {\\n        if(index1 === index2) return;\\n        const tmp = this.heap[index1];\\n        this.heap[index1] = this.heap[index2];\\n        this.heap[index2] = tmp;\\n    }\\n    \\n    add (num) {\\n        this.heap.push(num);\\n        this.heapify(this.heap.length-1);\\n    }\\n    \\n    heapify (index) {\\n        if(index === 0) \\n            return;\\n        const parent = Math.floor((index-1)/2);\\n        if (!this.heapFn(this.heap[index], this.heap[parent])) {\\n            this.exchange(index, parent);\\n            this.heapify(parent);\\n        }\\n    }\\n    \\n    remove () {\\n        this.heap[0] = this.heap[this.heap.length-1];\\n        this.heap.pop();\\n        this.downHeapify(0);\\n    }\\n    downHeapify (index) {\\n        const child1 = index*2 + 1, child2 = index*2 + 2;\\n        let minIndex = index;\\n        if(child1 < this.heap.length && !this.heapFn(this.heap[child1], this.heap[minIndex])) {\\n            minIndex = child1;\\n        }\\n        if(child2 < this.heap.length && !this.heapFn(this.heap[child2], this.heap[minIndex])) {\\n            minIndex = child2;\\n        }\\n        if(index !== minIndex) {\\n            this.exchange(index, minIndex);\\n            this.downHeapify(minIndex);\\n        }\\n    }\\n}\\n\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const sellOrders = new Heap((child, parent) => child.price > parent.price);\\n    const buyOrders = new Heap((child, parent) => child.price < parent.price);\\n    orders.forEach(order => {\\n        let quantity = order[1];\\n        if(order[2] === 0) {\\n            let sell = sellOrders.heap[0];\\n            while(sell && sell.price <= order[0] && quantity > 0) {\\n               if(sell.quantity > quantity) {\\n                   sell.quantity -= quantity;\\n                   quantity = 0;\\n               } else {\\n                   sellOrders.remove();\\n                   quantity -= sell.quantity;\\n                   sell = sellOrders.heap[0];\\n               }\\n            }\\n            if(quantity) {\\n                buyOrders.add({price: order[0], quantity});\\n            }\\n        } else {\\n            let buy = buyOrders.heap[0];\\n            while(buy && buy.price >= order[0] && quantity > 0) {\\n                if(buy.quantity > quantity) {\\n                    buy.quantity -= quantity;\\n                    quantity = 0;\\n                } else {\\n                    buyOrders.remove();\\n                    quantity -= buy.quantity;\\n                    buy = buyOrders.heap[0];\\n                }\\n            }\\n            if(quantity) {\\n                sellOrders.add({price: order[0], quantity});\\n            }\\n        }\\n    });\\n    return (buyOrders.heap.reduce((acc, val) => acc + val.quantity, 0) + sellOrders.heap.reduce((acc, val) => acc + val.quantity, 0)) % 1000000007 ;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} orders\\n * @return {number}\\n */\\nclass Heap {\\n    constructor (heapFn = (child, parent) => child > parent) {\\n        this.heap = [];\\n        this.heapFn = heapFn;\\n    }\\n    \\n    exchange (index1, index2) {\\n        if(index1 === index2) return;\\n        const tmp = this.heap[index1];\\n        this.heap[index1] = this.heap[index2];\\n        this.heap[index2] = tmp;\\n    }\\n    \\n    add (num) {\\n        this.heap.push(num);\\n        this.heapify(this.heap.length-1);\\n    }\\n    \\n    heapify (index) {\\n        if(index === 0) \\n            return;\\n        const parent = Math.floor((index-1)/2);\\n        if (!this.heapFn(this.heap[index], this.heap[parent])) {\\n            this.exchange(index, parent);\\n            this.heapify(parent);\\n        }\\n    }\\n    \\n    remove () {\\n        this.heap[0] = this.heap[this.heap.length-1];\\n        this.heap.pop();\\n        this.downHeapify(0);\\n    }\\n    downHeapify (index) {\\n        const child1 = index*2 + 1, child2 = index*2 + 2;\\n        let minIndex = index;\\n        if(child1 < this.heap.length && !this.heapFn(this.heap[child1], this.heap[minIndex])) {\\n            minIndex = child1;\\n        }\\n        if(child2 < this.heap.length && !this.heapFn(this.heap[child2], this.heap[minIndex])) {\\n            minIndex = child2;\\n        }\\n        if(index !== minIndex) {\\n            this.exchange(index, minIndex);\\n            this.downHeapify(minIndex);\\n        }\\n    }\\n}\\n\\nvar getNumberOfBacklogOrders = function(orders) {\\n    const sellOrders = new Heap((child, parent) => child.price > parent.price);\\n    const buyOrders = new Heap((child, parent) => child.price < parent.price);\\n    orders.forEach(order => {\\n        let quantity = order[1];\\n        if(order[2] === 0) {\\n            let sell = sellOrders.heap[0];\\n            while(sell && sell.price <= order[0] && quantity > 0) {\\n               if(sell.quantity > quantity) {\\n                   sell.quantity -= quantity;\\n                   quantity = 0;\\n               } else {\\n                   sellOrders.remove();\\n                   quantity -= sell.quantity;\\n                   sell = sellOrders.heap[0];\\n               }\\n            }\\n            if(quantity) {\\n                buyOrders.add({price: order[0], quantity});\\n            }\\n        } else {\\n            let buy = buyOrders.heap[0];\\n            while(buy && buy.price >= order[0] && quantity > 0) {\\n                if(buy.quantity > quantity) {\\n                    buy.quantity -= quantity;\\n                    quantity = 0;\\n                } else {\\n                    buyOrders.remove();\\n                    quantity -= buy.quantity;\\n                    buy = buyOrders.heap[0];\\n                }\\n            }\\n            if(quantity) {\\n                sellOrders.add({price: order[0], quantity});\\n            }\\n        }\\n    });\\n    return (buyOrders.heap.reduce((acc, val) => acc + val.quantity, 0) + sellOrders.heap.reduce((acc, val) => acc + val.quantity, 0)) % 1000000007 ;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120066,
                "title": "the-description-is-a-disaster-i-m-so-confused",
                "content": "The problem doesn\\'t clearly declare at least two rules:\\n\\n1. Whether it is a Call Auction or a Consecutive Auction?\\n2. How should we deal with partial exectution? Partially executed while others are dropped or partially executed and the rest are put back to the queue?\\n\\nIt\\'s like a stocking market and you have so many different ways to submit your transcation.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1760652,
                "content": [
                    {
                        "username": "kmp1084",
                        "content": "It helps if you have ever bought/sold stocks or options using limit!! Hence no wonder Robinhood asked this question!"
                    }
                ]
            }
        ]
    }
]