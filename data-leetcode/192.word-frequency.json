[
    {
        "title": "Reverse Linked List II",
        "question_content": "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\nExample 2:\n\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is n.\n\t1 <= n <= 500\n\t-500 <= Node.val <= 500\n\t1 <= left <= right <= n\n\n&nbsp;\nFollow up: Could you do it in one pass?",
        "solutions": [
            {
                "id": 30709,
                "title": "talk-is-cheap-show-me-the-code-and-drawing",
                "content": "On my way of self-learning, ```linked list``` was always a nightmare to me. Hopes the code and this graph (ugh, kind of ugly maybe) can help someone who was just like me.\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\\n![0_1490008790876_reversed_linked_list.jpeg](/uploads/files/1490008792563-reversed_linked_list.jpeg)",
                "solutionTags": [],
                "code": "```linked list```\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30666,
                "title": "simple-java-solution-with-clear-explanation",
                "content": "Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then\\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return null;\\n        ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list\\n        dummy.next = head;\\n        ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing\\n        for(int i = 0; i<m-1; i++) pre = pre.next;\\n        \\n        ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n        ListNode then = start.next; // a pointer to a node that will be reversed\\n        \\n        // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---> pre = 1, start = 2, then = 3\\n        // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n        \\n        for(int i=0; i<n-m; i++)\\n        {\\n            start.next = then.next;\\n            then.next = pre.next;\\n            pre.next = then;\\n            then = start.next;\\n        }\\n        \\n        // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n        // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n        \\n        return dummy.next;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then\\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return null;\\n        ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list\\n        dummy.next = head;\\n        ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing\\n        for(int i = 0; i<m-1; i++) pre = pre.next;\\n        \\n        ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n        ListNode then = start.next; // a pointer to a node that will be reversed\\n        \\n        // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---> pre = 1, start = 2, then = 3\\n        // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n        \\n        for(int i=0; i<n-m; i++)\\n        {\\n            start.next = then.next;\\n            then.next = pre.next;\\n            pre.next = then;\\n            then = start.next;\\n        }\\n        \\n        // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n        // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n        \\n        return dummy.next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2311084,
                "title": "java-c-tried-to-explain-every-step",
                "content": "So, this problem is not that much hard, let me made it easy for you. Be with me **Ladies-N-Gentlemen**\\n\\nTo understand this problem let\\'s take an example:\\n\\n```\\nInput: head = [1,2,10,20,30,40,5], left = 3, right = 6\\nOutput: [1,2,40,30,20,10,5]\\n```\\n\\n\\n**So, first of all I would like to show you if we do reverse one-by-one then, how it\\'ll gonna looks like**\\n\\n![image](https://assets.leetcode.com/users/images/28290044-7497-4047-b3fd-8cb79794e386_1658375922.2664697.png)\\n\\n\\nNow, let\\'s talk about how we gonna achieve this result,\\n\\nSo, for that we gonna use 3 pointers:\\n* **Pre**\\n* **Curr**\\n* **Forw**\\n\\n```\\nSo, the pre pointer will be assigned on just before left position\\nCurr pointer & forw pointer will help in reversing the linkedlist\\n\\nSo, we gonna perform these steps,\\ncurr.next = forw.next\\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\\nprev.next = forw\\nforw = curr.next\\n```\\n* **`Step-1 :`** Assign the pointers at their positions\\n![image](https://assets.leetcode.com/users/images/786cd5ed-9358-44aa-8f7a-2165f3161765_1658373106.107245.png)\\n\\n* **`Step-2 :`** \\n* * **Curr** will point to 30 i.e. `10 --> 30`\\n* * **forw** will point to **curr** i.e. `20 --> 10`\\n* * **pre** will point to **forw** i.e. `2 --> 20`\\n![image](https://assets.leetcode.com/users/images/cf33f371-6877-4eee-a9ed-21f7345ce4d2_1658373524.8555613.png)\\n\\n* **`Step-3 :`** \\n* * **Curr** will point to 40 i.e. `10 --> 40`\\n* * **forw** will point to **just after prev** i.e. `30 --> 20` ***[Now at this point it\\'s get clear our forw will point to just after prev]***\\n* * **pre** will point to **forw** i.e. `2 --> 30`\\n![image](https://assets.leetcode.com/users/images/944a0961-1ae6-427d-9eff-973f95864860_1658373816.7264853.png)\\n\\n* **`Step-4 :`** \\n* * **Curr** will point to 5 i.e. `10 --> 5`\\n* * **forw** will point to **just after prev** i.e. `40 --> 30` \\n* * **pre** will point to **forw** i.e. `2 --> 40`\\n![image](https://assets.leetcode.com/users/images/01bdc537-40f9-4d83-8326-e6df28c517bc_1658374112.1678076.png)\\n\\nNow, ladies-n-gentlemen everything is absolutely clear I hope so. \\n\\nOops, one more thing I forgot to add and i.e. is we gonna use **`dummy list`**! Now you ask why?\\n```\\nBecause, let\\'s say we have given \"left = 1\" then where our prev pointer will be assigned then, \\nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node\\n```\\n\\nLet\\'s look at the code,\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(0); // created dummy node\\n        dummy.next = head;\\n        ListNode prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev.next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode curr = prev.next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode forw = curr.next; // forw pointer will be after curr\\n            curr.next = forw.next;\\n            forw.next = prev.next;\\n            prev.next = forw;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // created dummy node\\n        dummy->next = head;\\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev->next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode *curr = prev->next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode *forw = curr->next; // forw pointer will be after curr\\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nInput: head = [1,2,10,20,30,40,5], left = 3, right = 6\\nOutput: [1,2,40,30,20,10,5]\\n```\n```\\nSo, the pre pointer will be assigned on just before left position\\nCurr pointer & forw pointer will help in reversing the linkedlist\\n\\nSo, we gonna perform these steps,\\ncurr.next = forw.next\\nforw.next = curr.next ? prev.next [\"We are not sure at this point which one forw should have to point, so we gonna find out later\"]\\nprev.next = forw\\nforw = curr.next\\n```\n```\\nBecause, let\\'s say we have given \"left = 1\" then where our prev pointer will be assigned then, \\nto handle that case we gonna use one dummy node. So, if left = 1 then our prev will be at dummy node\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode dummy = new ListNode(0); // created dummy node\\n        dummy.next = head;\\n        ListNode prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev.next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode curr = prev.next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode forw = curr.next; // forw pointer will be after curr\\n            curr.next = forw.next;\\n            forw.next = prev.next;\\n            prev.next = forw;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // created dummy node\\n        dummy->next = head;\\n        ListNode *prev = dummy; // intialising prev pointer on dummy node\\n        \\n        for(int i = 0; i < left - 1; i++)\\n            prev = prev->next; // adjusting the prev pointer on it\\'s actual index\\n        \\n        ListNode *curr = prev->next; // curr pointer will be just after prev\\n        // reversing\\n        for(int i = 0; i < right - left; i++){\\n            ListNode *forw = curr->next; // forw pointer will be after curr\\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30668,
                "title": "c-simple",
                "content": "First locate the node before the `m`-th node (`pre`) and the `m`-th node (`cur`). Then move`cur -> next` to be after `pre` for `n - m` times.\\n\\n ```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n        dummy -> next = head;\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre -> next;\\n        }\\n        cur = pre -> next;\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n        dummy -> next = head;\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre -> next;\\n        }\\n        cur = pre -> next;\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode* temp = pre -> next;\\n            pre -> next = cur -> next;\\n            cur -> next = cur -> next -> next;\\n            pre -> next -> next = temp;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30667,
                "title": "easy-understanding-java-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy = new ListNode(0);\\n            dummy.next = head;\\n            //first part\\n            ListNode cur1 = dummy;\\n            ListNode pre1 = null;\\n            for(int i=0;i<m;i++){\\n                pre1 = cur1;\\n                cur1 = cur1.next;\\n            }\\n            \\n            //reverse\\n            ListNode cur2 = cur1;\\n            ListNode pre2 = pre1;\\n            ListNode q2;\\n            for(int i=m;i<=n;i++){\\n                q2 = cur2.next;\\n                cur2.next = pre2;\\n                pre2 = cur2;\\n                cur2 = q2;\\n            }\\n            \\n            //connect \\n            pre1.next = pre2;\\n            cur1.next = cur2;\\n            \\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy = new ListNode(0);\\n            dummy.next = head;\\n            //first part\\n            ListNode cur1 = dummy;\\n            ListNode pre1 = null;\\n            for(int i=0;i<m;i++){\\n                pre1 = cur1;\\n                cur1 = cur1.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30672,
                "title": "python-one-pass-iterative-solution",
                "content": "The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1\\n\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @param m, an integer\\n        # @param n, an integer\\n        # @return a ListNode\\n        def reverseBetween(self, head, m, n):\\n            if m == n:\\n                return head\\n    \\n            dummyNode = ListNode(0)\\n            dummyNode.next = head\\n            pre = dummyNode\\n    \\n            for i in range(m - 1):\\n                pre = pre.next\\n            \\n            # reverse the [m, n] nodes\\n            reverse = None\\n            cur = pre.next\\n            for i in range(n - m + 1):\\n                next = cur.next\\n                cur.next = reverse\\n                reverse = cur\\n                cur = next\\n    \\n            pre.next.next = cur\\n            pre.next = reverse\\n    \\n            return dummyNode.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is simple and intuitive: find linkedlist [m, n], reverse it, then connect m with n+1, connect n with m-1\\n\\n    \\n    class Solution:\\n        # @param head, a ListNode\\n        # @param m, an integer\\n        # @param n, an integer\\n        # @return a ListNode\\n        def reverseBetween(self, head, m, n):\\n            if m == n:\\n                return head\\n    \\n            dummyNode = ListNode(0)\\n            dummyNode.next = head\\n            pre = dummyNode\\n    \\n            for i in range(m - 1):\\n                pre = pre.next\\n            \\n            # reverse the [m, n] nodes\\n            reverse = None\\n            cur = pre.next\\n            for i in range(n - m + 1):\\n                next = cur.next\\n                cur.next = reverse\\n                reverse = cur\\n                cur = next\\n    \\n            pre.next.next = cur\\n            pre.next = reverse\\n    \\n            return dummyNode.next",
                "codeTag": "Java"
            },
            {
                "id": 839124,
                "title": "short-solutions-long-explanations-with-pictures",
                "content": "This is the objective:\\n\\n\\n![image](https://assets.leetcode.com/users/images/229b6d58-2a1c-4f87-8af5-7a9ee5fdb50e_1599848792.0750904.png)\\n\\nAll solutions below are one-pass, iterative ` O(N)`, `4 ms`.\\n\\n#### Good solution, 11-lines, 3 variables\\n\\nI use `3` additional variables (`ListNode*` pointers). \\n* `start` points at the node that procedes the green sublist we want to invert (or holds `nullptr` if the sublist is at the front).\\n* `h` points at the current node.\\n* `prev` points at the previous node.\\n\\n\\nThe algo is the following: traverse the gray left sublist, keeping track of the previous node and adjusting `start` variable so that at the end it points at the last gray node.\\n\\n![image](https://assets.leetcode.com/users/images/cd668784-2ba0-4109-afff-2b8762d81711_1599850514.4737976.png)\\n\\n\\n\\nTraverse the green sublist, keeping track of the previous node and inverting the pointers of the nodes.\\nThe pointer of the leftmost green node can be undetermined though.\\n\\n![image](https://assets.leetcode.com/users/images/b5835d7a-8d30-440e-ae4b-aa0b8d396eef_1599850220.599696.png)\\n\\n\\n\\nNow let the `start` node point at the last node of the green sublist.\\nLet the first node of the green sublist point at the first node past green sublist. Return `head`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/80b81a94-6e9a-43a2-abaa-28d918174b64_1599849692.615093.png)\\n\\n\\n\\n\\nIf green sublist starts right at the start of the linked list, then `start` is `nullptr`. In this case set the `head` variable to the last node of the green sublist. As before the first node of the green sublist should point at the first node past green sublist. Return `head`.\\n\\n\\n![image](https://assets.leetcode.com/users/images/f95ffe45-5f3a-453e-ac4c-3321797d1b39_1599850028.6086926.png)\\n\\n<br>\\n\\nHere\\'s the code:\\n\\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tListNode *start, *h, *prev = nullptr;\\n\\n\\tfor(h = head; n--; m--)\\n\\t\\tif(m>0)\\n\\t\\t\\tstart = exchange(prev, exchange(h, h->next));\\n\\t\\telse\\n\\t\\t\\tprev  = exchange(h, exchange(h->next, prev));\\n\\n    if(start)\\n        start->next->next = h, start->next = prev;\\n    else\\n        head->next = h, head = prev;\\n\\n\\treturn head;\\n}\\n```\\n\\n\\n\\nThe `if(m>0)` branch is responsible for traversing the gray sublist + the leftmost green node. The main objective : set the `start` variable that we will need later.\\nThe `else` branch is responsible for traversing all the rest of the green sublist. The main objective : invert pointers.\\nBoth branches maintain `h` and `prev` pointers (basically `h->next` \\u2192 `h` \\u2192 `prev`).\\nWe should be careful though because as we switch green pointers we can no longer use them to advance `h`, hence we should use temp variable to store `h->next` before we change it (I did it all with the help of handy `exchange` function instead).\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/1e5c8007-fadb-4c93-8679-63cb717f7c21_1599743516.2696543.png)\\n\\n<br>\\n\\nThe loop terminates after we process the last node in the green sublist.\\nWe can now use `start` variable to the set the pointers of `start` node and `start->next` node.\\n`Start` can be `nullptr` hence the `if` part.\\n\\n**Pictures**\\n\\nThe first line is the initial linked list with green sublist we aim to  invert.\\nThe second line represents the state after the loop.\\nThe last line shows the final result.\\n\\nHere is the testcase where the sublist we want to invert is inside the list.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/12e20c5a-f825-48d9-a8e9-80b7abe728bf_1599709537.467519.png)\\n\\n<br>\\n\\nHere is the testcase where the sublist we want to invert is at the front.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/89b26cfd-cc93-45c2-8e28-b7d13fe6cf95_1599762595.596899.png)\\n\\n<br>\\n<br>\\n\\n**Better solution, 5-liner, 3 variables**\\n\\nIt\\'s possible to improve the solution above.\\nIf we use `ListNode **`  variable we can get rid of `if` before`return` and treat two testcases from the pictures uniformly.\\nBasically it\\'s dummy node solution in disguise.\\nWe can also avoid `if` in the loop and break it down into two smaller loops instead.\\n\\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto *prev{head}, *h{head}, **start{&head};\\n\\n\\tfor(; prev = exchange(h, h->next), --m && --n; start = &prev->next); \\n\\tfor(; --n; prev = exchange(h, exchange(h->next, prev))); \\n\\n\\t(*start)->next = h, *start = prev;\\n\\n\\treturn head;\\n}\\n\\n```\\n\\n**Great solution, 4 liner, 2 variables** (credit to https://leetcode.com/problems/reverse-linked-list-ii/discuss/30676/6-10-lines-in-C%2B%2B) \\n\\nI don\\'t like a couple of things in my solution.\\nThe last line before `return` is kinda lame. It would be so much better if everything was finished inside the loop.\\nIt\\'s also wasteful that until the end the first green node doesn\\'t point at anything useful.\\nIf we can make it point at the node we are going to consider next, we no longer need `prev` and `h` variables hopping around, we just need one variable that I will call `pivot`.\\nIt other words instead of this\\n\\n\\n![image](https://assets.leetcode.com/users/images/c9e40926-14c4-4de5-b55f-ff77c5fd3458_1600043706.5722702.png)\\n\\n\\n\\nwe will have this\\n\\n![image](https://assets.leetcode.com/users/images/5f7c8be5-d6e9-4738-8c4d-b4222ffa4c65_1600042483.4226246.png)\\n\\n\\n\\nLet\\'s consider another green node. We need to manage three arrows (pointers `pivot->next`, `pivot->next->next` and `start->next`) namely\\n* `pivot->next` should go to `start`  \\n*  `pivot->next->next` should go to `pivot`\\n* `start->next` should go to `pivot->next->next`\\n\\n\\n![image](https://assets.leetcode.com/users/images/f12c0247-8569-47b8-8ce5-387fd244ef49_1600042419.6194477.png)\\n\\n\\nthat will result\\n\\n\\n![image](https://assets.leetcode.com/users/images/5cc221e6-024d-4057-8764-59886426d6f1_1600044869.3226385.png)\\n\\n\\nThe amazing part is that we don\\'t need to \"cook up\" new pointers, we just transfer ownership of the existing ones. This truly shows that this problem is not about\\nnodes - it\\'s about pointers.\\n\\nIt\\'s also useful **both** auxilary variables `start` and `pivot` be of type `ListNode**`. This makes code easier.\\nThis leads to the solution\\n \\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto **pivot{&head->next}, **start{&head};\\n\\n\\tfor(; --n && --m; pivot = &(*(start = pivot))->next); \\n\\tfor(; n--; swap(*start, (*pivot)->next), swap(*start, *pivot)); \\n\\n\\treturn head;\\n}\\n```\\nThis is the most accurate picture of what is going on.\\n\\n\\n![image](https://assets.leetcode.com/users/images/51861227-af1e-4d4e-95ea-ac1a0e91b248_1600039376.005103.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/86d64a15-a9db-4675-b98a-8fadfcbf7909_1600045889.459057.png)\\n\\n\\nI like this solution (credit to StefanPochmann\\'s https://leetcode.com/problems/reverse-linked-list-ii/discuss/30676/6-10-lines-in-C%2B%2B)) because it reshuffles **existing** pointers, uses minimum number of additional variables, early returns and automatically handles special case when the green sublist starts at the start of the list (done by using `ListNode**` variables).\\n\\nP.S. Sorry, it has turned out to be pretty lengthy.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tListNode *start, *h, *prev = nullptr;\\n\\n\\tfor(h = head; n--; m--)\\n\\t\\tif(m>0)\\n\\t\\t\\tstart = exchange(prev, exchange(h, h->next));\\n\\t\\telse\\n\\t\\t\\tprev  = exchange(h, exchange(h->next, prev));\\n\\n    if(start)\\n        start->next->next = h, start->next = prev;\\n    else\\n        head->next = h, head = prev;\\n\\n\\treturn head;\\n}\\n```\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto *prev{head}, *h{head}, **start{&head};\\n\\n\\tfor(; prev = exchange(h, h->next), --m && --n; start = &prev->next); \\n\\tfor(; --n; prev = exchange(h, exchange(h->next, prev))); \\n\\n\\t(*start)->next = h, *start = prev;\\n\\n\\treturn head;\\n}\\n\\n```\n```\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n\\tauto **pivot{&head->next}, **start{&head};\\n\\n\\tfor(; --n && --m; pivot = &(*(start = pivot))->next); \\n\\tfor(; n--; swap(*start, (*pivot)->next), swap(*start, *pivot)); \\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011862,
                "title": "92-40-two-pointers-stack-recursion",
                "content": "# Interview Guide - Reversing a Sublist of a Linked List: A Comprehensive Analysis for Programmers\\n\\n## Introduction & Problem Statement\\n\\nWelcome to this detailed guide, where we delve into the fascinating problem of reversing a sublist within a singly-linked list. The challenge is not just to reverse a sublist but to do it efficiently, ideally in a single pass through the list. This guide is designed to arm you with multiple approaches for tackling this problem, each with its own unique advantages and considerations. Specifically, we will explore three distinct strategies: Two Pointers, Using a Stack, and Recursion.\\n\\n## Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n    Let\\'s start with the basics. In a singly-linked list, each node has an integer value and a `next` pointer that points to the subsequent node in the list.\\n    \\n2. **Sublist Reversal**:  \\n    The primary task is to reverse only the nodes between positions `left` and `right`, both inclusive, within the list.\\n\\n3. **Order Preservation**:  \\n    While reversing the sublist, we must ensure that the relative order of all nodes outside this range remains unchanged.\\n\\n4. **Size Constraints**:  \\n    The number of nodes in the list `n` can vary but will always be between 1 and 500, giving us more than enough to work with.\\n\\n# Live Coding & More\\nhttps://youtu.be/RohipcSF3HM?si=9GIVdRg72_EHEMmv\\n\\n- [\\uD83D\\uDC0D Two Pointers \\uD83D\\uDC49\\uD83D\\uDC48](https://youtu.be/RohipcSF3HM?si=9GIVdRg72_EHEMmv)\\n- [\\uD83D\\uDC0D Stack \\uD83D\\uDCDA](https://youtu.be/E79svvS1DB0?si=37SbMxSSJeQQHHcf)\\n- [\\uD83D\\uDC0D Recursion \\uD83D\\uDD01](https://youtu.be/xcKS9d1_vDg?si=rbsNpLsNa3EJSVD8)\\n\\n---\\n# Strategies to Tackle the Problem: A Three-Pronged Approach\\n\\n## 1. Using Two Pointers (One-Pass)\\n\\n### Intuition and Logic Behind the Solution\\n\\nIn this efficient method, we employ two pointers to traverse and manipulate the linked list in one go. The clever use of a dummy node helps us elegantly handle edge cases, and tuple unpacking makes the code more Pythonic and straightforward.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create a `dummy` node and connect its `next` to the head of the list.\\n    - Initialize a `prev` pointer to the `dummy` node.\\n\\n2. **Move to Start Position**:  \\n    - Traverse the list until the node just before the `left`-th node is reached.\\n\\n3. **Execute Sublist Reversal**:  \\n    - Use a `current` pointer to keep track of the first node in the sublist.\\n    - Reverse the sublist nodes using `prev` and `current`.\\n\\n4. **Link Back**:  \\n    - Automatically link the reversed sublist back into the original list.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)` \\u2014 A single traversal does the job.\\n- **Space Complexity**: `O(1)` \\u2014 Smart pointer manipulation eliminates the need for additional data structures.\\n\\n---\\n\\n## 2. Using a Stack\\n\\n### Intuition and Logic Behind the Solution\\n\\nThis approach uses a stack data structure to temporarily store and then reverse the sublist, making the logic easier to follow.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**:  \\n    - Like before, create a `dummy` node and set a `prev` pointer.\\n\\n2. **Populate the Stack**:  \\n    - Traverse the list and populate the stack with the nodes falling within the `left` and `right` positions.\\n\\n3. **Perform Reversal and Relink Nodes**:  \\n    - Pop nodes from the stack and relink them, essentially reversing the sublist.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)`\\n- **Space Complexity**: `O(n)` \\u2014 The stack takes extra space.\\n\\n---\\n\\n## 3. Using Recursion\\n\\n#### Intuition and Logic Behind the Solution\\n\\nIn this elegant method, the language\\'s call stack is leveraged to reverse the sublist through recursive function calls.\\n\\n### Step-by-step Explanation\\n\\n1. **Define Recursive Function**: \\n    - Create a helper function that will do the heavy lifting, taking the node and its position as parameters.\\n\\n2. **Base and Recursive Cases**:  \\n    - Implement base and recursive cases to control the flow and reversal.\\n\\n3. **Unwind and Relink**:  \\n    - As the recursion unwinds, the nodes get relinked in the reversed order.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: `O(n)`\\n- **Space Complexity**: `O(n)` \\u2014 The call stack consumes extra memory.\\n\\n## Code Highlights and Best Practices\\n\\n- The use of a `dummy` node is universal across all methods for handling edge cases gracefully.\\n- Tuple unpacking in the Two-Pointer approach makes the code clean and Pythonic.\\n- The Stack approach makes clever use of the stack data structure for sublist reversal.\\n- The Recursion method leverages the language\\'s call stack for a clean and elegant solution.\\n\\n---\\n\\n# Performance\\n\\n| Language     | Fastest Runtime (ms) | Memory Usage (MB) | Method      |\\n|--------------|----------------------|-------------------|-------------|\\n| Rust         | 0                    | 2.3               | Two-Pointers|\\n| PHP          | 0                    | 18.9              | Two-Pointers|\\n| Java         | 0                    | 40.8              | Two-Pointers|\\n| Go           | 1                    | 2.1               | Two-Pointers|\\n| C++          | 4                    | 7.4               | Two-Pointers|\\n| Python3      | 33                   | 16.6              | Two-Pointers|\\n| Python3      | 38                   | 16.6              | Recursion   |\\n| Python3      | 39                   | 16.3              | Stack       |\\n| JavaScript   | 44                   | 41.8              | Two-Pointers|\\n| C#           | 71                   | 38.4              | Two-Pointers|\\n \\n![n4.png](https://assets.leetcode.com/users/images/0ba70f84-5f2e-4007-aea3-7c491f9610e1_1694049302.9630964.png)\\n\\n\\n# Code Two Pointers\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n        \\n        dummy = ListNode(0, head)\\n        prev = dummy\\n        \\n        for _ in range(left - 1):\\n            prev = prev.next\\n        \\n        current = prev.next\\n        \\n        for _ in range(right - left):\\n            next_node = current.next\\n            current.next, next_node.next, prev.next = next_node.next, prev.next, next_node\\n\\n        return dummy.next\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n    \\n    dummy := &ListNode{0, head}\\n    prev := dummy\\n    \\n    for i := 0; i < left - 1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    current := prev.Next\\n    \\n    for i := 0; i < right - left; i++ {\\n        nextNode := current.Next\\n        current.Next = nextNode.Next\\n        nextNode.Next = prev.Next\\n        prev.Next = nextNode\\n    }\\n    \\n    return dummy.Next\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = Some(Box::new(ListNode {\\n            val: 0,\\n            next: head,\\n        }));\\n        let mut before = &mut dummy;\\n        for _ in 1..left {\\n            before = &mut before.as_mut()?.next;\\n        }\\n\\n        let mut node = before.as_mut()?.next.take();\\n        let mut node2 = node.as_mut()?.next.take();\\n        for _ in left..right {\\n            let node3 = node2.as_mut()?.next.take();\\n            node2.as_mut()?.next = node;\\n            node = node2;\\n            node2 = node3;\\n        }\\n\\n        let mut rev_tail = &mut node;\\n        for _ in left..right {\\n            rev_tail = &mut rev_tail.as_mut()?.next;\\n        }\\n        rev_tail.as_mut()?.next = node2;\\n        before.as_mut()?.next = node;\\n\\n        dummy.unwrap().next\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) return head;\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode* prev = &dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev->next;\\n        }\\n        \\n        ListNode* current = prev->next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode* next_node = current->next;\\n            current->next = next_node->next;\\n            next_node->next = prev->next;\\n            prev->next = next_node;\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n``` PHP []\\nclass Solution {\\n    function reverseBetween($head, $left, $right) {\\n        if ($head == null || $left == $right) return $head;\\n        \\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $prev = $dummy;\\n        \\n        for ($i = 0; $i < $left - 1; ++$i) {\\n            $prev = $prev->next;\\n        }\\n        \\n        $current = $prev->next;\\n        \\n        for ($i = 0; $i < $right - $left; ++$i) {\\n            $nextNode = $current->next;\\n            $current->next = $nextNode->next;\\n            $nextNode->next = $prev->next;\\n            $prev->next = $nextNode;\\n        }\\n        \\n        return $dummy->next;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    let prev = dummy;\\n    \\n    for (let i = 0; i < left - 1; ++i) {\\n        prev = prev.next;\\n    }\\n    \\n    let current = prev.next;\\n    \\n    for (let i = 0; i < right - left; ++i) {\\n        const nextNode = current.next;\\n        current.next = nextNode.next;\\n        nextNode.next = prev.next;\\n        prev.next = nextNode;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\n# Code Recursion\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not (head and left < right):\\n            return head\\n\\n        def helper(node, m):\\n            nonlocal left, right\\n            if m == left:\\n                prev = None\\n                current = node\\n                while m <= right:\\n                    current.next, prev, current = prev, current, current.next\\n                    m += 1\\n                node.next = current\\n                return prev\\n            elif m < left:\\n                node.next = helper(node.next, m + 1)\\n            return node\\n\\n        return helper(head, 1)\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left >= right {\\n        return head\\n    }\\n\\n    var helper func(node *ListNode, m int) *ListNode\\n    helper = func(node *ListNode, m int) *ListNode {\\n        if m == left {\\n            var prev, current *ListNode = nil, node\\n            for m <= right {\\n                current.Next, prev, current = prev, current, current.Next\\n                m++\\n            }\\n            node.Next = current\\n            return prev\\n        } else if m < left {\\n            node.Next = helper(node.Next, m+1)\\n        }\\n        return node\\n    }\\n\\n    return helper(head, 1)\\n}\\n\\n```\\n\\n# Code Stack\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        stack = []\\n        current = prev.next\\n\\n        for _ in range(right - left + 1):\\n            stack.append(current)\\n            current = current.next\\n\\n        while stack:\\n            prev.next = stack.pop()\\n            prev = prev.next\\n\\n        prev.next = current\\n\\n        return dummy.next\\n```\\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n\\n    dummy := &ListNode{Val: 0, Next: head}\\n    prev := dummy\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    stack := []*ListNode{}\\n    current := prev.Next\\n\\n    for i := 0; i < right-left+1; i++ {\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    for len(stack) > 0 {\\n        last := len(stack) - 1\\n        prev.Next = stack[last]\\n        stack = stack[:last]\\n        prev = prev.Next\\n    }\\n\\n    prev.Next = current\\n\\n    return dummy.Next\\n}\\n\\n```\\n\\n# Live Coding & More\\n## Stack\\nhttps://youtu.be/E79svvS1DB0?si=37SbMxSSJeQQHHcf\\n## Recursion\\nhttps://youtu.be/xcKS9d1_vDg?si=rbsNpLsNa3EJSVD8\\n\\n## Final Thoughts\\n\\nEach of the three methods comes with its own set of pros and cons. Your choice would depend on various factors such as readability, space complexity, and the specific constraints of the problem at hand. This guide equips you with the knowledge to make that choice wisely.\\n\\nSo there you have it\\u2014a multifaceted guide to tackling the problem of reversing a sublist in a singly-linked list. Armed with this knowledge, you\\'re now better prepared to face linked list challenges in interviews and beyond. Happy coding!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Linked List",
                    "Stack"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n        \\n        dummy = ListNode(0, head)\\n        prev = dummy\\n        \\n        for _ in range(left - 1):\\n            prev = prev.next\\n        \\n        current = prev.next\\n        \\n        for _ in range(right - left):\\n            next_node = current.next\\n            current.next, next_node.next, prev.next = next_node.next, prev.next, next_node\\n\\n        return dummy.next\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n    \\n    dummy := &ListNode{0, head}\\n    prev := dummy\\n    \\n    for i := 0; i < left - 1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    current := prev.Next\\n    \\n    for i := 0; i < right - left; i++ {\\n        nextNode := current.Next\\n        current.Next = nextNode.Next\\n        nextNode.Next = prev.Next\\n        prev.Next = nextNode\\n    }\\n    \\n    return dummy.Next\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {\\n        let mut dummy = Some(Box::new(ListNode {\\n            val: 0,\\n            next: head,\\n        }));\\n        let mut before = &mut dummy;\\n        for _ in 1..left {\\n            before = &mut before.as_mut()?.next;\\n        }\\n\\n        let mut node = before.as_mut()?.next.take();\\n        let mut node2 = node.as_mut()?.next.take();\\n        for _ in left..right {\\n            let node3 = node2.as_mut()?.next.take();\\n            node2.as_mut()?.next = node;\\n            node = node2;\\n            node2 = node3;\\n        }\\n\\n        let mut rev_tail = &mut node;\\n        for _ in left..right {\\n            rev_tail = &mut rev_tail.as_mut()?.next;\\n        }\\n        rev_tail.as_mut()?.next = node2;\\n        before.as_mut()?.next = node;\\n\\n        dummy.unwrap().next\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) return head;\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        ListNode* prev = &dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev->next;\\n        }\\n        \\n        ListNode* current = prev->next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode* next_node = current->next;\\n            current->next = next_node->next;\\n            next_node->next = prev->next;\\n            prev->next = next_node;\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) return head;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        \\n        for (int i = 0; i < left - 1; ++i) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode current = prev.next;\\n        \\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prev.next;\\n            prev.next = nextNode;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n``` PHP []\\nclass Solution {\\n    function reverseBetween($head, $left, $right) {\\n        if ($head == null || $left == $right) return $head;\\n        \\n        $dummy = new ListNode(0);\\n        $dummy->next = $head;\\n        $prev = $dummy;\\n        \\n        for ($i = 0; $i < $left - 1; ++$i) {\\n            $prev = $prev->next;\\n        }\\n        \\n        $current = $prev->next;\\n        \\n        for ($i = 0; $i < $right - $left; ++$i) {\\n            $nextNode = $current->next;\\n            $current->next = $nextNode->next;\\n            $nextNode->next = $prev->next;\\n            $prev->next = $nextNode;\\n        }\\n        \\n        return $dummy->next;\\n    }\\n}\\n```\n``` JavaScript []\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) return head;\\n    \\n    const dummy = new ListNode(0);\\n    dummy.next = head;\\n    let prev = dummy;\\n    \\n    for (let i = 0; i < left - 1; ++i) {\\n        prev = prev.next;\\n    }\\n    \\n    let current = prev.next;\\n    \\n    for (let i = 0; i < right - left; ++i) {\\n        const nextNode = current.next;\\n        current.next = nextNode.next;\\n        nextNode.next = prev.next;\\n        prev.next = nextNode;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not (head and left < right):\\n            return head\\n\\n        def helper(node, m):\\n            nonlocal left, right\\n            if m == left:\\n                prev = None\\n                current = node\\n                while m <= right:\\n                    current.next, prev, current = prev, current, current.next\\n                    m += 1\\n                node.next = current\\n                return prev\\n            elif m < left:\\n                node.next = helper(node.next, m + 1)\\n            return node\\n\\n        return helper(head, 1)\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left >= right {\\n        return head\\n    }\\n\\n    var helper func(node *ListNode, m int) *ListNode\\n    helper = func(node *ListNode, m int) *ListNode {\\n        if m == left {\\n            var prev, current *ListNode = nil, node\\n            for m <= right {\\n                current.Next, prev, current = prev, current, current.Next\\n                m++\\n            }\\n            node.Next = current\\n            return prev\\n        } else if m < left {\\n            node.Next = helper(node.Next, m+1)\\n        }\\n        return node\\n    }\\n\\n    return helper(head, 1)\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        stack = []\\n        current = prev.next\\n\\n        for _ in range(right - left + 1):\\n            stack.append(current)\\n            current = current.next\\n\\n        while stack:\\n            prev.next = stack.pop()\\n            prev = prev.next\\n\\n        prev.next = current\\n\\n        return dummy.next\\n```\n``` Go []\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    if head == nil || left == right {\\n        return head\\n    }\\n\\n    dummy := &ListNode{Val: 0, Next: head}\\n    prev := dummy\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    stack := []*ListNode{}\\n    current := prev.Next\\n\\n    for i := 0; i < right-left+1; i++ {\\n        stack = append(stack, current)\\n        current = current.Next\\n    }\\n\\n    for len(stack) > 0 {\\n        last := len(stack) - 1\\n        prev.Next = stack[last]\\n        stack = stack[:last]\\n        prev = prev.Next\\n    }\\n\\n    prev.Next = current\\n\\n    return dummy.Next\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291559,
                "title": "python-o-1-o-n-space-time-solution-explained",
                "content": "Very similar to problem **25**. We keep three pointers as with any other reverse linked lists problems: `pre, curr, next`. We can split all algorithm into `3` steps:\\n\\n1. Do `m-1` steps to reach the first point of range we need to reverse.\\n2. Reverse range `[n - m]`, using 3 pointers approach.\\n3. Finally we need to fix connections for the start and for the end of reversed list, using saved pointer to `pre` element.\\n\\n#### Complexity\\nTime complexity is `O(n)`, because we need to traverse elements upto `n`-th. Space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def reverseBetween(self, head, m, n):\\n        if m == n: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(m-1):\\n            pre = pre.next\\n            \\n        curr = pre.next\\n        nxt = curr.next\\n        \\n        for i in range(n-m):\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        pre.next.next = nxt\\n        pre.next = curr\\n        return dummy.next\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head, m, n):\\n        if m == n: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(m-1):\\n            pre = pre.next\\n            \\n        curr = pre.next\\n        nxt = curr.next\\n        \\n        for i in range(n-m):\\n            tmp = nxt.next\\n            nxt.next = curr\\n            curr = nxt\\n            nxt = tmp\\n            \\n        pre.next.next = nxt\\n        pre.next = curr\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30744,
                "title": "share-my-14-lines-c-solution",
                "content": "     ListNode *reverseBetween(ListNode *head, int m, int n) {\\n        if(m==n)return head;\\n\\t\\tn-=m;\\n        ListNode prehead(0);\\n        prehead.next=head;\\n        ListNode* pre=&prehead;\\n        while(--m)pre=pre->next;        \\n        ListNode* pstart=pre->next;\\n        while(n--)\\n        {\\n            ListNode *p=pstart->next;\\n            pstart->next=p->next;\\n            p->next=pre->next;\\n            pre->next=p;\\n        }\\n        return prehead.next;\\n    }",
                "solutionTags": [],
                "code": "     ListNode *reverseBetween(ListNode *head, int m, int n) {\\n        if(m==n)return head;\\n\\t\\tn-=m;\\n        ListNode prehead(0);\\n        prehead.next=head;\\n        ListNode* pre=&prehead;\\n        while(--m)pre=pre->next;        \\n        ListNode* pstart=pre->next;\\n        while(n--)\\n        {\\n            ListNode *p=pstart->next;\\n            pstart->next=p->next;\\n            p->next=pre->next;\\n            pre->next=p;\\n        }\\n        return prehead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 30676,
                "title": "6-10-lines-in-c",
                "content": "This ended up a bit extreme. I suggest to read the original one at the bottom first, which also includes an explanation. Then move upwards through the updates.\\n\\nUpdate 4:\\n\"Code golf\" (6 lines)\\n-\\n\\nNot fully golfed, but yeah...\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **a = &head, **b;\\n        for (;m--; n--)\\n            a = &(*(b=a))->next;\\n        for (;n--; swap(*b, *a))\\n            swap(*b, (*a)->next);\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 3:\\nPointer pointers (8 lines)\\n-\\n\\nRemoved duplicate code.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **pivot = &head, **prev;\\n        for (int i=0; i<m; i++)\\n            pivot = &(*(prev=pivot))->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 2:\\nPointer pointers (9 lines)\\n-\\n\\nUsing a second pointer pointer.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode **pivot = &(*prev)->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 1:\\nPointer pointer (9 lines)\\n-\\n\\nMotivated by quick glance at [lchen77's solution](https://leetcode.com/discuss/74361/less-than-10-lines-c-double-pointer-easy-understanding).\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode *pivot = *prev;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, pivot->next->next);\\n            swap(*prev, pivot->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nDummy node (10 lines)\\n-\\n\\nMy original one.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode dummy(0), *prev = &dummy;\\n        dummy.next = head;\\n        for (int i=1; i<m; i++)\\n            prev = prev->next;\\n        ListNode *pivot = prev->next;\\n        for (int i=m; i<n; i++) {\\n            swap(prev->next, pivot->next->next);\\n            swap(prev->next, pivot->next);\\n        }\\n        return dummy.next;\\n    }\\n\\nSome explanation: First I find the node right *before* the first node in the reverse range. I call it `prev`. And I call the first node *in* the reverse range `pivot`. Then this pivot node goes through the reverse range. Every next node it encounters is moved behind `prev`, i.e., to the start of the reverse range. \\n\\nSo before the reversing, I'm in this situation:\\n\\n    prev   pivot\\n     |       |\\n    [A] --> [B] --> [C] --> [D] --> [E] --> [F] --> ...\\n\\nIn front of the pivot we have node C, which gets moved to after prev, and pivot moves on:\\n\\n    prev           pivot\\n     |               |\\n    [A] --> [C] --> [B] --> [D] --> [E] --> [F] --> ...\\n\\nSo far the range from B to C has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node D, which gets moved to after prev, and pivot moves on:\\n\\n    prev                   pivot\\n     |                       |\\n    [A] --> [D] --> [C] --> [B] --> [E] --> [F] --> ...\\n\\nSo far the range from B to D has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node E, which gets moved to after prev, and pivot moves on:\\n\\n    prev                           pivot\\n     |                               |\\n    [A] --> [E] --> [D] --> [C] --> [B] --> [F] --> ...\\n\\nSo far the range from B to E has been reversed. If that was the goal, we can stop now. Otherwise...\\n\\nAnd so on...\\n\\nNote that taking out a node in front of the pivot and inserting it after prev involves modifying three pointers: `prev->next`, `pivot->next` and `pivot->next->next`. I do it with two swaps, but it could also be done with a helper variable and four assignments:\\n\\n            for (int i=m; i<n; i++) {\\n                auto next = pivot->next;\\n                pivot->next = next->next;\\n                next->next = prev->next;\\n                prev->next = next;\\n            }",
                "solutionTags": [
                    "C++"
                ],
                "code": "This ended up a bit extreme. I suggest to read the original one at the bottom first, which also includes an explanation. Then move upwards through the updates.\\n\\nUpdate 4:\\n\"Code golf\" (6 lines)\\n-\\n\\nNot fully golfed, but yeah...\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **a = &head, **b;\\n        for (;m--; n--)\\n            a = &(*(b=a))->next;\\n        for (;n--; swap(*b, *a))\\n            swap(*b, (*a)->next);\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 3:\\nPointer pointers (8 lines)\\n-\\n\\nRemoved duplicate code.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **pivot = &head, **prev;\\n        for (int i=0; i<m; i++)\\n            pivot = &(*(prev=pivot))->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 2:\\nPointer pointers (9 lines)\\n-\\n\\nUsing a second pointer pointer.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode **pivot = &(*prev)->next;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, (*pivot)->next);\\n            swap(*prev, *pivot);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nUpdate 1:\\nPointer pointer (9 lines)\\n-\\n\\nMotivated by quick glance at [lchen77's solution](https://leetcode.com/discuss/74361/less-than-10-lines-c-double-pointer-easy-understanding).\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode **prev = &head;\\n        for (int i=1; i<m; i++)\\n            prev = &(*prev)->next;\\n        ListNode *pivot = *prev;\\n        for (int i=m; i<n; i++) {\\n            swap(*prev, pivot->next->next);\\n            swap(*prev, pivot->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\nDummy node (10 lines)\\n-\\n\\nMy original one.\\n\\n    ListNode* reverseBetween(ListNode *head, int m, int n) {\\n        ListNode dummy(0), *prev = &dummy;\\n        dummy.next = head;\\n        for (int i=1; i<m; i++)\\n            prev = prev->next;\\n        ListNode *pivot = prev->next;\\n        for (int i=m; i<n; i++) {\\n            swap(prev->next, pivot->next->next);\\n            swap(prev->next, pivot->next);\\n        }\\n        return dummy.next;\\n    }\\n\\nSome explanation: First I find the node right *before* the first node in the reverse range. I call it `prev`. And I call the first node *in* the reverse range `pivot`. Then this pivot node goes through the reverse range. Every next node it encounters is moved behind `prev`, i.e., to the start of the reverse range. \\n\\nSo before the reversing, I'm in this situation:\\n\\n    prev   pivot\\n     |       |\\n    [A] --> [B] --> [C] --> [D] --> [E] --> [F] --> ...\\n\\nIn front of the pivot we have node C, which gets moved to after prev, and pivot moves on:\\n\\n    prev           pivot\\n     |               |\\n    [A] --> [C] --> [B] --> [D] --> [E] --> [F] --> ...\\n\\nSo far the range from B to C has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node D, which gets moved to after prev, and pivot moves on:\\n\\n    prev                   pivot\\n     |                       |\\n    [A] --> [D] --> [C] --> [B] --> [E] --> [F] --> ...\\n\\nSo far the range from B to D has been reversed. If that was the goal, we can stop now. Otherwise... Now in front of the pivot we have node E, which gets moved to after prev, and pivot moves on:\\n\\n    prev                           pivot\\n     |                               |\\n    [A] --> [E] --> [D] --> [C] --> [B] --> [F] --> ...\\n\\nSo far the range from B to E has been reversed. If that was the goal, we can stop now. Otherwise...\\n\\nAnd so on...\\n\\nNote that taking out a node in front of the pivot and inserting it after prev involves modifying three pointers: `prev->next`, `pivot->next` and `pivot->next->next`. I do it with two swaps, but it could also be done with a helper variable and four assignments:\\n\\n            for (int i=m; i<n; i++) {\\n                auto next = pivot->next;\\n                pivot->next = next->next;\\n                next->next = prev->next;\\n                prev->next = next;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 30673,
                "title": "why-nobody-does-it-with-recursion-shouldn-t-the-code-be-simpler",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(m==n){\\n            return head;\\n        }\\n        if(m>1){\\n            ListNode newHead = head;\\n            newHead.next = reverseBetween(head.next, m-1, n-1);\\n            return newHead;\\n        }else{\\n            ListNode next = head.next;\\n            ListNode newHead = reverseBetween(next, 1, n-1);\\n            ListNode nextnext = next.next;\\n            next.next = head;\\n            head.next = nextnext;\\n            return newHead;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(m==n){\\n            return head;\\n        }\\n        if(m>1){\\n            ListNode newHead = head;\\n            newHead.next = reverseBetween(head.next, m-1, n-1);\\n            return newHead;\\n        }else{\\n            ListNode next = head.next;\\n            ListNode newHead = reverseBetween(next, 1, n-1);\\n            ListNode nextnext = next.next;\\n            next.next = head;\\n            head.next = nextnext;\\n            return newHead;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30732,
                "title": "python-implementation-and-detailed-explanation",
                "content": "For List with [1, 2, 3, 4, 5], supposed m ==  2 and n == 4\\n\\n**Step1:**\\nThe part I need to reversed is node 2 to node 4, which has `n - m + 1` = 3 nodes.\\nTherefore, I would like to maintain a window with `n - m + 1` nodes with the window's head `whead` and window's tail `wtail`, then if `whead` is head,  `wtail` would be the next `n-m` node from head.\\n\\n-  [123]45 => `whead` is 1 and `wtail` is 3\\n\\n**Step2:**\\nAnd to get to the right reversed portion we want, we need to shift the window `m-1` times\\n\\n- 1[234]5 => `whead` is 2 and `wtail` is 4\\n\\n**Step3:** Isolate the nodes inside the window, reverse the window as [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n\\n**Step4:** combine the outside node with reversed node.\\nTo do so, I need to record the head outside the window `ohead`, and the tail outside the window `otail` \\n\\n- `ohead` is 1, `otail` is 5\\n- 1-[432]-5\\n\\n**Implementation detail:** Since in **step 4**, you need to let `ohead.next = reversed_head`If you create a dummy node, you can save some lines for m == 1 cases, where `ohead` would be `None` and `ohead.next` would fail the program.\\n\\n\\n    class Solution(object):\\n        def reverseBetween(self, head, m, n):\\n            if m >= n:\\n                return head\\n            #Step 1#    \\n            ohead = dummy = ListNode(0)\\n            whead = wtail = head\\n            dummy.next = head\\n            for i in range(n-m):\\n                wtail = wtail.next\\n            #Step 2#  \\n            for i in range(m-1):\\n                ohead, whead, wtail = whead, whead.next, wtail.next\\n            #Step 3#  \\n            otail, wtail.next = wtail.next, None\\n            revhead, revtail = self.reverse(whead)\\n            #Step 4#  \\n            ohead.next, revtail.next = revhead, otail\\n            return dummy.next\\n                \\n        def reverse(self, head):\\n            pre, cur, tail = None, head, head\\n            while cur:\\n                cur.next, pre, cur = pre, cur, cur.next\\n            return pre, tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "For List with [1, 2, 3, 4, 5], supposed m ==  2 and n == 4\\n\\n**Step1:**\\nThe part I need to reversed is node 2 to node 4, which has `n - m + 1` = 3 nodes.\\nTherefore, I would like to maintain a window with `n - m + 1` nodes with the window's head `whead` and window's tail `wtail`, then if `whead` is head,  `wtail` would be the next `n-m` node from head.\\n\\n-  [123]45 => `whead` is 1 and `wtail` is 3\\n\\n**Step2:**\\nAnd to get to the right reversed portion we want, we need to shift the window `m-1` times\\n\\n- 1[234]5 => `whead` is 2 and `wtail` is 4\\n\\n**Step3:** Isolate the nodes inside the window, reverse the window as [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n\\n**Step4:** combine the outside node with reversed node.\\nTo do so, I need to record the head outside the window `ohead`, and the tail outside the window `otail` \\n\\n- `ohead` is 1, `otail` is 5\\n- 1-[432]-5\\n\\n**Implementation detail:** Since in **step 4**, you need to let `ohead.next = reversed_head`If you create a dummy node, you can save some lines for m == 1 cases, where `ohead` would be `None` and `ohead.next` would fail the program.\\n\\n\\n    class Solution(object):\\n        def reverseBetween(self, head, m, n):\\n            if m >= n:\\n                return head\\n            #Step 1#    \\n            ohead = dummy = ListNode(0)\\n            whead = wtail = head\\n            dummy.next = head\\n            for i in range(n-m):\\n                wtail = wtail.next\\n            #Step 2#  \\n            for i in range(m-1):\\n                ohead, whead, wtail = whead, whead.next, wtail.next\\n            #Step 3#  \\n            otail, wtail.next = wtail.next, None\\n            revhead, revtail = self.reverse(whead)\\n            #Step 4#  \\n            ohead.next, revtail.next = revhead, otail\\n            return dummy.next\\n                \\n        def reverse(self, head):\\n            pre, cur, tail = None, head, head\\n            while cur:\\n                cur.next, pre, cur = pre, cur, cur.next\\n            return pre, tail",
                "codeTag": "Java"
            },
            {
                "id": 30681,
                "title": "python-one-pass-concise-solution-with-comments",
                "content": "        \\n    def reverseBetween(self, head, m, n):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(m-1):\\n            pre = pre.next\\n        cur= pre.next\\n        # reverse the defined part \\n        node = None\\n        for _ in xrange(n-m+1):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur= nxt\\n        # connect three parts\\n        pre.next.next = cur\\n        pre.next = node\\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def reverseBetween(self, head, m, n):\\n        dummy = pre = ListNode(0)\\n        dummy.next = head\\n        for _ in xrange(m-1):\\n            pre = pre.next\\n        cur= pre.next\\n        # reverse the defined part \\n        node = None\\n        for _ in xrange(n-m+1):\\n            nxt = cur.next\\n            cur.next = node\\n            node = cur\\n            cur= nxt\\n        # connect three parts\\n        pre.next.next = cur\\n        pre.next = node\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 4011892,
                "title": "video-beat-97-21-python-javascript-java-c",
                "content": "This Python solution beats 97.21%.\\n\\n![Screen Shot 2023-09-07 at 9.31.46.png](https://assets.leetcode.com/users/images/7dd9d408-b0b0-495a-a052-ec386f5e8fdc_1694046724.5898378.png)\\n\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 257 videos as of September 7th, 2023.\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\nhttps://youtu.be/vE__gU1MUnw\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2245\\nThank you for your support!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Check for base cases.\\n   - If the linked list is empty (`not head`) or `left` is equal to `right`, return the original `head` as there is no reversal needed.\\n\\n2. Initialize a `dummy` node to simplify edge cases and connect it to the head of the linked list.\\n   - Create a `dummy` node with a value of 0 and set its `next` pointer to the `head` of the linked list. This dummy node helps in handling the case when `left` is 1.\\n\\n3. Traverse the list to find the (left-1)-th node.\\n   - Initialize a `prev` pointer to `dummy`.\\n   - Loop `left - 1` times to move the `prev` pointer to the node just before the left-th node.\\n\\n4. Reverse the portion of the linked list from the left-th node to the right-th node.\\n   - Initialize a `cur` pointer to `prev.next`.\\n   - Loop `right - left` times to reverse the direction of the pointers in this portion of the linked list:\\n     - Store the next node (`temp`) of `cur` to avoid losing the reference.\\n     - Update the `cur.next` to point to `temp.next`, effectively reversing the direction.\\n     - Move `temp.next` to point to `prev.next`, effectively moving `temp` to the correct position in the reversed portion.\\n     - Update `prev.next` to point to `temp`, making `temp` the new next node of `prev`.\\n\\n5. Return the new head of the modified linked list.\\n   - `dummy.next` points to the head of the modified linked list, so return `dummy.next` as the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0, head)\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        cur = prev.next\\n        for _ in range(right - left):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next = prev.next\\n            prev.next = temp\\n\\n        return dummy.next\\n```\\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) {\\n        return head;\\n    }\\n\\n    const dummy = new ListNode(0, head);\\n    let prev = dummy;\\n\\n    for (let i = 0; i < left - 1; i++) {\\n        prev = prev.next;\\n    }\\n\\n    let cur = prev.next;\\n\\n    for (let i = 0; i < right - left; i++) {\\n        const temp = cur.next;\\n        cur.next = temp.next;\\n        temp.next = prev.next;\\n        prev.next = temp;\\n    }\\n\\n    return dummy.next;    \\n};\\n```\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) {\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        ListNode cur = prev.next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode temp = cur.next;\\n            cur.next = temp.next;\\n            temp.next = prev.next;\\n            prev.next = temp;\\n        }\\n\\n        return dummy.next;        \\n    }\\n}\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) {\\n            return head;\\n        }\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        ListNode* cur = prev->next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = cur->next;\\n            cur->next = temp->next;\\n            temp->next = prev->next;\\n            prev->next = temp;\\n        }\\n\\n        return dummy->next;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        if not head or left == right:\\n            return head\\n\\n        dummy = ListNode(0, head)\\n        prev = dummy\\n\\n        for _ in range(left - 1):\\n            prev = prev.next\\n\\n        cur = prev.next\\n        for _ in range(right - left):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next = prev.next\\n            prev.next = temp\\n\\n        return dummy.next\\n```\n```javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    if (!head || left === right) {\\n        return head;\\n    }\\n\\n    const dummy = new ListNode(0, head);\\n    let prev = dummy;\\n\\n    for (let i = 0; i < left - 1; i++) {\\n        prev = prev.next;\\n    }\\n\\n    let cur = prev.next;\\n\\n    for (let i = 0; i < right - left; i++) {\\n        const temp = cur.next;\\n        cur.next = temp.next;\\n        temp.next = prev.next;\\n        prev.next = temp;\\n    }\\n\\n    return dummy.next;    \\n};\\n```\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || left == right) {\\n            return head;\\n        }\\n\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        ListNode cur = prev.next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode temp = cur.next;\\n            cur.next = temp.next;\\n            temp.next = prev.next;\\n            prev.next = temp;\\n        }\\n\\n        return dummy.next;        \\n    }\\n}\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (!head || left == right) {\\n            return head;\\n        }\\n\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        ListNode* cur = prev->next;\\n\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = cur->next;\\n            cur->next = temp->next;\\n            temp->next = prev->next;\\n            prev->next = temp;\\n        }\\n\\n        return dummy->next;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30876,
                "title": "share-my-java-code",
                "content": "The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. \\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n    \\tListNode dummyhead = new ListNode(0);\\n    \\tdummyhead.next = head;\\n    \\tListNode sublisthead = new ListNode(0);\\n    \\tListNode sublisttail = new ListNode(0);\\n    \\tint count = 1;\\n    \\tListNode pre_cur = dummyhead, cur = head;\\n    \\twhile(count <=n){\\n\\t\\t\\tListNode temp = cur.next;\\n    \\t\\tif (count < m)\\n    \\t\\t\\tpre_cur = cur;\\n    \\t\\telse if (count == m){\\n    \\t\\t\\tsublisttail = cur;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}else if (count > m){\\n    \\t\\t\\tcur.next = sublisthead.next;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}\\n    \\t\\tcur = temp;\\n    \\t\\t++count;\\n    \\t}\\n    \\tpre_cur.next = sublisthead.next;\\n    \\tsublisttail.next = cur;\\n    \\treturn dummyhead.next;\\n    }",
                "solutionTags": [],
                "code": "The basic idea is to build a sub-list when we hit Node m by adding the subsequent nodes to the head of the sub-list one by one until we hit Node n. Then connect the nodes before Node m, the sub-list and the nodes following Node n. \\n\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n    \\tListNode dummyhead = new ListNode(0);\\n    \\tdummyhead.next = head;\\n    \\tListNode sublisthead = new ListNode(0);\\n    \\tListNode sublisttail = new ListNode(0);\\n    \\tint count = 1;\\n    \\tListNode pre_cur = dummyhead, cur = head;\\n    \\twhile(count <=n){\\n\\t\\t\\tListNode temp = cur.next;\\n    \\t\\tif (count < m)\\n    \\t\\t\\tpre_cur = cur;\\n    \\t\\telse if (count == m){\\n    \\t\\t\\tsublisttail = cur;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}else if (count > m){\\n    \\t\\t\\tcur.next = sublisthead.next;\\n    \\t\\t\\tsublisthead.next = cur;\\n    \\t\\t}\\n    \\t\\tcur = temp;\\n    \\t\\t++count;\\n    \\t}\\n    \\tpre_cur.next = sublisthead.next;\\n    \\tsublisttail.next = cur;\\n    \\treturn dummyhead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2310832,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseBetween(ListNode *head, int left, int right){\\n            ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n            dummy->next = head;\\n            for (int i = 0; i < left - 1; i++){\\n                pre = pre->next;\\n            }\\n            cur = pre->next;\\n            for (int i = 0; i < right - left; i++){\\n                ListNode *temp = pre->next;\\n                pre->next = cur->next;\\n                cur->next = cur->next->next;\\n                pre->next->next = temp;\\n            }\\n            return dummy->next;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        ListNode* reverseBetween(ListNode *head, int left, int right){\\n            ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n            dummy->next = head;\\n            for (int i = 0; i < left - 1; i++){\\n                pre = pre->next;\\n            }\\n            cur = pre->next;\\n            for (int i = 0; i < right - left; i++){\\n                ListNode *temp = pre->next;\\n                pre->next = cur->next;\\n                cur->next = cur->next->next;\\n                pre->next->next = temp;\\n            }\\n            return dummy->next;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910770,
                "title": "easy-js-solution",
                "content": "```\\nvar reverseBetween = function(head, m, n) {\\n    let start = head, cur = head;\\n    let i = 1;\\n    while (i < m) {\\n        start = cur;\\n        cur = cur.next;\\n        i++;\\n    }\\n    let prev = null, tail = cur;\\n    while (i <= n) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n        i++;\\n    }\\n    start.next = prev;\\n    tail.next = cur;\\n    return m == 1 ? prev : head; \\n    // if m == 1, we have no need to connect start list with reversed list reversed list itself is the start (or the head)\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseBetween = function(head, m, n) {\\n    let start = head, cur = head;\\n    let i = 1;\\n    while (i < m) {\\n        start = cur;\\n        cur = cur.next;\\n        i++;\\n    }\\n    let prev = null, tail = cur;\\n    while (i <= n) {\\n        let next = cur.next;\\n        cur.next = prev;\\n        prev = cur;\\n        cur = next;\\n        i++;\\n    }\\n    start.next = prev;\\n    tail.next = cur;\\n    return m == 1 ? prev : head; \\n    // if m == 1, we have no need to connect start list with reversed list reversed list itself is the start (or the head)\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292582,
                "title": "2-different-approach-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* it = dummy;\\n        ListNode* pre_it = NULL;\\n        //traverse till left index\\n        for(int i = 0; i < left; i++){\\n            pre_it = it;\\n            it = it->next;\\n        }\\n        \\n        ListNode* itR = it;\\n        ListNode* pre_R = pre_it;\\n        //reverse \\n        for(int i = left; i <= right; i++){\\n            ListNode* forward = itR->next;\\n            itR->next = pre_R;\\n            pre_R = itR;\\n            itR = forward;\\n        }\\n        \\n        //connect\\n        pre_it->next = pre_R;\\n        it->next = itR;\\n\\t\\t\\n        return dummy->next;      \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* left_node = head; \\n        for(int i = 1; i < left; i++) left_node = left_node->next;\\n        \\n        ListNode* node = left_node;\\n        for(int i = 0; i < (right-left+1); i++){\\n            v.push_back(node->val);\\n            node = node->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i = 0; i < v.size(); i++){\\n            left_node->val = v[i];\\n            left_node = left_node->next;\\n        }\\n    return head;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* it = dummy;\\n        ListNode* pre_it = NULL;\\n        //traverse till left index\\n        for(int i = 0; i < left; i++){\\n            pre_it = it;\\n            it = it->next;\\n        }\\n        \\n        ListNode* itR = it;\\n        ListNode* pre_R = pre_it;\\n        //reverse \\n        for(int i = left; i <= right; i++){\\n            ListNode* forward = itR->next;\\n            itR->next = pre_R;\\n            pre_R = itR;\\n            itR = forward;\\n        }\\n        \\n        //connect\\n        pre_it->next = pre_R;\\n        it->next = itR;\\n\\t\\t\\n        return dummy->next;      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* left_node = head; \\n        for(int i = 1; i < left; i++) left_node = left_node->next;\\n        \\n        ListNode* node = left_node;\\n        for(int i = 0; i < (right-left+1); i++){\\n            v.push_back(node->val);\\n            node = node->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        for(int i = 0; i < v.size(); i++){\\n            left_node->val = v[i];\\n            left_node = left_node->next;\\n        }\\n    return head;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167109,
                "title": "python3-one-pass-iterative-solution-beats-95-50-with-figure-explanation",
                "content": "**Idea**\\nReverse a part of linked list can be performed by iteratively move nodes to the beginning within the reverse part\\n![image](https://assets.leetcode.com/users/images/f5d2b8e7-a60f-4708-95f0-ccefec71d3b2_1618866607.652895.png)\\n\\n\\n**Implementation**\\n```python\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next or left == right:\\n            return head\\n        \\n        dummy_head = ListNode(val=-1, next=head)\\n        p_prev = dummy_head\\n        \\n        # Iterate p_prev to the (left-1)-th node\\n        for _ in range(left - 1):\\n            p_prev = p_prev.next\\n            \\n        p_cur = p_prev.next # p_cur is at the left-th node\\n        \\n        # Within the reverse part, iteratively move the next node of p_cur to the beginning\\n        for _ in range(right - left):\\n            p_next = p_cur.next\\n            p_cur.next = p_next.next\\n            p_next.next = p_prev.next\\n            p_prev.next = p_next\\n        \\n        return dummy_head.next\\n```\\n\\nExplanation:\\n- In the first loop `for _ in range(left - 1)`, we iterate `p_prev` to the (`left-1`) -th node\\n- In the second loop, within the reverse part, we iteratively shift the next node of `p_cur` to the beginning of the reverse part\\n\\t![image](https://assets.leetcode.com/users/images/3e5ec220-c2f8-4b5f-9e9f-012fabfa4e86_1618867097.78969.png)\\n> For the links modification in the second loop, it is easy to get lost or create loop accidentally. To handle this problem, I have a small trick.\\n> 1. Figure out how the list looks like **before** and **after** links modification\\n> ![image](https://assets.leetcode.com/users/images/89404580-5ca4-47b4-b61c-7ba26cf586f3_1618868088.0298142.png)\\n> 2. Mark the order of nodes alphabetically and start modifying from the **last** letter\\n> ![image](https://assets.leetcode.com/users/images/3f51fe85-c465-4656-a9fc-5eed981d3e33_1618868258.3117332.png)\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next or left == right:\\n            return head\\n        \\n        dummy_head = ListNode(val=-1, next=head)\\n        p_prev = dummy_head\\n        \\n        # Iterate p_prev to the (left-1)-th node\\n        for _ in range(left - 1):\\n            p_prev = p_prev.next\\n            \\n        p_cur = p_prev.next # p_cur is at the left-th node\\n        \\n        # Within the reverse part, iteratively move the next node of p_cur to the beginning\\n        for _ in range(right - left):\\n            p_next = p_cur.next\\n            p_cur.next = p_next.next\\n            p_next.next = p_prev.next\\n            p_prev.next = p_next\\n        \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607485,
                "title": "simple-with-explanation-o-n-same-as-problem-206",
                "content": "\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        # Comparing with Problem 206: just need to find the start position \\n        # then reverse (same as 206)\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        pre = dummy\\n        cur = dummy.next\\n        \\n        # find the position\\n        for i in range(1,m):\\n            cur = cur.next\\n            pre = pre.next\\n        \\n        \\n        # reverse\\n        for i in range(n-m):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next  = pre.next\\n            pre.next = temp\\n        \\n        return dummy.next\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        # Comparing with Problem 206: just need to find the start position \\n        # then reverse (same as 206)\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        \\n        pre = dummy\\n        cur = dummy.next\\n        \\n        # find the position\\n        for i in range(1,m):\\n            cur = cur.next\\n            pre = pre.next\\n        \\n        \\n        # reverse\\n        for i in range(n-m):\\n            temp = cur.next\\n            cur.next = temp.next\\n            temp.next  = pre.next\\n            pre.next = temp\\n        \\n        return dummy.next\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 4013431,
                "title": "beats-100-o-1-space-easy-code-video-in-depth-c-java-python",
                "content": "# intuition\\n Just do manipulation of pointers and call reverse function.\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n### Problem Description\\n\\nThe problem asks to reverse a specified portion of a singly linked list between positions `left` and `right`. You are given the head of the linked list and two integers, `left` and `right`, where `1 <= left <= right <= n` (n is the number of nodes in the linked list). Your task is to reverse the nodes between positions `left` and `right` and return the modified linked list.\\n\\n### Solution Explanation\\n\\n#### `rev` Function\\n\\nThe `rev` function is a helper function used to reverse a linked list. It takes the head of a linked list as input and returns the head of the reversed linked list.\\n\\nHere\\'s how it works:\\n\\n1. If the input `head` is `NULL` or it has only one node (i.e., `head->next` is `NULL`), there\\'s nothing to reverse, so it returns `head` as it is.\\n\\n2. Create three pointers: `curr` (current), `prev` (previous), and `nex` (next) to traverse the linked list.\\n\\n3. Start a `while` loop that continues until `curr` becomes `NULL`, which means we have traversed the entire original linked list.\\n\\n4. Inside the loop:\\n   - Save the next node in `nex`.\\n   - Update `curr->next` to point to the previous node (`prev`), effectively reversing the link.\\n   - Move `prev` to `curr` and `curr` to `nex` for the next iteration.\\n\\n5. Finally, return `prev` as the new head of the reversed linked list.\\n\\n#### `reverseBetween` Function\\n\\nThe `reverseBetween` function is the main function that solves the problem by reversing the specified portion of the linked list between positions `left` and `right`. It takes the head of the linked list, `left`, and `right` as input and returns the modified linked list.\\n\\nHere\\'s how it works:\\n\\n1. Similar to the `rev` function, it first handles the base cases. If `head` is `NULL` or has only one node, it returns `head` as it is.\\n\\n2. If `left` is equal to `right`, it means there\\'s no need to reverse anything, so it also returns `head` as it is.\\n\\n3. Initialize several pointers and a boolean variable `f`:\\n   - `curr` points to the current node while traversing the linked list.\\n   - `t` will eventually point to the node at position `left`.\\n   - `prev` is used to keep track of the previous node.\\n   - `s` will eventually point to the node at position `right + 1`.\\n   - `v` will point to the node just before position `left`.\\n   - `f` is a boolean flag that indicates whether `left` is equal to 1.\\n\\n4. If `left` is 1, set `f` to `true`, and `t` to `curr` initially. This is done to handle the case where we need to reverse from the beginning of the list.\\n\\n5. Use a loop to traverse the list:\\n   - When we reach `left`, set `v` to `prev` and `t` to `curr`. `v` is used to keep track of the node just before the reverse portion, and `t` is used to keep track of the first node in the reverse portion.\\n   - When we reach `right`, set `s` to `curr->next` and break the loop. This separates the portion to be reversed from the rest of the list.\\n\\n6. If `f` is `false`, it means `left` is not 1, so we need to disconnect the nodes before the reverse portion. Set `v->next` to `NULL`.\\n\\n7. Call the `rev` function to reverse the portion of the linked list starting from `t`. This returns the new head of the reversed portion.\\n\\n8. Connect the reversed portion to the rest of the list:\\n   - Set `t->next` to `s` to link the end of the reversed portion to the node at position `right + 1`.\\n   - If `f` is `false`, connect `v` to the new head of the reversed portion.\\n\\n9. If `f` is `true`, it means we reversed the portion starting from the beginning, so update `head` to point to the new head of the reversed portion.\\n\\n10. Return `head` as the final result.\\n\\n### Overall Explanation\\n\\nThe given code effectively reverses the portion of the linked list between positions `left` and `right` and returns the modified linked list. It uses the `rev` function to reverse a linked list and carefully handles the edge cases and pointer manipulation to achieve the desired result. The time complexity of this solution is O(n), where n is the number of nodes in the linked list.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1))$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode*rev(ListNode*head){\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*prev=NULL;\\n        ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(left==right)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*t=NULL;\\n        ListNode*prev=NULL;\\n        ListNode*s=NULL;\\n        ListNode*v=NULL;\\n        bool f=0;\\n        if(left==1){\\n            f=1;\\n            t=curr;\\n        }\\n        int s1=1;\\n        while(curr!=NULL){\\n            if(s1==left&&f==0){\\n                v=prev;\\n                t=curr;\\n            }\\n            if(s1==right){\\n                s=curr->next;\\n                curr->next=NULL;\\n                break;\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            s1++;\\n        }\\n        if(f==0){\\n        v->next=NULL;\\n        }\\n        ListNode*ans=rev(t);\\n        t->next=s;\\n        if(f==0)\\n        v->next=ans;\\n        if(f==1)\\n            head=ans;\\n        return head;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || head.next == null)\\n            return head;\\n        if (left == right)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode t = null;\\n        ListNode prev = null;\\n        ListNode s = null;\\n        ListNode v = null;\\n        boolean f = false;\\n\\n        if (left == 1) {\\n            f = true;\\n            t = curr;\\n        }\\n\\n        int s1 = 1;\\n\\n        while (curr != null) {\\n            if (s1 == left && !f) {\\n                v = prev;\\n                t = curr;\\n            }\\n\\n            if (s1 == right) {\\n                s = curr.next;\\n                curr.next = null;\\n                break;\\n            }\\n\\n            prev = curr;\\n            curr = curr.next;\\n            s1++;\\n        }\\n\\n        if (!f) {\\n            v.next = null;\\n        }\\n\\n        ListNode ans = reverseList(t);\\n        t.next = s;\\n\\n        if (!f) {\\n            v.next = ans;\\n        }\\n\\n        if (f) {\\n            head = ans;\\n        }\\n\\n        return head;\\n    }\\n\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n\\n        while (curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head\\n\\n        curr = head\\n        t = None\\n        prev = None\\n        s = None\\n        v = None\\n        f = False\\n\\n        if left == 1:\\n            f = True\\n            t = curr\\n\\n        s1 = 1\\n\\n        while curr:\\n            if s1 == left and not f:\\n                v = prev\\n                t = curr\\n\\n            if s1 == right:\\n                s = curr.next\\n                curr.next = None\\n                break\\n\\n            prev = curr\\n            curr = curr.next\\n            s1 += 1\\n\\n        if not f:\\n            v.next = None\\n\\n        ans = self.reverseList(t)\\n        t.next = s\\n\\n        if not f:\\n            v.next = ans\\n\\n        if f:\\n            head = ans\\n\\n        return head\\n\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        curr = head\\n        prev = None\\n        next_node = None\\n\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n\\n        return prev\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "``` C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode*rev(ListNode*head){\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*prev=NULL;\\n        ListNode*nex=NULL;\\n        while(curr!=NULL){\\n            nex=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nex;\\n        }\\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        if(left==right)\\n            return head;\\n        ListNode*curr=head;\\n        ListNode*t=NULL;\\n        ListNode*prev=NULL;\\n        ListNode*s=NULL;\\n        ListNode*v=NULL;\\n        bool f=0;\\n        if(left==1){\\n            f=1;\\n            t=curr;\\n        }\\n        int s1=1;\\n        while(curr!=NULL){\\n            if(s1==left&&f==0){\\n                v=prev;\\n                t=curr;\\n            }\\n            if(s1==right){\\n                s=curr->next;\\n                curr->next=NULL;\\n                break;\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            s1++;\\n        }\\n        if(f==0){\\n        v->next=NULL;\\n        }\\n        ListNode*ans=rev(t);\\n        t->next=s;\\n        if(f==0)\\n        v->next=ans;\\n        if(f==1)\\n            head=ans;\\n        return head;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if (head == null || head.next == null)\\n            return head;\\n        if (left == right)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode t = null;\\n        ListNode prev = null;\\n        ListNode s = null;\\n        ListNode v = null;\\n        boolean f = false;\\n\\n        if (left == 1) {\\n            f = true;\\n            t = curr;\\n        }\\n\\n        int s1 = 1;\\n\\n        while (curr != null) {\\n            if (s1 == left && !f) {\\n                v = prev;\\n                t = curr;\\n            }\\n\\n            if (s1 == right) {\\n                s = curr.next;\\n                curr.next = null;\\n                break;\\n            }\\n\\n            prev = curr;\\n            curr = curr.next;\\n            s1++;\\n        }\\n\\n        if (!f) {\\n            v.next = null;\\n        }\\n\\n        ListNode ans = reverseList(t);\\n        t.next = s;\\n\\n        if (!f) {\\n            v.next = ans;\\n        }\\n\\n        if (f) {\\n            head = ans;\\n        }\\n\\n        return head;\\n    }\\n\\n    public ListNode reverseList(ListNode head) {\\n        if (head == null || head.next == null)\\n            return head;\\n\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        ListNode next = null;\\n\\n        while (curr != null) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        return prev;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n        if left == right:\\n            return head\\n\\n        curr = head\\n        t = None\\n        prev = None\\n        s = None\\n        v = None\\n        f = False\\n\\n        if left == 1:\\n            f = True\\n            t = curr\\n\\n        s1 = 1\\n\\n        while curr:\\n            if s1 == left and not f:\\n                v = prev\\n                t = curr\\n\\n            if s1 == right:\\n                s = curr.next\\n                curr.next = None\\n                break\\n\\n            prev = curr\\n            curr = curr.next\\n            s1 += 1\\n\\n        if not f:\\n            v.next = None\\n\\n        ans = self.reverseList(t)\\n        t.next = s\\n\\n        if not f:\\n            v.next = ans\\n\\n        if f:\\n            head = ans\\n\\n        return head\\n\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next:\\n            return head\\n\\n        curr = head\\n        prev = None\\n        next_node = None\\n\\n        while curr:\\n            next_node = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next_node\\n\\n        return prev\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012057,
                "title": "c-5ms-fastest-easy-to-understand",
                "content": "# C++ | 5ms | Fastest | Easy to Understand\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (head == nullptr) return head;\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        ListNode* prev = dummy;\\n        for (int i = 0; i < left-1; i++) {\\n            prev = prev->next;\\n        }\\n        ListNode* curr = prev->next;\\n        \\n        for (int i = 0; i < right-left; i++) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = prev->next;\\n            prev->next = next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if (head == nullptr) return head;\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        ListNode* prev = dummy;\\n        for (int i = 0; i < left-1; i++) {\\n            prev = prev->next;\\n        }\\n        ListNode* curr = prev->next;\\n        \\n        for (int i = 0; i < right-left; i++) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = prev->next;\\n            prev->next = next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291851,
                "title": "easy-to-understand-java-solution-explanation-with-comments-and-diagrams",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n/*  Approach:  \\n\\n                                                   reverse\\n    Input: m = 4, n = 6                      m  <----------->  n\\n    \\n                  a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n                 head       \\n    \\n    \\n    i. Store preHead as parent of head to return (preHead.next) at last.\\n       It will return the updated list with new head at that position.\\n\\n     \\n          0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head\\n\\n\\n    ii. Loop prev till reaches position m - 1\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev\\n       \\n\\n\\n    iii. Reverse list from m to n\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev     curr     temp\\n       \\n    \\n        reverseHead = null\\n        \\n                                            d   ->   e   ->   f   ->   g\\n                                           curr     temp                   temp = curr.next\\n                                           \\n                                  revH  <-  d        e   ->   f   ->   g\\n                                   --      curr     temp                   curr.next = revH\\n                                           \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr                   revH = curr, curr = temp\\n                                   \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr     temp          temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------\\n                            \\n                                        <-   d   <-  e        f   ->   g\\n                                   --      revH     curr     temp           curr.next = revH\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr           revH = curr, curr = temp\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr     temp  temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------           \\n                                   \\n                                   \\n                                        <-   d   <-  e   <-   f        g\\n                                   --               revH     curr     temp    curr.next = revH\\n                                    \\n                                        <-   d   <-  e   <-   f        g\\n                                   --                        revH     curr    revH = curr, curr = temp\\n                                   \\n                                   \\n    \\n               Reversed sublist :  __   <-   d   <-  e   <-   f     <=>   f  ->  e  ->  d  -> __\\n    \\n    \\n    iv. Connect the reversed list\\n\\n\\n    \\n    \\n            \\n            \\n*/\\n\\nclass Solution {\\n    \\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        \\n        int m = left, n = right;\\n        \\n        /*  Corner Case */\\n        \\n        if (head == null || head.next == null || m <= 0 || n <= 0 || m == n) {\\n            return head;\\n        }\\n        \\n        // to store the head index, to return the final updated head at this index.\\n        \\n        ListNode preHead = new ListNode(0);  \\n        preHead.next = head;\\n        \\n        // Traverse the list till position m. Position m -> index m-1 => loop till 0 to m-2.\\n        \\n        ListNode prev = preHead;\\n        \\n        for (int i = 0; i <= m-2; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Reverse the list from position m to n.\\n        \\n        ListNode curr = prev.next;\\n        ListNode temp = null;\\n        \\n        ListNode reverseHead = null;\\n        \\n        for (int i = 0; i <= n-m; i++) {\\n            \\n            temp = curr.next;         // save next of current for next iteration\\n            curr.next = reverseHead;  // reset current to point back not forward\\n            \\n            reverseHead = curr;       // make current as head of new reverseHead list\\n            curr = temp;              // move to next node\\n            \\n        }\\n        \\n        \\n        // Connect the reversed list with the prev node (position m-1)\\n        \\n        prev.next.next = curr;\\n        prev.next = reverseHead;\\n        \\n     \\n    return preHead.next;\\n        \\n        \\n    }\\n}\\n```\\n\\n\\n**Please Upvote if you find it helpful. Happy Coding!**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\n\\n/*  Approach:  \\n\\n                                                   reverse\\n    Input: m = 4, n = 6                      m  <----------->  n\\n    \\n                  a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n                 head       \\n    \\n    \\n    i. Store preHead as parent of head to return (preHead.next) at last.\\n       It will return the updated list with new head at that position.\\n\\n     \\n          0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head\\n\\n\\n    ii. Loop prev till reaches position m - 1\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev\\n       \\n\\n\\n    iii. Reverse list from m to n\\n    \\n                                            m                 n\\n         0  ->   a   ->   b   ->   c   ->   d   ->   e   ->   f   ->   g   ->   h\\n       preHead   head             prev     curr     temp\\n       \\n    \\n        reverseHead = null\\n        \\n                                            d   ->   e   ->   f   ->   g\\n                                           curr     temp                   temp = curr.next\\n                                           \\n                                  revH  <-  d        e   ->   f   ->   g\\n                                   --      curr     temp                   curr.next = revH\\n                                           \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr                   revH = curr, curr = temp\\n                                   \\n                                        <-  d        e   ->   f   ->   g\\n                                   --      revH     curr     temp          temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------\\n                            \\n                                        <-   d   <-  e        f   ->   g\\n                                   --      revH     curr     temp           curr.next = revH\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr           revH = curr, curr = temp\\n                                   \\n                                        <-   d   <-  e        f   ->   g\\n                                   --               revH     curr     temp  temp = curr.next\\n                                   \\n                            -----------------------------------------------------------------------------------           \\n                                   \\n                                   \\n                                        <-   d   <-  e   <-   f        g\\n                                   --               revH     curr     temp    curr.next = revH\\n                                    \\n                                        <-   d   <-  e   <-   f        g\\n                                   --                        revH     curr    revH = curr, curr = temp\\n                                   \\n                                   \\n    \\n               Reversed sublist :  __   <-   d   <-  e   <-   f     <=>   f  ->  e  ->  d  -> __\\n    \\n    \\n    iv. Connect the reversed list\\n\\n\\n    \\n    \\n            \\n            \\n*/\\n\\nclass Solution {\\n    \\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        \\n        int m = left, n = right;\\n        \\n        /*  Corner Case */\\n        \\n        if (head == null || head.next == null || m <= 0 || n <= 0 || m == n) {\\n            return head;\\n        }\\n        \\n        // to store the head index, to return the final updated head at this index.\\n        \\n        ListNode preHead = new ListNode(0);  \\n        preHead.next = head;\\n        \\n        // Traverse the list till position m. Position m -> index m-1 => loop till 0 to m-2.\\n        \\n        ListNode prev = preHead;\\n        \\n        for (int i = 0; i <= m-2; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        // Reverse the list from position m to n.\\n        \\n        ListNode curr = prev.next;\\n        ListNode temp = null;\\n        \\n        ListNode reverseHead = null;\\n        \\n        for (int i = 0; i <= n-m; i++) {\\n            \\n            temp = curr.next;         // save next of current for next iteration\\n            curr.next = reverseHead;  // reset current to point back not forward\\n            \\n            reverseHead = curr;       // make current as head of new reverseHead list\\n            curr = temp;              // move to next node\\n            \\n        }\\n        \\n        \\n        // Connect the reversed list with the prev node (position m-1)\\n        \\n        prev.next.next = curr;\\n        prev.next = reverseHead;\\n        \\n     \\n    return preHead.next;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322510,
                "title": "cpp-solution-faster-than-100-of-submissions-faster-than-55-runtime",
                "content": "Here\\'s an easy to understand iterative solution to the problem of reversing a sublist within a list given the boundaries. The code has comments to help you understand better, why the conditions are as such.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        if(head == NULL)\\n            return NULL; //Handled an edge case\\n        \\n        ListNode *temp, *curr = head, *prev = NULL;\\n        while(m>1)\\n        {\\n            prev = curr;\\n            curr = curr->next;\\n            m--;\\n            n--; //Only relative shifting of variable n. Doesn\\'t make a difference to the logic\\n        }\\n        //Through this We have traversed till the mth node.\\n        \\n        ListNode *con = prev, *tail = curr;\\n        //Two nodes to help the set the connections of the list at the end of sublist reversal\\n        \\n        while(n>0)\\n        { //The actual reversal happens here\\n            temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n            n--;\\n        }\\n        //Setting the connections to complete sublist reversal\\n        if(con!= NULL) \\n        {\\n            con->next = prev;\\n        }\\n        else\\n        { //To handle the case if m=0\\n            head = prev;\\n        }\\n        \\n        tail->next = curr; //Even if current node is NULL, the tail node is the last node of the new list which in turn points to null\\n        return head;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        if(head == NULL)\\n            return NULL; //Handled an edge case\\n        \\n        ListNode *temp, *curr = head, *prev = NULL;\\n        while(m>1)\\n        {\\n            prev = curr;\\n            curr = curr->next;\\n            m--;\\n            n--; //Only relative shifting of variable n. Doesn\\'t make a difference to the logic\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4011894,
                "title": "mastering-linked-list-reversal-a-step-by-step-guide-easy-to-understand-beginner",
                "content": "# PROBLEM UNDERSTANDING:\\n- **The code appears** to be a C++ implementation of a function `reverseBetween `within a class `Solution`. \\n- This function takes as input a singly-linked list represented by a `ListNode` and two integers, `left` and `right`. \\n- It aims to reverse the elements of the linked list from the `left`-th node to the `right`-th node (inclusive).\\n\\n# Here\\'s a step-by-step explanation of the code:\\n**Step 1: Initializing Pointers**\\n```\\nListNode* temp = new ListNode(-1);\\nListNode* prev = temp;\\ntemp->next = head;\\n\\n```\\n- `temp` is a new **ListNode created with a value of -1**. This is used as a dummy node to simplify the logic.\\n- `prev` is initialized to `temp`, which **initially points to the same location as** `temp`.\\n- `temp->next` is set to point to the head of the input linked list (`head`).\\n\\n**Step 2: Moving to the Left Position:**\\n```\\nfor (int i = 0; i < left - 1; i++) {\\n    prev = prev->next;\\n}\\n\\n```\\n- This loop moves the `prev` pointer to the node just before the `left`-th node in the linked list.\\n\\n**Step 3: Reversing the Nodes:**\\n```\\nListNode* cur = prev->next;\\nfor (int i = 0; i < right - left; i++) {\\n    ListNode* ptr = prev->next;\\n    prev->next = cur->next;\\n    cur->next = cur->next->next;\\n    prev->next->next = ptr;\\n}\\n\\n```\\n- In this loop, a pointer `cur` is used to keep track of the current node.\\n- For each iteration, a pointer `ptr` is used to temporarily store `prev->next`.\\n- **The code then rearranges the pointers to reverse** the direction of the nodes between `left` and `right`.\\n\\n**Step 4: Returning the Result:**\\n```\\nreturn temp->next;\\n\\n```\\n- Finally, the modified linked list is returned. `temp->next` points to the new head of the linked list after reversing the specified portion.\\n\\n# Strategy to Tackle the Problem:\\n\\n**1. Initialize a dummy node (`temp`) to simplify handling edge cases.**\\n**1. Move `prev` to the node just before the `left`-th node using a loop.**\\n**1. Reverse the nodes between left and right using a loop.**\\n**1. Return the modified linked list.**\\n\\n\\n\\n\\n\\n\\n\\n# Intuition\\n- The code employs a common technique for reversing a portion of a linked list. \\n- It uses pointers (`prev`, `cur`, and `ptr`) to manipulate the connections between nodes, effectively reversing the direction of the nodes between `left` and `right`.\\n\\n# Approach\\n- Initialize `temp` and `prev` pointers.\\n- Move `prev` to the node before the `left`-th node.\\n- Reverse nodes between `left` and `right` using a loop.\\n- Return the modified linked list.\\n\\n# Complexity\\n- **Time complexity:**\\n 1. **Initialization:** The initialization part involves creating a dummy node (`temp`) and moving prev to the `left-1`-th node, both of which take constant time, `O(1)`.\\n\\n 1. **Reversing the Nodes:** The loop that reverses the nodes between `left` and right runs for `right - left` iterations. \\n     - Inside the loop, there are constant-time operations like pointer assignments. \\n     - Therefore, this part of the code also has a time complexity of `O(right - left)`, which can be simplified to `O(n)`, where n is the number of nodes in the linked list.\\n\\n**Overall, the time complexity of the code is `O(n)`, where n is the number of nodes in the linked list.**\\n\\n- **Space complexity:**\\n1. **Additional Pointers:** The code uses a few extra pointers (`temp`, `prev`, `cur`, and `ptr`) to keep track of nodes and perform the reversal. These pointers occupy a constant amount of space regardless of the size of the linked list. \\n2. Therefore, the `space complexity is O(1)`, indicating constant space usage.\\n\\n# PLEASE UPVOTE\\uD83D\\uDE0D\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n      ListNode*temp= new ListNode(-1);\\n      ListNode*prev=temp;\\n      temp->next=head;\\n      for(int i=0;i<left-1;i++)\\n      {\\n          prev=prev->next;\\n      }\\n     ListNode*cur=prev->next;\\n    for(int i=0;i<right-left;i++)\\n    {\\n       ListNode *ptr = prev->next;\\n       prev->next = cur->next;\\n       cur->next = cur->next->next;\\n       prev->next->next = ptr;\\n    }\\n     return temp->next;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode temp = new ListNode(-1);\\n        ListNode prev = temp;\\n        temp.next = head;\\n        \\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode cur = prev.next;\\n        \\n        for (int i = 0; i < right - left; i++) {\\n            ListNode ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n        \\n        return temp.next;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def reverseBetween(self, head, left, right):\\n        temp = ListNode(-1)\\n        prev = temp\\n        temp.next = head\\n        \\n        for i in range(left - 1):\\n            prev = prev.next\\n        \\n        cur = prev.next\\n        \\n        for i in range(right - left):\\n            ptr = prev.next\\n            prev.next = cur.next\\n            cur.next = cur.next.next\\n            prev.next.next = ptr\\n        \\n        return temp.next\\n\\n```\\n# JAVASCRIPT\\n```\\nclass ListNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n    }\\n}\\n\\nclass Solution {\\n    reverseBetween(head, left, right) {\\n        const temp = new ListNode(-1);\\n        let prev = temp;\\n        temp.next = head;\\n\\n        for (let i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        let cur = prev.next;\\n\\n        for (let i = 0; i < right - left; i++) {\\n            let ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n\\n        return temp.next;\\n    }\\n}\\n\\n```\\n# GO\\n```\\npackage main\\n\\ntype ListNode struct {\\n    Val  int\\n    Next *ListNode\\n}\\n\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    temp := &ListNode{Val: -1}\\n    prev := temp\\n    temp.Next = head\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    cur := prev.Next\\n\\n    for i := 0; i < right-left; i++ {\\n        ptr := prev.Next\\n        prev.Next = cur.Next\\n        cur.Next = cur.Next.Next\\n        prev.Next.Next = ptr\\n    }\\n\\n    return temp.Next\\n}\\n\\n```\\n# \\uD83D\\uDC7E\\u2763PLEASE UPVOTE\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nListNode* temp = new ListNode(-1);\\nListNode* prev = temp;\\ntemp->next = head;\\n\\n```\n```\\nfor (int i = 0; i < left - 1; i++) {\\n    prev = prev->next;\\n}\\n\\n```\n```\\nListNode* cur = prev->next;\\nfor (int i = 0; i < right - left; i++) {\\n    ListNode* ptr = prev->next;\\n    prev->next = cur->next;\\n    cur->next = cur->next->next;\\n    prev->next->next = ptr;\\n}\\n\\n```\n```\\nreturn temp->next;\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n      ListNode*temp= new ListNode(-1);\\n      ListNode*prev=temp;\\n      temp->next=head;\\n      for(int i=0;i<left-1;i++)\\n      {\\n          prev=prev->next;\\n      }\\n     ListNode*cur=prev->next;\\n    for(int i=0;i<right-left;i++)\\n    {\\n       ListNode *ptr = prev->next;\\n       prev->next = cur->next;\\n       cur->next = cur->next->next;\\n       prev->next->next = ptr;\\n    }\\n     return temp->next;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode temp = new ListNode(-1);\\n        ListNode prev = temp;\\n        temp.next = head;\\n        \\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n        \\n        ListNode cur = prev.next;\\n        \\n        for (int i = 0; i < right - left; i++) {\\n            ListNode ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n        \\n        return temp.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def reverseBetween(self, head, left, right):\\n        temp = ListNode(-1)\\n        prev = temp\\n        temp.next = head\\n        \\n        for i in range(left - 1):\\n            prev = prev.next\\n        \\n        cur = prev.next\\n        \\n        for i in range(right - left):\\n            ptr = prev.next\\n            prev.next = cur.next\\n            cur.next = cur.next.next\\n            prev.next.next = ptr\\n        \\n        return temp.next\\n\\n```\n```\\nclass ListNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.next = null;\\n    }\\n}\\n\\nclass Solution {\\n    reverseBetween(head, left, right) {\\n        const temp = new ListNode(-1);\\n        let prev = temp;\\n        temp.next = head;\\n\\n        for (let i = 0; i < left - 1; i++) {\\n            prev = prev.next;\\n        }\\n\\n        let cur = prev.next;\\n\\n        for (let i = 0; i < right - left; i++) {\\n            let ptr = prev.next;\\n            prev.next = cur.next;\\n            cur.next = cur.next.next;\\n            prev.next.next = ptr;\\n        }\\n\\n        return temp.next;\\n    }\\n}\\n\\n```\n```\\npackage main\\n\\ntype ListNode struct {\\n    Val  int\\n    Next *ListNode\\n}\\n\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    temp := &ListNode{Val: -1}\\n    prev := temp\\n    temp.Next = head\\n\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n\\n    cur := prev.Next\\n\\n    for i := 0; i < right-left; i++ {\\n        ptr := prev.Next\\n        prev.Next = cur.Next\\n        cur.Next = cur.Next.Next\\n        prev.Next.Next = ptr\\n    }\\n\\n    return temp.Next\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292413,
                "title": "easy-use-of-stack-c-beginners-friendly",
                "content": "I used curr pointer to store the value of node into the stack and popped out while traversing the previous pointer.\\n\\n```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = head;\\n        \\n        stack<int> st;\\n        for(int i=0; i<left-1; i++)\\n        {\\n             curr=curr->next;\\n             prev=prev->next;\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            st.push(curr->val);\\n            curr=curr->next;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            prev->val = st.top();\\n            st.pop();\\n            prev = prev->next;\\n        }\\n        \\n      return head;  \\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = head;\\n        \\n        stack<int> st;\\n        for(int i=0; i<left-1; i++)\\n        {\\n             curr=curr->next;\\n             prev=prev->next;\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            st.push(curr->val);\\n            curr=curr->next;\\n        }\\n \\xA0 \\xA0 \\xA0 \\xA0for(int i=0; i<=(right-left); i++)\\n        {\\n            prev->val = st.top();\\n            st.pop();\\n            prev = prev->next;\\n        }\\n        \\n      return head;  \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30827,
                "title": "c-in-14-lines",
                "content": "    class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *slow = &dummy;\\n            n -= m;\\n            while (--m)\\n                slow = slow->next;\\n            ListNode *fast = slow->next, *tmp;\\n            while (n--) {\\n                tmp = fast->next;\\n                fast->next = fast->next->next;\\n                tmp->next = slow->next;\\n                slow->next = tmp;\\n            }\\n            return dummy.next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode dummy(0);\\n            dummy.next = head;\\n            ListNode *slow = &dummy;\\n            n -= m;\\n            while (--m)\\n                slow = slow->next;\\n            ListNode *fast = slow->next, *tmp;\\n            while (n--) {\\n                tmp = fast->next;\\n                fast->next = fast->next->next;\\n                tmp->next = slow->next;\\n                slow->next = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30873,
                "title": "240ms-java-solution",
                "content": "    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy=new ListNode(0);\\n            dummy.next=head;\\n            ListNode pre=dummy; //pre is the node before orignal M\\n            ListNode M=head;    //M is after pre\\n            \\n            for(int i=1;i<m;i++){ //Move pre and M to orignal place\\n                pre=pre.next;\\n                M=M.next;\\n            }\\n            \\n            for(int i=0;i<n-m;i++){ \\n                ListNode current=M.next; //Both pre and M are all fixed, only current is assigned every time to M.next. M is pushed back everytime\\n                M.next=current.next;     //Move current to the position after pre\\n                current.next=pre.next;\\n                pre.next=current;\\n            }\\n            \\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode dummy=new ListNode(0);\\n            dummy.next=head;\\n            ListNode pre=dummy; //pre is the node before orignal M\\n            ListNode M=head;    //M is after pre\\n            \\n            for(int i=1;i<m;i++){ //Move pre and M to orignal place\\n                pre=pre.next;\\n                M=M.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4012465,
                "title": "java-beats-100-0ms-c-2ms-two-solutions-commented-code",
                "content": "# Problem Description\\nGiven a singly linked list and two integers `left` and `right`, where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return the reversed list.\\n\\n\\n---\\n\\n# Proposed Solutions\\n## 1. Using an Array \\n### Approach\\n1. **Copy** the elements of the given Linked List into **another array**.\\n2. **Reverse** the required range of the copied array. \\n3. **Copy** the array elements **into the Linked List**.\\n4. **Return** the modified Linked List.\\n\\n\\n### Complexity\\n- **Time complexity**:\\nSince we are traversing the LinkedList twice and the array once, it is `3*N`. so time complexity is `O(N)`.\\n\\n- **Space complexity**:\\nWe store the values of linked list in an array then space complexity is `O(N)`.\\n\\n\\n## 2. Inplace Reversing\\n### Approach\\n1. Make a **dummy node** with dummy value **before the head**.\\n2. Initialize a pointer `pervLeft` and make it **points** to the node **just before** the first node in our range.\\n3. Apply **inplace reversing** method by maintaing current node and shift it to the right like the picture below :\\n![leet.PNG](https://assets.leetcode.com/users/images/807730e7-9afc-4cd3-9f69-d863bbd51c38_1694063044.7778773.png)\\n4. **return** the modified node.  \\n\\n\\n### Complexity\\n- **Time complexity**:\\nThere are two for loops, it is `2*N`. so time complexity is `O(N)`.\\n\\n- **Space complexity**:\\nWe store only couple of additional nodes (prevLeft, current and nextNode), then is is `O(1)`.\\n\\n\\n---\\n\\n\\n# Code\\n## 1. Using an Array \\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a list to store the values of the linked list\\n        List<Integer> valueList = new ArrayList<Integer>();\\n        \\n        // Traverse the linked list and store its values in the list\\n        ListNode current = head;\\n        while (current != null) {\\n            valueList.add(current.val);\\n            current = current.next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the value list\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int num1 = valueList.get(i);\\n            int num2 = valueList.get(right - 1 - shift);\\n            \\n            // Swap the values in the value list\\n            valueList.set(i, num2);\\n            valueList.set(right - 1 - shift, num1);\\n            \\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != null) {\\n            current.val = valueList.get(ptr++);\\n            current = current.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a vector to store the values of the linked list\\n        vector<int> valueList;\\n        \\n        // Traverse the linked list and store its values in the vector\\n        ListNode *current = head;\\n        while (current != nullptr) {\\n            valueList.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the vector\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int temp = valueList[i];\\n            valueList[i] = valueList[right - 1 - shift];\\n            valueList[right - 1 - shift] = temp;\\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != nullptr) {\\n            current->val = valueList[ptr++];\\n            current = current->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n## 2. Inplace Reversing\\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevLeft = dummy;\\n        \\n        // Move \\'prevLeft\\' to the node just before the \\'left\\' position\\n        for (int i = 0; i < left - 1; ++i) {\\n            prevLeft = prevLeft.next;\\n        }\\n        \\n        // Initialize the current node within the sublist\\n        ListNode current = prevLeft.next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prevLeft.next;\\n            prevLeft.next = nextNode;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode* dummy = new ListNode(1);\\n        dummy->next = head;\\n        \\n        // Find the node just before the \\'left\\' position\\n        ListNode* prevLeft  = dummy;\\n        for (int i = 0; i < left - 1; i++) {\\n            prevLeft  = prevLeft ->next;\\n        }\\n        \\n        // Initialize the current pointer within the sublist\\n        ListNode* current = prevLeft ->next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = prevLeft ->next;\\n            prevLeft ->next = current->next;\\n            current->next = current->next->next;\\n            prevLeft ->next->next = temp;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Linked List"
                ],
                "code": "```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a list to store the values of the linked list\\n        List<Integer> valueList = new ArrayList<Integer>();\\n        \\n        // Traverse the linked list and store its values in the list\\n        ListNode current = head;\\n        while (current != null) {\\n            valueList.add(current.val);\\n            current = current.next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the value list\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int num1 = valueList.get(i);\\n            int num2 = valueList.get(right - 1 - shift);\\n            \\n            // Swap the values in the value list\\n            valueList.set(i, num2);\\n            valueList.set(right - 1 - shift, num1);\\n            \\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != null) {\\n            current.val = valueList.get(ptr++);\\n            current = current.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a vector to store the values of the linked list\\n        vector<int> valueList;\\n        \\n        // Traverse the linked list and store its values in the vector\\n        ListNode *current = head;\\n        while (current != nullptr) {\\n            valueList.push_back(current->val);\\n            current = current->next;\\n        }\\n        \\n        int shift = 0; // Initialize a shift variable to handle reversing\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\' in the vector\\n        for (int i = left - 1; i < right && i < right - 1 - shift; i++) {\\n            int temp = valueList[i];\\n            valueList[i] = valueList[right - 1 - shift];\\n            valueList[right - 1 - shift] = temp;\\n            shift++;\\n        }\\n        \\n        // Update the original linked list with the modified values\\n        current = head;\\n        int ptr = 0;\\n        while (current != nullptr) {\\n            current->val = valueList[ptr++];\\n            current = current->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prevLeft = dummy;\\n        \\n        // Move \\'prevLeft\\' to the node just before the \\'left\\' position\\n        for (int i = 0; i < left - 1; ++i) {\\n            prevLeft = prevLeft.next;\\n        }\\n        \\n        // Initialize the current node within the sublist\\n        ListNode current = prevLeft.next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; ++i) {\\n            ListNode nextNode = current.next;\\n            current.next = nextNode.next;\\n            nextNode.next = prevLeft.next;\\n            prevLeft.next = nextNode;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Create a dummy node to simplify edge cases\\n        ListNode* dummy = new ListNode(1);\\n        dummy->next = head;\\n        \\n        // Find the node just before the \\'left\\' position\\n        ListNode* prevLeft  = dummy;\\n        for (int i = 0; i < left - 1; i++) {\\n            prevLeft  = prevLeft ->next;\\n        }\\n        \\n        // Initialize the current pointer within the sublist\\n        ListNode* current = prevLeft ->next;\\n        \\n        // Reverse the sublist from \\'left\\' to \\'right\\'\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode* temp = prevLeft ->next;\\n            prevLeft ->next = current->next;\\n            current->next = current->next->next;\\n            prevLeft ->next->next = temp;\\n        }\\n        \\n        // Return the modified linked list (skip the dummy node)\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384023,
                "title": "javascript-solution-time-o-n-space-o-1-with-very-detailed-explanation",
                "content": "We can split this problem into 2 problems\\n1. Find where the reversal should begin (start of left)\\n2. Reverse the section between left to right\\n\\n**Where the reversal should begin**\\nWe need to set a pointer to the node right before the reversed section of the list. If we keep a pointer `position`  and use the condition `position<left` we can traverse through the linked list and set a `start` pointer to the node prior to where the reversal starts.\\n\\n**Reverse teh section between left and right**\\nNow that we have the node prior to where the reversal begins, we need to set a `tail` pointer that points to the beginning of the reversed list. Reason? Because we know the first node will be the tail of the `reversedList` we need that reference in order to assign its next value to whatever of the original list is left over. \\n\\nOnce we set the tail to the `current` node which is the beginning of the reversed list, we can traverse through this section with the condition `position >= left && position <= right` which is the portion that needs to be reversed. I highly recommend checking out the [reverse linked list problem](https://leetcode.com/problems/reverse-linked-list/) which is all the logic we need here. We simply just reverse this portion of the linkedlist and set it to `reversedList`.\\n\\nNow because we have the `start` pointer before the reversal begin, all we need to do is set the starts next property to the `reversedList` and because the `tail` pointer is now set to the end of the `reversedlist` we can set the tail\\'s next pointer to the `current` node which is the left over portion of the list. \\n\\n**One caveat**\\nThe reason why this ternary return statement is needed: `left > 1 ? head : reversedList` at the end is because if `left` is equal to 1 there is essentially no start value ever set. We are reversing from the beginning of the list, so we can just return the `reversedList` which will have the reversed portion of the list and whatever is left over.\\n\\nHope this helps and keep working hard!\\n\\n```\\nvar reverseBetween = function(head, left, right){\\n    let current = head, start = head, position = 1;\\n    \\n    while(position < left) {\\n        start = current\\n        current = current.next;\\n        position ++;\\n    }\\n    \\n    let reversedList = null,  tail = current;\\n    \\n    while(position >= left && position <= right) {\\n        const next = current.next;\\n        current.next = reversedList;\\n        reversedList = current;\\n        current = next;\\n        position ++\\n    }\\n    start.next = reversedList;\\n    tail.next = current;\\n    \\n    return left > 1 ? head : reversedList\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar reverseBetween = function(head, left, right){\\n    let current = head, start = head, position = 1;\\n    \\n    while(position < left) {\\n        start = current\\n        current = current.next;\\n        position ++;\\n    }\\n    \\n    let reversedList = null,  tail = current;\\n    \\n    while(position >= left && position <= right) {\\n        const next = current.next;\\n        current.next = reversedList;\\n        reversedList = current;\\n        current = next;\\n        position ++\\n    }\\n    start.next = reversedList;\\n    tail.next = current;\\n    \\n    return left > 1 ? head : reversedList\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291670,
                "title": "c-with-diagram-example-comments",
                "content": "##### The main idea is to advance the left pointer to the location just before from where we want to inverse the linked list (because we can\\'nt travel backwards ). After that we have to reverse the linked list in the range [0, right- left ).\\n#### Example :\\n\\nGive Linked List : 1 --> 2 --> 3 --> 4 --> 5 --> 6\\nleft = 2 , right = 5\\nAdd Dummy node ( To handle the case when left =1 )\\ndummy -> 1 -> 2 -> 3 -> 4 -> 5 -> 6\\nAfter first loop , LEFT_PTR will be pointing to 1 and LEFT to 2\\n\\nNow reversing for one iteration,(**with logic of inserting element after LEFT_PTR)**\\n```\\ntemp = node(2)\\nnode(1) ->next =  node(2) ->next   (i.e node(1) next is node(3))\\nnode(2) ->next = node(2) ->next ->next (i.e node(2) next is node(4))\\nnode(1) ->next ->next = node(2)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5adcc438-8cfe-4311-a4d5-23361b10b965_1624436981.9676034.png)\\n\\n##### CODE : \\n```\\n\\t\\t//If right == left then no need to reverse\\n\\t\\tif(!head or left == right)\\n            return head;\\n\\t\\t\\n\\t\\t//inserting dummy node in front\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next =head;\\n\\t\\t\\n\\t\\t// L is pointer to the left node to reverse ans LEFT_PTR is pointer left of L (just before L)\\n        ListNode *L ,*LEFT_PTR=dummy;\\n        for(int i=0;i<left-1;i++)\\n            LEFT_PTR = LEFT_PTR->next;\\n\\t\\t\\n        L = LEFT_PTR->next;\\n\\t\\t \\n\\t\\t //JUST REVERSE LOGIC HERE\\n        for(int i=0;i<right-left;i++){\\n            ListNode *tmp  = LEFT_PTR->next;\\n            LEFT_PTR->next = L->next;\\n            L->next  =  L->next->next;\\n            LEFT_PTR->next->next = tmp;\\n        }\\n        return dummy->next;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntemp = node(2)\\nnode(1) ->next =  node(2) ->next   (i.e node(1) next is node(3))\\nnode(2) ->next = node(2) ->next ->next (i.e node(2) next is node(4))\\nnode(1) ->next ->next = node(2)\\n```\n```\\n\\t\\t//If right == left then no need to reverse\\n\\t\\tif(!head or left == right)\\n            return head;\\n\\t\\t\\n\\t\\t//inserting dummy node in front\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next =head;\\n\\t\\t\\n\\t\\t// L is pointer to the left node to reverse ans LEFT_PTR is pointer left of L (just before L)\\n        ListNode *L ,*LEFT_PTR=dummy;\\n        for(int i=0;i<left-1;i++)\\n            LEFT_PTR = LEFT_PTR->next;\\n\\t\\t\\n        L = LEFT_PTR->next;\\n\\t\\t \\n\\t\\t //JUST REVERSE LOGIC HERE\\n        for(int i=0;i<right-left;i++){\\n            ListNode *tmp  = LEFT_PTR->next;\\n            LEFT_PTR->next = L->next;\\n            L->next  =  L->next->next;\\n            LEFT_PTR->next->next = tmp;\\n        }\\n        return dummy->next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30831,
                "title": "short-java-solution-for-reverse-linked-list-ii",
                "content": "    public class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode curr = new ListNode(0);\\n            curr.next = head;\\n            int k = n - m;\\n            int j = m;\\n            while(j > 1){\\n                curr = curr.next;\\n                j--;\\n            }\\n            ListNode reve = curr.next;\\n            while(k > 0){\\n                ListNode temp = reve.next;\\n                reve.next = reve.next.next;\\n                temp.next = curr.next;\\n                curr.next = temp;\\n                k--;\\n            }\\n            if(m == 1){\\n                head = curr.next;\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode reverseBetween(ListNode head, int m, int n) {\\n            ListNode curr = new ListNode(0);\\n            curr.next = head;\\n            int k = n - m;\\n            int j = m;\\n            while(j > 1){\\n                curr = curr.next;\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 30724,
                "title": "my-2-ms-c-solution-o-n-time-and-o-1-space-with-comments",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode *reverseBetween(struct ListNode *head, int m, int n) {\\n        \\n    \\n        //handle case for empty list\\n        if(head == NULL){\\n            return NULL;\\n        }\\n    \\n        //handle special case for one node list\\n        if(head->next == NULL){\\n            return head;\\n        }\\n        \\n        //handle input values of m & n , if m==n - no need to do anything \\n        if(m >= n){\\n            return head;\\n        }\\n        \\n\\n        struct ListNode * prev  = head;    \\n        struct ListNode * curr  = head;\\n        struct ListNode * next  = head;\\n\\n        struct ListNode *mTh   = NULL; //mTh node\\n        struct ListNode *nTh   = NULL; //nTh node         \\n        struct ListNode *mPrev = NULL; // node just previous to mTh node\\n        struct ListNode *nNext = NULL; // node next to the nTh node\\n        \\n    \\n        for(int i = 1 ; curr != NULL ; i++){\\n    \\n            next = curr->next ;\\n    \\n            if(i == m){\\n               //when we reach the mTh node, save mTh and mPrevious\\n                mPrev = prev ; \\n                mTh   = curr ; \\n            }\\n    \\n            if(i> m && i <= n){    \\n                 //revese links if we fall within the m and n range (include n)\\n                 curr->next = prev;\\n            }\\n            \\n            if(i == n ){\\n               //when we reach the nTh node, save nTh and nNext\\n                nNext = next ;\\n                nTh   = curr ;  \\n            }\\n                \\n            prev = curr; \\n            curr = next;\\n        }\\n        \\n        if(m == 1 ){\\n            //handle special case if head needs to be changed since m==1 \\n            mTh->next = nNext;\\n            head = nTh;\\n        }else{\\n            mPrev->next  = nTh ; \\n            mTh->next = nNext; \\n        }\\n    \\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     struct ListNode *next;\\n     * };\\n     */\\n    struct ListNode *reverseBetween(struct ListNode *head, int m, int n) {\\n        \\n    \\n        //handle case for empty list\\n        if(head == NULL){\\n            return NULL;\\n        }\\n    \\n        //handle special case for one node list\\n        if(head->next == NULL){\\n            return head;\\n        }\\n        \\n        //handle input values of m & n , if m==n - no need to do anything \\n        if(m >= n){\\n            return head;\\n        }\\n        \\n\\n        struct ListNode * prev  = head;    \\n        struct ListNode * curr  = head;\\n        struct ListNode * next  = head;\\n\\n        struct ListNode *mTh   = NULL; //mTh node\\n        struct ListNode *nTh   = NULL; //nTh node         \\n        struct ListNode *mPrev = NULL; // node just previous to mTh node\\n        struct ListNode *nNext = NULL; // node next to the nTh node\\n        \\n    \\n        for(int i = 1 ; curr != NULL ; i++){\\n    \\n            next = curr->next ;\\n    \\n            if(i == m){\\n               //when we reach the mTh node, save mTh and mPrevious\\n                mPrev = prev ; \\n                mTh   = curr ; \\n            }\\n    \\n            if(i> m && i <= n){    \\n                 //revese links if we fall within the m and n range (include n)\\n                 curr->next = prev;\\n            }\\n            \\n            if(i == n ){\\n               //when we reach the nTh node, save nTh and nNext\\n                nNext = next ;\\n                nTh   = curr ;  \\n            }\\n                \\n            prev = curr; \\n            curr = next;\\n        }\\n        \\n        if(m == 1 ){\\n            //handle special case if head needs to be changed since m==1 \\n            mTh->next = nNext;\\n            head = nTh;\\n        }else{\\n            mPrev->next  = nTh ; \\n            mTh->next = nNext; \\n        }\\n    \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4012847,
                "title": "c-solution-100-faster-with-test-cases-and-asked-in-tech-inteviews",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 7},\\n    {\"Microsoft\", 5},\\n    {\"Amazon\", 5},\\n    {\"Google\", 3},\\n    {\"Apple\", 2},\\n    {\"Adobe\", 2}\\n};\\n```\\n# C++ Code\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *head = new ListNode(1);\\n\\thead->next = new ListNode(2);\\n\\thead->next->next = new ListNode(3);\\n\\thead->next->next->next = new ListNode(4);\\n\\thead->next->next->next->next = new ListNode(5);\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\thead = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1), *L2 = new ListNode(2), *L3 = new ListNode(3);\\n\\tListNode *L4 = new ListNode(4), *L5 = new ListNode(5);\\n\\n\\tL1->next = L2;\\n\\tL2->next = L3;\\n\\tL3->next = L4;\\n\\tL4->next = L5;\\n\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Facebook\", 7},\\n    {\"Microsoft\", 5},\\n    {\"Amazon\", 5},\\n    {\"Google\", 3},\\n    {\"Apple\", 2},\\n    {\"Adobe\", 2}\\n};\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *head = new ListNode(1);\\n\\thead->next = new ListNode(2);\\n\\thead->next->next = new ListNode(3);\\n\\thead->next->next->next = new ListNode(4);\\n\\thead->next->next->next->next = new ListNode(5);\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\thead = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(head, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1), *L2 = new ListNode(2), *L3 = new ListNode(3);\\n\\tListNode *L4 = new ListNode(4), *L5 = new ListNode(5);\\n\\n\\tL1->next = L2;\\n\\tL2->next = L3;\\n\\tL3->next = L4;\\n\\tL4->next = L5;\\n\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```\n```C++ []\\n#include <iostream>\\n\\nstruct ListNode {\\n\\tint val;\\n\\tListNode *next;\\n\\tListNode() : val(0), next(nullptr) {}\\n\\tListNode(int x) : val(x), next(nullptr) {}\\n\\tListNode(int x, ListNode *next) : val(x), next(next) {}\\n};\\n\\nclass Solution {\\npublic:\\n\\tListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\t\\tif (!head || !head->next || left == right) \\n\\t\\t\\treturn head;\\n\\n\\t\\tListNode dummy(0), *prev = &dummy, *curr = head;\\n\\t\\tdummy.next = head;\\n\\t\\tfor (int i = 1; i < left; i++) {\\n\\t\\t\\tprev = curr;\\n\\t\\t\\tcurr = curr->next;\\n\\t\\t}\\n\\n\\t\\tListNode *tail = curr, *prev2 = nullptr;\\n\\t\\tfor (int i = left; i <= right; i++) {\\n\\t\\t\\tListNode *next = curr->next;\\n\\t\\t\\tcurr->next = prev2;\\n\\t\\t\\tprev2 = curr;\\n\\t\\t\\tcurr = next;\\n\\t\\t}\\n\\n\\t\\tprev->next = prev2;\\n\\t\\ttail->next = curr;\\n\\t\\treturn dummy.next;\\n\\t}\\n};\\n\\nvoid main() {\\n\\t//Input: head = [1,2,3,4,5], left = 2, right = 4\\n\\tListNode *L1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\\n\\tint left = 2, right = 4;\\n\\n\\tSolution oSolution;\\n\\tListNode *res = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \" ;\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\t// Input: head = [5], left = 1, right = 1\\n\\tL1 = new ListNode(5);\\n\\tleft = 1, right = 4;\\n\\tres = oSolution.reverseBetween(L1, left, right);\\n\\n\\tstd::cout << \"[ \";\\n\\twhile (res) {\\n\\t\\tstd::cout << res->val << \" \";\\n\\t\\tres = res->next;\\n\\t}\\n\\tstd::cout << \"]\";\\n\\tstd::cout << std::endl;\\n\\n\\tsystem(\"pause\");\\n}\\n/**\\nOutput:\\n[ 1 4 3 2 5 ]\\n[ 5 ]\\n**/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2310950,
                "title": "python-simple-and-clean-solution",
                "content": "```python\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        p1, p2 = None, head\\n        for _ in range(left - 1):\\n            p1, p2 = p2, p2.next\\n        \\n        p4, p5 = p2, p2.next\\n        for _ in range(right - left):\\n            p5.next, p4, p5 = p4, p5, p5.next\\n\\n        p2.next = p5\\n        if p1:\\n            p1.next, p4 = p4, head\\n        \\n        return p4\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n\\n        p1, p2 = None, head\\n        for _ in range(left - 1):\\n            p1, p2 = p2, p2.next\\n        \\n        p4, p5 = p2, p2.next\\n        for _ in range(right - left):\\n            p5.next, p4, p5 = p4, p5, p5.next\\n\\n        p2.next = p5\\n        if p1:\\n            p1.next, p4 = p4, head\\n        \\n        return p4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222461,
                "title": "visual-explanation-drawings-with-easiest-approach",
                "content": "Since linkedlist problems are playing with pointers.. Its very easy to understand by diagrams. To keep it simple I just used classic iterative approach of reversing linked list but with two extra variables to reverse the required portion in **one pass**.. UPVOTE IT IF U LIKE MY EFFORTS ;)\\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        if left == right:\\n            return head\\n        p = dummy\\n        for i in range(left-1):\\n            p = p.next\\n        \\n        #initialising prev = None, cur = p\\'s next, start = p\\'s next, new = cur\\'s next\\n        prev = None\\n        cur = p.next\\n        start = cur\\n        new = cur.next\\n        p.next = None\\n        for i in range(right-left):\\n            # storing new\\'s next node\\n            store = new.next\\n            \\n            #reversing link between nodes\\n            new.next = cur\\n            cur.next = prev\\n            \\n            # updating prev,cur,new\\n            prev = cur\\n            cur = new\\n            new = store\\n        \\n        #finishing touch\\n        p.next = cur\\n        start.next = store\\n        \\n        #returning head\\n        return dummy.next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b001bbb5-b975-426d-a78a-6e21a6f21f0c_1656669945.6396508.jpeg)\\n![image](https://assets.leetcode.com/users/images/2c5df3ff-30cf-4662-ac61-281186fcd6b2_1656670598.9884937.jpeg)\\n![image](https://assets.leetcode.com/users/images/bb930a89-efac-46f6-aa85-5e2dd5bc255c_1656670610.17001.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        dummy = ListNode(0,head)\\n        if left == right:\\n            return head\\n        p = dummy\\n        for i in range(left-1):\\n            p = p.next\\n        \\n        #initialising prev = None, cur = p\\'s next, start = p\\'s next, new = cur\\'s next\\n        prev = None\\n        cur = p.next\\n        start = cur\\n        new = cur.next\\n        p.next = None\\n        for i in range(right-left):\\n            # storing new\\'s next node\\n            store = new.next\\n            \\n            #reversing link between nodes\\n            new.next = cur\\n            cur.next = prev\\n            \\n            # updating prev,cur,new\\n            prev = cur\\n            cur = new\\n            new = store\\n        \\n        #finishing touch\\n        p.next = cur\\n        start.next = store\\n        \\n        #returning head\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339407,
                "title": "easy-code-one-pass-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int cnt = 0;\\n        \\n        while(curr != NULL){\\n            cnt++;\\n            if(cnt == left){\\n                \\n                ListNode* inner_curr = curr;\\n                ListNode* inner_prev = NULL;\\n                \\n                while(cnt <= right){\\n                    ListNode* nextptr = inner_curr->next;\\n                    inner_curr->next = inner_prev;\\n                    inner_prev = inner_curr;\\n                    inner_curr = nextptr;\\n                    cnt++;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev->next = inner_prev;\\n                }\\n                else{\\n                    head = inner_prev;\\n                }\\n                curr->next = inner_curr;\\n                \\n                break;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        int cnt = 0;\\n        \\n        while(curr != NULL){\\n            cnt++;\\n            if(cnt == left){\\n                \\n                ListNode* inner_curr = curr;\\n                ListNode* inner_prev = NULL;\\n                \\n                while(cnt <= right){\\n                    ListNode* nextptr = inner_curr->next;\\n                    inner_curr->next = inner_prev;\\n                    inner_prev = inner_curr;\\n                    inner_curr = nextptr;\\n                    cnt++;\\n                }\\n                \\n                if(prev != NULL){\\n                    prev->next = inner_prev;\\n                }\\n                else{\\n                    head = inner_prev;\\n                }\\n                curr->next = inner_curr;\\n                \\n                break;\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038167,
                "title": "javascript-solution-with-easy-explanation-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Takes a singly linked list and two integers as inputs\\nreverses the order of the elements of the list between the indices (left, right) inclusively.\\n2. Uses two pointers, head and tail along with a dummy variable to perform the reverse operation.\\n3. Iterates the list using head pointer till it reaches the left pointer.\\n4. Uses tail pointer to mark the first element which needs to be reversed.\\n5. Uses a while loop that iterates till the left pointer becomes equal to the right pointer to perform the reversal operation .\\n6. Returns the head of the modified list which is the dummy.next variable\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the function reverseBetween is O(n), where n is the number of elements in the linked list.\\n\\nThe function iterates through the list twice. First, it uses a while loop to move the head pointer to the starting point of the sublist that needs to be reversed. The second while loop performs the reversal of the elements which is taking at most n steps. The rest of the operations like moving pointers, swapping links etc all takes O(1) so the overall time complexity is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs far as space complexity is concerned, it is O(1). The function uses a few variables (dummy, head, tail, next, and curr) to perform the reversal, but it doesn\\'t use any additional data structure like an array or a stack, so the space complexity is constant. The function only uses constant extra memory throughout its execution.\\n# Note\\nIt is important to note that this is for the singly linked list if it were doubly linked list the time complexity would have been O(n/2) and space complexity would have been O(1\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nconst reverseBetween = (list, left, right) => {\\n  const dummy = new ListNode(0, list);\\n  let head = dummy;\\n  let curr = 1;\\n\\n  while (curr++ < left) head = head.next;\\n\\n  let tail = head.next;\\n  while (left++ < right) {\\n    const next = tail.next; \\n    tail.next = next.next; \\n    next.next = head.next; \\n    head.next = next;\\n  }\\n  return dummy.next;\\n};\\n```\\n# \\n Please upvote if you like this solution.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nconst reverseBetween = (list, left, right) => {\\n  const dummy = new ListNode(0, list);\\n  let head = dummy;\\n  let curr = 1;\\n\\n  while (curr++ < left) head = head.next;\\n\\n  let tail = head.next;\\n  while (left++ < right) {\\n    const next = tail.next; \\n    tail.next = next.next; \\n    next.next = head.next; \\n    head.next = next;\\n  }\\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310994,
                "title": "python3-easy-in-one-go-explained-with-and-without-extra-space",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        values = []                        # to stores the values that needed to be reverse\\n        nodes = []                         # to keep track of the nodes which needs to be reverse\\n        counter = 0\\n        curr = head\\n        while curr:\\n            counter += 1\\n            if counter >= left and counter <= right:\\n                values.append(curr.val)     #  | adding value and nodes in the list\\n                nodes.append(curr)          #  |\\n            curr = curr.next\\n        for node in nodes:\\n            node.val = values.pop(-1)       #  replace the value of nodes\\n        return head\\n```\\nAND\\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next or left == right:          # base case\\n            return head\\n        temp = ListNode(val=-1e9)\\n        temp.next = head\\n        curr = temp\\n        for _ in range(left - 1):               # iterate through the list\\n            curr = curr.next\\n            \\n            \\n        temp_curr = curr.next\\n        for _ in range(right - left):           # reverse the list\\n            nxt = temp_curr.next\\n            temp_curr.next = nxt.next\\n            nxt.next = curr.next\\n            curr.next = nxt\\n\\n        return temp.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        values = []                        # to stores the values that needed to be reverse\\n        nodes = []                         # to keep track of the nodes which needs to be reverse\\n        counter = 0\\n        curr = head\\n        while curr:\\n            counter += 1\\n            if counter >= left and counter <= right:\\n                values.append(curr.val)     #  | adding value and nodes in the list\\n                nodes.append(curr)          #  |\\n            curr = curr.next\\n        for node in nodes:\\n            node.val = values.pop(-1)       #  replace the value of nodes\\n        return head\\n```\n```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next or left == right:          # base case\\n            return head\\n        temp = ListNode(val=-1e9)\\n        temp.next = head\\n        curr = temp\\n        for _ in range(left - 1):               # iterate through the list\\n            curr = curr.next\\n            \\n            \\n        temp_curr = curr.next\\n        for _ in range(right - left):           # reverse the list\\n            nxt = temp_curr.next\\n            temp_curr.next = nxt.next\\n            nxt.next = curr.next\\n            curr.next = nxt\\n\\n        return temp.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921952,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\\n        var left_head = head\\n        var left_tail: ListNode?\\n        var current = head\\n        var index = 1\\n        \\n        while index < left {\\n            left_tail = current\\n            current = current?.next\\n            index += 1 \\n        }\\n\\n        var mid_tail = current\\n        var node0: ListNode? = current\\n        var node1: ListNode? = node0?.next\\n        var node2: ListNode? = node1?.next\\n        \\n        while index < right {\\n            node1?.next = node0\\n            node0 = node1\\n            node1 = node2\\n            node2 = node2?.next\\n            index += 1\\n        }\\n\\n        if left_tail == nil {\\n            mid_tail?.next = node1\\n            return node0\\n            \\n        } else {\\n            left_tail?.next = node0\\n            mid_tail?.next = node1\\n            return left_head\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\\n        var left_head = head\\n        var left_tail: ListNode?\\n        var current = head\\n        var index = 1\\n        \\n        while index < left {\\n            left_tail = current\\n            current = current?.next\\n            index += 1 \\n        }\\n\\n        var mid_tail = current\\n        var node0: ListNode? = current\\n        var node1: ListNode? = node0?.next\\n        var node2: ListNode? = node1?.next\\n        \\n        while index < right {\\n            node1?.next = node0\\n            node0 = node1\\n            node1 = node2\\n            node2 = node2?.next\\n            index += 1\\n        }\\n\\n        if left_tail == nil {\\n            mid_tail?.next = node1\\n            return node0\\n            \\n        } else {\\n            left_tail?.next = node0\\n            mid_tail?.next = node1\\n            return left_head\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853388,
                "title": "c-easy-to-understand-code",
                "content": "**Please upvote if you find this helpful :)**\\n\\n```\\nclass Solution {\\npublic:\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n    if(head == NULL)\\n        return head; \\n    \\n    \\n    ListNode *curr = head;\\n    ListNode *prev = nullptr;\\n    int k = 1;\\n    while(k<m)\\n    {\\n        prev = curr;\\n        curr = curr->next;\\n        k++;\\n    }\\n      \\n    ListNode *temp = curr->next;\\n    \\n    ListNode *join1 = prev, *join2 = curr;\\n\\n    while(k<=n)\\n    { \\n        temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        k++;\\n    }\\n    \\n    if(join1!= NULL) \\n    {\\n        join1->next = prev;\\n    }\\n    else\\n    { \\n        head = prev;\\n    }\\n    \\n    join2->next = curr; \\n    return head;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nListNode* reverseBetween(ListNode* head, int m, int n) \\n{\\n    if(head == NULL)\\n        return head; \\n    \\n    \\n    ListNode *curr = head;\\n    ListNode *prev = nullptr;\\n    int k = 1;\\n    while(k<m)\\n    {\\n        prev = curr;\\n        curr = curr->next;\\n        k++;\\n    }\\n      \\n    ListNode *temp = curr->next;\\n    \\n    ListNode *join1 = prev, *join2 = curr;\\n\\n    while(k<=n)\\n    { \\n        temp = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = temp;\\n        k++;\\n    }\\n    \\n    if(join1!= NULL) \\n    {\\n        join1->next = prev;\\n    }\\n    else\\n    { \\n        head = prev;\\n    }\\n    \\n    join2->next = curr; \\n    return head;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151384,
                "title": "javascript-solution",
                "content": "```js\\nfunction reverseBetween(head, m, n) {\\n  const before = { next: head };\\n  let prev = before;\\n\\n  while (--m) {\\n    prev = prev.next;\\n    --n;\\n  }\\n\\n  let curr = prev.next;\\n  while (--n) {\\n    let next = curr.next;\\n    curr.next = next.next;\\n    next.next = prev.next;\\n    prev.next = next;\\n  }\\n\\n  return before.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction reverseBetween(head, m, n) {\\n  const before = { next: head };\\n  let prev = before;\\n\\n  while (--m) {\\n    prev = prev.next;\\n    --n;\\n  }\\n\\n  let curr = prev.next;\\n  while (--n) {\\n    let next = curr.next;\\n    curr.next = next.next;\\n    next.next = prev.next;\\n    prev.next = next;\\n  }\\n\\n  return before.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430686,
                "title": "easy-to-understand-step-by-step-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Check for special cases (empty list, single node, left and right positions are the same).\\n2. Traverse the list until we reach the left position, keeping track of previous node, current node and count.\\n3. The left position becomes the new start of the reversed list.\\nReverse the nodes from left to right by keeping track of next node and setting the current node\\'s next pointer to the previous node.\\n4. The right position becomes the new end of the reversed list.\\n5. Connect the reversed list with the rest of the original list by setting the next pointer of start node to the node after right position, and next pointer of previous node to the end node.\\n6. If left position was the first node, return the end node as new head of the list. Else, return the original head node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given implementation is O(n), where n is the length of the linked list. This is because we traverse the linked list only once, and perform constant-time operations for each node.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the implementation is O(1), as we use only constant extra space for the variables used in the algorithm, and do not use any additional data structures to store the nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n    if(head == NULL || head->next == NULL || left == right) {\\n        return head;\\n    }\\n    \\n    ListNode *start = NULL, *end = NULL, *temp = head, *prev = NULL, *next = NULL;\\n    int cnt = 1;\\n\\n    // Traverse the list until we reach the left position\\n    while(cnt < left) {\\n        prev = temp;\\n        temp = temp->next;\\n        cnt++;\\n    }\\n    start = temp; // The left position becomes the new start of the reversed list\\n\\n    // Reverse the nodes from left to right position\\n    while(cnt <= right) {\\n        next = temp->next;\\n        temp->next = end;\\n        end = temp;\\n        temp = next;\\n        cnt++;\\n    }\\n\\n    // Connect the reversed list with the rest of the original list\\n    start->next = temp;\\n    if(prev != NULL) {\\n        prev->next = end;\\n        return head; // The left position was not the first node\\n    }\\n    return end; // The left position was the first node\\n}\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/523c089a-bf72-4b59-aa88-dccd424608a9_1681816403.0643857.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n    if(head == NULL || head->next == NULL || left == right) {\\n        return head;\\n    }\\n    \\n    ListNode *start = NULL, *end = NULL, *temp = head, *prev = NULL, *next = NULL;\\n    int cnt = 1;\\n\\n    // Traverse the list until we reach the left position\\n    while(cnt < left) {\\n        prev = temp;\\n        temp = temp->next;\\n        cnt++;\\n    }\\n    start = temp; // The left position becomes the new start of the reversed list\\n\\n    // Reverse the nodes from left to right position\\n    while(cnt <= right) {\\n        next = temp->next;\\n        temp->next = end;\\n        end = temp;\\n        temp = next;\\n        cnt++;\\n    }\\n\\n    // Connect the reversed list with the rest of the original list\\n    start->next = temp;\\n    if(prev != NULL) {\\n        prev->next = end;\\n        return head; // The left position was not the first node\\n    }\\n    return end; // The left position was the first node\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602516,
                "title": "simple-solution-explained-with-images",
                "content": "This is solution was implemented by @firemanysome ( https://leetcode.com/problems/reverse-linked-list-ii/discuss/30666/Simple-Java-solution-with-clear-explanation/221870 ). I just added images for better understanding.\\nSo if you find it helpful please upvote so others can benefit.\\n\\n```    \\n        ListNode fakeHead = new ListNode(-1);\\n        fakeHead.next = head;\\n        ListNode prev = fakeHead;\\n        ListNode curr = fakeHead.next;\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/170cdd26-ee46-476e-be7b-ee8429ab5e06_1638184968.5516498.png)\\n\\n  ```\\n        int i=1;\\n        while(i<left){\\n            prev = curr;\\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        ListNode node = prev;\\n  ```\\n  ![image](https://assets.leetcode.com/users/images/29c99523-e025-4850-a213-ab30cc1ada86_1638185026.5081031.png)\\n\\n        while(i<=right){\\n            ListNode next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            i++;\\n        }\\n![image](https://assets.leetcode.com/users/images/2905b5fb-ebda-4121-aa95-f3c3b4b692a2_1638185048.7788653.png)\\n``` \\n\\n        node.next.next = curr;\\n        node.next = prev;\\n        \\n        return fakeHead.next;\\n```\\n![image](https://assets.leetcode.com/users/images/1a273093-dbba-4b4b-9932-d6050a36dc8a_1638185063.6721435.png)\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```    \\n        ListNode fakeHead = new ListNode(-1);\\n        fakeHead.next = head;\\n        ListNode prev = fakeHead;\\n        ListNode curr = fakeHead.next;\\n  ```\n```\\n        int i=1;\\n        while(i<left){\\n            prev = curr;\\n            curr = curr.next;\\n            i++;\\n        }\\n        \\n        ListNode node = prev;\\n  ```\n``` \\n\\n        node.next.next = curr;\\n        node.next = prev;\\n        \\n        return fakeHead.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553812,
                "title": "python-o-n-in-one-pass-85-w-visualization",
                "content": "Python O(n) in one-pass. \\n\\n---\\n**Abstract Model & Algorithm**:\\n\\nTerminology\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392151.png)\\n\\n---\\n\\nStep_#1:\\nReverse the linkage on specified interval\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392161.png)\\n\\n---\\n\\nStep_#2:\\nUpdate the linkage on boundary\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1585392168.png)\\n\\n\\n---\\n**Implementation**:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        if m == n:\\n            # Quick response for empty reverse interval\\n            return head\\n        \\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        \\n        cur, prev = head, dummy_head\\n        cur_idx = 1\\n        \\n        # left sentry is the the m-th node\\n        # right sentry is the the n-th node\\n        left_sentry, right_sentry = None, None\\n        \\n        # left junction is the (m-1)-th node\\n        # right junction is the (n+1)-th node\\n        left_junction, right_junction = None, None\\n        \\n        rev = False\\n        \\n        while cur:\\n            \\n            if rev:\\n                # now we are in reverse interval\\n                \\n                # Backup original next node\\n                ori_next = cur.next\\n                \\n                # Let current node point to previous node\\n                cur.next = prev\\n                \\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = ori_next\\n                \\n                # Handle for right junction node\\n                if cur_idx == n:\\n                    right_sentry = prev\\n                    right_junction = cur\\n\\n                    # Construct new linkage based on left junction and right junction\\n                    left_junction.next = right_sentry\\n                    left_sentry.next = right_junction\\n\\n                    # turn off reverse flag\\n                    rev = False              \\n                \\n                \\n            else:\\n                # now we are in normal interval\\n                \\n                # Handle for left junction node\\n                if cur_idx == m:\\n                \\n                    left_sentry = cur\\n                    left_junction = prev\\n                    \\n                    # turn on reverse flag\\n                    rev = True\\n\\n\\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = cur.next\\n            \\n            \\n  \\n            # update visiting index\\n            cur_idx +=1\\n            \\n        return dummy_head.next\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #206 Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        \\n        if m == n:\\n            # Quick response for empty reverse interval\\n            return head\\n        \\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        \\n        cur, prev = head, dummy_head\\n        cur_idx = 1\\n        \\n        # left sentry is the the m-th node\\n        # right sentry is the the n-th node\\n        left_sentry, right_sentry = None, None\\n        \\n        # left junction is the (m-1)-th node\\n        # right junction is the (n+1)-th node\\n        left_junction, right_junction = None, None\\n        \\n        rev = False\\n        \\n        while cur:\\n            \\n            if rev:\\n                # now we are in reverse interval\\n                \\n                # Backup original next node\\n                ori_next = cur.next\\n                \\n                # Let current node point to previous node\\n                cur.next = prev\\n                \\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = ori_next\\n                \\n                # Handle for right junction node\\n                if cur_idx == n:\\n                    right_sentry = prev\\n                    right_junction = cur\\n\\n                    # Construct new linkage based on left junction and right junction\\n                    left_junction.next = right_sentry\\n                    left_sentry.next = right_junction\\n\\n                    # turn off reverse flag\\n                    rev = False              \\n                \\n                \\n            else:\\n                # now we are in normal interval\\n                \\n                # Handle for left junction node\\n                if cur_idx == m:\\n                \\n                    left_sentry = cur\\n                    left_junction = prev\\n                    \\n                    # turn on reverse flag\\n                    rev = True\\n\\n\\n                # Update previous node\\n                # Update current point to original next node\\n                prev = cur\\n                cur = cur.next\\n            \\n            \\n  \\n            # update visiting index\\n            cur_idx +=1\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 261443,
                "title": "golang-recursive-iterative-versions-dummy-beat-100",
                "content": "Iterative version\\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ { head = head.Next }\\n    var curr, prev *ListNode = head.Next, nil\\n    for i := 0; i < n - m + 1; i++ {\\n        next := curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n    head.Next.Next = curr\\n    head.Next = prev\\n    return dummy.Next\\n}\\n```\\n\\nRecursive version\\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ {\\n        head = head.Next\\n    }\\n    newHead, _ := reverseList(head.Next, n - m + 1)\\n    head.Next = newHead\\n    // if m == 1 { return head.Next } else { return dummy.Next }\\n    return dummy.Next\\n}\\n\\n// return new head and the head of the rest\\nfunc reverseList(head *ListNode, cnt int) (*ListNode, *ListNode) {\\n    if cnt == 1 { return head, head.Next }\\n    newHead, restHead := reverseList(head.Next, cnt - 1)\\n    head.Next.Next = head\\n    head.Next = restHead\\n    return newHead, restHead\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ { head = head.Next }\\n    var curr, prev *ListNode = head.Next, nil\\n    for i := 0; i < n - m + 1; i++ {\\n        next := curr.Next\\n        curr.Next = prev\\n        prev = curr\\n        curr = next\\n    }\\n    head.Next.Next = curr\\n    head.Next = prev\\n    return dummy.Next\\n}\\n```\n```\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    dummy := new(ListNode)\\n    head, dummy.Next = dummy, head\\n    for i := 0; i < m-1; i++ {\\n        head = head.Next\\n    }\\n    newHead, _ := reverseList(head.Next, n - m + 1)\\n    head.Next = newHead\\n    // if m == 1 { return head.Next } else { return dummy.Next }\\n    return dummy.Next\\n}\\n\\n// return new head and the head of the rest\\nfunc reverseList(head *ListNode, cnt int) (*ListNode, *ListNode) {\\n    if cnt == 1 { return head, head.Next }\\n    newHead, restHead := reverseList(head.Next, cnt - 1)\\n    head.Next.Next = head\\n    head.Next = restHead\\n    return newHead, restHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012582,
                "title": "simple-solution-using-stack-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we know, a stack can be used to reverse elements that are pushed into in an specific order. \\nSo, using this concept we are going to solve this problem. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we will reach out to the left position ans from there, we will start pushing data of nodes to a stack until right position is reached.\\nAfter that we will again treverse from left to right and keep adding the top of stack from left to right.\\nIn this way, we can get the nodes of a linked list reversed from given left to given right position.\\n\\n# Complexity\\n- Time complexity: O(right)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(right-left)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        stack<int> s;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int le = left;\\n        while(--left){  // traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(--right){  // traversing to right\\n            temp2 = temp2->next;\\n        }\\n        while(temp1 != temp2->next){  //pushing nodes->val to stack\\n            s.push(temp1->val);\\n            temp1 = temp1->next;\\n        }\\n        temp1 = head;\\n        while(--le){   //again traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(s.size()){   //from left keep changing nodes->val to s.top()\\n            temp1->val = s.top();\\n            temp1 = temp1->next;\\n            s.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        stack<int> s;\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head;\\n        int le = left;\\n        while(--left){  // traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(--right){  // traversing to right\\n            temp2 = temp2->next;\\n        }\\n        while(temp1 != temp2->next){  //pushing nodes->val to stack\\n            s.push(temp1->val);\\n            temp1 = temp1->next;\\n        }\\n        temp1 = head;\\n        while(--le){   //again traversing to left\\n            temp1 = temp1->next;\\n        }\\n        while(s.size()){   //from left keep changing nodes->val to s.top()\\n            temp1->val = s.top();\\n            temp1 = temp1->next;\\n            s.pop();\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310945,
                "title": "0ms-c-easy-one-pass-solution-with-comments-easy-to-understand-o-n",
                "content": "# **0ms C++ Easy One Pass Solution With Comments || Easy To Understand || O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int L, int R) {\\n        ListNode*dummy=new ListNode(),*prev=dummy,*left=head,*right=head,*forw=head->next;\\n        dummy->next=head;//we have declared dummy variable and initialize its next to head\\n\\t\\t\\n        int dif=(R-L);//we have stored the difference between R and L\\n        while(--L){//we are traversing to the left node \\n            prev=left;\\n            left=forw;\\n            right=forw;\\n            forw=forw->next;\\n        }\\n        \\n        while(dif--){//after we reach the left node we will start reversing the linked list\\n            ListNode*temp=forw->next;\\n            forw->next=right;\\n            right=forw;\\n            forw=temp;\\n        }\\n        prev->next=right;\\n        left->next=forw;\\n        return dummy->next;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/240e007e-5fd0-4806-a3d2-4894c0b13902_1658371188.1270595.png)\\n\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int L, int R) {\\n        ListNode*dummy=new ListNode(),*prev=dummy,*left=head,*right=head,*forw=head->next;\\n        dummy->next=head;//we have declared dummy variable and initialize its next to head\\n\\t\\t\\n        int dif=(R-L);//we have stored the difference between R and L\\n        while(--L){//we are traversing to the left node \\n            prev=left;\\n            left=forw;\\n            right=forw;\\n            forw=forw->next;\\n        }\\n        \\n        while(dif--){//after we reach the left node we will start reversing the linked list\\n            ListNode*temp=forw->next;\\n            forw->next=right;\\n            right=forw;\\n            forw=temp;\\n        }\\n        prev->next=right;\\n        left->next=forw;\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292131,
                "title": "python-explained-intuitive-and-one-pass-algo-easy-to-understand",
                "content": "**Method 1: Intuitive Approach.**\\n\\nStep1: Find the node with at position = left and the node with position = right.\\nStep2: Split the linkedlist into three linked list like nodeL = [1, left-1], nodeM = [left, right] and nodeR = [right, n], where n = length of the linkedlist.\\nStep3: Reverse the nodeM linkedlist.\\nStep4: Merge the linkedlists as  nodeL + nodeM(reversed) + nodeR.\\n![image](https://assets.leetcode.com/users/images/b071e9ed-493a-4f04-b4d1-6f0baa3d8bb6_1624451012.2986653.png)\\n\\n\\nFull code for intuitive approach:\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        # a standard template code to reverse a linkedlist\\n        def reverse(head):\\n            if head is None or head.next is None:\\n                return head\\n            rest = reverse(head.next)\\n            head.next.next = head\\n            head.next = None\\n            return rest\\n        \\n        nodeL, nodeM, nodeR = None, None, None\\n        \\n        # if both left and right points to the same element, then there is no point of reversing\\n        if left == right:\\n            return head\\n        \\n        # Split the list into left, middle, and right part, \\n        # such that the middle part needs to be reversed.\\n        temp = ListNode()\\n        temp.next = head\\n        nodeL = temp\\n        \\n        i = 0\\n        while i < right:\\n            if i + 1 == left:\\n                nodeM = temp.next\\n                temp.next = None\\n                temp = nodeM\\n            elif i + 1 == right:\\n                nodeR = temp.next\\n                temp.next = None\\n                temp = nodeR\\n                break\\n            temp = temp.next\\n            i += 1\\n        \\n        nodeL = nodeL.next\\n        \\n        # reverse the middle part\\n        nodeM = reverse(nodeM)\\n        \\n        # if left part exists then add middle part to the end of left part\\n        if nodeL:\\n            temp = nodeL\\n            while temp.next:\\n                temp = temp.next\\n            temp.next = nodeM\\n        else:\\n            nodeL = nodeM\\n        \\n        # add right part to the end of middle part\\n        temp = nodeM\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = nodeR\\n        \\n        return nodeL\\n```\\n**Time = O(n)** as we need to traverse through the whole linked list(atleast upto right).\\n**Space = O(n)** as we are using the recursive approach to reverse the linked list, so stack space = O(right - left) which is O(n).\\nBut **this can be reduced to constant space** by changing the recursive method of reversing linkedlist to iterative method. \\nIterative method to reverse linkedlist:\\n```\\n\\t\\tdef reverse(head):\\n            prev = None\\n            current = head\\n            while(current is not None):\\n                next = current.next\\n                current.next = prev\\n                prev = current\\n                current = next\\n            head = prev\\n            return head\\n```\\nThus, **Space = O(1)**.\\n\\nBut the challenge is can we do it in one pass? -> Yes.\\n\\n**Method 2: One - pass solution**\\n*Note: It is not much efficient than the above intuitive method as a lots of swaps are happening, also the above method take much lesser time than this one in actual implementation. Try executing both and see the actual runtimes.*\\nApproach: Find the node previous of left, then swap left and left+1 along with  previous next at the same time.\\n\\n*Read the code, then look into the picture given below and try to map the idea, it\\'s simple.*\\n\\nOne pass code:\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        if left == right:\\n            return head\\n        \\n        node = temp = ListNode()\\n        node.next = head\\n        \\n        i = 1\\n        while i < left:\\n            temp = temp.next\\n            i += 1\\n        \\n        \\n        current = temp.next\\n        while left < right:\\n            t = current.next\\n            current.next = t.next\\n            t.next = temp.next\\n            temp.next = t\\n            left += 1\\n            print(node.next)\\n        \\n        return node.next\\n ```\\n Now you guys might be wondering how is it one pass solution, as there are two loops.\\n See, the first loop is going from start to left and second loop is going from left to right, so overall we are going from start to right once, hence it is one-pass.\\n \\n*Try doing it in a pen and paper, you will easily understand how the node-links are changing.*\\n *Try for [1,2,3,4,5,6] with  left = 3 and right= 5.*\\n \\n ![image](https://assets.leetcode.com/users/images/29f94123-2066-4d1b-8004-743a2165f1ce_1624454579.0142164.png)\\n \\n Time = O(n)\\n Space = O(1).\\n \\n Hope it helps!\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        # a standard template code to reverse a linkedlist\\n        def reverse(head):\\n            if head is None or head.next is None:\\n                return head\\n            rest = reverse(head.next)\\n            head.next.next = head\\n            head.next = None\\n            return rest\\n        \\n        nodeL, nodeM, nodeR = None, None, None\\n        \\n        # if both left and right points to the same element, then there is no point of reversing\\n        if left == right:\\n            return head\\n        \\n        # Split the list into left, middle, and right part, \\n        # such that the middle part needs to be reversed.\\n        temp = ListNode()\\n        temp.next = head\\n        nodeL = temp\\n        \\n        i = 0\\n        while i < right:\\n            if i + 1 == left:\\n                nodeM = temp.next\\n                temp.next = None\\n                temp = nodeM\\n            elif i + 1 == right:\\n                nodeR = temp.next\\n                temp.next = None\\n                temp = nodeR\\n                break\\n            temp = temp.next\\n            i += 1\\n        \\n        nodeL = nodeL.next\\n        \\n        # reverse the middle part\\n        nodeM = reverse(nodeM)\\n        \\n        # if left part exists then add middle part to the end of left part\\n        if nodeL:\\n            temp = nodeL\\n            while temp.next:\\n                temp = temp.next\\n            temp.next = nodeM\\n        else:\\n            nodeL = nodeM\\n        \\n        # add right part to the end of middle part\\n        temp = nodeM\\n        while temp.next:\\n            temp = temp.next\\n        temp.next = nodeR\\n        \\n        return nodeL\\n```\n```\\n\\t\\tdef reverse(head):\\n            prev = None\\n            current = head\\n            while(current is not None):\\n                next = current.next\\n                current.next = prev\\n                prev = current\\n                current = next\\n            head = prev\\n            return head\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        \\n        if left == right:\\n            return head\\n        \\n        node = temp = ListNode()\\n        node.next = head\\n        \\n        i = 1\\n        while i < left:\\n            temp = temp.next\\n            i += 1\\n        \\n        \\n        current = temp.next\\n        while left < right:\\n            t = current.next\\n            current.next = t.next\\n            t.next = temp.next\\n            temp.next = t\\n            left += 1\\n            print(node.next)\\n        \\n        return node.next\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 110983,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null){\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        for(int i = 1; i < m; i++){\\n            previous = current;\\n            current = current.next;\\n        }\\n        \\n        ListNode newCurrent = current;\\n        ListNode prev = null;\\n        \\n        while(current != null && m <= n){\\n            ListNode temp = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = temp;\\n            m++;\\n        }\\n        \\n        if(previous == null){\\n            head = prev;\\n        } else {\\n            previous.next = prev;\\n        }\\n        \\n        newCurrent.next = current;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null){\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        ListNode previous = null;\\n        \\n        for(int i = 1; i < m; i++){\\n            previous = current;\\n            current = current.next;\\n        }\\n        \\n        ListNode newCurrent = current;\\n        ListNode prev = null;\\n        \\n        while(current != null && m <= n){\\n            ListNode temp = current.next;\\n            current.next = prev;\\n            prev = current;\\n            current = temp;\\n            m++;\\n        }\\n        \\n        if(previous == null){\\n            head = prev;\\n        } else {\\n            previous.next = prev;\\n        }\\n        \\n        newCurrent.next = current;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311055,
                "title": "easy-to-understand-dry-run-with-example",
                "content": "**if(like) upvote;**\\n\\n ![image](https://assets.leetcode.com/users/images/d8139dd2-81ca-445c-bff5-1d3530881aba_1658378298.123155.jpeg)\\n\\n ListNode *forw = curr->next; \\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n\\n\\n```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *prev = dummy, *curr;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           prev = prev-> next;\\n       }\\n       curr = prev -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode *forw = curr->next; \\n            curr->next = forw->next;\\n            forw->next = prev->next;\\n            prev->next = forw;\\n       }\\n       return dummy -> next;\\n   }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *prev = dummy, *curr;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           prev = prev-> next;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2310852,
                "title": "java-easy-solution-100-faster-code",
                "content": "PLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n   public ListNode rev(ListNode head)\\n{\\nListNode curr=head,prev=null,next=null;\\nwhile(curr!=null)\\n{\\n\\n        next=curr.next;\\n        curr.next=prev;\\n        prev=curr;\\n        curr=next;\\n    }\\n    return prev;\\n}\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    if(left==right)\\n        return head;\\n    ListNode l=null,r=null,curr=head;\\n    int c=0;\\n    while(curr!=null)\\n    {\\n        c++;\\n        if(c==left)\\n         break;\\n        l=curr;\\n        curr=curr.next;\\n    }\\n    ListNode lt=curr;\\n   while(curr!=null)\\n    {\\n       \\n        if(c==right)\\n            break;\\n        c++;\\n        curr=curr.next;\\n    }\\n  \\n    r=curr.next;\\n     curr.next=null;\\n   lt=rev(lt);\\n   if(l==null)\\n       head=lt;\\n    else\\n        l.next=lt;\\n          while(lt.next!=null)\\n         {\\n               lt=lt.next;\\n          }\\n    lt.next=r;\\n    \\n    return head;\\n    \\n    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public ListNode rev(ListNode head)\\n{\\nListNode curr=head,prev=null,next=null;\\nwhile(curr!=null)\\n{\\n\\n        next=curr.next;\\n        curr.next=prev;\\n        prev=curr;\\n        curr=next;\\n    }\\n    return prev;\\n}\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    if(left==right)\\n        return head;\\n    ListNode l=null,r=null,curr=head;\\n    int c=0;\\n    while(curr!=null)\\n    {\\n        c++;\\n        if(c==left)\\n         break;\\n        l=curr;\\n        curr=curr.next;\\n    }\\n    ListNode lt=curr;\\n   while(curr!=null)\\n    {\\n       \\n        if(c==right)\\n            break;\\n        c++;\\n        curr=curr.next;\\n    }\\n  \\n    r=curr.next;\\n     curr.next=null;\\n   lt=rev(lt);\\n   if(l==null)\\n       head=lt;\\n    else\\n        l.next=lt;\\n          while(lt.next!=null)\\n         {\\n               lt=lt.next;\\n          }\\n    lt.next=r;\\n    \\n    return head;\\n    \\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849391,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\n    ListNode *reverse(ListNode *head)\\n    {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode *smallAns=reverse(head->next);\\n        ListNode *temp=head->next;\\n        temp->next=head;\\n        head->next=NULL;\\n        return smallAns;\\n    }\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {   if(head==NULL or head->next==NULL)\\n        {\\n            return head; \\n        }\\n        if(left==right)\\n        {\\n            return head;\\n        }\\n        if((right-left+1)==length(head))\\n        {\\n            return reverse(head);\\n        }\\n        if(left==1)\\n        {\\n            ListNode *end=NULL;\\n            ListNode *temp=head;\\n            int count=1;\\n            while(temp!=NULL)\\n            {\\n                if(count==right)\\n                {\\n                    end=temp;\\n                    break;\\n                }\\n                temp=temp->next;\\n                count=count+1;\\n            }\\n            ListNode *remain=end->next;\\n            end->next=NULL;\\n            ListNode *first=head;\\n            head=reverse(head);\\n            first->next=remain;\\n            return head;\\n        }\\n        ListNode *start=NULL;\\n        ListNode *end=NULL;\\n        ListNode *temp=head;\\n        int count=1;\\n        while(temp!=NULL)\\n        {\\n            if(count==left){\\n                start=temp;\\n            }\\n            if(count==right){\\n                end=temp;\\n            }\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        temp=head;\\n        while(temp->next!=start)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        ListNode *part2=end->next;\\n        end->next=NULL;\\n        start=reverse(start);\\n        temp->next=start;\\n        ListNode *curr=start;\\n        while(curr->next!=NULL){\\n            curr=curr->next;\\n        }\\n        curr->next=part2;\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n    ListNode *reverse(ListNode *head)\\n    {\\n        if(head==NULL or head->next==NULL){\\n            return head;\\n        }\\n        ListNode *smallAns=reverse(head->next);\\n        ListNode *temp=head->next;\\n        temp->next=head;\\n        head->next=NULL;\\n        return smallAns;\\n    }\\n    int length(ListNode *head){\\n        if(head==NULL){\\n            return 0;\\n        }\\n        else{\\n            return 1+length(head->next);\\n        }\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {   if(head==NULL or head->next==NULL)\\n        {\\n            return head; \\n        }\\n        if(left==right)\\n        {\\n            return head;\\n        }\\n        if((right-left+1)==length(head))\\n        {\\n            return reverse(head);\\n        }\\n        if(left==1)\\n        {\\n            ListNode *end=NULL;\\n            ListNode *temp=head;\\n            int count=1;\\n            while(temp!=NULL)\\n            {\\n                if(count==right)\\n                {\\n                    end=temp;\\n                    break;\\n                }\\n                temp=temp->next;\\n                count=count+1;\\n            }\\n            ListNode *remain=end->next;\\n            end->next=NULL;\\n            ListNode *first=head;\\n            head=reverse(head);\\n            first->next=remain;\\n            return head;\\n        }\\n        ListNode *start=NULL;\\n        ListNode *end=NULL;\\n        ListNode *temp=head;\\n        int count=1;\\n        while(temp!=NULL)\\n        {\\n            if(count==left){\\n                start=temp;\\n            }\\n            if(count==right){\\n                end=temp;\\n            }\\n            temp=temp->next;\\n            count=count+1;\\n        }\\n        temp=head;\\n        while(temp->next!=start)\\n        {\\n            temp=temp->next;\\n        }\\n        temp->next=NULL;\\n        ListNode *part2=end->next;\\n        end->next=NULL;\\n        start=reverse(start);\\n        temp->next=start;\\n        ListNode *curr=start;\\n        while(curr->next!=NULL){\\n            curr=curr->next;\\n        }\\n        curr->next=part2;\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1831913,
                "title": "single-traversal-interview-approaches-100-beating-other-solutions",
                "content": "**Please Upvote it helps a lot**\\n*Approach 1 Using Stack,it takes two traversals(using data change)*\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n     \\n        ListNode ptr = head;\\n        int count = 1;\\n        Stack<Integer> st = new Stack<>();\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                st.push(ptr.val);\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        count = 1;\\n        ptr = head;\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                ptr.val = st.pop();\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n*Single Traversal Solution,Using Link Change*\\n\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        \\n        int count = 0;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode ptr = dummy;    //ptr for iteration\\n        ListNode h1 = null;\\n        \\n        while(ptr != null){\\n            if(count == left - 1){\\n                 h1 = ptr;  //store it as we have to change its next pointer\\n            }\\n            \\n            if(count == left){\\n                ListNode h2 = ptr;      //store it as we have to change its next pointer\\n                reverse(h2,right - left,h1,h2);\\n                return dummy.next;\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    private void reverse(ListNode head,int con,ListNode h1,ListNode h2){\\n        //function for reversing the sub list and after that \\n        //add it to main list using h1 and h2 pointers\\n        \\n        ListNode prev = head;\\n        ListNode cur = prev.next;\\n        ListNode next = null ;\\n        \\n        for(int i = 1;i<=con;i++){ //reverse the sub list\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        h1.next = prev;\\n        h2.next = cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n     \\n        ListNode ptr = head;\\n        int count = 1;\\n        Stack<Integer> st = new Stack<>();\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                st.push(ptr.val);\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        count = 1;\\n        ptr = head;\\n        while(count <= right){\\n            if(count >= left && count <= right){\\n                ptr.val = st.pop();\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        \\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        \\n        int count = 0;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode ptr = dummy;    //ptr for iteration\\n        ListNode h1 = null;\\n        \\n        while(ptr != null){\\n            if(count == left - 1){\\n                 h1 = ptr;  //store it as we have to change its next pointer\\n            }\\n            \\n            if(count == left){\\n                ListNode h2 = ptr;      //store it as we have to change its next pointer\\n                reverse(h2,right - left,h1,h2);\\n                return dummy.next;\\n            }\\n            ptr = ptr.next;\\n            count++;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    private void reverse(ListNode head,int con,ListNode h1,ListNode h2){\\n        //function for reversing the sub list and after that \\n        //add it to main list using h1 and h2 pointers\\n        \\n        ListNode prev = head;\\n        ListNode cur = prev.next;\\n        ListNode next = null ;\\n        \\n        for(int i = 1;i<=con;i++){ //reverse the sub list\\n            next = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        \\n        h1.next = prev;\\n        h2.next = cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30815,
                "title": "less-than-10-lines-c-double-pointer-easy-understanding",
                "content": "    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode **pre = &head;\\n        int steps = m;\\n        while (--steps) { pre = &(*pre)->next;}\\n        ListNode *cur = *pre;\\n        for (int i = m; i < n; i++) {\\n            ListNode *next_n = cur->next;\\n            cur->next = next_n->next;\\n            next_n->next = *pre;\\n            *pre = next_n;\\n        }\\n        return head; \\n    }",
                "solutionTags": [],
                "code": "    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        ListNode **pre = &head;\\n        int steps = m;\\n        while (--steps) { pre = &(*pre)->next;}\\n        ListNode *cur = *pre;\\n        for (int i = m; i < n; i++) {\\n            ListNode *next_n = cur->next;\\n            cur->next = next_n->next;\\n            next_n->next = *pre;\\n            *pre = next_n;\\n        }\\n        return head; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3197002,
                "title": "c-linked-list-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        reverse(v.begin()+left-1, v.begin()+right);\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head){return NULL;}\\n        vector<int>v;\\n        while(head){\\n            v.push_back(head->val);\\n            head=head->next;\\n        }\\n        reverse(v.begin()+left-1, v.begin()+right);\\n        ListNode* root=NULL;\\n        for(int i=v.size()-1; i>=0; i--){\\n            ListNode* temp=new ListNode;\\n            temp->val=v[i];\\n            temp->next=root;\\n            root=temp;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090795,
                "title": "c-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        for(int i=1;i<left;i++) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n        ListNode* first = prev;\\n        ListNode* newend = curr;\\n        ListNode* nextNode = curr -> next;\\n        for(int i = 0;i<right - left + 1;i++) {\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n            if(nextNode != NULL) nextNode = nextNode -> next;\\n        }\\n        if(first != NULL) first -> next = prev;\\n        else head = prev;\\n        newend -> next = curr;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        for(int i=1;i<left;i++) {\\n            prev = curr;\\n            curr = curr -> next;\\n        }\\n        ListNode* first = prev;\\n        ListNode* newend = curr;\\n        ListNode* nextNode = curr -> next;\\n        for(int i = 0;i<right - left + 1;i++) {\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n            if(nextNode != NULL) nextNode = nextNode -> next;\\n        }\\n        if(first != NULL) first -> next = prev;\\n        else head = prev;\\n        newend -> next = curr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497448,
                "title": "python-easy-solution-with-explanation",
                "content": "\\n        # setting dummy node \\n        dummy = ListNode(0, head)\\n        \\n        \\n        # setting leftprev so that we can link this linkedlist with the reversed one\\n        leftprev, curr = dummy, head\\n        \\n        \\n        # iterating till we reach the desired start pos from where we need to reverse the list\\n        \\n        for i in range(0, left-1):\\n            \\n            leftprev , curr = curr, curr.next\\n            \\n        #leftprev = curr    \\n        \\n        #now reversing the linkedlist\\n        \\n        #this will run from right -left +1\\n        \\n        prev = None\\n        for i in range(right - left +1):\\n            \\n            nxt = curr.next\\n            \\n            curr.next = prev\\n            \\n            prev = curr\\n            \\n            curr = nxt\\n            \\n            \\n        # Now the main logic \\n        \\n        #since we got the given range linkedlist reversed but it is connected with the other so how to do that\\n        \\n        # see exp 1 we want 2\\'s next pointer to be 5 and 1\\'s next pointer to be 4 right??\\n        \\n        # So our leftprev is pointing to 1 and currently its .next is pointing to 2 coz we have linked the reversed linkedlist\\n        \\n        # with the non reversed linkedlist\\n        \\n        # so we will do leftprev. next.next to be curr coz curr is pointing to last as it is evident from line 36 above\\n        \\n        #now to make the next pointer of left prev to point to 4 how can we do that ???\\n        \\n        # remember that in reversed linkedlist prev is pointing to 4, so all we need to do is that do leftprev.next = prev\\n        \\n        \\n       \\n\\t   #REMEMBER THE ORDER SHOULD BE THIS WAY ELSE WE DO VICE VERSA THEN LEFTPREV.NEXT WILL POINT TO 4 AND 4\\'S NEXT WILL START\\n        \\n        # POINTING TO 5 RATHER THAN POINTING TO 3\\n        \\n        leftprev.next.next = curr # now 2\\'s next is pointing to 5 \\n        \\n        leftprev.next = prev # 1\\'s next pointer is poiting to 4\\n        \\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\n        # setting dummy node \\n        dummy = ListNode(0, head)\\n        \\n        \\n        # setting leftprev so that we can link this linkedlist with the reversed one\\n        leftprev, curr = dummy, head\\n        \\n        \\n        # iterating till we reach the desired start pos from where we need to reverse the list\\n        \\n        for i in range(0, left-1):\\n            \\n            leftprev , curr = curr, curr.next\\n            \\n        #leftprev = curr    \\n        \\n        #now reversing the linkedlist\\n        \\n        #this will run from right -left +1\\n        \\n        prev = None\\n        for i in range(right - left +1):\\n            \\n            nxt = curr.next\\n            \\n            curr.next = prev\\n            \\n            prev = curr\\n            \\n            curr = nxt\\n            \\n            \\n        # Now the main logic \\n        \\n        #since we got the given range linkedlist reversed but it is connected with the other so how to do that\\n        \\n        # see exp 1 we want 2\\'s next pointer to be 5 and 1\\'s next pointer to be 4 right??\\n        \\n        # So our leftprev is pointing to 1 and currently its .next is pointing to 2 coz we have linked the reversed linkedlist\\n        \\n        # with the non reversed linkedlist\\n        \\n        # so we will do leftprev. next.next to be curr coz curr is pointing to last as it is evident from line 36 above\\n        \\n        #now to make the next pointer of left prev to point to 4 how can we do that ???\\n        \\n        # remember that in reversed linkedlist prev is pointing to 4, so all we need to do is that do leftprev.next = prev\\n        \\n        \\n       \\n\\t   #REMEMBER THE ORDER SHOULD BE THIS WAY ELSE WE DO VICE VERSA THEN LEFTPREV.NEXT WILL POINT TO 4 AND 4\\'S NEXT WILL START\\n        \\n        # POINTING TO 5 RATHER THAN POINTING TO 3\\n        \\n        leftprev.next.next = curr # now 2\\'s next is pointing to 5 \\n        \\n        leftprev.next = prev # 1\\'s next pointer is poiting to 4\\n        \\n        return dummy.next",
                "codeTag": "Unknown"
            },
            {
                "id": 4011861,
                "title": "c-simple-solution-13-line-code",
                "content": "`Time Complexity` -O(n)\\n`Space Complexity` -O(1)\\nGiven the code, we have a `ListNode` definition with three constructors, a class `Solution` with a `reverseBetween` function.\\n### Step 1: Initialize Variables\\n\\n1. Create a `dummy` node and set its `next` pointer to the original `head`.\\n2. Initialize the `prev` pointer on the `dummy` node.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n ^\\n head\\n prev\\n```\\n\\n### Step 2: Move `prev` to (left - 1) position\\n\\nIterate `left - 1` times to position `prev` at the node just before the segment to be reversed.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^   \\n         prev\\n```\\n\\n### Step 3: Initialize `current`\\n\\nSet the `current` pointer to the `prev` node. This is because we want to start reversing from position `left`.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^        \\n         prev\\n         current\\n```\\n\\n### Step 4: Reverse the Segment\\n\\nIterate and reverse the nodes between `left` and `right`.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[3]->[2]->[4]->[5]->[6]->nullptr\\n          ^   ^    ^\\n         prev  |  current\\n               x\\n```\\n\\n### Step 5: Continue Reversing\\n\\nRepeat the process until `right - left` times.\\n\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n          ^   ^        ^\\n         prev  |       current\\n               x\\n```\\n\\n### Step 6: Return the Modified List\\nReturn the `next` pointer of `dummy` which points to the modified list.\\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n```\\nThis completes the process of reversing the segment between `left` and `right` in the linked list.\\n![image](https://assets.leetcode.com/users/images/10c4c0ba-f8bf-45db-9b6f-80a1ddb25653_1694047517.3518703.png)\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // Create a dummy node.\\n        dummy->next = head;\\n        ListNode *prev = dummy; //the prev pointer on the dummy node.\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next; // Move the prev pointer to the (left - 1)-th node.\\n        }\\n\\n        ListNode *current = prev->next; // The current pointer starts just after the prev.\\n\\n        // Reverse the portion.\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode *x = current->next; // save current->next \\n            current->next = x->next; // Update current\\'s next \\n            x->next = prev->next; // Insert x node between prev and its next node.\\n            prev->next = x; // Update prev\\'s next to point to forw.\\n        }\\n\\n        return dummy->next; \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dc223b26-c098-421b-8482-bde1e4972cb1_1694045277.3329945.webp)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n ^\\n head\\n prev\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^   \\n         prev\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[2]->[3]->[4]->[5]->[6]->nullptr\\n          ^        \\n         prev\\n         current\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[3]->[2]->[4]->[5]->[6]->nullptr\\n          ^   ^    ^\\n         prev  |  current\\n               x\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n          ^   ^        ^\\n         prev  |       current\\n               x\\n```\n```plaintext\\n    dummy\\n     |\\n     v\\n[0]->[1]->[4]->[3]->[2]->[5]->[6]->nullptr\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0); // Create a dummy node.\\n        dummy->next = head;\\n        ListNode *prev = dummy; //the prev pointer on the dummy node.\\n\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next; // Move the prev pointer to the (left - 1)-th node.\\n        }\\n\\n        ListNode *current = prev->next; // The current pointer starts just after the prev.\\n\\n        // Reverse the portion.\\n        for (int i = 0; i < right - left; i++) {\\n            ListNode *x = current->next; // save current->next \\n            current->next = x->next; // Update current\\'s next \\n            x->next = prev->next; // Insert x node between prev and its next node.\\n            prev->next = x; // Update prev\\'s next to point to forw.\\n        }\\n\\n        return dummy->next; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011858,
                "title": "c-linked-list-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike yesterday transverse the list.  Use a dummy ListNode makes programming easier.\\n```\\nListNode dummy=ListNode();\\nListNode* L=&dummy, *R;\\ndummy.next=head;\\n```\\n# Approach\\n\\nThe implementation avoids the possiblity for memory leaks.\\n<!-- Describe your approach to solving the problem. -->\\nLeetcode 86. Partition List\\n[Please turn on english subtitles if necessary]\\n[https://youtu.be/LZ6oARGKnZA?si=JszrMJrISfmZkSd-](https://youtu.be/LZ6oARGKnZA?si=JszrMJrISfmZkSd-)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code runtime 0 ms beats 100%\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        if (right==1) return head;\\n        ListNode dummy=ListNode();\\n        ListNode* L=&dummy, *R;\\n        dummy.next=head;\\n        // Move L to the position left\\n        for(int i=0; i<left-1; i++)\\n            L=L->next;\\n        R=L->next;\\n        //From i=left to right, move R->next to the position right stepwise\\n        for(int i=left; i<right; i++){\\n            ListNode* rev=R->next;//Reverse the linked list (1)\\n            R->next=rev->next;//(2)position for R->next in next i \\n            rev->next=L->next;//(3)\\n            L->next=rev; //(4)\\n        }\\n\\n        return dummy.next;\\n    }\\n};\\n```\\n# Diagram for reversing linked list\\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nListNode dummy=ListNode();\\nListNode* L=&dummy, *R;\\ndummy.next=head;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        if (right==1) return head;\\n        ListNode dummy=ListNode();\\n        ListNode* L=&dummy, *R;\\n        dummy.next=head;\\n        // Move L to the position left\\n        for(int i=0; i<left-1; i++)\\n            L=L->next;\\n        R=L->next;\\n        //From i=left to right, move R->next to the position right stepwise\\n        for(int i=left; i<right; i++){\\n            ListNode* rev=R->next;//Reverse the linked list (1)\\n            R->next=rev->next;//(2)position for R->next in next i \\n            rev->next=L->next;//(3)\\n            L->next=rev; //(4)\\n        }\\n\\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742121,
                "title": "using-stacks-in-c",
                "content": "# Intuition\\nuse stacks.push the elments in stack to be reversed .then we will have a reversed list of the elements then insert the remaining elements to the list at beginning and at last\\n# Approach\\n\\nThe code aims to reverse a sublist of a singly-linked list between two given positions, left and right. It follows the following approach:\\n\\nInitialize a stack (top) to store the elements that need to be reversed.\\n\\nImplement the isfull function to check if the stack is full. In this code, it always returns 0 as the stack is implemented using a linked list and doesn\\'t have a predefined size.\\n\\nImplement the isempty function to check if the stack is empty. It returns 1 if the stack is empty (i.e., t is NULL) and 0 otherwise.\\n\\nImplement the push function to push an element onto the stack. It first checks if the stack is full using the isfull function. If the stack is not full, it allocates memory for a new node, assigns the value to the node, updates the next pointer to point to the current top of the stack, and then updates the stack\\'s top to the new node. It returns the updated top of the stack.\\n\\nThe reverseBetween function takes the head of the linked list, head, and the positions left and right as input. It initializes pointers p and q to point to the head of the list and sets top (the stack) to NULL.\\n\\nThe function iterates p to reach the node at position left - 1 and q to reach the node at position right. This is done using two for-loops.\\n\\nNext, it iterates from p to q and pushes the values of the nodes onto the stack using the push function.\\n\\nAfter the iteration, it pushes the value of p onto the stack as well.\\n\\nIt then finds the last node in the stack by iterating from top until the next pointer is NULL. It assigns q->next to the next of this last node.\\n\\nIf left > 1, it updates the next pointer of the node at position left - 2 to the top of the stack. Otherwise, it updates the head of the list to top.\\n\\nFinally, it returns the head of the modified list.\\n\\nThe time complexity of the code is O(N), where N is the number of nodes in the linked list. This is because the code iterates over the sublist to be reversed and pushes the values onto the stack, which takes O(N) time. Additionally, it iterates over the stack to find the last node, which also takes O(N) time.\\n\\nThe space complexity of the code is O(N) as well. It uses a stack (top) to store the sublist elements that need to be reversed. The maximum size of the stack will be equal to the size of the sublist, which can be up to N in the worst case.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n struct  ListNode *top=NULL;\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    struct ListNode *p=head;\\n    struct ListNode *q=head;\\n         struct ListNode *top=NULL;\\n    int i;\\n    for(i=0;i<left-1;i++)\\n    {\\n        p=p->next;\\n    }\\n    for(i=0;i<right-1;i++)\\n    {\\n        q=q->next;\\n    }\\n    while(p!=q)\\n    {\\n        top=push(top,p->val);\\n        p=p->next;\\n    }\\n    top=push(top,p->val);\\nstruct ListNode* o = top;\\n    while (o->next != NULL) {\\n        o = o->next;\\n    }\\n    o->next = q->next;\\n    struct ListNode* e = head;\\n    if (left > 1) {\\n        for (i = 0; i < left - 2; i++) {\\n            e = e->next;\\n        }\\n        e->next = top;\\n        return head;\\n    } else {\\n        return top;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n struct  ListNode *top=NULL;\\n int isfull(struct ListNode *t)\\n{\\n    struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n    if(q==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nint isempty(struct ListNode *t)\\n{\\n    if(t==NULL)\\n    {\\n        return 1;\\n    }\\n    else\\n    return 0;\\n}\\nstruct ListNode *push(struct ListNode *t,int val)\\n{\\n    if(isfull(t))\\n    printf(\"stack full\");\\n    else\\n    {\\n        struct ListNode *q=(struct ListNode *)malloc(sizeof(struct ListNode));\\n        q->val=val;\\n        q->next=t;\\n        t=q;\\n        return t;\\n    }\\n    return t;\\n}\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    struct ListNode *p=head;\\n    struct ListNode *q=head;\\n         struct ListNode *top=NULL;\\n    int i;\\n    for(i=0;i<left-1;i++)\\n    {\\n        p=p->next;\\n    }\\n    for(i=0;i<right-1;i++)\\n    {\\n        q=q->next;\\n    }\\n    while(p!=q)\\n    {\\n        top=push(top,p->val);\\n        p=p->next;\\n    }\\n    top=push(top,p->val);\\nstruct ListNode* o = top;\\n    while (o->next != NULL) {\\n        o = o->next;\\n    }\\n    o->next = q->next;\\n    struct ListNode* e = head;\\n    if (left > 1) {\\n        for (i = 0; i < left - 2; i++) {\\n            e = e->next;\\n        }\\n        e->next = top;\\n        return head;\\n    } else {\\n        return top;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3187602,
                "title": "reverse-linked-list-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a dummy node to keep track of the previous node. It first moves prev to the node before the start node, and then reverse the nodes from the start node to the end node. For each iteration, it changes the next pointer of the start node to the next node of the end node, and changes the next pointer of the end node to the next node of prev.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Create a dummy node\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        # Keep track of the previous node\\n        prev = dummy\\n        # Move to the node before the start node\\n        for i in range(left - 1):\\n            prev = prev.next\\n        start = prev.next\\n        end = start.next\\n        # Reverse the nodes\\n        for i in range(right - left):\\n            start.next = end.next\\n            end.next = prev.next\\n            prev.next = end\\n            end = start.next\\n        return dummy.next\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Create a dummy node\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        # Keep track of the previous node\\n        prev = dummy\\n        # Move to the node before the start node\\n        for i in range(left - 1):\\n            prev = prev.next\\n        start = prev.next\\n        end = start.next\\n        # Reverse the nodes\\n        for i in range(right - left):\\n            start.next = end.next\\n            end.next = prev.next\\n            prev.next = end\\n            end = start.next\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713725,
                "title": "c-0-ms-beats-100-runtime",
                "content": "# C++ || 0 ms || beats 100% runtime || \\uD83D\\uDCAF\\uD83D\\uDCAF\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n  ListNode* reverse(ListNode* start, ListNode* end ){\\n      \\n         ListNode *curr = start;\\n         ListNode *prev = NULL ;\\n         ListNode *forward = NULL;\\n              \\n           while(curr != end  ){\\n            \\n              forward = curr->next;\\n              curr -> next = prev;\\n         \\n             prev = curr;\\n            curr = forward;\\n        }\\n          \\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(head->next==NULL || head==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *start=head;\\n        ListNode *end = head;\\n        ListNode *temp = start;\\n        ListNode* nextToEnd = NULL;\\n       if(left==1 && right==1){\\n           return head;\\n       }\\n        int cnt = 1 ;\\n        \\n        while(cnt<left){\\n            temp=start;\\n            start=start->next;\\n            cnt++;\\n        }\\n        cnt = 1;\\n           while(cnt<right){\\n            end=end->next;\\n               \\n            cnt++;\\n        }\\n        nextToEnd = end->next  ;\\n        //for left = 1\\n        \\n        if(left==1 ){\\n         head = reverse(start, nextToEnd);\\n          ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n         }\\n                    tail->next = nextToEnd ;\\n             return head;\\n        }\\n        \\n       temp->next = reverse(start, nextToEnd);\\n    \\n        ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n        }\\n        tail->next = nextToEnd ;\\n       return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n  ListNode* reverse(ListNode* start, ListNode* end ){\\n      \\n         ListNode *curr = start;\\n         ListNode *prev = NULL ;\\n         ListNode *forward = NULL;\\n              \\n           while(curr != end  ){\\n            \\n              forward = curr->next;\\n              curr -> next = prev;\\n         \\n             prev = curr;\\n            curr = forward;\\n        }\\n          \\n        return prev;\\n    }\\n\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(head->next==NULL || head==NULL){\\n            return head;\\n        }\\n        \\n        ListNode *start=head;\\n        ListNode *end = head;\\n        ListNode *temp = start;\\n        ListNode* nextToEnd = NULL;\\n       if(left==1 && right==1){\\n           return head;\\n       }\\n        int cnt = 1 ;\\n        \\n        while(cnt<left){\\n            temp=start;\\n            start=start->next;\\n            cnt++;\\n        }\\n        cnt = 1;\\n           while(cnt<right){\\n            end=end->next;\\n               \\n            cnt++;\\n        }\\n        nextToEnd = end->next  ;\\n        //for left = 1\\n        \\n        if(left==1 ){\\n         head = reverse(start, nextToEnd);\\n          ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n         }\\n                    tail->next = nextToEnd ;\\n             return head;\\n        }\\n        \\n       temp->next = reverse(start, nextToEnd);\\n    \\n        ListNode *tail = head;\\n        \\n        while(tail->next!=NULL){\\n            tail=tail->next;\\n        }\\n        tail->next = nextToEnd ;\\n       return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086886,
                "title": "simple-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL){return head;} // Base case:- If there are no nodes or only a single node. \\n        \\n        ListNode* dummy=new ListNode(-1); // Creating a dummy node.\\n        dummy->next=head; // Making connection of the dummy node to head.\\n        \\n        // Creating pointers for traversal which will further help in making connections after the reversal operation.\\n        ListNode* previt=NULL; \\n        ListNode* it=dummy;\\n        \\n        // Traverse till the left node which is the beginning node for the reversal part of the linked list. \\n        for(int i=0;i<left;i++){\\n            previt=it;\\n            it=it->next;\\n        }\\n        \\n        // Appointing pointers to the left node and its previous node to help in reversal operation.\\n        ListNode* curr=it;\\n        ListNode* prev=previt;\\n        \\n        \\n        // Traverse till the right node which is the ending point for the reverse operation and reverse nodes side by side as done in \"Reverse Linked List 1(Leetcode no. 206)\"\\n        for(int i=left;i<=right;i++){\\n            ListNode* Next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=Next;\\n        }\\n        \\n        // Make connections \\n        previt->next=prev;\\n        it->next=curr;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL){return head;} // Base case:- If there are no nodes or only a single node. \\n        \\n        ListNode* dummy=new ListNode(-1); // Creating a dummy node.\\n        dummy->next=head; // Making connection of the dummy node to head.\\n        \\n        // Creating pointers for traversal which will further help in making connections after the reversal operation.\\n        ListNode* previt=NULL; \\n        ListNode* it=dummy;\\n        \\n        // Traverse till the left node which is the beginning node for the reversal part of the linked list. \\n        for(int i=0;i<left;i++){\\n            previt=it;\\n            it=it->next;\\n        }\\n        \\n        // Appointing pointers to the left node and its previous node to help in reversal operation.\\n        ListNode* curr=it;\\n        ListNode* prev=previt;\\n        \\n        \\n        // Traverse till the right node which is the ending point for the reverse operation and reverse nodes side by side as done in \"Reverse Linked List 1(Leetcode no. 206)\"\\n        for(int i=left;i<=right;i++){\\n            ListNode* Next=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=Next;\\n        }\\n        \\n        // Make connections \\n        previt->next=prev;\\n        it->next=curr;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621775,
                "title": "easy-to-understand-13-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right || !head || !head->next)return head;\\n             \\n        ListNode* temp = head;\\n        vector<int> order;\\n        \\n        while(temp != NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        reverse(order.begin() + left - 1 , order.begin() + right);\\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right || !head || !head->next)return head;\\n             \\n        ListNode* temp = head;\\n        vector<int> order;\\n        \\n        while(temp != NULL)\\n        {\\n            order.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        reverse(order.begin() + left - 1 , order.begin() + right);\\n        int index = 0;\\n        temp = head;\\n        \\n        while(temp != NULL)\\n        {\\n            temp->val = order[index++];\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498545,
                "title": "c-simple-and-commented-solution-faster-than-100-0-ms",
                "content": "```\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0,head);\\n        //dummy will always point to head , to handle edge cases\\n        \\n        ListNode *Leftprev = dummy;\\n        ListNode *cur = head;\\n        //1st pass -> iterate to left and previous of left means iterate till left-1\\n        for(int i=1;i<left;i++)\\n        {\\n            Leftprev = cur;\\n            cur = cur->next;\\n        }\\n        //prev which will iterate to right \\n        ListNode *prev = NULL;\\n        \\n        //2nd pass , reverse from left to right\\n        for(int i=1;i<=(right-left+1);i++)\\n        {\\n            ListNode *tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        //now the list is 0->1->2<-3<-4->5 \\n        //leftprev is at 1 , prev = 4 , cur = 5 \\n        // so we just need to connect leftprev->next->next = cur and leftprev->next = prev;\\n        Leftprev->next->next = cur;\\n        Leftprev->next = prev;\\n        \\n        return dummy->next;\\n            \\n    }\\n```\\n**If you like it , Do upvote\\nHappy Coding;**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummy = new ListNode(0,head);\\n        //dummy will always point to head , to handle edge cases\\n        \\n        ListNode *Leftprev = dummy;\\n        ListNode *cur = head;\\n        //1st pass -> iterate to left and previous of left means iterate till left-1\\n        for(int i=1;i<left;i++)\\n        {\\n            Leftprev = cur;\\n            cur = cur->next;\\n        }\\n        //prev which will iterate to right \\n        ListNode *prev = NULL;\\n        \\n        //2nd pass , reverse from left to right\\n        for(int i=1;i<=(right-left+1);i++)\\n        {\\n            ListNode *tmp = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        //now the list is 0->1->2<-3<-4->5 \\n        //leftprev is at 1 , prev = 4 , cur = 5 \\n        // so we just need to connect leftprev->next->next = cur and leftprev->next = prev;\\n        Leftprev->next->next = cur;\\n        Leftprev->next = prev;\\n        \\n        return dummy->next;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291724,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head== NULL) return NULL;\\n        ListNode* res= new ListNode(0,head);\\n        ListNode* prev= res;\\n        for(int i=0; i<left-1; i++) prev= prev->next; \\n        ListNode* curr= prev->next;\\n        while(left++ < right){\\n            ListNode* temp= curr->next;\\n            curr->next= temp->next;\\n            temp->next= prev->next;\\n            prev->next= temp;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head== NULL) return NULL;\\n        ListNode* res= new ListNode(0,head);\\n        ListNode* prev= res;\\n        for(int i=0; i<left-1; i++) prev= prev->next; \\n        ListNode* curr= prev->next;\\n        while(left++ < right){\\n            ListNode* temp= curr->next;\\n            curr->next= temp->next;\\n            temp->next= prev->next;\\n            prev->next= temp;\\n        }\\n        return res->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230124,
                "title": "easy-c-solution-without-creating-any-dummy-node",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode *tmp=head,*age;\\n        int count=1;\\n        while(tmp && count<left)\\n        {\\n            age=tmp;\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        ListNode *prev=NULL,*later=NULL,*curr=tmp;\\n        while(curr && count<=right)\\n        {\\n            later=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=later;\\n            count++;\\n        }\\n        if(left==1)\\n        {\\n            head=prev;\\n        }\\n        else\\n        {\\n            age->next=prev;\\n        }\\n        tmp->next=curr;\\n        return head;\\n    }\\n};\\n```\\n**Please upvote if you have any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode *tmp=head,*age;\\n        int count=1;\\n        while(tmp && count<left)\\n        {\\n            age=tmp;\\n            tmp=tmp->next;\\n            count++;\\n        }\\n        ListNode *prev=NULL,*later=NULL,*curr=tmp;\\n        while(curr && count<=right)\\n        {\\n            later=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=later;\\n            count++;\\n        }\\n        if(left==1)\\n        {\\n            head=prev;\\n        }\\n        else\\n        {\\n            age->next=prev;\\n        }\\n        tmp->next=curr;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641876,
                "title": "c-50-well-commented-code",
                "content": "**If needed explanation please comment will reply within 2 hours**\\n**Upvotes are appreciated**\\n```\\nListNode* reverse(ListNode* head){\\n        ListNode* curr=head;\\n        ListNode* nxt=head;\\n        ListNode* prev=NULL;\\n        while(curr){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n\\t\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(!head || !head->next ||m==n)\\n            return head;\\n        ListNode* p1=head;\\n        ListNode* prevp1=head;\\n        ListNode* p2=head;\\n        ListNode* forp2=head;\\n        int x=m,y=n;\\n        //traversing upto m and marking prevp1 as previous to p1 pointer\\n        while(x-->1){\\n            prevp1=p1;\\n            p1=p1->next;\\n        }\\n        //traversing upto n\\n        while(y-->1)\\n            p2=p2->next;\\n        //marking forp2 as next pointer to p2\\n        forp2=p2->next;\\n        //if we have to reverse 1 node to last node\\n        //just revrse whole linked list\\n        if(m==1 and p2->next==NULL){\\n            p1=reverse(p1);\\n            return p1;\\n        }\\n        //if we have to revrese upto last node strating from any node but first\\n        if(p2->next==NULL){\\n            p1=reverse(p1);\\n            prevp1->next=p1;\\n            return head;\\n        }\\n        //breaking linked list in two parts for reversal\\n        p2->next=NULL;\\n        //returning head pointer to reveresed list\\n        p1=reverse(p1);\\n        //if have to reverse from 1st node to any node but last\\n        if(m==1){\\n            prevp1=p1;\\n            while(p1->next)\\n                p1=p1->next;\\n            p1->next=forp2;\\n            return prevp1;\\n        }\\n        // if any other condition than above\\n        //that is want to reverse list when m!=1 and n!=length of list\\n        prevp1->next=p1;\\n        while(p1->next)\\n            p1=p1->next;\\n        p1->next=forp2;\\n        \\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverse(ListNode* head){\\n        ListNode* curr=head;\\n        ListNode* nxt=head;\\n        ListNode* prev=NULL;\\n        while(curr){\\n            nxt=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=nxt;\\n        }\\n        return prev;\\n    }\\n\\t\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(!head || !head->next ||m==n)\\n            return head;\\n        ListNode* p1=head;\\n        ListNode* prevp1=head;\\n        ListNode* p2=head;\\n        ListNode* forp2=head;\\n        int x=m,y=n;\\n        //traversing upto m and marking prevp1 as previous to p1 pointer\\n        while(x-->1){\\n            prevp1=p1;\\n            p1=p1->next;\\n        }\\n        //traversing upto n\\n        while(y-->1)\\n            p2=p2->next;\\n        //marking forp2 as next pointer to p2\\n        forp2=p2->next;\\n        //if we have to reverse 1 node to last node\\n        //just revrse whole linked list\\n        if(m==1 and p2->next==NULL){\\n            p1=reverse(p1);\\n            return p1;\\n        }\\n        //if we have to revrese upto last node strating from any node but first\\n        if(p2->next==NULL){\\n            p1=reverse(p1);\\n            prevp1->next=p1;\\n            return head;\\n        }\\n        //breaking linked list in two parts for reversal\\n        p2->next=NULL;\\n        //returning head pointer to reveresed list\\n        p1=reverse(p1);\\n        //if have to reverse from 1st node to any node but last\\n        if(m==1){\\n            prevp1=p1;\\n            while(p1->next)\\n                p1=p1->next;\\n            p1->next=forp2;\\n            return prevp1;\\n        }\\n        // if any other condition than above\\n        //that is want to reverse list when m!=1 and n!=length of list\\n        prevp1->next=p1;\\n        while(p1->next)\\n            p1=p1->next;\\n        p1->next=forp2;\\n        \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 620280,
                "title": "python-iterative-sol-beats-95",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        if not head:\\n            return head\\n        cur, prev = head, None\\n        for _ in range(m-1):\\n            prev = cur\\n            cur = cur.next\\n        tail, con = cur, prev\\n        for _ in range(n-m+1):\\n            third = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = third\\n        if con:\\n            con.next = prev\\n        else:\\n            head = prev\\n        tail.next = cur\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        if not head:\\n            return head\\n        cur, prev = head, None\\n        for _ in range(m-1):\\n            prev = cur\\n            cur = cur.next\\n        tail, con = cur, prev\\n        for _ in range(n-m+1):\\n            third = cur.next\\n            cur.next = prev\\n            prev = cur\\n            cur = third\\n        if con:\\n            con.next = prev\\n        else:\\n            head = prev\\n        tail.next = cur\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30695,
                "title": "java-solution-with-less-pointers-and-detailed-comments",
                "content": "```\\npublic ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return head;\\n        ListNode fake_head = new ListNode(0);\\n        fake_head.next = head;\\n        \\n        //move to the start point\\n        ListNode pre = fake_head;\\n        for(int i = 0; i < m - 1; i ++){\\n            pre = pre.next;\\n        }\\n        \\n        //do the reverse\\n        ListNode cur = pre.next;\\n        ListNode new_head = null;\\n        for(int i = 0; i <= n - m; i ++){\\n            ListNode next = cur.next;\\n            cur.next = new_head;\\n            new_head = cur;\\n            cur = next;\\n        }\\n        \\n        //reconnect\\n        pre.next.next = cur;\\n        pre.next = new_head;\\n        \\n        return fake_head.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int m, int n) {\\n        if(head == null) return head;\\n        ListNode fake_head = new ListNode(0);\\n        fake_head.next = head;\\n        \\n        //move to the start point\\n        ListNode pre = fake_head;\\n        for(int i = 0; i < m - 1; i ++){\\n            pre = pre.next;\\n        }\\n        \\n        //do the reverse\\n        ListNode cur = pre.next;\\n        ListNode new_head = null;\\n        for(int i = 0; i <= n - m; i ++){\\n            ListNode next = cur.next;\\n            cur.next = new_head;\\n            new_head = cur;\\n            cur = next;\\n        }\\n        \\n        //reconnect\\n        pre.next.next = cur;\\n        pre.next = new_head;\\n        \\n        return fake_head.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012720,
                "title": "drawing-explanation-easy-to-understand",
                "content": "# Intuition and Approach\\n\\n    1. Find left node indcated by index - l\\n    2. Find right node indicated by index - r\\n    3. Revers left node till right node\\n    4. Link the broken links\\n\\n    Note: Add a dummy head to track left_prev node in case left node is at head\\n\\n#### Please bear with my diagrams :)\\n\\nInput: head = ```[1,2,3,4,5]```, l = ```2``` (left index), r = ```4``` (right index)\\nOutput: ```[1,4,3,2,5]```\\n\\n![20230907_111845_1.jpg](https://assets.leetcode.com/users/images/e5b2b627-ed02-4dca-a99e-751701ca1170_1694068233.7766912.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(2r - l))$$ ```r```= right index, ```l``` = left index\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# C++\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode* dummy_head = new ListNode(-1);\\n        dummy_head->next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode* left_prev = dummy_head;\\n        ListNode* left = dummy_head->next;\\n        int left_count = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (left_count < l) {\\n            left_prev = left;\\n            left = left->next;\\n            left_count++;\\n        }\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode* right = left;\\n        ListNode* right_next = left->next;\\n        int right_count = 0;\\n        while (right_count < r - l) {\\n            right = right_next;\\n            right_next = right_next->next;\\n            right_count++;\\n        }\\n        // 3rd while loop (reverse element between left and right node)\\n        ListNode* cur = left;\\n        ListNode* pre = nullptr;\\n        while (cur != right_next) {\\n            ListNode* tmp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n        // 4th fix breakage link\\n        left_prev->next = right;\\n        left->next = right_next;\\n\\n        head = dummy_head->next;\\n        delete dummy_head;\\n        return head;\\n    }\\n};\\n```\\n# Python3\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], l: int, r: int) -> Optional[ListNode]:\\n        \\n        # Dummy head insertion\\n        dummy_head = ListNode(None)\\n        dummy_head.next = head\\n\\n        # 1st while loop (spot left_prev, left nodes)\\n        left_prev = dummy_head\\n        left = dummy_head.next\\n        left_count = 1  # we start with 1 because we have to stop previous to left (because dummy head added)\\n        while left_count < l:\\n            left_prev = left\\n            left = left.next\\n            left_count += 1\\n\\n        # 2nd while loop (spot the right, right_next nodes)\\n        right = left\\n        right_next = left.next\\n        right_count = 0\\n        while right_count < r - l:\\n            right = right_next\\n            right_next = right_next.next\\n            right_count += 1\\n\\n        # 3rd while loop (reverse element between left and right node)\\n        cur = left\\n        pre = None\\n        while cur != right_next:\\n            tmp = cur.next\\n            cur.next = pre\\n            pre = cur\\n            cur = tmp\\n        \\n        # 4th fix breakage link\\n        left_prev.next = right\\n        left.next = right_next\\n\\n        head = dummy_head.next\\n        del dummy_head\\n        return head\\n```\\n# Java\\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode leftPrev = dummyHead;\\n        ListNode left = dummyHead.next;\\n        int leftCount = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (leftCount < l) {\\n            leftPrev = left;\\n            left = left.next;\\n            leftCount++;\\n        }\\n\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode right = left;\\n        ListNode rightNext = left.next;\\n        int rightCount = 0;\\n        while (rightCount < r - l) {\\n            right = rightNext;\\n            rightNext = rightNext.next;\\n            rightCount++;\\n        }\\n\\n        // 3rd while loop (reverse elements between left and right node)\\n        ListNode cur = left;\\n        ListNode pre = null;\\n        while (cur != rightNext) {\\n            ListNode tmp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n\\n        // 4th fix breakage link\\n        leftPrev.next = right;\\n        left.next = rightNext;\\n\\n        head = dummyHead.next;\\n        // remove(dummyHead);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```[1,2,3,4,5]```\n```2```\n```4```\n```[1,4,3,2,5]```\n```r```\n```l```\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode* dummy_head = new ListNode(-1);\\n        dummy_head->next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode* left_prev = dummy_head;\\n        ListNode* left = dummy_head->next;\\n        int left_count = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (left_count < l) {\\n            left_prev = left;\\n            left = left->next;\\n            left_count++;\\n        }\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode* right = left;\\n        ListNode* right_next = left->next;\\n        int right_count = 0;\\n        while (right_count < r - l) {\\n            right = right_next;\\n            right_next = right_next->next;\\n            right_count++;\\n        }\\n        // 3rd while loop (reverse element between left and right node)\\n        ListNode* cur = left;\\n        ListNode* pre = nullptr;\\n        while (cur != right_next) {\\n            ListNode* tmp = cur->next;\\n            cur->next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n        // 4th fix breakage link\\n        left_prev->next = right;\\n        left->next = right_next;\\n\\n        head = dummy_head->next;\\n        delete dummy_head;\\n        return head;\\n    }\\n};\\n```\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], l: int, r: int) -> Optional[ListNode]:\\n        \\n        # Dummy head insertion\\n        dummy_head = ListNode(None)\\n        dummy_head.next = head\\n\\n        # 1st while loop (spot left_prev, left nodes)\\n        left_prev = dummy_head\\n        left = dummy_head.next\\n        left_count = 1  # we start with 1 because we have to stop previous to left (because dummy head added)\\n        while left_count < l:\\n            left_prev = left\\n            left = left.next\\n            left_count += 1\\n\\n        # 2nd while loop (spot the right, right_next nodes)\\n        right = left\\n        right_next = left.next\\n        right_count = 0\\n        while right_count < r - l:\\n            right = right_next\\n            right_next = right_next.next\\n            right_count += 1\\n\\n        # 3rd while loop (reverse element between left and right node)\\n        cur = left\\n        pre = None\\n        while cur != right_next:\\n            tmp = cur.next\\n            cur.next = pre\\n            pre = cur\\n            cur = tmp\\n        \\n        # 4th fix breakage link\\n        left_prev.next = right\\n        left.next = right_next\\n\\n        head = dummy_head.next\\n        del dummy_head\\n        return head\\n```\n```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\n\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int l, int r) {\\n        // Dummy head insertion\\n        ListNode dummyHead = new ListNode(-1);\\n        dummyHead.next = head;\\n\\n        // 1st while loop (spot left_prev, left nodes)\\n        ListNode leftPrev = dummyHead;\\n        ListNode left = dummyHead.next;\\n        int leftCount = 1;  // we start with 1 because we have to stop previous to left (because dummy head added)\\n        while (leftCount < l) {\\n            leftPrev = left;\\n            left = left.next;\\n            leftCount++;\\n        }\\n\\n        // 2nd while loop (spot the right, right_next nodes)\\n        ListNode right = left;\\n        ListNode rightNext = left.next;\\n        int rightCount = 0;\\n        while (rightCount < r - l) {\\n            right = rightNext;\\n            rightNext = rightNext.next;\\n            rightCount++;\\n        }\\n\\n        // 3rd while loop (reverse elements between left and right node)\\n        ListNode cur = left;\\n        ListNode pre = null;\\n        while (cur != rightNext) {\\n            ListNode tmp = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = tmp;\\n        }\\n\\n        // 4th fix breakage link\\n        leftPrev.next = right;\\n        left.next = rightNext;\\n\\n        head = dummyHead.next;\\n        // remove(dummyHead);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012232,
                "title": "making-the-linked-list-isolated-easy-approach-o-n-complexity-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is same as the [**Reversal Of Linked List**](https://leetcode.com/problems/reverse-linked-list). But , the problem asked for reversal of specific part of the linked list to get reversed.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe mail approach is to make the the part of the linked list that is need to be reversed **isolated** from the *original linked list* and after the reversal make the original linked list connected with the reversed linked list.\\n\\n---\\n\\n# Steps Involved\\n- Traverse the linked list so that left2 represents the starting node of the list to be reversed and left1 represents the node before the left2.\\n ```\\nwhile(left-->1){\\n    left1=left2;\\n    left2=left2.next;\\n}\\n```\\n\\n- Traverse the linked list such that, right2 represents the end node of the list to be reversed. right1 represents the immediate node after right1.\\n```\\nwhile(right-->=1){\\n    right2=right1;\\n    right1=right1.next;\\n}\\n```\\n- Isolating the Linked list that is to be reversed.\\n```\\nif (l!=1)\\n    left1.next=null;    \\nright2.next=null;\\n```\\n\\n- The intention of making the condition l!=1 is that, if the given left most node is head , it is important to have it remebered. otherwise the traversal for the linked list will not get the head node.\\nTry it by removing the condition if you wanna see what happens \\uD83D\\uDE0A.\\n\\n- The Next part of code is for reversal of the isolated linked list.\\n```\\nListNode prev=null,next=null,curr=left2;\\n\\nwhile(curr!=null){\\n    next=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=next;\\n}\\n```\\n- Here comes the part where we will make the isolated reversed linked list connected with the original linked list.\\n\\n```\\nif (l==1){\\n    head.next=right1;\\n    return prev;\\n}        \\nleft1.next=prev;\\nleft2.next=right1;\\n```\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode left2=head,left1=head,right1=head,right2=head;\\n        int l=left;\\n        \\n        if (head==null)\\n            return null;\\n        if (head.next==null)\\n            return head;\\n\\n        \\n        while(left-->1){\\n            left1=left2;\\n            left2=left2.next;\\n        }\\n\\n        while(right-->=1){\\n            right2=right1;\\n            right1=right1.next;\\n        }\\n        \\n        if (l!=1)\\n            left1.next=null;\\n        \\n        right2.next=null;\\n        \\n        ListNode prev=null,next=null,curr=left2;\\n\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        if (l==1){\\n            head.next=right1;\\n            return prev;\\n        }\\n        \\n        left1.next=prev;\\n        left2.next=right1;\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nwhile(left-->1){\\n    left1=left2;\\n    left2=left2.next;\\n}\\n```\n```\\nwhile(right-->=1){\\n    right2=right1;\\n    right1=right1.next;\\n}\\n```\n```\\nif (l!=1)\\n    left1.next=null;    \\nright2.next=null;\\n```\n```\\nListNode prev=null,next=null,curr=left2;\\n\\nwhile(curr!=null){\\n    next=curr.next;\\n    curr.next=prev;\\n    prev=curr;\\n    curr=next;\\n}\\n```\n```\\nif (l==1){\\n    head.next=right1;\\n    return prev;\\n}        \\nleft1.next=prev;\\nleft2.next=right1;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode left2=head,left1=head,right1=head,right2=head;\\n        int l=left;\\n        \\n        if (head==null)\\n            return null;\\n        if (head.next==null)\\n            return head;\\n\\n        \\n        while(left-->1){\\n            left1=left2;\\n            left2=left2.next;\\n        }\\n\\n        while(right-->=1){\\n            right2=right1;\\n            right1=right1.next;\\n        }\\n        \\n        if (l!=1)\\n            left1.next=null;\\n        \\n        right2.next=null;\\n        \\n        ListNode prev=null,next=null,curr=left2;\\n\\n        while(curr!=null){\\n            next=curr.next;\\n            curr.next=prev;\\n            prev=curr;\\n            curr=next;\\n        }\\n        if (l==1){\\n            head.next=right1;\\n            return prev;\\n        }\\n        \\n        left1.next=prev;\\n        left2.next=right1;\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011933,
                "title": "c-optimal-solution-explained",
                "content": "# Intuition: Just reverse nodes inbetween L and R\\n\\n# Approach:\\n\\n**Step 1: Insert a Dummy Node**\\n- This will help us solve edge cases where the reversal starts from the head (node 1) of the list\\n- Without this, we will not have a previous node to act as our previous left node for future linking\\n- See code below for this insertion:\\n```\\n    ListNode* dummy = new ListNode(0,head);\\n    head = dummy;\\n```\\n\\n**Step 2: Find our Left Node and the Node before Left**\\n- As we can see below in the example, the left node (2) and left previous (1) play pivotal roles in solving the questions\\n- The left node is the start of the reverse part\\n- The node before the left is important as its next pointer needs to eventually be updated to the right node in the list\\n- See Example (note the dummy node is not included in diagram):\\n![IMG_0712.jpeg](https://assets.leetcode.com/users/images/1270f88d-57c7-413c-a5de-dc8d075c350c_1694047969.3313951.jpeg)\\n\\nThe following code will do this\\n```\\n // Step 2: Find l_prev and l\\n ListNode* curr = head->next; // original head\\nListNode* prev = dummy;\\n\\nfor(int i = 0; i < left - 1; i++) {\\n    prev = curr;\\n    curr = curr->next;\\n}\\n\\n```\\nNote: L - 1 iterations will ALWAYS reult in curr at the left node\\n\\n**Step 3: Reverse from L to R**\\n- to do this we will create a list that will result in this. \\n- Notice the previous pointer is left at the right node of the reversal, and curr is the right->next node\\n\\n![IMG_0715.jpeg](https://assets.leetcode.com/users/images/eddf30ad-3bb3-4281-be92-9d282881595a_1694048550.1179438.jpeg)\\n- See the code for this below:\\n```\\n// Step 3: Revere from L to r\\nListNode* left_prev = prev;\\nprev = nullptr;\\n\\nfor(int i = 0; i < right - left + 1; i++) {\\n    ListNode* temp = curr->next;\\n    curr->next = prev;\\n    prev = curr;\\n    curr = temp;\\n}\\n```\\n\\n**Step 4: Rerrange Pointers**\\n- In the above diagram we can see a couple of the next pointers that are not quite correct yet.\\n- The first is the original left node. It currently points to a nullptr. However in the example provided, we want this to point to the right->next node, which in the example is node 5. In the diagram above we can see the curr pointer is there after reversing the nodes. therefore we can directly set this next pointer. The next code snippet does this by making use of the left_prev->left connection\\n```\\nleft_prev->next->next = curr;\\n```\\n- The next pointer that is not correct is the left_prev->next pointer. It still points to the original left node (2). It is supposed to be pointing to the right node (4). In the diagram above we can see after the reverse iterations the prev pointer is positioned at the right node. Thefore we can directly update this connection\\n```\\n    left_prev->next = prev;\\n```\\n\\nwe can finally return dummy->next to return the next head of the rearrganged linked list.\\n\\n# Complexity\\n**Time complexity: O(n)**\\n- We only traverse through the linked list\\n\\n**Space complexity: O(1)**\\n- Only a constant amount of variables are used in this soloution\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head) return nullptr;\\n\\n        // Step 1: Add dummy node to front of LL\\n        ListNode* dummy = new ListNode(0,head);\\n        head = dummy;\\n\\n        // Step 2: Find l_prev and l\\n        ListNode* curr = head->next; // original head\\n        ListNode* prev = dummy;\\n\\n        for(int i = 0; i < left - 1; i++) {\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        // Step 3: Revere from L to r\\n        ListNode* left_prev = prev;\\n        prev = nullptr;\\n\\n        for(int i = 0; i < right - left + 1; i++) {\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n\\n        // Step 4: Rearrange pointers\\n        left_prev->next->next = curr;\\n        left_prev->next = prev;\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    ListNode* dummy = new ListNode(0,head);\\n    head = dummy;\\n```\n```\\n // Step 2: Find l_prev and l\\n ListNode* curr = head->next; // original head\\nListNode* prev = dummy;\\n\\nfor(int i = 0; i < left - 1; i++) {\\n    prev = curr;\\n    curr = curr->next;\\n}\\n\\n```\n```\\n// Step 3: Revere from L to r\\nListNode* left_prev = prev;\\nprev = nullptr;\\n\\nfor(int i = 0; i < right - left + 1; i++) {\\n    ListNode* temp = curr->next;\\n    curr->next = prev;\\n    prev = curr;\\n    curr = temp;\\n}\\n```\n```\\nleft_prev->next->next = curr;\\n```\n```\\n    left_prev->next = prev;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head) return nullptr;\\n\\n        // Step 1: Add dummy node to front of LL\\n        ListNode* dummy = new ListNode(0,head);\\n        head = dummy;\\n\\n        // Step 2: Find l_prev and l\\n        ListNode* curr = head->next; // original head\\n        ListNode* prev = dummy;\\n\\n        for(int i = 0; i < left - 1; i++) {\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n\\n        // Step 3: Revere from L to r\\n        ListNode* left_prev = prev;\\n        prev = nullptr;\\n\\n        for(int i = 0; i < right - left + 1; i++) {\\n            ListNode* temp = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = temp;\\n        }\\n\\n        // Step 4: Rearrange pointers\\n        left_prev->next->next = curr;\\n        left_prev->next = prev;\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773055,
                "title": "java-solution-explained-with-diagram-good-as-well-as-important-question",
                "content": "![image.png](https://assets.leetcode.com/users/images/463f4099-7ac8-4be9-a958-413a293f1722_1689502227.159058.png)\\n![image.png](https://assets.leetcode.com/users/images/86b9e30b-45cc-4e4f-9d97-0b29d0961779_1689502491.443635.png)\\n![image.png](https://assets.leetcode.com/users/images/8faa3fcc-168e-490b-aa43-0f5e824e15df_1689502611.894665.png)\\n\\nThis list is returned from the reverse function ;\\n\\n![image.png](https://assets.leetcode.com/users/images/8129bfee-56db-45a0-bcfc-1b593c2d9fde_1689502809.16709.png)\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        //first we handle the edge cases ;\\n        if(head==null||head.next==null){\\n            return head ;\\n        }\\n        //then e make a dummy node iterator and deveral different nodes like l,r and int x ;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode i = dummy ; int x = 0 ;\\n        ListNode l=null;ListNode r = null;ListNode temp = null;\\n\\n        //then we iterate i till i reaches null ;\\n        while(i!=null){\\n            //if i reaches 1 previous node to left index ; we put l node at that place;\\n            if(x==left-1){\\n                l = i;\\n            }if(x==right){\\n                //and it i reaches the right index we put r at that place ;\\n                r = i;\\n            }\\n            //then we move both pointer and iterator;\\n            i=i.next;x++;\\n        }\\n        \\n        //then what we have to do is make the next of r node to be null and move r by 1;\\n        if(r.next!=null){\\n            temp = r.next;\\n        }\\n\\n        r.next=null;\\n        r=temp;\\n\\n        //then we reverse the list; from l.next to null as we ahve seperated the list\\n        //that we have to revese;\\n        ListNode next = reverse(l.next,r);\\n        l.next=next;//here we just link the reverse list to l.next;\\n\\n        return dummy.next;\\n    }\\n    public ListNode reverse(ListNode l , ListNode r){\\n        //in this function i have to reverse the l lnked list and connect it to r;\\n        //this is a little bit tricky as i have both r and l in the function\\'s parameter\\n        //as you know when we reverse a linked list we make a dummt null and link it to the head of \\n        //linked list and then reverse all the links of the list ; here in the place of null\\n        // we are just joining it to the next part of our question\\'s linked list \\n        ListNode i = l ;\\n\\n        //this is simple reversing function ;\\n        while(i!=null){\\n            ListNode temp = i.next;\\n            i.next = r;\\n            r=i;\\n            i=temp;\\n        }\\n        return r;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        //first we handle the edge cases ;\\n        if(head==null||head.next==null){\\n            return head ;\\n        }\\n        //then e make a dummy node iterator and deveral different nodes like l,r and int x ;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode i = dummy ; int x = 0 ;\\n        ListNode l=null;ListNode r = null;ListNode temp = null;\\n\\n        //then we iterate i till i reaches null ;\\n        while(i!=null){\\n            //if i reaches 1 previous node to left index ; we put l node at that place;\\n            if(x==left-1){\\n                l = i;\\n            }if(x==right){\\n                //and it i reaches the right index we put r at that place ;\\n                r = i;\\n            }\\n            //then we move both pointer and iterator;\\n            i=i.next;x++;\\n        }\\n        \\n        //then what we have to do is make the next of r node to be null and move r by 1;\\n        if(r.next!=null){\\n            temp = r.next;\\n        }\\n\\n        r.next=null;\\n        r=temp;\\n\\n        //then we reverse the list; from l.next to null as we ahve seperated the list\\n        //that we have to revese;\\n        ListNode next = reverse(l.next,r);\\n        l.next=next;//here we just link the reverse list to l.next;\\n\\n        return dummy.next;\\n    }\\n    public ListNode reverse(ListNode l , ListNode r){\\n        //in this function i have to reverse the l lnked list and connect it to r;\\n        //this is a little bit tricky as i have both r and l in the function\\'s parameter\\n        //as you know when we reverse a linked list we make a dummt null and link it to the head of \\n        //linked list and then reverse all the links of the list ; here in the place of null\\n        // we are just joining it to the next part of our question\\'s linked list \\n        ListNode i = l ;\\n\\n        //this is simple reversing function ;\\n        while(i!=null){\\n            ListNode temp = i.next;\\n            i.next = r;\\n            r=i;\\n            i=temp;\\n        }\\n        return r;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768814,
                "title": "easy-java-solution-easy-to-understand-beats-100",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(left == right) {\\n            return head;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        for(int i = 1; curr != null && i < left; i++) {\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode temp = prev;\\n        ListNode temp1 = curr;\\n        ListNode forw = null;\\n\\n        for(int i = left; i <=  right; i++) {\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n\\n        if(temp != null) {\\n            temp.next = prev;\\n        }\\n        else {\\n        head = prev;\\n        }\\n\\n        temp1.next = curr;\\n        return head;\\n    }\\n}\\n```\\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/90e24a6e-1b48-458f-ae07-8180ee271778_1689426592.0713346.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(left == right) {\\n            return head;\\n        }\\n\\n        ListNode prev = null;\\n        ListNode curr = head;\\n\\n        for(int i = 1; curr != null && i < left; i++) {\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode temp = prev;\\n        ListNode temp1 = curr;\\n        ListNode forw = null;\\n\\n        for(int i = left; i <=  right; i++) {\\n            forw = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = forw;\\n        }\\n\\n        if(temp != null) {\\n            temp.next = prev;\\n        }\\n        else {\\n        head = prev;\\n        }\\n\\n        temp1.next = curr;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609243,
                "title": "easy-to-understand-c-solution-using-vectors",
                "content": "# Intuition\\n<!-- DeI scribe your first thoughts on how to solve this problem. -->\\nI need to swap left and right indices and keep on doing it until they both collide \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCopy all the values in vector , swap left and right and keep on doing it until left!=right\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int> buff;\\n        ListNode *p = head;\\n        int i = 0;\\n        \\n        while (p != nullptr) {\\n            buff.push_back(p->val);\\n            p = p->next;\\n            i++;\\n        }\\n        \\n        while (left < right) {\\n            swap(buff[left - 1], buff[right - 1]);\\n            left++;\\n            right--;\\n        }\\n        \\n        ListNode* newHead = new ListNode(buff[0]);\\n        ListNode* current = newHead;\\n        \\n        for (int i = 1; i < buff.size(); i++) {\\n            ListNode* newNode = new ListNode(buff[i]);\\n            current->next = newNode;\\n            current = newNode;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int> buff;\\n        ListNode *p = head;\\n        int i = 0;\\n        \\n        while (p != nullptr) {\\n            buff.push_back(p->val);\\n            p = p->next;\\n            i++;\\n        }\\n        \\n        while (left < right) {\\n            swap(buff[left - 1], buff[right - 1]);\\n            left++;\\n            right--;\\n        }\\n        \\n        ListNode* newHead = new ListNode(buff[0]);\\n        ListNode* current = newHead;\\n        \\n        for (int i = 1; i < buff.size(); i++) {\\n            ListNode* newNode = new ListNode(buff[i]);\\n            current->next = newNode;\\n            current = newNode;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149900,
                "title": "easy-solution-o-n",
                "content": "# Code\\n    C++ easy solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right)\\n    {\\n        if(head==NULL || head->next==NULL) return head;    //if list contain only single node or no node\\n        ListNode *h1=head;\\n        ListNode *x = head;\\n        ListNode *x1=head,*x2=head;\\n        int n = 0;\\n        while(x!=NULL) {\\n            n++;\\n            x=x->next;\\n        }\\n        if(left==n) return head;   //if left position is equal to size \\n        int i=1;\\n        while(i<left) {      //assining left position\\n            x1 = h1;\\n            h1=h1->next;\\n            i++;\\n        }\\n        ListNode *t1=head;\\n        if(right<n) {        //assigning right position\\n            i=1;\\n            while(i<right){\\n                t1=t1->next;\\n                i++;\\n            }\\n            x2=t1->next;\\n            t1->next=NULL;\\n        }\\n        ListNode *t = NULL, *p=NULL;\\n        ListNode *temp = h1;\\n        while(h1!=NULL)       //reversing from left positin to right position\\n        {\\n            t=h1->next;\\n            h1->next=p;\\n            p=h1;\\n            h1=t;\\n        }\\n        h1=p;\\n        while(p->next != NULL)\\n            p=p->next;\\n        if(left!=1)\\n        {\\n            x1->next=h1;\\n            if(right != n)\\n                temp->next = x2;\\n            return head;\\n        }\\n        if(right != n)\\n                temp->next = x2;\\n        return h1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right)\\n    {\\n        if(head==NULL || head->next==NULL) return head;    //if list contain only single node or no node\\n        ListNode *h1=head;\\n        ListNode *x = head;\\n        ListNode *x1=head,*x2=head;\\n        int n = 0;\\n        while(x!=NULL) {\\n            n++;\\n            x=x->next;\\n        }\\n        if(left==n) return head;   //if left position is equal to size \\n        int i=1;\\n        while(i<left) {      //assining left position\\n            x1 = h1;\\n            h1=h1->next;\\n            i++;\\n        }\\n        ListNode *t1=head;\\n        if(right<n) {        //assigning right position\\n            i=1;\\n            while(i<right){\\n                t1=t1->next;\\n                i++;\\n            }\\n            x2=t1->next;\\n            t1->next=NULL;\\n        }\\n        ListNode *t = NULL, *p=NULL;\\n        ListNode *temp = h1;\\n        while(h1!=NULL)       //reversing from left positin to right position\\n        {\\n            t=h1->next;\\n            h1->next=p;\\n            p=h1;\\n            h1=t;\\n        }\\n        h1=p;\\n        while(p->next != NULL)\\n            p=p->next;\\n        if(left!=1)\\n        {\\n            x1->next=h1;\\n            if(right != n)\\n                temp->next = x2;\\n            return head;\\n        }\\n        if(right != n)\\n                temp->next = x2;\\n        return h1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095221,
                "title": "easy-solution-pointers-and-counter-easy-understanding-very-fast",
                "content": "# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1) => because it\\'s just a static pointers and we are changing their refrences \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    let currNode = head, start = head, counter = 1;\\n    while(counter < left) {\\n        start = currNode; \\n        currNode = currNode.next;\\n        counter++;\\n    }\\n    let tail = currNode, prev = null;\\n    while(counter >=  left && counter <= right){\\n        const next = currNode.next;\\n        currNode.next = prev;\\n        prev = currNode;\\n        currNode = next;\\n        counter++;\\n    }\\n    start.next = prev;\\n    tail.next = currNode;\\n    if(left > 1){\\n        return head;\\n    }else{\\n        return prev\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Linked List",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} left\\n * @param {number} right\\n * @return {ListNode}\\n */\\nvar reverseBetween = function(head, left, right) {\\n    let currNode = head, start = head, counter = 1;\\n    while(counter < left) {\\n        start = currNode; \\n        currNode = currNode.next;\\n        counter++;\\n    }\\n    let tail = currNode, prev = null;\\n    while(counter >=  left && counter <= right){\\n        const next = currNode.next;\\n        currNode.next = prev;\\n        prev = currNode;\\n        currNode = next;\\n        counter++;\\n    }\\n    start.next = prev;\\n    tail.next = currNode;\\n    if(left > 1){\\n        return head;\\n    }else{\\n        return prev\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3045252,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* pre = dummy;\\n        for(int i = 0; i < m-1; i++)\\n            pre = pre->next;\\n        ListNode* cur=pre->next;\\n        ListNode* curR = cur;\\n        ListNode* pre_R = pre;\\n        //reverse \\n        for(int i = m; i <= n; i++){\\n            ListNode* next = curR->next;\\n            curR->next = pre_R;\\n            pre_R = curR;\\n            curR = next;\\n        }\\n        \\n        //connect\\n        pre->next = pre_R;\\n        cur->next = curR;\\n\\t\\t\\n        return dummy->next;    \\n\\t}\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head == NULL || head->next == NULL) return head;\\n        \\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        \\n        ListNode* pre = dummy;\\n        for(int i = 0; i < m-1; i++)\\n            pre = pre->next;\\n        ListNode* cur=pre->next;\\n        ListNode* curR = cur;\\n        ListNode* pre_R = pre;\\n        //reverse \\n        for(int i = m; i <= n; i++){\\n            ListNode* next = curR->next;\\n            curR->next = pre_R;\\n            pre_R = curR;\\n            curR = next;\\n        }\\n        \\n        //connect\\n        pre->next = pre_R;\\n        cur->next = curR;\\n\\t\\t\\n        return dummy->next;    \\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698062,
                "title": "easy-solution-diagrams-approach",
                "content": "**Python**\\n\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\\n\\n\\n**JAVA**\\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        //first part\\n        ListNode cur1 = dummy;\\n        ListNode pre1 = null;\\n        for(int i=0;i<m;i++){\\n            pre1 = cur1;\\n            cur1 = cur1.next;\\n        }\\n        \\n        //reverse\\n        ListNode cur2 = cur1;\\n        ListNode pre2 = pre1;\\n        ListNode q2;\\n        for(int i=m;i<=n;i++){\\n            q2 = cur2.next;\\n            cur2.next = pre2;\\n            pre2 = cur2;\\n            cur2 = q2;\\n        }\\n        \\n        //connect \\n        pre1.next = pre2;\\n        cur1.next = cur2;\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n# *DIAGRAMS*\\n\\nhttps://assets.leetcode.com/users/images/286faf1c-7e7b-44a8-ab21-093645471823_1665657107.7047188.png\\n\\n![image](https://assets.leetcode.com/users/images/589ce713-275e-4604-be95-b262dbfb9256_1665657060.8020976.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/8bcfc04c-fcf6-46e0-ad60-c491c8dfb8c7_1665657076.5328043.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/0453d446-ec80-4448-b417-b37203f973ce_1665657093.2993279.png)\\n\\n\\n**The backtracking process. We don\\'t recurse further. The operation performed during the backtracking is swapping of data between the left and right nodes.**\\n\\n![image](https://assets.leetcode.com/users/images/286faf1c-7e7b-44a8-ab21-093645471823_1665657107.7047188.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseBetween(self, head, m, n):\\n        \"\"\"\\n        :type head: ListNode\\n        :type m: int\\n        :type n: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head or m == n: return head\\n        p = dummy = ListNode(None)\\n        dummy.next = head\\n        for i in range(m-1): p = p.next\\n        tail = p.next\\n\\n        for i in range(n-m):\\n            tmp = p.next                  # a)\\n            p.next = tail.next            # b)\\n            tail.next = tail.next.next    # c)\\n            p.next.next = tmp             # d)\\n        return dummy.next\\n```\n```\\npublic class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        //first part\\n        ListNode cur1 = dummy;\\n        ListNode pre1 = null;\\n        for(int i=0;i<m;i++){\\n            pre1 = cur1;\\n            cur1 = cur1.next;\\n        }\\n        \\n        //reverse\\n        ListNode cur2 = cur1;\\n        ListNode pre2 = pre1;\\n        ListNode q2;\\n        for(int i=m;i<=n;i++){\\n            q2 = cur2.next;\\n            cur2.next = pre2;\\n            pre2 = cur2;\\n            cur2 = q2;\\n        }\\n        \\n        //connect \\n        pre1.next = pre2;\\n        cur1.next = cur2;\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311349,
                "title": "easy-to-understand-c-solution-with-explanation",
                "content": "I\\'ll try to explain in simple words.\\n\\n1. Take a TempPrev variable to store, such that from left = TempPrev + 1, So we can connect the reversed sub-linkedlist to it.\\n2. Next we Store the curr_p = right + 1.\\nSo that we can connect the remaining one to the right side.\\n3. Reverse the linkedlist in regular fashion.\\n4. Connect the parts.\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode * start = head;\\n        ListNode * tempPrev = new ListNode(0,head); // Will be at left - 1\\n        int cnt = 1;\\n        while(cnt < left)\\n            cnt++,tempPrev = tempPrev->next,head=head->next;\\n        ListNode * temp = head;\\n        ListNode * prev_p = NULL;\\n        ListNode * curr_p = head;\\n        ListNode * next_p;\\n        \\n        while(cnt <= right){\\n            next_p = curr_p -> next;\\n            curr_p -> next = prev_p;\\n            \\n            prev_p = curr_p;\\n            curr_p = next_p;\\n            cnt++;\\n        }\\n        head = prev_p;\\n        tempPrev->next = head;\\n        temp->next = curr_p;\\n        if(left == 1) // Starting point will change\\n            return head;\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode * start = head;\\n        ListNode * tempPrev = new ListNode(0,head); // Will be at left - 1\\n        int cnt = 1;\\n        while(cnt < left)\\n            cnt++,tempPrev = tempPrev->next,head=head->next;\\n        ListNode * temp = head;\\n        ListNode * prev_p = NULL;\\n        ListNode * curr_p = head;\\n        ListNode * next_p;\\n        \\n        while(cnt <= right){\\n            next_p = curr_p -> next;\\n            curr_p -> next = prev_p;\\n            \\n            prev_p = curr_p;\\n            curr_p = next_p;\\n            cnt++;\\n        }\\n        head = prev_p;\\n        tempPrev->next = head;\\n        temp->next = curr_p;\\n        if(left == 1) // Starting point will change\\n            return head;\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310666,
                "title": "daily-leetcoding-challenge-july-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-linked-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterative Link Reversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-linked-list-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2254933,
                "title": "java-100-faster-0-ms-time-complexity-o-n-space-complexity-o-1",
                "content": "To solve the quesrion you have to add the sentinal node so that edge case of head node will become the intermidiate node and make problem easy to solve.\\n```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode sentinalNode = new ListNode(0,head);\\n        var temp = sentinalNode;\\n        \\n        for(int i = 0;i<left-1;i++){\\n            temp = temp.next;\\n        }\\n        var start = temp.next;\\n        for(int i = 0 ;start!=null && start.next!=null && i < right - left;i++){\\n            var next = start.next;\\n            start.next = start.next.next;\\n            next.next = temp.next;\\n            temp.next = next; \\n        }\\n        return sentinalNode.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode sentinalNode = new ListNode(0,head);\\n        var temp = sentinalNode;\\n        \\n        for(int i = 0;i<left-1;i++){\\n            temp = temp.next;\\n        }\\n        var start = temp.next;\\n        for(int i = 0 ;start!=null && start.next!=null && i < right - left;i++){\\n            var next = start.next;\\n            start.next = start.next.next;\\n            next.next = temp.next;\\n            temp.next = next; \\n        }\\n        return sentinalNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523758,
                "title": "amazing-approach-to-solve-in-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head || left==right) return head;\\n        ListNode dummy(0);\\n        dummy.next=head;\\n        ListNode* nodebeforesublist=&dummy;\\n        int pos=1;\\n        while(pos<left){\\n            nodebeforesublist=nodebeforesublist->next;\\n            pos++;\\n        }\\n        ListNode* workingptr=nodebeforesublist->next;\\n        while(left<right){\\n            ListNode* nodetobeextracted=workingptr->next;\\n            workingptr->next=nodetobeextracted->next;\\n            \\n            nodetobeextracted->next=nodebeforesublist->next;\\n            nodebeforesublist->next=nodetobeextracted;\\n            left++;\\n        }\\n        return dummy.next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head || left==right) return head;\\n        ListNode dummy(0);\\n        dummy.next=head;\\n        ListNode* nodebeforesublist=&dummy;\\n        int pos=1;\\n        while(pos<left){\\n            nodebeforesublist=nodebeforesublist->next;\\n            pos++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1427894,
                "title": "sharing-simplest-c-solution-beats-100",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right || head==NULL || left==right ) return head;      // Base Condition\\n        \\n        ListNode* dummy=new ListNode(0);                //Dummy Node\\n        ListNode *curr=head,*prev=dummy,*nxt=NULL;\\n        dummy->next=head;\\n        \\n        for(int i=1;i<left; i++)                                        //Make left position node as curr\\n              {    prev=curr;                                              //Store previous element of left node in prev\\n\\t\\t\\t       curr=curr->next;\\n              }\\n        ListNode *first=curr,*temp=prev;                   //store current in first because its the element at left pos\\n        for(int i=1;i<=(right-left)+1;i++)                    //store previous element of first in temp,because here we modify prev element\\n            {  nxt=curr->next;                                     \\n              curr->next=prev;\\n              prev=curr;\\n             curr=nxt;\\n        }                                // Here prev return newhead of reversed linkedlist\\n        \\n        temp->next=prev;   \\n        first->next=curr;\\n        return dummy->next;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right || head==NULL || left==right ) return head;      // Base Condition\\n        \\n        ListNode* dummy=new ListNode(0);                //Dummy Node\\n        ListNode *curr=head,*prev=dummy,*nxt=NULL;\\n        dummy->next=head;\\n        \\n        for(int i=1;i<left; i++)                                        //Make left position node as curr\\n              {    prev=curr;                                              //Store previous element of left node in prev\\n\\t\\t\\t       curr=curr->next;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1292564,
                "title": "reverse-linked-list-ii-java-iterative-approach-with-one-pass-o-n-solution",
                "content": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n\\n        // In case of empty list return null\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        int count = 1;\\n\\n        // Move curr and prev until they reach proper starting point in the list\\n        ListNode curr = head;\\n\\n        ListNode prev = null;\\n\\n        while (curr != null && count < left) {\\n            prev = curr;\\n            curr = curr.next;\\n            count++;\\n        }\\n\\n        // A node before the subList\\'s node\\n        ListNode beforeNode = prev;\\n\\n        // Sublist\\'s first node\\n        ListNode subHead = curr;\\n\\n        ListNode next;\\n\\n        // Reverse the sublist\\n        while (curr != null && count <= right) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Fix the connections\\n        if (beforeNode != null) {\\n            beforeNode.next = prev;\\n        } else {\\n            head = prev;\\n        }\\n\\n        subHead.next = curr;\\n\\n        return head;\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n\\n        // In case of empty list return null\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        int count = 1;\\n\\n        // Move curr and prev until they reach proper starting point in the list\\n        ListNode curr = head;\\n\\n        ListNode prev = null;\\n\\n        while (curr != null && count < left) {\\n            prev = curr;\\n            curr = curr.next;\\n            count++;\\n        }\\n\\n        // A node before the subList\\'s node\\n        ListNode beforeNode = prev;\\n\\n        // Sublist\\'s first node\\n        ListNode subHead = curr;\\n\\n        ListNode next;\\n\\n        // Reverse the sublist\\n        while (curr != null && count <= right) {\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            count++;\\n        }\\n\\n        // Fix the connections\\n        if (beforeNode != null) {\\n            beforeNode.next = prev;\\n        } else {\\n            head = prev;\\n        }\\n\\n        subHead.next = curr;\\n\\n        return head;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1291790,
                "title": "c-reverse-linked-list-ii-one-pass-solution",
                "content": "So reversing a part of a linked list is very similar to reversing the whole list, but we just have to handle the elements at the boundary of the reverse sublist, i.e the element before left and the element after right (let\\'s assume that the first one is start and the second one is end).\\n\\nWe use the usual three pointer approach to reversing the linked list, this time just limiting the number of iterations so that we end up with c = end (i.e the element after right). \\nThen we put b->next = a, but don\\'t increment the pointers, since this is the last step of the reversing operation. Now the start of the sublist is pointed to by b and let\\'s say we have a reference to both the start pointer (as mentioned above) and the actual starting point of the sublist (i.e left). \\nThen to make the list consistent again, but with reversed order, we assign `start->next = b` and `left->next = c`. \\n\\nBut now we will need to think about some edge cases.\\n\\n1. What if left == 1? \\n\\there our start pointer will be nullptr, so we have to handle that separately and c will become the new head, so we return that.\\n2. What if left == right?\\n\\there we don\\'t have to do anything, since the length of the reversed subarray is only 1 element, so we just return the list as it was.\\n3. What if the list has fewer than two elements?\\n\\tthen we handle that separately, checking if left == 1 and right == 2 and length == 2, then either just reversing the list, or returning the same list.\\n\\t\\nAfter incorporating the following checks into the code, here is the result:\\n```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\tListNode *a = nullptr, *b = head, *c = head->next;\\n\\tif(!b || !c) return head;\\n\\tif(left == right) return head;\\n\\tfor(int i = 0; i<left-1; i++) {\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tListNode *start = a;\\n\\tListNode *rev_start = b;\\n\\ta = b;\\n\\tb = c;\\n\\tc = c->next;\\n\\tfor(int i = left + 1; i<right; i++) {\\n\\t\\tb->next = a;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tb->next = a;\\n\\trev_start->next = c;\\n\\tif(left == 1) {\\n\\t\\treturn b;\\n\\t}\\n\\tstart->next = b;\\n\\treturn head;\\n}\\n```\\n\\n**Time: O(n)**, its just a single pass of the list, (not even a full single pass)\\n**Space: O(1)**, just a bunch of pointers.\\n\\n<br/>\\n\\nFeel free to ask any doubts, or suggest any corrections/improvements in the comments, and please upvote this post if you liked it.\\n**Note:** I just noticed that I didn\\'t incorporate the last check (that for fewer than 2 elements) quite correctly. I forgot to account for the case where there are only two elements and left == 1 and right == 2. So please be sure to incorporate that. But anyways, it passed without that as well :P.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n\\tListNode *a = nullptr, *b = head, *c = head->next;\\n\\tif(!b || !c) return head;\\n\\tif(left == right) return head;\\n\\tfor(int i = 0; i<left-1; i++) {\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tListNode *start = a;\\n\\tListNode *rev_start = b;\\n\\ta = b;\\n\\tb = c;\\n\\tc = c->next;\\n\\tfor(int i = left + 1; i<right; i++) {\\n\\t\\tb->next = a;\\n\\t\\ta = b;\\n\\t\\tb = c;\\n\\t\\tc = c->next;\\n\\t}\\n\\tb->next = a;\\n\\trev_start->next = c;\\n\\tif(left == 1) {\\n\\t\\treturn b;\\n\\t}\\n\\tstart->next = b;\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831030,
                "title": "c-easiest-sol-so-far-using-vector-beats-65-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head==NULL)\\n            return NULL;\\n        vector<int>v;\\n        ListNode *p=head;\\n        while(p!=NULL)\\n        {\\n            v.push_back(p->val);\\n            p=p->next;\\n        }\\n        p=head;\\n        for(int i=0;i<m-1;i++) //till m-1 values will remain same as in the list..\\n            p=p->next;\\n        for(int i=n;i>=m;i--)\\n        {\\n            p->val=v[i-1];    //reverse the value within range..\\n            p=p->next;\\n        }\\n        return head;",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if(head==NULL)\\n            return NULL;\\n        vector<int>v;\\n        ListNode *p=head;\\n        while(p!=NULL)\\n        {\\n            v.push_back(p->val);\\n            p=p->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 300120,
                "title": "java-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\n\\t// logic: keep swapping next elements and change the pointers accordingly\\n    private static LinkedListUtils.ListNode reverseBetween(LinkedListUtils.ListNode head, int m, int n) {\\n        if (head == null || head.next == null || m <= 0 || n <= 0) {\\n            return head;\\n        }\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode pre = dummyNode;\\n        ListNode start = head;\\n\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre.next;\\n            start = start.next;\\n        }\\n\\n        // flow of execution in each iteration (for the 2nd input): 1->2->3->4->5->6->7  |  1->2->4->3->5->6->7 | 1->2->5->4->3->6->7 | 1->2->6->5->4->3->7 | 1->2->7->6->5->4->3\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode current = start.next;\\n            start.next = current.next;\\n            current.next = pre.next;\\n            pre.next = current;\\n        }\\n        return dummyNode.next;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t// logic: keep swapping next elements and change the pointers accordingly\\n    private static LinkedListUtils.ListNode reverseBetween(LinkedListUtils.ListNode head, int m, int n) {\\n        if (head == null || head.next == null || m <= 0 || n <= 0) {\\n            return head;\\n        }\\n        ListNode dummyNode = new ListNode(0);\\n        dummyNode.next = head;\\n        ListNode pre = dummyNode;\\n        ListNode start = head;\\n\\n        for (int i = 0; i < m - 1; i++) {\\n            pre = pre.next;\\n            start = start.next;\\n        }\\n\\n        // flow of execution in each iteration (for the 2nd input): 1->2->3->4->5->6->7  |  1->2->4->3->5->6->7 | 1->2->5->4->3->6->7 | 1->2->6->5->4->3->7 | 1->2->7->6->5->4->3\\n        for (int i = 0; i < n - m; i++) {\\n            ListNode current = start.next;\\n            start.next = current.next;\\n            current.next = pre.next;\\n            pre.next = current;\\n        }\\n        return dummyNode.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 259924,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n\\t  guard head != nil else { return nil }\\n\\t\\t\\n      let dm: ListNode? = ListNode(0)\\n      dm?.next = head\\n\\n      var before = dm\\n\\n      for _ in 0..<m-1 {\\n        before = before?.next\\n      }\\n\\n      let endOfReverse = before?.next\\n      var prev = before?.next\\n      var curr = prev?.next\\n\\n      for _ in 0..<n-m {\\n        let next = curr?.next\\n        curr?.next = prev\\n        prev = curr\\n        curr = next\\n      }\\n\\n      before?.next = prev\\n      endOfReverse?.next = curr\\n\\n      return dm?.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n\\t  guard head != nil else { return nil }\\n\\t\\t\\n      let dm: ListNode? = ListNode(0)\\n      dm?.next = head\\n\\n      var before = dm\\n\\n      for _ in 0..<m-1 {\\n        before = before?.next\\n      }\\n\\n      let endOfReverse = before?.next\\n      var prev = before?.next\\n      var curr = prev?.next\\n\\n      for _ in 0..<n-m {\\n        let next = curr?.next\\n        curr?.next = prev\\n        prev = curr\\n        curr = next\\n      }\\n\\n      before?.next = prev\\n      endOfReverse?.next = curr\\n\\n      return dm?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226518,
                "title": "concise-javascript",
                "content": "```javascript\\nvar reverseBetween = function(head, m, n) {\\n  let dummy = new ListNode(undefined);\\n  let sentinel = dummy;\\n  sentinel.next = head;\\n  \\n  for(let i = 1; i < m; i++) {\\n    sentinel = sentinel.next;\\n  }\\n  \\n  let curr = sentinel.next;\\n  let next = curr.next;\\n  \\n  for(let i = 0; i < n - m; i++) {\\n    curr.next = next.next;\\n    next.next = sentinel.next;\\n    sentinel.next = next;\\n    \\n    next = curr.next;\\n  }\\n  \\n  return dummy.next;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar reverseBetween = function(head, m, n) {\\n  let dummy = new ListNode(undefined);\\n  let sentinel = dummy;\\n  sentinel.next = head;\\n  \\n  for(let i = 1; i < m; i++) {\\n    sentinel = sentinel.next;\\n  }\\n  \\n  let curr = sentinel.next;\\n  let next = curr.next;\\n  \\n  for(let i = 0; i < n - m; i++) {\\n    curr.next = next.next;\\n    next.next = sentinel.next;\\n    sentinel.next = next;\\n    \\n    next = curr.next;\\n  }\\n  \\n  return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30770,
                "title": "clean-yet-efficient-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        ListNode newHead(0);\\n        newHead.next = head;\\n        ListNode *pre = &newHead, *cur = head, *next = NULL;\\n        int i = 1;\\n        while(i < n)\\n        {\\n            if(i++ < m) { pre = cur; cur = cur->next; }\\n            else\\n            { \\n                next = cur->next; \\n                cur->next = cur->next->next; \\n                next->next = pre->next; \\n                pre->next = next; \\n            }\\n        }\\n        return newHead.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) \\n    {\\n        ListNode newHead(0);\\n        newHead.next = head;\\n        ListNode *pre = &newHead, *cur = head, *next = NULL;\\n        int i = 1;\\n        while(i < n)\\n        {\\n            if(i++ < m) { pre = cur; cur = cur->next; }\\n            else\\n            { \\n                next = cur->next; \\n                cur->next = cur->next->next; \\n                next->next = pre->next; \\n                pre->next = next; \\n            }\\n        }\\n        return newHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 30803,
                "title": "c-solution-for-reverse-linked-list-ii",
                "content": "    typedef struct ListNode node;\\n\\n    struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {\\n    if(head == NULL || head->next == NULL || m == n)\\n        return head;\\n        \\n    node *temp = head;\\n    node *start = head;\\n    int i = 1;\\n    \\n    while(i < m && temp->next != NULL)\\n    {\\n        start = temp;\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    node *curr = temp->next;\\n    node *prev = temp;\\n    node *t;\\n    prev->next = NULL;\\n    \\n    while(i < n && curr != NULL)\\n    {\\n        t = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = t;\\n        i++;\\n    }\\n    \\n    start->next = prev;\\n    temp->next = curr;\\n    \\n    if(m == 1)\\n        return prev;\\n    return head;\\n}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "    typedef struct ListNode node;\\n\\n    struct ListNode* reverseBetween(struct ListNode* head, int m, int n) {\\n    if(head == NULL || head->next == NULL || m == n)\\n        return head;\\n        \\n    node *temp = head;\\n    node *start = head;\\n    int i = 1;\\n    \\n    while(i < m && temp->next != NULL)\\n    {\\n        start = temp;\\n        temp = temp->next;\\n        i++;\\n    }\\n    \\n    node *curr = temp->next;\\n    node *prev = temp;\\n    node *t;\\n    prev->next = NULL;\\n    \\n    while(i < n && curr != NULL)\\n    {\\n        t = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = t;\\n        i++;\\n    }\\n    \\n    start->next = prev;\\n    temp->next = curr;\\n    \\n    if(m == 1)\\n        return prev;\\n    return head;\\n}",
                "codeTag": "Python3"
            },
            {
                "id": 4088356,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next==null || right==left) return head;\\n        boolean check = false;\\n        ListNode Pleft = null;\\n        ListNode Pright = null;\\n        ListNode Tleft = null;\\n        ListNode Tright = null;\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            if(count==left-1)   Pleft = curr;\\n            if(count==right+1)  Pright = curr;          \\n            if(count==left)     Tleft = curr;\\n            if(count==right)    Tright = curr;\\n            curr = curr.next;\\n        }\\n        if(Tleft==head)  check = true;     \\n        if(Pleft!=null && Pleft.next!=null)  Pleft.next = null;\\n        if(Tright.next!=null) Tright.next = null;\\n        curr = Tleft;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }    \\n        if(Pleft!=null )  Pleft.next = Tright;\\n        Tleft.next = Pright;\\n        if(head.next==null || check)  return Tright;\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next==null || right==left) return head;\\n        boolean check = false;\\n        ListNode Pleft = null;\\n        ListNode Pright = null;\\n        ListNode Tleft = null;\\n        ListNode Tright = null;\\n        ListNode curr = head;\\n        int count = 0;\\n        while(curr!=null){\\n            count++;\\n            if(count==left-1)   Pleft = curr;\\n            if(count==right+1)  Pright = curr;          \\n            if(count==left)     Tleft = curr;\\n            if(count==right)    Tright = curr;\\n            curr = curr.next;\\n        }\\n        if(Tleft==head)  check = true;     \\n        if(Pleft!=null && Pleft.next!=null)  Pleft.next = null;\\n        if(Tright.next!=null) Tright.next = null;\\n        curr = Tleft;\\n        ListNode prev = null;\\n        ListNode next = null;\\n        while(curr!=null){\\n            next = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n        }    \\n        if(Pleft!=null )  Pleft.next = Tright;\\n        Tleft.next = Pright;\\n        if(head.next==null || check)  return Tright;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012831,
                "title": "java-single-pass-solution-explanation-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution uses the approach of reversing the list in a smarter way that is using the insert at starting.\\n1->2->3\\n\\nremove 1 \\n \\nnew list: 1\\ncurr list: 2->3\\n\\nremove 2\\ninsert at start\\n\\nnew list: 2->1\\ncurr list: 3\\n\\nremove 3\\n\\nnew list: 3->2->1\\ncurr list : {}\\nKeep in mind to mark the next pointer of curr null \\uD83D\\uDE09\\n\\nWe have created temporary head and temporary tail which will store the reversed linkedlist.\\n\\n\\nCan you solve reverseInKgroup using this?? (made something much easy for you) \\uD83C\\uDFC6\\uD83C\\uDFC6\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprev pointer is taken so that we can be just behind the curr pointer because when we our in range where we have to reverse the linkedList. we need to hold on our prev Node so that once we get the fully reversed linkedList we can simply attach that prev node to the temporary head and temporary tail to the curr.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode th=null;\\n    ListNode tt=null;\\n    void addFirst(ListNode node){\\n        if(th==null){\\n            th=node;\\n            tt=node;\\n        }\\n        else{\\n            node.next=th;\\n            th=node;\\n        }\\n    }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        int idx=1;\\n        while(curr!=null){\\n            while(idx>=left && idx<=right){\\n                ListNode fwd = curr.next;\\n                curr.next=null;\\n                addFirst(curr);\\n                curr=fwd;\\n                idx++;\\n            }\\n            if(idx>right){\\n                if(prev!=null){\\n                    prev.next=th;\\n                    tt.next=curr;\\n                    return head;\\n                }\\n                else{\\n                    tt.next=curr;\\n                    return th;\\n                }\\n            }\\n            idx++;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n![please upvote me.jpg](https://assets.leetcode.com/users/images/9d9aaf36-e638-4581-9ae8-36466e9548b3_1694068310.5698211.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    ListNode th=null;\\n    ListNode tt=null;\\n    void addFirst(ListNode node){\\n        if(th==null){\\n            th=node;\\n            tt=node;\\n        }\\n        else{\\n            node.next=th;\\n            th=node;\\n        }\\n    }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        int idx=1;\\n        while(curr!=null){\\n            while(idx>=left && idx<=right){\\n                ListNode fwd = curr.next;\\n                curr.next=null;\\n                addFirst(curr);\\n                curr=fwd;\\n                idx++;\\n            }\\n            if(idx>right){\\n                if(prev!=null){\\n                    prev.next=th;\\n                    tt.next=curr;\\n                    return head;\\n                }\\n                else{\\n                    tt.next=curr;\\n                    return th;\\n                }\\n            }\\n            idx++;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012534,
                "title": "c-easy-explanation-pictorial-explanation",
                "content": "## Logic\\n- This is one of the *standard* question in Single Linked List.\\n- I have solved it using ***three pointer approach*** which is *inplace* and fast.\\n\\n## Implementation\\n```\\nListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\t//The three pointers here are prev , curr and forw\\n            ListNode *temp = new ListNode(0);\\n\\t\\t\\t//A dummy node before head\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n```\\n\\n## Pictorial Representation\\n![image](https://assets.leetcode.com/users/images/3e2162ba-9084-40f7-97b6-81ee2cca70d9_1658424854.7308772.jpeg)\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanation and if there is any scope of improvement do mention it in the comments section\\uD83D\\uDE01.\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\t//The three pointers here are prev , curr and forw\\n            ListNode *temp = new ListNode(0);\\n\\t\\t\\t//A dummy node before head\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012485,
                "title": "easy-beginner-friendly-o-n-with-proper-explain-c-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we get the linked list from left to right separete from remaninig list we can easily reverse it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply split the linked list int three parts 0<-->left-1 && left<-->right  && right+1<-->end .\\nTo do this make some pointers as\\n(temp) ptr to traverse linked list.\\n(temp1) ptr to point to the node just before left one node.\\n(temp2) ptr to point to the node just before right one node.\\n(newh) this point to left one node(temp1->next) and used for reverse that list as head of linked list.\\n(end) to point on the node just after right one node used to reconnent them all.\\n\\n\\nNow, separate them in 3 parts by making temp1->next=NULL  and temp2->next->next=ULL and reverse the linked list with head as newh.\\n\\nIn the end join them again by making temp1->next=newh  and \\n(last node of reversed list)->next=end.\\n\\n!!!Please UPvote\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* temp;\\n        while(cur!=NULL)\\n        {\\n            temp=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }  \\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right)\\n        return head;\\n        ListNode* dummy=new ListNode(-600);\\n        dummy->next=head;\\n        ListNode* temp1;\\n        ListNode* temp2;\\n        ListNode* temp=dummy;\\n        int l=left,r=right;\\n        while(temp)\\n        {\\n            l--;\\n            r--;\\n            if(l==0)\\n            temp1=temp;\\n            if(r==0)\\n            temp2=temp;\\n            temp=temp->next;\\n\\n        }\\n        ListNode* end=temp2->next->next;\\n        ListNode* newh=temp1->next;\\n        temp1->next=NULL;\\n        temp2->next->next=NULL;\\n        newh=reverseList(newh);\\n        temp1->next=newh;\\n        while(newh->next)\\n        {\\n            newh=newh->next;\\n        }\\n        newh->next=end;\\n        return dummy->next;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head==NULL||head->next==NULL)\\n        return head;\\n\\n        ListNode* prev=NULL;\\n        ListNode* cur=head;\\n        ListNode* temp;\\n        while(cur!=NULL)\\n        {\\n            temp=cur->next;\\n            cur->next=prev;\\n            prev=cur;\\n            cur=temp;\\n        }  \\n        return prev;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right)\\n        return head;\\n        ListNode* dummy=new ListNode(-600);\\n        dummy->next=head;\\n        ListNode* temp1;\\n        ListNode* temp2;\\n        ListNode* temp=dummy;\\n        int l=left,r=right;\\n        while(temp)\\n        {\\n            l--;\\n            r--;\\n            if(l==0)\\n            temp1=temp;\\n            if(r==0)\\n            temp2=temp;\\n            temp=temp->next;\\n\\n        }\\n        ListNode* end=temp2->next->next;\\n        ListNode* newh=temp1->next;\\n        temp1->next=NULL;\\n        temp2->next->next=NULL;\\n        newh=reverseList(newh);\\n        temp1->next=newh;\\n        while(newh->next)\\n        {\\n            newh=newh->next;\\n        }\\n        newh->next=end;\\n        return dummy->next;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011871,
                "title": "java-beats-100-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public ListNode reverseBetween(ListNode head, int lindex, int rindex) {\\n    ListNode ptr, l = null;\\n    var i = 1;\\n    \\n    for (ptr = head; i < lindex; ptr = ptr.next, i++)\\n      if (i+1 == lindex) l = ptr;\\n\\n    var left = ptr;\\n    \\n    for (; i < rindex; ptr = ptr.next, i++);\\n    var right = ptr;\\n    \\n    if (l == null) head = right;\\n    else l.next = right;\\n  \\n    if (left != right) {\\n      var p1 = left;\\n      var p2 = p1.next;\\n      var p3 = p2.next;\\n      left.next = right.next;\\n      \\n      while (p2 != right) {\\n        p2.next = p1;\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = p3.next;\\n      }\\n      p2.next = p1;\\n    }   \\n    return head;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n  public ListNode reverseBetween(ListNode head, int lindex, int rindex) {\\n    ListNode ptr, l = null;\\n    var i = 1;\\n    \\n    for (ptr = head; i < lindex; ptr = ptr.next, i++)\\n      if (i+1 == lindex) l = ptr;\\n\\n    var left = ptr;\\n    \\n    for (; i < rindex; ptr = ptr.next, i++);\\n    var right = ptr;\\n    \\n    if (l == null) head = right;\\n    else l.next = right;\\n  \\n    if (left != right) {\\n      var p1 = left;\\n      var p2 = p1.next;\\n      var p3 = p2.next;\\n      left.next = right.next;\\n      \\n      while (p2 != right) {\\n        p2.next = p1;\\n        p1 = p2;\\n        p2 = p3;\\n        p3 = p3.next;\\n      }\\n      p2.next = p1;\\n    }   \\n    return head;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865862,
                "title": "java-0ms-easy-to-understand-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next == null)   return head;\\n\\n        ListNode dummy_node = new ListNode(0);\\n        dummy_node.next= head;\\n        ListNode prev = dummy_node;\\n\\n        for(int i = 1; i <= left - 1; i++ )     prev = prev.next;\\n        \\n        ListNode curr = prev.next;\\n        \\n\\n        for(int i = 1; i <= right - left; i++)\\n        {\\n            ListNode frwd = curr.next;\\n            curr.next = frwd.next;\\n            frwd.next = prev.next;\\n            prev.next = frwd;\\n        } \\n        return dummy_node.next;\\n        \\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head.next == null)   return head;\\n\\n        ListNode dummy_node = new ListNode(0);\\n        dummy_node.next= head;\\n        ListNode prev = dummy_node;\\n\\n        for(int i = 1; i <= left - 1; i++ )     prev = prev.next;\\n        \\n        ListNode curr = prev.next;\\n        \\n\\n        for(int i = 1; i <= right - left; i++)\\n        {\\n            ListNode frwd = curr.next;\\n            curr.next = frwd.next;\\n            frwd.next = prev.next;\\n            prev.next = frwd;\\n        } \\n        return dummy_node.next;\\n        \\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800443,
                "title": "go-solution-great-explanation-and-full-description",
                "content": "# Intuition\\nThe problem asks to reverse a linked list from position `left` to position `right`. This can be solved by locating the `left-1` position node first and then reversing the sublist from `left` to `right`.\\n\\n# Approach\\n1. **Create a Dummy Node**: Initialize a dummy node that points to the head to handle edge cases such as reversing at the very beginning of the list.\\n2. **Locate the `left-1` Position**: Move a pointer `prev` to its place, which is at position `left-1`.\\n3. **Reverse the Sublist**: Use another pointer to reverse the sublist from position `left` to `right`. While reversing, also keep track of the next node `currRev` after the reversed sublist for later reconnection.\\n4. **Reconnect**: Connect the `prev.Next` with the reversed sublist and also connect the end of the reversed sublist with the remaining list `currRev`.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where `n` is the number of nodes in the list, because we potentially need to traverse all the nodes in the list.\\n- Space complexity: The space complexity is O(1), as we only use a constant amount of space to store the pointers.\\n\\n# Code\\n```\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    // Return nil if the list is empty\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Initialize a dummy node that points to the head\\n    dummy := &ListNode{Next: head}\\n    prev := dummy\\n\\n    // Move \\'prev\\' to its place which is at position \\'left - 1\\'\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    // Reverse the sublist from position \\'left\\' to \\'right\\'\\n    prevRev, currRev := reverse(prev.Next, right-left+1)\\n\\n    // Connect the \\'prev.Next\\' with the reversed sublist and \\n    // also connect the end of reversed sublist with the remaining list \\'currRev\\'\\n    prev.Next.Next = currRev\\n    prev.Next = prevRev\\n\\n    // Return the next node of dummy node\\n    return dummy.Next\\n}\\n\\nfunc reverse(head *ListNode, len int) (*ListNode, *ListNode) {\\n    var prev *ListNode\\n    // Reverse \\'len\\' nodes of the list and keep track of the next node after the reversed sublist\\n    for i := 0; i < len; i++ {\\n        nextRev := head.Next\\n        head.Next = prev\\n        prev = head\\n        head = nextRev\\n    }\\n    // Return the head of reversed sublist and the next node after the reversed sublist\\n    return prev, head\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```\\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode {\\n    // Return nil if the list is empty\\n    if head == nil {\\n        return nil\\n    }\\n\\n    // Initialize a dummy node that points to the head\\n    dummy := &ListNode{Next: head}\\n    prev := dummy\\n\\n    // Move \\'prev\\' to its place which is at position \\'left - 1\\'\\n    for i := 0; i < left-1; i++ {\\n        prev = prev.Next\\n    }\\n    \\n    // Reverse the sublist from position \\'left\\' to \\'right\\'\\n    prevRev, currRev := reverse(prev.Next, right-left+1)\\n\\n    // Connect the \\'prev.Next\\' with the reversed sublist and \\n    // also connect the end of reversed sublist with the remaining list \\'currRev\\'\\n    prev.Next.Next = currRev\\n    prev.Next = prevRev\\n\\n    // Return the next node of dummy node\\n    return dummy.Next\\n}\\n\\nfunc reverse(head *ListNode, len int) (*ListNode, *ListNode) {\\n    var prev *ListNode\\n    // Reverse \\'len\\' nodes of the list and keep track of the next node after the reversed sublist\\n    for i := 0; i < len; i++ {\\n        nextRev := head.Next\\n        head.Next = prev\\n        prev = head\\n        head = nextRev\\n    }\\n    // Return the head of reversed sublist and the next node after the reversed sublist\\n    return prev, head\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767472,
                "title": "java-easy-steps-explanation-with-drawing-beats-100",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n![LLsolution.jpeg](https://assets.leetcode.com/users/images/0e0e6f31-fd37-484a-b096-243f5d8886f0_1689405838.3570461.jpeg)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==right) return head;\\n       ListNode prev = null;\\n       ListNode curr = head;\\n       for(int i=0; curr!=null && i<left-1; i++){\\n           prev = curr;\\n           curr = curr.next;\\n       }\\n       ListNode last = prev;\\n       ListNode newEnd = curr;\\n       ListNode forward = curr.next;\\n       for(int i=0; curr!=null && i<right-left+1; i++){\\n           curr.next = prev;\\n           prev = curr;\\n           curr = forward;\\n           if(forward!=null){\\n               forward = forward.next;\\n           }\\n       }\\n       if(last!=null) last.next = prev;\\n       else head = prev;\\n\\n       newEnd.next=curr;\\n       return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==right) return head;\\n       ListNode prev = null;\\n       ListNode curr = head;\\n       for(int i=0; curr!=null && i<left-1; i++){\\n           prev = curr;\\n           curr = curr.next;\\n       }\\n       ListNode last = prev;\\n       ListNode newEnd = curr;\\n       ListNode forward = curr.next;\\n       for(int i=0; curr!=null && i<right-left+1; i++){\\n           curr.next = prev;\\n           prev = curr;\\n           curr = forward;\\n           if(forward!=null){\\n               forward = forward.next;\\n           }\\n       }\\n       if(last!=null) last.next = prev;\\n       else head = prev;\\n\\n       newEnd.next=curr;\\n       return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534924,
                "title": "java-solution-100-faster-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode ptr=head;\\n        int k=0;\\n\\n        Stack<Integer> s=new Stack<>();\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                s.push(ptr.val);\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        ptr=head;\\n\\n        k=0;\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                ptr.val=s.pop();\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode ptr=head;\\n        int k=0;\\n\\n        Stack<Integer> s=new Stack<>();\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                s.push(ptr.val);\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        ptr=head;\\n\\n        k=0;\\n\\n        while(ptr!=null){\\n            k++;\\n            if(k>=left && k<=right){\\n                ptr.val=s.pop();\\n            }\\n            ptr=ptr.next;\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256987,
                "title": "beats-100-0ms-java-detailed-explanation-python3-c-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this problem is to use a simple two-pointer approach to manipulate the pointers of the nodes in the linked list in order to reverse a sublist in place.\\n\\n# Approach\\nThe input to the function is the `head` of the linked list, and two integers `left` and `right` representing the starting and ending indices (1-based) of the sublist to be reversed.\\n\\nThe function starts by handling the edge case where `left` is equal to `right`, in which case it simply returns the original list as it is.\\n\\nNext, it initializes two pointers `prev` and `curr` to traverse the list until `curr` points to the node at index `left`. It also maintains a reference to the node immediately preceding the sublist, `last`.\\n\\nAfter locating the starting point of the sublist, the function then reverses the sublist in place. This is done by iterating over the nodes between `left` and `right`, and swapping the next pointers of the nodes to reverse the order of the sublist.\\n\\nOnce the sublist is reversed, the function then connects it back to the rest of the list. This is done by setting the `next` pointer of the node at index `last` to point to the first node of the reversed sublist (`prev`). If `last` is `null`, then the sublist starts at the `head` of the list, so the `head` variable is updated to point to the first node of the reversed sublist. The `next` pointer of the last node of the reversed sublist is then set to point to the node immediately following the sublist, which is `curr`.\\n\\nFinally, the function returns the updated `head` of the list.\\n\\n# Complexity\\n- Time complexity:  O(n)\\nTime complexity of this solution is O(n), where n is the length of the list, since it only requires a single pass over the list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\nThe space complexity is O(1), since it only uses a constant amount of extra space to store pointers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        for(int i=0 ; curr != null && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode last = prev;\\n        ListNode newEnd = curr;\\n        ListNode next = curr.next;\\n        for(int i=0 ; curr != null && i < right - left + 1 ; i++){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != null) {next = next.next;}\\n        }\\n        if(last != null){ last.next = prev;}\\n        else {head = prev;}\\n        newEnd.next = curr;\\n        return head;\\n    }\\n}\\n```\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* last = prev;\\n        ListNode* newEnd = curr;\\n        ListNode* next = curr->next;\\n        for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != NULL) {next = next->next;}\\n        }\\n        if(last != NULL){ last->next = prev;}\\n        else {head = prev;}\\n        newEnd->next = curr;\\n        return head;\\n    }\\n};\\n\\n```\\n# Python3\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if left == right:\\n            return head\\n        curr = head\\n        prev = None\\n        for i in range(left-1):\\n            prev = curr\\n            curr = curr.next\\n        last = prev\\n        new_end = curr\\n        next = curr.next\\n        for i in range(right - left + 1):\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            if next != None:\\n                next = next.next\\n        if last != None:\\n            last.next = prev\\n        else:\\n            head = prev\\n        new_end.next = curr\\n        return head\\n\\n```\\n# C\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    if(left == right) return head;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n        prev = curr;\\n        curr = curr->next;\\n    }\\n    struct ListNode* last = prev;\\n    struct ListNode* newEnd = curr;\\n    struct ListNode* next = curr->next;\\n    for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n        if (next != NULL) {next = next->next;}\\n    }\\n    if(last != NULL){ last->next = prev;}\\n    else {head = prev;}\\n    newEnd->next = curr;\\n    return head;\\n}\\n\\n```\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode curr = head;\\n        ListNode prev = null;\\n        for(int i=0 ; curr != null && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        ListNode last = prev;\\n        ListNode newEnd = curr;\\n        ListNode next = curr.next;\\n        for(int i=0 ; curr != null && i < right - left + 1 ; i++){\\n            curr.next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != null) {next = next.next;}\\n        }\\n        if(last != null){ last.next = prev;}\\n        else {head = prev;}\\n        newEnd.next = curr;\\n        return head;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left == right) return head;\\n        ListNode* curr = head;\\n        ListNode* prev = NULL;\\n        for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        ListNode* last = prev;\\n        ListNode* newEnd = curr;\\n        ListNode* next = curr->next;\\n        for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n            if (next != NULL) {next = next->next;}\\n        }\\n        if(last != NULL){ last->next = prev;}\\n        else {head = prev;}\\n        newEnd->next = curr;\\n        return head;\\n    }\\n};\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        if left == right:\\n            return head\\n        curr = head\\n        prev = None\\n        for i in range(left-1):\\n            prev = curr\\n            curr = curr.next\\n        last = prev\\n        new_end = curr\\n        next = curr.next\\n        for i in range(right - left + 1):\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n            if next != None:\\n                next = next.next\\n        if last != None:\\n            last.next = prev\\n        else:\\n            head = prev\\n        new_end.next = curr\\n        return head\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n    if(left == right) return head;\\n    struct ListNode* curr = head;\\n    struct ListNode* prev = NULL;\\n    for(int i=0 ; curr != NULL && i < left - 1 ; i++){\\n        prev = curr;\\n        curr = curr->next;\\n    }\\n    struct ListNode* last = prev;\\n    struct ListNode* newEnd = curr;\\n    struct ListNode* next = curr->next;\\n    for(int i=0 ; curr != NULL && i < right - left + 1 ; i++){\\n        curr->next = prev;\\n        prev = curr;\\n        curr = next;\\n        if (next != NULL) {next = next->next;}\\n    }\\n    if(last != NULL){ last->next = prev;}\\n    else {head = prev;}\\n    newEnd->next = curr;\\n    return head;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070934,
                "title": "python-simple-solution-beats-100-explained",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        cn_position = 1\\n        current_node = head\\n        start = head\\n        while cn_position < left:\\n            start = current_node\\n            current_node = current_node.next\\n            cn_position +=1\\n        newlist = None\\n        tail = current_node\\n        while cn_position >= left and cn_position <= right:\\n            next_node = current_node.next\\n            current_node.next = newlist\\n            newlist = current_node\\n            current_node = next_node\\n            cn_position +=1\\n        start.next = newlist\\n        tail.next =current_node\\n        if left >1:\\n            return head\\n        else:\\n            return newlist\\n\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        cn_position = 1\\n        current_node = head\\n        start = head\\n        while cn_position < left:\\n            start = current_node\\n            current_node = current_node.next\\n            cn_position +=1\\n        newlist = None\\n        tail = current_node\\n        while cn_position >= left and cn_position <= right:\\n            next_node = current_node.next\\n            current_node.next = newlist\\n            newlist = current_node\\n            current_node = next_node\\n            cn_position +=1\\n        start.next = newlist\\n        tail.next =current_node\\n        if left >1:\\n            return head\\n        else:\\n            return newlist\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044019,
                "title": "c-simple-reverse-list-beginner-friendly",
                "content": "\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = next -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *leftPrev = nullptr, *r = nullptr, *l = nullptr;\\n        ListNode *curr = head, *prev = nullptr;\\n\\n        int cnt = 1;\\n        while(curr) {\\n            if(cnt == left) {\\n                leftPrev = prev;\\n                l = curr;\\n            }\\n\\n            if(cnt == right) r = curr;\\n\\n            prev = curr;\\n            curr = curr -> next; \\n            cnt++;\\n        }\\n        \\n        ListNode *rightSide = r -> next;\\n        r -> next = nullptr;\\n        \\n        ListNode *a = F(l);\\n        l -> next = rightSide;\\n\\n        if(!leftPrev) return a;\\n        leftPrev -> next = a;\\n        return head;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* F(ListNode* curr) {\\n        ListNode *prev = nullptr, *next = curr;\\n        while(curr) {\\n            next = next -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        return prev;\\n    }\\n\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *leftPrev = nullptr, *r = nullptr, *l = nullptr;\\n        ListNode *curr = head, *prev = nullptr;\\n\\n        int cnt = 1;\\n        while(curr) {\\n            if(cnt == left) {\\n                leftPrev = prev;\\n                l = curr;\\n            }\\n\\n            if(cnt == right) r = curr;\\n\\n            prev = curr;\\n            curr = curr -> next; \\n            cnt++;\\n        }\\n        \\n        ListNode *rightSide = r -> next;\\n        r -> next = nullptr;\\n        \\n        ListNode *a = F(l);\\n        l -> next = rightSide;\\n\\n        if(!leftPrev) return a;\\n        leftPrev -> next = a;\\n        return head;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978378,
                "title": "python-3-solution-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Linked list reversal** can be accomplished with minimal code. With this problem, there\\'s a complication: we need to reverse a *sublist* and join the parts together again.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Traverse the unaltered first section that precedes the starting node of the reversal\\n1. Reverse the specified section\\n1. Join the unaltered first section, the reversed middle section, and the unaltered ending section\\n\\nIt\\'s possible that either of both of the unaltered sections is empty, or that the section to be reversed has only one node (meaning no reversal).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if left == right or not head.next:          # Nothing to change\\n            return head\\n        current, prev, pos = head, None, 1\\n        while current.next and pos < left:          # Traverse and count the left section\\n            prev, current = current, current.next\\n            pos += 1\\n        end_of_left = prev                          # end_of_left.next = start of the reversed segment\\n        end_of_mid = current                        # end_of_mid.next = start of the right section\\n        while pos < right:                          # Reverse the middle section\\n            to_do_next, current.next, prev = current.next, prev, current\\n            current = to_do_next\\n            pos += 1\\n        # Finish middle and attach sections\\n        if left == 1:                               # Special case: no left section\\n            head = current\\n        else:\\n            end_of_left.next = current\\n        end_of_mid.next, current.next = current.next, prev\\n        return head\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if left == right or not head.next:          # Nothing to change\\n            return head\\n        current, prev, pos = head, None, 1\\n        while current.next and pos < left:          # Traverse and count the left section\\n            prev, current = current, current.next\\n            pos += 1\\n        end_of_left = prev                          # end_of_left.next = start of the reversed segment\\n        end_of_mid = current                        # end_of_mid.next = start of the right section\\n        while pos < right:                          # Reverse the middle section\\n            to_do_next, current.next, prev = current.next, prev, current\\n            current = to_do_next\\n            pos += 1\\n        # Finish middle and attach sections\\n        if left == 1:                               # Special case: no left section\\n            head = current\\n        else:\\n            end_of_left.next = current\\n        end_of_mid.next, current.next = current.next, prev\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618388,
                "title": "100-faster-submission-c-solution-easy-understandable",
                "content": "![image](https://assets.leetcode.com/users/images/bc24cb38-8d79-4193-9688-1e1fb72921cd_1664027885.8875773.png)\\n**Approach:**\\n1.convert to vector\\n2.reverse vector using stl sort function time complex=ologn\\n3.now insert to the linked list\\n\\ncode is in simple and understandable format\\n\\nfollow on linked in = https://www.linkedin.com/in/kishan-kadam/",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bc24cb38-8d79-4193-9688-1e1fb72921cd_1664027885.8875773.png)\\n**Approach:**\\n1.convert to vector\\n2.reverse vector using stl sort function time complex=ologn\\n3.now insert to the linked list\\n\\ncode is in simple and understandable format\\n\\nfollow on linked in = https://www.linkedin.com/in/kishan-kadam/",
                "codeTag": "Unknown"
            },
            {
                "id": 2542093,
                "title": "java-solution-with-comments-and-clear-variable-name-for-better-understanding-o-1-memory",
                "content": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(right == left)\\n            return head;\\n        \\n        ListNode currentNode = head;\\n        ListNode previousNode = null;\\n        \\n        //Get the node before the left position\\n        for(int index = 0; index < left - 1 && currentNode != null; index++){\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n        \\n        ListNode lastNodeBeforeLeftNode = previousNode;\\n        \\n        ListNode firstNodeAfterLeftNode = currentNode;\\n        \\n        ListNode nextNode = null;\\n        \\n        //Perform a reverse between left and right\\n        for(int index = 0; index < right - left +1 && currentNode != null; index++){\\n            nextNode = currentNode.next;\\n            currentNode.next = previousNode;\\n            previousNode = currentNode;\\n            currentNode = nextNode;\\n        }\\n        \\n        \\n        if(lastNodeBeforeLeftNode != null){\\n            lastNodeBeforeLeftNode.next = previousNode;\\n        }else{\\n            head = previousNode;\\n        }\\n        \\n        firstNodeAfterLeftNode.next = currentNode;\\n        \\n        return head;\\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(right == left)\\n            return head;\\n        \\n        ListNode currentNode = head;\\n        ListNode previousNode = null;\\n        \\n        //Get the node before the left position\\n        for(int index = 0; index < left - 1 && currentNode != null; index++){\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n        \\n        ListNode lastNodeBeforeLeftNode = previousNode;\\n        \\n        ListNode firstNodeAfterLeftNode = currentNode;\\n        \\n        ListNode nextNode = null;\\n        \\n        //Perform a reverse between left and right\\n        for(int index = 0; index < right - left +1 && currentNode != null; index++){\\n            nextNode = currentNode.next;\\n            currentNode.next = previousNode;\\n            previousNode = currentNode;\\n            currentNode = nextNode;\\n        }\\n        \\n        \\n        if(lastNodeBeforeLeftNode != null){\\n            lastNodeBeforeLeftNode.next = previousNode;\\n        }else{\\n            head = previousNode;\\n        }\\n        \\n        firstNodeAfterLeftNode.next = currentNode;\\n        \\n        return head;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2320281,
                "title": "simple-java-c-solution-with-clear-explanation",
                "content": "\\nC++ Solution\\nhttps://leetcode.com/problems/reverse-linked-list-ii/discuss/2320268/Simple-C%2B%2B-JAVA-Solution-with-TC-O(N)-SC-O(1)\\n\\nVery similar to problem 25. We keep three pointers as with any other reverse linked lists problems: pre, curr, next. We can split all algorithm into 3 steps:\\n\\nDo m-1 steps to reach the first point of range we need to reverse.\\nReverse range [n - m], using 3 pointers approach.\\nFinally we need to fix connections for the start and for the end of reversed list, using saved pointer to pre element.\\n\\n**Complexity**\\nTime complexity is O(n), because we need to traverse elements upto n-th. Space complexity is O(1).\\n\\n```\\nclass Solution {\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    \\n    if(head == null && head.next==null) return null;\\n    \\n    ListNode dummy = new ListNode(Integer.MIN_VALUE); // dummy node at head\\n    dummy.next = head;\\n    \\n    ListNode pre = dummy; //   prev pointer at the node before reversing\\n    for(int i = 0; i<left - 1; i++) pre = pre.next;\\n    \\n    ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n    ListNode then = start.next; // a pointer to a node that will be reversed\\n    \\n    // 1 - 2 -3 - 4 - 5 ; left=2; right =4 --> pre = 1, start = 2, then = 3\\n    // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n    for(int i=0; i<right-left; i++)\\n    {\\n        start.next = then.next;\\n        then.next = pre.next;\\n        //System.out.println(pre.next.val);        \\n        pre.next = then;\\n        then = start.next;\\n    }\\n    \\n    // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n    // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n    \\n    return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n    \\n    if(head == null && head.next==null) return null;\\n    \\n    ListNode dummy = new ListNode(Integer.MIN_VALUE); // dummy node at head\\n    dummy.next = head;\\n    \\n    ListNode pre = dummy; //   prev pointer at the node before reversing\\n    for(int i = 0; i<left - 1; i++) pre = pre.next;\\n    \\n    ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed\\n    ListNode then = start.next; // a pointer to a node that will be reversed\\n    \\n    // 1 - 2 -3 - 4 - 5 ; left=2; right =4 --> pre = 1, start = 2, then = 3\\n    // dummy-> 1 -> 2 -> 3 -> 4 -> 5\\n    for(int i=0; i<right-left; i++)\\n    {\\n        start.next = then.next;\\n        then.next = pre.next;\\n        //System.out.println(pre.next.val);        \\n        pre.next = then;\\n        then = start.next;\\n    }\\n    \\n    // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4\\n    // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)\\n    \\n    return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320268,
                "title": "simple-c-java-solution-with-tc-o-n-sc-o-1",
                "content": "JAVA Solution \\nhttps://leetcode.com/problems/reverse-linked-list-ii/discuss/2320281/Simple-JAVA-C%2B%2B-Solution-with-clear-explanation\\n```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           pre = pre -> next;\\n       }\\n       cur = pre -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode* temp = pre -> next;\\n           pre -> next = cur -> next;\\n           cur -> next = cur -> next -> next;\\n           pre -> next -> next = temp;\\n       }\\n       return dummy -> next;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   ListNode* reverseBetween(ListNode* head, int m, int n) {\\n       ListNode *dummy = new ListNode(0), *pre = dummy, *cur;\\n       dummy -> next = head;\\n       for (int i = 0; i < m - 1; i++) {\\n           pre = pre -> next;\\n       }\\n       cur = pre -> next;\\n       for (int i = 0; i < n - m; i++) {\\n           ListNode* temp = pre -> next;\\n           pre -> next = cur -> next;\\n           cur -> next = cur -> next -> next;\\n           pre -> next -> next = temp;\\n       }\\n       return dummy -> next;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315123,
                "title": "92-reverse-linked-list-ii-c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\n            ListNode *temp = new ListNode(0);\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode *head, int left, int right)\\n        {\\n\\t\\n            ListNode *temp = new ListNode(0);\\n            temp->next = head;\\n            ListNode *prev = temp;\\t\\n\\n            for (int i = 0; i < left - 1; i++)\\n                prev = prev->next;\\n            ListNode *curr = prev->next;\\n           \\n            for (int i = 0; i < right - left; i++)\\n            {\\n                ListNode *forw = curr->next;\\t\\n                curr->next = forw->next;\\n                forw->next = prev->next;\\n                prev->next = forw;\\n            }\\n            return temp->next;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311050,
                "title": "beats-100-other-solutions",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int o) {\\n        if(!head) return head;\\n        ListNode *t1=nullptr,*t2=head;\\n        for(int i=0;i<m-1;i++){\\n            t1=t2;\\n            t2=t2->next;\\n        } \\n        int cnt=0;\\n        ListNode *c=t2,*p=nullptr,*n;\\n        while(cnt<o-m+1){\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            cnt++;\\n        }\\n        if(!t1) head=p;\\n        else t1->next=p;\\n        t2->next=c;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int o) {\\n        if(!head) return head;\\n        ListNode *t1=nullptr,*t2=head;\\n        for(int i=0;i<m-1;i++){\\n            t1=t2;\\n            t2=t2->next;\\n        } \\n        int cnt=0;\\n        ListNode *c=t2,*p=nullptr,*n;\\n        while(cnt<o-m+1){\\n            n=c->next;\\n            c->next=p;\\n            p=c;\\n            c=n;\\n            cnt++;\\n        }\\n        if(!t1) head=p;\\n        else t1->next=p;\\n        t2->next=c;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310931,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "**Java**\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null)    return null;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for(int i=0; i<left-1; i++)  pre = pre.next;\\n        ListNode start = pre.next;\\n        ListNode tmp = start.next;\\n        for(int i=0; i<right-left; i++){\\n            start.next = tmp.next;\\n            tmp.next = pre.next;\\n            pre.next = tmp;\\n            tmp = start.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar reverseBetween = function(head, left, right) {\\n    if(!head)    return null\\n    let dummy = new ListNode()\\n    dummy.next = head\\n    let pre = dummy\\n    for(let i=0; i<left-1; i++)  pre = pre.next;\\n    let start = pre.next\\n    let tmp = start.next\\n    for(let i=0; i<right-left; i++){\\n        start.next = tmp.next\\n        tmp.next = pre.next\\n        pre.next = tmp\\n        tmp = start.next\\n    }\\n    return dummy.next\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if not head:\\n            return null\\n        dummy = ListNode()\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(left-1):\\n            pre = pre.next\\n        start = pre.next\\n        tmp = start.next\\n        for i in range(right-left):\\n            start.next = tmp.next\\n            tmp.next = pre.next\\n            pre.next = tmp\\n            tmp = start.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null)    return null;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode pre = dummy;\\n        for(int i=0; i<left-1; i++)  pre = pre.next;\\n        ListNode start = pre.next;\\n        ListNode tmp = start.next;\\n        for(int i=0; i<right-left; i++){\\n            start.next = tmp.next;\\n            tmp.next = pre.next;\\n            pre.next = tmp;\\n            tmp = start.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```\\nvar reverseBetween = function(head, left, right) {\\n    if(!head)    return null\\n    let dummy = new ListNode()\\n    dummy.next = head\\n    let pre = dummy\\n    for(let i=0; i<left-1; i++)  pre = pre.next;\\n    let start = pre.next\\n    let tmp = start.next\\n    for(let i=0; i<right-left; i++){\\n        start.next = tmp.next\\n        tmp.next = pre.next\\n        pre.next = tmp\\n        tmp = start.next\\n    }\\n    return dummy.next\\n};\\n```\n```\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if not head:\\n            return null\\n        dummy = ListNode()\\n        dummy.next = head\\n        pre = dummy\\n        for i in range(left-1):\\n            pre = pre.next\\n        start = pre.next\\n        tmp = start.next\\n        for i in range(right-left):\\n            start.next = tmp.next\\n            tmp.next = pre.next\\n            pre.next = tmp\\n            tmp = start.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310899,
                "title": "simple-iterative-java-solution-tc-o-n-sc-o-n",
                "content": "\\n\\tclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        //iterate until left\\n        ListNode currLeft = dummy;\\n        ListNode prevLeft = null;\\n        for(int i = 0; i < left; i++){\\n            prevLeft = currLeft;\\n            currLeft = currLeft.next;\\n        }\\n        \\n        //reverse until right\\n        ListNode currRight = currLeft;\\n        ListNode prevRight = prevLeft;\\n        for(int i = left; i <= right; i++){\\n            ListNode temp = currRight.next;\\n            currRight.next = prevRight;\\n            prevRight = currRight;\\n            currRight = temp;\\n        }\\n        \\n        //connect the left and right pointers appropriately\\n        prevLeft.next = prevRight;\\n        currLeft.next = currRight;\\n        \\n        return dummy.next;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        //iterate until left\\n        ListNode currLeft = dummy;\\n        ListNode prevLeft = null;\\n        for(int i = 0; i < left; i++){\\n            prevLeft = currLeft;\\n            currLeft = currLeft.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2310877,
                "title": "easy-to-understand-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if (!head || m == n)\\n            return head;\\n\\n        ListNode dummy(0, head);\\n        ListNode* front = &dummy;\\n        ListNode* end = &dummy;\\n        \\n        for (int i = 0; i < m - 1; ++i)\\n            front = front->next;\\n        \\n        for (int i = 0; i <= n; ++i)\\n            end = end->next;\\n        \\n        ListNode* inter = front->next;\\n        stack<ListNode*> stack;\\n        \\n        while (inter != end) {\\n            stack.push(inter);\\n            \\n            inter = inter->next;\\n        }\\n        \\n        while (!stack.empty()) {\\n            front->next = stack.top();\\n            stack.pop();\\n            front = front->next;\\n        }\\n        \\n        front->next = end;\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\\n        if (!head || m == n)\\n            return head;\\n\\n        ListNode dummy(0, head);\\n        ListNode* front = &dummy;\\n        ListNode* end = &dummy;\\n        \\n        for (int i = 0; i < m - 1; ++i)\\n            front = front->next;\\n        \\n        for (int i = 0; i <= n; ++i)\\n            end = end->next;\\n        \\n        ListNode* inter = front->next;\\n        stack<ListNode*> stack;\\n        \\n        while (inter != end) {\\n            stack.push(inter);\\n            \\n            inter = inter->next;\\n        }\\n        \\n        while (!stack.empty()) {\\n            front->next = stack.top();\\n            stack.pop();\\n            front = front->next;\\n        }\\n        \\n        front->next = end;\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278406,
                "title": "java-single-pass",
                "content": "````\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // 1. Iterate till left pointer\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prevLeft = dummy, cur = head;\\n        \\n        for(int i=0; i<left-1; i++){\\n            prevLeft = cur;\\n            cur = cur.next;\\n        }\\n        \\n        // 2. reverse the lists from left to right i.e., right -left + 1 times\\n        ListNode prev = null;\\n        for(int i=0; i<right-left+1; i++){\\n            ListNode tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        // 3. Rearrange the pointers\\n        prevLeft.next.next = cur;\\n        prevLeft.next = prev;\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        // 1. Iterate till left pointer\\n        ListNode dummy = new ListNode(0, head);\\n        ListNode prevLeft = dummy, cur = head;\\n        \\n        for(int i=0; i<left-1; i++){\\n            prevLeft = cur;\\n            cur = cur.next;\\n        }\\n        \\n        // 2. reverse the lists from left to right i.e., right -left + 1 times\\n        ListNode prev = null;\\n        for(int i=0; i<right-left+1; i++){\\n            ListNode tmp = cur.next;\\n            cur.next = prev;\\n            prev = cur;\\n            cur = tmp;\\n        }\\n        \\n        // 3. Rearrange the pointers\\n        prevLeft.next.next = cur;\\n        prevLeft.next = prev;\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2217647,
                "title": "c-2-solutions-dummy-node",
                "content": "Dummy Node Approach\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        // Dummy Node Approach (helps to handle edge cases)\\n        \\n        ListNode* dummy = new ListNode;   // dummy node\\n        dummy -> next = head;\\n        \\n        // 1. reach node at position \\'left\\'\\n        \\n        ListNode* leftPrev = dummy;\\n        ListNode* curr = head;\\n        for(int i=0; i<left-1; i++){\\n            leftPrev = curr;\\n            curr = curr -> next;\\n        }\\n        \\n        // curr = \\'left\\', leftPrev = \\'node before left\\'\\n        // 2. reverse from left to right \\n        \\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        for(int i=0; i<right-left+1; i++){  \\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // 3. updating pointers\\n        \\n        leftPrev -> next -> next = curr;\\n        leftPrev -> next = prev;\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nSimple Iterative Approach\\n\\n```\\nclass Solution {\\nprivate:\\n    // Iterative Approach\\n    ListNode* reverse(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        \\n        int count = 1;\\n        while(count != left){\\n            prev = curr;          // prev will be placed just before left\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* start = curr;   // start is placed on left \\n        \\n        while(count != right){\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* end = curr;       // end is placed on right\\n        curr = curr -> next;        // curr is placed just after right\\n        end -> next = NULL;        \\n        \\n        ListNode* newHead = reverse(start);    // reversing Linked List from start to end (NULL)\\n        \\n        if(prev != NULL)\\n            prev -> next = newHead;        // as prev stores left-side data not reversed\\n        else\\n            head = newHead;               // when (left == 1) -> prev is still at NULL\\n        \\n        while(newHead -> next != NULL)\\n            newHead = newHead -> next;\\n        \\n        newHead -> next = curr;        // as curr stores right-side data not reversed\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        // Dummy Node Approach (helps to handle edge cases)\\n        \\n        ListNode* dummy = new ListNode;   // dummy node\\n        dummy -> next = head;\\n        \\n        // 1. reach node at position \\'left\\'\\n        \\n        ListNode* leftPrev = dummy;\\n        ListNode* curr = head;\\n        for(int i=0; i<left-1; i++){\\n            leftPrev = curr;\\n            curr = curr -> next;\\n        }\\n        \\n        // curr = \\'left\\', leftPrev = \\'node before left\\'\\n        // 2. reverse from left to right \\n        \\n        ListNode* prev = NULL;\\n        ListNode* next = NULL;\\n        for(int i=0; i<right-left+1; i++){  \\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        // 3. updating pointers\\n        \\n        leftPrev -> next -> next = curr;\\n        leftPrev -> next = prev;\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // Iterative Approach\\n    ListNode* reverse(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* next = NULL;\\n        \\n        while(curr != NULL){\\n            next = curr -> next;\\n            curr -> next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n        \\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        \\n        int count = 1;\\n        while(count != left){\\n            prev = curr;          // prev will be placed just before left\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* start = curr;   // start is placed on left \\n        \\n        while(count != right){\\n            curr = curr -> next;\\n            count++;\\n        }\\n        \\n        ListNode* end = curr;       // end is placed on right\\n        curr = curr -> next;        // curr is placed just after right\\n        end -> next = NULL;        \\n        \\n        ListNode* newHead = reverse(start);    // reversing Linked List from start to end (NULL)\\n        \\n        if(prev != NULL)\\n            prev -> next = newHead;        // as prev stores left-side data not reversed\\n        else\\n            head = newHead;               // when (left == 1) -> prev is still at NULL\\n        \\n        while(newHead -> next != NULL)\\n            newHead = newHead -> next;\\n        \\n        newHead -> next = curr;        // as curr stores right-side data not reversed\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163598,
                "title": "very-easy-and-different-c-solution-70-faster",
                "content": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* p = new ListNode(0,head);\\n        if(right==left)\\n            return head;\\n        ListNode* l1 = p;\\n        int i=1;\\n        while(l1)\\n        {\\n            if(i>=left)\\n                break;\\n            l1=l1->next;\\n            i++;\\n        }\\n        ListNode* next = l1;\\n        ListNode* curr = l1->next;\\n        ListNode* prev = l1;\\n        while(curr)\\n        {\\n            if(i==right+1)\\n                break;\\n            next = curr->next;\\n            curr->next=prev;\\n            prev = curr;\\n            curr = next;\\n            i++;   \\n        }\\n        l1->next->next = curr;\\n        l1->next = prev;\\n        return p->next;\\n    }\\n\\t\\n\\tIf you like the code, do upvote.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* p = new ListNode(0,head);\\n        if(right==left)\\n            return head;\\n        ListNode* l1 = p;\\n        int i=1;\\n        while(l1)\\n        {\\n            if(i>=left)\\n                break;\\n            l1=l1->next;\\n            i++;\\n        }\\n        ListNode* next = l1;\\n        ListNode* curr = l1->next;\\n        ListNode* prev = l1;\\n        while(curr)\\n        {\\n            if(i==right+1)\\n                break;\\n            next = curr->next;\\n            curr->next=prev;\\n            prev = curr;\\n            curr = next;\\n            i++;   \\n        }\\n        l1->next->next = curr;\\n        l1->next = prev;\\n        return p->next;\\n    }\\n\\t\\n\\tIf you like the code, do upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 2089708,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head->next) return head;\\n        if(left == right) return head;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        ListNode* curr = head;\\n        ListNode* start = NULL;\\n        //ListNode* end = NULL;\\n        int idx = 1;\\n        while(curr && idx <= right)\\n        {\\n            if(idx == left)\\n            {\\n                start = prev;\\n                \\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            idx++;\\n        }\\n        //cout << start->next->val << \" \" << end->val;\\n        while(start->next != prev)\\n        {\\n            //cout<< start->next->val;\\n            //if(!curr) cout<<prev->val << \" \";\\n            prev->next = start->next;\\n            //cout<< start->next->val;\\n            //cout << prev->next->val;\\n            ListNode* tmp = start->next->next;\\n            start->next->next = curr;\\n            start->next = tmp;\\n            curr = prev->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(!head->next) return head;\\n        if(left == right) return head;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* prev = dummy;\\n        ListNode* curr = head;\\n        ListNode* start = NULL;\\n        //ListNode* end = NULL;\\n        int idx = 1;\\n        while(curr && idx <= right)\\n        {\\n            if(idx == left)\\n            {\\n                start = prev;\\n                \\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            idx++;\\n        }\\n        //cout << start->next->val << \" \" << end->val;\\n        while(start->next != prev)\\n        {\\n            //cout<< start->next->val;\\n            //if(!curr) cout<<prev->val << \" \";\\n            prev->next = start->next;\\n            //cout<< start->next->val;\\n            //cout << prev->next->val;\\n            ListNode* tmp = start->next->next;\\n            start->next->next = curr;\\n            start->next = tmp;\\n            curr = prev->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2026310,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        curCount = 1\\n        leftPre = dummy\\n        rightNex = head\\n        \\n        while cur:\\n            if curCount < left:\\n                leftPre = leftPre.next\\n            if curCount == right:\\n                rightNex = cur.next\\n                cur.next = None\\n                break\\n            cur = cur.next\\n            curCount += 1\\n        \\n        pre = leftPre\\n        cur = pre.next\\n        nex = cur.next\\n        while nex:\\n            cur.next = nex.next\\n            nex.next = pre.next\\n            pre.next = nex\\n            nex = cur.next\\n        \\n        cur.next = rightNex\\n        return dummy.next\\n\\t\\t\\n# Time: O(n)\\n# Space: O(1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\\n        if not head or not head.next: return head\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        cur = head\\n        curCount = 1\\n        leftPre = dummy\\n        rightNex = head\\n        \\n        while cur:\\n            if curCount < left:\\n                leftPre = leftPre.next\\n            if curCount == right:\\n                rightNex = cur.next\\n                cur.next = None\\n                break\\n            cur = cur.next\\n            curCount += 1\\n        \\n        pre = leftPre\\n        cur = pre.next\\n        nex = cur.next\\n        while nex:\\n            cur.next = nex.next\\n            nex.next = pre.next\\n            pre.next = nex\\n            nex = cur.next\\n        \\n        cur.next = rightNex\\n        return dummy.next\\n\\t\\t\\n# Time: O(n)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934292,
                "title": "clean-iterative-ruby",
                "content": "Using Ruby\\'s parallel assignment really helps clean things up\\n\\n```\\ndef reverse_between(head, left, right)\\n  prehead = ListNode.new(0, head)\\n  prev, curr = prehead, head\\n  \\n  (left-1).times { prev, curr = curr, curr.next } # set pointers\\n  \\n  node = prev\\n  (right-left+1).times { curr.next, prev, curr = prev, curr, curr.next } # reverse list\\n  \\n  node.next.next, node.next = curr, prev # attach nodes\\n  prehead.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef reverse_between(head, left, right)\\n  prehead = ListNode.new(0, head)\\n  prev, curr = prehead, head\\n  \\n  (left-1).times { prev, curr = curr, curr.next } # set pointers\\n  \\n  node = prev\\n  (right-left+1).times { curr.next, prev, curr = prev, curr, curr.next } # reverse list\\n  \\n  node.next.next, node.next = curr, prev # attach nodes\\n  prehead.next\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1694423,
                "title": "reverse-linked-list-ii-c-east-to-understand-o-n-time",
                "content": "Logic is to seperate the right side  node and then reverse the remaining from the given left part and then combine the 2 half \\n```\\n ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        ListNode* templeft = head;\\n        ListNode* prevleft = NULL;\\n        while(right)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n            right--;\\n            left--;\\n            if(left > 0)\\n            {\\n                prevleft = templeft;\\n                templeft = templeft->next;\\n            }\\n        }\\n        if(prevleft != NULL)\\n        {\\n            prev->next = NULL;\\n            prevleft->next = reverse(templeft);\\n            templeft->next = temp;\\n            return head;\\n        }\\n        prev->next = NULL;\\n        head = reverse(templeft);\\n        templeft->next = temp;\\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Logic is to seperate the right side  node and then reverse the remaining from the given left part and then combine the 2 half \\n```\\n ListNode* reverse(ListNode* head)\\n    {\\n        if(head == NULL || head->next == NULL)\\n            return head;\\n        \\n        ListNode* newhead = reverse(head->next);\\n        \\n        head->next->next = head;\\n        head->next = NULL;\\n        \\n        return newhead;\\n        \\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        ListNode* temp = head;\\n        ListNode* prev = NULL;\\n        \\n        ListNode* templeft = head;\\n        ListNode* prevleft = NULL;\\n        while(right)\\n        {\\n            prev = temp;\\n            temp = temp->next;\\n            right--;\\n            left--;\\n            if(left > 0)\\n            {\\n                prevleft = templeft;\\n                templeft = templeft->next;\\n            }\\n        }\\n        if(prevleft != NULL)\\n        {\\n            prev->next = NULL;\\n            prevleft->next = reverse(templeft);\\n            templeft->next = temp;\\n            return head;\\n        }\\n        prev->next = NULL;\\n        head = reverse(templeft);\\n        templeft->next = temp;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1621650,
                "title": "c-non-recursive-iterative-approach-linked-list-to-vector-0-n-0ms",
                "content": "**Idea : First store values of linked list in a vector then reverse it . It\\'s easy that way :)\\nand in the end store values of vector into linked list again**.\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* temp = head;\\n        vector<int> nums;\\n        // Store linked list data in a vector so it\\'s operation becomes easier\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        // subtract left and right by 1 because vector\\'s index starts from 0\\n        left--;\\n        right--;\\n        \\n        // swap them\\n        while(left < right)\\n            swap(nums[left++], nums[right--]);\\n        \\n        // restore back vector\\'s data in linked list and return it\\n        temp = head;\\n        int i = 0;\\n        while(i < nums.size()){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Note : When u convert linked list into vectors/arrays it\\'s operation becomes easier\\nI know that\\'s not a good method to do it but still this way it makes problemsa easier lol**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* temp = head;\\n        vector<int> nums;\\n        // Store linked list data in a vector so it\\'s operation becomes easier\\n        while(temp != NULL){\\n            nums.push_back(temp->val);\\n            temp = temp->next;\\n        }\\n        // subtract left and right by 1 because vector\\'s index starts from 0\\n        left--;\\n        right--;\\n        \\n        // swap them\\n        while(left < right)\\n            swap(nums[left++], nums[right--]);\\n        \\n        // restore back vector\\'s data in linked list and return it\\n        temp = head;\\n        int i = 0;\\n        while(i < nums.size()){\\n            temp->val = nums[i++];\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594309,
                "title": "java-easy-0ms-100-faster",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        if(left==right) return head;\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next=head;\\n        ListNode s= dummy;\\n        if(left>1) s=s.next;\\n        ListNode e=head;\\n        \\n        for(int i=1;i<left-1;i++) s=s.next;\\n        for(int i=1;i<=right;i++) e=e.next;\\n       \\n       ListNode r= reverseList(s.next,e);\\n         \\n        s.next=r;\\n        while(s.next!=null){\\n            s=s.next;\\n        }\\n        s.next=e;\\n          \\n        return dummy.next;\\n        \\n    }\\n   \\n    public ListNode reverseList(ListNode head, ListNode tail) {\\n        if(head==null || head.next==null) return head;\\n       ListNode newhead = null;\\n        while(head!=tail){\\n            ListNode temp = head.next;\\n            \\n            head.next= newhead;\\n            newhead= head;\\n            head=temp;\\n            \\n        }\\n        \\n        return newhead;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null || head.next==null) return head;\\n        if(left==right) return head;\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next=head;\\n        ListNode s= dummy;\\n        if(left>1) s=s.next;\\n        ListNode e=head;\\n        \\n        for(int i=1;i<left-1;i++) s=s.next;\\n        for(int i=1;i<=right;i++) e=e.next;\\n       \\n       ListNode r= reverseList(s.next,e);\\n         \\n        s.next=r;\\n        while(s.next!=null){\\n            s=s.next;\\n        }\\n        s.next=e;\\n          \\n        return dummy.next;\\n        \\n    }\\n   \\n    public ListNode reverseList(ListNode head, ListNode tail) {\\n        if(head==null || head.next==null) return head;\\n       ListNode newhead = null;\\n        while(head!=tail){\\n            ListNode temp = head.next;\\n            \\n            head.next= newhead;\\n            newhead= head;\\n            head=temp;\\n            \\n        }\\n        \\n        return newhead;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467541,
                "title": "easy-naive-cpp-solution",
                "content": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* temp=head,*temp1=NULL;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        int j=left;\\n        while(j<=right){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n            j++;\\n        }\\n        temp=head;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        j=v.size()-1;\\n        while(left<=right){\\n            temp->val=v[j--];\\n            temp=temp->next;\\n            left++;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverseBetween(ListNode* head, int left, int right) {\\n        vector<int>v;\\n        ListNode* temp=head,*temp1=NULL;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        int j=left;\\n        while(j<=right){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n            j++;\\n        }\\n        temp=head;\\n        for(int i=1;i<left;i++) temp=temp->next;\\n        j=v.size()-1;\\n        while(left<=right){\\n            temp->val=v[j--];\\n            temp=temp->next;\\n            left++;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292533,
                "title": "reverse-linked-list-ii-python3-two-solutions",
                "content": "```\\nclass Solution:\\n    def Stack_reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Solutino using stack to push itens that should be reversed, and pop them after\\n        pos = 1\\n        curr = head\\n        anter = None\\n        stack = []\\n        while pos < left:\\n            pos += 1\\n            anter = curr\\n            curr = curr.next\\n        nodoleft = anter\\n        while pos <= right:\\n            pos += 1\\n            stack.append(curr)\\n            curr = curr.next\\n        if not nodoleft:\\n            nodoleft = stack.pop()\\n            head = nodoleft\\n        while len(stack):\\n            nodoleft.next = stack.pop()\\n            nodoleft = nodoleft.next\\n        nodoleft.next = curr\\n        return head\\n\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Reverting on the way\\n        if left == right:\\n            return head\\n        prev = curr = head\\n        pos = 1\\n        while pos < left:\\n            pos += 1\\n            prev = curr\\n            curr = curr.next\\n        nleft = prev\\n        nlast = curr\\n        nfirst = curr\\n        curr = curr.next\\n        pos += 1\\n        while pos < right:\\n            pos += 1\\n            next = curr.next\\n            curr.next = nfirst\\n            nfirst = curr\\n            curr = next\\n        if left > 1:\\n            nleft.next = curr\\n        else:\\n            head = curr\\n        nlast.next = curr.next\\n        curr.next = nfirst\\n        return head\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def Stack_reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Solutino using stack to push itens that should be reversed, and pop them after\\n        pos = 1\\n        curr = head\\n        anter = None\\n        stack = []\\n        while pos < left:\\n            pos += 1\\n            anter = curr\\n            curr = curr.next\\n        nodoleft = anter\\n        while pos <= right:\\n            pos += 1\\n            stack.append(curr)\\n            curr = curr.next\\n        if not nodoleft:\\n            nodoleft = stack.pop()\\n            head = nodoleft\\n        while len(stack):\\n            nodoleft.next = stack.pop()\\n            nodoleft = nodoleft.next\\n        nodoleft.next = curr\\n        return head\\n\\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\\n        # Reverting on the way\\n        if left == right:\\n            return head\\n        prev = curr = head\\n        pos = 1\\n        while pos < left:\\n            pos += 1\\n            prev = curr\\n            curr = curr.next\\n        nleft = prev\\n        nlast = curr\\n        nfirst = curr\\n        curr = curr.next\\n        pos += 1\\n        while pos < right:\\n            pos += 1\\n            next = curr.next\\n            curr.next = nfirst\\n            nfirst = curr\\n            curr = next\\n        if left > 1:\\n            nleft.next = curr\\n        else:\\n            head = curr\\n        nlast.next = curr.next\\n        curr.next = nfirst\\n        return head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292254,
                "title": "python-simulation",
                "content": "Approach 1: Simulation\\n```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @param m, an integer\\n    # @param n, an integer\\n    # @return a ListNode\\n    def reverseBetween(self, head, m, n):\\n        dummy, diff = ListNode(0), n - m\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        while m > 1:\\n            prev, curr = curr, curr.next\\n            m -= 1\\n        last_unswapped, first_swapped = prev, curr\\n        while curr and diff >= 0:\\n            curr.next, prev, curr = prev, curr, curr.next\\n            diff -= 1\\n        last_unswapped.next, first_swapped.next = prev, curr\\n        return dummy.next\\n        # Here is an exmple\\n        # 1 --> 2 --> 3 --> 4 --> 5\\n        #       \\n        # Before first while-loop\\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5\\n        #      prev  curr\\n        # After first while-loop \\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5 \\n        #            prev curr \\n        #  last_unswapped, first_swapped = prev, curr\\n        # The following is the details for 2nd while-loop\\n        # diff=2 #   1 <-- 2 --> 3 --> 4 --> 5\\n        #                 prev  curr\\n        # diff=1 #   1 <-- 2 <-- 3 --> 4 --> 5\\n        #                       prev  curr\\n        # diff=0 #   1 <-- 2 <-- 3 <-- 4 --> 5\\n        #                             prev  curr\\n        # last_unswapped.next = prev\\n        # first_swapped.next  = curr\\n        # After impletenting the above two lines, we get:\\n        #         first_swapped.next = curr\\n        #          __________________  \\n        #          ^                 |      \\n        #          |                 V \\n        # 1        2 <-- 3 <-- 4     5\\n        # |                    ^\\n        # V ___________________| \\n        # last_unswapped.next=prev    \\n        # Reverse partial Linked List\\n        # Refer Figure1: http://images.cnitblog.com/i/546654/201404/072244468407048.jpg\\n        # Refer: http://www.cnblogs.com/4everlove/p/3651002.html\\n        # Refer: http://stackoverflow.com/questions/21529359/reversing-a-linked-list-in-python\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    # @param head, a ListNode\\n    # @param m, an integer\\n    # @param n, an integer\\n    # @return a ListNode\\n    def reverseBetween(self, head, m, n):\\n        dummy, diff = ListNode(0), n - m\\n        dummy.next = head\\n        prev, curr = dummy, dummy.next\\n        while m > 1:\\n            prev, curr = curr, curr.next\\n            m -= 1\\n        last_unswapped, first_swapped = prev, curr\\n        while curr and diff >= 0:\\n            curr.next, prev, curr = prev, curr, curr.next\\n            diff -= 1\\n        last_unswapped.next, first_swapped.next = prev, curr\\n        return dummy.next\\n        # Here is an exmple\\n        # 1 --> 2 --> 3 --> 4 --> 5\\n        #       \\n        # Before first while-loop\\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5\\n        #      prev  curr\\n        # After first while-loop \\n        #      0 --> 1 --> 2 --> 3 --> 4 --> 5 \\n        #            prev curr \\n        #  last_unswapped, first_swapped = prev, curr\\n        # The following is the details for 2nd while-loop\\n        # diff=2 #   1 <-- 2 --> 3 --> 4 --> 5\\n        #                 prev  curr\\n        # diff=1 #   1 <-- 2 <-- 3 --> 4 --> 5\\n        #                       prev  curr\\n        # diff=0 #   1 <-- 2 <-- 3 <-- 4 --> 5\\n        #                             prev  curr\\n        # last_unswapped.next = prev\\n        # first_swapped.next  = curr\\n        # After impletenting the above two lines, we get:\\n        #         first_swapped.next = curr\\n        #          __________________  \\n        #          ^                 |      \\n        #          |                 V \\n        # 1        2 <-- 3 <-- 4     5\\n        # |                    ^\\n        # V ___________________| \\n        # last_unswapped.next=prev    \\n        # Reverse partial Linked List\\n        # Refer Figure1: http://images.cnitblog.com/i/546654/201404/072244468407048.jpg\\n        # Refer: http://www.cnblogs.com/4everlove/p/3651002.html\\n        # Refer: http://stackoverflow.com/questions/21529359/reversing-a-linked-list-in-python\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250959,
                "title": "java-linkedlist-0ms-beats-100-t-c-o-n-s-c-o-1",
                "content": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        ListNode temp1 = dummy;\\n        for(int i = 0; i <= left - 2; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = right - left + 1;\\n        \\n        ListNode temp2 = temp1;\\n        for(int i = 0; i < total; i++)\\n            temp2 = temp2.next;\\n                \\n        ListNode end = temp2.next;\\n        temp2.next = null;\\n        ListNode temp = temp1.next;\\n        ListNode rev = reverseList(temp);\\n        temp1.next = rev;\\n        temp.next = end;\\n        \\n        return dummy.next;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        \\n       ListNode pre = head;\\n       ListNode curr = head.next;\\n        \\n       while(curr!=null){\\n           ListNode ahead = curr.next;\\n           curr.next = pre;\\n           pre = curr;\\n           curr = ahead;\\n       } \\n        \\n       head.next = null;\\n        \\n       ListNode temp = head;\\n       return pre;\\n    }",
                "solutionTags": [],
                "code": "\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        \\n        ListNode temp1 = dummy;\\n        for(int i = 0; i <= left - 2; i++)\\n            temp1 = temp1.next;\\n        \\n        int total = right - left + 1;\\n        \\n        ListNode temp2 = temp1;\\n        for(int i = 0; i < total; i++)\\n            temp2 = temp2.next;\\n                \\n        ListNode end = temp2.next;\\n        temp2.next = null;\\n        ListNode temp = temp1.next;\\n        ListNode rev = reverseList(temp);\\n        temp1.next = rev;\\n        temp.next = end;\\n        \\n        return dummy.next;\\n    }\\n    \\n    public ListNode reverseList(ListNode head) {\\n        \\n       ListNode pre = head;\\n       ListNode curr = head.next;\\n        \\n       while(curr!=null){\\n           ListNode ahead = curr.next;\\n           curr.next = pre;\\n           pre = curr;\\n           curr = ahead;\\n       } \\n        \\n       head.next = null;\\n        \\n       ListNode temp = head;\\n       return pre;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1088300,
                "title": "simple-solution-with-explanation-0ms",
                "content": "**Simple C++ solution:** Simple swapping operation, no recursion\\n**Time: 0 ms**\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* left_pos=head,*right_pos=head;\\n        int i=1,temp,diff,j;\\n        while(i!=left)\\n        {\\n            left_pos=left_pos->next;\\n            right_pos=right_pos->next;\\n            i++;\\n        }\\n        while(left<right)\\n        {\\n            right_pos=left_pos;\\n            diff=right-left;\\n            j=0;\\n            while(j!=diff)\\n            {\\n                right_pos=right_pos->next; \\n                j++;\\n            }\\n            //Swapping \\n            temp=left_pos->val;\\n            left_pos->val=right_pos->val;\\n            right_pos->val=temp;\\n            //Updating the pointers\\n            left++;\\n            right--;\\n            left_pos=left_pos->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nRuntime: 0 ms\\n*Time Comp: O(n)*\\n*Space Comp: O(1)*\\n\\nIf you like, please **UPVOTE**\\nHappy Coding :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* left_pos=head,*right_pos=head;\\n        int i=1,temp,diff,j;\\n        while(i!=left)\\n        {\\n            left_pos=left_pos->next;\\n            right_pos=right_pos->next;\\n            i++;\\n        }\\n        while(left<right)\\n        {\\n            right_pos=left_pos;\\n            diff=right-left;\\n            j=0;\\n            while(j!=diff)\\n            {\\n                right_pos=right_pos->next; \\n                j++;\\n            }\\n            //Swapping \\n            temp=left_pos->val;\\n            left_pos->val=right_pos->val;\\n            right_pos->val=temp;\\n            //Updating the pointers\\n            left++;\\n            right--;\\n            left_pos=left_pos->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981806,
                "title": "java-recursive-beats-100",
                "content": "```\\nclass Solution {\\n    ListNode headTail;\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        return reverseBetween(head,  m,  n, 1);\\n    }\\n    public ListNode reverseBetween(ListNode head, int m, int n, int i) {\\n         if (head==null){\\n            return null;\\n        }\\n        if (i==n){\\n          headTail = reverseBetween(head.next,m,n,i+1);\\n          return head;  \\n        }\\n        else if (i>=m && i<n){\\n            ListNode node = reverseBetween(head.next,m,n,i+1);\\n            if (head.next!=null){\\n                head.next.next = head;\\n                head.next=null;\\n            }\\n            if (i==m){\\n                head.next = headTail;\\n            }\\n            return node;\\n        }\\n        else {\\n            head.next = reverseBetween(head.next,m,n,i+1);\\n            return head;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ListNode headTail;\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        return reverseBetween(head,  m,  n, 1);\\n    }\\n    public ListNode reverseBetween(ListNode head, int m, int n, int i) {\\n         if (head==null){\\n            return null;\\n        }\\n        if (i==n){\\n          headTail = reverseBetween(head.next,m,n,i+1);\\n          return head;  \\n        }\\n        else if (i>=m && i<n){\\n            ListNode node = reverseBetween(head.next,m,n,i+1);\\n            if (head.next!=null){\\n                head.next.next = head;\\n                head.next=null;\\n            }\\n            if (i==m){\\n                head.next = headTail;\\n            }\\n            return node;\\n        }\\n        else {\\n            head.next = reverseBetween(head.next,m,n,i+1);\\n            return head;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902722,
                "title": "java-easy-to-understand",
                "content": "////Please upvote if you like\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n     \\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        for(int i=0;i<m-1;++i)\\n        {\\n            pre=pre.next;\\n        }\\n        ListNode curr=pre.next;\\n        for(int i=0;i<n-m;++i)\\n        {\\n            ListNode Next=curr.next;\\n            curr.next=Next.next;\\n            Next.next=pre.next;\\n            pre.next=Next;\\n        }\\n        \\n       return dummy.next;    \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n     \\n        ListNode dummy=new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        for(int i=0;i<m-1;++i)\\n        {\\n            pre=pre.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 808421,
                "title": "rust-solution-no-stack-0ms",
                "content": "Pretty straight forward, but as always, very annoying to do in Rust because of the ownership rules.\\n\\nWith `reverse_between` if `m` is 1, then we reverse starting at the beginning, otherwise, walk to one before the right position.\\nWe do one before, so we use `node.next.take()` to transfer ownership. It then links the next node to the reverse of the rest.\\n\\n`reverse`, will reverse `count` number of nodes, and then append the rest to the end. It does it recursively, so we have to pass an accumulator of `None` for the initial call.\\n\\n`append` walks the first list to the end, and then appends the second list. \\n\\n```\\nimpl Solution {\\n    pub fn reverse_between(\\n        mut head: Option<Box<ListNode>>,\\n        m: i32,\\n        n: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if m == 1 {\\n            return Self::reverse(head, None, n - m + 1);\\n        }\\n\\n        let mut count = 1;\\n        let mut current = head.as_mut();\\n        while let Some(node) = current {\\n            count += 1;\\n\\n            if count == m {\\n                node.next = Self::reverse(node.next.take(), None, n - m + 1);\\n                break;\\n            } else {\\n                current = node.next.as_mut();\\n            }\\n        }\\n\\n        head\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        acc: Option<Box<ListNode>>,\\n        count: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            return Self::append(acc, head);\\n        }\\n\\n        if let Some(mut node) = head {\\n            let next = node.next;\\n            node.next = acc;\\n\\n            Self::reverse(next, Some(node), count - 1)\\n        } else {\\n            acc\\n        }\\n    }\\n\\n    fn append(\\n        mut front: Option<Box<ListNode>>,\\n        back: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut current = front.as_mut();\\n        while let Some(node) = current {\\n            if node.next.is_none() {\\n                node.next = back;\\n                break;\\n            }\\n            current = node.next.as_mut();\\n        }\\n\\n        front\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn reverse_between(\\n        mut head: Option<Box<ListNode>>,\\n        m: i32,\\n        n: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if m == 1 {\\n            return Self::reverse(head, None, n - m + 1);\\n        }\\n\\n        let mut count = 1;\\n        let mut current = head.as_mut();\\n        while let Some(node) = current {\\n            count += 1;\\n\\n            if count == m {\\n                node.next = Self::reverse(node.next.take(), None, n - m + 1);\\n                break;\\n            } else {\\n                current = node.next.as_mut();\\n            }\\n        }\\n\\n        head\\n    }\\n\\n    fn reverse(\\n        head: Option<Box<ListNode>>,\\n        acc: Option<Box<ListNode>>,\\n        count: i32,\\n    ) -> Option<Box<ListNode>> {\\n        if count == 0 {\\n            return Self::append(acc, head);\\n        }\\n\\n        if let Some(mut node) = head {\\n            let next = node.next;\\n            node.next = acc;\\n\\n            Self::reverse(next, Some(node), count - 1)\\n        } else {\\n            acc\\n        }\\n    }\\n\\n    fn append(\\n        mut front: Option<Box<ListNode>>,\\n        back: Option<Box<ListNode>>,\\n    ) -> Option<Box<ListNode>> {\\n        let mut current = front.as_mut();\\n        while let Some(node) = current {\\n            if node.next.is_none() {\\n                node.next = back;\\n                break;\\n            }\\n            current = node.next.as_mut();\\n        }\\n\\n        front\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560525,
                "title": "simple-python-solution-faster-than-93",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        a = []\\n        for i in range(n): #leave the tail unchanged\\n            a.append(head)\\n            head = head.next\\n            \\n        a = a[:m-1] + a[m-1:][::-1] #reverse the middle part\\n        \\n        for i in range(len(a)-1, -1, -1): #link all nodes\\n            tmp = a[i]\\n            tmp.next = head\\n            head = tmp\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        a = []\\n        for i in range(n): #leave the tail unchanged\\n            a.append(head)\\n            head = head.next\\n            \\n        a = a[:m-1] + a[m-1:][::-1] #reverse the middle part\\n        \\n        for i in range(len(a)-1, -1, -1): #link all nodes\\n            tmp = a[i]\\n            tmp.next = head\\n            head = tmp\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509552,
                "title": "python3-solution-in-single-pass-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        count = 1\\n        prev = None\\n        prev_r = None\\n        temp = head\\n        last = None\\n        while temp:\\n            if count==n:\\n                actual_last = temp\\n                last = temp.next\\n            if count<m:\\n                prev_r = temp\\n            if count==m:\\n                actual = temp\\n            if count>=m and count<=n:\\n                next = temp.next\\n                temp.next = prev\\n                prev = temp\\n                temp = next\\n            else:\\n                prev = temp\\n                temp = temp.next\\n            count+=1\\n        actual.next = last\\n        if prev_r==None:\\n            return actual_last\\n        else:\\n            prev_r.next = actual_last\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        count = 1\\n        prev = None\\n        prev_r = None\\n        temp = head\\n        last = None\\n        while temp:\\n            if count==n:\\n                actual_last = temp\\n                last = temp.next\\n            if count<m:\\n                prev_r = temp\\n            if count==m:\\n                actual = temp\\n            if count>=m and count<=n:\\n                next = temp.next\\n                temp.next = prev\\n                prev = temp\\n                temp = next\\n            else:\\n                prev = temp\\n                temp = temp.next\\n            count+=1\\n        actual.next = last\\n        if prev_r==None:\\n            return actual_last\\n        else:\\n            prev_r.next = actual_last\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319298,
                "title": "easy-to-read-java-beats-100",
                "content": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode back = dummy, front = dummy;\\n        for (int i = 0; i < m - 1; i++) back = back.next;\\n        for (int i = 0; i < n + 1; i++) front = front.next;\\n        \\n        ListNode prev = front;\\n        ListNode curr = back.next;\\n        while (curr != front) {\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        back.next = prev;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int m, int n) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode back = dummy, front = dummy;\\n        for (int i = 0; i < m - 1; i++) back = back.next;\\n        for (int i = 0; i < n + 1; i++) front = front.next;\\n        \\n        ListNode prev = front;\\n        ListNode curr = back.next;\\n        while (curr != front) {\\n            ListNode tmp = curr.next;\\n            curr.next = prev;\\n            prev = curr;\\n            curr = tmp;\\n        }\\n        back.next = prev;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318517,
                "title": "swift-top-97-single-pass-o-n-solution-shorter-shortest",
                "content": "I know it\\'s possible to get it shorter by combining operations.\\n\\nThis is as short as I can get it, using a sentinel node to accommodate reversed first portions...\\n\\n      [1, 2, 3, 4, 5, 6] 1  3\\n=> [3, 2, 1, 4, 5, 6]\\n\\n```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n        \\n        var sentinel = ListNode(0)\\n        sentinel.next = head\\n        var prev: ListNode? = sentinel\\n        var node: ListNode? = head\\n        \\n        var index = 1\\n        while index < m && node != nil {\\n            prev = node\\n            node = node!.next\\n            index += 1\\n        }\\n        \\n        var m_tail: ListNode! = prev\\n        var n_head: ListNode? = node\\n        \\n        var next: ListNode?\\n        while index <= n && node != nil {\\n            next = node!.next\\n            node!.next = prev\\n            prev = node\\n            node = next\\n            index += 1\\n        }\\n        \\n        m_tail.next = prev\\n        n_head?.next = node\\n        \\n        return sentinel.next\\n    }\\n}\\n```\\n\\nPretty good. If you think you can beat it, send me a hatemail. I will not reply. This question is for pleebs and daywalkers.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -> ListNode? {\\n        \\n        var sentinel = ListNode(0)\\n        sentinel.next = head\\n        var prev: ListNode? = sentinel\\n        var node: ListNode? = head\\n        \\n        var index = 1\\n        while index < m && node != nil {\\n            prev = node\\n            node = node!.next\\n            index += 1\\n        }\\n        \\n        var m_tail: ListNode! = prev\\n        var n_head: ListNode? = node\\n        \\n        var next: ListNode?\\n        while index <= n && node != nil {\\n            next = node!.next\\n            node!.next = prev\\n            prev = node\\n            node = next\\n            index += 1\\n        }\\n        \\n        m_tail.next = prev\\n        n_head?.next = node\\n        \\n        return sentinel.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264533,
                "title": "go-double-100",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    shadowHead := &ListNode{ Next: head }\\n    prevNode := shadowHead\\n    for i := 1; i < m; i++ {\\n        prevNode = prevNode.Next\\n        head = head.Next\\n    }\\n    mNode := head\\n    nNode := head.Next\\n    for i := m; i < n; i++ {\\n        nextNNode := nNode.Next\\n        nNode.Next = head\\n        head = nNode\\n        nNode = nextNNode\\n    }\\n    mNode.Next = nNode\\n    prevNode.Next = head\\n    return shadowHead.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc reverseBetween(head *ListNode, m int, n int) *ListNode {\\n    shadowHead := &ListNode{ Next: head }\\n    prevNode := shadowHead\\n    for i := 1; i < m; i++ {\\n        prevNode = prevNode.Next\\n        head = head.Next\\n    }\\n    mNode := head\\n    nNode := head.Next\\n    for i := m; i < n; i++ {\\n        nextNNode := nNode.Next\\n        nNode.Next = head\\n        head = nNode\\n        nNode = nextNNode\\n    }\\n    mNode.Next = nNode\\n    prevNode.Next = head\\n    return shadowHead.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216869,
                "title": "c-clean-code-with-explaination-drawing",
                "content": "Try to maintain prev, curr, and next Nodes along the line\\n\\nInitialize: \\nSet dummy and prev nodes point to head of linked list. Then move prev node before current node. \\nCurrent node is set at where reversion occurs\\n![image](https://assets.leetcode.com/users/uyenmnguyen/image_1547165157.png)\\n\\nWhile m++ < n, move pre and current along the line\\n![image](https://assets.leetcode.com/users/uyenmnguyen/image_1547165727.png)\\n\\nFinally, return dummy.next;\\n```\\n public ListNode ReverseBetween(ListNode head, int m, int n) {\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n      \\n      ListNode pre = dummy;\\n      for(int i = 1; i < m; i++)\\n        pre = pre.next;\\n      \\n      ListNode cur = pre.next;\\n      while(m ++ <n)\\n      {\\n          var temp = cur.next;\\n          cur.next = temp.next;\\n          temp.next = pre.next;\\n          pre.next = temp;\\n      }\\n      \\n      return dummy.next;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n public ListNode ReverseBetween(ListNode head, int m, int n) {\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n      \\n      ListNode pre = dummy;\\n      for(int i = 1; i < m; i++)\\n        pre = pre.next;\\n      \\n      ListNode cur = pre.next;\\n      while(m ++ <n)\\n      {\\n          var temp = cur.next;\\n          cur.next = temp.next;\\n          temp.next = pre.next;\\n          pre.next = temp;\\n      }\\n      \\n      return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 30801,
                "title": "easy-to-understand-c-solution",
                "content": "This is a partial reversal, we need to find the left interface (let it be `leftI`, `(m-1)th` node) to link the head of reversed list, and the tail of reversed list will link with the right interface(let it be `rightI`, `(n+1)th` node).  This sounds all right, what if `m = 1`? There is nothing left to the head. A common way to do is to introduce a dummy head. So now there are four things to do:\\n\\n    1. Find and record leftI\\n    2. Reverse sublist [m,n] -> [rhead, rtail]\\n    3. Find and record rightI\\n    4. Relink: leftI->next = rhead, rtail->next = rightI \\n    5. Return dummy->next\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode *leftI = dummy;\\n            for(; --m; --n) leftI = leftI->next; \\n    \\n            ListNode *cur = leftI->next, *rtail = cur, *pre = nullptr;\\n            while(n--){\\n                ListNode* nxt = cur->next;\\n                cur->next = pre;\\n                pre = cur;\\n                cur = nxt;\\n            }\\n            rtail->next = cur; leftI->next = pre;\\n    \\n            return dummy->next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* reverseBetween(ListNode* head, int m, int n) {\\n            ListNode* dummy = new ListNode(0);\\n            dummy->next = head;\\n            ListNode *leftI = dummy;\\n            for(; --m; --n) leftI = leftI->next; \\n    \\n            ListNode *cur = leftI->next, *rtail = cur, *pre = nullptr;\\n            while(n--){\\n                ListNode* nxt = cur->next;\\n                cur->next = pre;\\n                pre = cur;\\n                cur = nxt;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4014442,
                "title": "beats-100-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n\\n    struct ListNode *p = head,*k=head;\\n    int i = 1,kk=0;\\n    int a[100000];\\n    while(p!=NULL){\\n        if (i>=left && i<=right){\\n            a[kk++]=p->val;\\n        }\\n        p=p->next;\\n        i++;\\n    }\\n    i=1;\\n    while(k!=NULL){\\n        if (i>=left && i<=right){\\n            k->val=a[--kk];\\n        }\\n        k=k->next;\\n        i++;\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* reverseBetween(struct ListNode* head, int left, int right){\\n\\n    struct ListNode *p = head,*k=head;\\n    int i = 1,kk=0;\\n    int a[100000];\\n    while(p!=NULL){\\n        if (i>=left && i<=right){\\n            a[kk++]=p->val;\\n        }\\n        p=p->next;\\n        i++;\\n    }\\n    i=1;\\n    while(k!=NULL){\\n        if (i>=left && i<=right){\\n            k->val=a[--kk];\\n        }\\n        k=k->next;\\n        i++;\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013373,
                "title": "o-ms-beats-100-users-java-easy-approach-for-beginers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right)  {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size =0;\\n        ListNode temp = head;\\n        ListNode leftNode  = null;\\n        ListNode rightNode  = null;\\n        List<Integer> arr = new ArrayList<>();\\n        while(temp != null ){\\n            size++;\\n            if(size == left){\\n                leftNode = temp;\\n            }\\n            if(size >= left && size <= right){\\n                arr.add(temp.val);\\n            }\\n            if(size == right){\\n                rightNode= temp;\\n            }\\n            temp = temp.next;\\n        }\\n        int sizes = left;\\n        int arrSize = arr.size()-1;\\n        while(sizes <= right){\\n            leftNode.val = arr.get(arrSize--);\\n            leftNode = leftNode.next;\\n            sizes++;\\n        }\\n\\n\\n        return head;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right)  {\\n        if(head.next == null){\\n            return head;\\n        }\\n        int size =0;\\n        ListNode temp = head;\\n        ListNode leftNode  = null;\\n        ListNode rightNode  = null;\\n        List<Integer> arr = new ArrayList<>();\\n        while(temp != null ){\\n            size++;\\n            if(size == left){\\n                leftNode = temp;\\n            }\\n            if(size >= left && size <= right){\\n                arr.add(temp.val);\\n            }\\n            if(size == right){\\n                rightNode= temp;\\n            }\\n            temp = temp.next;\\n        }\\n        int sizes = left;\\n        int arrSize = arr.size()-1;\\n        while(sizes <= right){\\n            leftNode.val = arr.get(arrSize--);\\n            leftNode = leftNode.next;\\n            sizes++;\\n        }\\n\\n\\n        return head;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013213,
                "title": "simplest-ruby-solution-95",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI\\'ve attached the explanation of this problem here if the code isn\\'t clear enough. Super simple using only pointers.\\n[Solution JS/TS](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4013174/simplest-solution-0-n-time-95/)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {ListNode}\\ndef reverse_between(head, left, right)\\n    return head if left == right\\n    dummy = ListNode.new(0, @next=head)\\n    prev = dummy\\n    i = 1\\n\\n    # Set prev to pointer before left\\n    while i < left\\n        prev = prev.next\\n        i += 1\\n    end\\n\\n    curr = prev.next\\n    next_node = curr.next\\n\\n    # Begin reverse process with node at left and its next node \\n    while i < right\\n        temp = next_node.next\\n        next_node.next = curr\\n        curr = next_node\\n\\n        next_node = temp\\n        i += 1\\n    end\\n    \\n    # Set prev (1) next pointers to the in-between reversed list end i.e example1 = 4 -> 3 -> 2 AND\\n    # remaining part of the linked list i.e 5 -> nil\\n    prev.next.next = next_node\\n    prev.next = curr\\n\\n    dummy.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode\\n#     attr_accessor :val, :next\\n#     def initialize(val = 0, _next = nil)\\n#         @val = val\\n#         @next = _next\\n#     end\\n# end\\n# @param {ListNode} head\\n# @param {Integer} left\\n# @param {Integer} right\\n# @return {ListNode}\\ndef reverse_between(head, left, right)\\n    return head if left == right\\n    dummy = ListNode.new(0, @next=head)\\n    prev = dummy\\n    i = 1\\n\\n    # Set prev to pointer before left\\n    while i < left\\n        prev = prev.next\\n        i += 1\\n    end\\n\\n    curr = prev.next\\n    next_node = curr.next\\n\\n    # Begin reverse process with node at left and its next node \\n    while i < right\\n        temp = next_node.next\\n        next_node.next = curr\\n        curr = next_node\\n\\n        next_node = temp\\n        i += 1\\n    end\\n    \\n    # Set prev (1) next pointers to the in-between reversed list end i.e example1 = 4 -> 3 -> 2 AND\\n    # remaining part of the linked list i.e 5 -> nil\\n    prev.next.next = next_node\\n    prev.next = curr\\n\\n    dummy.next\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012897,
                "title": "easy-neat-and-clean-code-for-daily-leetcode-challenge",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseLL(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr!=NULL){\\n            ListNode* currkanext = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = currkanext;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(!head || head->next==NULL){\\n            return head;\\n        }\\n        \\n        left--;\\n        right--;\\n        \\n        ListNode* dummy1 = new ListNode(-1);\\n        ListNode* dummy2 = new ListNode(-1);\\n        ListNode* dummy3 = new ListNode(-1); \\n        \\n        ListNode* head1 = dummy1;\\n        \\n        ListNode* head2 = dummy2;\\n        \\n        ListNode* head3 = dummy3;\\n        \\n        ListNode* temp = head;\\n        for(int i=0;i<left;i++){\\n            dummy1->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        for(int i=left;i<=right;i++){\\n            dummy2->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        while(temp!=NULL){\\n            dummy3->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy3 = dummy3->next;\\n        }\\n        \\n        ListNode* dummy = head2->next;\\n        \\n        ListNode* node = reverseLL(head2->next);\\n        \\n        dummy1->next = node;\\n        \\n        cout<<dummy2->val<<endl;\\n        \\n        dummy->next = head3->next;\\n        \\n        return head1->next;\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* reverseLL(ListNode* head){\\n        \\n        ListNode* prev = NULL;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr!=NULL){\\n            ListNode* currkanext = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = currkanext;\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        \\n        if(!head || head->next==NULL){\\n            return head;\\n        }\\n        \\n        left--;\\n        right--;\\n        \\n        ListNode* dummy1 = new ListNode(-1);\\n        ListNode* dummy2 = new ListNode(-1);\\n        ListNode* dummy3 = new ListNode(-1); \\n        \\n        ListNode* head1 = dummy1;\\n        \\n        ListNode* head2 = dummy2;\\n        \\n        ListNode* head3 = dummy3;\\n        \\n        ListNode* temp = head;\\n        for(int i=0;i<left;i++){\\n            dummy1->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy1 = dummy1->next;\\n        }\\n        \\n        for(int i=left;i<=right;i++){\\n            dummy2->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy2 = dummy2->next;\\n        }\\n        \\n        while(temp!=NULL){\\n            dummy3->next = new ListNode(temp->val);\\n            temp = temp->next;\\n            dummy3 = dummy3->next;\\n        }\\n        \\n        ListNode* dummy = head2->next;\\n        \\n        ListNode* node = reverseLL(head2->next);\\n        \\n        dummy1->next = node;\\n        \\n        cout<<dummy2->val<<endl;\\n        \\n        dummy->next = head3->next;\\n        \\n        return head1->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4012812,
                "title": "beats-100-python-c-java-easy-linked-list",
                "content": "\\n```Python []\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if left >= right:\\n            return head\\n           \\n        ohead = newhd = ListNode(0)\\n        whead = wlast = head\\n        newhd.next = head\\n        for i in range(right-left):\\n            wlast = wlast.next\\n        for i in range(left-1):\\n            ohead, whead, wlast = whead, whead.next, wlast.next \\n        olast, wlast.next = wlast.next, None\\n        revhead, revlast = self.reverse(whead)\\n        ohead.next, revlast.next = revhead, olast\\n        return newhd.next\\n            \\n    def reverse(self, head):\\n        pre, curr, last = None, head, head\\n        while curr:\\n            curr.next, pre, curr = pre, curr, curr.next\\n        return pre, last\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* dummy = new ListNode(0), *pre = dummy , *curr;\\n        dummy->next = head;\\n\\n        for(int i = 0 ; i< left-1 ; i++){\\n            pre = pre->next;\\n        }\\n        curr = pre->next;\\n        pre->next = NULL;\\n        ListNode* l1 = curr;\\n\\n        ListNode* prev = NULL;\\n\\n        for(int i =0 ; i<= right-left ; i++){\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        l1->next = curr;\\n        pre->next = prev;\\n        return dummy->next;\\n\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode curr=head;\\n        int v[]=new int[right-left+1];\\n        int l=0,r=0;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n        while(r<right){  \\n            v[l]=curr.val;\\n            curr=curr.next;\\n            l++;\\n            r++;\\n        }\\n        r=0;l--;\\n        curr=head;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n            while(r<right){\\n                curr.val=v[l];\\n                curr=curr.next;\\n                l--;\\n                r++; \\n            }\\n    return head;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Python []\\nclass Solution(object):\\n    def reverseBetween(self, head, left, right):\\n        if left >= right:\\n            return head\\n           \\n        ohead = newhd = ListNode(0)\\n        whead = wlast = head\\n        newhd.next = head\\n        for i in range(right-left):\\n            wlast = wlast.next\\n        for i in range(left-1):\\n            ohead, whead, wlast = whead, whead.next, wlast.next \\n        olast, wlast.next = wlast.next, None\\n        revhead, revlast = self.reverse(whead)\\n        ohead.next, revlast.next = revhead, olast\\n        return newhd.next\\n            \\n    def reverse(self, head):\\n        pre, curr, last = None, head, head\\n        while curr:\\n            curr.next, pre, curr = pre, curr, curr.next\\n        return pre, last\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* dummy = new ListNode(0), *pre = dummy , *curr;\\n        dummy->next = head;\\n\\n        for(int i = 0 ; i< left-1 ; i++){\\n            pre = pre->next;\\n        }\\n        curr = pre->next;\\n        pre->next = NULL;\\n        ListNode* l1 = curr;\\n\\n        ListNode* prev = NULL;\\n\\n        for(int i =0 ; i<= right-left ; i++){\\n            ListNode* next = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = next;\\n        }\\n\\n        l1->next = curr;\\n        pre->next = prev;\\n        return dummy->next;\\n\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode curr=head;\\n        int v[]=new int[right-left+1];\\n        int l=0,r=0;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n        while(r<right){  \\n            v[l]=curr.val;\\n            curr=curr.next;\\n            l++;\\n            r++;\\n        }\\n        r=0;l--;\\n        curr=head;\\n        while(r<left-1) {\\n            curr=curr.next;\\n            r++;\\n        }\\n            while(r<right){\\n                curr.val=v[l];\\n                curr=curr.next;\\n                l--;\\n                r++; \\n            }\\n    return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012776,
                "title": "why-dummy-node-declaration-simplify-the-code-here-is-the-perfect-soln-with-great-explanation",
                "content": "#### The dummy ListNode declaration in this code is used to simplify the code when handling edge cases where the reversal of nodes needs to occur within the given linked list. Specifically, it helps in handling the cases where left is equal to 1 or where left is greater than 1.\\n\\n##### 1.left is equal to 1: In this case, the dummy ListNode (tmep) allows you to insert a new node at the beginning of the linked list to handle the reversal. Without a dummy node, you would need special logic to handle the case where the reversal starts from the head of the linked list.\\n\\n##### 2.left is greater than 1: In this case, the dummy ListNode is used to create a reference (prev) to the node just before the left-th node.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Check if the input list is empty; if so, return it as is.\\n        if (!head) return head;\\n\\n        // Create a dummy node with a value of 0 and set its next to the head.\\n        ListNode *temp = new ListNode(0);\\n        temp->next = head;\\n\\n        // Initialize a \\'prev\\' pointer to the dummy node.\\n        ListNode *prev = temp;\\n\\n        // Move \\'prev\\' to the node just before the \\'left\\' index.\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        // Initialize a \\'curr\\' pointer to \\'prev->next\\'.\\n        ListNode *curr = prev->next;\\n\\n        // Reverse the portion of the list between \\'left\\' and \\'right\\'.\\n        for (int i = 0; i < right - left; i++) {\\n            // Store the next node after \\'curr\\' in \\'nex\\'.\\n            ListNode* nex = curr->next;\\n\\n            // Update the next of \\'curr\\' to point to the node after \\'nex\\',\\n            // effectively detaching \\'curr\\' from the list.\\n            curr->next = nex->next;\\n\\n            // Update \\'nex->next\\' to point to \\'prev->next\\', effectively reversing\\n            // the direction of the next pointer of \\'nex\\'.\\n            nex->next = prev->next;\\n\\n            // Update \\'prev->next\\' to point to \\'nex\\', effectively linking \\'nex\\'\\n            // as the new next node after \\'prev\\'.\\n            prev->next = nex;\\n        }\\n\\n        // Return the modified linked list, starting from \\'temp->next\\'.\\n        return temp->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Check if the input list is empty; if so, return it as is.\\n        if (!head) return head;\\n\\n        // Create a dummy node with a value of 0 and set its next to the head.\\n        ListNode *temp = new ListNode(0);\\n        temp->next = head;\\n\\n        // Initialize a \\'prev\\' pointer to the dummy node.\\n        ListNode *prev = temp;\\n\\n        // Move \\'prev\\' to the node just before the \\'left\\' index.\\n        for (int i = 0; i < left - 1; i++) {\\n            prev = prev->next;\\n        }\\n\\n        // Initialize a \\'curr\\' pointer to \\'prev->next\\'.\\n        ListNode *curr = prev->next;\\n\\n        // Reverse the portion of the list between \\'left\\' and \\'right\\'.\\n        for (int i = 0; i < right - left; i++) {\\n            // Store the next node after \\'curr\\' in \\'nex\\'.\\n            ListNode* nex = curr->next;\\n\\n            // Update the next of \\'curr\\' to point to the node after \\'nex\\',\\n            // effectively detaching \\'curr\\' from the list.\\n            curr->next = nex->next;\\n\\n            // Update \\'nex->next\\' to point to \\'prev->next\\', effectively reversing\\n            // the direction of the next pointer of \\'nex\\'.\\n            nex->next = prev->next;\\n\\n            // Update \\'prev->next\\' to point to \\'nex\\', effectively linking \\'nex\\'\\n            // as the new next node after \\'prev\\'.\\n            prev->next = nex;\\n        }\\n\\n        // Return the modified linked list, starting from \\'temp->next\\'.\\n        return temp->next;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012514,
                "title": "video-solution-explanation-with-drawings-in-depth-java-c",
                "content": "# Intuition,approach, and complexity discussed in detail in video solution\\nhttps://youtu.be/OTgS22UDGSY\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummyHead = new ListNode(), *rangeHead = NULL, *prevNode = dummyHead, *currNode = head, *rangeTail = NULL, *rangeHeadPrev = prevNode; \\n        dummyHead->next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode->next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode* nextNode = currNode->next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode->next = (nodeNum != left) ? prevNode : NULL;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }   \\n        rangeHeadPrev->next = rangeTail;\\n        rangeHead->next = currNode;\\n        return dummyHead->next;\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode  dummyHead = new ListNode(),  rangeHead = null,  prevNode = dummyHead,  currNode = head,  rangeTail = null,  rangeHeadPrev = prevNode; \\n        dummyHead.next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode.next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode  nextNode = currNode.next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode.next = (nodeNum != left) ? prevNode : null;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }\\n        rangeHeadPrev.next = rangeTail;\\n        rangeHead.next = currNode;\\n        return dummyHead.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode *dummyHead = new ListNode(), *rangeHead = NULL, *prevNode = dummyHead, *currNode = head, *rangeTail = NULL, *rangeHeadPrev = prevNode; \\n        dummyHead->next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode->next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode* nextNode = currNode->next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode->next = (nodeNum != left) ? prevNode : NULL;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }   \\n        rangeHeadPrev->next = rangeTail;\\n        rangeHead->next = currNode;\\n        return dummyHead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        ListNode  dummyHead = new ListNode(),  rangeHead = null,  prevNode = dummyHead,  currNode = head,  rangeTail = null,  rangeHeadPrev = prevNode; \\n        dummyHead.next = head;\\n        int nodeNum = 1;\\n        for(; nodeNum<left; nodeNum++){\\n             prevNode = currNode;\\n             currNode = currNode.next;              \\n        }\\n        rangeHeadPrev = prevNode;\\n        for(; nodeNum<=right; nodeNum++){\\n             ListNode  nextNode = currNode.next;\\n             if(nodeNum == left)rangeHead = currNode;\\n             if(nodeNum == right)rangeTail = currNode;\\n             currNode.next = (nodeNum != left) ? prevNode : null;\\n             prevNode = currNode;\\n             currNode = nextNode;\\n        }\\n        rangeHeadPrev.next = rangeTail;\\n        rangeHead.next = currNode;\\n        return dummyHead.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012440,
                "title": "beats-100-with-proper-explanation-and-visualisation",
                "content": "\\n# Approach\\nSo firstly return ```null``` if ```head``` doesn\\'t exist.\\n\\n- Now , since we have to reverse the list from ```left to right``` we will first traverse till our ```left``` node, this we will do with the help of our ```prev``` Node, prev would point to the node before (previous) to our left node.\\n- So our ```current``` node would be prev->next.\\n- Create a ```next``` node pointing to ```null```, this will tell us which node to process next.\\n- Now for ```right- left times``` , i.e for the given number of nodes starting left, we reverse the linked list.\\n- This is done by \\n```\\nnext = current->next;\\ncurrent->next = next->next;\\nnext->next = prev->next;\\nprev->next = next;\\n```\\n# Refer to the image below for first test case\\n![image.png](https://assets.leetcode.com/users/images/9402f82d-73a5-4354-9d9e-095c23734f78_1694062838.3300138.png)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Handle the edge case of an empty list\\n    if (!head) return nullptr;\\n    \\n    // Create a dummy node to handle the case when left = 1\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    \\n    // Move to the node before the sublist\\n    ListNode* prev = dummy;\\n    for (int i = 0; i < left - 1; i++) {\\n        prev = prev->next;\\n    }\\n    \\n    // Start reversing the sublist\\n    ListNode* current = prev->next;\\n    ListNode* next = nullptr;\\n    \\n    for (int i = 0; i < right - left; i++) {\\n        next = current->next;\\n        current->next = next->next;\\n        next->next = prev->next;\\n        prev->next = next;\\n    }\\n    \\n    return dummy->next;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```null```\n```head```\n```left to right```\n```left```\n```prev```\n```current```\n```next```\n```null```\n```right- left times```\n```\\nnext = current->next;\\ncurrent->next = next->next;\\nnext->next = prev->next;\\nprev->next = next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        // Handle the edge case of an empty list\\n    if (!head) return nullptr;\\n    \\n    // Create a dummy node to handle the case when left = 1\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    \\n    // Move to the node before the sublist\\n    ListNode* prev = dummy;\\n    for (int i = 0; i < left - 1; i++) {\\n        prev = prev->next;\\n    }\\n    \\n    // Start reversing the sublist\\n    ListNode* current = prev->next;\\n    ListNode* next = nullptr;\\n    \\n    for (int i = 0; i < right - left; i++) {\\n        next = current->next;\\n        current->next = next->next;\\n        next->next = prev->next;\\n        prev->next = next;\\n    }\\n    \\n    return dummy->next;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012418,
                "title": "reverse-linked-list-ii-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* revList(ListNode* head){\\n        if(head==NULL || head->next==NULL) return head;\\n        ListNode* temp= revList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return temp;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right) return head;\\n        ListNode* prev=NULL;\\n        int l=1;\\n        ListNode* temp=head;\\n        while(l<left){\\n            prev=temp;\\n            temp=temp->next;\\n            l++;\\n        }\\n        int r=1;\\n        ListNode* temp2=head;\\n        while(r<right){\\n            temp2=temp2->next;\\n            r++;\\n        }\\n        ListNode* last=NULL;\\n        if(temp2->next){\\n            last=temp2->next;\\n            temp2->next=NULL;\\n        }\\n        if(prev){\\n            prev->next=revList(temp);\\n        }\\n        else{\\n            head=revList(temp);\\n        }\\n        temp->next=last;\\n        return head;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* revList(ListNode* head){\\n        if(head==NULL || head->next==NULL) return head;\\n        ListNode* temp= revList(head->next);\\n        head->next->next=head;\\n        head->next=NULL;\\n        return temp;\\n    }\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        if(left==right) return head;\\n        ListNode* prev=NULL;\\n        int l=1;\\n        ListNode* temp=head;\\n        while(l<left){\\n            prev=temp;\\n            temp=temp->next;\\n            l++;\\n        }\\n        int r=1;\\n        ListNode* temp2=head;\\n        while(r<right){\\n            temp2=temp2->next;\\n            r++;\\n        }\\n        ListNode* last=NULL;\\n        if(temp2->next){\\n            last=temp2->next;\\n            temp2->next=NULL;\\n        }\\n        if(prev){\\n            prev->next=revList(temp);\\n        }\\n        else{\\n            head=revList(temp);\\n        }\\n        temp->next=last;\\n        return head;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2047146,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1734854,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1979285,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1629491,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1988688,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1568918,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047099,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1573713,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047259,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1576002,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047146,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1734854,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1979285,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1629491,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1988688,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1568918,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047099,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1573713,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 2047259,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1576002,
                "content": [
                    {
                        "username": "ALS_Venky",
                        "content": "So, this is a Linked list week.\nBy the way, `Happy Janmastami :)`"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Hare Krishna \\u2764\\uFE0F\\n"
                    },
                    {
                        "username": "_ashish2001",
                        "content": "Jai Shree Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Happy Janmashtmi my fellow coderbro"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "Hare Krishna \\u2764\\uFE0F"
                    },
                    {
                        "username": "anubhav_0",
                        "content": "Hare Krishna\\u2764\\uFE0F"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "happy Janmastami \\u2764\\uFE0F"
                    },
                    {
                        "username": "BhavyaMPatel",
                        "content": "Happy Janmastami :)"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "What the hell? so the Left and Right are 1-based POSITIONs, not node.val?  who the hell uses 1-based positions."
                    },
                    {
                        "username": "andrewjunggg",
                        "content": "Understanding the problem is the hardest thing to do. Oh man, I didn\\'t read that left and right are just positions. \\uD83D\\uDE2D"
                    },
                    {
                        "username": "vardhan790harsh",
                        "content": "same, i was doing it that way only\\n"
                    },
                    {
                        "username": "vasche",
                        "content": "The first example they gave causes the confusion, agreed. Couldn\\'t they used different numbers? FML"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "P.s-I also thought it would be node.val \\uD83E\\uDD72\\n\\nIt\\'s their trick because a lot of us don\\'t read the given question see:-\\nGiven the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from ```position left to position right```, and return the reversed list.\\n\\nThey have used the word position so it would be index be it 0-based or 1-based \\nand not node.val \\uD83D\\uDE2D"
                    },
                    {
                        "username": "ImKumar",
                        "content": "After knowing this fact ( after passing 32 cases ) I was like f*** off and I stopped solving it further."
                    },
                    {
                        "username": "knotri",
                        "content": "First I was \"WTF\"\\nthen I add dummy node and now its became 0-based indexed\\nand now I am \"Aha, so this is why!\" "
                    },
                    {
                        "username": "pqow16",
                        "content": "This problem should explicitly state that it is 1-indexed"
                    },
                    {
                        "username": "rajharshyadav2",
                        "content": "What you can do here is:\nstep 1: create dummy node and put address of head int it next;\nstep2: find node  at place (left-1 and right);\nstep3:  reverse letft node to right node;\nstep4: put address of node at left->next in right->next && store head of reverse node(i.e right) address in next of node at (left-1) position;\nstep 5: if left is node at head then send dummy->next; else send head;"
                    },
                    {
                        "username": "adityacool001",
                        "content": "Apki bateii hameii samj nhi aayi"
                    },
                    {
                        "username": "sameer89",
                        "content": "Wasted so much time coding up the solution assuming that left and right are node values. Who would\\'ve guessed they are indices (with 1 based indexing btw). And to confuse you even more they have come up with the most ambiguous first test case."
                    },
                    {
                        "username": "zhizhipaint",
                        "content": "My submission failed for this test case, but unless I misunderstood the question, I think mine is actually the expected output?\\n\\nSubmission Result: Wrong Answer\\n\\nInput:\\t{1,2,3,4}, 1, 4\\nOutput:\\t{4,2,3,1}\\nExpected:\\t{4,3,2,1}"
                    },
                    {
                        "username": "Bhoomika_Rajani",
                        "content": "all the nodes between the left node and right node must be reversed, hence the expected output is {4,3,2,1}"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "?? doesn\\'t make any sense, you should revert 1, 2, 3 ,4 , first index 0 has value 1, fourth index 3 has value 4"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Done before! Resubmit! Like yesterday transverse the list .  Use a dummy ListNode makes programming easier. For example\n```\nListNode* dummy=new ListNode();\n```\n# Diagram for reversing linked list\n![reverseBet.png](https://assets.leetcode.com/users/images/7a7b6c79-5ebe-4a0f-a010-a4651936c676_1694085157.0015168.png)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) One pass is possible. Revise."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "It is possible in one pass only, no need to traverse the full linked list twice"
                    },
                    {
                        "username": "psionl0",
                        "content": "Likewise. I originally did this in May  I was able to do one small refinement before re-submitting."
                    },
                    {
                        "username": "phoe6",
                        "content": "Can someone suggest good videos, good resources, simulation or activies that can help to write revese of linked list?\\n\\nI seem to have completed 206 just 15 days ago, and I was drawing a blank today when I encountered this problem.\\n"
                    },
                    {
                        "username": "boney0310",
                        "content": "Try drawing what happens in every step of the algorithm. I find this especially helpful with problems involving linked lists. Once I had a visual representation of what the reverse list algorithm did in each step (for each node), I was amazed at how simple it was. It also helps recalling the algorithm later as that picture gets stuck in your mind. So even if you don\\'t recall the exact algo, you can still come up with it at the spot."
                    },
                    {
                        "username": "hristian00i",
                        "content": "Don\\'t worry I am in the same boat. It is just a weir concept. It helped me to simply draw out the algorithm on paper."
                    },
                    {
                        "username": "uzia35",
                        "content": "I think the first example is confusing people, it should probably have different numbers, left and right being numbers would make this question much harder if you had to account for duplicates with no constraints specifying so."
                    },
                    {
                        "username": "newtothis1562",
                        "content": "Got tripped while creating my own solution, as in first example the indexes and node values coincided. Had to look at solution to figure this out."
                    }
                ]
            },
            {
                "id": 1569164,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1575680,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047900,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047861,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047595,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047177,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2047101,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2019846,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1760998,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 1690795,
                "content": [
                    {
                        "username": "PremiumLab_",
                        "content": "In problem 206. Reverse Linked List, the node before the head is simply null, however in problem 92. Reverse Linked List II, the node before head is a dummy. Can anyone explain why do we use null in problem 206 while use dummy in problem 92???"
                    },
                    {
                        "username": "Ares2k",
                        "content": "[@godshiva](/godshiva) you can create a dummy node to point to the head of the linkedlist so it essentially becomes the new \\'head\\'."
                    },
                    {
                        "username": "godshiva",
                        "content": "How are you seeing the node before head?  This should not be visible in a singlely linked list."
                    },
                    {
                        "username": "namaaa",
                        "content": "![image](https://assets.leetcode.com/users/images/78a5e2ec-9c4a-40a6-b6c3-6e1721687b82_1629736919.8510926.png)\\n"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "here you use additional list"
                    },
                    {
                        "username": "leetcancode",
                        "content": "Few more test cases:\\n[1,2,3,4,5]\\n2\\n4\\n[5]\\n1\\n1\\n[1,2,3,4,5]\\n2\\n3\\n[1,2,3,4,5]\\n2\\n2\\n[1,2,3,4,5]\\n1\\n4\\n[1,2,3,4,5]\\n1\\n5\\n[1,2,3,4,5]\\n5\\n5\\n[1,2]\\n1\\n2"
                    },
                    {
                        "username": "s3stan",
                        "content": "Only when you get to test 28, where head = [1,2,3,4] and the expected answer Expected = [4,3,2,1] do you understand that you need to swap not two elements, but flip the list starting from the Left position to Right position"
                    },
                    {
                        "username": "rishu00007",
                        "content": "Feeling like Baldev \"the destroyer of linked list nodes\"!!"
                    },
                    {
                        "username": "MushyBear",
                        "content": "Who writes these discriptions and examples? The left and right are indices, not node.vals... wouldve been great to know before wasting my time."
                    },
                    {
                        "username": "bbbbeetroot",
                        "content": "three linked list question on a row. I\\'m the master of linked list now!"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "Why the hell Leetcode  testcases are misleading always and this time question too , who gonna tell me that it is 1 indexed question"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "ManasT4",
                        "content": "stop spamming bro"
                    },
                    {
                        "username": "mahendra_p_s_dhakad",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* newlist=new ListNode(0);\\n        ListNode* pre=newlist;\\n        ListNode* curr;\\n        newlist->next=head;\\n        for(int i=0; i<left-1; i++)\\n        {\\n            pre=pre->next;\\n        }\\n        curr=pre->next;\\n        for(int i=0; i<right-left; i++)\\n        {\\n            ListNode *temp=pre->next;\\n            pre->next=curr->next;\\n            curr->next=curr->next->next;\\n            pre->next->next=temp;\\n        }\\n        return newlist->next;\\n    }\\n\\n};"
                    }
                ]
            },
            {
                "id": 2075985,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2066868,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048296,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048275,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048183,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048180,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048102,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2048066,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047942,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047923,
                "content": [
                    {
                        "username": "ajahmed",
                        "content": "@leetcode please explicitly state this is 1-based indexing. "
                    },
                    {
                        "username": "Priyanshu_srivastava__",
                        "content": "bhai solution bhej do koi gand phat gya hai\\n"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Le bhai :\\npublic ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(left==right){\\n            return head;\\n        }\\n        int i=1;\\n        ListNode prev=null;\\n        ListNode temp=head;\\n        while(i<left){\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        //prev=1\\n        ListNode tail=temp; //tail=2\\n        ListNode dummy=null;\\n        for(;temp!=null && i<=right;i++){\\n            ListNode after=temp.next;\\n            temp.next=dummy;\\n            dummy=temp;\\n            temp=after;\\n        }\\n        tail.next=temp;\\n        if(prev!=null){\\n            prev.next=dummy;\\n        }\\n        else{\\n            head=dummy;\\n        }\\n        return head;\\n    }"
                    },
                    {
                        "username": "narayan1281",
                        "content": "Try thinking in terms of parts: (Ideation for single pass solution)\\nThe original linked list will be divided into three parts\\nFirst        -----     Second       ------ Third\\n\\n-------------------------------- Hints ----------------------------------\\n-> we need to reverse \"Second\" part only.\\n-> end pointer of \"First\" part should point to new start of Second pointer\\n-> and similar modification required for \"Third\"\\n-> special attention required when \"First == NULL\""
                    },
                    {
                        "username": "1234567812345678",
                        "content": "The question is misleading, so not a good problem to solve imo. \\nAs for the difficulty, as a medium level question, I felt this is too easy. "
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "can\\'t we do like create new list from left to right and reverse that list now iterating original list and updating the corresponding values ? surprisingly it\\'s shows 62% beats in memory "
                    },
                    {
                        "username": "mpavlov99",
                        "content": "Does anyone have good explanation over this problem ? "
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Is it cheating to use ArrayList to save the ListNode, and then swap the elements in list based on the index."
                    },
                    {
                        "username": "RosyMaple",
                        "content": "No, its never cheating to use other data structures to help with an operation. \\n\\nsometimes they limit the memory to stop you form doing this but i believe that using another data structure is part of the optimal solution for this one"
                    },
                    {
                        "username": "julia-rodrigo",
                        "content": "Hi, I don\\'t work with linkList at all, so I cannot find the docs for any functions of the LinkedList in javascript. I am trying to find ways to at least get a pop() or get an element in a certain position. :) Thanks."
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t use JS as a rule but I have implemented a SList class in JS just for the exercise. It is pretty concise and easy to read. I can upload the file for you if you provide me with an address."
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n   static ListNode LLatpoint(ListNode head , int n){\\n        for(int i=1;i<n;i++){\\n            if(head==null){\\n                break;\\n            }\\n            head=head.next;\\n        }\\n        return head;\\n  }\\n\\n  static ListNode rev(ListNode head , int n){\\n        ListNode ans = LLatpoint(head,n);\\n        ListNode tempans=ans;\\n        n--;\\n        while(n>0){\\n            ListNode nextans=LLatpoint(head,n);\\n            tempans.next=nextans;\\n            tempans= tempans.next;\\n            n--;\\n        }\\n        tempans.next=null;\\n        return ans;\\n  }\\n   static int count(ListNode head){\\n        int ans=0;\\n        while(head!=null){\\n            head=head.next;\\n            ans++;\\n        }\\n        return ans;\\n  }\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n       if(left==1){\\n            if(right==count(head)){\\n                return rev(head,right-left+1);\\n            }\\n            ListNode next = LLatpoint(head,right+1);\\n            ListNode ans = rev(head,right-left+1);\\n            head.next=next;\\n            return ans;\\n        }\\n        ListNode ans = head;\\n        ListNode strt = LLatpoint(head,left-1);\\n        if(right==count(head)){\\n            strt.next=rev(LLatpoint(head,left),right-left+1);\\n            return ans;\\n        }\\n        ListNode end = LLatpoint(head,right+1);\\n        ListNode newend=LLatpoint(head,left);\\n        ListNode rev = rev(LLatpoint(head,left),right-left+1);\\n        strt.next=rev;\\n        newend.next=end;\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "minizminh",
                        "content": "Happy LinkedList week "
                    }
                ]
            },
            {
                "id": 2047891,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047858,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047852,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047809,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047780,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047770,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047755,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047733,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047651,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047612,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "By the way, this is how the condition of problem 24 is presented. And immediately everything is clear and understandable.\\n24. Swap Nodes in Pairs\\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values \\u200B\\u200Bin the list\\'s nodes (i.e., only nodes themselves may be changed.)"
                    },
                    {
                        "username": "19121a1216",
                        "content": "can you guys tell me why the dummy node is required here?\n  tell me guys\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "You don\\'t need a dummy node but then you have to code for the edge case where the head node is part of the sublist that needs to be reversed."
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "Code\\n```\\nhead->next = head;\\nreturn head;\\n```\\nruins the Matrix.\\n"
                    },
                    {
                        "username": "Gauravgeekp",
                        "content": "\"A break is needed to disengage from the fixation of the ineffective solution\"."
                    },
                    {
                        "username": "hanse413",
                        "content": "The question isn\\'t stated clearly. For anyone wondering, the left and right integers are indices not values. they are 1 indexed. "
                    },
                    {
                        "username": "hanse413",
                        "content": "is left and right integer indeices or value of that Node. "
                    },
                    {
                        "username": "NeedleFung",
                        "content": "I used recursion, beat 100% at the first try with C++, but space complexity is so ugly :))"
                    },
                    {
                        "username": "Bilal_Rizvi",
                        "content": "Linked List Again!!!!!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Don\\'t worry if your runtime is low, just submit the same solution again you\\'ll see a better runtime, slow runtime is often due to server congestion at that moment\\n[drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/?envType=daily-question&envId=2023-09-07)"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Happy Janmashtami! \\uD83C\\uDF89\\n\\nBefore diving into this post, let\\'s keep things simple and effective. If complex pointer solutions aren\\'t coming to mind, that\\'s perfectly okay. Sometimes, a straightforward approach can work wonders. So, why not take a bit of extra space to store the values of the nodes?\\n\\nHere\\'s what I did: I collected all the node values into a vector. Then, with the built-in reverse function, I effortlessly reversed this vector from left to right. Finally, it\\'s just a matter of populating a linked list with the values from the vector. It\\'s that straightforward! \\uD83D\\uDD04\\n\\nThis way, you\\'ve achieved your goal without wrestling with complex pointers. Happy coding! \\uD83D\\uDE0A"
                    }
                ]
            },
            {
                "id": 2047573,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047535,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047516,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047468,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047465,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047436,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047415,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047404,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047336,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047334,
                "content": [
                    {
                        "username": "munu8998rai",
                        "content": "I understood the question but I am able to code!Is it  Normal?"
                    },
                    {
                        "username": "RosyMaple",
                        "content": "Anyone else getting Out of memory. errors when attempting the 2 pointer stack approach in c#?"
                    },
                    {
                        "username": "KingShuK17",
                        "content": "```Jai Shree Krishnaa my friends!```"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "Leetcode be like: Linked List go brrrrrr..."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "`dummy = ListNode(0,head)`\\nwhat does this line mean?"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "Did I do it wrong if I only changed the order of the values of the nodes and not the nodes themselves? The submission got accepted, but after reading the solutions I am not sure wether I solved it correctly.  "
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "Another linked list!!!"
                    },
                    {
                        "username": "user8272RT",
                        "content": "I usually do Linked List problems with recursion. Had to look up an iterative solution for this one."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "this question is bit irritating because of one index add a node at front now it\\'s trivial"
                    },
                    {
                        "username": "wafsinc",
                        "content": "The edge case left=1 can be a bit annoying. You can avoid solving it separately by adding a dummy node before head, call it say aux, and then returning aux.next."
                    }
                ]
            },
            {
                "id": 2047326,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047209,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047198,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047188,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047179,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047178,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047154,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047133,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2047106,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 2039661,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "solved [here with explanation and drawing](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012440/beats-100-with-proper-explanation-and-visualisation/) too"
                    },
                    {
                        "username": "AthulKkumar",
                        "content": "I write an code and run it but its show this kind of error :\\nTypeError: [1, 4, 3, 2, 5] is not valid value for the expected return type ListNode\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type ListNode\");\\nLine 70 in _driver (Solution.py)\\n    _driver()\\nLine 76 in <module> (Solution.py)"
                    },
                    {
                        "username": "ayushxsharma",
                        "content": "Leetcode trying to link our programming skills with Linked List week :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "anyone else miss the left = 1 edge case at first?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "*reversing linked list is always been famous*"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This\\'s a good follow-up from [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)."
                    },
                    {
                        "username": "psionl0",
                        "content": "If you know how to reverse a linked list then one option is to \"lift out\" the sublist from left to right, make sure that the right node points to NULL, reverse the sublist then \"glue\" it back into the original list. Of course you will need 2 extra pointers: one at the end of the first left - 1 nodes, and one at the start of the right+1 node;"
                    },
                    {
                        "username": "Anurag_mishra_08",
                        "content": "Okay so it\\'s Linked List week : )"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "I am dealing with a very strange bug where my for-loop apparently resets i\\'s value for no apparent reason. If anyone can see a reason for this in my code please let me know... I\\'m kinda puzzled.\\nCode:\\n ``` public ListNode ReverseBetween(ListNode head, int left, int right) {\\n        int ind = 1;\\n        ListNode[] nodes = new ListNode[1 + (right + 1 - (left - 1))];\\n        var trav = head;\\n        while (trav != null && ind <= right + 1){\\n            if (ind >= left - 1){\\n                nodes[ind - 1] = trav;\\n            }\\n            ind++;\\n            trav = trav.next;\\n        }\\n        for (int i = 0; i < nodes.Length; i++){\\n            Console.WriteLine(\"I is {0}\", i);\\n            Console.WriteLine(\"Currently on node number {0}\", i + 1);\\n            Console.WriteLine(\"Node val is {0}\", nodes[i].val);\\n        }\\n        \\n        return head;\\n    }\\n```\\n\\nHere\\'s what that outputs for the first testcase:\\nI is 0\\nCurrently on node number 1\\nNode val is 1\\nI is 1\\nCurrently on node number 2\\nNode val is 2\\nI is 2\\nCurrently on node number 3\\nNode val is 3\\nI is 3\\nCurrently on node number 4\\nNode val is 4\\nI is 4\\nCurrently on node number 5\\nNode val is 5\\nI is 0\\nCurrently on node number 1\\nNode val is 5\\nI is 1\\nCurrently on node number 2\\n\\nSee how once it went through 0 - 4 it resets back to 0 again? Wtf is that about?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "[@kylecrowley](/kylecrowley) Thank you! You are completely right, it was another test case that was making it look wonky. I appreciate the insight."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Printing to the console in LC can be a little odd, and it seems like that\\'s what is happening here. It\\'s printing the output for the first test case (1->2->3->4->5), then printing the output for the second test case (5->2, seems like you modified this one from the example test case).\\n\\nYou may have to work with one test case at a time to get the proper output."
                    },
                    {
                        "username": "rotem250297",
                        "content": "can i run over the values? (using swap with the values instead with the nodes)"
                    },
                    {
                        "username": "Coder_Rookie08",
                        "content": "you can but interviewer will not be happy with this step, generally in LinkedList it is recommended that you should swap nodes not the data "
                    }
                ]
            },
            {
                "id": 1985697,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1945128,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1940209,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1922705,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1865106,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1848014,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1810623,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1781985,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1773687,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            },
            {
                "id": 1757416,
                "content": [
                    {
                        "username": "dev_bhalodia",
                        "content": "Very similar to reverse nodes in k-group."
                    },
                    {
                        "username": "sonivinayak716",
                        "content": "`I want help i used to traverse the linked list throught temp what ia have done is i have traversed with  while(left>1) so that i reach the left location along with reducing right to right--. now i am confused that why my code isnt giving  me the reversed output i have used stack data structure to store the values between left and right. please help me based on my code\\n\\nListNode* reverseBetween(ListNode* head, int left, int right) \\n    {\\n        ListNode*temp=head;\\n        stack <int>s;\\n        int r2=right;\\n        int l2=left;\\n        if(head->next)return head;\\n        \\n        while(left>1)\\n        {\\n            temp=temp->next;\\n            left--;\\n            right--;\\n        }\\n        while(right>=1)\\n        {\\n            s.push(temp->val);\\n            temp=temp->next;\\n            right--;\\n        }\\n        temp=head;\\n        while(l2>1)\\n        {\\n            temp=temp->next;\\n            l2--;\\n            r2--;\\n        }\\n        while(r2>=1)\\n        {\\n            temp->val=s.top();\\n            s.pop();\\n            r2--;\\n            temp=temp->next;\\n        }\\n        return head;\\n\\n    }\\n"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "i dont know why but my mind freezes coz of the edgecases...is there any solution to that..\\n"
                    },
                    {
                        "username": "user4796V",
                        "content": "For questions like these my approach is to first forget about all the possible edge cases and just concider the most generic input,\\nafter i come up with a solution for that then i test my algorithm with the most extreme edge cases, if it fails then i try to correct it while keeping it valid for the generic input"
                    },
                    {
                        "username": "rajveer_09",
                        "content": "This question first seems easy but soon you realize its not that easy because these pointers are going to mess up a lot than normal reverse linked list."
                    },
                    {
                        "username": "AbirDey",
                        "content": "Can someone explain why my code works for odd reverse list and doesn\\'t for even linked-list\\n\\nThe approach is simply, calling the main function recursively and replacing two nodes at each recursion and simply changing the pointers to the next two nodes and feeding it to the function for the next recursion.\\n\\nPlease help\\n\\n \\n\\n`your inline code...\\n\\n\\n        \\n        \\n        while(right - left >= 0){\\n            \\n            ListNode leftcurr = head;\\n            ListNode rightcurr = head;\\n            int leftmove = left;\\n            int rightmove = right;\\n            \\n            while(leftmove > 1){\\n                leftmove = leftmove - 1;\\n                leftcurr = leftcurr.next;\\n            }\\n            \\n            while(rightmove > 1){\\n                rightmove = rightmove - 1;\\n                rightcurr  = rightcurr.next;\\n            }\\n            int temp = leftcurr.val;\\n            leftcurr.val = rightcurr.val;\\n            rightcurr.val = temp;\\n            left = left+1;\\n            right = right-1;\\n            reverseBetween(head,left,right);\\n        }\\n\\n        return head;\\n    }\\n\\n\\nyour inline code...`"
                    },
                    {
                        "username": "shivam20_",
                        "content": "Java easy solution\\nclass Solution {\\n    public ListNode reverseBetween(ListNode head, int left, int right) {\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode prev=null;\\n        ListNode current=head;\\n        while(left>1){\\n            prev=current;\\n            current=current.next;\\n            left--;\\n            right--;\\n        }\\n        ListNode connection=prev;\\n        ListNode tail=current;\\n        while(right>0){\\n            ListNode temp=current.next;\\n            current.next=prev;\\n            prev=current;\\n            current=temp;\\n            right--;\\n        }\\n        if(connection!=null){\\n            connection.next=prev;\\n        }else{\\n            head=prev;\\n        }\\n        tail.next=current;\\n        return head;\\n    }\\n}"
                    },
                    {
                        "username": "ankit0987",
                        "content": "how to select from left to right part of linked list to reverse"
                    },
                    {
                        "username": "devasahu2003",
                        "content": "class Solution {\\npublic:\\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\\n        ListNode* l1=head;\\n        // int arr[right-left+1];\\n\\n        ListNode* l2=head;\\n        if(l1->next==NULL  && l2->next==NULL)\\n            return head;\\n        int r=right,l=left-1;\\n        vector<int>v;\\n        while(l1)\\n        {\\n            int x= l1->val;\\n            v.push_back(x);\\n            l1=l1->next;\\n        }\\n        reverse(v.begin()+l,v.begin()+r);\\n        int i=0;\\n        while(l2)\\n        {\\n            l2->val=v[i];\\n            l2=l2->next;\\n            i++;\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/92_reverse_linked_list_2.cpp"
                    },
                    {
                        "username": "egoriy",
                        "content": "Could somebody explain me why it ended up in infinite cycle?\ninput [1,2,3,4,5] -> output [1,4,3,2,5,5,5,5,5,5,5,5,5.........\n\ncheck the comments in source code\n `\nclass Solution {\n    func reverseBetween(_ head: ListNode?, _ left: Int, _ right: Int) -> ListNode? {\n        // find the left pointer\n        var leftNode = head\n        var leftPrev = head\n        for _ in 1..<left {\n            leftPrev = leftNode \n            leftNode = leftNode?.next\n        }\n       \n        //find the right pointer\n        var rightNode = head\n        var rightCount = 1\n        while rightNode?.next != nil && rightCount <= right {\n            rightNode = rightNode?.next\n            rightCount += 1\n        }\n\n        //reverse\n        var current = leftNode\n        var prev: ListNode? = rightNode // if I put nil here it doesn't go into infinite loop but the answer is wrong, since right part is missing\n        while current != nil && current !== rightNode {\n            let next = current?.next\n            current?.next = prev\n            prev = current\n            current = next\n        }\n        leftPrev?.next = prev\n        \n        return head\n    }\n}\n`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Frequency",
        "question_content": "<p>Write a bash script to calculate the <span data-keyword=\"frequency-textfile\">frequency</span> of each word in a text file <code>words.txt</code>.</p>\n\n<p>For simplicity sake, you may assume:</p>\n\n<ul>\n\t<li><code>words.txt</code> contains only lowercase characters and space <code>&#39; &#39;</code> characters.</li>\n\t<li>Each word must consist of lowercase characters only.</li>\n\t<li>Words are separated by one or more whitespace characters.</li>\n</ul>\n\n<p><strong class=\"example\">Example:</strong></p>\n\n<p>Assume that <code>words.txt</code> has the following content:</p>\n\n<pre>\nthe day is sunny the the\nthe sunny is is\n</pre>\n\n<p>Your script should output the following, sorted by descending frequency:</p>\n\n<pre>\nthe 4\nis 3\nsunny 2\nday 1\n</pre>\n\n<p><b>Note:</b></p>\n\n<ul>\n\t<li>Don&#39;t worry about handling ties, it is guaranteed that each word&#39;s frequency count is unique.</li>\n\t<li>Could you write it in one-line using <a href=\"http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-4.html\">Unix pipes</a>?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 55443,
                "title": "my-simple-solution-one-line-with-pipe",
                "content": "```\\ncat words.txt | tr -s ' ' '\\\\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'\\n```\\n\\n**tr -s**: truncate the string with target string, but only remaining one instance (e.g. multiple whitespaces)\\n\\n**sort**: To make the same string successive so that `uniq` could count the same string fully and correctly.\\n\\n**uniq -c**: uniq is used to filter out the repeated lines which are successive, -c means counting\\n\\n**sort -r**: -r means sorting in descending order\\n\\n**awk '{ print $2, $1 }'**: To format the output, see [here][1].\\n\\n\\n  [1]: http://linux.cn/article-3945-1.html",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s ' ' '\\\\n' | sort | uniq -c | sort -r | awk '{ print $2, $1 }'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 849332,
                "title": "one-line-with-pipe-with-explanation",
                "content": "**One Line Solution**\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```\\n**Explanation :**\\n\\nAs per the problem we need to read `words.txt` file and then process it. To practice it by hand, let\\'s create a `words.txt` file giving our test strings.\\n\\n*creating words.txt file*\\n```\\necho \\'the day is sunny the the\\nthe sunny is is\\' > words.txt\\n```\\n\\nNow, we can see what is the output we are getting from each command joined by pipes\\n\\n**cat words.txt**\\nOutputs the content in the file in the standard output\\n```\\n\\u279C  ~ cat words.txt\\nthe day is sunny the the\\nthe sunny is is\\n```\\n\\n**tr -s \\' \\' \\'\\\\n\\'**\\n*tr -s*  uses for truncating the input as per given command followed by it. In our case, we are interested in truncating each whitespace( \\'  \\') and replace it with newline(\\'\\\\n\\') as shown below:\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n```\\n**sort**\\nThis sort the input in `ascending` order so that `uniq` can find duplicate words adjacently (order does not matter for uniq) as shown below:\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n```\\n**uniq --count**\\nThis command provides word frequency as \"count  word\" format.\\nFilter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\nNote: \\'uniq\\' does not detect repeated lines unless they are adjacent.\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n```\\n\\n**sort -r**\\n`sort -r` sorts the input in descending order.\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n```\\n**awk \\'{print $2 \" \" $1}**\\n`awk` formats the input given for each line. In our example, we want the second column ($2) appears first and the first column ($1) appears second separated by whitespace(\" \")\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```\\n*Feel free to provide feedback. *",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```\n```\\necho \\'the day is sunny the the\\nthe sunny is is\\' > words.txt\\n```\n```\\n\\u279C  ~ cat words.txt\\nthe day is sunny the the\\nthe sunny is is\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n```\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535836,
                "title": "fully-explained-100-faster-new-edge-case",
                "content": "```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\\n\\n```tr -s```  **translate, squeeze+replace:** replaces [tab, newline, vertical tab, form feed, carriage return, and space] i.e., *space characters* ```[:space:]``` with a newline ```\\\\n```.\\n```sort``` **sort:** sorts alphabetically (ascending order)\\n```uniq -c``` **unique, count:** prints after omitting repeating adjacent lines ```uniq``` along with number of occurrences ```-c```\\n```sort -nr -k 1``` **sort, numeric+reverse, key:** sorts numerically  and in reverse ```-nr``` based on the key - first column ```-k 1```\\n```awk \\'{print $2 $1}\\'``` **awk - split line into fields** splitting each line into specified fields (word first and then frequency). You can find more info on ```awk``` [here](https://www.***.org/awk-command-unixlinux-examples/).\\n\\n***EDGE CASE:***\\n\\nIn case there are **punctuations** in the text:\\n\\n```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | tr -d [:punct:] | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\\n\\n```tr -d```  **translate, delete:** deletes any [! \\u201D # $ % & \\u2018 ( ) * + , \\u2013 . / : ; < = > ? @ [ \\\\ ] ^ _ \\\\` { | } ~. ] i.e., *punctuation characters*  `[:punct:]`\\n\\n---------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------\\n---------------------------------------------------------------------------------------------------\\n\\n**A shameless plug:**\\nI do enjoy writing detailed explanations of solutions, but I too (like you probably are) am looking for a job right now and am a little short on time. \\nSo, **please give this solution an upvote** if you would like to see more of these for other problems. Thanks! :)\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\n```tr -s```\n```[:space:]```\n```\\\\n```\n```sort```\n```uniq -c```\n```uniq```\n```-c```\n```sort -nr -k 1```\n```-nr```\n```-k 1```\n```awk \\'{print $2 $1}\\'```\n```awk```\n```\\ncat words.txt | tr -s [:blank:] \\'\\\\n\\' | tr -d [:punct:] | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2, $1}\\'\\n```\n```tr -d```",
                "codeTag": "Unknown"
            },
            {
                "id": 55462,
                "title": "solution-using-awk-and-pipes-with-explaination",
                "content": "\\n1. I should count the words. So I chose the `awk` command.\\n  - I use a dictionary in `awk`. For every line I count every word in the dictionary.\\n  - After deal with all lines. At the `END`, use `for (item in Dict) { #do someting# } ` to print every words and its frequency.\\n2. Now the printed words are unsorted. Then I use a `|` pipes and sort it by `sort`\\n  - `sort -n` means \"compare according to string numerical value\".\\n  - `sort -r` means \"reverse the result of comparisons\".\\n  - `sort -k 2` means \"sort by the second word\"\\n\\n---\\n\\n\\n    awk '\\\\\\n    { for (i=1; i<=NF; i++) { ++D[$i]; } }\\\\\\n    END { for (i in D) { print i, D[i] } }\\\\\\n    ' words.txt | sort -nr -k 2\\n\\n---\\n\\nAre there any other solutions without `awk`?  \\nSuch as using `sed` or `grep`.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\n1. I should count the words. So I chose the `awk` command.\\n  - I use a dictionary in `awk`. For every line I count every word in the dictionary.\\n  - After deal with all lines. At the `END`, use `for (item in Dict) { #do someting# } ` to print every words and its frequency.\\n2. Now the printed words are unsorted. Then I use a `|` pipes and sort it by `sort`\\n  - `sort -n` means \"compare according to string numerical value\".\\n  - `sort -r` means \"reverse the result of comparisons\".\\n  - `sort -k 2` means \"sort by the second word\"\\n\\n---\\n\\n\\n    awk '\\\\\\n    { for (i=1; i<=NF; i++) { ++D[$i]; } }\\\\\\n    END { for (i in D) { print i, D[i] } }\\\\\\n    ' words.txt | sort -nr -k 2\\n\\n---\\n\\nAre there any other solutions without `awk`?  \\nSuch as using `sed` or `grep`.",
                "codeTag": "Unknown"
            },
            {
                "id": 2621959,
                "title": "shell-explained-easy-to-understand",
                "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'`\\nExplanation :\\n`tr -s \\' \\' \\'\\\\n\\'`\\n**tr -s** uses for truncating the input as per given command followed by it. In our case, we are interested in truncating each whitespace( \\' \\') and replace it with newline(\\'\\\\n\\') as shown below:\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\'` will look like this -\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\n`sort`\\nThis sort the input in ascending order so that uniq can find duplicate words adjacently (order does not matter for uniq) as shown below:\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort`\\nday\\nis\\nis\\nis\\nsunny\\nsunny\\nthe\\nthe\\nthe\\nthe\\n`uniq --count`\\nThis command provides word frequency as \"count word\" format.\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count`\\n      1 day\\n      3 is\\n      2 sunny\\n      4 the\\n`sort -r`\\nsort -r sorts the input in descending order.\\n`\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r`\\n      4 the\\n      3 is\\n      2 sunny\\n      1 day\\n`awk \\'{print $2 \" \" $1}`\\nawk formats the input given for each line. In our example, we want the second column ($2) appears first and the first column ($1) appears second separated by whitespace(\" \")\\n\\n```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "solutionTags": [],
                "code": "```\\n\\u279C  ~ cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\nthe 4\\nis 3\\nsunny 2\\nday 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1559560,
                "title": "bash-192-word-frequency-one-line-0ms-beats-100-sed-sort-uniq-awk",
                "content": "```bash\\nsed -e \\'s/ /\\\\n/g\\' words.txt | sed -e \\'/^$/d\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n### Explanation\\n`sed -e \\'s/ /\\\\n/g\\' word.txt` - converts spaces to newlines to give us one word per line\\n`sed -e \\'/^$/d\\'` - deletes blank lines\\n`sort` - sorts the word alphabetically (this is needed for `uniq -c` to work)\\n`uniq -c` - outputs each word *preceded* by the frequency count\\n`sort -r` - sorts in decreasing frequency order\\n`awk \\'{ print $2\" \"$1}\\'` - swaps the column order to match the question\\'s requirements.\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```bash\\nsed -e \\'s/ /\\\\n/g\\' words.txt | sed -e \\'/^$/d\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3218865,
                "title": "192-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nExplanation:\\n\\n- cat words.txt reads the contents of the file\\n- tr -s \\' \\' \\'\\\\n\\' replaces all spaces with newlines to separate each word into its own line\\n- sort sorts the words in alphabetical order\\n- uniq -c counts the frequency of each unique word\\n- sort -rn sorts the words in descending order of frequency\\n- awk \\'{print $2 \" \" $1}\\' prints the output in the desired format of \"word count\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559512,
                "title": "bash-two-solutions-command-script",
                "content": "Method 1 - piping commands (4ms)\\n```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```\\n\\nMethod 2 - associative array in bash script (16ms) \\n```\\ndeclare -A arr #associative array\\n\\nwhile IFS= read -r line\\ndo\\n    for word in $line\\n    do\\n        let arr[$word]=${arr[$word]}+1\\n    done\\ndone < words.txt\\n\\nfor key in ${!arr[@]}\\ndo\\n    echo $key ${arr[$key]}\\ndone | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```\n```\\ndeclare -A arr #associative array\\n\\nwhile IFS= read -r line\\ndo\\n    for word in $line\\n    do\\n        let arr[$word]=${arr[$word]}+1\\n    done\\ndone < words.txt\\n\\nfor key in ${!arr[@]}\\ndo\\n    echo $key ${arr[$key]}\\ndone | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395274,
                "title": "using-cat-tr-sed-sort-uniq-and-awk",
                "content": "```bash\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sed \\'/^$/d\\' -  | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```\\n\\nFor example, consider the words.txt file to consist:\\n```\\na b b c c c c c\\n```\\n\\n1. `cat words.txt` : writes the content of the file `words.txt` onto standard output.\\n2. `tr \\' \\' \\'\\\\n\\'` : converts whitespaces to newlines.\\n3. `sed \\'/^$/d\\'`: removes any empty words.\\n4. `sort`: sort the words\\n5. `uniq -c`: gives the unique words an its count\\n\\nExample output of commands till now.\\n```\\n\\t1 a\\n\\t2 b\\n\\t5 c\\n```\\n\\n6. `sort -nr`: sort the output considering numerical and in descending order.\\nEx, output:\\n```\\n\\t5 c\\n\\t2 b\\n\\t1 a\\n```\\n\\n7. `awk \\'{print $1 \" \" $2}\\'`: print the word first and then the count, also removes the initial whitespaces\\n\\nFinal output: \\n```\\nc 5\\nb 2\\n1 a\\n```\\n\\nI enjoy using the pipelines, and multiple utilities, where each does it own work perfectly!",
                "solutionTags": [],
                "code": "```bash\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sed \\'/^$/d\\' -  | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```\n```\\na b b c c c c c\\n```\n```\\n\\t1 a\\n\\t2 b\\n\\t5 c\\n```\n```\\n\\t5 c\\n\\t2 b\\n\\t1 a\\n```\n```\\nc 5\\nb 2\\n1 a\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55472,
                "title": "share-my-accepted-solution-using-awk-and-sort",
                "content": "    cat words.txt | awk '{for(i=1;i<=NF;++i){count[$i]++}} END{for(i in count) {print i,count[i]}}' | sort -k2nr",
                "solutionTags": [],
                "code": "    cat words.txt | awk '{for(i=1;i<=NF;++i){count[$i]++}} END{for(i in count) {print i,count[i]}}' | sort -k2nr",
                "codeTag": "Unknown"
            },
            {
                "id": 862661,
                "title": "did-this-four-ways-fastest-was-gawk-with-built-in-sort-0ms",
                "content": "My first solution was essentially the same as a bunch of people, pipeline using tr and sort -nr, 4 ms runtime, 3.3MB memory footprint.\\n\\nNext up I figured I would dust off awk, but I still piped it to sort -k2 -nr, and the speed and footprint result was the same of the first solve.\\n\\nThe third result was sort of surprising...  I did it this time using a bash-native associative array. I thought this would be faster, but it ended up being 12 ms runtime, but 3.0 memory footprint (100th percentile). I probably read the file and words in inefficiently.\\n\\nFinally, I ended up looking at the gawk manual and found that it has a pretty sweet extension for built in array sorting, which led to a 0 ms runtime and 3.3 mb footprint, here it is:\\n\\n```\\ngawk -F\\' \\' \\'BEGIN {PROCINFO[\"sorted_in\"]=\"@val_num_desc\"} {for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```\\ngawk -F\\' \\' \\'BEGIN {PROCINFO[\"sorted_in\"]=\"@val_num_desc\"} {for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197037,
                "title": "1-line-solution",
                "content": "```\\ncat words.txt | tr [:space:] \"\\\\n\" | sed \\'/^$/d\\' | tr \\'[:upper:]\\' \\'[:lower:]\\'|sort|uniq -c|sort -nr| awk \\'{print $2\" \"$1}\\'\\n```\\n\\n* cat: open content\\n* tr: replace all space with newline ( all words will be as one line )\\n* tr: convert all to lowercase\\n* sort: sort alpha\\n* uniq: count word\\n* sort: sort with reverse order\\n* awk: print by format we want",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr [:space:] \"\\\\n\" | sed \\'/^$/d\\' | tr \\'[:upper:]\\' \\'[:lower:]\\'|sort|uniq -c|sort -nr| awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693026,
                "title": "pipe-solution-single-line",
                "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'`",
                "solutionTags": [],
                "code": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 185847,
                "title": "bash-solution-one-small-line",
                "content": "```\\ncat words.txt | tr -s \\' \\' \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```\\n\\nVery concise and tiny solution, extra good and very small. I love it.",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256787,
                "title": "simple-solution-grep-sort-uniq-awk",
                "content": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997540,
                "title": "one-line-python-horror-solution",
                "content": "# Why learn how to use bash when you can just write Python?\\n***Runtime: 290 ms, faster than 5.16% of Bash online submissions for Word Frequency.\\nMemory Usage: 9.6 MB, less than 37.52% of Bash online submissions for Word Frequency.***\\n\\nI used the Python exec() function to parse through my code written as a string and used here-string (<<<) to send everything to python3.exe in bash\\n```\\npython3 <<< \\'exec(\"import re\\\\na=open(\\\\\"words.txt\\\\\")\\\\nb=a.read().strip()\\\\na.close();z=b.split(\\\\\"\\\\\\\\n\\\\\");y=\\\\\" \\\\\".join(z)\\\\nc=re.split(r\\\\\"\\\\s+\\\\\",y);d=dict()\\\\nfor w in c:x=d.get(w,0);d[w]=x+1\\\\nout=[(w[1],w[0]) for w in list(d.items())];out.sort(reverse=True)\\\\nfor o in out:print(o[1],o[0])\")\\'\\n```\\n\\nMy (human-readable) solution is:\\n```\\nimport re\\na = open(\"words.txt\")\\nb = a.read().strip()\\na.close()\\nz = b.split(\"\\\\n\")\\ny=\" \".join(z)\\n# I used regex to split on any whitespace bc I failed a test case\\nc=re.split(r\"\\\\s+\", y)\\nd=dict()\\nfor w in c:\\n\\tx=d.get(w,0)\\n\\td[w]=x+1\\nout=[(w[1],w[0]) for w in list(d.items())]\\nout.sort(reverse=True)\\nfor o in out:\\n\\tprint(o[1],o[0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\npython3 <<< \\'exec(\"import re\\\\na=open(\\\\\"words.txt\\\\\")\\\\nb=a.read().strip()\\\\na.close();z=b.split(\\\\\"\\\\\\\\n\\\\\");y=\\\\\" \\\\\".join(z)\\\\nc=re.split(r\\\\\"\\\\s+\\\\\",y);d=dict()\\\\nfor w in c:x=d.get(w,0);d[w]=x+1\\\\nout=[(w[1],w[0]) for w in list(d.items())];out.sort(reverse=True)\\\\nfor o in out:print(o[1],o[0])\")\\'\\n```\n```\\nimport re\\na = open(\"words.txt\")\\nb = a.read().strip()\\na.close()\\nz = b.split(\"\\\\n\")\\ny=\" \".join(z)\\n# I used regex to split on any whitespace bc I failed a test case\\nc=re.split(r\"\\\\s+\", y)\\nd=dict()\\nfor w in c:\\n\\tx=d.get(w,0)\\n\\td[w]=x+1\\nout=[(w[1],w[0]) for w in list(d.items())]\\nout.sort(reverse=True)\\nfor o in out:\\n\\tprint(o[1],o[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1776717,
                "title": "using-tr-and-uniq-for-a-simple-one-line-solution-with-explanation",
                "content": "The solution is as follows:\\n```cat words.txt | (tr \\' \\' \\'\\\\n\\' ) | tr -s \\'\\\\n\\' | sort | uniq -c | sort -hr | awk -c \\'{print $2\" \"$1}\\'```\\n\\nThere are a few main commands at work here, all piped into each other. \"The first executed command is ```cat words.txt```, which sends the contents of the file \"word.txt\" to stdout. It\\'s then piped via the operator | into the command  ```tr \\' \\' \\'\\\\n\\'```. tr has the description in \"man\" to translate or delete characters, and is used here to do the first function of that to translate all space characters into endline characters to set up for the next command. That output is piped again into the command ```tr -s \\'\\\\n\\'``` which uses the second feature listed to delete all consecutive occurrences of \\'\\\\n\\' after the first. stdout is then piped yet again into ```sort```, which is used to alphabetically sort the lines which is required for the next command ```uniq -c``` to function properly.  ```uniq -c``` counts the unique lines from its input source and lists them number first followed by the line. This is perfect for the next command it is piped into, ```sort -hr```, which sorts them based on the leading number this time and reverses the list for the required parameter to list the words in descending order based on count. The output stream is then piped final time into the command, ```awk -c \\'{print $2\" \"$1}\\'``` which executes the print function in awk to send both fields of each line in the order of second field, followed by a space, followed by the first field. Since ```uniq -c``` outputted two fields in the form of the count and line, this works nicely to make all outputs follow the constrained format consistently. \\n\\nStats for those who are curious:\\nRuntime: 4 ms\\nMemory Usage: 3.5 MB",
                "solutionTags": [],
                "code": "```cat words.txt | (tr \\' \\' \\'\\\\n\\' ) | tr -s \\'\\\\n\\' | sort | uniq -c | sort -hr | awk -c \\'{print $2\" \"$1}\\'```\n```cat words.txt```\n```tr \\' \\' \\'\\\\n\\'```\n```tr -s \\'\\\\n\\'```\n```sort```\n```uniq -c```\n```uniq -c```\n```sort -hr```\n```awk -c \\'{print $2\" \"$1}\\'```\n```uniq -c```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713062,
                "title": "cat-sort-uniq-awk-runtime-4-ms-faster-than-77-25-of-bash",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258784,
                "title": "awk-one-line-beats-100",
                "content": "```\\nawk \\'{for (i=1;i<=NF;i++){a[$i]++}}END{for (i in a) print i,a[i]}\\' words.txt | sort -k2 -rn\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for (i=1;i<=NF;i++){a[$i]++}}END{for (i in a) print i,a[i]}\\' words.txt | sort -k2 -rn\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180503,
                "title": "1-line-solution-using-xargs-sort-uniq-awk",
                "content": "\\n```\\ncat words.txt |xargs -n 1|sort |uniq -c |sort -r|awk \\'{print $2,$1}\\'\\n```\\nxargs: convert multi lines to one columns\\nsort,uniq : \\nawk: print  output ,  column2 column1",
                "solutionTags": [],
                "code": "```\\ncat words.txt |xargs -n 1|sort |uniq -c |sort -r|awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3271687,
                "title": "shell-simple-shell-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 113 ms, faster than 25.39% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.8 MB, less than 90.42% of Bash online submissions for Word Frequency.\\n\\n\\tcat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 113 ms, faster than 25.39% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.8 MB, less than 90.42% of Bash online submissions for Word Frequency.\\n\\n\\tcat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 2211392,
                "title": "bash-solution-using-grep-sort-uniq-awk",
                "content": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ngrep -Eio \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039269,
                "title": "used-cat-tr-sort-uniq-sort-awk-78-10-time-37-46-space",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{ print $2, $1 }\\'\\n```\\n* cat words.txt : prints the content into the stdout\\n* tr -s \\' \\' \\'\\\\n\\' : substitutes  spaces by \\'\\\\n\\'\\n* uniq -c : does the count of each word (to work must have the data sorted before)\\n* sort -nr : does the sort by numerical values in reverse order\\n* awk \\'{ print $2, $1 }\\' : switch the order of the columns, leaving the words in the first column and the counter in the second column as is expected.\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1832480,
                "title": "one-line-pipeline-using-egrep-o",
                "content": "From the manual of `egrep`, the `-o` option (`--only-matching`) prints only the non-empty matched parts of a matching line with each part printed on a seperate line.\\n```\\negrep \"[a-z]+\" -o words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\negrep \"[a-z]+\" -o words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463081,
                "title": "solution-with-explanation-the-straightforward-50-50-one-liner-solution",
                "content": "```bash\\ncat words.txt | xargs -n1 | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\n# Runtime: 12 ms, faster than 56.12% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.3 MB, less than 44.83% of Bash online submissions for Word Frequency.\\n```\\n\\ncat read file\\ntokenize with line by line output\\nsort the words to prepare for `count -c`\\noutput unique words with count (-c)\\nsort in natural order (-n) descending (-r reverse)\\ntokenize with awk to remove whitespace formatting and reverse the order given by `count -c`",
                "solutionTags": [],
                "code": "```bash\\ncat words.txt | xargs -n1 | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\n# Runtime: 12 ms, faster than 56.12% of Bash online submissions for Word Frequency.\\n# Memory Usage: 3.3 MB, less than 44.83% of Bash online submissions for Word Frequency.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304323,
                "title": "readable-bash-native-solution-with-associate-array",
                "content": "I don\\'t know why I am doing this in 2019, but here it is:\\n\\n```\\n#!/bin/bash\\ndeclare -A counts\\nfor i in $(cat words.txt); do\\n    counts[$i]=$((${counts[$i]:-0}+1))\\ndone\\n\\nfor w in ${!counts[*]}; do\\n    echo $w ${counts[$w]}\\ndone | sort -rnk 2\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\ndeclare -A counts\\nfor i in $(cat words.txt); do\\n    counts[$i]=$((${counts[$i]:-0}+1))\\ndone\\n\\nfor w in ${!counts[*]}; do\\n    echo $w ${counts[$w]}\\ndone | sort -rnk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55464,
                "title": "my-16ms-unix-pipe-cat-tr-awk-sort-hash-solution",
                "content": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    \\n    # use cat+tr+awk+sort\\n    # use hashtables\\n    # use Unix pipes\\n    \\n    cat words.txt | \\\\\\n    tr -s ' ' '\\\\n' | \\\\\\n    awk '{nums[$1]++}END{for(word in nums) print word, nums[word]}' | \\\\\\n    sort -rn -k2",
                "solutionTags": [],
                "code": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    \\n    # use cat+tr+awk+sort\\n    # use hashtables\\n    # use Unix pipes\\n    \\n    cat words.txt | \\\\\\n    tr -s ' ' '\\\\n' | \\\\\\n    awk '{nums[$1]++}END{for(word in nums) print word, nums[word]}' | \\\\\\n    sort -rn -k2",
                "codeTag": "Unknown"
            },
            {
                "id": 55449,
                "title": "my-1-line-solution-using-awk-sort-and-pipe",
                "content": "\\nFirst, use awk to count the number for each word.\\nThen sort to sort the result by decreasing order.\\n\\n    awk '{for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}' words.txt | sort -k2 -nr",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "\\nFirst, use awk to count the number for each word.\\nThen sort to sort the result by decreasing order.\\n\\n    awk '{for(i=1;i<=NF;i++) a[$i]++} END {for(k in a) print k,a[k]}' words.txt | sort -k2 -nr",
                "codeTag": "Unknown"
            },
            {
                "id": 2373566,
                "title": "faster-than-94-58",
                "content": "![image](https://assets.leetcode.com/users/images/852b682a-665c-42a2-8281-6e5f3ce1f1f6_1659522173.9779828.png)\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A map\\n\\nwhile read line; do\\n    for word in $line; do\\n        ((map[\"$word\"]=${map[\"$word\"]:-0}+1))\\n    done\\ndone < words.txt\\n\\nfor key in ${!map[@]}; do\\n    echo \"$key ${map[$key]}\"\\ndone | sort -rn -k 2\\n```\\n.",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A map\\n\\nwhile read line; do\\n    for word in $line; do\\n        ((map[\"$word\"]=${map[\"$word\"]:-0}+1))\\n    done\\ndone < words.txt\\n\\nfor key in ${!map[@]}; do\\n    echo \"$key ${map[$key]}\"\\ndone | sort -rn -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296773,
                "title": "single-line-code",
                "content": "tr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "tr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2053690,
                "title": "easy-one-liner-using-cat-grep-sort-uniq-awk",
                "content": "[59% Better in Time, 87% better in Space]\\n```\\ncat words.txt | grep -wo \\'[[:alnum:]]\\\\+\\' | sort | uniq -c | sort -bnr | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\nParts of the Solution:-\\n* `sort` to prepare as input for uniq\\n* `uniq -c` to count occurrences\\n* `sort -bnr` sorts in numeric reverse order while ignoring whitespace\\n* `awk` for priniting in required format\\n\\nUpvote it, if you like it....",
                "solutionTags": [],
                "code": "```\\ncat words.txt | grep -wo \\'[[:alnum:]]\\\\+\\' | sort | uniq -c | sort -bnr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589385,
                "title": "one-line-with-pipe",
                "content": "`cat words.txt |  awk \\'{for(i=1;i<=NF;i++){printf \"%s\\\\n\", $i}}\\' | sort  | uniq -c  | sort -r | awk \\'{print $2\" \"$1}\\'`\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "`cat words.txt |  awk \\'{for(i=1;i<=NF;i++){printf \"%s\\\\n\", $i}}\\' | sort  | uniq -c  | sort -r | awk \\'{print $2\" \"$1}\\'`\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1073860,
                "title": "100-the-simplest-easiest-and-fastest-solution",
                "content": "```\\ncat words.txt | sed \\'s/\\\\ /\\\\n/g\\' | sort | uniq -c |sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | sed \\'s/\\\\ /\\\\n/g\\' | sort | uniq -c |sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546802,
                "title": "yet-another-similar-one-liner-100-0-faster-no-cat",
                "content": "``` tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{ print $2 \" \" $1}\\'```",
                "solutionTags": [],
                "code": "``` tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{ print $2 \" \" $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 433697,
                "title": "bash-shell-100-fast-with-egrep-and-awk",
                "content": "####             ***** SOLUTION 1 100% FAST 90% Less Space *****    \\n\\n\\t\\t\\t \\n```\\negrep -o [a-z]+ words.txt | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```\\n\\n <br> </br>\\n  ####             ***** SOLUTION 2 ~56% FAST 30% Less Space *****                 \\n  <br>\\n\\t\\t\\t   \\n```\\nawk \\'\\n{for (i = 1; i<=NF; i++) words[$i]++} \\nEND {for (i in words) print i, words[i]}\\' words.txt | \\\\\\nsort -nr -k2\\n\\n```",
                "solutionTags": [],
                "code": "```\\negrep -o [a-z]+ words.txt | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```\n```\\nawk \\'\\n{for (i = 1; i<=NF; i++) words[$i]++} \\nEND {for (i in words) print i, words[i]}\\' words.txt | \\\\\\nsort -nr -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172537,
                "title": "one-liner-solution-4-ms",
                "content": "Used awk to separate by rows:\\n```\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++)print $i}\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++)print $i}\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133594,
                "title": "simple-1-liner",
                "content": "```\\nfor i in `cat text` ; do echo $i ; done | sort | uniq -c\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor i in `cat text` ; do echo $i ; done | sort | uniq -c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3183862,
                "title": "beats-95-submission-using-awk",
                "content": "# Intuition\\n<!-- Very first thought was that we need to increment count each time we see a repeated word. What could be better than an array. -->\\nVery first thought was that we need to increment count each time we see a repeated word. What could be better than an array!\\n\\n# Approach\\n<!-- The best way was using awk associative array as it gives to you liberty to store values as arr[\"the\"]=2 format.  -->\\nThe best way was using awk associative array as it gives to you liberty to store values as arr[\"the\"]=2 format.\\n\\n# Complexity\\n- Time complexity:\\n<!-- $$O(n)$$ : n being number of words in file -->\\n$$O(n)$$ : n being number of words in file\\n- Space complexity:\\n<!-- $$Ohm(n)$$ : less than or equal to number of words in file -->\\n$$Ohm(n)$$ : less than or equal to number of words in file\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\necho -e \"$(cat words.txt)\" | awk \\'{for(i=1;i<=NF;i++){if(arr[$i]==0){arr[$i]=1}else{arr[$i]=arr[$i]+1}}}END{for(i in arr) print i, arr[i]}\\' | sort -k2 -n -r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\necho -e \"$(cat words.txt)\" | awk \\'{for(i=1;i<=NF;i++){if(arr[$i]==0){arr[$i]=1}else{arr[$i]=arr[$i]+1}}}END{for(i in arr) print i, arr[i]}\\' | sort -k2 -n -r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2566791,
                "title": "stupid-shell-script",
                "content": "#!/bin/bash\\ncat word.txt\\ncnt=`wc -l < word.txt`\\n\\ndist=`head -q -n  $cnt  word.txt | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort -u`\\n\\nfor i in $dist\\ndo\\nres=`grep -o -i $i  word.txt | wc -l`\\necho \"$i $res\"\\ndone",
                "solutionTags": [],
                "code": "#!/bin/bash\\ncat word.txt\\ncnt=`wc -l < word.txt`\\n\\ndist=`head -q -n  $cnt  word.txt | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort -u`\\n\\nfor i in $dist\\ndo\\nres=`grep -o -i $i  word.txt | wc -l`\\necho \"$i $res\"\\ndone",
                "codeTag": "Unknown"
            },
            {
                "id": 2149108,
                "title": "one-liner-grep-sort-uniq-awk",
                "content": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort -n | uniq -c | sort -rn | awk \\' {print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort -n | uniq -c | sort -rn | awk \\' {print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057881,
                "title": "my-one-liner",
                "content": "Here is what I did:\\n\\n```bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -n -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709659,
                "title": "low-complexity-one-liner-while-read-for-in-sort-uniq-awk",
                "content": "```\\ncat words.txt | while read -r l; do for w in $l; do echo $w; done; done | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | while read -r l; do for w in $l; do echo $w; done; done | sort | uniq -c | sort -nr | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658902,
                "title": "one-more-oneliner-awk-tr-sort",
                "content": "```\\nawk \\'{for(i=1;i<=NF;i++) words[$i]++} END {for(word in words) print word,words[word]}\\' words.txt | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{for(i=1;i<=NF;i++) words[$i]++} END {for(word in words) print word,words[word]}\\' words.txt | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391346,
                "title": "pure-bash-solution-merge-sort",
                "content": "```\\nmergesort() {\\n    local -n _merge_arr=$1\\n    local start=${2:-0}\\n    local end=${3:-${#_merge_arr[@]}}\\n    if ((start >= end - 1)); then\\n        return\\n    fi\\n    local middle=$(( (start + end) / 2 ))\\n    mergesort \"$1\" \"$start\" \"$middle\"\\n    mergesort \"$1\" \"$middle\" \"$end\"\\n\\n    local firsthalf=(\"${_merge_arr[@]:start:middle - start}\")\\n    local secondhalf=(\"${_merge_arr[@]:middle:end - middle}\")\\n    local i=0 j=0 k=$start\\n    while ((i < ${#firsthalf[@]} || j < ${#secondhalf[@]})); do\\n        read -r _ fh <<< \"${firsthalf[i]}\"\\n        read -r _ sh <<< \"${secondhalf[j]}\"\\n        if (( i < ${#firsthalf[@]} && (j >= ${#secondhalf[@]} || fh > sh) )); then\\n            _merge_arr[k++]=${firsthalf[i++]}\\n        else\\n            _merge_arr[k++]=${secondhalf[j++]}\\n        fi\\n    done\\n}\\n\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A words\\nwhile read -r -a line; do\\n    for word in \"${line[@]}\"; do\\n        count=words[\"$word\"]\\n        words[\"$word\"]=$((count + 1))\\n    done\\ndone < words.txt\\n\\ntosort=()\\nfor word in \"${!words[@]}\"; do\\n    tosort+=(\"$word ${words[$word]}\")\\ndone\\n\\nmergesort tosort\\n(IFS=$\\'\\\\n\\'; echo \"${tosort[*]}\")\\n```",
                "solutionTags": [],
                "code": "```\\nmergesort() {\\n    local -n _merge_arr=$1\\n    local start=${2:-0}\\n    local end=${3:-${#_merge_arr[@]}}\\n    if ((start >= end - 1)); then\\n        return\\n    fi\\n    local middle=$(( (start + end) / 2 ))\\n    mergesort \"$1\" \"$start\" \"$middle\"\\n    mergesort \"$1\" \"$middle\" \"$end\"\\n\\n    local firsthalf=(\"${_merge_arr[@]:start:middle - start}\")\\n    local secondhalf=(\"${_merge_arr[@]:middle:end - middle}\")\\n    local i=0 j=0 k=$start\\n    while ((i < ${#firsthalf[@]} || j < ${#secondhalf[@]})); do\\n        read -r _ fh <<< \"${firsthalf[i]}\"\\n        read -r _ sh <<< \"${secondhalf[j]}\"\\n        if (( i < ${#firsthalf[@]} && (j >= ${#secondhalf[@]} || fh > sh) )); then\\n            _merge_arr[k++]=${firsthalf[i++]}\\n        else\\n            _merge_arr[k++]=${secondhalf[j++]}\\n        fi\\n    done\\n}\\n\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A words\\nwhile read -r -a line; do\\n    for word in \"${line[@]}\"; do\\n        count=words[\"$word\"]\\n        words[\"$word\"]=$((count + 1))\\n    done\\ndone < words.txt\\n\\ntosort=()\\nfor word in \"${!words[@]}\"; do\\n    tosort+=(\"$word ${words[$word]}\")\\ndone\\n\\nmergesort tosort\\n(IFS=$\\'\\\\n\\'; echo \"${tosort[*]}\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162726,
                "title": "awk-sort-solution",
                "content": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++)\\n        words[$i]++\\n}\\n\\nEND {\\n    for (word in words)\\n        print word, words[word]\\n}\\n\\' words.txt | sort -n -r -k 2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for (i = 1; i <= NF; i++)\\n        words[$i]++\\n}\\n\\nEND {\\n    for (word in words)\\n        print word, words[word]\\n}\\n\\' words.txt | sort -n -r -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099989,
                "title": "just-one-sort-blazing-fast",
                "content": "```\\ndeclare -A word_count\\n\\nfor word in $(sed \\'s/\\\\\\\\n/ /g\\' <words.txt); do\\n    ((word_count[$word]++))\\ndone\\n\\nfor k in ${!word_count[@]}; do\\n    echo $k ${word_count[$k]}\\ndone | sort -rn -k2\\n```\\n\\n1. Create associative array `word_count`\\n2. Count each word occurence\\n3. Print and sort",
                "solutionTags": [],
                "code": "```\\ndeclare -A word_count\\n\\nfor word in $(sed \\'s/\\\\\\\\n/ /g\\' <words.txt); do\\n    ((word_count[$word]++))\\ndone\\n\\nfor k in ${!word_count[@]}; do\\n    echo $k ${word_count[$k]}\\ndone | sort -rn -k2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1047002,
                "title": "piping-6-bash-built-in-commands",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{printf(\"%s %s\\\\n\",$2,$1)}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{printf(\"%s %s\\\\n\",$2,$1)}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007477,
                "title": "faster-than-100",
                "content": "```\\nfor w in $(cat words.txt | cut -d \\' \\' -f1-);do echo $w;done | sort | uniq -c | sort -r| awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor w in $(cat words.txt | cut -d \\' \\' -f1-);do echo $w;done | sort | uniq -c | sort -r| awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 992603,
                "title": "one-line-using-tr-s-n-sort-uniq-c-and-awk-print-2-1",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 875893,
                "title": "just-tr-sort-and-awk",
                "content": "tr, sort and awk\\n```tr -s \\' \\' \\'\\\\n\\' < words.txt|sort|uniq -c |sort -rn|awk \\'{print $2,$1}```",
                "solutionTags": [],
                "code": "```tr -s \\' \\' \\'\\\\n\\' < words.txt|sort|uniq -c |sort -rn|awk \\'{print $2,$1}```",
                "codeTag": "Unknown"
            },
            {
                "id": 659537,
                "title": "bash-faster-than-100-1-liner",
                "content": "```\\ncat words.txt | tr $\\'\\\\n\\' \\' \\' | sed -r \"s/ +/\\\\n/g\" | sort | uniq -c | sed \"s/^[ \\\\t]*//\" | cut -d \\' \\' -f 1,2 | sort -rn | sed -r \"s/([0-9]+) ([a-zA-Z]+)/\\\\2 \\\\1/\" \\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr $\\'\\\\n\\' \\' \\' | sed -r \"s/ +/\\\\n/g\" | sort | uniq -c | sed \"s/^[ \\\\t]*//\" | cut -d \\' \\' -f 1,2 | sort -rn | sed -r \"s/([0-9]+) ([a-zA-Z]+)/\\\\2 \\\\1/\" \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615062,
                "title": "simple-c-solution",
                "content": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532985,
                "title": "less-is-better-one-line-with-pipe",
                "content": "```\\nless words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\nless words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 514519,
                "title": "awk-pipe-sort-faster-than-100",
                "content": "```\\nawk \\'{ for (i=1; i <= NF; i++) {m[$i]++;} } END { for(x in m){ print(x, m[x]) } }\\' words.txt | sort -rn -k2\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'{ for (i=1; i <= NF; i++) {m[$i]++;} } END { for(x in m){ print(x, m[x]) } }\\' words.txt | sort -rn -k2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 405283,
                "title": "solution-using-sort-uniq-and-awk",
                "content": "```\\nfor word in $(cat test.txt); do echo $word; done | sort | uniq -c | sort -r | awk \\'{ print $2 \" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor word in $(cat test.txt); do echo $word; done | sort | uniq -c | sort -r | awk \\'{ print $2 \" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375927,
                "title": "one-line-solution-using-sed-and-awk-faster-than-100",
                "content": "```\\ncat words.txt | sed \\'s/ /\\\\n/g;\\' | sed \\'/^\\\\s*$/D\\' | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\n- First `sed` replaces all spaces with new lines.\\n- Second `sed` deletes all whitespace-only lines\\n- `sort` sorts all the words\\n- `uniq -c` removes the duplicates and prefixes the frequency of each word\\n- `sort -nr` sorts the input based on the frequency (`-r` is for descending order)\\n- `awk \\'{print $2 \" \" $1}` reverses the ordering of frequency and word in a line",
                "solutionTags": [],
                "code": "```\\ncat words.txt | sed \\'s/ /\\\\n/g;\\' | sed \\'/^\\\\s*$/D\\' | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374679,
                "title": "my-simple-slution",
                "content": "awk \\'{for(i=1;i<=NF;i++) print $i}\\' words.txt | sort | uniq -c |sort -r|awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "awk \\'{for(i=1;i<=NF;i++) print $i}\\' words.txt | sort | uniq -c |sort -r|awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 315510,
                "title": "one-line",
                "content": "```cat words.txt | sed \\'s/ /\\\\n/g\\' | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $NF, $1}\\'```",
                "solutionTags": [],
                "code": "```cat words.txt | sed \\'s/ /\\\\n/g\\' | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $NF, $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 240212,
                "title": "one-line-with-pipe-beats-100",
                "content": "```\\ncat words.txt |awk \\'{for(i=1;i<=NF;i++) print $i;}\\'|sort|uniq -c|sort -r |awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt |awk \\'{for(i=1;i<=NF;i++) print $i;}\\'|sort|uniq -c|sort -r |awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229528,
                "title": "my-one-line-solution",
                "content": "Inspired by @Swordmctster in this [post](https://leetcode.com/problems/word-frequency/discuss/55443/My-simple-solution-(one-line-with-pipe)).\\n```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |sort| grep .| uniq -c | sort -r -n -k 1| awk \\'{print $2,$1}\\' \\n```\\nadd grep . to ignore blank lines.\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |sort| grep .| uniq -c | sort -r -n -k 1| awk \\'{print $2,$1}\\' \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 190312,
                "title": "4ms-single-process-no-pipe-solution-using-awk-comments-included",
                "content": "```\nawk 'BEGIN { \n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"   # set array traversal to values in descending order\n} { \n    for (i=1;i<=NF;i++) {   # take each word separately\n        a[$i]++             # populate array a with word count incremented each time\n    }\n} END {\n    for (i in a) {          # array traversal and print which will follow pre-set order\n        print i,a[i]\n    }\n}' words.txt\n```",
                "solutionTags": [],
                "code": "```\nawk 'BEGIN { \n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"   # set array traversal to values in descending order\n} { \n    for (i=1;i<=NF;i++) {   # take each word separately\n        a[$i]++             # populate array a with word count incremented each time\n    }\n} END {\n    for (i in a) {          # array traversal and print which will follow pre-set order\n        print i,a[i]\n    }\n}' words.txt\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186434,
                "title": "easy-to-understand-solution-using-unix-pipeline-and-awk",
                "content": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |awk \\'{for(i=1;i<=NF;i++) a[$i]++}END{for(k in a) print k,a[k]}\\'|sort -k2nr\\n```\\n`cat`: display\\n`tr`: remove newline identifier \\'\\\\n\\'\\n`awk \\'{for(i=1;i<=NF;i++) a[$i]++} `: counting list generation\\n`for(k in a) print k,a[k]}`: printing\\n`sort -k2nr`: sort -n:numerical comparison -r:reversely(descending) -k2:based on column #2\\n",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' |awk \\'{for(i=1;i<=NF;i++) a[$i]++}END{for(k in a) print k,a[k]}\\'|sort -k2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114346,
                "title": "use-sed-and-grep",
                "content": "```\\nsed 's/ \\\\{1,\\\\}/\\\\n/g' words.txt | grep -v \"^$\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\\n```",
                "solutionTags": [],
                "code": "```\\nsed 's/ \\\\{1,\\\\}/\\\\n/g' words.txt | grep -v \"^$\" | sort | uniq -c | sort -r | awk '{print $2, $1}'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55446,
                "title": "solve-this-problem-in-linux-style",
                "content": "```\\n#!/bin/bash\\n cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'|uniq -c|sort -nr|awk '{print $2,$1}'\\n```\\nwhy use  tr -nr   not   tr -r ?\\n```\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -r\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n     13 can\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -nr\\n     13 can\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n```\\n\\nwhy added awk '{if($0!=\"\")print}' ?\\n\\n```\\n[root@pangu icai]# more words.txt \\na  a   b\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort\\n\\n\\n\\na\\na\\nb\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'\\na\\na\\nb\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\n cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'|uniq -c|sort -nr|awk '{print $2,$1}'\\n```\n```\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -r\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n     13 can\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort |uniq -c|sort -nr\\n     13 can\\n      8 a\\n      7 canner\\n      5 cans\\n      4 as\\n      3 many\\n      2 if\\n      1 how\\n```\n```\\n[root@pangu icai]# more words.txt \\na  a   b\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort\\n\\n\\n\\na\\na\\nb\\n[root@pangu icai]# cat words.txt |tr  ' '  '\\\\n'|sort|awk '{if($0!=\"\")print}'\\na\\na\\nb\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55459,
                "title": "my-solution-by-sort-tr-sed",
                "content": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    cat words.txt| tr -s \" \" \"\\\\n\" |sort| uniq -c | sort -rk1| sed \"s/\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2\\\\1/\" | tr -s \" \"",
                "solutionTags": [],
                "code": "    # Read from the file words.txt and output the word frequency list to stdout.\\n    cat words.txt| tr -s \" \" \"\\\\n\" |sort| uniq -c | sort -rk1| sed \"s/\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2\\\\1/\" | tr -s \" \"",
                "codeTag": "Unknown"
            },
            {
                "id": 55463,
                "title": "my-solution-using-only-awk",
                "content": "    cat words.txt | awk '{for(i=1;i<=NF;++i) { arr[$i]++; } } END { x=0; for(var in arr) {newarr[arr[var]]=var; if(arr[var]>x) x=arr[var];} for(i=x;i>0;--i) if (newarr[i] > 0) print newarr[i] \" \"i; }'",
                "solutionTags": [],
                "code": "    cat words.txt | awk '{for(i=1;i<=NF;++i) { arr[$i]++; } } END { x=0; for(var in arr) {newarr[arr[var]]=var; if(arr[var]>x) x=arr[var];} for(i=x;i>0;--i) if (newarr[i] > 0) print newarr[i] \" \"i; }'",
                "codeTag": "Unknown"
            },
            {
                "id": 4068579,
                "title": "beats-98-7-dict-and-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/sh\\n\\ndeclare -A dict\\narr=($(cat words.txt))\\nfor i in \"${arr[@]}\";\\ndo\\n    dict[$i]=0\\ndone\\n\\nfor i in \"${arr[@]}\";\\ndo\\n    ((dict[$i]+=1))\\ndone\\n\\nfor i in \"${!dict[@]}\";\\ndo\\n    echo \"$i ${dict[$i]}\"\\ndone | sort -t\\' \\' -k2 -rV\\n\\t \\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\n\\ndeclare -A dict\\narr=($(cat words.txt))\\nfor i in \"${arr[@]}\";\\ndo\\n    dict[$i]=0\\ndone\\n\\nfor i in \"${arr[@]}\";\\ndo\\n    ((dict[$i]+=1))\\ndone\\n\\nfor i in \"${!dict[@]}\";\\ndo\\n    echo \"$i ${dict[$i]}\"\\ndone | sort -t\\' \\' -k2 -rV\\n\\t \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023106,
                "title": "counting-word-frequencies-in-a-text-file-using-unix-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires counting the frequency of each word in a text file. To solve this, we need to read the contents of the file, split it into words, count the occurrences of each word, and then display the words sorted by their frequencies in descending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by reading the contents of the words.txt file using the cat command.\\n2. We use the tr command to replace spaces with newline characters. This effectively splits the text into individual words, as each word is separated by spaces.\\n3. Next, we use the sort command to sort the words alphabetically. This step is essential to prepare the data for counting.\\n4. We use the uniq -c command to count the unique occurrences of each word and prefix each line with its word count.\\n5. After counting, we use sort -nr to sort the lines in reverse order based on the word count. This gives us the words sorted by their frequencies in descending order.\\n6. Finally, we use awk to print the word and its frequency in the desired format.\\n\\n# Complexity\\n- Time complexity:\\n    - Reading the file and splitting it into words takes linear time, so it\\'s O(n), where n is the total number of characters in the file.\\n    - Sorting and counting unique words also takes linear time.\\n    - Sorting the lines based on word count takes O(m log m) time, where m is the number of unique words.\\n    - Overall time complexity is O(n + m log m).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - The space complexity is determined by the number of unique words, which is O(m), where m is the number of unique words.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020557,
                "title": "one-line-with-sed-sort-uniq-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nsed -r \\'s/^ +//g;s/ +/ /g;s/ +$//g;s/ /\\\\n/g\\' <words.txt | sort | uniq -c | sort -rn | awk -F\\' \\' \\'{print $2,$1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nsed -r \\'s/^ +//g;s/ +/ /g;s/ +$//g;s/ /\\\\n/g\\' <words.txt | sort | uniq -c | sort -rn | awk -F\\' \\' \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019819,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945872,
                "title": "solution-by-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npython3 -c \"\\nf = open(\\'words.txt\\', \\'r\\')\\nans = []\\n\\nl = f.read().split()\\nwhile len(l) != 0:\\n    c = l.count(l[0])\\n    value = l[0]\\n    pre_ans = [value, c]\\n    ans.append(pre_ans)\\n    for j in range(c):\\n        l.remove(value)\\n\\nans.sort(key = lambda x: x[1], reverse = True)\\nfor k in range(len(ans)):\\n    print(ans[k][0], ans[k][1])\\n\"\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\npython3 -c \"\\nf = open(\\'words.txt\\', \\'r\\')\\nans = []\\n\\nl = f.read().split()\\nwhile len(l) != 0:\\n    c = l.count(l[0])\\n    value = l[0]\\n    pre_ans = [value, c]\\n    ans.append(pre_ans)\\n    for j in range(c):\\n        l.remove(value)\\n\\nans.sort(key = lambda x: x[1], reverse = True)\\nfor k in range(len(ans)):\\n    print(ans[k][0], ans[k][1])\\n\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3938497,
                "title": "solution-using-bash-associative-arrays",
                "content": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A hash=()\\n\\nfor word in $(cat words.txt); do\\n    hash[\"$word\"]=$(( ${hash[$word]:-0} + 1 ));\\ndone\\n\\n{ for word in \"${!hash[@]}\"; do\\n    printf \\'%s %s\\\\n\\' \"$word\" \"${hash[$word]}\"\\ndone; } | sort -rnk 2\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ndeclare -A hash=()\\n\\nfor word in $(cat words.txt); do\\n    hash[\"$word\"]=$(( ${hash[$word]:-0} + 1 ));\\ndone\\n\\n{ for word in \"${!hash[@]}\"; do\\n    printf \\'%s %s\\\\n\\' \"$word\" \"${hash[$word]}\"\\ndone; } | sort -rnk 2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925305,
                "title": "easy-and-simple-check-it-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#!/bin/bash\\n\\n# Read the file, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Sort and count unique words\\nsort | uniq -c |\\n# Sort by descending frequency\\nsort -nr |\\n# Format output\\nawk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\n# Read the file, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Sort and count unique words\\nsort | uniq -c |\\n# Sort by descending frequency\\nsort -nr |\\n# Format output\\nawk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893200,
                "title": "quick-script",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# tr - Translate characters. The -s option tells tr to remove all duplicate whitespace characters from the input.\\n# sort - Sort the lines of the input.\\n# uniq -c - Count the number of occurrences of each line in the input.\\n# sort -nr - Sort the output of uniq in descending order.\\n# awk - Print the second and first field of each line, separated by a space. \\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# tr - Translate characters. The -s option tells tr to remove all duplicate whitespace characters from the input.\\n# sort - Sort the lines of the input.\\n# uniq -c - Count the number of occurrences of each line in the input.\\n# sort -nr - Sort the output of uniq in descending order.\\n# awk - Print the second and first field of each line, separated by a space. \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3884740,
                "title": "one-line-using-pipes",
                "content": "# Intuition\\ncat - print out the file\\ntr - truncate on spaces\\nsort - sort the truncated output into lines so it can be read by uniq easily\\nuniq -c - count all unique instances\\nsort -nr - sort in descending order\\nawk - print out the output with the second argument (the letter) after the first arguement (the number)\\n\\n# Approach\\nI honestly just ran it a couple times with uniq and then messed with the formating (tr and awk) until it matched the expected output. It\\'s not exactly optimal with space complexity; I think it could be cut down a bit.\\n\\n# Complexity\\n- Time complexity: 77ms\\n\\n- Space complexity: 3.81mb\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871827,
                "title": "bash-scripting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\n#!/bin/bash\\n\\n# Read the content of words.txt, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Count the frequency of each word\\nsort | uniq -c |\\n# Sort the output by descending frequency\\nsort -nr |\\n# Use awk to format the output as \"word frequency\"\\nawk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\n#!/bin/bash\\n\\n# Read the content of words.txt, convert to lowercase, and replace multiple spaces with a single space\\ncat words.txt | tr \\'[:upper:]\\' \\'[:lower:]\\' | tr -s \\' \\' \\'\\\\n\\' |\\n# Count the frequency of each word\\nsort | uniq -c |\\n# Sort the output by descending frequency\\nsort -nr |\\n# Use awk to format the output as \"word frequency\"\\nawk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813645,
                "title": "awk-sort-using-space-as-record-separator",
                "content": "My intuition was that take each space as a record separator, so I can have the variable `$0` with the word. \\n\\nThen, with the word in `$0`, I can do the old trick of update an `awk` associative array and incrementing acording the appareances.\\n\\n# Code\\n```\\nawk -v RS=\\'[[:space:]]+\\' \\'{arr[$0]++}END{\\n    for(letra in arr)\\n        printf \"%s %s\\\\n\", letra, arr[letra]\\n}\\' words.txt | sort -k2nr\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nawk -v RS=\\'[[:space:]]+\\' \\'{arr[$0]++}END{\\n    for(letra in arr)\\n        printf \"%s %s\\\\n\", letra, arr[letra]\\n}\\' words.txt | sort -k2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805456,
                "title": "bash-tr-sort-uniq-awk",
                "content": "```\\n#!/bin/bash\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n#!/bin/bash\\n\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787110,
                "title": "with-explanation",
                "content": "\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat \"words.txt\" | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# cat words.txt: This command reads the content of the file words.txt and outputs it to the standard output. \\n\\n# tr -s \\'[:space:]\\' \\'\\\\n\\': This command uses the tr (translate) utility to replace sequences of whitespace characters with a single newline character (\\'\\\\n\\'). The option -s stands for \"squeeze,\" which means it will replace multiple consecutive occurrences of the specified character class (in this case, whitespace characters) with a single occurrence.\\n\\n# sort: This command sorts the input data (words) in ascending order by default. Since no specific options are provided, it will use the lexicographic order for sorting.\\n\\n# uniq -c: The uniq command filters out adjacent duplicate lines in the input and only outputs unique lines. The option -c is used to count the occurrences of each unique line and print the count alongside the line.\\n\\n# sort -nr: This command performs a numeric sort (-n) in reverse order (-r). The reverse order (-r) ensures that the words with the highest counts appear first in the output.\\n\\n# awk \\'{print $2, $1}\\': The awk command is a powerful text processing tool. In this specific case, it takes each line of input and prints the second and first fields (columns) in that order.\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat \"words.txt\" | tr -s \\'[:space:]\\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n# cat words.txt: This command reads the content of the file words.txt and outputs it to the standard output. \\n\\n# tr -s \\'[:space:]\\' \\'\\\\n\\': This command uses the tr (translate) utility to replace sequences of whitespace characters with a single newline character (\\'\\\\n\\'). The option -s stands for \"squeeze,\" which means it will replace multiple consecutive occurrences of the specified character class (in this case, whitespace characters) with a single occurrence.\\n\\n# sort: This command sorts the input data (words) in ascending order by default. Since no specific options are provided, it will use the lexicographic order for sorting.\\n\\n# uniq -c: The uniq command filters out adjacent duplicate lines in the input and only outputs unique lines. The option -c is used to count the occurrences of each unique line and print the count alongside the line.\\n\\n# sort -nr: This command performs a numeric sort (-n) in reverse order (-r). The reverse order (-r) ensures that the words with the highest counts appear first in the output.\\n\\n# awk \\'{print $2, $1}\\': The awk command is a powerful text processing tool. In this specific case, it takes each line of input and prints the second and first fields (columns) in that order.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766806,
                "title": "solved-with-combined-powers-of-tr-awk-sort-commands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTry to get each word in the file printed per line.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we have each word of the file getting printed per line, using awk utility program, we can arrange to capture the frequency of each word in the file (using associative array approach). We can then pipe the result of awk program to sort utility to maintain the decending order of frequency of words.\\n\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \" \" \"\\\\n\" | awk -F\\' \\' \\'{freq[$0] += 1;}END{for(i in freq){printf(\"%s %d\\\\n\",i, freq[i])}}\\' | sort -nrk 2,2 -t\\' \\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \" \" \"\\\\n\" | awk -F\\' \\' \\'{freq[$0] += 1;}END{for(i in freq){printf(\"%s %d\\\\n\",i, freq[i])}}\\' | sort -nrk 2,2 -t\\' \\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651957,
                "title": "text-utils-tr-sort-uniq-c-do-the-job-sed-to-swap-2-values",
                "content": "# Intuition\\ntext utils tr, sort, uniq -c do the job, sed to swap 2 values\\n\\n# Approach\\nusing awk to swap 2 values is overkill, sed more effective. If run the script as #!/bin/sh, not as bash, it will be the fastest too\\n\\n# Complexity\\n- Time complexity:\\n15.26%\\n\\n- Space complexity:\\n99.91%\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt|\\\\\\ntr \\' \\' \\'\\\\n\\'|\\\\\\ntr -s \\'\\\\n\\'|\\\\\\nsort|\\\\\\nuniq -c|\\\\\\nsort -k1nr|\\\\\\nsed \\'s/^ *\\\\([0-9]*\\\\) \\\\([a-z]*\\\\)$/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt|\\\\\\ntr \\' \\' \\'\\\\n\\'|\\\\\\ntr -s \\'\\\\n\\'|\\\\\\nsort|\\\\\\nuniq -c|\\\\\\nsort -k1nr|\\\\\\nsed \\'s/^ *\\\\([0-9]*\\\\) \\\\([a-z]*\\\\)$/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631223,
                "title": "beat-98-76-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIn order to solve the problem of calculating word frequencies in a text file, the initial intuition was to split the words and count their occurrences. Considering that the input file contains only lowercase characters and space characters, we can assume that the words are separated by whitespace.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe chosen approach utilizes awk to process the text file efficiently. The script begins by looping through each line of the file. Within each line, another loop iterates through each word (based on whitespace separation) and increments its count in an array called count. This approach avoids the need for multiple commands and pipes, making it faster.\\n\\nAfter processing all lines, awk enters the END block. In this block, the script iterates over the count array and prints each word along with its corresponding frequency. The output is then piped to the sort command to sort the words based on their frequency in descending order.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach can be considered as linear, or O(n), where n represents the total number of words in the input file. The script reads each word once, incrementing the count in constant time for each word.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity can also be considered as linear, or O(n), where n represents the total number of distinct words in the input file. The count array stores the count for each unique word encountered during processing.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nawk \\'{ for (i=1; i<=NF; i++) count[$i]++ } END { for (word in count) { print word, count[word] } }\\' words.txt | sort -k2,2nr\\n```\\n\\nThe given code snippet uses awk to process the words.txt file. It loops through each line, splitting the words based on whitespace and increments their count in the count array. After processing all lines, the script prints each word along with its count. The output is then piped to the sort command, which sorts the word frequency list based on the second column in descending order.",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nawk \\'{ for (i=1; i<=NF; i++) count[$i]++ } END { for (word in count) { print word, count[word] } }\\' words.txt | sort -k2,2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621821,
                "title": "awk-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'\\n{\\n    split($0, arr, \" \");\\n    for (i = 1; i <= length(arr); i += 1) {\\n        words[arr[i]] += 1;\\n    }\\n}\\n\\nEND {\\n    n = 0\\n    for (k in words) {\\n        keys[++n] = k;\\n        vals[k] = words[k];\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        for (j = i + 1; j <= n; ++j) {\\n            if (vals[keys[i]] < vals[keys[j]]) {\\n                tmp = keys[i];\\n                keys[i] = keys[j];\\n                keys[j] = tmp;\\n            }\\n        }\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        print keys[i], vals[keys[i]];\\n    }\\n}\\n\\' words.txt\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'\\n{\\n    split($0, arr, \" \");\\n    for (i = 1; i <= length(arr); i += 1) {\\n        words[arr[i]] += 1;\\n    }\\n}\\n\\nEND {\\n    n = 0\\n    for (k in words) {\\n        keys[++n] = k;\\n        vals[k] = words[k];\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        for (j = i + 1; j <= n; ++j) {\\n            if (vals[keys[i]] < vals[keys[j]]) {\\n                tmp = keys[i];\\n                keys[i] = keys[j];\\n                keys[j] = tmp;\\n            }\\n        }\\n    }\\n\\n    for (i = 1; i <= n; ++i) {\\n        print keys[i], vals[keys[i]];\\n    }\\n}\\n\\' words.txt\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616110,
                "title": "1-word-low-ltncy-shell",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594841,
                "title": "solution-using-associative-arrays-bash-hyder-nabi",
                "content": "# Algorihtm:\\r\\n1. Read input file line by line;\\r\\n2. for each line:\\r\\n3. split the line into words using space as delimeter\\r\\n4. count the frequency of each word and store the frequency in associative array with the word itself as key.\\r\\n5. Repeat the same for every line.\\r\\n6. Finally sort the array using values with descending order.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(NoOfLines*NoOfWordsInEachLine^2)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(NoOfDifferentWords)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\n\\r\\nfile=\"words.txt\"\\r\\ndeclare -A freq\\r\\nwhile read -r line; do\\r\\n    IFS=\\' \\' read -ra Arr <<< \"$line\"\\r\\n    for i in \"${Arr[@]}\"; do\\r\\n        flag=0\\r\\n        for key in \"${!freq[@]}\"; do\\r\\n            if [ \"$i\" == \"$key\" ]; then\\r\\n                var=\"${freq[$i]}\"\\r\\n                freq[$i]=$((var+1))\\r\\n                flag=1\\r\\n            fi\\r\\n        done\\r\\n        if [ \"$flag\" == 0 ]; then\\r\\n            freq[$i]=1\\r\\n        fi\\r\\n    done\\r\\ndone < \"$file\"\\r\\n\\r\\nfor i in \"${!freq[@]}\"; do\\r\\n    echo \"$i ${freq[$i]}\"\\r\\ndone | sort -k2,2rn\\r\\n\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\n\\r\\nfile=\"words.txt\"\\r\\ndeclare -A freq\\r\\nwhile read -r line; do\\r\\n    IFS=\\' \\' read -ra Arr <<< \"$line\"\\r\\n    for i in \"${Arr[@]}\"; do\\r\\n        flag=0\\r\\n        for key in \"${!freq[@]}\"; do\\r\\n            if [ \"$i\" == \"$key\" ]; then\\r\\n                var=\"${freq[$i]}\"\\r\\n                freq[$i]=$((var+1))\\r\\n                flag=1\\r\\n            fi\\r\\n        done\\r\\n        if [ \"$flag\" == 0 ]; then\\r\\n            freq[$i]=1\\r\\n        fi\\r\\n    done\\r\\ndone < \"$file\"\\r\\n\\r\\nfor i in \"${!freq[@]}\"; do\\r\\n    echo \"$i ${freq[$i]}\"\\r\\ndone | sort -k2,2rn\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516417,
                "title": "bash",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514046,
                "title": "one-line-using-unix-pipes",
                "content": "\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3490307,
                "title": "unique-solution-beats-98-in-run-time",
                "content": "I guess nobody shared this solution.\\r\\n\\r\\nThis is a bit log and it is different approach\\r\\n\\r\\n\\r\\nIf you liked this **please upvote.**\\r\\n\\r\\n```Bash \\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\ndeclare -A hm\\r\\nmax=0\\r\\nwhile IFS=\\' \\' read -r -a line\\r\\ndo\\r\\n    for value in ${line[@]} \\r\\n        do \\r\\n            # echo $value\\r\\n            if [[ hm[$value] == -1 ]]\\r\\n                then \\r\\n                hm[$value]=1\\r\\n                else \\r\\n                (( hm[$value]+=1 ))\\r\\n                [[ hm[$value] -gt max ]] && (( max=hm[$value] ))\\r\\n            fi \\r\\n        done\\r\\ndone < \"words.txt\"\\r\\ndeclare -A another\\r\\nfor value in ${!hm[@]}; do \\r\\nif [[ another[${hm[$value]}] -eq -1 ]] ; then another[${hm[$value]}]=() ; fi\\r\\nanother[${hm[$value]}]+=$value\\r\\ndone\\r\\nwhile [ $max -gt 0 ] \\r\\ndo\\r\\nif [[ another[$max] -ne -1 ]]\\r\\nthen\\r\\nfor el in ${another[$max]}; do\\r\\necho \"${another[$max]} $max\"\\r\\ndone\\r\\nfi\\r\\n(( max-=1 ))\\r\\ndone\\r\\n```\\r\\n\\r\\nLast but not the least\\r\\nThis is one Liner solution\\r\\n\\r\\n```shell\\r\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\r\\n```\\r\\n\\r\\n",
                "solutionTags": [
                    "Bash",
                    "Shell"
                ],
                "code": "```Bash \\r\\n# Read from the file words.txt and output the word frequency list to stdout.\\r\\ndeclare -A hm\\r\\nmax=0\\r\\nwhile IFS=\\' \\' read -r -a line\\r\\ndo\\r\\n    for value in ${line[@]} \\r\\n        do \\r\\n            # echo $value\\r\\n            if [[ hm[$value] == -1 ]]\\r\\n                then \\r\\n                hm[$value]=1\\r\\n                else \\r\\n                (( hm[$value]+=1 ))\\r\\n                [[ hm[$value] -gt max ]] && (( max=hm[$value] ))\\r\\n            fi \\r\\n        done\\r\\ndone < \"words.txt\"\\r\\ndeclare -A another\\r\\nfor value in ${!hm[@]}; do \\r\\nif [[ another[${hm[$value]}] -eq -1 ]] ; then another[${hm[$value]}]=() ; fi\\r\\nanother[${hm[$value]}]+=$value\\r\\ndone\\r\\nwhile [ $max -gt 0 ] \\r\\ndo\\r\\nif [[ another[$max] -ne -1 ]]\\r\\nthen\\r\\nfor el in ${another[$max]}; do\\r\\necho \"${another[$max]} $max\"\\r\\ndone\\r\\nfi\\r\\n(( max-=1 ))\\r\\ndone\\r\\n```\n```shell\\r\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq --count | sort -r | awk \\'{print $2 \" \" $1}\\'\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409590,
                "title": "beats-86-easy-to-understand-code-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Detailed explanation of the bash script:\\n1. tr -s \\' \\' \\'\\\\n\\' < words.txt\\n\\nThis command uses the tr utility to replace all occurrences of one or more spaces with a newline character (\\\\n). The -s option squeezes repeated characters to a single character, so it ensures that consecutive spaces are treated as a single separator. The input for this command is read from the file words.txt.\\n\\n2. sort :\\n\\nThis command sorts the words alphabetically. Each word appears on a separate line thanks to the tr command.\\n\\n\\n3. uniq -c :\\n\\nThis command counts the frequency of each unique word. The -c option makes uniq output the count of each group of identical lines (i.e., each unique word).\\n\\n4. sort -nr :\\n\\nThis command sorts the output of uniq by frequency in descending order. The -n option tells sort to sort numerically, while the -r option tells it to sort in reverse order (i.e., descending).\\n\\n\\n5. awk \\'{print $2, $1}\\' :\\n\\nThis command uses awk to print the second field (the word) followed by the first field (the frequency), separated by a space. The output is sorted by frequency in descending order.\\n\\nSo overall, the script reads a text file words.txt, replaces all occurrences of one or more spaces with a newline character, sorts the resulting words alphabetically, counts the frequency of each unique word, sorts the words by frequency in descending order, and finally prints each word followed by its frequency separated by a space.\\n*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370688,
                "title": "192-word-frequency",
                "content": "# Intuition\\nHere\\'s a bash script that uses tr, sort, uniq, and awk commands to calculate the frequency of each word in a text file words.txt:\\n\\n# Approach\\nHere\\'s how it works:\\n\\ntr -s \\' \\' \\'\\\\n\\' < words.txt replaces every space character with a newline character, effectively converting the file into a list of words, one per line.\\nsort sorts the list of words in lexicographic order.\\nuniq -c counts the number of occurrences of each word and outputs the count followed by the word.\\nawk \\'{print $2 \" \" $1}\\' rearranges the output to have the word followed by its count.\\nsort -rn -k2 sorts the output in reverse numerical order based on the second field (the count).\\n\\n# Complexity\\nThe time and space complexity of the bash script to calculate the frequency of each word in a text file words.txt depends on the size of the input file and the number of distinct words in the file.\\n\\nLet\\'s analyze the individual commands used in the script:\\n\\ntr -s \\' \\' \\'\\\\n\\': This command reads the input file and replaces every space character with a newline character. The time complexity of this command is O(n), where n is the size of the input file. The space complexity is O(1), since the command only needs to store a few characters at a time.\\n\\nsort: This command sorts the list of words in lexicographic order. The time complexity of this command is O(n log n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words in memory to perform the sort.\\n\\nuniq -c: This command counts the number of occurrences of each word and outputs the count followed by the word. The time complexity of this command is O(n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nawk \\'{print $2 \" \" $1}\\': This command rearranges the output to have the word followed by its count. The time complexity of this command is O(n), where n is the number of words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nsort -rn -k2: This command sorts the output in reverse numerical order based on the second field (the count). The time complexity of this command is O(n log n), where n is the number of distinct words in the input file. The space complexity is O(n), since the command needs to store the list of words and their counts in memory.\\n\\nOverall, the time complexity of the script is O(n log n), where n is the number of words in the input file. The space complexity of the script is O(n), where n is the number of distinct words in the input file.\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | awk \\'{print $2 \" \" $1}\\' | sort -rn -k2\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ntr -s \\' \\' \\'\\\\n\\' < words.txt | sort | uniq -c | awk \\'{print $2 \" \" $1}\\' | sort -rn -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368097,
                "title": "using-awk-array",
                "content": "# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'{for(i=1;i<=NF;++i)count[$i]++;}END{for(i in count)print i, count[i]; }\\' words.txt | sort -r -n -k 2\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\nawk \\'{for(i=1;i<=NF;++i)count[$i]++;}END{for(i in count)print i, count[i]; }\\' words.txt | sort -r -n -k 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3335800,
                "title": "solution-step-by-step-explanation",
                "content": "Here\\'s a bash script to calculate the frequency of each word in a text file named **words.txt**. The script uses **awk** to split the input file into individual words and then uses **sort** and uniq to count the frequency of each word. Finally, **sort** is used again to **sort** the output by descending frequency.\\n\\n\\n> # Code\\n```\\n#!/bin/bash\\n\\n\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++) print $i}\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```\\n\\n\\n- **Explanation**:\\n\\n1. ***cat words.txt***: The cat command outputs the contents of the words.txt file to the standard output stream.\\n2. **awk {for(i=1;i<=NF;i++) print $i}**: The awk command splits each line of the input stream into individual words and outputs them to the standard output stream, one per line.\\n3. **tr -s \\' \\' \\'\\\\n\\'**: The tr command replaces all occurrences of the space character with a newline character, effectively splitting each line into individual words.\\n4. **sort**: The sort command sorts the input alphabetically.\\n5. **uniq -c**: The uniq command removes consecutive duplicate lines from the input and outputs the count of how many times each line occurred.\\n6. **sort -rn**: The second sort command sorts the output by the count of each word in descending order.\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/bash\\n\\n\\ncat words.txt | awk \\'{for(i=1;i<=NF;i++) print $i}\\' | sort | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173372,
                "title": "linux-pipe",
                "content": "# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\\n\\n# Step-by-step\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt\\n```\\n\\n> the\\n> day\\n> is\\n> sunny\\n> the\\n> the\\n> the\\n> sunny\\n> is\\n> is\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort\\n```\\n\\n> day\\n> is\\n> is\\n> is\\n> sunny\\n> sunny\\n> the\\n> the\\n> the\\n> the\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c\\n```\\n> 1 day\\n> 3 is\\n> 2 sunny\\n> 4 the\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r\\n```\\n\\n> 4 the\\n> 3 is\\n> 2 sunny\\n> 1 day\\n\\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\\n\\n> the 4\\n> is 3\\n> sunny 2\\n> day 1\\n",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r\\n```\n```\\ngrep -oE \\'[a-z]+\\' words.txt | sort | uniq -c | sort -r | awk \\'BEGIN{FS=\" \"} {print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3138563,
                "title": "clean-bash-high-speed-beats-98-9",
                "content": "# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090658,
                "title": "share-my-bash",
                "content": "```bash\\nfor i in $(cat words.txt); do echo $i; done | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```bash\\nfor i in $(cat words.txt); do echo $i; done | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -rn | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069417,
                "title": "word-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3056941,
                "title": "word-frequency-pipe-solution",
                "content": "One Liner || Easy Approach\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2974692,
                "title": "one-liner-with-tr-grep-uniq-sort-and-awk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple one liner to do the job:\\n* read file\\n* replace space with newline\\n* remove blank lines\\n* sort\\n* count unique words\\n* sort descending\\n* reverse word and count\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n  cat words.txt | tr \\' \\' \\'\\\\n\\' | grep  -E \\'\\\\w+\\' | sort -n | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n  cat words.txt | tr \\' \\' \\'\\\\n\\' | grep  -E \\'\\\\w+\\' | sort -n | uniq -c | sort -rn | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955398,
                "title": "simple-on-line-code",
                "content": "\\n\\n# Code\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{ print $2, $1 }\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2943097,
                "title": "my-one-liner-using-sed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nsed \\'s/ /\\\\\\'\\\\n\\'/g\\' words.txt |sed \\'/^$/d\\'| sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\nsed \\'s/ /\\\\\\'\\\\n\\'/g\\' words.txt |sed \\'/^$/d\\'| sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903345,
                "title": "using-tr-sort-uniq-read-tac-sed-not-in-one-line",
                "content": "```\\n#!/bin/sh\\nt=$(cat words.txt | tr \\'\\\\n\\' \\' \\' | tr -s \\' \\' | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | sed \"s/^[[:blank:]]*//g;s/[[:blank:]]*$//g\")\\nwhile read -r dat\\ndo\\n        echo $(echo $dat | tac -s \\' \\')\\ndone <<< $t\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n#!/bin/sh\\nt=$(cat words.txt | tr \\'\\\\n\\' \\' \\' | tr -s \\' \\' | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | sed \"s/^[[:blank:]]*//g;s/[[:blank:]]*$//g\")\\nwhile read -r dat\\ndo\\n        echo $(echo $dat | tac -s \\' \\')\\ndone <<< $t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886807,
                "title": "bash-script-arrays",
                "content": "# Intuition\\r\\nRead word by word the input text file and keep track of words read and update their absolute frequency with a counter.\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\nI used two vectors:\\r\\n1. wordList to keep track of words in the text\\r\\n2. freq to count the absolute freq of the words in wordList\\r\\n\\r\\nFor the same index i, the two vectors show the word with its absolute frequency.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n^2)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "solutionTags": [
                    "Bash",
                    "Array"
                ],
                "code": "```\\r\\n#!/bin/bash\\r\\n\\r\\ni=0\\r\\nfor word in $(cat words.txt)\\r\\ndo\\r\\n    j=0\\r\\n    flag=0\\r\\n    while [ $j -lt $i -a $flag -eq 0 ]\\r\\n    do\\r\\n        if [ \"${wordList[$j]}\" == \"$word\" ]\\r\\n        then\\r\\n            let freq[$j]=freq[$j]+1\\r\\n            flag=1\\r\\n        fi\\r\\n        let j=j+1\\r\\n    done\\r\\n\\r\\n    if [ $flag -eq 0 ]\\r\\n    then\\r\\n        wordList[$i]=\"$word\"\\r\\n        freq[$i]=1\\r\\n        let i=i+1\\r\\n    fi\\r\\ndone\\r\\n\\r\\nif [ $i -eq 0 ]\\r\\nthen\\r\\n    exit 0\\r\\nfi\\r\\n\\r\\nk=0\\r\\nwhile [ $k -lt $i ]\\r\\ndo\\r\\n    wordList[$k]=\"${wordList[$k]} ${freq[$k]}\"\\r\\n    let k=k+1\\r\\ndone\\r\\n\\r\\nprintf \"%s\\\\n\" \"${wordList[@]}\" | sort -k 2,2nr -k 1,1\\r\\n\\r\\nexit 0\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2881945,
                "title": "associative-array-bash-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nfile=words.txt\\n\\ndeclare -A array\\ncnt=1\\n\\nwhile read line\\ndo\\n     for word in $line\\n     do\\n       if [ -n \"${array[$word]}\" ]\\n       then\\n          array[\"$word\"]=$((${array[\"$word\"]} + 1))\\n       else\\n         array[\"$word\"]=1\\n       fi\\n     done\\ndone < $file\\n\\nfor key in \"${!array[@]}\"\\ndo\\necho $key ${array[$key]}\\ndone | sort -k2rn\\n\\n```",
                "solutionTags": [
                    "Bash"
                ],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n\\nfile=words.txt\\n\\ndeclare -A array\\ncnt=1\\n\\nwhile read line\\ndo\\n     for word in $line\\n     do\\n       if [ -n \"${array[$word]}\" ]\\n       then\\n          array[\"$word\"]=$((${array[\"$word\"]} + 1))\\n       else\\n         array[\"$word\"]=1\\n       fi\\n     done\\ndone < $file\\n\\nfor key in \"${!array[@]}\"\\ndo\\necho $key ${array[$key]}\\ndone | sort -k2rn\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812498,
                "title": "solution-using-awk-exclusively-runtime-62ms-beats-100-of-submissions",
                "content": "```bash\\nawk \\'\\nBEGIN {\\n    init = 0;\\n}\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (init == 0) {\\n            t[$i] = 1; #Initialize array that holds the number of times we see a word.\\n            init = 1;\\n        }\\n        else {\\n            if ($i in t) { # If word already in array\\n                t[$i] += 1;\\n            } \\n            else {\\n                t[$i] = 1;\\n            }\\n        }\\n    }\\n}\\nEND {\\n\\t#Traverse array elements values in descending numerical order\\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"; \\n    for (word in t) {\\n        print (word, t[word]);\\n    }\\n}\\n\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```bash\\nawk \\'\\nBEGIN {\\n    init = 0;\\n}\\n{\\n    for (i = 1; i <= NF; i++) {\\n        if (init == 0) {\\n            t[$i] = 1; #Initialize array that holds the number of times we see a word.\\n            init = 1;\\n        }\\n        else {\\n            if ($i in t) { # If word already in array\\n                t[$i] += 1;\\n            } \\n            else {\\n                t[$i] = 1;\\n            }\\n        }\\n    }\\n}\\nEND {\\n\\t#Traverse array elements values in descending numerical order\\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"; \\n    for (word in t) {\\n        print (word, t[word]);\\n    }\\n}\\n\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2629799,
                "title": "solution",
                "content": "```\\nsed -z \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "```\\nsed -z \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2528410,
                "title": "tr-grep-sort-uniq-sed-single-line-with-explanation",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\ntr \\' \\'  \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```\\n\\nFor explanation please refer:\\nhttps://leet-codes.blogspot.com/2022/09/192-word-frequency.html",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ntr \\' \\'  \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516734,
                "title": "solve-by-a-pipeline",
                "content": "``` bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [],
                "code": "``` bash\\ntr \\' \\' \\'\\\\n\\' < words.txt | grep -E \\'^[a-z]+$\\' | sort | uniq -c | sort -nr | sed -E \\'s/ +(.*) (.*)/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451304,
                "title": "faster-than-99-42-31-12-space",
                "content": "```\\nawk \\'{ for (i=1;i<=NF;i++) { counts[$i]++ } } END { for (k in counts) { print(k, counts[k]) } }\\' words.txt | sort -nrk2\\n```\\n\\nStores counts in an array in awk and spits them out at the end. `sort -nrk2` sorts numerically, reverse order, on 2nd column.\\n",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nawk \\'{ for (i=1;i<=NF;i++) { counts[$i]++ } } END { for (k in counts) { print(k, counts[k]) } }\\' words.txt | sort -nrk2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2404252,
                "title": "one-simple-and-quick-solution",
                "content": "#!/bin/bash\\n\\na=();\\ndeclare -A hash;\\nwhile IFS=\" \" read -r -a line; do\\n    for word in ${line[*]};do\\n        let \"hash[$word]+=1\";\\n    done\\ndone < words.txt\\n\\nfor i in ${!hash[@]};do\\n    echo $i ${hash[$i]};\\ndone | sort -k 2nr\\n",
                "solutionTags": [],
                "code": "#!/bin/bash\\n\\na=();\\ndeclare -A hash;\\nwhile IFS=\" \" read -r -a line; do\\n    for word in ${line[*]};do\\n        let \"hash[$word]+=1\";\\n    done\\ndone < words.txt\\n\\nfor i in ${!hash[@]};do\\n    echo $i ${hash[$i]};\\ndone | sort -k 2nr\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2184536,
                "title": "sed-with-awk-nf-to-filter-blank-lines",
                "content": "Nothing special, just some syntax simplification ideas.\\n```\\nsed \\'s/ /\\\\n/g\\' w* | awk NF | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/ /\\\\n/g\\' w* | awk NF | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119972,
                "title": "pure-bash-using-associative-arrays-and-sort",
                "content": "```\\ndeclare -A array\\nreadarray -t words < words.txt\\nfor w in ${words[@]}; do\\n    if [ -v \\'array[i]\\' ];then\\n        array[$w]=0\\n    else\\n        ((array[$w]+=1))\\n    fi\\ndone\\n\\nfor key in \"${!array[@]}\"; do\\n    echo $key ${array[$key]}\\ndone | sort -k2 -r -n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -A array\\nreadarray -t words < words.txt\\nfor w in ${words[@]}; do\\n    if [ -v \\'array[i]\\' ];then\\n        array[$w]=0\\n    else\\n        ((array[$w]+=1))\\n    fi\\ndone\\n\\nfor key in \"${!array[@]}\"; do\\n    echo $key ${array[$key]}\\ndone | sort -k2 -r -n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711091,
                "title": "use-tr",
                "content": "```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n\\n1. `tr -cs \"[:alpha:]\" \"\\\\n\" < words.txt ` One word perline\\n2. `sort | uniq -c` Precede each output line with the count of the number of times the line occurred\\n3. `sort -r` Descending sort order\\n4. `awk \\'{print $2\" \"$1}\\'` Output becareful space between two column\\n\\n\\nFor example:\\n\\nwords.txt\\n```txt\\nthe day is sunny the the\\nthe sunny is is\\na  a   b\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt\\n\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\na\\na\\nb\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r\\n   4 the\\n   3 is\\n   2 sunny\\n   2 a\\n   1 day\\n   1 b\\n```\\n\\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\nthe 4\\nis 3\\nsunny 2\\na 2\\nday 1\\nb 1\\n```\\n\\n\\t",
                "solutionTags": [],
                "code": "```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\n```txt\\nthe day is sunny the the\\nthe sunny is is\\na  a   b\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt\\n\\nthe\\nday\\nis\\nsunny\\nthe\\nthe\\nthe\\nsunny\\nis\\nis\\na\\na\\nb\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r\\n   4 the\\n   3 is\\n   2 sunny\\n   2 a\\n   1 day\\n   1 b\\n```\n```bash\\ntr -cs \"[:alpha:]\" \"\\\\n\" < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\nthe 4\\nis 3\\nsunny 2\\na 2\\nday 1\\nb 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411386,
                "title": "one-liner-with-xargs",
                "content": "cat words.txt | xargs | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "cat words.txt | xargs | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1401595,
                "title": "sed-grep-sort-uniq-awk",
                "content": "```\\nsed \\'s/ \\\\+/\\\\n/g\\' words.txt | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/ \\\\+/\\\\n/g\\' words.txt | grep -v \\'^$\\' | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388029,
                "title": "pure-awk-implementation-0ms-runtime",
                "content": "```\\nawk \\'\\n{\\n    for(i=1;i<=NF;i++) {\\n        ++map[$i]\\n    }\\n}\\n\\nEND {\\n    n=asorti(map, sorted, \"@val_num_asc\")\\n    for (i=n;i!=0;i--) {\\n        print sorted[i]\" \"map[sorted[i]]\\n    }\\n}\\n\\' words.txt\\n```",
                "solutionTags": [],
                "code": "```\\nawk \\'\\n{\\n    for(i=1;i<=NF;i++) {\\n        ++map[$i]\\n    }\\n}\\n\\nEND {\\n    n=asorti(map, sorted, \"@val_num_asc\")\\n    for (i=n;i!=0;i--) {\\n        print sorted[i]\" \"map[sorted[i]]\\n    }\\n}\\n\\' words.txt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197490,
                "title": "non-one-liner-s-benefits-memory-usage-3-1-mb-less-than-95-77",
                "content": "```\\ndeclare -r input_file=\"words.txt\"\\n\\nif ! [[ -f \"${input_file}\" ]]; then\\n    exit 1\\nfi\\n\\nunset -v words_freq\\ndeclare -A words_freq\\n\\n# Collect data from file\\nwhile IFS= read -r line || [ -n \"$line\" ]; do\\n    for word in ${line}; do ((words_freq[$word]++)); done\\ndone < ${input_file}\\n\\n# Output data sorted by frequency\\nfor word in ${!words_freq[@]}\\ndo\\n    echo -e \"${word} ${words_freq[$word]}\"\\ndone | sort -rn -k2\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare -r input_file=\"words.txt\"\\n\\nif ! [[ -f \"${input_file}\" ]]; then\\n    exit 1\\nfi\\n\\nunset -v words_freq\\ndeclare -A words_freq\\n\\n# Collect data from file\\nwhile IFS= read -r line || [ -n \"$line\" ]; do\\n    for word in ${line}; do ((words_freq[$word]++)); done\\ndone < ${input_file}\\n\\n# Output data sorted by frequency\\nfor word in ${!words_freq[@]}\\ndo\\n    echo -e \"${word} ${words_freq[$word]}\"\\ndone | sort -rn -k2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174939,
                "title": "fast-tr-awk-sort-pipeline-with-associative-array",
                "content": "I first relied two `sort` with `uniq -c`, but then I thought I could shorten the pipeline to just three processes like this, by using associative arrays from awk:\\n\\n```\\ntr \\' \\\\t\\\\n\\' \\'\\\\n\\' < words.txt | awk \\'(NF==1){count[$1]++} END{for (w in count) {print w, count[w];}}\\' | sort -k 2nr\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\ntr \\' \\\\t\\\\n\\' \\'\\\\n\\' < words.txt | awk \\'(NF==1){count[$1]++} END{for (w in count) {print w, count[w];}}\\' | sort -k 2nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144075,
                "title": "pure-bash-one-liner-code",
                "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print($2,$1)}\\'\\n\\ntr is  is a command-line utility in Linux and Unix systems that squezzes string using -s .",
                "solutionTags": [],
                "code": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print($2,$1)}\\'\\n\\ntr is  is a command-line utility in Linux and Unix systems that squezzes string using -s .",
                "codeTag": "Python3"
            },
            {
                "id": 1134791,
                "title": "with-awk-100-faster",
                "content": "```awk \\'{for(i=1;i<=NF;i++){a[$i]++}}END{for(i in a) print i\" \"a[i]}\\' words.txt |sort -k2nr```\\n",
                "solutionTags": [],
                "code": "```awk \\'{for(i=1;i<=NF;i++){a[$i]++}}END{for(i in a) print i\" \"a[i]}\\' words.txt |sort -k2nr```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112216,
                "title": "streamlining-pipe-and-sorting",
                "content": "`cat words.txt  | xargs | sed \\'s/\\\\ /\\\\n/g\\' | sort -d | uniq -c | sort -r | awk \\'{print $2, $1}\\' `",
                "solutionTags": [],
                "code": "`cat words.txt  | xargs | sed \\'s/\\\\ /\\\\n/g\\' | sort -d | uniq -c | sort -r | awk \\'{print $2, $1}\\' `",
                "codeTag": "Unknown"
            },
            {
                "id": 1086387,
                "title": "this-does-not-work-find-the-mistake-try-yourself",
                "content": "```\\nfor i in `cat words.txt`; do echo $i; done | sort | uniq -c | awk \\'FZ=\" \" {print $2,$1}\\' | sort -k2 -r\\n```\\n\\nbut this will run 100% faster \\n\\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'FS=\" \"{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `cat words.txt`; do echo $i; done | sort | uniq -c | awk \\'FZ=\" \" {print $2,$1}\\' | sort -k2 -r\\n```\n```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -nr | awk \\'FS=\" \"{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1056046,
                "title": "simple-and-easy-solution-100-fast",
                "content": "The below solution is 100% fast using awk, tr , sort and uniq.\\n\\n```bash\\ncat words.txt | tr \" \" \"\\\\n\" | awk \\'{print $1\"\\\\n\"}\\' | grep -v ^$ | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "solutionTags": [],
                "code": "The below solution is 100% fast using awk, tr , sort and uniq.\\n\\n```bash\\ncat words.txt | tr \" \" \"\\\\n\" | awk \\'{print $1\"\\\\n\"}\\' | grep -v ^$ | sort | uniq -c | sort -nr | awk \\'{print $2\" \"$1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1000886,
                "title": "one-line-solution-using-perl",
                "content": "perl -0777 -lape\\'s/\\\\s+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'",
                "solutionTags": [],
                "code": "perl -0777 -lape\\'s/\\\\s+/\\\\n/g\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2, $1}\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 966506,
                "title": "works-in-my-bash-shell-but-not-here",
                "content": "Anyone know why?  This runs perfectly on my comp.  Not here tho...  could \\'read\\' be the problem?\\n\\n```\\nwhile read -d \\' \\' word; do echo \"$word\"; done < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```\\n\\nThis produces no output in leetcode environment, but matches the reference output given using the same text on two different machines I tested it on...",
                "solutionTags": [],
                "code": "```\\nwhile read -d \\' \\' word; do echo \"$word\"; done < words.txt | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 965775,
                "title": "easy-one-liner",
                "content": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 871388,
                "title": "just-simple-awk",
                "content": "```\\nfile=\"words.txt\"\\n\\negrep -o \"\\\\b[[:alpha:]]+\\\\b\" $file | \\\\\\nawk \\'{ count[$0]++ }\\nEND {\\nfor(ind in count)\\n{ print ind \" \" count[ind]}\\n}\\' |  sort -k2 -nr\\n```",
                "solutionTags": [],
                "code": "```\\nfile=\"words.txt\"\\n\\negrep -o \"\\\\b[[:alpha:]]+\\\\b\" $file | \\\\\\nawk \\'{ count[$0]++ }\\nEND {\\nfor(ind in count)\\n{ print ind \" \" count[ind]}\\n}\\' |  sort -k2 -nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796172,
                "title": "0-ms-3-1-mb-background-task-with-for-loop",
                "content": "\\n```\\n#!/bin/bash\\nmany=$(sed \\'s/ /\\\\n/g\\' words.txt)\\nfor word in $(printf \"$many\" | sort -u)\\ndo\\n\\tprintf \"%s %d\\\\n\" $word $(printf \"$many\" | grep -w $word | wc -l) &\\ndone | sort -nru -k2\\n```\\n\\nThe key is to add the ```&``` to the end of the grep. This launches it as a background process. Without executing the grep operation as a background task, it takes 4 ms.",
                "solutionTags": [],
                "code": "```\\n#!/bin/bash\\nmany=$(sed \\'s/ /\\\\n/g\\' words.txt)\\nfor word in $(printf \"$many\" | sort -u)\\ndo\\n\\tprintf \"%s %d\\\\n\" $word $(printf \"$many\" | grep -w $word | wc -l) &\\ndone | sort -nru -k2\\n```\n```&```",
                "codeTag": "Unknown"
            },
            {
                "id": 714583,
                "title": "one-line-use-awk-and-sort-and-uniq-c",
                "content": "```\\ncat words.txt | awk \\'BEGIN{FS=\" \"}{for(i=1;i<=NF;i++){print $i}}\\' | sort | uniq -c | awk \\'BEGIN{FS=\" \"}{print $2,$1}\\' | sort -k2 -rn\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | awk \\'BEGIN{FS=\" \"}{for(i=1;i<=NF;i++){print $i}}\\' | sort | uniq -c | awk \\'BEGIN{FS=\" \"}{print $2,$1}\\' | sort -k2 -rn\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690248,
                "title": "accepted-solution-0ms-run-time",
                "content": "cat words.txt|sed -z \\'s|\\\\n| |g\\'|sed \\'s| \\\\+|\\\\n|g\\' |sort |uniq -c|sort -rn|awk \\'{print $2\" \"$1}\\'\\n",
                "solutionTags": [],
                "code": "cat words.txt|sed -z \\'s|\\\\n| |g\\'|sed \\'s| \\\\+|\\\\n|g\\' |sort |uniq -c|sort -rn|awk \\'{print $2\" \"$1}\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 602366,
                "title": "bash-pipe-solution",
                "content": "\\n\\n`cat words.txt |tr  \\' \\' \\'\\\\n\\' | sort | uniq -c |  sort -k1nr  | awk \\'{print$2\" \"$1}\\'`",
                "solutionTags": [],
                "code": "\\n\\n`cat words.txt |tr  \\' \\' \\'\\\\n\\' | sort | uniq -c |  sort -k1nr  | awk \\'{print$2\" \"$1}\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 543997,
                "title": "1-line-pipe-command",
                "content": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ngrep -o -E \\'\\\\w+\\' words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538900,
                "title": "one-line-using-piple",
                "content": "```cat words.txt | tr -s \\' \\' \\'\\\\n\\'  | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2\" \"$1}\\'```\\n\\nanother way(using loop and array) but it is not  the solution for this qustion \\nMy script \\n```\\n\\n#/bin/bash\\n#script will get how many times the word is repeated \\n#there might be other ways much much better than what i wrote\\n#file path\\nfile=$1\\n#store all words in this array\\narr=()\\n#store Unique Words\\narrU=()\\n\\n#loop in file and store the words in this arr\\nfor word in $(cat $file);\\ndo\\narr=(\"${arr[@]}\" \"$word\")\\ndone\\n\\nif [[ \"${#arr[@]}\" -gt 0 ]];then\\narrU=(\"${arr[0]}\")\\n# loop and store value in this arrU if no match was found\\nfor w in \"${arr[@]}\";\\ndo\\n  check=false\\n  for wu in \"${arrU[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcheck=true\\n\\tfi\\n  done\\n \\nif [[ \"$check\" = false ]];then\\n    arrU=(\"${arrU[@]}\" \"$w\")\\nfi\\ndone\\n\\n#count how many time the word is repeated\\nfor wu in \"${arrU[@]}\";\\ndo\\n  count=0\\n  for w in \"${arr[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcount=$((count + 1))\\t\\n\\tfi \\n  done\\n echo \"$wu $count\"\\ndone\\n\\nelse\\necho \"File is empty\"\\nfi\\n\\n```\\n\\nusage\\n\\n```\\n./frequency.sh words.txt | sort -rk 2\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cat words.txt | tr -s \\' \\' \\'\\\\n\\'  | sort | uniq -c | sort -nr -k 1 | awk \\'{print $2\" \"$1}\\'```\n```\\n\\n#/bin/bash\\n#script will get how many times the word is repeated \\n#there might be other ways much much better than what i wrote\\n#file path\\nfile=$1\\n#store all words in this array\\narr=()\\n#store Unique Words\\narrU=()\\n\\n#loop in file and store the words in this arr\\nfor word in $(cat $file);\\ndo\\narr=(\"${arr[@]}\" \"$word\")\\ndone\\n\\nif [[ \"${#arr[@]}\" -gt 0 ]];then\\narrU=(\"${arr[0]}\")\\n# loop and store value in this arrU if no match was found\\nfor w in \"${arr[@]}\";\\ndo\\n  check=false\\n  for wu in \"${arrU[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcheck=true\\n\\tfi\\n  done\\n \\nif [[ \"$check\" = false ]];then\\n    arrU=(\"${arrU[@]}\" \"$w\")\\nfi\\ndone\\n\\n#count how many time the word is repeated\\nfor wu in \"${arrU[@]}\";\\ndo\\n  count=0\\n  for w in \"${arr[@]}\";\\n  do\\n\\tif [[ \"$w\" = \"$wu\" ]];then\\n\\t\\tcount=$((count + 1))\\t\\n\\tfi \\n  done\\n echo \"$wu $count\"\\ndone\\n\\nelse\\necho \"File is empty\"\\nfi\\n\\n```\n```\\n./frequency.sh words.txt | sort -rk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535771,
                "title": "one-liner",
                "content": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | egrep \\'[a-zA-Z]+\\' | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \\' \\' \\'\\\\n\\' | sort | uniq -c | egrep \\'[a-zA-Z]+\\' | sort -r | awk \\'{print $2\" \"$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534704,
                "title": "one-liner-solution-faster-than-100",
                "content": "cat words.txt | sed \\'s/ /\\\\n/g\\' | sort | uniq -c | sort -r | sed \\'s/^ *//g\\' | sed \\'/[0-9]\\\\+ $/d\\' | awk \\'{ print $2\" \"$1 }\\'",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "cat words.txt | sed \\'s/ /\\\\n/g\\' | sort | uniq -c | sort -r | sed \\'s/^ *//g\\' | sed \\'/[0-9]\\\\+ $/d\\' | awk \\'{ print $2\" \"$1 }\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 525687,
                "title": "one-liner-0ms-must-be-some-sort-of-bug",
                "content": "```\\ncat words.txt | tr \" \" \"\\\\n\" |grep .|sort|uniq -c|sed \\'s/^ *//\\' | sort -rn | sed \\'s/^\\\\([0-9]\\\\+\\\\) \\\\([a-z]\\\\+\\\\).*/\\\\2 \\\\1/\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr \" \" \"\\\\n\" |grep .|sort|uniq -c|sed \\'s/^ *//\\' | sort -rn | sed \\'s/^\\\\([0-9]\\\\+\\\\) \\\\([a-z]\\\\+\\\\).*/\\\\2 \\\\1/\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524973,
                "title": "one-line-with-sed-and-awk",
                "content": "sed -E -e \\'s/[[:blank:]]+/\\\\n/g\\'  words.txt |sort |awk \\'{myword[$0]++} END {for (x in myword) print x,myword[x]}\\' |sort -k2,2 -r",
                "solutionTags": [],
                "code": "sed -E -e \\'s/[[:blank:]]+/\\\\n/g\\'  words.txt |sort |awk \\'{myword[$0]++} END {for (x in myword) print x,myword[x]}\\' |sort -k2,2 -r",
                "codeTag": "Unknown"
            },
            {
                "id": 524542,
                "title": "one-line-with-grep-sed-and-awk",
                "content": "\\n`cat words.txt  | sed \\'s/\\\\\\\\n/ /g\\' | sed \\'s/ /\\\\n/g\\' | sort | uniq -c  | sort -rn | awk \\'{print $2\" \"$1}\\' | grep -Ev \\'^\\\\s\\'`",
                "solutionTags": [],
                "code": "\\n`cat words.txt  | sed \\'s/\\\\\\\\n/ /g\\' | sed \\'s/ /\\\\n/g\\' | sort | uniq -c  | sort -rn | awk \\'{print $2\" \"$1}\\' | grep -Ev \\'^\\\\s\\'`",
                "codeTag": "Unknown"
            },
            {
                "id": 499314,
                "title": "funny-solution",
                "content": "I\\'m not good at bash scripting, but at least can show my funny solution\\n```\\ninput=$(\\nthings=$(cat words.txt); \\nfor thing in $things; \\ndo echo $thing; \\ndone | \\nsort | \\nuniq -c | \\nsort -nr); \\narr=($input); \\nfor ((i=1; i<=${#arr[@] + 1}; i+=2)) do \\necho \"${arr[i]//[$\\'\\\\t\\\\r\\\\n\\']} ${arr[i-1]//[$\\'\\\\t\\\\r\\\\n\\']}\"; \\ndone\\n```",
                "solutionTags": [],
                "code": "```\\ninput=$(\\nthings=$(cat words.txt); \\nfor thing in $things; \\ndo echo $thing; \\ndone | \\nsort | \\nuniq -c | \\nsort -nr); \\narr=($input); \\nfor ((i=1; i<=${#arr[@] + 1}; i+=2)) do \\necho \"${arr[i]//[$\\'\\\\t\\\\r\\\\n\\']} ${arr[i-1]//[$\\'\\\\t\\\\r\\\\n\\']}\"; \\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498257,
                "title": "help-why-did-i-get-wrong-answer-with-the-same-output-as-expected",
                "content": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n#!/bin/bash\\n\\nn=\"$( cat words.txt | tr \\' \\' \\'\\\\n\\' | sort  | uniq -c | tr -s \\' \\' | cut -d \" \" -f 3,2 )\"\\nr=\"\"\\nlet count=0\\nfor i in $n\\ndo\\n\\n    (( $count%2==0 )) && (( $count>1 )) && r=\"\\\\n$r\"\\n    let count++\\n    r=\"$i $r\"\\n\\ndone\\necho -e \"$r\"\\n```\\n![image](https://assets.leetcode.com/users/yyuze/image_1580747168.png)\\n",
                "solutionTags": [],
                "code": "```\\n# Read from the file words.txt and output the word frequency list to stdout.\\n#!/bin/bash\\n\\nn=\"$( cat words.txt | tr \\' \\' \\'\\\\n\\' | sort  | uniq -c | tr -s \\' \\' | cut -d \" \" -f 3,2 )\"\\nr=\"\"\\nlet count=0\\nfor i in $n\\ndo\\n\\n    (( $count%2==0 )) && (( $count>1 )) && r=\"\\\\n$r\"\\n    let count++\\n    r=\"$i $r\"\\n\\ndone\\necho -e \"$r\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498144,
                "title": "less-then-100-others-by-memory-usage-for-now",
                "content": "0ms, 3.1mb\\n\\n`sed \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt| sort | uniq -c |sort -nr | sed -e \\'s/\\\\s\\\\+\\\\([0-9]\\\\+\\\\)\\\\s\\\\+\\\\(.\\\\+\\\\)/\\\\2 \\\\1/;t;d\\'` \\n\\nIt was my first try, so I will try to optimize it.",
                "solutionTags": [],
                "code": "0ms, 3.1mb\\n\\n`sed \\'s/\\\\s\\\\+/\\\\n/g\\' words.txt| sort | uniq -c |sort -nr | sed -e \\'s/\\\\s\\\\+\\\\([0-9]\\\\+\\\\)\\\\s\\\\+\\\\(.\\\\+\\\\)/\\\\2 \\\\1/;t;d\\'` \\n\\nIt was my first try, so I will try to optimize it.",
                "codeTag": "Unknown"
            },
            {
                "id": 488733,
                "title": "any-reason-i-m-getting-rbash-prog-sh-permission-denied",
                "content": "rbash: ./prog.sh: Permission denied for:\\n```\\nfor i in `cat words.txt`; do echo $i ; done|sort|uniq -c|sort -nr| awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\nfor i in `cat words.txt`; do echo $i ; done|sort|uniq -c|sort -nr| awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487926,
                "title": "my-solution",
                "content": "```\\nlist=($(cat words.txt | awk \"/[a-z]+/\"))\\nprintf \"%s\\\\n\" \"${list[@]}\" | sort | uniq -c | sort -k2 -r -n | awk \\'{printf \"%s %s\\\\n\", $2, $1}\\'\\n```\\nFirst I put all the lowercase words inside of an array. The OFS will automatically separate the array by space\\nNext I print out sort the array by uniqueness and output the count as well. Since the fields should be switched and not sorted by descending order, I put it through another sort and pipe it to another awk, where I switch the fields.",
                "solutionTags": [],
                "code": "```\\nlist=($(cat words.txt | awk \"/[a-z]+/\"))\\nprintf \"%s\\\\n\" \"${list[@]}\" | sort | uniq -c | sort -k2 -r -n | awk \\'{printf \"%s %s\\\\n\", $2, $1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459274,
                "title": "1-line-100-faster",
                "content": "```\\ntr \"\\\\n\" \" \" < words.txt |  tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ntr \"\\\\n\" \" \" < words.txt |  tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -r | awk \\'{print $2,$1}\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456146,
                "title": "one-liner",
                "content": "```\\ntr \\' \\' \\'\\\\12\\' < words.txt  | sed \\'/^$/d\\'| sort |uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntr \\' \\' \\'\\\\12\\' < words.txt  | sed \\'/^$/d\\'| sort |uniq -c | sort -nr | awk \\'{print $2, $1}\\'\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432579,
                "title": "easy-to-understand-iteration-associative-array",
                "content": "```bash\\ndeclare -A WORD_FREQ_TABLE\\n\\ncat words.txt |\\n(while read line; do\\n    for word in $line; do\\n\\t# if the word does not exist\\n\\tif [ ${WORD_FREQ_TABLE[\"$word\"]+_} ]; then\\n\\t    WORD_FREQ_TABLE[\"$word\"]=$(( WORD_FREQ_TABLE[\"$word\"] + 1 ))\\n\\telse\\n\\t    WORD_FREQ_TABLE[\"$word\"]=1\\n\\tfi\\n    done\\ndone\\n\\nfor item in \"${!WORD_FREQ_TABLE[@]}\"; do\\n    echo \"$item\"  ${WORD_FREQ_TABLE[\"$item\"]}\\ndone | sort -r -k2 -n)",
                "solutionTags": [],
                "code": "```bash\\ndeclare -A WORD_FREQ_TABLE\\n\\ncat words.txt |\\n(while read line; do\\n    for word in $line; do\\n\\t# if the word does not exist\\n\\tif [ ${WORD_FREQ_TABLE[\"$word\"]+_} ]; then\\n\\t    WORD_FREQ_TABLE[\"$word\"]=$(( WORD_FREQ_TABLE[\"$word\"] + 1 ))\\n\\telse\\n\\t    WORD_FREQ_TABLE[\"$word\"]=1\\n\\tfi\\n    done\\ndone\\n\\nfor item in \"${!WORD_FREQ_TABLE[@]}\"; do\\n    echo \"$item\"  ${WORD_FREQ_TABLE[\"$item\"]}\\ndone | sort -r -k2 -n)",
                "codeTag": "Unknown"
            },
            {
                "id": 432428,
                "title": "my-accepted-solution",
                "content": "```cat words.txt | sed \"s/ /\\\\n/g\" | grep -v \"^$\" | sort | uniq -c | awk \\'{print $2 \" \" $1}\\'```",
                "solutionTags": [],
                "code": "```cat words.txt | sed \"s/ /\\\\n/g\" | grep -v \"^$\" | sort | uniq -c | awk \\'{print $2 \" \" $1}\\'```",
                "codeTag": "Unknown"
            },
            {
                "id": 402732,
                "title": "my-accepted-answer-using-for-loop-grep-and-without-using-awk",
                "content": "```\\nfor i in `sed \\'s/ /\\\\n/g\\' words.txt | sort -u`; do echo -ne $i; echo -ne \" \"; sed \\'s/ /\\\\n/g\\' words.txt | grep -wc $i; done | sort -k 2 -nr\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor i in `sed \\'s/ /\\\\n/g\\' words.txt | sort -u`; do echo -ne $i; echo -ne \" \"; sed \\'s/ /\\\\n/g\\' words.txt | grep -wc $i; done | sort -k 2 -nr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374308,
                "title": "one-line-solution-using-pipe",
                "content": "```\\nsed \\'s/^  *//g\\' words.txt | sed \\'s/  *$//g\\'| sed \\'s/  */\\\\n/g\\' | sort | uniq -c | sort -rn | sed \\'s/^ *\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2 \\\\1/g\\'\\n```",
                "solutionTags": [],
                "code": "```\\nsed \\'s/^  *//g\\' words.txt | sed \\'s/  *$//g\\'| sed \\'s/  */\\\\n/g\\' | sort | uniq -c | sort -rn | sed \\'s/^ *\\\\(.*\\\\) \\\\(.*\\\\)/\\\\2 \\\\1/g\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355301,
                "title": "common-awk-solution-it-is-very-easy-to-understand",
                "content": "```\\ncat words.txt| awk \\'{for(i=1;i<=NF;i++){count[$i]++}}END{for(k in count){print k \" \"count[k]}}\\'|sort -rnk 2\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt| awk \\'{for(i=1;i<=NF;i++){count[$i]++}}END{for(k in count){print k \" \"count[k]}}\\'|sort -rnk 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354236,
                "title": "one-line-with-pipes",
                "content": "```\\ncat words.txt | tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "solutionTags": [],
                "code": "```\\ncat words.txt | tr -s \" \" \"\\\\n\" | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565744,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566014,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1568235,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566764,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570458,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570253,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569478,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569010,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569011,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1575333,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1565744,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566014,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1568235,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1566764,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570458,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1570253,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569478,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569010,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1569011,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1575333,
                "content": [
                    {
                        "username": "wudeng",
                        "content": "    tr -s ' ' '\\\\n' < words.txt|sort|uniq -c|sort -nr|awk '{print $2, $1}'"
                    },
                    {
                        "username": "Roka",
                        "content": "`cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort | uniq -c | sort -r | awk \\'{print $2\" \"$1}\\'`"
                    },
                    {
                        "username": "SilviaChow",
                        "content": "cat words.txt | tr -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr -k2 |awk \\'{print $2,$1}\\'\\n"
                    },
                    {
                        "username": "fabrizio3",
                        "content": "    cat words.txt | tr '\\\\n' ' ' | sed \"s/\\\\s\\\\s*/ /g\" | awk -v RS=' ' '{print $0}' | sort | uniq -c | sort -nr -k1 | awk '{print $2\" \"$1}'\\n\\n**cat word.txt** :\\noutput the text in the file\\n\\n**tr '\\\\n' ' '** :\\nsubstitute endlines with single space\\n\\n**sed \"s/\\\\s\\\\s*/ /g\"** :\\nsubstitute multiple spaces with single space\\n\\n**awk -v RS=' ' '{print $0}'** :\\noutput one word per line by changing Record Separator in AWK to single space. $0 is the entire record (1 word).\\n\\n**sort** :\\nsort alphabetically the list of words (with repetitions) to prepare it for uniq command.\\n\\n**uniq -c** :\\nprint the list of unique words with their count. Before uniq you need to sort the list of words.\\n\\n**sort -nr -k1** :\\nsort the list of unique words by their count  (-nr numerical reverse sorting) (-k1 sort by the first field that is the count of repetitions for the current word)\\n\\n**awk '{print $2\" \"$1}'** :\\nfor each line print before the second field $2, that is the word, and then the first field that is the count of repetitions for the word."
                    },
                    {
                        "username": "trevormccormick",
                        "content": "`echo `cat words.txt` | tr \"[:space:]+\" \"\\\\n\" | sort | uniq -c | sort -k 1nr | sed \\'s/^ *//g\\' | awk \\'{print $2 \" \" $1}\\'`\\n\\n1. Pipe in content of words.txt\\n2. Translate one or more spaces into newlines\\n3. Sort the file line by line, ascending\\n4. Count how many times each of the lines appears in the file (output will be two columns: first is count, second is line\\n5. Sort the output \\n\\t* -k: sort by key (in this case column, pairs with -t)\\n\\t* 1: sort by firt column\\n\\t* -n: sort as a number\\n\\t* -r: reverse order\\n6. Remove any leading whitespace using sed\\n7. Print the output as second column, then space, then first column"
                    },
                    {
                        "username": "JimPerlGuy",
                        "content": "for word in `cat words.txt`;do echo $word; done|sort|uniq -c|sort -r|awk \\'{print $2,$1}\\'\\n\\n\\nused *for* with cat to cycle through each word in the txt file.\\n\\nthen used *sort* to output by word\\n\\nused *uniq* to count unique words\\n\\nused *sort -r* to reverse the order as descending\\n\\nThe output was backwards (count then word)\\n   4 the\\n   3 is\\n   2 sunny\\n   1 day\\nSo used *awk* to reverse (word then count)"
                    },
                    {
                        "username": "kenumida",
                        "content": "when python is largely avaibale, what\\'s the point of using bash to process files?"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "You are not restricted from using python for this task. Just start with `python -c \\'`and do whatever you want. However, you hardly can achieve one-line (not actually disadvantage), a pythonic solution most likely will be significantly slower than most of bash ones (true disadvantage). "
                    },
                    {
                        "username": "lemonlinger",
                        "content": "    grep -oE '[a-z]+' words.txt | sort | uniq -c | sort -r | awk '{print $2\" \"$1}' \\n\\nbut it costs 20ms."
                    },
                    {
                        "username": "lonelinsky",
                        "content": "sed 's/^\\\\s\\\\+//g; s/\\\\s\\\\+/ /g; s/\\\\s\\\\+$//g' words.txt | tr ' ' '\\\\n' | sort | uniq -c | sort -nr | awk -F' ' '{print $2\" \"$1}'\\n\\n1. use sed to strip head & tail spaces\\uff0cand change inline spaces to one space\\n2. use tr to trans space to return (these two steps also can be done cat words.txt | tr -s ' ' '\\\\n') \\n3. sort the words\\n4. uniq to count words\\n5. sort the stats result\\uff0c-n for numeric sort\\uff0c-r for reverse\\n6. use awk to format the output"
                    },
                    {
                        "username": "Yukariii",
                        "content": "`awk \\'{for (i = 1; i <= NF; i++) {cnt[$i]++}} END {for (w in cnt) {print w,cnt[w]}}\\' words.txt | sort -k2nr`\\n- Use `awk` to count how many times each word appears.\\n- Sort the result descendingly using `sort` ."
                    }
                ]
            },
            {
                "id": 1574095,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1573493,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572958,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572647,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1572449,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1571408,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 2044719,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670646,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670644,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            },
            {
                "id": 1670562,
                "content": [
                    {
                        "username": "matthew_boyd",
                        "content": "cat words.txt | tr -s \\' \\' \\'\\\\n\\' | sort |  uniq -c | awk \\'{printf(\"%s %s\\\\n\", $2, $1)}\\' | sort -k2nr"
                    },
                    {
                        "username": "huntekah",
                        "content": "tr -s \" \" < words.txt | tr \" \" $\\'\\\\n\\' | sort | uniq -c | sort -nr | sed -r \"s/\\\\s*([0-9]+)\\\\s*([a-z]+)/\\\\2 \\\\1/\" | grep -e \"[a-z]\""
                    },
                    {
                        "username": "totofoo",
                        "content": "egrep -o \"\\\\w+\" words.txt | sort | uniq -c | sort -nr | awk \\'{print $2 \" \" $1}\\'\\n\\nCommands explanation\\negrep -o \"\\\\w+\" words.txt\\nselect words(regex words) only. So anything that is not a word is filtered out. things like \"\\\\n\\\\n\"\\n\\nsort | uniq -c | sort -nr\\nfirst sort is needed because uniq assumes the list is sorted\\nuniq -c counts occurences of each word\\nsort -nr sorts final result as nums and in reverse order so that most frequent words appear on top\\n\\nawk \\'{print $2 \" \" $1}\\'\\nwith out this statement, the result would be : frequency word\\nwith awk, we are able to take first argument (frequency) and second argument (word) and reverse their order by printing the second one (word) first, then first one(frequency) second.\\n\\n\\n\\n"
                    },
                    {
                        "username": "xiaozhi_y",
                        "content": "cat words.txt | sed \\':a;N;$!ba;s/\\\\n/ /g\\' | sed \\'s/ \\\\+/\\\\n/g\\' | sort | uniq -c | sort -k1nr | awk \\'{print $2, $1}\\'\\n![image](https://assets.leetcode.com/users/xiaozhi_y/image_1556540351.png)\\n"
                    },
                    {
                        "username": "SeqList",
                        "content": "cat words.txt|xargs -n 1|sort|uniq -c|sort -nr|awk \\'{print $2\" \"$1}\\'"
                    },
                    {
                        "username": "andyhansmall1001",
                        "content": "    tr < words.txt -cs \"[a-z]\" \"\\\\n\" | sort | uniq -c | sort -k1nr | awk '{print $2, $1}'\\n\\nIt is easy, huh?"
                    },
                    {
                        "username": "21bd1a0547csec",
                        "content": "where can I learn Bash scripting"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "It will use another file, just to remove duplicates in the file."
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\\n\\nwhile read line\\ndo\\n  for var in $line\\n   do\\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\\n    echo \"$var ::: $word_cnt >> sorted.txt\"\\n   done\\ndone < words.txt\\n\\nsort -u sorted.txt\\n"
                    },
                    {
                        "username": "shashankpriyadarshi",
                        "content": "rm -f sorted\n\nwhile read line\ndo\n  for var in $line\n   do\n\n    word_cnt=`grep -w -o \"$var\" words.txt | wc -w`\n    echo \"$var ::: $word_cnt >> sorted.txt\"\n\n   done\ndone < words.txt\n\nsort -u sorted.txt\n"
                    }
                ]
            }
        ]
    }
]