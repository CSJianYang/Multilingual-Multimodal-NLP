[
    {
        "title": "Find the Minimum and Maximum Number of Nodes Between Critical Points",
        "question_content": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any&nbsp;two distinct critical points and maxDistance is the maximum distance between any&nbsp;two distinct critical points. If there are fewer than two critical points, return [-1, -1].\n&nbsp;\nExample 1:\n\nInput: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].\n\nExample 2:\n\nInput: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.\n\nExample 3:\n\nInput: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [2, 105].\n\t1 <= Node.val <= 105",
        "solutions": [
            {
                "id": 1549991,
                "title": "one-pass",
                "content": "To make it simple, we track:\\n- `first` and `last` indexes of local min/max.\\n- the value of the previous node `prev_val`.\\n- smallest difference between two adjacent indices (current `i` minus `last`) as `min_d`.\\n\\nThe result is `{min_d, last - first}`.\\n\\nThe complexity of this solution is *O(n)* time and *O(1)* memory.\\n\\n**C++**\\n```cpp\\nvector<int> nodesBetweenCriticalPoints(ListNode* h) {\\n    int first = INT_MAX, last = 0, prev_val = h->val, min_d = INT_MAX;\\n    for (int i = 0; h->next != nullptr; ++i) {\\n        if ((max(prev_val, h->next->val) < h->val) || \\n            (min(prev_val, h->next->val) > h->val)) {\\n            if (last != 0)\\n                min_d = min(min_d, i - last);\\n            first = min(first, i);\\n            last = i;\\n        }\\n        prev_val = h->val;\\n        h = h->next;\\n    }\\n    if (min_d == INT_MAX)\\n        return {-1, -1};\\n    return {min_d, last - first};\\n}\\n```\\n**Java**\\n```java\\npublic int[] nodesBetweenCriticalPoints(ListNode h) {\\n    int first = Integer.MAX_VALUE, last = 0, prev_val = h.val, min_d = Integer.MAX_VALUE;\\n    for (int i = 0; h.next != null; ++i) {\\n        if ((prev_val < h.val && h.val > h.next.val) || \\n            (prev_val > h.val && h.val < h.next.val)) {\\n            if (last != 0)\\n                min_d = Math.min(min_d, i - last);\\n            first = Math.min(first, i);\\n            last = i;\\n        }\\n        prev_val = h.val;\\n        h = h.next;\\n    }        \\n    if (min_d == Integer.MAX_VALUE)\\n        return new int[] {-1, -1};\\n    return new int[] {min_d, last - first};\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nvector<int> nodesBetweenCriticalPoints(ListNode* h) {\\n    int first = INT_MAX, last = 0, prev_val = h->val, min_d = INT_MAX;\\n    for (int i = 0; h->next != nullptr; ++i) {\\n        if ((max(prev_val, h->next->val) < h->val) || \\n            (min(prev_val, h->next->val) > h->val)) {\\n            if (last != 0)\\n                min_d = min(min_d, i - last);\\n            first = min(first, i);\\n            last = i;\\n        }\\n        prev_val = h->val;\\n        h = h->next;\\n    }\\n    if (min_d == INT_MAX)\\n        return {-1, -1};\\n    return {min_d, last - first};\\n}\\n```\n```java\\npublic int[] nodesBetweenCriticalPoints(ListNode h) {\\n    int first = Integer.MAX_VALUE, last = 0, prev_val = h.val, min_d = Integer.MAX_VALUE;\\n    for (int i = 0; h.next != null; ++i) {\\n        if ((prev_val < h.val && h.val > h.next.val) || \\n            (prev_val > h.val && h.val < h.next.val)) {\\n            if (last != 0)\\n                min_d = Math.min(min_d, i - last);\\n            first = Math.min(first, i);\\n            last = i;\\n        }\\n        prev_val = h.val;\\n        h = h.next;\\n    }        \\n    if (min_d == Integer.MAX_VALUE)\\n        return new int[] {-1, -1};\\n    return new int[] {min_d, last - first};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549980,
                "title": "short-easy-c",
                "content": "**TC : O(n)\\nSC : O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *prev=head;\\n        head=head->next;\\n        int i=1;\\n        vector<int> index;\\n        while(head->next){\\n            if((prev->val < head->val and head->val > head->next->val) ||( prev->val > head->val and head->val < head->next->val)){\\n                index.push_back(i);\\n            }\\n            prev=head;\\n            head=head->next;\\n            i++;\\n        }\\n        if(index.size() < 2) return {-1,-1};\\n        \\n        int mindist=INT_MAX;\\n        for(int i=0;i<index.size()-1;i++){\\n            mindist=min(index[i+1]-index[i],mindist);\\n        }\\n        return {mindist,index.back()-index[0]};\\n    }\\n};\\n```\\n**TC : O(n)\\nSC : O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *prev=head;\\n        head=head->next;\\n        int i=1,mindist=INT_MAX,prev_i=INT_MIN,first_i=-1;\\n        while(head->next){\\n            if((prev->val < head->val and head->val > head->next->val) ||( prev->val > head->val and head->val < head->next->val)){\\n                if(prev_i!=INT_MIN) mindist=min(mindist,i-prev_i);\\n                if(first_i==-1) first_i=i;\\n                prev_i=i;\\n            }\\n            prev=head;\\n            head=head->next;\\n            i++;\\n        }\\n        if(mindist==INT_MAX) return {-1,-1};\\n        return {mindist,prev_i-first_i};\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *prev=head;\\n        head=head->next;\\n        int i=1;\\n        vector<int> index;\\n        while(head->next){\\n            if((prev->val < head->val and head->val > head->next->val) ||( prev->val > head->val and head->val < head->next->val)){\\n                index.push_back(i);\\n            }\\n            prev=head;\\n            head=head->next;\\n            i++;\\n        }\\n        if(index.size() < 2) return {-1,-1};\\n        \\n        int mindist=INT_MAX;\\n        for(int i=0;i<index.size()-1;i++){\\n            mindist=min(index[i+1]-index[i],mindist);\\n        }\\n        return {mindist,index.back()-index[0]};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *prev=head;\\n        head=head->next;\\n        int i=1,mindist=INT_MAX,prev_i=INT_MIN,first_i=-1;\\n        while(head->next){\\n            if((prev->val < head->val and head->val > head->next->val) ||( prev->val > head->val and head->val < head->next->val)){\\n                if(prev_i!=INT_MIN) mindist=min(mindist,i-prev_i);\\n                if(first_i==-1) first_i=i;\\n                prev_i=i;\\n            }\\n            prev=head;\\n            head=head->next;\\n            i++;\\n        }\\n        if(mindist==INT_MAX) return {-1,-1};\\n        return {mindist,prev_i-first_i};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555778,
                "title": "one-pass-explained-time-o-n-space-o-1",
                "content": "* Keep Two Pointers - One for traversing \"curr\" in my solution and \"prev\" to track last node\\n* To make solution simple declare variables for minDistance with large value, maxDistance as smallest value, length (size), First Critical Point ( first ) and Previous Critical Point ( preCP ).\\n* While traversing a linkedList check if it is Local Maxima or Local Minima\\n* For the first Local Maxima/Minima we will only update firstCP variable as having lesser than two CP we can\\'t find distance hence ```return {-1,-1};```\\n* For all next LocalMinima Or Maxima we will update as follows \\n```\\nminDistance = min(minDistance, size - preCP);    //  difference of just prev and curr CP\\nmaxDistance = max(maxDistance, size - first);    // difference of first and curr CP\\n```\\nLastly \\n```\\nreturn {minDistance == INT_MAX ? -1 : minDistance, maxDistance};\\n```\\n\\nCode\\n\\n```\\nclass Solution {\\n   public:\\n    vector<int> nodesBetweenCriticalPoints(ListNode *head) {\\n        ListNode *curr = head, *prev = NULL;\\n        int minDistance = INT_MAX, maxDistance = -1, size = 0, preCP = 0,\\n            first = 0;\\n        while (curr) {\\n            if (curr->next && prev) {\\n                if ((curr->val < prev->val && curr->val < curr->next->val) ||\\n                    (curr->val > prev->val && curr->val > curr->next->val)) {\\n                    if (first == 0) {\\n                        first = size;\\n                    } else {\\n                        minDistance = min(minDistance, size - preCP);\\n                        maxDistance = max(maxDistance, size - first);\\n                    }\\n                    preCP = size;\\n                }\\n            }\\n            size++;\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return {minDistance == INT_MAX ? -1 : minDistance, maxDistance};\\n    }\\n};\\n```\\n\\n```\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n```\\n**Feel free to ask any question in the comment section.**",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```return {-1,-1};```\n```\\nminDistance = min(minDistance, size - preCP);    //  difference of just prev and curr CP\\nmaxDistance = max(maxDistance, size - first);    // difference of first and curr CP\\n```\n```\\nreturn {minDistance == INT_MAX ? -1 : minDistance, maxDistance};\\n```\n```\\nclass Solution {\\n   public:\\n    vector<int> nodesBetweenCriticalPoints(ListNode *head) {\\n        ListNode *curr = head, *prev = NULL;\\n        int minDistance = INT_MAX, maxDistance = -1, size = 0, preCP = 0,\\n            first = 0;\\n        while (curr) {\\n            if (curr->next && prev) {\\n                if ((curr->val < prev->val && curr->val < curr->next->val) ||\\n                    (curr->val > prev->val && curr->val > curr->next->val)) {\\n                    if (first == 0) {\\n                        first = size;\\n                    } else {\\n                        minDistance = min(minDistance, size - preCP);\\n                        maxDistance = max(maxDistance, size - first);\\n                    }\\n                    preCP = size;\\n                }\\n            }\\n            size++;\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        return {minDistance == INT_MAX ? -1 : minDistance, maxDistance};\\n    }\\n};\\n```\n```\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550147,
                "title": "short-and-easy-c-beginner-friendly",
                "content": "This is a very simple approach and easy to understand for beginners \\nFor sake of understanding \\nlets consider a  example :\\n Input: head = [5,3,1,2,5,1,2]\\n so here what will be the next step;\\n lets take a empty vector of int;\\n i have attached a image check it out.\\n 1. it will [![image](https://assets.leetcode.com/users/images/840afcfb-b46e-44fd-acf7-4dbef33ae504_1635655499.54518.jpeg)\\n]\\n\\'\\'\\'\\n**class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n         if(!head || !head->next || !head->next->next) return {-1,-1};\\n        ListNode *prev=head;\\n        head=head->next;\\n       \\n        \\n            \\n        vector<int> index;\\n        int i = 1;\\n        while(head->next){\\n            if((prev->val < head->val && head->val > head->next->val) ||( prev->val > head->val && head->val < head->next->val)){\\n                index.push_back(i);\\n            }\\n            prev=head;\\n            head=head->next;\\n            i++;\\n        }\\n        \\n        if(index.size() < 2)\\n            return {-1,-1};\\n        int localminima = INT_MAX;\\n            for(int l = 0 ; l < index.size()-1;l++)\\n            {\\n                localminima = min(index[l+1] - index[l],localminima);\\n            }\\n        \\n        return {localminima , index.back()-index[0]};\\n    }**\\n};\\n\\'\\'\\'\\nTC - 0(N)\\nSC - 0(N);",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n         if(!head || !head->next || !head->next->next) return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1558852,
                "title": "python-easy-solution",
                "content": "class Solution:\\n\\t\\n\\tdef nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        prev = None\\n        temp = head\\n        \\n        mini, maxi = 10 ** 5, 0\\n        count = 1\\n        \\n        diff = 10 ** 5\\n        while temp.next.next != None:\\n            prev = temp\\n            temp = temp.next\\n            count += 1\\n            \\n            if prev.val > temp.val < temp.next.val or prev.val < temp.val > temp.next.val:\\n            \\n                if maxi != 0:\\n                    mini = min(mini, count - maxi)\\n                diff = min(diff, count)\\n                maxi = count\\n        \\n        if diff == 10 ** 5 or mini == 10 ** 5:\\n            return [-1, -1]\\n        return [mini, maxi - diff]\\n\\t\\t\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "class Solution:\\n\\t\\n\\tdef nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        prev = None\\n        temp = head\\n        \\n        mini, maxi = 10 ** 5, 0\\n        count = 1\\n        \\n        diff = 10 ** 5\\n        while temp.next.next != None:\\n            prev = temp\\n            temp = temp.next\\n            count += 1\\n            \\n            if prev.val > temp.val < temp.next.val or prev.val < temp.val > temp.next.val:\\n            \\n                if maxi != 0:\\n                    mini = min(mini, count - maxi)\\n                diff = min(diff, count)\\n                maxi = count\\n        \\n        if diff == 10 ** 5 or mini == 10 ** 5:\\n            return [-1, -1]\\n        return [mini, maxi - diff]\\n\\t\\t\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1550686,
                "title": "easy-java-soln-beats-100-without-using-array-arraylist",
                "content": "Traversing the Linked-List to check for the critical points and maintaining the` minimum_index , last_index and current_index`\\nAlso checking for the minimum distance between the critical point index at each traversal.\\nThe maximum distance at end of traversal will be `current_index - minimum_index`\\n\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int res[]=new int[]{-1,-1};\\n        if(head==null||head.next==null||head.next.next==null) return res;\\n        int minidx=Integer.MAX_VALUE,curridx=-1,lastidx=-1;\\n        ListNode prev=head,ptr=head.next;\\n        int idx=1,minD=Integer.MAX_VALUE;\\n        while(ptr!=null&&ptr.next!=null){\\n            if((ptr.val>prev.val&&ptr.val>ptr.next.val)||(ptr.val<prev.val&&ptr.val<ptr.next.val)){\\n                if(idx<minidx) minidx=idx;\\n                lastidx=curridx;\\n                curridx=idx;\\n                if(lastidx!=-1&&curridx-lastidx<minD) minD=curridx-lastidx;\\n            }\\n            prev=ptr;\\n            ptr=ptr.next;\\n            idx++;\\n        }\\n        if(lastidx==-1) return res;\\n        else{\\n            res[0]=minD;\\n            res[1]=curridx-minidx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int res[]=new int[]{-1,-1};\\n        if(head==null||head.next==null||head.next.next==null) return res;\\n        int minidx=Integer.MAX_VALUE,curridx=-1,lastidx=-1;\\n        ListNode prev=head,ptr=head.next;\\n        int idx=1,minD=Integer.MAX_VALUE;\\n        while(ptr!=null&&ptr.next!=null){\\n            if((ptr.val>prev.val&&ptr.val>ptr.next.val)||(ptr.val<prev.val&&ptr.val<ptr.next.val)){\\n                if(idx<minidx) minidx=idx;\\n                lastidx=curridx;\\n                curridx=idx;\\n                if(lastidx!=-1&&curridx-lastidx<minD) minD=curridx-lastidx;\\n            }\\n            prev=ptr;\\n            ptr=ptr.next;\\n            idx++;\\n        }\\n        if(lastidx==-1) return res;\\n        else{\\n            res[0]=minD;\\n            res[1]=curridx-minidx;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719832,
                "title": "python-3-11-lines-w-explanation-t-m-92-82",
                "content": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: ListNode) -> List[int]:\\n\\n        ct, critPts, prev = 0, [], head.val                         # keep track of node-count, critical points\\n                                                                    # encountered, and previous node value\\n        while head.next:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# Tests for critical points: product < 0 if and only if\\n            if (prev-head.val)*(head.val-head.next.val) < 0:        #          prev < head.val > head.next.val, or \\n                critPts.append(ct)                                  #          prev > head.val < head.next.val\\n                                                      \\n            prev, head = head.val, head.next                        # iterates to next node and increments node-count\\n            ct+= 1\\n\\n        n = len(critPts)                                            # fewer than 2 nodes\\n        if n < 2: return [-1,-1]\\n\\n        mn = min((critPts[i]-critPts[i-1] for i in range(1, n)))    # list already sorted, so min is least dist between \\n        mx = critPts[-1] - critPts[0]                               # consecutive elements; max is last element - 1st element\\n\\n        return [mn, mx]\\n```\\n\\n[https://leetcode.com/submissions/detail/825482978/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: ListNode) -> List[int]:\\n\\n        ct, critPts, prev = 0, [], head.val                         # keep track of node-count, critical points\\n                                                                    # encountered, and previous node value\\n        while head.next:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# Tests for critical points: product < 0 if and only if\\n            if (prev-head.val)*(head.val-head.next.val) < 0:        #          prev < head.val > head.next.val, or \\n                critPts.append(ct)                                  #          prev > head.val < head.next.val\\n                                                      \\n            prev, head = head.val, head.next                        # iterates to next node and increments node-count\\n            ct+= 1\\n\\n        n = len(critPts)                                            # fewer than 2 nodes\\n        if n < 2: return [-1,-1]\\n\\n        mn = min((critPts[i]-critPts[i-1] for i in range(1, n)))    # list already sorted, so min is least dist between \\n        mx = critPts[-1] - critPts[0]                               # consecutive elements; max is last element - 1st element\\n\\n        return [mn, mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550747,
                "title": "c-simple-and-clean-solution-detailed-explanation-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nWe loop through the list, and check each node if it\\'s critical using helper function `isCritical`.\\nIf it\\'s critical, we save in `mn` the minimum distance between two close critical points.\\nWe also save in `first_crit` the index of the first critical point.\\nLast, we update `prev_crit` to the current `idx`.\\n\\nOur result will be `{ mn, prev_crit - first_crit }`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    int isCritical(ListNode* prev, ListNode* node) {\\n        if (prev->val < node->val && node->val > node->next->val) return true;\\n        if (prev->val > node->val && node->val < node->next->val) return true;\\n        return false;\\n    }\\n    \\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int mn = INT_MAX, first_crit = -1, prev_crit = INT_MIN, idx = 1;\\n        ListNode* ptr = head->next, *prev = head;\\n        \\n        while (ptr->next) {\\n            \\n            if (isCritical(prev, ptr)) {\\n                if (prev_crit > INT_MIN) mn = min(mn, idx - prev_crit);\\n                if (first_crit == -1) first_crit = idx;\\n                prev_crit = idx;\\n            }\\n            \\n            idx++;\\n            prev = prev->next;\\n            ptr = ptr->next;\\n        }\\n        \\n        if (mn == INT_MAX) return {-1, -1};\\n        return {mn, prev_crit - first_crit};\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isCritical(ListNode* prev, ListNode* node) {\\n        if (prev->val < node->val && node->val > node->next->val) return true;\\n        if (prev->val > node->val && node->val < node->next->val) return true;\\n        return false;\\n    }\\n    \\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int mn = INT_MAX, first_crit = -1, prev_crit = INT_MIN, idx = 1;\\n        ListNode* ptr = head->next, *prev = head;\\n        \\n        while (ptr->next) {\\n            \\n            if (isCritical(prev, ptr)) {\\n                if (prev_crit > INT_MIN) mn = min(mn, idx - prev_crit);\\n                if (first_crit == -1) first_crit = idx;\\n                prev_crit = idx;\\n            }\\n            \\n            idx++;\\n            prev = prev->next;\\n            ptr = ptr->next;\\n        }\\n        \\n        if (mn == INT_MAX) return {-1, -1};\\n        return {mn, prev_crit - first_crit};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549969,
                "title": "c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {    \\n        vector<int> v; // v to store critical point locations\\n        ListNode*prev = head; ListNode* curr = head->next; ListNode* ahead = head->next->next;\\n        int i=2;\\n        \\n        while(curr->next != NULL)\\n        {\\n            if(prev->val < curr->val && curr->val > ahead->val)\\n                v.push_back(i); // local maxima at i\\n            if(prev->val > curr->val && curr->val < ahead->val)\\n                v.push_back(i); // local minima at i\\n            prev = prev->next, curr = curr->next, ahead = ahead->next, i++;\\n        }\\n        \\n        if(v.size() < 2) \\n            return {-1,-1};\\n        \\n        int temp, min_dist = INT_MAX;\\n        for(int i=1; i<v.size(); i++) // minimum distance can be anywhere\\n        {\\n            temp = v[i] - v[i-1]; // check for every pair\\n            min_dist = min(temp, min_dist); // greedily get the minimum distance\\n        }\\n        \\n        return {min_dist, v[v.size()-1] - v[0]}; // maxmimum distance will be highest i - least i\\n    }\\n};\\n```\\n\\n**upvote if you like it**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {    \\n        vector<int> v; // v to store critical point locations\\n        ListNode*prev = head; ListNode* curr = head->next; ListNode* ahead = head->next->next;\\n        int i=2;\\n        \\n        while(curr->next != NULL)\\n        {\\n            if(prev->val < curr->val && curr->val > ahead->val)\\n                v.push_back(i); // local maxima at i\\n            if(prev->val > curr->val && curr->val < ahead->val)\\n                v.push_back(i); // local minima at i\\n            prev = prev->next, curr = curr->next, ahead = ahead->next, i++;\\n        }\\n        \\n        if(v.size() < 2) \\n            return {-1,-1};\\n        \\n        int temp, min_dist = INT_MAX;\\n        for(int i=1; i<v.size(); i++) // minimum distance can be anywhere\\n        {\\n            temp = v[i] - v[i-1]; // check for every pair\\n            min_dist = min(temp, min_dist); // greedily get the minimum distance\\n        }\\n        \\n        return {min_dist, v[v.size()-1] - v[0]}; // maxmimum distance will be highest i - least i\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522737,
                "title": "90-tc-and-87-sc-easy-python-solution",
                "content": "```\\ndef nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n\\tans = [float(\\'inf\\'), -float(\\'inf\\')]\\n\\tcurr = head.next\\n\\tprev = head\\n\\ti = 1\\n\\tpos = []\\n\\twhile(curr.next):\\n\\t\\tif(prev.val < curr.val > curr.next.val):\\n\\t\\t\\tpos.append(i)\\n\\t\\telif(prev.val > curr.val < curr.next.val):\\n\\t\\t\\tpos.append(i)\\n\\t\\ti += 1\\n\\t\\tprev, curr = curr, curr.next\\n\\tif(len(pos) < 2):\\n\\t\\treturn -1, -1\\n\\tfor i in range(1, len(pos)):\\n\\t\\tans[0] = min(ans[0], pos[i]-pos[i-1])\\n\\tans[1] = pos[-1]-pos[0]\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n\\tans = [float(\\'inf\\'), -float(\\'inf\\')]\\n\\tcurr = head.next\\n\\tprev = head\\n\\ti = 1\\n\\tpos = []\\n\\twhile(curr.next):\\n\\t\\tif(prev.val < curr.val > curr.next.val):\\n\\t\\t\\tpos.append(i)\\n\\t\\telif(prev.val > curr.val < curr.next.val):\\n\\t\\t\\tpos.append(i)\\n\\t\\ti += 1\\n\\t\\tprev, curr = curr, curr.next\\n\\tif(len(pos) < 2):\\n\\t\\treturn -1, -1\\n\\tfor i in range(1, len(pos)):\\n\\t\\tans[0] = min(ans[0], pos[i]-pos[i-1])\\n\\tans[1] = pos[-1]-pos[0]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3937027,
                "title": "easy-c-solution-using-vector-easy-and-optimal-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n      int count=2;\\n      vector<int>v;\\n      ListNode * temp=head->next;\\n      ListNode * prev=head;\\n      while(temp->next)\\n      {\\n          if(temp->val > prev->val && temp->val > temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          if(temp->val < prev->val && temp->val < temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          count++;\\n          prev=temp;\\n          temp=temp->next;\\n      }\\n      if(v.size()<2)\\n      {\\n          return {-1,-1};\\n      }\\n    sort(v.begin(), v.end()); // Sort the vector\\n\\n    int maxDifference = v[v.size() - 1] - v[0];\\n    int minDifference = INT_MAX;\\n\\n    for (int i = 1; i < v.size(); ++i) {\\n        int diff = v[i] - v[i - 1];\\n        minDifference = min(minDifference, diff);\\n    }\\n    return {minDifference,maxDifference};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n      int count=2;\\n      vector<int>v;\\n      ListNode * temp=head->next;\\n      ListNode * prev=head;\\n      while(temp->next)\\n      {\\n          if(temp->val > prev->val && temp->val > temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          if(temp->val < prev->val && temp->val < temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          count++;\\n          prev=temp;\\n          temp=temp->next;\\n      }\\n      if(v.size()<2)\\n      {\\n          return {-1,-1};\\n      }\\n    sort(v.begin(), v.end()); // Sort the vector\\n\\n    int maxDifference = v[v.size() - 1] - v[0];\\n    int minDifference = INT_MAX;\\n\\n    for (int i = 1; i < v.size(); ++i) {\\n        int diff = v[i] - v[i - 1];\\n        minDifference = min(minDifference, diff);\\n    }\\n    return {minDifference,maxDifference};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384291,
                "title": "easy-cpp-solution-beats-99-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344449,
                "title": "c-easy-samaj-me-aaega-bro",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n          vector<int> ans(2,-1);\\n        if(head==NULL || head->next==NULL || head->next->next==NULL || head->next->next->next==NULL){\\n            return ans;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nex=head->next->next;\\n        ListNode* cur=head->next;\\n        int index=1;\\n        vector<int> points;\\n        while(nex){\\n            if(cur->val<prev->val && cur->val<nex->val){\\n                 points.push_back(index);\\n            }\\n            if(cur->val>prev->val && cur->val>nex->val){\\n                 points.push_back(index);\\n            }\\n            index++;\\n            prev=prev->next;\\n            cur=cur->next;\\n            nex=nex->next;\\n\\n        }\\n        int minn= INT_MAX;\\n        int maxx=INT_MIN;\\n        if(points.size()<2){\\n            return ans;\\n        }\\n            sort(points.begin(),points.end());\\n            for(int i=0;i<points.size()-1;i++){\\n                minn=min(minn,abs(points[i]-points[i+1]));\\n            }\\n            maxx=abs(points[0]-points[points.size()-1]);\\n            ans[0]=minn;\\n            ans[1]=maxx;\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n          vector<int> ans(2,-1);\\n        if(head==NULL || head->next==NULL || head->next->next==NULL || head->next->next->next==NULL){\\n            return ans;\\n        }\\n        ListNode* prev=head;\\n        ListNode* nex=head->next->next;\\n        ListNode* cur=head->next;\\n        int index=1;\\n        vector<int> points;\\n        while(nex){\\n            if(cur->val<prev->val && cur->val<nex->val){\\n                 points.push_back(index);\\n            }\\n            if(cur->val>prev->val && cur->val>nex->val){\\n                 points.push_back(index);\\n            }\\n            index++;\\n            prev=prev->next;\\n            cur=cur->next;\\n            nex=nex->next;\\n\\n        }\\n        int minn= INT_MAX;\\n        int maxx=INT_MIN;\\n        if(points.size()<2){\\n            return ans;\\n        }\\n            sort(points.begin(),points.end());\\n            for(int i=0;i<points.size()-1;i++){\\n                minn=min(minn,abs(points[i]-points[i+1]));\\n            }\\n            maxx=abs(points[0]-points[points.size()-1]);\\n            ans[0]=minn;\\n            ans[1]=maxx;\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219843,
                "title": "c-easy-to-understand",
                "content": "\\'\\'\\' \\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\n         int mini=INT_MAX;\\n         ListNode *cur=head->next,*pre=head;\\n         if(head==NULL || cur->next==NULL)\\n            return {-1,-1};\\n        int ind=1;\\n        int ind1=0,ind2=0;\\n      // count is using for maxDistance by adding the distance btw two critical points\\n        int count=0;\\n         while(cur->next)\\n         {\\n           // for local minima\\n            if(pre->val > cur->val && cur->val< cur->next->val)\\n            {\\n                if(ind1==0)\\n                   ind1=ind;\\n                else\\n                  ind2=ind;\\n              \\n               \\n            }\\n           // for local maxima\\n            else if(pre->val < cur->val && cur->val > cur->next->val)\\n            {\\n               if(ind1==0)\\n                   ind1=ind;\\n                else\\n                  ind2=ind;\\n              \\n            }  \\n           if(ind1!=0 && ind2!=0)\\n              {\\n                mini=min(mini,ind2-ind1);\\n                count+=ind2-ind1;\\n                 ind1=ind2;\\n                 ind2=0;\\n              } \\n           pre=cur;\\n           cur=cur->next;\\n           ind++;\\n          \\n         }\\n       // if we don\\'t have any critcal point\\n       if(mini==INT_MAX || count==0)\\n          return {-1,-1};\\n       return {mini,count};\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\' \\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\n         int mini=INT_MAX;\\n         ListNode *cur=head->next,*pre=head;\\n         if(head==NULL || cur->next==NULL)\\n            return {-1,-1};\\n        int ind=1;\\n        int ind1=0,ind2=0;\\n      // count is using for maxDistance by adding the distance btw two critical points\\n        int count=0;\\n         while(cur->next)\\n         {\\n           // for local minima\\n            if(pre->val > cur->val && cur->val< cur->next->val)\\n            {\\n                if(ind1==0)\\n                   ind1=ind;\\n                else\\n                  ind2=ind;\\n              \\n               \\n            }\\n           // for local maxima\\n            else if(pre->val < cur->val && cur->val > cur->next->val)\\n            {\\n               if(ind1==0)\\n                   ind1=ind;\\n                else\\n                  ind2=ind;\\n              \\n            }  \\n           if(ind1!=0 && ind2!=0)\\n              {\\n                mini=min(mini,ind2-ind1);\\n                count+=ind2-ind1;\\n                 ind1=ind2;\\n                 ind2=0;\\n              } \\n           pre=cur;\\n           cur=cur->next;\\n           ind++;\\n          \\n         }\\n       // if we don\\'t have any critcal point\\n       if(mini==INT_MAX || count==0)\\n          return {-1,-1};\\n       return {mini,count};\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1847310,
                "title": "easy-to-understand-python-solution",
                "content": "Hope this helps!\\n\\n~First of all, we first create two pointer, `curr` and `prev` to track previous and current node. We can keep track the node after curr using `curr.next`. So we only require 2 pointer here.\\n\\n~Then, we keep track the index of the curr node using `count`  at the beginning and set it at 0. Whenever `curr = curr.next`, `count` increases by one. Note that `(count + 1)` is used in the code so that the index starts at 1 instead of 0-indexing. \\n\\n~ We create one tmp array and one res array that we return at the end. \\n\\nWe append the count to tmp array when \\n1) `curValue` > `cur.next.val` and `curValue > prevValue` OR \\n2) `curValue` <` prevValue` and `curValue` < `cur.next.val`\\n\\n\\n~Since the tmp array is sorted when we keep track of the index of the node, the maximum distance will be tmp[-1] - tmp[0] at the end or we can also keep track using `maxi = max(maxi, tmp[-1] - tmp[0])`.\\n\\n~Since we do not know the minimum distance between two critical points, we will keep track of minimum distance when `len(tmp) > 2`. I used `mini = min(mini, tmp[-1] - tmp[-2])` here.\\n\\n\\nAt the end, we append (min distance, max distance) to res. Min distance wound be `mini` and max distance would be tmp[-1] - tmp[0]. (Ending index) - (starting index) will result in the maximum distance since the arr is sorted as we loop from left to right.\\n    \\nWe check the len(tmp) at the end. If there is less than 2 distinct nodes in tmp, we return\\n[-1,-1]. Else we return [mini, maxi] distances of the 2 distinct nodes.\\n\\n\\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        cur = head\\n        prev = cur\\n        tmp = []\\n        res = []\\n        count = 0\\n        mini = float(\\'inf\\')\\n\\n        while cur.next:\\n            curValue = cur.val\\n            if count >= 1:\\n                prevValue = prev.val\\n\\n                if curValue > cur.next.val and curValue > prevValue:\\n                    tmp.append(count + 1)\\n                elif curValue < prevValue and curValue < cur.next.val:\\n                    tmp.append(count + 1)\\n\\n                prev = prev.next\\n                if len(tmp) > 1:\\n                    mini = min(mini, tmp[-1] - tmp[-2])\\n\\t\\t\\t\\t\\t#alternative\\n\\t\\t\\t\\t\\t#maxi = max(maxi, tmp[-1] - tmp[0])\\n\\n            cur = cur.next\\n            count += 1\\n\\n        if len(tmp) < 2:\\n            return [-1, -1]\\n        else:\\n            return [mini, (tmp[-1] - tmp[0])] \\n\\t\\t\\t\\n\\t\\t\\t#alternative\\n\\t\\t\\t#return [mini, maxi]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        cur = head\\n        prev = cur\\n        tmp = []\\n        res = []\\n        count = 0\\n        mini = float(\\'inf\\')\\n\\n        while cur.next:\\n            curValue = cur.val\\n            if count >= 1:\\n                prevValue = prev.val\\n\\n                if curValue > cur.next.val and curValue > prevValue:\\n                    tmp.append(count + 1)\\n                elif curValue < prevValue and curValue < cur.next.val:\\n                    tmp.append(count + 1)\\n\\n                prev = prev.next\\n                if len(tmp) > 1:\\n                    mini = min(mini, tmp[-1] - tmp[-2])\\n\\t\\t\\t\\t\\t#alternative\\n\\t\\t\\t\\t\\t#maxi = max(maxi, tmp[-1] - tmp[0])\\n\\n            cur = cur.next\\n            count += 1\\n\\n        if len(tmp) < 2:\\n            return [-1, -1]\\n        else:\\n            return [mini, (tmp[-1] - tmp[0])] \\n\\t\\t\\t\\n\\t\\t\\t#alternative\\n\\t\\t\\t#return [mini, maxi]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752383,
                "title": "c-simple-and-clean-solution-time-o-n",
                "content": "// By using extra space ie. a vector \\n// Time O(N) Space O(N)\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev= head;\\n            ListNode* curr=head->next;\\n            ListNode* after=curr->next;\\n        if(prev==NULL || curr==NULL || after==NULL)\\n            return {-1,-1};\\n        int i=2;\\n        vector<int>v;\\n        while(curr->next){\\n            \\n            if(curr->val>prev->val && curr->val >after->val)\\n               v.push_back(i);\\n            \\n            else if(curr->val<prev->val && curr->val < after->val)\\n               v.push_back(i);\\n            \\n            i++;\\n            prev=curr;\\n            curr=after;\\n            after=after->next;\\n        }\\n        if(v.size()==0 || v.size()==1)\\n            return{-1,-1};\\n        int sum=INT_MAX;\\n        for(int i=1;i<v.size();i++){\\n            int min1=v[i]-v[i-1];\\n            if(min1<sum)\\n                sum=min1;\\n        }\\n        int p=v[v.size()-1]-v[0];\\n        return {sum,p};\\n        \\n    }\\n};\\n\\n\\n// Without using extra space\\n//Time O(N) and Space O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n            ListNode* prev= head;\\n            ListNode* curr=head->next;\\n            ListNode* after=curr->next;\\n        \\n        if(prev==NULL || curr==NULL || after==NULL)\\n            return {-1,-1};\\n        int i=2,j=0,k=0,h=0;\\n        bool flag=false;\\n        int ans=INT_MAX;\\n        while(curr->next)\\n        {\\n            if((curr->val>prev->val && curr->val >after->val) || (curr->val<prev->val && curr->val < after->val))\\n            {\\n                // j is used for storing the first index at which we get maximum or minimum. \\n                if(j==0)\\n                    j=i;\\n                else\\n                {\\n                    // k is used for storing next maximum or minimum index, so as to calcumte min difference b/w them. \\n                   flag=true;\\n                   k=i;\\n                }\\n                if(flag==true)\\n                   ans=min(ans,k-h);\\n                \\n                 h=i;\\n             }\\n               i++;\\n               prev=curr;\\n               curr=after;\\n               after=after->next;\\n        }\\n        if((ans==INT_MAX || k==0) || (ans==INT_MAX && k==0))\\n            return {-1,-1};\\n        return {ans,k-j};\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev= head;\\n            ListNode* curr=head->next;\\n            ListNode* after=curr->next;\\n        if(prev==NULL || curr==NULL || after==NULL)\\n            return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1608075,
                "title": "c-easy-soln",
                "content": "hint-store the indicies of critical points in array\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n        vector<int> v;\\n        int i=1;\\n        while(temp2->next!=NULL)\\n        {\\n            if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                v.push_back(i);\\n            }\\n            i++;\\n            temp2=temp2->next;\\n            temp=temp->next;\\n        }\\n        if(v.size()<2)\\n        {\\n            return {-1,-1};\\n        }\\n        int mini=INT_MAX;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            mini=min(mini,v[i]-v[i-1]);\\n        }\\n        return {mini,v[v.size()-1]-v[0]};\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n        vector<int> v;\\n        int i=1;\\n        while(temp2->next!=NULL)\\n        {\\n            if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                v.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1553659,
                "title": "c-2058-find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int dmin = INT_MAX, last = 0, first = 0, prev = head->val, i = 1; \\n        for (ListNode* node = head->next; node && node->next; prev = node->val, node = node->next, ++i) \\n            if ((prev < node->val && node->val > node->next->val) || (prev > node->val && node->val < node->next->val)) {\\n                if (last) dmin = min(dmin, i - last); \\n                if (!first) first = i; \\n                last = i; \\n            }\\n        if (dmin < INT_MAX) return {dmin, last - first}; \\n        return {-1, -1}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int dmin = INT_MAX, last = 0, first = 0, prev = head->val, i = 1; \\n        for (ListNode* node = head->next; node && node->next; prev = node->val, node = node->next, ++i) \\n            if ((prev < node->val && node->val > node->next->val) || (prev > node->val && node->val < node->next->val)) {\\n                if (last) dmin = min(dmin, i - last); \\n                if (!first) first = i; \\n                last = i; \\n            }\\n        if (dmin < INT_MAX) return {dmin, last - first}; \\n        return {-1, -1}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551477,
                "title": "python3-o-n-time-o-1-space-faster-than-100",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev = head.val\\n        head = head.next\\n        if not head.next: return [-1, -1]\\n        \\n        first, last, currmin, curr = None, None, float(\"inf\"), 1\\n        ahead = head.next\\n        while ahead:\\n            if prev > head.val < ahead.val or prev < head.val > ahead.val:\\n                if first is None: first = last = curr\\n                else:\\n                    currmin = min(currmin, curr - last)\\n                    last = curr\\n            prev, curr = head.val, curr + 1\\n            head, ahead = head.next, ahead.next\\n        \\n        return [currmin, last - first] if currmin != float(\"inf\") else [-1, -1]\\n```\\nRuntime: 924 ms\\nMemory Usage: 55.1 MB",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev = head.val\\n        head = head.next\\n        if not head.next: return [-1, -1]\\n        \\n        first, last, currmin, curr = None, None, float(\"inf\"), 1\\n        ahead = head.next\\n        while ahead:\\n            if prev > head.val < ahead.val or prev < head.val > ahead.val:\\n                if first is None: first = last = curr\\n                else:\\n                    currmin = min(currmin, curr - last)\\n                    last = curr\\n            prev, curr = head.val, curr + 1\\n            head, ahead = head.next, ahead.next\\n        \\n        return [currmin, last - first] if currmin != float(\"inf\") else [-1, -1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550226,
                "title": "easy-one-pass-fast-java-solution",
                "content": "`\\nclass Solution {\\n\\n\\n\\n    public int[] nodesBetweenCriticalPoints(ListNode head)\\n    {\\n        ListNode temp=head.next;\\n        int min1=-1;\\n        ListNode prev=head;\\n        int min=Integer.MAX_VALUE;\\n        int pre=-1;\\n        int i=1;\\n        while(temp.next!=null){\\n            if((prev.val>temp.val && temp.val<temp.next.val) || (prev.val<temp.val && temp.val>temp.next.val)){\\n                \\n                // System.out.println(i);\\n                if(pre!=-1){\\n                    min=Math.min(min,i-pre);\\n                }\\n                \\n                pre=i;\\n                if(min1==-1) min1=i;\\n            }\\n            prev=temp;\\n            temp=temp.next;\\n            i++;\\n        }\\n        \\n        if(min1==-1 || pre==min1) return new int[]{-1,-1};\\n        else return new int[]{min,pre-min1};\\n    }\\n}\\n`",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n\\n    public int[] nodesBetweenCriticalPoints(ListNode head)\\n    {\\n        ListNode temp=head.next;\\n        int min1=-1;\\n        ListNode prev=head;\\n        int min=Integer.MAX_VALUE;\\n        int pre=-1;\\n        int i=1;\\n        while(temp.next!=null){\\n            if((prev.val>temp.val && temp.val<temp.next.val) || (prev.val<temp.val && temp.val>temp.next.val)){\\n                \\n                // System.out.println(i);\\n                if(pre!=-1){\\n                    min=Math.min(min,i-pre);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4054925,
                "title": "easy-java-solution-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int ans[] = new int[2];\\n        ans[0]= -1;\\n        ans[1] = -1;\\n\\n        if(head==null || head.next==null || head.next.next==null) return ans;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        ListNode t = head.next;\\n\\n        ListNode prev = head;\\n        int idx = 1;\\n\\n        while(t.next!=null){\\n            if(t.val>prev.val && t.val>t.next.val) arr.add(idx);\\n            if(t.val<prev.val && t.val<t.next.val) arr.add(idx);\\n\\n            idx++;\\n            prev = t;\\n            t=t.next;\\n        }\\n\\n        if(arr.size()<2) return ans;\\n\\n        ans[1] = arr.get(arr.size()-1) - arr.get(0);\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<arr.size(); i++){\\n            min = Math.min(arr.get(i)-arr.get(i-1),min);\\n        }\\n        ans[0] = min;\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int ans[] = new int[2];\\n        ans[0]= -1;\\n        ans[1] = -1;\\n\\n        if(head==null || head.next==null || head.next.next==null) return ans;\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        ListNode t = head.next;\\n\\n        ListNode prev = head;\\n        int idx = 1;\\n\\n        while(t.next!=null){\\n            if(t.val>prev.val && t.val>t.next.val) arr.add(idx);\\n            if(t.val<prev.val && t.val<t.next.val) arr.add(idx);\\n\\n            idx++;\\n            prev = t;\\n            t=t.next;\\n        }\\n\\n        if(arr.size()<2) return ans;\\n\\n        ans[1] = arr.get(arr.size()-1) - arr.get(0);\\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i=1; i<arr.size(); i++){\\n            min = Math.min(arr.get(i)-arr.get(i-1),min);\\n        }\\n        ans[0] = min;\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819984,
                "title": "python-3-save-critical-points-then-return-min-and-max-diff",
                "content": "```python3 []\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        idx, i = [], 1\\n        prev, cur = head, head.next\\n        while cur and cur.next:\\n            if prev.val < cur.val > cur.next.val or prev.val > cur.val < cur.next.val:\\n                idx.append(i)\\n            prev = cur\\n            cur = cur.next\\n            i += 1\\n\\n        if len(idx) < 2:\\n            return [-1, -1]\\n        \\n        minDist = min(j - i for i, j in pairwise(idx))\\n        maxDist = idx[-1] - idx[0]\\n\\n        return [minDist, maxDist]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        idx, i = [], 1\\n        prev, cur = head, head.next\\n        while cur and cur.next:\\n            if prev.val < cur.val > cur.next.val or prev.val > cur.val < cur.next.val:\\n                idx.append(i)\\n            prev = cur\\n            cur = cur.next\\n            i += 1\\n\\n        if len(idx) < 2:\\n            return [-1, -1]\\n        \\n        minDist = min(j - i for i, j in pairwise(idx))\\n        maxDist = idx[-1] - idx[0]\\n\\n        return [minDist, maxDist]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769514,
                "title": "c-easy-solution-simple",
                "content": "\\n\\n\\n\\n    class Solution {\\n    public:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL or head->next==NULL or head->next->next==NULL)return {-1,-1};\\n        int cnt=0,mini=INT_MAX,maxi=INT_MIN;\\n        vector<int>vect;\\n        ListNode* curr=head->next;\\n        ListNode* prev=head;\\n        ListNode* next=NULL;\\n        while(curr->next!=NULL){\\n            next=curr->next;\\n            if((curr->val<prev->val and curr->val<next->val) or (curr->val>prev->val and curr->val>next->val)){\\n                vect.push_back(cnt);;\\n            }\\n            cnt++;\\n            prev=curr;\\n            curr=curr->next;\\n        }\\n        if(vect.size()<=1){\\n            return {-1,-1};\\n        }\\n        for(int i=1;i<vect.size();i++){\\n            mini=min(mini,vect[i]-vect[i-1]);\\n        }\\n        maxi=vect[vect.size()-1]-vect[0];\\n        return {mini,maxi};\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL or head->next==NULL or head->next->next==NULL)return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 3758228,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Approach\\n1. The code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n2. Then, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n3. Next, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n4. After the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n5. If there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n6. Finally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727544,
                "title": "easy-java-solution-beats-98-online-submissions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int mn = 1000000, mx = -1;\\n\\n        int prev = head.val;\\n        head = head.next;\\n        int ct = -1;\\n        int total = 0;\\n        boolean present = false;\\n\\n        while(head.next != null){\\n            if((prev < head.val && head.val > head.next.val) || (prev > head.val && head.val < head.next.val)){\\n                present = true;\\n                if(ct != -1){\\n                    total += ct;\\n                    mn = Math.min(mn,ct);\\n                    mx = Math.max(mx,total);\\n                }\\n                ct = 0;\\n            }\\n            if(present){\\n                ct++;\\n            }\\n            prev = head.val;\\n            head = head.next;\\n        }\\n\\n        if(mn == 1000000 && mx == -1){\\n            return new int[]{-1,-1};\\n        }\\n\\n        return new int[]{mn,mx};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int mn = 1000000, mx = -1;\\n\\n        int prev = head.val;\\n        head = head.next;\\n        int ct = -1;\\n        int total = 0;\\n        boolean present = false;\\n\\n        while(head.next != null){\\n            if((prev < head.val && head.val > head.next.val) || (prev > head.val && head.val < head.next.val)){\\n                present = true;\\n                if(ct != -1){\\n                    total += ct;\\n                    mn = Math.min(mn,ct);\\n                    mx = Math.max(mx,total);\\n                }\\n                ct = 0;\\n            }\\n            if(present){\\n                ct++;\\n            }\\n            prev = head.val;\\n            head = head.next;\\n        }\\n\\n        if(mn == 1000000 && mx == -1){\\n            return new int[]{-1,-1};\\n        }\\n\\n        return new int[]{mn,mx};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582262,
                "title": "easy-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516829,
                "title": "easy-to-understand-solution-with-a-straight-forward-approach",
                "content": "# Here is my Approach:-\\n- Traverse the given linked list and store all the values in an ArrayList.\\n- Traverse the ArrayList and find all the critical points (local minima or maxima).\\n- For each critical point, find the distance to the previous critical point and update the minimum distance accordingly.\\n- Also, keep track of the distance to the first critical point encountered and update the maximum distance accordingly.\\n- Return the minimum and maximum distances as the result.\\n- If no critical points are found, return [-1, -1].\\n\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        while (head != null) {\\n            arr.add(head.val);\\n            head = head.next;\\n        }\\n        int prev = -1, minDis = Integer.MAX_VALUE, maxDis = -1, firstIndex = Integer.MAX_VALUE;\\n        int n = arr.size();\\n        for (int i = 1; i < n - 1; i++) {\\n            if ((arr.get(i - 1) < arr.get(i) && arr.get(i) > arr.get(i + 1)) || (arr.get(i - 1) > arr.get(i) && arr.get(i) < arr.get(i + 1))) {\\n                if (prev != -1) {\\n                    int distance = i - prev;\\n                    minDis = Math.min(minDis, distance);\\n                    int firstDis = Math.abs(i - firstIndex);\\n                    maxDis = Math.max(maxDis, Math.max(distance, firstDis));\\n                }\\n                prev = i;\\n                firstIndex = Math.min(prev, firstIndex);\\n            }\\n        }\\n        return minDis==Integer.MAX_VALUE && maxDis==-1 ? new int[]{-1, -1} : new int[]{minDis, maxDis};\\n    }\\n}\\n\\n```\\n# Do Upvote If you Find it Helpful",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        while (head != null) {\\n            arr.add(head.val);\\n            head = head.next;\\n        }\\n        int prev = -1, minDis = Integer.MAX_VALUE, maxDis = -1, firstIndex = Integer.MAX_VALUE;\\n        int n = arr.size();\\n        for (int i = 1; i < n - 1; i++) {\\n            if ((arr.get(i - 1) < arr.get(i) && arr.get(i) > arr.get(i + 1)) || (arr.get(i - 1) > arr.get(i) && arr.get(i) < arr.get(i + 1))) {\\n                if (prev != -1) {\\n                    int distance = i - prev;\\n                    minDis = Math.min(minDis, distance);\\n                    int firstDis = Math.abs(i - firstIndex);\\n                    maxDis = Math.max(maxDis, Math.max(distance, firstDis));\\n                }\\n                prev = i;\\n                firstIndex = Math.min(prev, firstIndex);\\n            }\\n        }\\n        return minDis==Integer.MAX_VALUE && maxDis==-1 ? new int[]{-1, -1} : new int[]{minDis, maxDis};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363442,
                "title": "golang-time-o-n-space-o-1-runtime-beats-100-memory-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc nodesBetweenCriticalPoints(head *ListNode) []int {\\n    if head.Next.Next == nil {\\n        return []int{-1, -1}\\n    }\\n\\n    min, max := -1, -1\\n\\n    prev := head\\n    head = head.Next\\n    prevIndex, firstIndex := -1, -1\\n    curIndex := 1\\n    \\n    for head.Next != nil {\\n        if (head.Val < prev.Val && head.Val < head.Next.Val) || (head.Val > prev.Val && head.Val > head.Next.Val) {\\n            if prevIndex == -1 {\\n                prevIndex = curIndex\\n                firstIndex = curIndex\\n            } else {\\n                max = curIndex - firstIndex\\n                if curIndex - prevIndex < min || min == -1 {\\n                    min = curIndex - prevIndex\\n                }\\n                prevIndex = curIndex\\n            }\\n        }\\n        prev = head\\n        head = head.Next\\n        curIndex++\\n    }\\n\\n    return []int{min, max}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc nodesBetweenCriticalPoints(head *ListNode) []int {\\n    if head.Next.Next == nil {\\n        return []int{-1, -1}\\n    }\\n\\n    min, max := -1, -1\\n\\n    prev := head\\n    head = head.Next\\n    prevIndex, firstIndex := -1, -1\\n    curIndex := 1\\n    \\n    for head.Next != nil {\\n        if (head.Val < prev.Val && head.Val < head.Next.Val) || (head.Val > prev.Val && head.Val > head.Next.Val) {\\n            if prevIndex == -1 {\\n                prevIndex = curIndex\\n                firstIndex = curIndex\\n            } else {\\n                max = curIndex - firstIndex\\n                if curIndex - prevIndex < min || min == -1 {\\n                    min = curIndex - prevIndex\\n                }\\n                prevIndex = curIndex\\n            }\\n        }\\n        prev = head\\n        head = head.Next\\n        curIndex++\\n    }\\n\\n    return []int{min, max}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3109715,
                "title": "easy-solution-faster-than-others-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head || !head->next || !head->next->next)return {-1,-1};\\n\\n        vector<int>points;\\n        int i=0;\\n        ListNode*curr=head, *prev=NULL;\\n        while(curr->next){\\n            if(prev && ((curr->val>prev->val && curr->val>curr->next->val)|| (curr->val<prev->val && curr->val<curr->next->val))){\\n                points.push_back(i);\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            i++;\\n        }\\n\\n        if(points.size()<=1)return {-1,-1};\\n        else if(points.size()==2)return {abs(points[0]-points[1]),abs(points[0]-points[1])};\\n        int mindiff=INT_MAX;\\n        for(int i=1;i<points.size();i++){\\n            mindiff=min(mindiff,abs(points[i]-points[i-1]));\\n        }\\n        int maxdiff=abs(points[0]-points[points.size()-1]);\\n        return {mindiff,maxdiff};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head || !head->next || !head->next->next)return {-1,-1};\\n\\n        vector<int>points;\\n        int i=0;\\n        ListNode*curr=head, *prev=NULL;\\n        while(curr->next){\\n            if(prev && ((curr->val>prev->val && curr->val>curr->next->val)|| (curr->val<prev->val && curr->val<curr->next->val))){\\n                points.push_back(i);\\n            }\\n            prev=curr;\\n            curr=curr->next;\\n            i++;\\n        }\\n\\n        if(points.size()<=1)return {-1,-1};\\n        else if(points.size()==2)return {abs(points[0]-points[1]),abs(points[0]-points[1])};\\n        int mindiff=INT_MAX;\\n        for(int i=1;i<points.size();i++){\\n            mindiff=min(mindiff,abs(points[i]-points[i-1]));\\n        }\\n        int maxdiff=abs(points[0]-points[points.size()-1]);\\n        return {mindiff,maxdiff};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063280,
                "title": "java-solution-tc-o-n-sc-o-1-easy-with-comment",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Maximum distance is always between first and the last critical point.\\n2) for minimum distance we will keep traversing the list and update it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head.next.next==null) return new int[]{-1,-1};\\n        int index=2;                 // to see the index it is 2 because 1st node cant be critical point\\n        ListNode prev=head;          // point to previous node of current node\\n        ListNode curr=head.next;     // to traverse linked list\\n        int min=Integer.MAX_VALUE;  //to store first critical point\\n        int max=Integer.MIN_VALUE;  // to store last critical point\\n        int min_diff=Integer.MAX_VALUE; //to store the minimum distance btw to critical point\\n        int prevs=0;               // to store value of previous critical point\\n        while(curr.next!=null){\\n        if((curr.val>prev.val && curr.val>curr.next.val) || (curr.val<prev.val && curr.val<curr.next.val)){ // condition\\n            max=Math.max(max,index); // finding last critical point\\n            min=Math.min(min,index); // finding first critical point\\n            if(prevs!=0)            //  if this is the second critical point then find its distance with the previous critical point\\n                min_diff=Math.min(min_diff,index-prevs);\\n            prevs=index;             // shift the previous critical point to the current one\\n        }\\n        prev=curr;               // update the previous pointer   \\n        curr=curr.next;         // move to the next node\\n        index++;               // increase the index  \\n        }\\n       \\n        if(min!=Integer.MAX_VALUE && max!=Integer.MIN_VALUE && min!=max){\\n            return new int[]{min_diff,max-min};  // max distance is always between first and last critical point and minimum we have already maintained;\\n        }\\n        else{\\n            return new int[]{-1,-1};\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head.next.next==null) return new int[]{-1,-1};\\n        int index=2;                 // to see the index it is 2 because 1st node cant be critical point\\n        ListNode prev=head;          // point to previous node of current node\\n        ListNode curr=head.next;     // to traverse linked list\\n        int min=Integer.MAX_VALUE;  //to store first critical point\\n        int max=Integer.MIN_VALUE;  // to store last critical point\\n        int min_diff=Integer.MAX_VALUE; //to store the minimum distance btw to critical point\\n        int prevs=0;               // to store value of previous critical point\\n        while(curr.next!=null){\\n        if((curr.val>prev.val && curr.val>curr.next.val) || (curr.val<prev.val && curr.val<curr.next.val)){ // condition\\n            max=Math.max(max,index); // finding last critical point\\n            min=Math.min(min,index); // finding first critical point\\n            if(prevs!=0)            //  if this is the second critical point then find its distance with the previous critical point\\n                min_diff=Math.min(min_diff,index-prevs);\\n            prevs=index;             // shift the previous critical point to the current one\\n        }\\n        prev=curr;               // update the previous pointer   \\n        curr=curr.next;         // move to the next node\\n        index++;               // increase the index  \\n        }\\n       \\n        if(min!=Integer.MAX_VALUE && max!=Integer.MIN_VALUE && min!=max){\\n            return new int[]{min_diff,max-min};  // max distance is always between first and last critical point and minimum we have already maintained;\\n        }\\n        else{\\n            return new int[]{-1,-1};\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035299,
                "title": "c-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int last = -1, mid = -1, curr = -1;\\n        int f = 0, l = 0, mn = INT_MAX;\\n        int len = 0;\\n\\n        while(head) {\\n            int val = head -> val;\\n            last = mid;\\n            mid = curr;\\n            curr = val;\\n\\n            if(len >= 2 && ((mid > last && mid > curr) || (mid < last && mid < curr))) {\\n                if(f == 0) f = len, l = len;\\n                else {\\n                    mn = min(len - l, mn);\\n                    l = len;\\n                }\\n            }\\n\\n            head = head -> next;\\n            len++;\\n        }   \\n\\n        if(mn == INT_MAX) return {-1, -1};\\n\\n        return {mn, l - f};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int last = -1, mid = -1, curr = -1;\\n        int f = 0, l = 0, mn = INT_MAX;\\n        int len = 0;\\n\\n        while(head) {\\n            int val = head -> val;\\n            last = mid;\\n            mid = curr;\\n            curr = val;\\n\\n            if(len >= 2 && ((mid > last && mid > curr) || (mid < last && mid < curr))) {\\n                if(f == 0) f = len, l = len;\\n                else {\\n                    mn = min(len - l, mn);\\n                    l = len;\\n                }\\n            }\\n\\n            head = head -> next;\\n            len++;\\n        }   \\n\\n        if(mn == INT_MAX) return {-1, -1};\\n\\n        return {mn, l - f};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543235,
                "title": "one-pass-easy-and-understandable-c-code",
                "content": "``` \\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        if(head == nullptr || head->next == nullptr) return {-1, -1};\\n        \\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* nextptr = head->next->next;\\n        int criticalPoint = 0;\\n        int firstCriticalPoint = 0;\\n        int minDistance = INT_MAX;\\n        int maxDistance = INT_MIN;\\n        int index = 0;\\n        \\n        while(nextptr != nullptr) {\\n            \\n            index++;\\n            \\n            if((curr->val < prev->val && curr->val < nextptr->val) \\n               || (curr->val > prev->val && curr->val > nextptr->val)) {\\n                \\n                if(criticalPoint) {\\n                    minDistance = min(minDistance, index - criticalPoint);\\n                    maxDistance = max(maxDistance, index - firstCriticalPoint);\\n                } else {\\n                    firstCriticalPoint = index;\\n                }\\n                \\n                criticalPoint = index;\\n            }\\n            \\n            prev = curr;\\n            curr = nextptr;\\n            nextptr = nextptr->next;\\n        }\\n        \\n        if(criticalPoint != firstCriticalPoint)\\n            return {minDistance, maxDistance};\\n        \\n        return {-1, -1};\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        if(head == nullptr || head->next == nullptr) return {-1, -1};\\n        \\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* nextptr = head->next->next;\\n        int criticalPoint = 0;\\n        int firstCriticalPoint = 0;\\n        int minDistance = INT_MAX;\\n        int maxDistance = INT_MIN;\\n        int index = 0;\\n        \\n        while(nextptr != nullptr) {\\n            \\n            index++;\\n            \\n            if((curr->val < prev->val && curr->val < nextptr->val) \\n               || (curr->val > prev->val && curr->val > nextptr->val)) {\\n                \\n                if(criticalPoint) {\\n                    minDistance = min(minDistance, index - criticalPoint);\\n                    maxDistance = max(maxDistance, index - firstCriticalPoint);\\n                } else {\\n                    firstCriticalPoint = index;\\n                }\\n                \\n                criticalPoint = index;\\n            }\\n            \\n            prev = curr;\\n            curr = nextptr;\\n            nextptr = nextptr->next;\\n        }\\n        \\n        if(criticalPoint != firstCriticalPoint)\\n            return {minDistance, maxDistance};\\n        \\n        return {-1, -1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386298,
                "title": "java-find-min-and-max-of-nodes-b-w-cp-brute-optimal",
                "content": "```\\npublic int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        \\n    //                APPROACH 1 - BRUTE FORCE\\n    \\n    //Step 1: Iniatialize a ArrayList for storing critical points.\\n    \\n    //Step 2: Set index = 1 for keeping track of curr element and set prev , curr and next pointers.\\n    \\n    //Step 3: Loop until next != null add critical pts based on the condition given and move all points to its next\\n    \\n    //Step 4: Find Min and Max from ArrayList between two distinct critical points\\n    \\n        \\n        ArrayList<Integer> criticalPointList = new ArrayList();\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        int index = 1;\\n        \\n        if(head.next.next == null)\\n        {\\n            return new int[] {-1,-1};\\n        }\\n        ListNode next = head.next.next;\\n        \\n        while(next!=null)\\n        {\\n            if(prev.val > curr.val && curr.val < next.val)\\n            {\\n               criticalPointList.add(index+1); \\n            }\\n            \\n            if(prev.val < curr.val && curr.val > next.val)\\n            {\\n               criticalPointList.add(index+1); \\n            }\\n            prev = curr;\\n            curr = next;\\n            next = next.next;\\n            index++;\\n        }\\n     \\n       \\n        if(criticalPointList.size()<=1)\\n        {\\n           return new int[] {-1,-1}; \\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < criticalPointList.size() ; i++) {\\n            min = Math.min(min,criticalPointList.get(i) - criticalPointList.get(i-1));\\n        }\\n        int lastElement  = criticalPointList.get(criticalPointList.size()-1);\\n        int firstElement =    criticalPointList.get(0);\\n        \\n        return new int[] {min,lastElement-firstElement};\\n        \\n       \\n    }\\n    \\n    \\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        //                APPROACH 2 - Optimal\\n    \\n    //Step 1: Iniatialize some variable instead of arrayList.\\n    \\n    //Step 2: Set index = 1 for keeping track of curr element and set prev , curr and next pointers.\\n    \\n    //Step 3: Loop until next != null set variables based on the condition given and move all points to its next\\n    \\n    //Step 4: Find Min and Max in O(1) time.\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        int index = 1 , firstPos = -1 , prevPos = -1 , min = Integer.MAX_VALUE , max = Integer.MIN_VALUE  ;\\n        \\n        \\n        if(head.next.next == null)\\n        {\\n            return new int[] {-1,-1};\\n        }\\n        ListNode next = head.next.next;\\n        \\n        while(next!=null)\\n        {\\n            index++;\\n            if(prev.val > curr.val && curr.val < next.val || prev.val < curr.val && curr.val > next.val )\\n            {\\n               if(firstPos == -1)\\n               {\\n                   firstPos = index;\\n                   prevPos = index;\\n               }\\n                else\\n                {\\n                    min = Math.min(min , index - prevPos );\\n                    max = Math.max(max , index - firstPos);\\n                    prevPos = index;\\n                }\\n            }\\n            \\n           \\n            prev = curr;\\n            curr = next;\\n            next = next.next;\\n            \\n        }\\n     \\n       if(min == Integer.MAX_VALUE )\\n       {\\n           return new int[] {-1,-1};\\n       }\\n        \\n        return new int[]{min,max};\\n        \\n        \\n       \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        \\n    //                APPROACH 1 - BRUTE FORCE\\n    \\n    //Step 1: Iniatialize a ArrayList for storing critical points.\\n    \\n    //Step 2: Set index = 1 for keeping track of curr element and set prev , curr and next pointers.\\n    \\n    //Step 3: Loop until next != null add critical pts based on the condition given and move all points to its next\\n    \\n    //Step 4: Find Min and Max from ArrayList between two distinct critical points\\n    \\n        \\n        ArrayList<Integer> criticalPointList = new ArrayList();\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        int index = 1;\\n        \\n        if(head.next.next == null)\\n        {\\n            return new int[] {-1,-1};\\n        }\\n        ListNode next = head.next.next;\\n        \\n        while(next!=null)\\n        {\\n            if(prev.val > curr.val && curr.val < next.val)\\n            {\\n               criticalPointList.add(index+1); \\n            }\\n            \\n            if(prev.val < curr.val && curr.val > next.val)\\n            {\\n               criticalPointList.add(index+1); \\n            }\\n            prev = curr;\\n            curr = next;\\n            next = next.next;\\n            index++;\\n        }\\n     \\n       \\n        if(criticalPointList.size()<=1)\\n        {\\n           return new int[] {-1,-1}; \\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < criticalPointList.size() ; i++) {\\n            min = Math.min(min,criticalPointList.get(i) - criticalPointList.get(i-1));\\n        }\\n        int lastElement  = criticalPointList.get(criticalPointList.size()-1);\\n        int firstElement =    criticalPointList.get(0);\\n        \\n        return new int[] {min,lastElement-firstElement};\\n        \\n       \\n    }\\n    \\n    \\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        //                APPROACH 2 - Optimal\\n    \\n    //Step 1: Iniatialize some variable instead of arrayList.\\n    \\n    //Step 2: Set index = 1 for keeping track of curr element and set prev , curr and next pointers.\\n    \\n    //Step 3: Loop until next != null set variables based on the condition given and move all points to its next\\n    \\n    //Step 4: Find Min and Max in O(1) time.\\n        \\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        int index = 1 , firstPos = -1 , prevPos = -1 , min = Integer.MAX_VALUE , max = Integer.MIN_VALUE  ;\\n        \\n        \\n        if(head.next.next == null)\\n        {\\n            return new int[] {-1,-1};\\n        }\\n        ListNode next = head.next.next;\\n        \\n        while(next!=null)\\n        {\\n            index++;\\n            if(prev.val > curr.val && curr.val < next.val || prev.val < curr.val && curr.val > next.val )\\n            {\\n               if(firstPos == -1)\\n               {\\n                   firstPos = index;\\n                   prevPos = index;\\n               }\\n                else\\n                {\\n                    min = Math.min(min , index - prevPos );\\n                    max = Math.max(max , index - firstPos);\\n                    prevPos = index;\\n                }\\n            }\\n            \\n           \\n            prev = curr;\\n            curr = next;\\n            next = next.next;\\n            \\n        }\\n     \\n       if(min == Integer.MAX_VALUE )\\n       {\\n           return new int[] {-1,-1};\\n       }\\n        \\n        return new int[]{min,max};\\n        \\n        \\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319478,
                "title": "easiest-approach-for-better-understanding-c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v, index, ans;\\n        while(head != NULL) {                       // Convert Linked List into vector\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        \\n        for(int i=1;i<v.size()-1;i++) {             // Storing index at which local maxima and minima are found\\n            if(v[i-1] < v[i] && v[i+1] < v[i]) {\\n                index.push_back(i);\\n            }\\n            else if(v[i-1] > v[i] && v[i+1] > v[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n        \\n        if(index.size() > 1) {                      // If minDistance, maxDistance are present\\n            int min = INT_MAX;\\n            for(int i=0;i<index.size()-1;i++) {     // To find minDistance\\n                int temp = index[i+1] - index[i];\\n                if(temp < min) {\\n                    min = temp;\\n                }\\n            }\\n            int max = index[index.size()-1] - index[0]; // To find maxDistance\\n            ans.push_back(min);\\n            ans.push_back(max);\\n        }\\n        \\n        else {                                      // If minDistance, maxDistance are not present\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n\\t// If this helped you, then please do up vote\\uD83D\\uDE0A.\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v, index, ans;\\n        while(head != NULL) {                       // Convert Linked List into vector\\n            v.push_back(head -> val);\\n            head = head -> next;\\n        }\\n        \\n        for(int i=1;i<v.size()-1;i++) {             // Storing index at which local maxima and minima are found\\n            if(v[i-1] < v[i] && v[i+1] < v[i]) {\\n                index.push_back(i);\\n            }\\n            else if(v[i-1] > v[i] && v[i+1] > v[i]) {\\n                index.push_back(i);\\n            }\\n        }\\n        \\n        if(index.size() > 1) {                      // If minDistance, maxDistance are present\\n            int min = INT_MAX;\\n            for(int i=0;i<index.size()-1;i++) {     // To find minDistance\\n                int temp = index[i+1] - index[i];\\n                if(temp < min) {\\n                    min = temp;\\n                }\\n            }\\n            int max = index[index.size()-1] - index[0]; // To find maxDistance\\n            ans.push_back(min);\\n            ans.push_back(max);\\n        }\\n        \\n        else {                                      // If minDistance, maxDistance are not present\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n\\t// If this helped you, then please do up vote\\uD83D\\uDE0A.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311869,
                "title": "normal-java-solution-general-approach",
                "content": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ListNode p=head;\\n        ListNode c=head.next;\\n        ListNode a=head.next.next;\\n        int min=Integer.MAX_VALUE;\\n        int index=2,prev=0,x=0,st=0,y=0;\\n        while(a!=null){           \\n            if(((c.val>p.val) && (c.val>a.val)) || ((c.val<p.val) && (c.val<a.val))){\\n               if(x==0){\\n                   st=index;\\n                   prev=st;\\n                   x++;\\n                   y++;\\n               }               \\n            else {\\n                if(min>=(index-prev)){\\n                    min=index-prev;                \\n                }\\n                prev=index;\\n                        y++; \\n            }           \\n            } \\n            p=c;\\n            c=a;\\n            a=a.next;\\n            index++;\\n                      \\n    }\\n         if(y>1){\\n                return new int[] {min,prev-st};\\n            }\\n        else \\n            return new int[] {-1,-1};\\n}\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ListNode p=head;\\n        ListNode c=head.next;\\n        ListNode a=head.next.next;\\n        int min=Integer.MAX_VALUE;\\n        int index=2,prev=0,x=0,st=0,y=0;\\n        while(a!=null){           \\n            if(((c.val>p.val) && (c.val>a.val)) || ((c.val<p.val) && (c.val<a.val))){\\n               if(x==0){\\n                   st=index;\\n                   prev=st;\\n                   x++;\\n                   y++;\\n               }               \\n            else {\\n                if(min>=(index-prev)){\\n                    min=index-prev;                \\n                }\\n                prev=index;\\n                        y++; \\n            }           \\n            } \\n            p=c;\\n            c=a;\\n            a=a.next;\\n            index++;\\n                      \\n    }\\n         if(y>1){\\n                return new int[] {min,prev-st};\\n            }\\n        else \\n            return new int[] {-1,-1};\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308822,
                "title": "easy-simple-c-solution-faster-than-92-36-uses-less-space-than-26-o-n",
                "content": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev=head;\\n        ListNode* curr=prev->next;\\n        ListNode* ne;\\n        vector<int>v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        if(curr->next!=NULL)\\n        {\\n            ne=curr->next;\\n        }\\n        else\\n        {\\n            return v;\\n        }\\n        v.clear();\\n        int k=1;\\n        while(ne!=NULL)\\n        {\\n            if(curr->val<prev->val && curr->val<ne->val)\\n            {\\n                v.push_back(k);\\n            }\\n            if(curr->val>prev->val && curr->val>ne->val)\\n            {\\n                v.push_back(k);\\n            }\\n            prev=prev->next;\\n            curr=curr->next;\\n            ne=ne->next;\\n            k=k+1;\\n        }\\n        int max=0;\\n        int minimum=INT_MAX;\\n        if(v.size()>1)\\n        {\\n            max=v[v.size()-1]-v[0];\\n            for(int i=0;i<v.size()-1;i=i+1)\\n            {\\n                minimum=min(v[i+1]-v[i],minimum);\\n            }\\n            v.clear();\\n            v.push_back(minimum);\\n            v.push_back(max);\\n        }\\n        else\\n        {\\n            v.clear();\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev=head;\\n        ListNode* curr=prev->next;\\n        ListNode* ne;\\n        vector<int>v;\\n        v.push_back(-1);\\n        v.push_back(-1);\\n        if(curr->next!=NULL)\\n        {\\n            ne=curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2230212,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n        // pair<int,int> p;\\n        int max = 0, min = INT_MAX;\\n        \\n        // if(head == NULL || head->next == NULL)\\n        \\n        while(head != NULL)\\n        {\\n            v1.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        for(int i=1; i<v1.size()-1; i++)\\n        {\\n            if(v1[i] > v1[i-1] && v1[i] > v1[i+1])\\n            {\\n                // p = make_pair(v1[i], i);\\n                v.push_back(i);\\n            }\\n            \\n            if(v1[i] < v1[i-1] && v1[i] < v1[i+1])\\n            {\\n                // p = make_pair(v1[i], i);\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        // v1.erase();\\n        \\n        if(v.size() < 2)\\n        {\\n            min = -1;\\n            max = -1;\\n        }\\n        else\\n        {\\n            for(int i=0; i<v.size()-1; i++)\\n            {\\n                if(v[i+1]-v[i] < min)\\n                {\\n                   min = v[i+1]-v[i];\\n                }\\n            }\\n            \\n                    max = v[v.size()-1] -v[0];\\n\\n        }\\n        \\n        \\n        v2.push_back(min);\\n                v2.push_back(max);\\n\\n        \\n        return v2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n        // pair<int,int> p;\\n        int max = 0, min = INT_MAX;\\n        \\n        // if(head == NULL || head->next == NULL)\\n        \\n        while(head != NULL)\\n        {\\n            v1.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        for(int i=1; i<v1.size()-1; i++)\\n        {\\n            if(v1[i] > v1[i-1] && v1[i] > v1[i+1])\\n            {\\n                // p = make_pair(v1[i], i);\\n                v.push_back(i);\\n            }\\n            \\n            if(v1[i] < v1[i-1] && v1[i] < v1[i+1])\\n            {\\n                // p = make_pair(v1[i], i);\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        // v1.erase();\\n        \\n        if(v.size() < 2)\\n        {\\n            min = -1;\\n            max = -1;\\n        }\\n        else\\n        {\\n            for(int i=0; i<v.size()-1; i++)\\n            {\\n                if(v[i+1]-v[i] < min)\\n                {\\n                   min = v[i+1]-v[i];\\n                }\\n            }\\n            \\n                    max = v[v.size()-1] -v[0];\\n\\n        }\\n        \\n        \\n        v2.push_back(min);\\n                v2.push_back(max);\\n\\n        \\n        return v2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227572,
                "title": "one-pass-by-votrubac-with-explaination-t-c-o-n-s-c-o-1",
                "content": "```\\n// Solution by votrubac, S.C O(1), T.C O(n)\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // keeping track of four variables \\n        /*\\n        first: this will keep track of first value of the ciritical point\\n        last: this will keep track of position of last critical point\\n        prev_val: this will keep track of previous value of node\\n        min_d: this will keep track of the mininum difference between the positions of two ciritcal points\\n        */\\n        int first = INT_MAX, last = 0, prev_val = head->val, min_d = INT_MAX;\\n        // this for loop is going till head is null, i.e, till last node\\n        for(int i = 0; head->next != NULL; ++i){\\n            // checking if current node is a critical point or not, i.e, is a local maxima or minima.\\n            if(\\n                (min(prev_val, head->next->val)>head->val)||\\n                (max(prev_val, head->next->val)<head->val)\\n            ){\\n                // this cond. will check if this is the first critical point or not\\n                if(last != 0){\\n                    // updating the value of minimum difference between two critical points\\n                    min_d = min(min_d, i-last);\\n                }\\n                // updating the first variable, which is keeping track of position of first critical point\\n                first = min(first, i);\\n                // updating last with position of current last critical point\\n                last = i;\\n            }\\n            // updating variables\\n            prev_val = head->val;\\n            head = head->next;\\n        }\\n        // checking if there exist two critical points or not and returning corresponding values\\n        if(min_d == INT_MAX) return {-1, -1};\\n        \\n        return {min_d, last-first};\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n// Solution by votrubac, S.C O(1), T.C O(n)\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // keeping track of four variables \\n        /*\\n        first: this will keep track of first value of the ciritical point\\n        last: this will keep track of position of last critical point\\n        prev_val: this will keep track of previous value of node\\n        min_d: this will keep track of the mininum difference between the positions of two ciritcal points\\n        */\\n        int first = INT_MAX, last = 0, prev_val = head->val, min_d = INT_MAX;\\n        // this for loop is going till head is null, i.e, till last node\\n        for(int i = 0; head->next != NULL; ++i){\\n            // checking if current node is a critical point or not, i.e, is a local maxima or minima.\\n            if(\\n                (min(prev_val, head->next->val)>head->val)||\\n                (max(prev_val, head->next->val)<head->val)\\n            ){\\n                // this cond. will check if this is the first critical point or not\\n                if(last != 0){\\n                    // updating the value of minimum difference between two critical points\\n                    min_d = min(min_d, i-last);\\n                }\\n                // updating the first variable, which is keeping track of position of first critical point\\n                first = min(first, i);\\n                // updating last with position of current last critical point\\n                last = i;\\n            }\\n            // updating variables\\n            prev_val = head->val;\\n            head = head->next;\\n        }\\n        // checking if there exist two critical points or not and returning corresponding values\\n        if(min_d == INT_MAX) return {-1, -1};\\n        \\n        return {min_d, last-first};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142174,
                "title": "scala-solution",
                "content": "```\\n\\nprivate implicit final class RichListNode(node: ListNode) {\\n    def iterator: Iterator[ListNode] = new Iterator[ListNode] {\\n      private var nextNode = node\\n      override def hasNext: Boolean = nextNode != null\\n      override def next(): ListNode = {\\n        val node = nextNode\\n        nextNode = nextNode.next\\n        node\\n      }\\n    }\\n  }\\n  def nodesBetweenCriticalPoints(head: ListNode): Array[Int] = {\\n    val indices = head.iterator\\n      .zip(head.iterator.drop(1))\\n      .zip(head.iterator.drop(2))\\n      .zipWithIndex\\n      .collect {case (((prev, curr), next), i)  if (prev.x < curr.x && next.x < curr.x || prev.x > curr.x && next.x > curr.x) => i}\\n      .toSeq\\n    if (indices.size >= 2) {\\n      Array(indices.iterator.zip(indices.iterator.drop(1)).map { case (i, j) => j - i }.min,\\n        indices.last - indices.head)\\n    } else {\\n      Array(-1, -1)\\n    }\\n  }\\n```",
                "solutionTags": [
                    "Scala",
                    "Iterator"
                ],
                "code": "```\\n\\nprivate implicit final class RichListNode(node: ListNode) {\\n    def iterator: Iterator[ListNode] = new Iterator[ListNode] {\\n      private var nextNode = node\\n      override def hasNext: Boolean = nextNode != null\\n      override def next(): ListNode = {\\n        val node = nextNode\\n        nextNode = nextNode.next\\n        node\\n      }\\n    }\\n  }\\n  def nodesBetweenCriticalPoints(head: ListNode): Array[Int] = {\\n    val indices = head.iterator\\n      .zip(head.iterator.drop(1))\\n      .zip(head.iterator.drop(2))\\n      .zipWithIndex\\n      .collect {case (((prev, curr), next), i)  if (prev.x < curr.x && next.x < curr.x || prev.x > curr.x && next.x > curr.x) => i}\\n      .toSeq\\n    if (indices.size >= 2) {\\n      Array(indices.iterator.zip(indices.iterator.drop(1)).map { case (i, j) => j - i }.min,\\n        indices.last - indices.head)\\n    } else {\\n      Array(-1, -1)\\n    }\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020417,
                "title": "java-o-1-space-o-n-time-complexity-one-pass",
                "content": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int[] arr={-1,-1};\\n        if(head.next.next==null || head.next.next.next==null)\\n        {\\n            return arr;\\n        }\\n        else\\n        {\\n            ListNode prev=head,curr=head.next,next=head.next.next;\\n            int i=2,first=-1,back=-1,now=-1,min=100001;\\n            while(next!=null)\\n            {\\n                if((curr.val<prev.val && curr.val<next.val) || (curr.val>prev.val && curr.val>next.val))\\n                {\\n                    if(first==-1)\\n                    {\\n                        first=i;\\n                        back=i;\\n                    }\\n                    else\\n                    {\\n                        now=i;\\n                        min = (now-back)<min ? (now-back) : min;\\n                        back=now;\\n                    }\\n                }\\n                prev=curr;\\n                curr=next;\\n                next=next.next;\\n                i++;\\n            }\\n            if(first==-1 || now==-1)\\n                return arr;\\n            arr[1]=now-first;\\n            arr[0]=min;\\n            return arr;\\n        }\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int[] arr={-1,-1};\\n        if(head.next.next==null || head.next.next.next==null)\\n        {\\n            return arr;\\n        }\\n        else\\n        {\\n            ListNode prev=head,curr=head.next,next=head.next.next;\\n            int i=2,first=-1,back=-1,now=-1,min=100001;\\n            while(next!=null)\\n            {\\n                if((curr.val<prev.val && curr.val<next.val) || (curr.val>prev.val && curr.val>next.val))\\n                {\\n                    if(first==-1)\\n                    {\\n                        first=i;\\n                        back=i;\\n                    }\\n                    else\\n                    {\\n                        now=i;\\n                        min = (now-back)<min ? (now-back) : min;\\n                        back=now;\\n                    }\\n                }\\n                prev=curr;\\n                curr=next;\\n                next=next.next;\\n                i++;\\n            }\\n            if(first==-1 || now==-1)\\n                return arr;\\n            arr[1]=now-first;\\n            arr[0]=min;\\n            return arr;\\n        }\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972906,
                "title": "c-o-n-points-vector",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        int count = 1;\\n        ListNode* p = head;\\n        while(p->next != nullptr){\\n            int prev = p->val;\\n            p = p->next;\\n            count++;\\n            if(p->next != nullptr){\\n                if(p->val > prev && p->val > p->next->val) points.push_back(count);\\n                else if(p->val < prev && p->val < p->next->val) points.push_back(count);\\n            }\\n        }\\n        if(points.size() < 2) return {-1, -1};\\n        vector<int> ans(2, points[1] - points[0]);\\n        ans[1] = points[points.size()-1] - points[0];\\n        for(int i = 1; i < points.size(); i++)\\n            if(points[i] - points[i-1] < ans[0]) ans[0] = points[i] - points[i-1];\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<int> points;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        int count = 1;\\n        ListNode* p = head;\\n        while(p->next != nullptr){\\n            int prev = p->val;\\n            p = p->next;\\n            count++;\\n            if(p->next != nullptr){\\n                if(p->val > prev && p->val > p->next->val) points.push_back(count);\\n                else if(p->val < prev && p->val < p->next->val) points.push_back(count);\\n            }\\n        }\\n        if(points.size() < 2) return {-1, -1};\\n        vector<int> ans(2, points[1] - points[0]);\\n        ans[1] = points[points.size()-1] - points[0];\\n        for(int i = 1; i < points.size(); i++)\\n            if(points[i] - points[i-1] < ans[0]) ans[0] = points[i] - points[i-1];\\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<int> points;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953334,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> g={-1,-1};\\n        vector<int> vec,veco;\\n        while(head)\\n        {\\n            vec.push_back(head->val);\\n            head=head->next;\\n        }\\n        if(vec.size()==2) return g;\\n        \\n        for(int i=1;i<vec.size()-1;i++)\\n            if((vec[i-1]>vec[i] and vec[i+1]>vec[i]) or (vec[i-1]<vec[i] and vec[i+1]<vec[i]))\\n                veco.push_back(i+1);\\n        \\n        if(veco.size()<=1) return g;\\n        vec.clear();\\n        \\n        \\n        int mn=100007,mx=0,mino,maxo;\\n        \\n        for(int i=0;i<veco.size()-1;i++)\\n            mn=min(mn,abs(veco[i+1]-veco[i]));\\n        \\n        mino=*min_element(veco.begin(),veco.end());\\n        maxo=*max_element(veco.begin(),veco.end());\\n        mx=maxo-mino;\\n        \\n        vec.push_back(mn);\\n        vec.push_back(mx);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> g={-1,-1};\\n        vector<int> vec,veco;\\n        while(head)\\n        {\\n            vec.push_back(head->val);\\n            head=head->next;\\n        }\\n        if(vec.size()==2) return g;\\n        \\n        for(int i=1;i<vec.size()-1;i++)\\n            if((vec[i-1]>vec[i] and vec[i+1]>vec[i]) or (vec[i-1]<vec[i] and vec[i+1]<vec[i]))\\n                veco.push_back(i+1);\\n        \\n        if(veco.size()<=1) return g;\\n        vec.clear();\\n        \\n        \\n        int mn=100007,mx=0,mino,maxo;\\n        \\n        for(int i=0;i<veco.size()-1;i++)\\n            mn=min(mn,abs(veco[i+1]-veco[i]));\\n        \\n        mino=*min_element(veco.begin(),veco.end());\\n        maxo=*max_element(veco.begin(),veco.end());\\n        mx=maxo-mino;\\n        \\n        vec.push_back(mn);\\n        vec.push_back(mx);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939088,
                "title": "golang-simple-solution-faster-than-70",
                "content": "```\\nfunc nodesBetweenCriticalPoints(head *ListNode) []int {\\n\\tif head.Next.Next == nil {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\tcriticalPoints := []int{}\\n\\tcurr, prev, count := head.Next, head, 2\\n\\tfor curr.Next != nil {\\n\\t\\tif curr.Val > prev.Val && curr.Val > curr.Next.Val {\\n\\t\\t\\tcriticalPoints = append(criticalPoints, count)\\n\\t\\t} else if curr.Val < prev.Val && curr.Val < curr.Next.Val {\\n\\t\\t\\tcriticalPoints = append(criticalPoints, count)\\n\\t\\t}\\n\\t\\tprev = curr\\n\\t\\tcount++\\n\\t\\tcurr = curr.Next\\n\\t}\\n\\tif len(criticalPoints) < 2 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\tminDistance := math.MaxInt64\\n\\tmaxDistance := criticalPoints[len(criticalPoints)-1] - criticalPoints[0]\\n\\tfor j := len(criticalPoints) - 1; j > 0; j-- {\\n\\t\\ttemp := criticalPoints[j] - criticalPoints[j-1]\\n\\t\\tif temp < minDistance {\\n\\t\\t\\tminDistance = temp\\n\\t\\t}\\n\\t}\\n\\treturn []int{minDistance, maxDistance}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Linked List"
                ],
                "code": "```\\nfunc nodesBetweenCriticalPoints(head *ListNode) []int {\\n\\tif head.Next.Next == nil {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\tcriticalPoints := []int{}\\n\\tcurr, prev, count := head.Next, head, 2\\n\\tfor curr.Next != nil {\\n\\t\\tif curr.Val > prev.Val && curr.Val > curr.Next.Val {\\n\\t\\t\\tcriticalPoints = append(criticalPoints, count)\\n\\t\\t} else if curr.Val < prev.Val && curr.Val < curr.Next.Val {\\n\\t\\t\\tcriticalPoints = append(criticalPoints, count)\\n\\t\\t}\\n\\t\\tprev = curr\\n\\t\\tcount++\\n\\t\\tcurr = curr.Next\\n\\t}\\n\\tif len(criticalPoints) < 2 {\\n\\t\\treturn []int{-1, -1}\\n\\t}\\n\\tminDistance := math.MaxInt64\\n\\tmaxDistance := criticalPoints[len(criticalPoints)-1] - criticalPoints[0]\\n\\tfor j := len(criticalPoints) - 1; j > 0; j-- {\\n\\t\\ttemp := criticalPoints[j] - criticalPoints[j-1]\\n\\t\\tif temp < minDistance {\\n\\t\\t\\tminDistance = temp\\n\\t\\t}\\n\\t}\\n\\treturn []int{minDistance, maxDistance}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1923340,
                "title": "java-easy-beginner-solution",
                "content": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while(head != null) {\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n        if(list.size() <= 2) {\\n            return new int[]{-1, -1};\\n        }\\n        List<Integer> indices = new ArrayList<>();\\n        for(int i=1;i<list.size()-1;i++) {\\n            if(list.get(i) > list.get(i+1) && list.get(i) > list.get(i-1)) {\\n                indices.add(i);\\n            }\\n            if(list.get(i) < list.get(i+1) && list.get(i) < list.get(i-1)) {\\n                indices.add(i);\\n            }\\n        }\\n        if(indices.size() < 2) {\\n            return new int[]{-1, -1};\\n        }\\n        return new int[]{minDiff(indices), maxDiff(indices)};\\n    }\\n    \\n    public int minDiff(List<Integer> nums) {\\n        Collections.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.size()-1;i++) {\\n            diff = Math.min(nums.get(i+1) - nums.get(i), diff);\\n        }\\n        return diff;\\n    }\\n    \\n    public int maxDiff(List<Integer> nums) {\\n        int min = nums.get(0);\\n        int max = nums.get(0);\\n        for (int i=1;i<nums.size();i++) {\\n            min = Math.min(min, nums.get(i));\\n            max = Math.max(max, nums.get(i));\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        List<Integer> list = new ArrayList<>();\\n        while(head != null) {\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n        if(list.size() <= 2) {\\n            return new int[]{-1, -1};\\n        }\\n        List<Integer> indices = new ArrayList<>();\\n        for(int i=1;i<list.size()-1;i++) {\\n            if(list.get(i) > list.get(i+1) && list.get(i) > list.get(i-1)) {\\n                indices.add(i);\\n            }\\n            if(list.get(i) < list.get(i+1) && list.get(i) < list.get(i-1)) {\\n                indices.add(i);\\n            }\\n        }\\n        if(indices.size() < 2) {\\n            return new int[]{-1, -1};\\n        }\\n        return new int[]{minDiff(indices), maxDiff(indices)};\\n    }\\n    \\n    public int minDiff(List<Integer> nums) {\\n        Collections.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.size()-1;i++) {\\n            diff = Math.min(nums.get(i+1) - nums.get(i), diff);\\n        }\\n        return diff;\\n    }\\n    \\n    public int maxDiff(List<Integer> nums) {\\n        int min = nums.get(0);\\n        int max = nums.get(0);\\n        for (int i=1;i<nums.size();i++) {\\n            min = Math.min(min, nums.get(i));\\n            max = Math.max(max, nums.get(i));\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799401,
                "title": "one-pass-solution-o-n-time-o-1-space",
                "content": "1) There should be at least 3 nodes to have a critical point. Return [-1,-1] if fewer than 3 nodes.\\n2) Initialize temp = head and traverse the LinkedList till temp.next.next is not null.\\n3) Check if the current node is a critical point or not. If yes, then if it is the first encountered critical point, do nothing, Otherwise update minDistance (least among any two critical points) and maxDistance (distance between last and first cirtical point).\\n4) Return [-1,-1] if 0 or 1 critical points encountered, otherwise return [minDistance, maxDistance]\\n5) Upvote if you like my solution!\\n```\\nclass Solution \\n{\\n    public int[] nodesBetweenCriticalPoints(ListNode head) \\n    {\\n        if(head == null || head.next == null || head.next.next == null)\\n            return new int[]{-1, -1};\\n        ListNode temp = head;\\n        int pos = 0;\\n        Integer first = null, last = null;\\n        int minDistance = Integer.MAX_VALUE;\\n        int maxDistance = Integer.MIN_VALUE;\\n        while(temp.next.next != null)\\n        {\\n            int a = temp.val;\\n            int b = temp.next.val;\\n            int c = temp.next.next.val;\\n            if((b < a && b < c) || (b > a && b > c))\\n            {\\n                if(first == null)\\n                    first = pos;\\n                if(last != null)\\n                {\\n                    minDistance = Math.min(minDistance, pos - last);\\n                    maxDistance = pos - first;\\n                }\\n                last = pos;\\n            }\\n            pos++;\\n            temp = temp.next;\\n        }\\n        if(first == last)\\n            return new int[]{-1, -1};\\n        return new int[]{minDistance, maxDistance};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] nodesBetweenCriticalPoints(ListNode head) \\n    {\\n        if(head == null || head.next == null || head.next.next == null)\\n            return new int[]{-1, -1};\\n        ListNode temp = head;\\n        int pos = 0;\\n        Integer first = null, last = null;\\n        int minDistance = Integer.MAX_VALUE;\\n        int maxDistance = Integer.MIN_VALUE;\\n        while(temp.next.next != null)\\n        {\\n            int a = temp.val;\\n            int b = temp.next.val;\\n            int c = temp.next.next.val;\\n            if((b < a && b < c) || (b > a && b > c))\\n            {\\n                if(first == null)\\n                    first = pos;\\n                if(last != null)\\n                {\\n                    minDistance = Math.min(minDistance, pos - last);\\n                    maxDistance = pos - first;\\n                }\\n                last = pos;\\n            }\\n            pos++;\\n            temp = temp.next;\\n        }\\n        if(first == last)\\n            return new int[]{-1, -1};\\n        return new int[]{minDistance, maxDistance};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780949,
                "title": "c-easy-to-understand-beginner-friendly-implementation-self-explanatory",
                "content": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> cp;\\n        if(head->next->next==NULL)return {-1,-1};\\n        ListNode* curr=head->next,*prev=head;\\n        int i=0;\\n        while(curr->next!=NULL){\\n            int x=curr->val;\\n            if((x<curr->next->val and x<prev->val) or(x>curr->next->val and x>prev->val))cp.push_back(i);\\n            curr=curr->next;\\n            prev=prev->next;\\n            i++;\\n            \\n        }\\n        if(cp.size()<2)return {-1,-1};\\n        int n=cp.size(),mini=INT_MAX;\\n        for(int i=0;i<n-1;i++)mini=min(mini,cp[i+1]-cp[i]);\\n        return {mini,cp[n-1]-cp[0]};\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> cp;\\n        if(head->next->next==NULL)return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1731434,
                "title": "very-easy-approach",
                "content": "```\\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>res;\\n        ListNode * prev = head;\\n        ListNode * curr = head->next;\\n        int i=1;\\n        while(curr->next!=nullptr){\\n            if((curr->val>prev->val && curr->val>curr->next->val)||(curr->val<prev->val && curr->val<curr->next->val)){\\n               res.push_back(i); \\n            }\\n            i++;\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        if(res.size()<2)return {-1,-1};\\n        else if(res.size()==2) return {abs(res[1]-res[0]),abs(res[1]-res[0])};\\n        sort(res.begin(),res.end());\\n        int n = res.size();\\n        int mini = INT_MAX;\\n        for(int i=1;i<n;i++){\\n            mini = min(mini,res[i]-res[i-1]);\\n        }\\n        return {mini,res[n-1]-res[0]};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>res;\\n        ListNode * prev = head;\\n        ListNode * curr = head->next;\\n        int i=1;\\n        while(curr->next!=nullptr){\\n            if((curr->val>prev->val && curr->val>curr->next->val)||(curr->val<prev->val && curr->val<curr->next->val)){\\n               res.push_back(i); \\n            }\\n            i++;\\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        if(res.size()<2)return {-1,-1};\\n        else if(res.size()==2) return {abs(res[1]-res[0]),abs(res[1]-res[0])};\\n        sort(res.begin(),res.end());\\n        int n = res.size();\\n        int mini = INT_MAX;\\n        for(int i=1;i<n;i++){\\n            mini = min(mini,res[i]-res[i-1]);\\n        }\\n        return {mini,res[n-1]-res[0]};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697370,
                "title": "easy-c-solution",
                "content": "<strong>Traverse the linked list and store all the critical points in an array and then calculate the number of nodes.</strong>\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        vector<int> critical;\\n        struct ListNode* temp=head;\\n        int prev=head->val,pos=1;\\n        while(temp!=NULL){\\n            if((temp->val)<prev){\\n                if(temp->next!=NULL && (temp->val)<(temp->next->val)){\\n                    critical.push_back(pos);\\n                }\\n            }\\n            if((temp->val)>prev){\\n                if(temp->next!=NULL && (temp->val)>(temp->next->val)){\\n                    critical.push_back(pos);\\n                }\\n            }\\n            pos++;\\n            prev=temp->val;\\n            temp=temp->next;\\n        }\\n        if(critical.size()>=2){\\n            int maxm=critical[critical.size()-1]-critical[0];\\n            int minm=INT_MAX;\\n            for(int i=critical.size()-1;i>0;i--){\\n                int diff=critical[i]-critical[i-1];\\n                minm=min(minm,diff);\\n            }\\n            ans[0]=minm;\\n            ans[1]=maxm;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        vector<int> critical;\\n        struct ListNode* temp=head;\\n        int prev=head->val,pos=1;\\n        while(temp!=NULL){\\n            if((temp->val)<prev){\\n                if(temp->next!=NULL && (temp->val)<(temp->next->val)){\\n                    critical.push_back(pos);\\n                }\\n            }\\n            if((temp->val)>prev){\\n                if(temp->next!=NULL && (temp->val)>(temp->next->val)){\\n                    critical.push_back(pos);\\n                }\\n            }\\n            pos++;\\n            prev=temp->val;\\n            temp=temp->next;\\n        }\\n        if(critical.size()>=2){\\n            int maxm=critical[critical.size()-1]-critical[0];\\n            int minm=INT_MAX;\\n            for(int i=critical.size()-1;i>0;i--){\\n                int diff=critical[i]-critical[i-1];\\n                minm=min(minm,diff);\\n            }\\n            ans[0]=minm;\\n            ans[1]=maxm;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662388,
                "title": "c-simple-and-easy-solution-o-n-space-complexity-o-1-space-complexity",
                "content": "O(N)SPACE COMPLEXITY\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n        vector<int> v11;\\n        int i=1;\\n        while(temp2->next!=NULL)\\n        {\\n            if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                v11.push_back(i);\\n            }\\n            i++;\\n            temp2=temp2->next;\\n            temp=temp->next;\\n        }\\n        if(v11.size()<2)\\n        {\\n            return {-1,-1};\\n        }\\n        int minimum=INT_MAX;\\n        for(int i=1;i<v11.size();i++)\\n        {\\n            minimum=min(minimum,v11[i]-v11[i-1]);\\n        }\\n       \\n        return {minimum,v11[v11.size()-1]-v11[0]};\\n        \\n    }\\n};\\n```\\nO(1) SPACE COMPLEXITY\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n         ListNode* temp11=head;\\n        ListNode* temp12=head->next;\\n       \\n        int i=1;\\n        int index=INT_MAX;\\n        int prev=0;\\n        int minimum=INT_MAX;\\n        while(temp2->next!=NULL)\\n        {\\n if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                if(prev!=0)\\n                {\\n                    minimum=min(minimum,i-prev);\\n                }\\n                prev=i;\\n                index=min(index,i);\\n              \\n            }\\n            i++;\\n            temp2=temp2->next;\\n            temp=temp->next;\\n        }\\n       \\n        if(minimum>0&&prev-index>0)\\n        {\\n            return{minimum,abs(prev-index)};\\n        }\\n        return {-1,-1};\\n    \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n        vector<int> v11;\\n        int i=1;\\n        while(temp2->next!=NULL)\\n        {\\n            if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                v11.push_back(i);\\n            }\\n            i++;\\n            temp2=temp2->next;\\n            temp=temp->next;\\n        }\\n        if(v11.size()<2)\\n        {\\n            return {-1,-1};\\n        }\\n        int minimum=INT_MAX;\\n        for(int i=1;i<v11.size();i++)\\n        {\\n            minimum=min(minimum,v11[i]-v11[i-1]);\\n        }\\n       \\n        return {minimum,v11[v11.size()-1]-v11[0]};\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* temp=head;\\n        ListNode* temp2=head->next;\\n         ListNode* temp11=head;\\n        ListNode* temp12=head->next;\\n       \\n        int i=1;\\n        int index=INT_MAX;\\n        int prev=0;\\n        int minimum=INT_MAX;\\n        while(temp2->next!=NULL)\\n        {\\n if(temp2->val>temp->val && temp2->val>temp2->next->val || temp2->val<temp->val && temp2->val<temp2->next->val )\\n            {\\n                if(prev!=0)\\n                {\\n                    minimum=min(minimum,i-prev);\\n                }\\n                prev=i;\\n                index=min(index,i);\\n              \\n            }\\n            i++;\\n            temp2=temp2->next;\\n            temp=temp->next;\\n        }\\n       \\n        if(minimum>0&&prev-index>0)\\n        {\\n            return{minimum,abs(prev-index)};\\n        }\\n        return {-1,-1};\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617590,
                "title": "c-solution-dfs-easy-sol",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        vector<int> vis(1001,0);\\n        queue<int> q;\\n        int ans=0;\\n        q.push(start);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n            int curr=q.front();\\n            q.pop();\\n            if(curr==goal)\\n                return ans;\\n            if(curr<0 or curr>1000 or vis[curr]) continue;\\n                vis[curr]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                q.push(curr+nums[i]);\\n                q.push(curr-nums[i]);\\n                q.push(curr^nums[i]);\\n            }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumOperations(vector<int>& nums, int start, int goal) {\\n        int n=nums.size();\\n        vector<int> vis(1001,0);\\n        queue<int> q;\\n        int ans=0;\\n        q.push(start);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            while(s--)\\n            {\\n            int curr=q.front();\\n            q.pop();\\n            if(curr==goal)\\n                return ans;\\n            if(curr<0 or curr>1000 or vis[curr]) continue;\\n                vis[curr]=1;\\n            for(int i=0;i<n;i++)\\n            {\\n                q.push(curr+nums[i]);\\n                q.push(curr-nums[i]);\\n                q.push(curr^nums[i]);\\n            }\\n                \\n            }\\n            ans++;\\n            \\n        }\\n        return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575573,
                "title": "java-easy-code",
                "content": "class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        ListNode prev=head;\\n        ListNode curr= head.next;\\n        int first_index=-1;\\n        int prev_index=-1;\\n        int i=1;\\n        int min = Integer.MAX_VALUE;\\n        while(curr.next!=null)\\n        {\\n            if(prev.val>curr.val && curr.val<curr.next.val || prev.val<curr.val && curr.val>curr.next.val)\\n            {\\n                if(first_index==-1)\\n                {\\n                    first_index=i;\\n                }\\n                if(prev_index!=-1)\\n                {\\n                    min=Math.min(min,i-prev_index);\\n                }\\n                \\n                prev_index=i;\\n            }\\n            \\n            prev=curr;\\n            curr=curr.next;\\n            ++i;\\n        }\\n        \\n        if(min==Integer.MAX_VALUE)\\n        {\\n            return new int[] {-1,-1};\\n        }\\n        \\n        \\n        return new int[] {min,prev_index-first_index};\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        ListNode prev=head;\\n        ListNode curr= head.next;\\n        int first_index=-1;\\n        int prev_index=-1;\\n        int i=1;\\n        int min = Integer.MAX_VALUE;\\n        while(curr.next!=null)\\n        {\\n            if(prev.val>curr.val && curr.val<curr.next.val || prev.val<curr.val && curr.val>curr.next.val)\\n            {\\n                if(first_index==-1)\\n                {\\n                    first_index=i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1563498,
                "title": "java-3-pointers-o-n",
                "content": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        if (head == null || head.next == null || head.next.next == null) {\\n            return new int[] {-1, -1};\\n        }\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        ListNode x = head;\\n        ListNode y = head.next; // mid element\\n        ListNode z = head.next.next;\\n        int previous = 0;\\n        int first = 0;\\n        int current = 1;\\n\\n        while (z != null) {\\n            if ((x.val < y.val && y.val > z.val) || (x.val > y.val && y.val < z.val)) {\\n                if (first == 0) {\\n                    first = current;\\n                } else {\\n                    max = current - first;\\n                }\\n                if (previous != 0) {\\n                    min = Math.min(min, current - previous);\\n                }\\n                previous = current;\\n            }\\n            z = z.next;\\n            x = x.next;\\n            y = y.next;\\n            current++;\\n        }\\n        if (min == Integer.MAX_VALUE) {\\n            return new int[] {-1, -1};\\n        }\\n        return new int[] { min, max };\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        \\n        if (head == null || head.next == null || head.next.next == null) {\\n            return new int[] {-1, -1}",
                "codeTag": "Java"
            },
            {
                "id": 1558888,
                "title": "c-single-iteration-readable",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if (head == NULL || head->next == NULL || head->next->next == NULL || head->next->next->next == NULL)\\n            return { -1, -1};\\n\\n        int minCriticalPoint = -1;\\n        int maxCriticalPoint = -1;\\n\\n        int prevCriticalPoint = -1;\\n\\n        int minDistance = INT_MAX;\\n\\n        ListNode* prev = head;\\n        ListNode* cur = head->next;\\n\\n        int i = 0;\\n        while (cur->next) {\\n            ListNode* next = cur->next;\\n            //If Critical Point\\n            if ( (prev->val < cur->val && next->val < cur->val) || (prev->val > cur->val && next->val > cur->val) ) {\\n                 if (minCriticalPoint != -1)\\n                    maxCriticalPoint = i;\\n                \\n                if (minCriticalPoint == -1) {\\n                    minCriticalPoint = i;\\n                }\\n\\n                if (prevCriticalPoint != -1)\\n                    minDistance = min(minDistance, abs(i - prevCriticalPoint));\\n                prevCriticalPoint = i;\\n            }\\n\\n            prev = cur;\\n            cur = next;\\n            ++i;\\n        }\\n\\n        if (minCriticalPoint != -1 && maxCriticalPoint != -1) {\\n            return {minDistance, abs(minCriticalPoint - maxCriticalPoint)};\\n        }\\n        return { -1, -1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if (head == NULL || head->next == NULL || head->next->next == NULL || head->next->next->next == NULL)\\n            return { -1, -1};\\n\\n        int minCriticalPoint = -1;\\n        int maxCriticalPoint = -1;\\n\\n        int prevCriticalPoint = -1;\\n\\n        int minDistance = INT_MAX;\\n\\n        ListNode* prev = head;\\n        ListNode* cur = head->next;\\n\\n        int i = 0;\\n        while (cur->next) {\\n            ListNode* next = cur->next;\\n            //If Critical Point\\n            if ( (prev->val < cur->val && next->val < cur->val) || (prev->val > cur->val && next->val > cur->val) ) {\\n                 if (minCriticalPoint != -1)\\n                    maxCriticalPoint = i;\\n                \\n                if (minCriticalPoint == -1) {\\n                    minCriticalPoint = i;\\n                }\\n\\n                if (prevCriticalPoint != -1)\\n                    minDistance = min(minDistance, abs(i - prevCriticalPoint));\\n                prevCriticalPoint = i;\\n            }\\n\\n            prev = cur;\\n            cur = next;\\n            ++i;\\n        }\\n\\n        if (minCriticalPoint != -1 && maxCriticalPoint != -1) {\\n            return {minDistance, abs(minCriticalPoint - maxCriticalPoint)};\\n        }\\n        return { -1, -1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557329,
                "title": "java-easy",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null || head.next.next == null || head.next.next.next == null){\\n            return new int[]{-1, -1};\\n        }\\n        List<Integer> indices = new ArrayList<>();\\n        ListNode itr = head.next;\\n        ListNode prev = head;\\n        ListNode nxt = itr.next;\\n        int i=1;\\n        while(itr.next!=null){\\n            if((prev.val > itr.val && itr.val < nxt.val) || (prev.val < itr.val && itr.val > nxt.val)){\\n                indices.add(i);\\n            }\\n            prev = itr;\\n            itr = nxt;\\n            nxt = nxt.next;\\n            i++;\\n        }\\n        for(int ind : indices){\\n            System.out.print(ind + \"  \");\\n        }\\n        Collections.sort(indices);\\n        \\n        int[] ans = new int[2];\\n        if(indices.size()<=1){\\n            return new int[]{-1,-1};\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int ind=0;ind<indices.size()-1;ind++){\\n            min = Math.min(min, indices.get(ind+1) - indices.get(ind));\\n        }\\n        ans[0] = min;\\n        ans[1] = indices.get(indices.size()-1)-indices.get(0);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null || head.next.next == null || head.next.next.next == null){\\n            return new int[]{-1, -1};\\n        }\\n        List<Integer> indices = new ArrayList<>();\\n        ListNode itr = head.next;\\n        ListNode prev = head;\\n        ListNode nxt = itr.next;\\n        int i=1;\\n        while(itr.next!=null){\\n            if((prev.val > itr.val && itr.val < nxt.val) || (prev.val < itr.val && itr.val > nxt.val)){\\n                indices.add(i);\\n            }\\n            prev = itr;\\n            itr = nxt;\\n            nxt = nxt.next;\\n            i++;\\n        }\\n        for(int ind : indices){\\n            System.out.print(ind + \"  \");\\n        }\\n        Collections.sort(indices);\\n        \\n        int[] ans = new int[2];\\n        if(indices.size()<=1){\\n            return new int[]{-1,-1};\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int ind=0;ind<indices.size()-1;ind++){\\n            min = Math.min(min, indices.get(ind+1) - indices.get(ind));\\n        }\\n        ans[0] = min;\\n        ans[1] = indices.get(indices.size()-1)-indices.get(0);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555638,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>all;\\n        \\n        ListNode *curr=head;\\n        if(head==NULL || head->next==NULL)\\n            return {-1,-1};\\n        int i=0;\\n        while(curr->next->next!=NULL)\\n        {\\n            if(curr->next->val>curr->val && curr->next->val>curr->next->next->val)\\n                all.push_back(i);\\n            \\n            if(curr->next->val<curr->val && curr->next->val<curr->next->next->val)\\n                all.push_back(i);\\n            \\n            curr=curr->next;\\n            i++;            \\n        }\\n        \\n        if(all.size()<2)\\n            return {-1,-1};\\n        \\n        int mina=INT_MAX;\\n        for(int i=0; i<all.size()-1; i++)\\n        {\\n            mina=min(mina,all[i+1]-all[i]);\\n        }\\n        \\n        return {mina,all[all.size()-1]-all[0]};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>all;\\n        \\n        ListNode *curr=head;\\n        if(head==NULL || head->next==NULL)\\n            return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1555168,
                "title": "a-few-solutions",
                "content": "Use a sliding window `a`,`b`,`c` to perform a linear scan of the linked list and place index `i` into an array `A` to store each \"critical point\".\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun nodesBetweenCriticalPoints(head: ListNode?): IntArray {\\n        if (head == null || head?.next == null || head?.next?.next == null)\\n            return intArrayOf(-1, -1)\\n        var (a, b, c) = listOf(head, head?.next, head?.next?.next)\\n        var lower = { a: ListNode?, b: ListNode?, c: ListNode? -> a!!.`val` > b!!.`val` && b!!.`val` < c!!.`val` }\\n        var upper = { a: ListNode?, b: ListNode?, c: ListNode? -> a!!.`val` < b!!.`val` && b!!.`val` > c!!.`val` }\\n        var i = 1\\n        var A = mutableListOf<Int>()\\n        while (c != null) {\\n            if (lower(a, b, c) || upper(a, b, c))\\n                A.add(i)\\n            ++i; a = b; b = c; c = c?.next  // \\uD83D\\uDC49 slide window\\n        }\\n        if (A.size < 2)\\n            return intArrayOf(-1, -1)\\n        var lo = A.mapIndexed{ i, _ -> if (0 < i) A[i] - A[i - 1] else (1e9 + 7).toInt() }.min()!!\\n        var hi = A.last() - A.first()\\n        return intArrayOf(lo, hi)\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet nodesBetweenCriticalPoints = head => {\\n    if (!head || !head.next || !head.next.next)\\n        return [-1, -1];\\n    let a = head,\\n        b = head.next,\\n        c = head.next.next;\\n    let lower = (a, b, c) => a.val > b.val && b.val < c.val;\\n    let upper = (a, b, c) => a.val < b.val && b.val > c.val;\\n    let [i, A] = [1, []];\\n    while (c) {\\n        if (lower(a, b, c) || upper(a, b, c))\\n            A.push(i);\\n        ++i, a = b, b = c, c = c.next;  // \\uD83D\\uDC49 slide window\\n    }\\n    if (A.length < 2)\\n        return [-1, -1];\\n    let lo = Math.min(...A.map((_, i) => 0 < i ? A[i] - A[i - 1] : Infinity));\\n    let hi = A[A.length - 1] - A[0];\\n    return [lo, hi];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if not head or not head.next or not head.next.next:\\n            return [-1, -1]\\n        lower = lambda a, b, c: a.val > b.val < c.val\\n        upper = lambda a, b, c: a.val < b.val > c.val\\n        a, b, c = head, head.next, head.next.next\\n        i, A = 1, []\\n        while c:\\n            if lower(a, b, c) or upper(a, b, c):\\n                A.append(i)\\n            i += 1; a = b; b = c; c = c.next  # \\uD83D\\uDC49 slide window\\n        if len(A) < 2:\\n            return [-1, -1]\\n        lo = min(A[i] - A[i - 1] for i in range(1, len(A)))\\n        hi = A[-1] - A[0]\\n        return [lo, hi]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Deque = deque<int>;\\n    VI nodesBetweenCriticalPoints(ListNode* head, VI A = {}) {\\n        if (!head || !head->next || !head->next->next)\\n            return { -1, -1 };\\n        auto a = head,\\n             b = head->next,\\n             c = head->next->next;\\n        auto lower = [](auto a, auto b, auto c) { return a->val > b->val && b->val < c->val; };\\n        auto upper = [](auto a, auto b, auto c) { return a->val < b->val && b->val > c->val; };\\n        auto i = 1;\\n        while (c) {\\n            if (lower(a, b, c) || upper(a, b, c))\\n                A.push_back(i);\\n            ++i, a = b, b = c, c = c->next;  // \\uD83D\\uDC49 slide window\\n        }\\n        if (A.size() < 2)\\n            return { -1, -1 };\\n        Deque D;\\n        adjacent_difference(A.begin(), A.end(), back_inserter(D)), D.pop_front();\\n        auto lo = *min_element(D.begin(), D.end());\\n        auto hi = A.back() - A.front();\\n        return { lo, hi };\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun nodesBetweenCriticalPoints(head: ListNode?): IntArray {\\n        if (head == null || head?.next == null || head?.next?.next == null)\\n            return intArrayOf(-1, -1)\\n        var (a, b, c) = listOf(head, head?.next, head?.next?.next)\\n        var lower = { a: ListNode?, b: ListNode?, c: ListNode? -> a!!.`val` > b!!.`val` && b!!.`val` < c!!.`val` }\\n        var upper = { a: ListNode?, b: ListNode?, c: ListNode? -> a!!.`val` < b!!.`val` && b!!.`val` > c!!.`val` }\\n        var i = 1\\n        var A = mutableListOf<Int>()\\n        while (c != null) {\\n            if (lower(a, b, c) || upper(a, b, c))\\n                A.add(i)\\n            ++i; a = b; b = c; c = c?.next  // \\uD83D\\uDC49 slide window\\n        }\\n        if (A.size < 2)\\n            return intArrayOf(-1, -1)\\n        var lo = A.mapIndexed{ i, _ -> if (0 < i) A[i] - A[i - 1] else (1e9 + 7).toInt() }.min()!!\\n        var hi = A.last() - A.first()\\n        return intArrayOf(lo, hi)\\n    }\\n}\\n```\n```\\nlet nodesBetweenCriticalPoints = head => {\\n    if (!head || !head.next || !head.next.next)\\n        return [-1, -1];\\n    let a = head,\\n        b = head.next,\\n        c = head.next.next;\\n    let lower = (a, b, c) => a.val > b.val && b.val < c.val;\\n    let upper = (a, b, c) => a.val < b.val && b.val > c.val;\\n    let [i, A] = [1, []];\\n    while (c) {\\n        if (lower(a, b, c) || upper(a, b, c))\\n            A.push(i);\\n        ++i, a = b, b = c, c = c.next;  // \\uD83D\\uDC49 slide window\\n    }\\n    if (A.length < 2)\\n        return [-1, -1];\\n    let lo = Math.min(...A.map((_, i) => 0 < i ? A[i] - A[i - 1] : Infinity));\\n    let hi = A[A.length - 1] - A[0];\\n    return [lo, hi];\\n};\\n```\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if not head or not head.next or not head.next.next:\\n            return [-1, -1]\\n        lower = lambda a, b, c: a.val > b.val < c.val\\n        upper = lambda a, b, c: a.val < b.val > c.val\\n        a, b, c = head, head.next, head.next.next\\n        i, A = 1, []\\n        while c:\\n            if lower(a, b, c) or upper(a, b, c):\\n                A.append(i)\\n            i += 1; a = b; b = c; c = c.next  # \\uD83D\\uDC49 slide window\\n        if len(A) < 2:\\n            return [-1, -1]\\n        lo = min(A[i] - A[i - 1] for i in range(1, len(A)))\\n        hi = A[-1] - A[0]\\n        return [lo, hi]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Deque = deque<int>;\\n    VI nodesBetweenCriticalPoints(ListNode* head, VI A = {}) {\\n        if (!head || !head->next || !head->next->next)\\n            return { -1, -1 };\\n        auto a = head,\\n             b = head->next,\\n             c = head->next->next;\\n        auto lower = [](auto a, auto b, auto c) { return a->val > b->val && b->val < c->val; };\\n        auto upper = [](auto a, auto b, auto c) { return a->val < b->val && b->val > c->val; };\\n        auto i = 1;\\n        while (c) {\\n            if (lower(a, b, c) || upper(a, b, c))\\n                A.push_back(i);\\n            ++i, a = b, b = c, c = c->next;  // \\uD83D\\uDC49 slide window\\n        }\\n        if (A.size() < 2)\\n            return { -1, -1 };\\n        Deque D;\\n        adjacent_difference(A.begin(), A.end(), back_inserter(D)), D.pop_front();\\n        auto lo = *min_element(D.begin(), D.end());\\n        auto hi = A.back() - A.front();\\n        return { lo, hi };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551962,
                "title": "java-easy",
                "content": "**NOTE : For the sake of simplicity I used ArrayList here , if you want you can do it without using AL.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n      //MAX DISTANCE will lie btw first and last critical points\\n      //MIN DISTANCE will lie btw adjacent critical points\\n        int res[] = {Integer.MAX_VALUE,Integer.MIN_VALUE};\\n        int prev = head.val;\\n        ListNode node = head.next;\\n        int i = 1;\\n        List<Integer> lst = new ArrayList<>();\\n        while(node.next != null){\\n          //For minima\\n           if(node.val < prev && node.val < node.next.val){\\n               lst.add(i);\\n           }\\n          //For maxima\\n           if(node.val > prev && node.val > node.next.val){\\n               lst.add(i);\\n           }\\n           i++;\\n           prev = node.val;\\n           node = node.next;\\n          \\n        }\\n       //If we have less than 2 critical points \\n         if(lst.size() < 2) return new int[]{-1,-1};\\n      \\n        int fmax = -1; //first index of critical point\\n        prev = -1; //prev index of critical point\\n        for(int idx : lst){\\n           if(fmax == -1) {\\n             fmax = idx;\\n           }\\n           else{ \\n            res[0] = Math.min(res[0],idx - prev );\\n            res[1] = Math.max(res[1],idx - fmax );\\n           }\\n           prev = idx;\\n        }\\n       \\n        return res;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n      //MAX DISTANCE will lie btw first and last critical points\\n      //MIN DISTANCE will lie btw adjacent critical points\\n        int res[] = {Integer.MAX_VALUE,Integer.MIN_VALUE};\\n        int prev = head.val;\\n        ListNode node = head.next;\\n        int i = 1;\\n        List<Integer> lst = new ArrayList<>();\\n        while(node.next != null){\\n          //For minima\\n           if(node.val < prev && node.val < node.next.val){\\n               lst.add(i);\\n           }\\n          //For maxima\\n           if(node.val > prev && node.val > node.next.val){\\n               lst.add(i);\\n           }\\n           i++;\\n           prev = node.val;\\n           node = node.next;\\n          \\n        }\\n       //If we have less than 2 critical points \\n         if(lst.size() < 2) return new int[]{-1,-1};\\n      \\n        int fmax = -1; //first index of critical point\\n        prev = -1; //prev index of critical point\\n        for(int idx : lst){\\n           if(fmax == -1) {\\n             fmax = idx;\\n           }\\n           else{ \\n            res[0] = Math.min(res[0],idx - prev );\\n            res[1] = Math.max(res[1],idx - fmax );\\n           }\\n           prev = idx;\\n        }\\n       \\n        return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551609,
                "title": "c-using-vectors",
                "content": "\\'\\'\\'\\n vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v,ind,res; \\n        int n = v.size();\\n\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n         for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] > v[i - 1] and v[i] > v[i + 1]) ind.push_back(i+1);\\n            else if(v[i] < v[i - 1] and v[i] < v[i + 1]) ind.push_back(i+1);\\n        }\\n        sort(ind.begin(), ind.end());\\n         if(ind.size()<2)return vector<int>{-1,-1};\\n        \\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        \\n        for(int i = 1; i < ind.size(); i++){\\n            mini = min(abs(ind[i] - ind[i - 1]), mini);\\n        }\\n        maxi = (maxi,(ind[ind.size()-1]-ind[0]));\\n\\n        \\n            res.push_back(mini);\\n            res.push_back(maxi);\\n        \\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v,ind,res; \\n        int n = v.size();\\n\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n         for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] > v[i - 1] and v[i] > v[i + 1]) ind.push_back(i+1);\\n            else if(v[i] < v[i - 1] and v[i] < v[i + 1]) ind.push_back(i+1);\\n        }\\n        sort(ind.begin(), ind.end());\\n         if(ind.size()<2)return vector<int>{-1,-1};\\n        \\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        \\n        for(int i = 1; i < ind.size(); i++){\\n            mini = min(abs(ind[i] - ind[i - 1]), mini);\\n        }\\n        maxi = (maxi,(ind[ind.size()-1]-ind[0]));\\n\\n        \\n            res.push_back(mini);\\n            res.push_back(maxi);\\n        \\n        \\n        return res;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1551353,
                "title": "python-o-1-memory-o-n-time-beats-100-00",
                "content": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        min_res = math.inf\\n        min_point = max_point = last_point = None\\n        prev_val = head.val\\n        head = head.next\\n        i = 1\\n        while head.next:\\n            if ((head.next.val < head.val and prev_val < head.val) or\\n               (head.next.val > head.val and prev_val > head.val)):\\n                \\n                if min_point is None:\\n                    min_point = i\\n                else:\\n                    max_point = i\\n                \\n                if last_point:\\n                    min_res = min(min_res, i - last_point)\\n                \\n                last_point = i\\n            \\n            prev_val = head.val\\n            i += 1\\n            head = head.next\\n        \\n        if min_res == math.inf:\\n            min_res = -1\\n        max_res = max_point - min_point if max_point else -1\\n        \\n        return [min_res, max_res]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        min_res = math.inf\\n        min_point = max_point = last_point = None\\n        prev_val = head.val\\n        head = head.next\\n        i = 1\\n        while head.next:\\n            if ((head.next.val < head.val and prev_val < head.val) or\\n               (head.next.val > head.val and prev_val > head.val)):\\n                \\n                if min_point is None:\\n                    min_point = i\\n                else:\\n                    max_point = i\\n                \\n                if last_point:\\n                    min_res = min(min_res, i - last_point)\\n                \\n                last_point = i\\n            \\n            prev_val = head.val\\n            i += 1\\n            head = head.next\\n        \\n        if min_res == math.inf:\\n            min_res = -1\\n        max_res = max_point - min_point if max_point else -1\\n        \\n        return [min_res, max_res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551287,
                "title": "bruh-this-is-the-easiest-solution-you-can-find",
                "content": "**maximum distance - first and last critical points\\nminimum distance - between the 2 neighboring critical points**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {             \\n        vector<int> criticalPoints; \\n        int i=1; \\n        ListNode* curr = head->next; \\n        int prev = head->val ; \\n        while(curr->next) {\\n            if(curr->val > prev && curr->val> curr->next->val)                          \\n                criticalPoints.push_back(i); \\n            else if(curr->val < prev && curr->val < curr->next->val)\\n                criticalPoints.push_back(i); \\n            prev = curr->val;             \\n            curr = curr->next; \\n            i++;\\n        }        \\n        if(criticalPoints.size()<2) {\\n            return {-1,-1}; \\n        }\\n        vector<int> result;          \\n        int minDist = INT_MAX;\\n        for(int i=1;i<criticalPoints.size();i++) {\\n            minDist = min(minDist , criticalPoints[i]-criticalPoints[i-1]); \\n        }\\n        result.push_back(minDist); \\n        result.push_back(criticalPoints[criticalPoints.size()-1] - criticalPoints[0]);\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {             \\n        vector<int> criticalPoints; \\n        int i=1; \\n        ListNode* curr = head->next; \\n        int prev = head->val ; \\n        while(curr->next) {\\n            if(curr->val > prev && curr->val> curr->next->val)                          \\n                criticalPoints.push_back(i); \\n            else if(curr->val < prev && curr->val < curr->next->val)\\n                criticalPoints.push_back(i); \\n            prev = curr->val;             \\n            curr = curr->next; \\n            i++;\\n        }        \\n        if(criticalPoints.size()<2) {\\n            return {-1,-1}; \\n        }\\n        vector<int> result;          \\n        int minDist = INT_MAX;\\n        for(int i=1;i<criticalPoints.size();i++) {\\n            minDist = min(minDist , criticalPoints[i]-criticalPoints[i-1]); \\n        }\\n        result.push_back(minDist); \\n        result.push_back(criticalPoints[criticalPoints.size()-1] - criticalPoints[0]);\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550730,
                "title": "c-100-100",
                "content": "```\\npublic int[] NodesBetweenCriticalPoints(ListNode head)\\n{\\n\\tint firstIndex = -1;\\n\\tint prevIndex = -1;\\n\\tint lastIndex = -1;\\n\\tvar prevNode = head;\\n\\tvar currNode = head.next;\\n\\tvar currIndex = 1;\\n\\tvar min = -1;\\n\\twhile (currNode.next != null)\\n\\t{\\n\\t\\tif (IsCritical(currNode, prevNode))\\n\\t\\t{\\n\\t\\t\\tif (firstIndex == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstIndex = currIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (prevIndex == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmin = currIndex - firstIndex;\\n\\t\\t\\t\\t\\tprevIndex = currIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (min > currIndex - prevIndex)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin = currIndex - prevIndex;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tprevIndex = currIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIndex = currIndex;\\n\\t\\t}\\n\\t\\tprevNode = currNode;\\n\\t\\tcurrNode = currNode.next;\\n\\t\\tcurrIndex++;\\n\\t}\\n\\tif (firstIndex == -1 || firstIndex == lastIndex) return new[] { -1, -1 };\\n\\tvar rs = new[] { min, lastIndex - firstIndex };\\n\\treturn rs;\\n}\\nprivate bool IsCritical(ListNode currNode, ListNode prevNode)\\n{\\n\\tif (prevNode.val > currNode.val && currNode.val < currNode.next.val) return true;\\n\\tif (prevNode.val < currNode.val && currNode.val > currNode.next.val) return true;\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] NodesBetweenCriticalPoints(ListNode head)\\n{\\n\\tint firstIndex = -1;\\n\\tint prevIndex = -1;\\n\\tint lastIndex = -1;\\n\\tvar prevNode = head;\\n\\tvar currNode = head.next;\\n\\tvar currIndex = 1;\\n\\tvar min = -1;\\n\\twhile (currNode.next != null)\\n\\t{\\n\\t\\tif (IsCritical(currNode, prevNode))\\n\\t\\t{\\n\\t\\t\\tif (firstIndex == -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfirstIndex = currIndex;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (prevIndex == -1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmin = currIndex - firstIndex;\\n\\t\\t\\t\\t\\tprevIndex = currIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (min > currIndex - prevIndex)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tmin = currIndex - prevIndex;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tprevIndex = currIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlastIndex = currIndex;\\n\\t\\t}\\n\\t\\tprevNode = currNode;\\n\\t\\tcurrNode = currNode.next;\\n\\t\\tcurrIndex++;\\n\\t}\\n\\tif (firstIndex == -1 || firstIndex == lastIndex) return new[] { -1, -1 };\\n\\tvar rs = new[] { min, lastIndex - firstIndex };\\n\\treturn rs;\\n}\\nprivate bool IsCritical(ListNode currNode, ListNode prevNode)\\n{\\n\\tif (prevNode.val > currNode.val && currNode.val < currNode.next.val) return true;\\n\\tif (prevNode.val < currNode.val && currNode.val > currNode.next.val) return true;\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550531,
                "title": "c-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n     \\n        vector<int> v;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        vector<int> cp;\\n        \\n        int n=v.size();\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n                cp.push_back(i);\\n            \\n         else if(v[i]<v[i-1]&&v[i]<v[i+1])\\n                cp.push_back(i);\\n        }\\n        \\n        if(cp.size()==0||cp.size()==1)\\n            return {-1,-1};\\n        \\n\\n        vector<int> ans;\\n        \\n        int minn=INT_MAX,maxx=cp[cp.size()-1]-cp[0];\\n        \\n        for(int i=1;i<cp.size();i++){\\n            minn=min(minn,cp[i]-cp[i-1]);\\n            \\n        }\\n        \\n        return {minn,maxx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n     \\n        vector<int> v;\\n        \\n        ListNode *temp=head;\\n        \\n        while(temp){\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        \\n        vector<int> cp;\\n        \\n        int n=v.size();\\n        \\n        for(int i=1;i<n-1;i++){\\n            \\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n                cp.push_back(i);\\n            \\n         else if(v[i]<v[i-1]&&v[i]<v[i+1])\\n                cp.push_back(i);\\n        }\\n        \\n        if(cp.size()==0||cp.size()==1)\\n            return {-1,-1};\\n        \\n\\n        vector<int> ans;\\n        \\n        int minn=INT_MAX,maxx=cp[cp.size()-1]-cp[0];\\n        \\n        for(int i=1;i<cp.size();i++){\\n            minn=min(minn,cp[i]-cp[i-1]);\\n            \\n        }\\n        \\n        return {minn,maxx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550379,
                "title": "java-one-pass",
                "content": "minDist =  minimum distance between any two distinct critical points \\nfirstIdx = index of first local minima or maxima\\nlastIdx = index of latest local minima or maxima\\nprevValue = previous node value\\ni = current index\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int minDist=Integer.MAX_VALUE;\\n        int i=0, firstIdx=-1, lastIdx=-1, prevValue=head.val;\\n        while(head.next != null){\\n\\t\\t\\t// check critical point\\n            if((head.val > prevValue && head.val > head.next.val) ||\\n               (head.val < prevValue && head.val < head.next.val)){\\n                if(firstIdx == -1){\\n                    firstIdx = i;\\n                }\\n                else {\\n                    minDist = Math.min(minDist, i-lastIdx);\\n                }\\n                lastIdx = i;\\n            }\\n            i++;\\n            prevValue = head.val;\\n            head = head.next;\\n        }\\n        \\n\\t\\t// if no critical point or only one critical point is found return [-1, -1]\\n        if(lastIdx == firstIdx) return new int[]{-1, -1};\\n        return new int[]{minDist, lastIdx - firstIdx};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int minDist=Integer.MAX_VALUE;\\n        int i=0, firstIdx=-1, lastIdx=-1, prevValue=head.val;\\n        while(head.next != null){\\n\\t\\t\\t// check critical point\\n            if((head.val > prevValue && head.val > head.next.val) ||\\n               (head.val < prevValue && head.val < head.next.val)){\\n                if(firstIdx == -1){\\n                    firstIdx = i;\\n                }\\n                else {\\n                    minDist = Math.min(minDist, i-lastIdx);\\n                }\\n                lastIdx = i;\\n            }\\n            i++;\\n            prevValue = head.val;\\n            head = head.next;\\n        }\\n        \\n\\t\\t// if no critical point or only one critical point is found return [-1, -1]\\n        if(lastIdx == firstIdx) return new int[]{-1, -1};\\n        return new int[]{minDist, lastIdx - firstIdx};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550363,
                "title": "java-single-pass-o-n-time-easy-to-understand",
                "content": "An arraylist maintains the indices of critical points.\\nThe maximum difference is the difference between first and last element of the list.\\nThe minimum difference between the current and previous critical point is stored while iterating to avoid another iteration.\\n```\\nclass Solution\\n{\\n    public int[] nodesBetweenCriticalPoints(ListNode head)\\n    {\\n        List<Integer> id = new LinkedList<>();\\n        int prev = head.val;\\n        head = head.next;\\n        int count = 0;\\n        int min = Integer.MAX_VALUE;\\n        while(head.next != null)\\n        {\\n            count++; // Counting the present index of node\\n            if((head.val > prev && head.val > head.next.val)||(head.val < prev && head.val < head.next.val)) // Checking for critical point\\n            {\\n                if(id.size() >= 1)\\n                    min = Math.min(min,count-id.get(id.size()-1)); // Comparing minimum and the current difference\\n                id.add(count);\\n            }\\n            prev = head.val; // Maintaining previous node\\'s value\\n            head = head.next;\\n        }\\n        if(id.size() < 2)\\n            return new int[]{-1,-1};\\n        return new int[]{min,id.get(id.size()-1)-id.get(0)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] nodesBetweenCriticalPoints(ListNode head)\\n    {\\n        List<Integer> id = new LinkedList<>();\\n        int prev = head.val;\\n        head = head.next;\\n        int count = 0;\\n        int min = Integer.MAX_VALUE;\\n        while(head.next != null)\\n        {\\n            count++; // Counting the present index of node\\n            if((head.val > prev && head.val > head.next.val)||(head.val < prev && head.val < head.next.val)) // Checking for critical point\\n            {\\n                if(id.size() >= 1)\\n                    min = Math.min(min,count-id.get(id.size()-1)); // Comparing minimum and the current difference\\n                id.add(count);\\n            }\\n            prev = head.val; // Maintaining previous node\\'s value\\n            head = head.next;\\n        }\\n        if(id.size() < 2)\\n            return new int[]{-1,-1};\\n        return new int[]{min,id.get(id.size()-1)-id.get(0)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550325,
                "title": "c-100-fast-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL || head->next->next->next==NULL)\\n             return {-1,-1};\\n        vector<int>cp;\\n        int critical_index=2;\\n        ListNode * tmp=head->next;\\n        ListNode* s=head;\\n        ListNode* f=tmp->next;\\n        while(f){\\n            if(tmp->val > f->val && tmp->val > s->val) cp.push_back(critical_index);\\n            if(tmp->val < f->val && tmp->val < s->val) cp.push_back(critical_index);\\n            critical_index++;\\n             s=tmp;\\n            tmp=f;\\n            f=f->next;\\n        }\\n            if(cp.size()<2) return {-1,-1};\\n            int mx=*max_element(cp.begin(),cp.end());\\n            int mn=*min_element(cp.begin(),cp.end());\\n            int mini=INT_MAX;\\n             for(int i=1; i<cp.size(); i++){\\n                 mini=min(cp[i]-cp[i-1],mini);\\n             }\\n         return {mini,mx-mn};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL || head->next->next->next==NULL)\\n             return {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1550245,
                "title": "python-easy-solution",
                "content": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        l = []\\n        while head:\\n            x = head.val\\n            l.append(x)\\n            head = head.next\\n\\n        l1 = []\\n\\n        if len(l) < 3:\\n            return [-1, -1]\\n\\n        for i in range(1, len(l) - 1):\\n            if l[i] > l[i - 1] and l[i] > l[i + 1]:\\n                l1.append(i)\\n\\n            if l[i] < l[i - 1] and l[i] < l[i + 1]:\\n                l1.append(i)\\n\\n        # print(l1)\\n\\n        if len(l1) < 2 and len(l1) < 2:\\n            return [-1, -1]\\n\\n        if len(l1) == 2 and len(l1) == 2:\\n            return [(l1[1] - l1[0]), (l1[-1] - l1[0])]\\n\\n        if len(l1) == 2 and len(l1) < 2:\\n            return [-1, (l1[-1] - l1[0])]\\n\\n        if len(l1) < 2 and len(l1) == 2:\\n            return [(l1[1] - l1[0]), -1]\\n\\n        a = l1[-1] - l1[0]\\n        b = l1[1] - l1[0]\\n        for i in range(1, len(l1)):\\n            # print(i)\\n            # print(l1[i]-l1[i-1])\\n            b = min(b, l1[i] - l1[i - 1])\\n\\n        return [b, a]\\n```\\nIf u understood the code then plz UPVOTE...thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        l = []\\n        while head:\\n            x = head.val\\n            l.append(x)\\n            head = head.next\\n\\n        l1 = []\\n\\n        if len(l) < 3:\\n            return [-1, -1]\\n\\n        for i in range(1, len(l) - 1):\\n            if l[i] > l[i - 1] and l[i] > l[i + 1]:\\n                l1.append(i)\\n\\n            if l[i] < l[i - 1] and l[i] < l[i + 1]:\\n                l1.append(i)\\n\\n        # print(l1)\\n\\n        if len(l1) < 2 and len(l1) < 2:\\n            return [-1, -1]\\n\\n        if len(l1) == 2 and len(l1) == 2:\\n            return [(l1[1] - l1[0]), (l1[-1] - l1[0])]\\n\\n        if len(l1) == 2 and len(l1) < 2:\\n            return [-1, (l1[-1] - l1[0])]\\n\\n        if len(l1) < 2 and len(l1) == 2:\\n            return [(l1[1] - l1[0]), -1]\\n\\n        a = l1[-1] - l1[0]\\n        b = l1[1] - l1[0]\\n        for i in range(1, len(l1)):\\n            # print(i)\\n            # print(l1[i]-l1[i-1])\\n            b = min(b, l1[i] - l1[i - 1])\\n\\n        return [b, a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550122,
                "title": "python-easy-solution-weekly-contest-265-que-2058",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        s1 = []\\n        s2 = []\\n        curr = head.next\\n        prev = head\\n        i = 2\\n        while curr.next:\\n            if prev.val < curr.val > curr.next.val:\\n                s1.append([curr.val,i])\\n            elif prev.val > curr.val < curr.next.val:\\n                s2.append([curr.val, i])\\n            i += 1\\n            prev = curr\\n            curr = curr.next\\n\\n        res = []\\n        for each in s1:\\n            res.append(each[1])\\n        for each in s2:\\n            res.append(each[1])\\n        if len(res) < 2:\\n            return [-1,-1]\\n        res.sort()\\n\\n        mx = max(res) - min(res)\\n        diff = math.inf\\n        for i in range(len(res)-1):\\n            if res[i + 1] - res[i] < diff:\\n                diff = res[i + 1] - res[i]\\n        return [diff,mx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        s1 = []\\n        s2 = []\\n        curr = head.next\\n        prev = head\\n        i = 2\\n        while curr.next:\\n            if prev.val < curr.val > curr.next.val:\\n                s1.append([curr.val,i])\\n            elif prev.val > curr.val < curr.next.val:\\n                s2.append([curr.val, i])\\n            i += 1\\n            prev = curr\\n            curr = curr.next\\n\\n        res = []\\n        for each in s1:\\n            res.append(each[1])\\n        for each in s2:\\n            res.append(each[1])\\n        if len(res) < 2:\\n            return [-1,-1]\\n        res.sort()\\n\\n        mx = max(res) - min(res)\\n        diff = math.inf\\n        for i in range(len(res)-1):\\n            if res[i + 1] - res[i] < diff:\\n                diff = res[i + 1] - res[i]\\n        return [diff,mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550034,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\t\\t\\tListNode* prev = head;\\n\\t\\t\\tListNode* curr = head -> next;\\n\\t\\t\\tListNode* next = head -> next -> next;\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\tint index = 1;\\n\\t\\t\\twhile(next){\\n\\t\\t\\t\\tif(curr -> val > next -> val && curr -> val > prev -> val){\\n\\t\\t\\t\\t\\ttemp.push_back(index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(curr -> val < next -> val && curr -> val < prev -> val){\\n\\t\\t\\t\\t\\ttemp.push_back(index);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = prev -> next;\\n\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\tnext = next->next;\\n\\t\\t\\t\\tindex++;\\n\\t\\t\\t}\\n\\t\\t\\tint n = temp.size();\\n\\t\\t\\tif(n < 2){\\n\\t\\t\\t\\treturn {-1, -1};\\n\\t\\t\\t}\\n\\t\\t\\tint maxDistance = temp[n - 1] - temp[0];\\n\\t\\t\\tint minDistance = INT_MAX;\\n\\t\\t\\tfor(int i = 1; i < n; i++){\\n\\t\\t\\t\\tminDistance = min(temp[i] - temp[i - 1], minDistance);\\n\\t\\t\\t}\\n\\t\\t\\treturn {minDistance, maxDistance};\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\t\\t\\tListNode* prev = head;\\n\\t\\t\\tListNode* curr = head -> next;\\n\\t\\t\\tListNode* next = head -> next -> next;\\n\\t\\t\\tvector<int> temp;\\n\\t\\t\\tint index = 1;\\n\\t\\t\\twhile(next){\\n\\t\\t\\t\\tif(curr -> val > next -> val && curr -> val > prev -> val){\\n\\t\\t\\t\\t\\ttemp.push_back(index);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4080707,
                "title": "0ms-o-n-c-100-correct-easy-intution-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> ans(2, -1);\\n\\n        if(!head)\\n        return ans;\\n\\n        vector<int> v;\\n        ListNode *pre=head;\\n        ListNode *curr=pre->next;\\n        ListNode *nxt=curr->next;\\n\\n        int i=1;\\n        while(nxt)\\n        {\\n            if((curr->val<pre->val)&&(curr->val<nxt->val))\\n            {\\n                v.push_back(i);\\n            }\\n            \\n            else if((curr->val>pre->val)&&(curr->val>nxt->val))\\n            {\\n                v.push_back(i);\\n            }\\n\\n            pre=curr;\\n            curr=nxt;\\n            nxt=nxt->next;\\n            ++i;\\n        }    \\n\\n        if(v.size()>=2)\\n        {\\n            ans[1]=(v[v.size()-1]-v[0]);\\n\\n            int mini=INT_MAX;\\n            for(int i=1;i<v.size(); ++i)\\n            {\\n                int diff=v[i]-v[i-1];\\n                mini=min(mini, diff);\\n            }\\n\\n            ans[0]=mini;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> ans(2, -1);\\n\\n        if(!head)\\n        return ans;\\n\\n        vector<int> v;\\n        ListNode *pre=head;\\n        ListNode *curr=pre->next;\\n        ListNode *nxt=curr->next;\\n\\n        int i=1;\\n        while(nxt)\\n        {\\n            if((curr->val<pre->val)&&(curr->val<nxt->val))\\n            {\\n                v.push_back(i);\\n            }\\n            \\n            else if((curr->val>pre->val)&&(curr->val>nxt->val))\\n            {\\n                v.push_back(i);\\n            }\\n\\n            pre=curr;\\n            curr=nxt;\\n            nxt=nxt->next;\\n            ++i;\\n        }    \\n\\n        if(v.size()>=2)\\n        {\\n            ans[1]=(v[v.size()-1]-v[0]);\\n\\n            int mini=INT_MAX;\\n            for(int i=1;i<v.size(); ++i)\\n            {\\n                int diff=v[i]-v[i-1];\\n                mini=min(mini, diff);\\n            }\\n\\n            ans[0]=mini;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070645,
                "title": "critical-points-min-and-max-distance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI earlier solved this problem using vector.After that i thought ki why not hold prev and curr critical point as min will always be one of curr-prev and for max we have to hold first and last critical point.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        int idx=2,frst=-1,crr=-1,prv=-1,Min=INT_MAX;\\n        while(curr->next){\\n          if((curr->val>prev->val&&curr->val>curr->next->val)||(curr->val<prev->val&&curr->val<curr->next->val)) {\\n              if(frst==-1) frst=idx;\\n              prv=crr;\\n              crr=idx;\\n              if(prv!=-1){\\n                Min=min(Min,crr-prv);\\n            }\\n          }\\n          idx++;\\n          prev=curr;\\n          curr=curr->next;\\n        }\\n        if(frst==-1 || prv==-1 || Min==INT_MAX) return {-1,-1};\\n        return {Min,crr-frst};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        int idx=2,frst=-1,crr=-1,prv=-1,Min=INT_MAX;\\n        while(curr->next){\\n          if((curr->val>prev->val&&curr->val>curr->next->val)||(curr->val<prev->val&&curr->val<curr->next->val)) {\\n              if(frst==-1) frst=idx;\\n              prv=crr;\\n              crr=idx;\\n              if(prv!=-1){\\n                Min=min(Min,crr-prv);\\n            }\\n          }\\n          idx++;\\n          prev=curr;\\n          curr=curr->next;\\n        }\\n        if(frst==-1 || prv==-1 || Min==INT_MAX) return {-1,-1};\\n        return {Min,crr-frst};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061076,
                "title": "easy-python-solution-in-o-n",
                "content": "# Approach\\nTwo Pointer Approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n\\n        pos = []\\n        \\n        temp1 = head\\n        temp2 = head.next\\n        i = 2\\n\\n        if(temp2.next):\\n            while(temp2.next):\\n                if((temp2.val > temp1.val and temp2.val > temp2.next.val) or (temp2.val < temp1.val and temp2.val < temp2.next.val)):\\n                    pos.append(i)\\n\\n                temp1 = temp1.next\\n                temp2 = temp2.next\\n                i += 1\\n\\n        if(len(pos) < 2):\\n            return [-1,-1]\\n\\n        \\n        min_ = float(\\'inf\\')    #  +infinity\\n\\n        for i in range(1, len(pos)):\\n            min_ = min(min_, pos[i]-pos[i-1])\\n\\n        max_ = pos[-1]-pos[0]\\n       \\n        return [min_,max_]\\n```\\n\\n# Idea\\n\\n1) Assume two pointers \\n2) temp1 is pointed towards head and temp2 is pointed towards 2nd node\\n3) In each iteration we check the node pointed by temp1 is either greater or lesser than the neighbour nodes with the help of temp1\\n4)  If the condition satisfies, the pointers are updated and the position of that condition satisifed node is appended in to an array\\n5) Now after all iterations, we will find max(a-b) and min(a-b) in the array (a and b are any two numbers in the array)\\n\\n\\n\\n##### If you find my solution helpful and worthy, please consider upvoting my solution. Upvotes play a crucial role in ensuring that this valuable content reaches others and helps them as well. \\n\\n##### Only your support motivates me to continue contributing more solutions and assisting the community further.\\n\\n##### Thank You for spending your valuable time.\\n",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n\\n        pos = []\\n        \\n        temp1 = head\\n        temp2 = head.next\\n        i = 2\\n\\n        if(temp2.next):\\n            while(temp2.next):\\n                if((temp2.val > temp1.val and temp2.val > temp2.next.val) or (temp2.val < temp1.val and temp2.val < temp2.next.val)):\\n                    pos.append(i)\\n\\n                temp1 = temp1.next\\n                temp2 = temp2.next\\n                i += 1\\n\\n        if(len(pos) < 2):\\n            return [-1,-1]\\n\\n        \\n        min_ = float(\\'inf\\')    #  +infinity\\n\\n        for i in range(1, len(pos)):\\n            min_ = min(min_, pos[i]-pos[i-1])\\n\\n        max_ = pos[-1]-pos[0]\\n       \\n        return [min_,max_]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044446,
                "title": "beats-98-11-more-simple",
                "content": "# Intuition\\nThe code is designed to find the minimum and maximum distances between critical points in a singly linked list. Critical points are defined as nodes where the value is either greater than both its previous and next nodes or smaller than both its previous and next nodes. The code keeps track of the distances between these critical points and returns the minimum and maximum distances in a vector.\\n\\n# Approach\\nInitialize an empty vector v to store the minimum and maximum distances between critical points.\\nCheck if the input linked list head is either empty or contains only one node. If so, there are no critical points, so we push (-1, -1) into v and return it.\\nInitialize minimumDistance and maximumDistance as positive and negative infinity, respectively, to track the minimum and maximum distances between critical points.\\nInitialize count to 1 to keep track of the current node\\'s position.\\nInitialize posMax and posMin to 0 to keep track of the positions of the last maximum and minimum critical points.\\nUse three pointers: temp, prev, and forward to traverse the linked list. Start with temp and prev pointing to the first two nodes.\\nLoop through the linked list until temp points to the second-to-last node (temp->next != nullptr).\\nInside the loop, check if temp is a critical point by comparing its value to its previous and next nodes. If it is a critical point, update the posMax and posMin positions and calculate the distance between critical points. Update maximumDistance and minimumDistance accordingly.\\nIncrement count, update prev, and move temp and forward pointers to the next nodes.\\nAfter the loop, check if any critical points were found. If not, push (-1, -1) into v.\\nOtherwise, push the minimumDistance and maximumDistance into v.\\nReturn v containing the minimum and maximum distances between critical points.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n\\n        if (head == nullptr || head->next == nullptr) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n            return v;\\n        }\\n\\n        int minimumDistance = INT_MAX;\\n        int maximumDistance = INT_MIN;\\n        int count = 1;\\n        int posMax = 0;\\n        int posMin = 0;\\n\\n        ListNode* temp = head->next;\\n        ListNode* prev = head;\\n        ListNode* forward = nullptr;\\n\\n        while (temp->next != nullptr) {\\n            forward = temp->next;\\n\\n            if ((temp->val > prev->val && temp->val > forward->val) ||\\n                (temp->val < prev->val && temp->val < forward->val)) {\\n                if (posMax == 0 && posMin == 0) {\\n                    posMax = count;\\n                    posMin = count;\\n\\n                } else {\\n                    maximumDistance = max(maximumDistance, count - posMax);\\n                    minimumDistance = min(minimumDistance, count - posMin);\\n                    posMin = count;\\n                }\\n            }\\n            count++;\\n            prev = temp;\\n            temp = forward;\\n        }\\n\\n\\n        if (minimumDistance == INT_MAX  || maximumDistance == INT_MIN ) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        } else {\\n            v.push_back(minimumDistance);\\n            v.push_back(maximumDistance);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n\\n        if (head == nullptr || head->next == nullptr) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n            return v;\\n        }\\n\\n        int minimumDistance = INT_MAX;\\n        int maximumDistance = INT_MIN;\\n        int count = 1;\\n        int posMax = 0;\\n        int posMin = 0;\\n\\n        ListNode* temp = head->next;\\n        ListNode* prev = head;\\n        ListNode* forward = nullptr;\\n\\n        while (temp->next != nullptr) {\\n            forward = temp->next;\\n\\n            if ((temp->val > prev->val && temp->val > forward->val) ||\\n                (temp->val < prev->val && temp->val < forward->val)) {\\n                if (posMax == 0 && posMin == 0) {\\n                    posMax = count;\\n                    posMin = count;\\n\\n                } else {\\n                    maximumDistance = max(maximumDistance, count - posMax);\\n                    minimumDistance = min(minimumDistance, count - posMin);\\n                    posMin = count;\\n                }\\n            }\\n            count++;\\n            prev = temp;\\n            temp = forward;\\n        }\\n\\n\\n        if (minimumDistance == INT_MAX  || maximumDistance == INT_MIN ) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        } else {\\n            v.push_back(minimumDistance);\\n            v.push_back(maximumDistance);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044405,
                "title": "beats-90-38-little-bit-simple",
                "content": "# Intuition\\nThe code aims to find the minimum and maximum distances between critical points in a singly-linked list. Critical points are defined as nodes where the value is either greater than both its previous and next nodes or less than both its previous and next nodes.\\n\\n# Approach\\nInitialize two variables, minimumDistance and maximumDistance, to represent the minimum and maximum distances between critical points. Set them to their respective extreme values using numeric_limits<int>::max() and numeric_limits<int>::min().\\n\\nInitialize count to 2 because we start counting from the second node. posMax and posMin are used to keep track of the positions of the last critical point.\\n\\nIterate through the linked list using three pointers: temp, prev, and forward. temp represents the current node, prev represents the previous node, and forward represents the next node.\\n\\nInside the loop, check if temp is a critical point by comparing its value with prev and forward. If it\\'s a critical point:\\n\\nUpdate posMax and posMin to the current count.\\nIf it\\'s the first critical point encountered, set minimumDistance to INT_MAX - 1 and maximumDistance to INT_MIN + 1. This ensures that the first critical point\\'s distance is correctly calculated.\\nCalculate the distances between critical points and update minimumDistance and maximumDistance accordingly.\\n\\nIncrement count and move prev, temp, and forward pointers to the next nodes.\\n\\nAfter the loop, check if the last node is a critical point, similar to the earlier checks.\\n\\nFinally, check if minimumDistance and maximumDistance are still at their extreme values, indicating that no critical points were found. If so, push -1 for both distances into the result vector v. Otherwise, push the calculated distances.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n\\n        if (head == nullptr || head->next == nullptr) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n            return v;\\n        }\\n\\n        int minimumDistance = numeric_limits<int>::max();\\n        int maximumDistance = numeric_limits<int>::min();\\n        int count = 2;\\n        int posMax = 0;\\n        int posMin = 0;\\n\\n        ListNode* temp = head->next;\\n        ListNode* prev = head;\\n        ListNode* forward = nullptr;\\n\\n        while (temp->next != nullptr) {\\n            forward = temp->next;\\n\\n            if ((temp->val > prev->val && temp->val > forward->val) ||\\n                (temp->val < prev->val && temp->val < forward->val)) {\\n                if (minimumDistance == numeric_limits<int>::max() && maximumDistance == numeric_limits<int>::min()) {\\n                    posMax = count;\\n                    posMin = count;\\n                    minimumDistance = INT_MAX-1 ;\\n                    maximumDistance = INT_MIN+1;\\n                } else {\\n                    maximumDistance = max(maximumDistance, count - posMax);\\n                    minimumDistance = min(minimumDistance, count - posMin);\\n                    posMin = count;\\n                }\\n            }\\n\\n            count++;\\n            prev = temp;\\n            temp = forward;\\n        }\\n\\n\\n        if (minimumDistance == numeric_limits<int>::max() || maximumDistance == numeric_limits<int>::min()||\\n        minimumDistance+1 == numeric_limits<int>::max() || maximumDistance-1 == numeric_limits<int>::min()) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        } else {\\n            v.push_back(minimumDistance);\\n            v.push_back(maximumDistance);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> v;\\n\\n        if (head == nullptr || head->next == nullptr) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n            return v;\\n        }\\n\\n        int minimumDistance = numeric_limits<int>::max();\\n        int maximumDistance = numeric_limits<int>::min();\\n        int count = 2;\\n        int posMax = 0;\\n        int posMin = 0;\\n\\n        ListNode* temp = head->next;\\n        ListNode* prev = head;\\n        ListNode* forward = nullptr;\\n\\n        while (temp->next != nullptr) {\\n            forward = temp->next;\\n\\n            if ((temp->val > prev->val && temp->val > forward->val) ||\\n                (temp->val < prev->val && temp->val < forward->val)) {\\n                if (minimumDistance == numeric_limits<int>::max() && maximumDistance == numeric_limits<int>::min()) {\\n                    posMax = count;\\n                    posMin = count;\\n                    minimumDistance = INT_MAX-1 ;\\n                    maximumDistance = INT_MIN+1;\\n                } else {\\n                    maximumDistance = max(maximumDistance, count - posMax);\\n                    minimumDistance = min(minimumDistance, count - posMin);\\n                    posMin = count;\\n                }\\n            }\\n\\n            count++;\\n            prev = temp;\\n            temp = forward;\\n        }\\n\\n\\n        if (minimumDistance == numeric_limits<int>::max() || maximumDistance == numeric_limits<int>::min()||\\n        minimumDistance+1 == numeric_limits<int>::max() || maximumDistance-1 == numeric_limits<int>::min()) {\\n            v.push_back(-1);\\n            v.push_back(-1);\\n        } else {\\n            v.push_back(minimumDistance);\\n            v.push_back(maximumDistance);\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043314,
                "title": "simple-and-fast-brute-force-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        A = []\\n        while head:\\n            A.append(head.val)\\n            head = head.next\\n        I = []\\n        if len(A) <= 2:\\n            return [-1, -1]\\n        for i in range(1, len(A)-1):\\n            if A[i-1] < A[i] > A[i+1] or A[i-1] > A[i] < A[i+1]:\\n                I.append(i)\\n        if len(I) <= 1:\\n            return [-1, -1]\\n        mn = 10**10\\n        mx = max(I) - min(I)\\n        for i in range(len(I)-1):\\n            mn = min(mn, I[i+1] - I[i])\\n        return [mn, mx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        A = []\\n        while head:\\n            A.append(head.val)\\n            head = head.next\\n        I = []\\n        if len(A) <= 2:\\n            return [-1, -1]\\n        for i in range(1, len(A)-1):\\n            if A[i-1] < A[i] > A[i+1] or A[i-1] > A[i] < A[i+1]:\\n                I.append(i)\\n        if len(I) <= 1:\\n            return [-1, -1]\\n        mn = 10**10\\n        mx = max(I) - min(I)\\n        for i in range(len(I)-1):\\n            mn = min(mn, I[i+1] - I[i])\\n        return [mn, mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036085,
                "title": "java-o-nlogn-solution",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int prev = 0, mid = 0, curr = 0, count = 0;\\n        List<Integer> listIdx = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            if (prev != 0 && mid != 0 && curr != 0) {\\n                if (prev > mid && mid < curr) listIdx.add(count);\\n                if (prev < mid && mid > curr) listIdx.add(count);\\n            }\\n\\n            prev = mid;\\n            mid = curr;\\n            curr = temp.val;\\n\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (prev != 0 && mid != 0 && curr != 0) {\\n            if (prev > mid && mid < curr) listIdx.add(count);\\n            if (prev < mid && mid > curr) listIdx.add(count);\\n        }\\n        if (listIdx.size() < 2) return new int[]{-1, -1};\\n        Collections.sort(listIdx);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < listIdx.size(); i++) min = Math.min(listIdx.get(i) - listIdx.get(i - 1), min);\\n        return new int[]{min, listIdx.get(listIdx.size() - 1) - listIdx.get(0)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int prev = 0, mid = 0, curr = 0, count = 0;\\n        List<Integer> listIdx = new ArrayList<>();\\n        ListNode temp = head;\\n        while (temp != null) {\\n            if (prev != 0 && mid != 0 && curr != 0) {\\n                if (prev > mid && mid < curr) listIdx.add(count);\\n                if (prev < mid && mid > curr) listIdx.add(count);\\n            }\\n\\n            prev = mid;\\n            mid = curr;\\n            curr = temp.val;\\n\\n            count++;\\n            temp = temp.next;\\n        }\\n        if (prev != 0 && mid != 0 && curr != 0) {\\n            if (prev > mid && mid < curr) listIdx.add(count);\\n            if (prev < mid && mid > curr) listIdx.add(count);\\n        }\\n        if (listIdx.size() < 2) return new int[]{-1, -1};\\n        Collections.sort(listIdx);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 1; i < listIdx.size(); i++) min = Math.min(listIdx.get(i) - listIdx.get(i - 1), min);\\n        return new int[]{min, listIdx.get(listIdx.size() - 1) - listIdx.get(0)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034590,
                "title": "cpp-easy-100-solution-done-easily",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        //first index=-1\\n        int findex=-1;\\n        //second index=-1\\n        int sindex=-1;\\n        //INDEX VARIABLE BHI LAGEGA\\n        int index=0;\\n        //3 node langenge for the comprasion\\n        ListNode *a=head;\\n        ListNode *b=head->next;\\n        ListNode *c=head->next->next;\\n\\n        //maximum distance nikal\\n        while(c!=NULL)\\n        {\\n            if(b->val >a->val && b->val>c->val || b->val < a->val && b->val < c->val )\\n            {\\n                if(findex==-1) \\n                {\\n                    // assign it with value\\n                    findex=index;\\n                }\\n                else\\n                {\\n                    sindex=index;\\n                }\\n            }\\n            a=a->next;\\n            b=b->next;\\n            c=c->next;\\n            index++;\\n        }\\n        if(sindex==-1)\\n        {\\n            return {-1,-1};\\n        }\\n         int maxd=sindex-findex;   \\n       \\n\\n        //aab minimum distance nikal\\n\\n\\n        //sabko wapis aapne jagah pe laa\\n\\n        //first index=-1\\n        findex=-1;\\n        //second index=-1\\n        sindex=-1;\\n        //INDEX VARIABLE BHI LAGEGA\\n        index=0;\\n        //3 node langenge for the comprasion\\n        //minimum nikal\\n        int mind=INT_MAX;\\n        a=head;\\n        b=head->next;\\n        c=head->next->next;\\n        while(c!=NULL)\\n        {\\n            if(b->val >a->val && b->val>c->val || b->val < a->val && b->val < c->val )\\n            {\\n              //kyuki piche rehna chhaiye na\\n              findex=sindex;\\n              sindex=index;\\n              if(findex!=-1)\\n              {\\n                  //distance calc kar\\n                  int d=sindex-findex;\\n                  mind=min(d,mind);\\n\\n              }\\n            }\\n            a=a->next;\\n            b=b->next;\\n            c=c->next;\\n            index++;\\n        }\\n        return {mind,maxd};\\n\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        //first index=-1\\n        int findex=-1;\\n        //second index=-1\\n        int sindex=-1;\\n        //INDEX VARIABLE BHI LAGEGA\\n        int index=0;\\n        //3 node langenge for the comprasion\\n        ListNode *a=head;\\n        ListNode *b=head->next;\\n        ListNode *c=head->next->next;\\n\\n        //maximum distance nikal\\n        while(c!=NULL)\\n        {\\n            if(b->val >a->val && b->val>c->val || b->val < a->val && b->val < c->val )\\n            {\\n                if(findex==-1) \\n                {\\n                    // assign it with value\\n                    findex=index;\\n                }\\n                else\\n                {\\n                    sindex=index;\\n                }\\n            }\\n            a=a->next;\\n            b=b->next;\\n            c=c->next;\\n            index++;\\n        }\\n        if(sindex==-1)\\n        {\\n            return {-1,-1};\\n        }\\n         int maxd=sindex-findex;   \\n       \\n\\n        //aab minimum distance nikal\\n\\n\\n        //sabko wapis aapne jagah pe laa\\n\\n        //first index=-1\\n        findex=-1;\\n        //second index=-1\\n        sindex=-1;\\n        //INDEX VARIABLE BHI LAGEGA\\n        index=0;\\n        //3 node langenge for the comprasion\\n        //minimum nikal\\n        int mind=INT_MAX;\\n        a=head;\\n        b=head->next;\\n        c=head->next->next;\\n        while(c!=NULL)\\n        {\\n            if(b->val >a->val && b->val>c->val || b->val < a->val && b->val < c->val )\\n            {\\n              //kyuki piche rehna chhaiye na\\n              findex=sindex;\\n              sindex=index;\\n              if(findex!=-1)\\n              {\\n                  //distance calc kar\\n                  int d=sindex-findex;\\n                  mind=min(d,mind);\\n\\n              }\\n            }\\n            a=a->next;\\n            b=b->next;\\n            c=c->next;\\n            index++;\\n        }\\n        return {mind,maxd};\\n\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032222,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if head == None or head.next==None or  head.next.next==None:\\n            return [-1,-1]\\n        prev=head\\n        curr=head.next\\n        nextNode=curr.next\\n        count =1\\n        result=[]\\n        while nextNode:\\n            if  curr.val < prev.val and curr.val < nextNode.val or curr.val > prev.val and curr.val >  nextNode.val:\\n                result.append(count)\\n            count +=1\\n            prev=curr\\n            curr=nextNode\\n            nextNode=nextNode.next\\n        # return result\\n        if len(result) < 2:\\n            return [-1,-1]\\n        mini=99999\\n        for i in range(1,len(result)):\\n            mini=min(mini,result[i]-result[i-1])\\n        return [mini,result[len(result)-1]-result[0]]\\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if head == None or head.next==None or  head.next.next==None:\\n            return [-1,-1]\\n        prev=head\\n        curr=head.next\\n        nextNode=curr.next\\n        count =1\\n        result=[]\\n        while nextNode:\\n            if  curr.val < prev.val and curr.val < nextNode.val or curr.val > prev.val and curr.val >  nextNode.val:\\n                result.append(count)\\n            count +=1\\n            prev=curr\\n            curr=nextNode\\n            nextNode=nextNode.next\\n        # return result\\n        if len(result) < 2:\\n            return [-1,-1]\\n        mini=99999\\n        for i in range(1,len(result)):\\n            mini=min(mini,result[i]-result[i-1])\\n        return [mini,result[len(result)-1]-result[0]]\\n\\n        \\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029789,
                "title": "python3-saved-critical-points",
                "content": "The idea behind this approach is to store the list of critical points by index and then compute the distances at the end with some basic list traversals.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        min_dist = -1\\n        max_dist = -1\\n\\n\\n        minima = []\\n\\n        prev = None\\n        curr = head\\n        idx = 0\\n\\n        while curr != None:\\n            if prev is None:\\n                prev = curr\\n                curr = head.next\\n                idx += 1\\n                continue\\n\\n            if curr.next:\\n                prev_val = prev.val\\n                curr_val = curr.val\\n                next_val = curr.next.val\\n                print(prev_val, curr_val, next_val)\\n                if (curr_val < prev_val and curr_val < next_val) or (prev_val < curr_val and next_val < curr_val):\\n                    minima.append(idx)\\n                    \\n\\n            prev = curr\\n            curr = curr.next\\n            idx += 1\\n\\n\\n        if len(minima) < 2:\\n            return [-1, -1]\\n\\n    \\n        min_dist = minima[1]-minima[0]\\n\\n        for i in range(1, len(minima)):            \\n            min_dist = min(min_dist, minima[i] - minima[(i-1)])\\n\\n        return [min_dist, minima[-1] - minima[0]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        min_dist = -1\\n        max_dist = -1\\n\\n\\n        minima = []\\n\\n        prev = None\\n        curr = head\\n        idx = 0\\n\\n        while curr != None:\\n            if prev is None:\\n                prev = curr\\n                curr = head.next\\n                idx += 1\\n                continue\\n\\n            if curr.next:\\n                prev_val = prev.val\\n                curr_val = curr.val\\n                next_val = curr.next.val\\n                print(prev_val, curr_val, next_val)\\n                if (curr_val < prev_val and curr_val < next_val) or (prev_val < curr_val and next_val < curr_val):\\n                    minima.append(idx)\\n                    \\n\\n            prev = curr\\n            curr = curr.next\\n            idx += 1\\n\\n\\n        if len(minima) < 2:\\n            return [-1, -1]\\n\\n    \\n        min_dist = minima[1]-minima[0]\\n\\n        for i in range(1, len(minima)):            \\n            min_dist = min(min_dist, minima[i] - minima[(i-1)])\\n\\n        return [min_dist, minima[-1] - minima[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027857,
                "title": "straightforward-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave three pointers to check for maximums and minimums, ensure that successive pointers are not NULL, and simply add all local maximum and mininmum values to an array. Then the furthest distance between nodes is between i = 0 and i = n, thus we acquire maximum. Then minimum must be sought separately between each node.\\n\\n# Complexity\\n- O(n) (roughly) space complexity, as in the worst case scenario half the elements will be stored\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- O(n) time complexity, passes one time through whole list\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> locals;\\n        ListNode *main, *prev, *future;\\n        if(head->next == NULL){\\n            locals.push_back(-1);\\n            locals.push_back(-1);\\n            return locals;\\n        }\\n        int q = 0;\\n        main=head;\\n        prev=main;\\n        main=main->next;\\n        future=main->next;\\n        while(future){\\n            if(prev->val > main->val && future->val >main->val){\\n                locals.push_back(q);\\n            }\\n            else if(prev->val < main->val && \\n            future->val < main->val){\\n                locals.push_back(q);\\n            }\\n            prev=main;\\n            main=future;\\n            future=future->next;\\n            q++;       \\n        }\\n        vector<int> main_v;\\n        if(locals.size()<2){\\n            main_v.push_back(-1);\\n            main_v.push_back(-1);\\n            return main_v;\\n        }\\n        int maxi = locals[locals.size()-1]-locals[0];\\n        int mini = 999999999;\\n        for(int i = 0;i < locals.size()-1;i++){\\n            mini = min(locals[i+1]-locals[i],mini);\\n        }\\n        main_v.push_back(mini);\\n        main_v.push_back(maxi);\\n        return main_v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> locals;\\n        ListNode *main, *prev, *future;\\n        if(head->next == NULL){\\n            locals.push_back(-1);\\n            locals.push_back(-1);\\n            return locals;\\n        }\\n        int q = 0;\\n        main=head;\\n        prev=main;\\n        main=main->next;\\n        future=main->next;\\n        while(future){\\n            if(prev->val > main->val && future->val >main->val){\\n                locals.push_back(q);\\n            }\\n            else if(prev->val < main->val && \\n            future->val < main->val){\\n                locals.push_back(q);\\n            }\\n            prev=main;\\n            main=future;\\n            future=future->next;\\n            q++;       \\n        }\\n        vector<int> main_v;\\n        if(locals.size()<2){\\n            main_v.push_back(-1);\\n            main_v.push_back(-1);\\n            return main_v;\\n        }\\n        int maxi = locals[locals.size()-1]-locals[0];\\n        int mini = 999999999;\\n        for(int i = 0;i < locals.size()-1;i++){\\n            mini = min(locals[i+1]-locals[i],mini);\\n        }\\n        main_v.push_back(mini);\\n        main_v.push_back(maxi);\\n        return main_v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012278,
                "title": "begineer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // maxDistance\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n        int first = -1;\\n        int second = -1;\\n        int idx = 1;\\n        while(curr->next!=NULL){\\n            if(curr->val > prev->val && curr->val > curr->next->val || curr->val < prev->val && curr->val < curr->next->val){\\n                if(first==-1) first = idx;\\n                else second = idx;\\n            }\\n            idx++;\\n            curr = curr->next;\\n            prev = prev->next;\\n        }\\n        if(second==-1) return {-1,-1};\\n        int maxDis = second - first;\\n        \\n        // minDistance\\n        curr = head->next;\\n        prev = head;\\n        first = -1;\\n        second = -1;\\n        idx = 1;\\n        int minDis = INT_MAX;\\n        while(curr->next!=NULL){\\n            if(curr->val > prev->val && curr->val > curr->next->val || curr->val < prev->val && curr->val < curr->next->val){\\n                first = second;\\n                second = idx;\\n                int d = second-first;\\n                if(first!=-1) minDis = min(minDis,d);\\n            }\\n            idx++;\\n            curr = curr->next;\\n            prev = prev->next;\\n        }\\n        return {minDis,maxDis};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // maxDistance\\n        ListNode* curr = head->next;\\n        ListNode* prev = head;\\n        int first = -1;\\n        int second = -1;\\n        int idx = 1;\\n        while(curr->next!=NULL){\\n            if(curr->val > prev->val && curr->val > curr->next->val || curr->val < prev->val && curr->val < curr->next->val){\\n                if(first==-1) first = idx;\\n                else second = idx;\\n            }\\n            idx++;\\n            curr = curr->next;\\n            prev = prev->next;\\n        }\\n        if(second==-1) return {-1,-1};\\n        int maxDis = second - first;\\n        \\n        // minDistance\\n        curr = head->next;\\n        prev = head;\\n        first = -1;\\n        second = -1;\\n        idx = 1;\\n        int minDis = INT_MAX;\\n        while(curr->next!=NULL){\\n            if(curr->val > prev->val && curr->val > curr->next->val || curr->val < prev->val && curr->val < curr->next->val){\\n                first = second;\\n                second = idx;\\n                int d = second-first;\\n                if(first!=-1) minDis = min(minDis,d);\\n            }\\n            idx++;\\n            curr = curr->next;\\n            prev = prev->next;\\n        }\\n        return {minDis,maxDis};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008240,
                "title": "python-traversal-and-comparison-on-the-go-sc-o-1-tc-o-n",
                "content": "# Intuition\\nTraverse the linked list to find all the local maxima and minima\\'s\\n# Approach\\nThe most common idea is to traverse the LL and append to an array on finding any maxima /minima , but rather, we can just keep 3 pointers Last position, current position and first position to calculate the maximum/minimum distance between maxima and minima o the go\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev_pos,curr_pos,pos,prev,node=0 ,0,1,head,head\\n        mini=float(\\'inf\\')\\n        while(node.next and node.next.next):\\n            node=node.next\\n            if((prev.val>node.val and node.next.val>node.val) or(prev.val<node.val and node.next.val<node.val)):\\n                if(prev_pos):\\n                    curr_pos=pos\\n                    if(curr_pos-prev_pos<mini):\\n                        mini=curr_pos-prev_pos\\n                else:\\n                    first_pos=pos\\n                prev_pos=pos\\n            pos+=1\\n            prev=node\\n        if(curr_pos and prev_pos):\\n            return [mini,curr_pos-first_pos]\\n        return [-1,-1]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev_pos,curr_pos,pos,prev,node=0 ,0,1,head,head\\n        mini=float(\\'inf\\')\\n        while(node.next and node.next.next):\\n            node=node.next\\n            if((prev.val>node.val and node.next.val>node.val) or(prev.val<node.val and node.next.val<node.val)):\\n                if(prev_pos):\\n                    curr_pos=pos\\n                    if(curr_pos-prev_pos<mini):\\n                        mini=curr_pos-prev_pos\\n                else:\\n                    first_pos=pos\\n                prev_pos=pos\\n            pos+=1\\n            prev=node\\n        if(curr_pos and prev_pos):\\n            return [mini,curr_pos-first_pos]\\n        return [-1,-1]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002579,
                "title": "c-logic-easy-solution-o-n-time",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        if(head == NULL or head->next == NULL)\\n            return {-1,-1};\\n\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        if(curr->next == NULL) return {-1, -1};\\n        int count = 2;\\n\\n        vector<int>ans(2);\\n        int minD = INT_MAX;\\n        int firstCP = -1;\\n        int lastCP = -1;\\n\\n        while(curr->next)\\n        {\\n            ListNode* forward = curr->next;\\n            bool isCP = ( (curr->val > prev->val and curr->val > forward->val) or\\n                    (curr->val < prev->val and curr->val < forward->val) ) ? true: false;\\n            \\n            if(isCP && firstCP == -1)\\n            {\\n                firstCP = count;\\n                lastCP = count;\\n            }\\n            else if(isCP)\\n            {\\n                minD = min(minD, count - lastCP);\\n                lastCP = count;\\n            }\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        if(firstCP == lastCP) return {-1, -1};\\n\\n        int maxD = lastCP - firstCP;\\n        return {minD, maxD};\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        if(head == NULL or head->next == NULL)\\n            return {-1,-1};\\n\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        if(curr->next == NULL) return {-1, -1};\\n        int count = 2;\\n\\n        vector<int>ans(2);\\n        int minD = INT_MAX;\\n        int firstCP = -1;\\n        int lastCP = -1;\\n\\n        while(curr->next)\\n        {\\n            ListNode* forward = curr->next;\\n            bool isCP = ( (curr->val > prev->val and curr->val > forward->val) or\\n                    (curr->val < prev->val and curr->val < forward->val) ) ? true: false;\\n            \\n            if(isCP && firstCP == -1)\\n            {\\n                firstCP = count;\\n                lastCP = count;\\n            }\\n            else if(isCP)\\n            {\\n                minD = min(minD, count - lastCP);\\n                lastCP = count;\\n            }\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n\\n        if(firstCP == lastCP) return {-1, -1};\\n\\n        int maxD = lastCP - firstCP;\\n        return {minD, maxD};\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997765,
                "title": "easy-solution-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans(2, -1);\\n\\n        int prev = head->val;\\n        head = head->next;\\n\\n        int mxdist = -1, mndist = 1e9;\\n        int mxidx =1e8, mnidx=-1e8, curridx =0;\\n        int count =0;\\n        while(head->next){\\n            if(head->val > prev && head->val > head->next->val ||\\n             head->val < prev && head->val < head->next->val){\\n                count++;\\n                mxidx = min(mxidx, curridx);\\n                mxdist = max(mxdist, curridx - mxidx);\\n\\n                mndist = min(mndist, curridx - mnidx);\\n                mnidx = curridx;\\n            }\\n            curridx++;\\n            prev = head->val;\\n            head = head->next;\\n        }\\n        if(count<2) return ans;\\n        ans[0] = mndist;ans[1] = mxdist;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans(2, -1);\\n\\n        int prev = head->val;\\n        head = head->next;\\n\\n        int mxdist = -1, mndist = 1e9;\\n        int mxidx =1e8, mnidx=-1e8, curridx =0;\\n        int count =0;\\n        while(head->next){\\n            if(head->val > prev && head->val > head->next->val ||\\n             head->val < prev && head->val < head->next->val){\\n                count++;\\n                mxidx = min(mxidx, curridx);\\n                mxdist = max(mxdist, curridx - mxidx);\\n\\n                mndist = min(mndist, curridx - mnidx);\\n                mnidx = curridx;\\n            }\\n            curridx++;\\n            prev = head->val;\\n            head = head->next;\\n        }\\n        if(count<2) return ans;\\n        ans[0] = mndist;ans[1] = mxdist;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990836,
                "title": "simple-c-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>ans(2);\\n        if(!head->next->next){\\n            return {-1,-1};\\n        }\\n        int minn=INT_MAX,maxx=INT_MIN;\\n\\n        vector<int>res;\\n        int i=1;\\n\\n        ListNode* curr=head->next;\\n        ListNode* prev=head;\\n\\n        while(curr->next){\\n            ListNode* ne=curr->next;\\n            if((curr->val>prev->val && curr->val>ne->val) || (curr->val<prev->val && curr->val<ne->val)){\\n                res.push_back(i);\\n            }\\n            i++;\\n            prev=curr;\\n            curr=ne;\\n        }\\n\\n        if(res.empty())\\n        return {-1,-1};\\n        \\n        for(int i=0;i<res.size()-1;i++){\\n            minn=min(minn,res[i+1]-res[i]);\\n            maxx=max(maxx,res[res.size()-1]-res[i]);\\n        }\\n        if(minn==INT_MAX)\\n        minn=-1;\\n        if(maxx==INT_MIN)\\n        maxx=-1;\\n        return {minn,maxx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>ans(2);\\n        if(!head->next->next){\\n            return {-1,-1};\\n        }\\n        int minn=INT_MAX,maxx=INT_MIN;\\n\\n        vector<int>res;\\n        int i=1;\\n\\n        ListNode* curr=head->next;\\n        ListNode* prev=head;\\n\\n        while(curr->next){\\n            ListNode* ne=curr->next;\\n            if((curr->val>prev->val && curr->val>ne->val) || (curr->val<prev->val && curr->val<ne->val)){\\n                res.push_back(i);\\n            }\\n            i++;\\n            prev=curr;\\n            curr=ne;\\n        }\\n\\n        if(res.empty())\\n        return {-1,-1};\\n        \\n        for(int i=0;i<res.size()-1;i++){\\n            minn=min(minn,res[i+1]-res[i]);\\n            maxx=max(maxx,res[res.size()-1]-res[i]);\\n        }\\n        if(minn==INT_MAX)\\n        minn=-1;\\n        if(maxx==INT_MIN)\\n        maxx=-1;\\n        return {minn,maxx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969252,
                "title": "java-very-easy-beats-99-one-pass",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int firstC = -1, lastC = -1, min = Integer.MAX_VALUE, index = 1;\\n        ListNode prev = head, curr = head.next;\\n        while (curr.next != null) {\\n            if ((prev.val < curr.val && curr.val > curr.next.val) || (prev.val > curr.val && curr.val < curr.next.val)) {\\n                if (firstC == -1) firstC = lastC = index;\\n                else {\\n                    min = Math.min(index - lastC, min);\\n                    lastC = index;\\n                }\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n            index++;\\n        }\\n        if (lastC == firstC) return new int[]{-1, -1};\\n        return new int[]{min, lastC - firstC};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int firstC = -1, lastC = -1, min = Integer.MAX_VALUE, index = 1;\\n        ListNode prev = head, curr = head.next;\\n        while (curr.next != null) {\\n            if ((prev.val < curr.val && curr.val > curr.next.val) || (prev.val > curr.val && curr.val < curr.next.val)) {\\n                if (firstC == -1) firstC = lastC = index;\\n                else {\\n                    min = Math.min(index - lastC, min);\\n                    lastC = index;\\n                }\\n            }\\n            prev = curr;\\n            curr = curr.next;\\n            index++;\\n        }\\n        if (lastC == firstC) return new int[]{-1, -1};\\n        return new int[]{min, lastC - firstC};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967428,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        temp=head \\n        l=[] \\n        #cp=[] \\n        ind=[] \\n        while temp: \\n            l.append(temp.val) \\n            temp=temp.next \\n        for i in range(1,len(l)-1,1): \\n            if  l[i]>l[i-1] and l[i]>l[i+1]: \\n                #cp.append(l[i]) \\n                ind.append(i+1) \\n            if l[i]<l[i-1] and l[i]<l[i+1]: \\n                #cp.append(l[i]) \\n                ind.append(i+1) \\n        #print(cp) \\n        ind.sort(reverse=True) \\n        ans=[]\\n        if len(ind) <=1: \\n            return [-1,-1]  \\n        elif len(ind)==2: \\n            return [abs(ind[0]-ind[1]),abs(ind[0]-ind[1])]\\n        else: \\n            min=ind[0]-ind[1] \\n            for i in range(1,len(ind)-1): \\n                if (ind[i]-ind[i+1])<min: \\n                    min=ind[i]-ind[i+1]\\n            ans.append(min) \\n            ans.append(ind[0]-ind[-1])\\n            return ans\\n        \\n            \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        temp=head \\n        l=[] \\n        #cp=[] \\n        ind=[] \\n        while temp: \\n            l.append(temp.val) \\n            temp=temp.next \\n        for i in range(1,len(l)-1,1): \\n            if  l[i]>l[i-1] and l[i]>l[i+1]: \\n                #cp.append(l[i]) \\n                ind.append(i+1) \\n            if l[i]<l[i-1] and l[i]<l[i+1]: \\n                #cp.append(l[i]) \\n                ind.append(i+1) \\n        #print(cp) \\n        ind.sort(reverse=True) \\n        ans=[]\\n        if len(ind) <=1: \\n            return [-1,-1]  \\n        elif len(ind)==2: \\n            return [abs(ind[0]-ind[1]),abs(ind[0]-ind[1])]\\n        else: \\n            min=ind[0]-ind[1] \\n            for i in range(1,len(ind)-1): \\n                if (ind[i]-ind[i+1])<min: \\n                    min=ind[i]-ind[i+1]\\n            ans.append(min) \\n            ans.append(ind[0]-ind[-1])\\n            return ans\\n        \\n            \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967091,
                "title": "simple-o-n-c-code-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head || !head->next || !head->next->next) return {-1, -1};\\n        ListNode* prev = head;\\n        ListNode* curr = prev->next;\\n        ListNode* forw = curr->next;\\n        int criticalPts = 0;\\n\\n        // Variables for finding maxDistance & minDistance b/w any two critical points\\n        bool firstCP = false;\\n        bool lastCP = false; // In case of finding minDistance, the variable name \\'secondCP\\' suits the best, \\'lastCP\\' suits for finding maxDistance\\n        int maxCount = 0;\\n        int maxDistance = INT_MIN;\\n        int minCount = 0;\\n        int minDistance = INT_MAX;\\n        \\n\\n        while(forw != nullptr){\\n            int preVal = prev->val, currVal = curr->val, forwVal = forw->val;\\n            // We go In, If local minima OR local maxima is found (Given in the question)\\n            if((currVal < preVal && currVal < forwVal) || (currVal > preVal && currVal > forwVal)){\\n                if(!firstCP) firstCP = true; // first critical point found\\n                else lastCP = true; // another critical point found\\n                criticalPts++; // storing number of critical points\\n            }\\n\\n            // This is the whole simple logic that calculates the minDist & maxDist side by side with finding critical points\\n            if(firstCP){ \\n                if(lastCP){\\n                    maxDistance = max(maxDistance, maxCount);\\n                    minDistance = min(minDistance, minCount);\\n                    lastCP = false;\\n                    minCount = 0;\\n                }\\n                maxCount++; \\n                minCount++;\\n            }\\n\\n            prev = prev->next;\\n            curr = prev->next;\\n            forw = curr->next;\\n        }\\n\\n        if(criticalPts < 2) return {-1, -1};\\n        return {minDistance, maxDistance};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head || !head->next || !head->next->next) return {-1, -1};\\n        ListNode* prev = head;\\n        ListNode* curr = prev->next;\\n        ListNode* forw = curr->next;\\n        int criticalPts = 0;\\n\\n        // Variables for finding maxDistance & minDistance b/w any two critical points\\n        bool firstCP = false;\\n        bool lastCP = false; // In case of finding minDistance, the variable name \\'secondCP\\' suits the best, \\'lastCP\\' suits for finding maxDistance\\n        int maxCount = 0;\\n        int maxDistance = INT_MIN;\\n        int minCount = 0;\\n        int minDistance = INT_MAX;\\n        \\n\\n        while(forw != nullptr){\\n            int preVal = prev->val, currVal = curr->val, forwVal = forw->val;\\n            // We go In, If local minima OR local maxima is found (Given in the question)\\n            if((currVal < preVal && currVal < forwVal) || (currVal > preVal && currVal > forwVal)){\\n                if(!firstCP) firstCP = true; // first critical point found\\n                else lastCP = true; // another critical point found\\n                criticalPts++; // storing number of critical points\\n            }\\n\\n            // This is the whole simple logic that calculates the minDist & maxDist side by side with finding critical points\\n            if(firstCP){ \\n                if(lastCP){\\n                    maxDistance = max(maxDistance, maxCount);\\n                    minDistance = min(minDistance, minCount);\\n                    lastCP = false;\\n                    minCount = 0;\\n                }\\n                maxCount++; \\n                minCount++;\\n            }\\n\\n            prev = prev->next;\\n            curr = prev->next;\\n            forw = curr->next;\\n        }\\n\\n        if(criticalPts < 2) return {-1, -1};\\n        return {minDistance, maxDistance};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957446,
                "title": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        int[] ans = new int[2];\\n        for(int i=0;i<ans.length;i++)\\n        {\\n            ans[i] = -1;\\n        }\\n        if(head.next.next==null)\\n        return ans;\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        ListNode next = head.next.next;\\n        int i=1;\\n        while(next!=null)\\n        {\\n            if(curr.val<next.val&&curr.val<prev.val)\\n            arr.add(i);\\n            else if(curr.val>next.val&&curr.val>prev.val)\\n            arr.add(i);\\n            prev = prev.next;\\n            curr = curr.next;\\n            next = next.next;\\n            i++;\\n        }\\n        if(arr.size()<2)\\n        return ans;\\n        ans[1] = arr.get(arr.size()-1)-arr.get(0);\\n        ans[0] = arr.get(arr.size()-1)-arr.get(arr.size()-2);\\n        for(i=1;i<arr.size();i++)\\n        {\\n            ans[0] = Math.min(ans[0],arr.get(i)-arr.get(i-1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        int[] ans = new int[2];\\n        for(int i=0;i<ans.length;i++)\\n        {\\n            ans[i] = -1;\\n        }\\n        if(head.next.next==null)\\n        return ans;\\n        ListNode prev = head;\\n        ListNode curr = head.next;\\n        ListNode next = head.next.next;\\n        int i=1;\\n        while(next!=null)\\n        {\\n            if(curr.val<next.val&&curr.val<prev.val)\\n            arr.add(i);\\n            else if(curr.val>next.val&&curr.val>prev.val)\\n            arr.add(i);\\n            prev = prev.next;\\n            curr = curr.next;\\n            next = next.next;\\n            i++;\\n        }\\n        if(arr.size()<2)\\n        return ans;\\n        ans[1] = arr.get(arr.size()-1)-arr.get(0);\\n        ans[0] = arr.get(arr.size()-1)-arr.get(arr.size()-2);\\n        for(i=1;i<arr.size();i++)\\n        {\\n            ans[0] = Math.min(ans[0],arr.get(i)-arr.get(i-1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949820,
                "title": "beginner-friendly-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        vector<int> ans = {-1,-1};\\n        // LL containing less than three nodes can\\'t have critical pts\\n        if(head  == NULL || head -> next == NULL || head -> next -> next == NULL) {\\n            return ans;\\n        }\\n\\n        ListNode* prev = head;\\n        ListNode* curr = head -> next;\\n        ListNode* nxt = head -> next -> next;\\n        int firstCp = -1;\\n        int lastCp = -1;\\n        int minDist = INT_MAX;\\n        int i = 1;\\n\\n        while(nxt) {\\n\\n            bool isCp = ((curr -> val > prev -> val && curr -> val > nxt -> val) || (curr -> val < prev -> val && curr -> val < nxt -> val) ? true:false);\\n\\n            if(isCp && firstCp== -1) {\\n                firstCp = i;\\n                lastCp = i;\\n            }\\n            else if(isCp) {\\n                minDist = min(minDist, i - lastCp);\\n                lastCp = i;\\n            }\\n            i++;\\n            curr = curr -> next;\\n            prev = prev -> next;\\n            nxt = nxt -> next;\\n        }\\n\\n        if(firstCp == lastCp) {\\n            return ans;\\n        }        \\n        else{\\n            ans[0] = minDist;\\n            ans[1] = lastCp - firstCp;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        \\n        vector<int> ans = {-1,-1};\\n        // LL containing less than three nodes can\\'t have critical pts\\n        if(head  == NULL || head -> next == NULL || head -> next -> next == NULL) {\\n            return ans;\\n        }\\n\\n        ListNode* prev = head;\\n        ListNode* curr = head -> next;\\n        ListNode* nxt = head -> next -> next;\\n        int firstCp = -1;\\n        int lastCp = -1;\\n        int minDist = INT_MAX;\\n        int i = 1;\\n\\n        while(nxt) {\\n\\n            bool isCp = ((curr -> val > prev -> val && curr -> val > nxt -> val) || (curr -> val < prev -> val && curr -> val < nxt -> val) ? true:false);\\n\\n            if(isCp && firstCp== -1) {\\n                firstCp = i;\\n                lastCp = i;\\n            }\\n            else if(isCp) {\\n                minDist = min(minDist, i - lastCp);\\n                lastCp = i;\\n            }\\n            i++;\\n            curr = curr -> next;\\n            prev = prev -> next;\\n            nxt = nxt -> next;\\n        }\\n\\n        if(firstCp == lastCp) {\\n            return ans;\\n        }        \\n        else{\\n            ans[0] = minDist;\\n            ans[1] = lastCp - firstCp;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947258,
                "title": "cpp-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solution(ListNode* head,vector<int>&v)\\n    {\\n        int i=1,ind=0;\\n        ListNode* p=head;\\n        ListNode *f=head->next;\\n        while(f->next!=NULL)\\n        {\\n            i++;\\n            if(f->val>p->val && f->val>(f->next)->val)\\n            {\\n                v.push_back(i);\\n            }\\n            if(f->val<p->val && f->val<(f->next)->val)\\n            {\\n                v.push_back(i);\\n            }\\n            f=f->next;\\n            p=p->next;\\n        }\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v;\\n        solution(head,v);\\n        int n=v.size();\\n        vector<int>p;\\n        cout<<n;\\n        if(n<=1)\\n        {\\n            p.push_back(-1);\\n            p.push_back(-1);\\n            return p;\\n        }\\n        else if(n==2)\\n        {\\n            p.push_back(v[1]-v[0]);\\n            p.push_back(v[1]-v[0]);\\n            return p;\\n        }\\n        int m=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if((v[i+1]-v[i])<m)\\n            {\\n                m=v[i+1]-v[i];\\n            }\\n        }\\n        p.push_back(m);\\n        p.push_back(v[n-1]-v[0]);\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solution(ListNode* head,vector<int>&v)\\n    {\\n        int i=1,ind=0;\\n        ListNode* p=head;\\n        ListNode *f=head->next;\\n        while(f->next!=NULL)\\n        {\\n            i++;\\n            if(f->val>p->val && f->val>(f->next)->val)\\n            {\\n                v.push_back(i);\\n            }\\n            if(f->val<p->val && f->val<(f->next)->val)\\n            {\\n                v.push_back(i);\\n            }\\n            f=f->next;\\n            p=p->next;\\n        }\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v;\\n        solution(head,v);\\n        int n=v.size();\\n        vector<int>p;\\n        cout<<n;\\n        if(n<=1)\\n        {\\n            p.push_back(-1);\\n            p.push_back(-1);\\n            return p;\\n        }\\n        else if(n==2)\\n        {\\n            p.push_back(v[1]-v[0]);\\n            p.push_back(v[1]-v[0]);\\n            return p;\\n        }\\n        int m=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if((v[i+1]-v[i])<m)\\n            {\\n                m=v[i+1]-v[i];\\n            }\\n        }\\n        p.push_back(m);\\n        p.push_back(v[n-1]-v[0]);\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3945847,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans{-1,-1};\\n        ListNode* prev = head;\\n        if(!prev) return ans;\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n        ListNode* nxt = head->next->next;\\n        if(!nxt) return ans;\\n\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        int i=1;\\n        while(nxt){\\n            bool isCP = ((curr->val>prev->val && curr->val>nxt->val)\\n            || (curr->val <prev->val && curr->val <nxt->val))\\n            ? true:false;\\n\\n        if(isCP && firstCP == -1){\\n            firstCP = i;\\n            lastCP = i;\\n        }\\n        else if(isCP){\\n                minDist = min(minDist, i-lastCP);\\n                lastCP = i;\\n        }\\n        ++i;\\n        prev = prev->next;\\n        curr = curr->next;\\n        nxt = nxt->next;\\n        }\\n        if(lastCP == firstCP){\\n            return ans;\\n        }\\n        else{\\n            ans[0] = minDist;\\n            ans[1] = lastCP - firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans{-1,-1};\\n        ListNode* prev = head;\\n        if(!prev) return ans;\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n        ListNode* nxt = head->next->next;\\n        if(!nxt) return ans;\\n\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        int i=1;\\n        while(nxt){\\n            bool isCP = ((curr->val>prev->val && curr->val>nxt->val)\\n            || (curr->val <prev->val && curr->val <nxt->val))\\n            ? true:false;\\n\\n        if(isCP && firstCP == -1){\\n            firstCP = i;\\n            lastCP = i;\\n        }\\n        else if(isCP){\\n                minDist = min(minDist, i-lastCP);\\n                lastCP = i;\\n        }\\n        ++i;\\n        prev = prev->next;\\n        curr = curr->next;\\n        nxt = nxt->next;\\n        }\\n        if(lastCP == firstCP){\\n            return ans;\\n        }\\n        else{\\n            ans[0] = minDist;\\n            ans[1] = lastCP - firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944253,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n        if(list.size()<=2){\\n            return new int[]{-1,-1};\\n        }\\n                List<Integer> indices = new ArrayList<>();\\n\\n        for(int i=1;i<list.size()-1;i++){\\n            if(list.get(i)>list.get(i+1) && list.get(i)>list.get(i-1)){\\n                indices.add(i);\\n\\n            }\\n            if(list.get(i)<list.get(i+1) && list.get(i)<list.get(i-1)){\\n                indices.add(i);\\n\\n            }\\n        }\\n        if(indices.size()<2){\\n         return new int[]{-1,-1};\\n        }\\n        return new int[]{mindiff(indices),maxDiff(indices)};\\n        \\n    }\\n    public int mindiff(List<Integer> nums){\\n         Collections.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.size()-1;i++) {\\n            diff = Math.min(nums.get(i+1) - nums.get(i), diff);\\n        }\\n        return diff;\\n    }\\n     public int maxDiff(List<Integer> nums){\\n                  Collections.sort(nums);\\n                  int min = nums.get(0);\\n                  int max=nums.get(nums.size()-1);\\n                  return max-min;\\n\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        while(head!=null){\\n            list.add(head.val);\\n            head=head.next;\\n        }\\n        if(list.size()<=2){\\n            return new int[]{-1,-1};\\n        }\\n                List<Integer> indices = new ArrayList<>();\\n\\n        for(int i=1;i<list.size()-1;i++){\\n            if(list.get(i)>list.get(i+1) && list.get(i)>list.get(i-1)){\\n                indices.add(i);\\n\\n            }\\n            if(list.get(i)<list.get(i+1) && list.get(i)<list.get(i-1)){\\n                indices.add(i);\\n\\n            }\\n        }\\n        if(indices.size()<2){\\n         return new int[]{-1,-1};\\n        }\\n        return new int[]{mindiff(indices),maxDiff(indices)};\\n        \\n    }\\n    public int mindiff(List<Integer> nums){\\n         Collections.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.size()-1;i++) {\\n            diff = Math.min(nums.get(i+1) - nums.get(i), diff);\\n        }\\n        return diff;\\n    }\\n     public int maxDiff(List<Integer> nums){\\n                  Collections.sort(nums);\\n                  int min = nums.get(0);\\n                  int max=nums.get(nums.size()-1);\\n                  return max-min;\\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943983,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:O(nlogn)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> criticalPoints;\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        int i = 1;\\n<!-- Finding critical positions, as we only have to deal with their posion not their values so we store their index  -->\\n\\n        while(curr->next != nullptr) {\\n            if((curr->val > prev->val && curr->val > curr->next->val) || (curr->val < prev->val && curr->val < curr->next->val)) {\\n                criticalPoints.push_back(i);\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            i++;\\n        }\\n <!-- we first find all the critical points and store their positions in a vector. We then sort this vector and iterate over it to find the minimum and maximum differences between consecutive elements -->\\n\\n        if(criticalPoints.size() < 2) return {-1,-1};\\n        sort(criticalPoints.begin(), criticalPoints.end());\\n        int localMin = criticalPoints[1] - criticalPoints[0];\\n        int localMax = criticalPoints[criticalPoints.size()-1] - criticalPoints[0];\\n        for(int j = 2; j < criticalPoints.size(); j++) {\\n            localMin = min(localMin, criticalPoints[j] - criticalPoints[j - 1]);\\n            localMax = max(localMax, criticalPoints[j] - criticalPoints[j - 1]);\\n        }\\n        return {localMin, localMax};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> criticalPoints;\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        int i = 1;\\n<!-- Finding critical positions, as we only have to deal with their posion not their values so we store their index  -->\\n\\n        while(curr->next != nullptr) {\\n            if((curr->val > prev->val && curr->val > curr->next->val) || (curr->val < prev->val && curr->val < curr->next->val)) {\\n                criticalPoints.push_back(i);\\n            }\\n            prev = curr;\\n            curr = curr->next;\\n            i++;\\n        }\\n <!-- we first find all the critical points and store their positions in a vector. We then sort this vector and iterate over it to find the minimum and maximum differences between consecutive elements -->\\n\\n        if(criticalPoints.size() < 2) return {-1,-1};\\n        sort(criticalPoints.begin(), criticalPoints.end());\\n        int localMin = criticalPoints[1] - criticalPoints[0];\\n        int localMax = criticalPoints[criticalPoints.size()-1] - criticalPoints[0];\\n        for(int j = 2; j < criticalPoints.size(); j++) {\\n            localMin = min(localMin, criticalPoints[j] - criticalPoints[j - 1]);\\n            localMax = max(localMax, criticalPoints[j] - criticalPoints[j - 1]);\\n        }\\n        return {localMin, localMax};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941753,
                "title": "easy-cpp-solution-using-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans , v ;\\n        ListNode *a = head->next, *b = head , *c;\\n        int cnt  = 2, mn = INT_MAX ;\\n        while(a->next)\\n        {\\n            c = a->next ;\\n            if(a->val>b->val && a->val>c->val || a->val<b->val && a->val<c->val )\\n            {\\n                v.push_back(cnt);\\n            }\\n            cnt++ ;\\n            b = a ;\\n            a = a->next ;\\n        }\\n        if(v.empty() || v.size()==1)\\n        {\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else\\n        {\\n            for(int k = 0 ; k<v.size()-1 ; k++)\\n            mn = min(mn,v[k+1]-v[k]);\\n            ans.push_back(mn);\\n            if(v.size()>1)\\n            ans.push_back(v[v.size()-1]-v[0]);\\n            else \\n            ans.push_back(mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans , v ;\\n        ListNode *a = head->next, *b = head , *c;\\n        int cnt  = 2, mn = INT_MAX ;\\n        while(a->next)\\n        {\\n            c = a->next ;\\n            if(a->val>b->val && a->val>c->val || a->val<b->val && a->val<c->val )\\n            {\\n                v.push_back(cnt);\\n            }\\n            cnt++ ;\\n            b = a ;\\n            a = a->next ;\\n        }\\n        if(v.empty() || v.size()==1)\\n        {\\n            ans.push_back(-1);\\n            ans.push_back(-1);\\n        }\\n        else\\n        {\\n            for(int k = 0 ; k<v.size()-1 ; k++)\\n            mn = min(mn,v[k+1]-v[k]);\\n            ans.push_back(mn);\\n            if(v.size()>1)\\n            ans.push_back(v[v.size()-1]-v[0]);\\n            else \\n            ans.push_back(mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936295,
                "title": "simple-solution-o-n-runtime-100",
                "content": "![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-08-20 \\u0432 14.28.19.png](https://assets.leetcode.com/users/images/03f63fcf-9e4e-49d3-a0b7-55936f973303_1692530929.967533.png)\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        cnt, prev_val, prev_point, min_dist = 0, head.val, 0, inf\\n        while head.next:\\n            curr_val = head.val\\n            next_val = head.next.val\\n            if (curr_val > prev_val and curr_val > next_val) or (curr_val < prev_val and curr_val < next_val):\\n                if prev_point:\\n                    min_dist = min(cnt-prev_point, min_dist)\\n                else:\\n                    first_point = cnt\\n                prev_point = cnt\\n            prev_val = curr_val\\n            cnt += 1\\n            head = head.next\\n \\n        return [-1,-1] if min_dist == inf else [min_dist, prev_point-first_point]\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        cnt, prev_val, prev_point, min_dist = 0, head.val, 0, inf\\n        while head.next:\\n            curr_val = head.val\\n            next_val = head.next.val\\n            if (curr_val > prev_val and curr_val > next_val) or (curr_val < prev_val and curr_val < next_val):\\n                if prev_point:\\n                    min_dist = min(cnt-prev_point, min_dist)\\n                else:\\n                    first_point = cnt\\n                prev_point = cnt\\n            prev_val = curr_val\\n            cnt += 1\\n            head = head.next\\n \\n        return [-1,-1] if min_dist == inf else [min_dist, prev_point-first_point]\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914943,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>indexes;\\n        ListNode* temp=head->next;\\n        ListNode* prev=head;\\n        ListNode* n;\\n        if(head->next->next!=NULL)\\n        n=head->next->next;\\n        else\\n        return {-1,-1};\\n        int count=1;\\n        while(temp->next!=NULL){\\n            if((temp->val>prev->val && temp->val>n->val) || (temp->val<prev->val && temp->val<n->val)){\\n                indexes.push_back(count);\\n            }\\n            count++;\\n            prev=temp;\\n            temp=temp->next;\\n            n=temp->next;\\n        }\\n        if(indexes.size()<=1)\\n        return {-1,-1};\\n        if(indexes.size()==2){\\n            return{indexes[1]-indexes[0],indexes[1]-indexes[0]};\\n        }\\n        int m=111111;\\n        for(int i=0;i<indexes.size()-1;i++){\\n            m=min(m,(indexes[i+1]-indexes[i]));\\n        }\\n        return {m,indexes[indexes.size()-1]-indexes[0]};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>indexes;\\n        ListNode* temp=head->next;\\n        ListNode* prev=head;\\n        ListNode* n;\\n        if(head->next->next!=NULL)\\n        n=head->next->next;\\n        else\\n        return {-1,-1};\\n        int count=1;\\n        while(temp->next!=NULL){\\n            if((temp->val>prev->val && temp->val>n->val) || (temp->val<prev->val && temp->val<n->val)){\\n                indexes.push_back(count);\\n            }\\n            count++;\\n            prev=temp;\\n            temp=temp->next;\\n            n=temp->next;\\n        }\\n        if(indexes.size()<=1)\\n        return {-1,-1};\\n        if(indexes.size()==2){\\n            return{indexes[1]-indexes[0],indexes[1]-indexes[0]};\\n        }\\n        int m=111111;\\n        for(int i=0;i<indexes.size()-1;i++){\\n            m=min(m,(indexes[i+1]-indexes[i]));\\n        }\\n        return {m,indexes[indexes.size()-1]-indexes[0]};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912748,
                "title": "easy-cpp-solution-beats-100-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL ||head->next->next->next==NULL)return {-1,-1};\\n        vector<int>help;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* nxt=curr->next;\\n        int a=0;\\n        int mini=INT_MAX;\\n        int cnt=2;\\n        while(nxt!=NULL){\\n            if(((curr->val>prev->val )and (curr->val > nxt-> val)) or ((curr->val<prev->val )and (curr->val < nxt-> val))){\\n                help.push_back(cnt);\\n                if(a==0){\\n                    a=cnt;\\n                }\\n                else{\\n                    mini=min(mini,cnt-a);\\n                    a=cnt;\\n                }\\n            }\\n            cnt++;\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n        if(help.size()<2)return {-1,-1};\\n        return {mini,help[help.size()-1]-help[0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL ||head->next->next->next==NULL)return {-1,-1};\\n        vector<int>help;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* nxt=curr->next;\\n        int a=0;\\n        int mini=INT_MAX;\\n        int cnt=2;\\n        while(nxt!=NULL){\\n            if(((curr->val>prev->val )and (curr->val > nxt-> val)) or ((curr->val<prev->val )and (curr->val < nxt-> val))){\\n                help.push_back(cnt);\\n                if(a==0){\\n                    a=cnt;\\n                }\\n                else{\\n                    mini=min(mini,cnt-a);\\n                    a=cnt;\\n                }\\n            }\\n            cnt++;\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n        if(help.size()<2)return {-1,-1};\\n        return {mini,help[help.size()-1]-help[0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905792,
                "title": "python-two-pointers-concise-one-pass-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def isCriticalPoint(self, prev, cur, nextt):\\n        if (cur.val < prev.val and cur.val < nextt.val) or (cur.val > prev.val and cur.val > nextt.val):\\n            return True\\n        return False\\n    \\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev = head\\n        cur = head.next\\n        cur_index = 1\\n\\n        left_most_cp_index = float(\"inf\")\\n        right_most_cp_index = float(\"-inf\")\\n\\n        prev_cp_index = float(\"-inf\")\\n        min_dist = float(\"inf\")\\n        \\n        while cur.next:\\n            isCriticalPoint = self.isCriticalPoint(prev, cur, cur.next)\\n            # Critical point found\\n            if isCriticalPoint:\\n                left_most_cp_index = min(left_most_cp_index, cur_index)\\n                right_most_cp_index = max(right_most_cp_index, cur_index)\\n                min_dist = min(min_dist, cur_index - prev_cp_index)\\n                prev_cp_index = cur_index\\n                \\n            # Update pointers\\n            prev = cur\\n            cur = cur.next\\n            cur_index += 1\\n        \\n        # Calculate the longest distance\\n        max_dist = right_most_cp_index - left_most_cp_index\\n        \\n        # Edge case, if no cpoints or only one\\n        if min_dist == inf:\\n            return [-1, -1]\\n            \\n        return [min_dist, max_dist]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isCriticalPoint(self, prev, cur, nextt):\\n        if (cur.val < prev.val and cur.val < nextt.val) or (cur.val > prev.val and cur.val > nextt.val):\\n            return True\\n        return False\\n    \\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev = head\\n        cur = head.next\\n        cur_index = 1\\n\\n        left_most_cp_index = float(\"inf\")\\n        right_most_cp_index = float(\"-inf\")\\n\\n        prev_cp_index = float(\"-inf\")\\n        min_dist = float(\"inf\")\\n        \\n        while cur.next:\\n            isCriticalPoint = self.isCriticalPoint(prev, cur, cur.next)\\n            # Critical point found\\n            if isCriticalPoint:\\n                left_most_cp_index = min(left_most_cp_index, cur_index)\\n                right_most_cp_index = max(right_most_cp_index, cur_index)\\n                min_dist = min(min_dist, cur_index - prev_cp_index)\\n                prev_cp_index = cur_index\\n                \\n            # Update pointers\\n            prev = cur\\n            cur = cur.next\\n            cur_index += 1\\n        \\n        # Calculate the longest distance\\n        max_dist = right_most_cp_index - left_most_cp_index\\n        \\n        # Edge case, if no cpoints or only one\\n        if min_dist == inf:\\n            return [-1, -1]\\n            \\n        return [min_dist, max_dist]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904290,
                "title": "best-in-time-complexity-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if (head==null){\\n            return new int[]{-1,-1};\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int i = 0;\\n        int min_diff = Integer.MAX_VALUE;\\n        int max_diff;\\n        int prev = -1;\\n        int first=-1;\\n        while(fast.next!=null){\\n            i+=1;\\n            if ( (slow.val<fast.val && fast.val> fast.next.val)|| (slow.val>fast.val && fast.val< fast.next.val)){\\n                if (prev==-1){\\n                    prev = i;\\n                    first= i;\\n                }else{\\n                    min_diff = Math.min(min_diff,i-prev);\\n                }\\n                prev=i;\\n                            \\n            }\\n            slow=fast;\\n            fast=fast.next;\\n            }\\n\\n        if (first==-1 || prev==-1||first==prev){\\n            return new int[]{-1,-1};\\n        }\\n        max_diff =prev-first;\\n\\n        return new int[]{min_diff,max_diff};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if (head==null){\\n            return new int[]{-1,-1};\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int i = 0;\\n        int min_diff = Integer.MAX_VALUE;\\n        int max_diff;\\n        int prev = -1;\\n        int first=-1;\\n        while(fast.next!=null){\\n            i+=1;\\n            if ( (slow.val<fast.val && fast.val> fast.next.val)|| (slow.val>fast.val && fast.val< fast.next.val)){\\n                if (prev==-1){\\n                    prev = i;\\n                    first= i;\\n                }else{\\n                    min_diff = Math.min(min_diff,i-prev);\\n                }\\n                prev=i;\\n                            \\n            }\\n            slow=fast;\\n            fast=fast.next;\\n            }\\n\\n        if (first==-1 || prev==-1||first==prev){\\n            return new int[]{-1,-1};\\n        }\\n        max_diff =prev-first;\\n\\n        return new int[]{min_diff,max_diff};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904210,
                "title": "java-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if (head==null){\\n            return new int[]{-1,-1};\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int i = 0;\\n        int min_diff = Integer.MAX_VALUE;\\n        int max_diff;\\n        int prev = -1;\\n        int first=-1,last=-1;\\n        while(fast.next!=null){\\n            i+=1;\\n            if ( (slow.val<fast.val && fast.val> fast.next.val)|| (slow.val>fast.val && fast.val< fast.next.val)){\\n                if (prev==-1){\\n                    prev = i;\\n                    first= i;\\n                }else{\\n                    min_diff = Math.min(min_diff,i-prev);\\n                }\\n                prev=i;\\n                last=i;              \\n            }\\n            slow=fast;\\n            fast=fast.next;\\n            }\\n\\n        if (first==-1 || last==-1||first==last){\\n            return new int[]{-1,-1};\\n        }\\n        max_diff =last-first;\\n\\n        return new int[]{min_diff,max_diff};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if (head==null){\\n            return new int[]{-1,-1};\\n        }\\n        ListNode slow = head;\\n        ListNode fast = head.next;\\n        int i = 0;\\n        int min_diff = Integer.MAX_VALUE;\\n        int max_diff;\\n        int prev = -1;\\n        int first=-1,last=-1;\\n        while(fast.next!=null){\\n            i+=1;\\n            if ( (slow.val<fast.val && fast.val> fast.next.val)|| (slow.val>fast.val && fast.val< fast.next.val)){\\n                if (prev==-1){\\n                    prev = i;\\n                    first= i;\\n                }else{\\n                    min_diff = Math.min(min_diff,i-prev);\\n                }\\n                prev=i;\\n                last=i;              \\n            }\\n            slow=fast;\\n            fast=fast.next;\\n            }\\n\\n        if (first==-1 || last==-1||first==last){\\n            return new int[]{-1,-1};\\n        }\\n        max_diff =last-first;\\n\\n        return new int[]{min_diff,max_diff};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896511,
                "title": "beginner-friendly-code-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1,-1};\\n\\n        if(head->next->next == NULL ) return ans;\\n        vector<int> dist;\\n        int n =0;\\n\\n        ListNode *prev = head, *curr = head->next, *nextPtr = head->next->next;\\n        \\n    while(nextPtr != NULL){\\n            n++;\\n            if(curr->val > prev->val && curr->val > nextPtr->val){\\n                dist.push_back(n);\\n            }else if(curr->val < prev->val && curr->val < nextPtr->val){\\n                dist.push_back(n);\\n            }\\n            prev = prev->next;\\n            curr = curr->next;\\n            nextPtr = nextPtr->next;\\n        }\\n\\n        int N = dist.size();\\n        if(N == 0 || N == 1) return ans;\\n        int minDistance = INT_MAX;\\n\\n        for(int i =0; i< N-1 ; i++){\\n            int diff = dist[i+1] - dist[i];\\n             minDistance = min(minDistance, diff);\\n        }\\n        int maxDistance = dist[N-1] - dist[0];\\n        ans[0]= minDistance;\\n        ans[1] = maxDistance;\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1,-1};\\n\\n        if(head->next->next == NULL ) return ans;\\n        vector<int> dist;\\n        int n =0;\\n\\n        ListNode *prev = head, *curr = head->next, *nextPtr = head->next->next;\\n        \\n    while(nextPtr != NULL){\\n            n++;\\n            if(curr->val > prev->val && curr->val > nextPtr->val){\\n                dist.push_back(n);\\n            }else if(curr->val < prev->val && curr->val < nextPtr->val){\\n                dist.push_back(n);\\n            }\\n            prev = prev->next;\\n            curr = curr->next;\\n            nextPtr = nextPtr->next;\\n        }\\n\\n        int N = dist.size();\\n        if(N == 0 || N == 1) return ans;\\n        int minDistance = INT_MAX;\\n\\n        for(int i =0; i< N-1 ; i++){\\n            int diff = dist[i+1] - dist[i];\\n             minDistance = min(minDistance, diff);\\n        }\\n        int maxDistance = dist[N-1] - dist[0];\\n        ans[0]= minDistance;\\n        ans[1] = maxDistance;\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895716,
                "title": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
                "content": "\\n# Code\\n```\\n  /*\\n       Algorithm:\\n       Step 1 : Find the Critical Points(CP) in whole Linked List..\\n\\n            1.1 Local max:  CP > next  && C.P > prev where (next -> points to its next of CP node and \" prev \" points to node prev to CP)\\n\\n            1.1 Local min:  CP < next  && C.P <  prev where (next -> points to its next node and \" prev \" points to node prev to it)\\n\\n       Step 2 : Get those Indexes Where the Critical Points are found\\n      \\n       Step3 : Find MAX And MIN distance between the C.P..\\n\\n       */   \\n\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n      List<Integer> ls = new ArrayList<Integer>();\\n      \\n      int[] ans = {-1, -1};\\n\\n      // Boundary check:-\\n      if(head == null || head.next == null || head.next.next == null){\\n         return ans;\\n      }\\n\\n      ListNode prev = head;\\n      ListNode curr = head.next;\\n      ListNode Next = head.next.next;\\n      \\n      int count = 1;\\n\\n      while(Next != null){\\n        \\n         if((curr.val > prev.val && curr.val > Next.val) || (curr.val < prev.val && curr.val < Next.val))\\n           ls.add(count);\\n           count++;\\n           \\n         // moving forward if the Node is not the CP..  \\n         prev = curr;\\n         curr = Next;\\n         Next = Next.next;\\n\\n      }\\n      if(ls.size() < 2) {\\n        return ans;\\n      }\\n\\n      int min = Integer.MAX_VALUE;\\n\\n      for(int i = 1 ; i < ls.size(); i++){\\n          min = Math.min(min, ls.get(i) - ls.get(i-1));\\n       }\\n\\n     int lastElement  = ls.get(ls.size()-1);        \\n     int firstElement = ls.get(0);\\n\\n      return new int[]{min, lastElement-firstElement};     \\n\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  /*\\n       Algorithm:\\n       Step 1 : Find the Critical Points(CP) in whole Linked List..\\n\\n            1.1 Local max:  CP > next  && C.P > prev where (next -> points to its next of CP node and \" prev \" points to node prev to CP)\\n\\n            1.1 Local min:  CP < next  && C.P <  prev where (next -> points to its next node and \" prev \" points to node prev to it)\\n\\n       Step 2 : Get those Indexes Where the Critical Points are found\\n      \\n       Step3 : Find MAX And MIN distance between the C.P..\\n\\n       */   \\n\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n      List<Integer> ls = new ArrayList<Integer>();\\n      \\n      int[] ans = {-1, -1};\\n\\n      // Boundary check:-\\n      if(head == null || head.next == null || head.next.next == null){\\n         return ans;\\n      }\\n\\n      ListNode prev = head;\\n      ListNode curr = head.next;\\n      ListNode Next = head.next.next;\\n      \\n      int count = 1;\\n\\n      while(Next != null){\\n        \\n         if((curr.val > prev.val && curr.val > Next.val) || (curr.val < prev.val && curr.val < Next.val))\\n           ls.add(count);\\n           count++;\\n           \\n         // moving forward if the Node is not the CP..  \\n         prev = curr;\\n         curr = Next;\\n         Next = Next.next;\\n\\n      }\\n      if(ls.size() < 2) {\\n        return ans;\\n      }\\n\\n      int min = Integer.MAX_VALUE;\\n\\n      for(int i = 1 ; i < ls.size(); i++){\\n          min = Math.min(min, ls.get(i) - ls.get(i-1));\\n       }\\n\\n     int lastElement  = ls.get(ls.size()-1);        \\n     int firstElement = ls.get(0);\\n\\n      return new int[]{min, lastElement-firstElement};     \\n\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889606,
                "title": "easy-to-understand-beats-100-tc-o-n",
                "content": "\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ListNode present = head.next;\\n        ListNode prev = head;\\n        int min_dist = Integer.MAX_VALUE;\\n        int firstIdx = -1;\\n        int lastIdx=-1;\\n        int i =0;\\n\\n        while(present.next!=null){\\n            if(present.val<prev.val && present.val<present.next.val ||\\n               present.val>prev.val && present.val>present.next.val){\\n                   if(firstIdx==-1){\\n                       firstIdx=i;\\n                   }else{\\n                       min_dist=Math.min(min_dist,i-lastIdx);\\n                   }\\n                   lastIdx=i;\\n               }\\n               i++;\\n               prev=present;\\n               present=present.next;\\n        }\\n        if(lastIdx==firstIdx) return new int[]{-1,-1};\\n        return  new int[]{min_dist,lastIdx-firstIdx};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ListNode present = head.next;\\n        ListNode prev = head;\\n        int min_dist = Integer.MAX_VALUE;\\n        int firstIdx = -1;\\n        int lastIdx=-1;\\n        int i =0;\\n\\n        while(present.next!=null){\\n            if(present.val<prev.val && present.val<present.next.val ||\\n               present.val>prev.val && present.val>present.next.val){\\n                   if(firstIdx==-1){\\n                       firstIdx=i;\\n                   }else{\\n                       min_dist=Math.min(min_dist,i-lastIdx);\\n                   }\\n                   lastIdx=i;\\n               }\\n               i++;\\n               prev=present;\\n               present=present.next;\\n        }\\n        if(lastIdx==firstIdx) return new int[]{-1,-1};\\n        return  new int[]{min_dist,lastIdx-firstIdx};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885710,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int[] res={-1,-1};\\n        ListNode prev=head;\\n        ListNode curr=head.next;\\n        ListNode nextNode=curr.next;\\n\\n        if(prev==null || curr==null || nextNode==null){\\n            return res;\\n        }\\n        int ct=1;\\n        List<Integer> list=new ArrayList<>();\\n\\n        while(nextNode!=null){\\n            int prevValue=prev.val;\\n            int currValue=curr.val;\\n            int nextValue=nextNode.val;\\n\\n            ct++;\\n            if((currValue>prevValue && currValue>nextValue) || (currValue<prevValue && currValue<nextValue) ){\\n                list.add(ct);\\n            }\\n            prev=curr;\\n            curr=nextNode;\\n            nextNode=nextNode.next;\\n        }\\n\\n        int len=list.size();\\n        if(len<2){\\n            return res;\\n        }\\n        if(len==2){\\n            res[0]=list.get(1)-list.get(0);\\n            res[1]=list.get(1)-list.get(0);\\n        }\\n        else{\\n            res[0]=list.get(1)-list.get(0);\\n            for(int i=2;i<len;i++){\\n                res[0]=Math.min(res[0],list.get(i)-list.get(i-1));\\n            }\\n            res[1]=list.get(len-1)-list.get(0);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int[] res={-1,-1};\\n        ListNode prev=head;\\n        ListNode curr=head.next;\\n        ListNode nextNode=curr.next;\\n\\n        if(prev==null || curr==null || nextNode==null){\\n            return res;\\n        }\\n        int ct=1;\\n        List<Integer> list=new ArrayList<>();\\n\\n        while(nextNode!=null){\\n            int prevValue=prev.val;\\n            int currValue=curr.val;\\n            int nextValue=nextNode.val;\\n\\n            ct++;\\n            if((currValue>prevValue && currValue>nextValue) || (currValue<prevValue && currValue<nextValue) ){\\n                list.add(ct);\\n            }\\n            prev=curr;\\n            curr=nextNode;\\n            nextNode=nextNode.next;\\n        }\\n\\n        int len=list.size();\\n        if(len<2){\\n            return res;\\n        }\\n        if(len==2){\\n            res[0]=list.get(1)-list.get(0);\\n            res[1]=list.get(1)-list.get(0);\\n        }\\n        else{\\n            res[0]=list.get(1)-list.get(0);\\n            for(int i=2;i<len;i++){\\n                res[0]=Math.min(res[0],list.get(i)-list.get(i-1));\\n            }\\n            res[1]=list.get(len-1)-list.get(0);\\n        }\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879738,
                "title": "3-pointers-using-java",
                "content": "# Intuition\\nThis question can be solved using 3 ptrs, read comment to understand the solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n3 pointer Approch.\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int [] ans = {-1,-1};  // Initialize the answer array with -1, -1\\n        \\n        // Initialize pointers for previous, current and next nodes\\n        ListNode prevN = head;\\n        ListNode currN = head.next;\\n        ListNode nextN = currN.next;\\n        \\n        // If there aren\\'t at least three nodes, return the initial answer\\n        if(prevN==null || currN == null || nextN ==null){\\n            return ans;\\n        }\\n\\n        int cnt=1;  // Initialize a counter to keep track of the current node\\'s position\\n        int p=0,c=0,n=0;  // Initialize values for previous, current, and next nodes\\n        \\n        // Initialize a list to store positions of critical points\\n        List<Integer> list = new ArrayList<>();\\n        \\n        // While there is a next node:\\n        while(nextN!=null){\\n            p=prevN.val;  // Save the value of the previous node\\n            c=currN.val;  // Save the value of the current node\\n            n=nextN.val;  // Save the value of the next node\\n            \\n            cnt++;  // Increment the counter\\n            \\n            // If the current node is a critical point (local min or max), add its position to the list\\n            if((c<n && c<p) || (c>n && c>p)){\\n                list.add(cnt);\\n            }\\n\\n            // Move the pointers to the next set of nodes\\n            prevN = currN;\\n            currN = nextN;\\n            nextN = nextN.next;    \\n        }\\n\\n        int len = list.size();  // Get the number of critical points\\n\\n        // If there aren\\'t at least two critical points, return the initial answer\\n        if(len<2){\\n            return ans;\\n        }\\n\\n        // If there are exactly two critical points, calculate their distance for min and max\\n        if(list.size()==2){\\n            ans[0]=list.get(1)-list.get(0);\\n            ans[1]=list.get(1)-list.get(0);\\n        } else {\\n            // If there are more than two critical points, calculate the minimum and maximum distance\\n            \\n            ans[0]=list.get(1)-list.get(0);  // Start with the distance between the first two points\\n            \\n            // For each subsequent point, calculate its distance from the previous point and update the minimum\\n            for(int i=2;i<len;i++){\\n                int diff = list.get(i)-list.get(i-1); \\n                ans[0]=Math.min(ans[0],diff);\\n            }\\n            \\n            // The maximum distance is the distance between the last and first critical points\\n            ans[1]=list.get(len-1)-list.get(0);\\n        }\\n        \\n        // Return the result\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int [] ans = {-1,-1};  // Initialize the answer array with -1, -1\\n        \\n        // Initialize pointers for previous, current and next nodes\\n        ListNode prevN = head;\\n        ListNode currN = head.next;\\n        ListNode nextN = currN.next;\\n        \\n        // If there aren\\'t at least three nodes, return the initial answer\\n        if(prevN==null || currN == null || nextN ==null){\\n            return ans;\\n        }\\n\\n        int cnt=1;  // Initialize a counter to keep track of the current node\\'s position\\n        int p=0,c=0,n=0;  // Initialize values for previous, current, and next nodes\\n        \\n        // Initialize a list to store positions of critical points\\n        List<Integer> list = new ArrayList<>();\\n        \\n        // While there is a next node:\\n        while(nextN!=null){\\n            p=prevN.val;  // Save the value of the previous node\\n            c=currN.val;  // Save the value of the current node\\n            n=nextN.val;  // Save the value of the next node\\n            \\n            cnt++;  // Increment the counter\\n            \\n            // If the current node is a critical point (local min or max), add its position to the list\\n            if((c<n && c<p) || (c>n && c>p)){\\n                list.add(cnt);\\n            }\\n\\n            // Move the pointers to the next set of nodes\\n            prevN = currN;\\n            currN = nextN;\\n            nextN = nextN.next;    \\n        }\\n\\n        int len = list.size();  // Get the number of critical points\\n\\n        // If there aren\\'t at least two critical points, return the initial answer\\n        if(len<2){\\n            return ans;\\n        }\\n\\n        // If there are exactly two critical points, calculate their distance for min and max\\n        if(list.size()==2){\\n            ans[0]=list.get(1)-list.get(0);\\n            ans[1]=list.get(1)-list.get(0);\\n        } else {\\n            // If there are more than two critical points, calculate the minimum and maximum distance\\n            \\n            ans[0]=list.get(1)-list.get(0);  // Start with the distance between the first two points\\n            \\n            // For each subsequent point, calculate its distance from the previous point and update the minimum\\n            for(int i=2;i<len;i++){\\n                int diff = list.get(i)-list.get(i-1); \\n                ans[0]=Math.min(ans[0],diff);\\n            }\\n            \\n            // The maximum distance is the distance between the last and first critical points\\n            ans[1]=list.get(len-1)-list.get(0);\\n        }\\n        \\n        // Return the result\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867533,
                "title": "most-memory-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head==null||head.next==null||head.next.next==null)\\n        {\\n            return new int[]{-1,-1};\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ListNode cur=head.next;\\n        ListNode prev=head;\\n        ListNode next=cur.next;\\n        int i=1;\\n        while(next!=null)\\n        {\\n            if(cur.val>next.val&&cur.val>prev.val||cur.val<next.val&&cur.val<prev.val)\\n            {\\n                   list.add(i);\\n            }\\n            i++;\\n            prev=cur;\\n            cur=next;\\n            next=next.next;\\n            \\n        }\\n        if(list.size()<2)\\n        {\\n            return new int[]{-1,-1};\\n        }\\n //whenever we will get critical points their indexes will always be in the ascending order\\n        int mindis=Integer.MAX_VALUE;\\n        int maxdis=0;\\n        for(int j=0;j<list.size()-1;j++)\\n        {\\n          mindis=Math.min(mindis,list.get(j+1)-list.get(j));\\n        }\\n         maxdis=list.get(list.size()-1)-list.get(0);\\n        return new int[]{mindis,maxdis};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head==null||head.next==null||head.next.next==null)\\n        {\\n            return new int[]{-1,-1};\\n        }\\n        ArrayList<Integer> list=new ArrayList<>();\\n        ListNode cur=head.next;\\n        ListNode prev=head;\\n        ListNode next=cur.next;\\n        int i=1;\\n        while(next!=null)\\n        {\\n            if(cur.val>next.val&&cur.val>prev.val||cur.val<next.val&&cur.val<prev.val)\\n            {\\n                   list.add(i);\\n            }\\n            i++;\\n            prev=cur;\\n            cur=next;\\n            next=next.next;\\n            \\n        }\\n        if(list.size()<2)\\n        {\\n            return new int[]{-1,-1};\\n        }\\n //whenever we will get critical points their indexes will always be in the ascending order\\n        int mindis=Integer.MAX_VALUE;\\n        int maxdis=0;\\n        for(int j=0;j<list.size()-1;j++)\\n        {\\n          mindis=Math.min(mindis,list.get(j+1)-list.get(j));\\n        }\\n         maxdis=list.get(list.size()-1)-list.get(0);\\n        return new int[]{mindis,maxdis};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862588,
                "title": "easy-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> pt,point;\\n        while(head!=nullptr)\\n        {\\n            pt.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1;i<pt.size()-1;i++)\\n        {\\n            if(pt[i]>pt[i-1]&&pt[i]>pt[i+1])\\n            point.push_back(i);\\n            if(pt[i]<pt[i-1]&&pt[i]<pt[i+1])\\n            point.push_back(i);\\n        }\\n        if(point.size()<2)\\n        return {-1,-1};\\n        int min_di=INT32_MAX;\\n        for(int i=0;i<point.size()-1;i++)\\n        {\\n            min_di=min(min_di,point[i+1]-point[i]);\\n        }\\n        return {min_di,point[point.size()-1]-point[0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> pt,point;\\n        while(head!=nullptr)\\n        {\\n            pt.push_back(head->val);\\n            head=head->next;\\n        }\\n        for(int i=1;i<pt.size()-1;i++)\\n        {\\n            if(pt[i]>pt[i-1]&&pt[i]>pt[i+1])\\n            point.push_back(i);\\n            if(pt[i]<pt[i-1]&&pt[i]<pt[i+1])\\n            point.push_back(i);\\n        }\\n        if(point.size()<2)\\n        return {-1,-1};\\n        int min_di=INT32_MAX;\\n        for(int i=0;i<point.size()-1;i++)\\n        {\\n            min_di=min(min_di,point[i+1]-point[i]);\\n        }\\n        return {min_di,point[point.size()-1]-point[0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835176,
                "title": "runtime-beats-99-8-c-simple-approach",
                "content": "# Intuition\\nWe are given a linked list, and we need to find the critical points in it. Critical points are nodes whose values are either greater than both of their neighbors or smaller than both of their neighbors. We have to calculate the minimum distance between any two consecutive critical points and also figure out how many nodes are between the first and last critical points.\\n\\nTo solve this, we\\'ll be using three pointers to traverse the linked list and compare each middle node with its neighbors to check for critical points. If we find a critical point, we\\'ll keep track of the minimum distance and update our first and last critical point indices accordingly.\\n\\nOnce we\\'re done traversing the linked list, we\\'ll check if we found at least one critical point. If we did, we\\'ll calculate the number of nodes between the first and last critical points. If no critical points were found, we\\'ll return {-1, -1} to indicate that.\\n\\nOverall, we need to be careful with the pointer manipulation and make sure we handle the linked list cases properly to efficiently identify and process the critical points\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy keeping track of the first critical point encountered (fid) and the last critical point encountered (lid), the code can calculate the minimum distance (mind) between any two consecutive critical points.\\n\\nThe approach utilizes three pointers (a, b, and c) to traverse the linked list in groups of three nodes at a time. The middle node (b) is checked against its neighboring nodes (a and c) to determine if it is a critical point. When a critical point is found, the code updates fid and lid accordingly. If at least two critical points have been found (fid != -1), the code calculates their distance and updates the mind variable with the minimum distance encountered so far.\\n\\nAfter traversing the entire linked list, the code checks if there was at least one critical point found (lid != -1). If there are no critical points, it returns {-1, -1}. Otherwise, it calculates the number of nodes between the first and last critical points (mix = lid - fid) and returns the result as {mind, mix}.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- Overall Time Complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Overall Space Complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int idx = 1;\\n        int fid = -1;\\n        int lid = -1;\\n        ListNode* a = head;\\n        ListNode* b = head->next;\\n        ListNode* c = head->next->next;\\n        \\n        if (c == NULL) return {-1, -1};\\n        \\n        int f = -1;\\n        int l = -1;\\n        int mind = INT_MAX;\\n        \\n        while (c) {\\n            if ((b->val > a->val && b->val > c->val) || (b->val < a->val && b->val < c->val)) {\\n                if (fid == -1) fid = idx;\\n                else lid = idx;\\n                \\n                f = l;\\n                l = idx;\\n                \\n                if (f != -1) {\\n                    int d = l - f;\\n                    mind = min(mind, d);\\n                }\\n            }\\n            a = a->next;\\n            b = b->next;\\n            c = c->next;\\n            idx++;\\n        }\\n        \\n        if (lid == -1) return {-1, -1};\\n        \\n        int mix = lid - fid;\\n        \\n        return {mind, mix};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int idx = 1;\\n        int fid = -1;\\n        int lid = -1;\\n        ListNode* a = head;\\n        ListNode* b = head->next;\\n        ListNode* c = head->next->next;\\n        \\n        if (c == NULL) return {-1, -1};\\n        \\n        int f = -1;\\n        int l = -1;\\n        int mind = INT_MAX;\\n        \\n        while (c) {\\n            if ((b->val > a->val && b->val > c->val) || (b->val < a->val && b->val < c->val)) {\\n                if (fid == -1) fid = idx;\\n                else lid = idx;\\n                \\n                f = l;\\n                l = idx;\\n                \\n                if (f != -1) {\\n                    int d = l - f;\\n                    mind = min(mind, d);\\n                }\\n            }\\n            a = a->next;\\n            b = b->next;\\n            c = c->next;\\n            idx++;\\n        }\\n        \\n        if (lid == -1) return {-1, -1};\\n        \\n        int mix = lid - fid;\\n        \\n        return {mind, mix};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830285,
                "title": "efficient-approach-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *temp=head;\\n        int first=-1;\\n        int last=-1;\\n        int counter=1;\\n        int minn=INT_MAX;\\n        vector<int> ans={-1,-1};\\n        while(temp->next->next!=NULL){\\n            int pre_p=temp->val;\\n            int curr_p=temp->next->val;\\n            int next_p=temp->next->next->val;\\n            // Checking for Local Maximum\\n            if (pre_p < curr_p && curr_p > next_p) {\\n                if (first == -1) {\\n                    first = counter;\\n                    last = counter;\\n                } else {\\n                    minn = min(minn, counter - last);\\n                    last = counter;\\n                }\\n            }\\n            // Checking for Local Minimum\\n            if (pre_p > curr_p && curr_p < next_p) {\\n                if (first == -1) {\\n                    first = counter;\\n                    last = counter;\\n                } else {\\n                    minn = min(minn, counter - last);\\n                    last = counter;\\n                }\\n            }\\n\\n            counter++;\\n            temp = temp->next;\\n        }\\n        \\n        if (first == last) {\\n            return ans;\\n        } else {\\n            ans[0] = minn;\\n            ans[1] = last - first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *temp=head;\\n        int first=-1;\\n        int last=-1;\\n        int counter=1;\\n        int minn=INT_MAX;\\n        vector<int> ans={-1,-1};\\n        while(temp->next->next!=NULL){\\n            int pre_p=temp->val;\\n            int curr_p=temp->next->val;\\n            int next_p=temp->next->next->val;\\n            // Checking for Local Maximum\\n            if (pre_p < curr_p && curr_p > next_p) {\\n                if (first == -1) {\\n                    first = counter;\\n                    last = counter;\\n                } else {\\n                    minn = min(minn, counter - last);\\n                    last = counter;\\n                }\\n            }\\n            // Checking for Local Minimum\\n            if (pre_p > curr_p && curr_p < next_p) {\\n                if (first == -1) {\\n                    first = counter;\\n                    last = counter;\\n                } else {\\n                    minn = min(minn, counter - last);\\n                    last = counter;\\n                }\\n            }\\n\\n            counter++;\\n            temp = temp->next;\\n        }\\n        \\n        if (first == last) {\\n            return ans;\\n        } else {\\n            ans[0] = minn;\\n            ans[1] = last - first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821490,
                "title": "beats-99-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v;\\n       if(head==NULL||head->next==NULL||head->next->next==NULL)\\n        return {-1,-1}; \\n        ListNode *curr=head->next;\\n        ListNode *pre=head;\\n        ListNode *nex=head->next->next;\\n        int count=1;\\n       while(nex)\\n       {\\n        if((curr->val>pre->val&&curr->val>nex->val)||(curr->val<pre->val&&curr->val<nex->val))\\n          v.push_back(count);\\n        count++;\\n        curr=curr->next;\\n        pre=pre->next;\\n        nex=nex->next;  \\n       } \\n       if(v.size()<2)\\n       return {-1,-1};\\n       sort(v.begin(),v.end());\\n       int mini=INT_MAX;\\n       for(int i=0;i<v.size()-1;i++)\\n       {\\n           int t=abs(v[i]-v[i+1]);\\n           if(mini>=t)\\n             mini=t;\\n       }\\n       int maxi=v[v.size()-1]-v[0];\\n       return {mini,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>v;\\n       if(head==NULL||head->next==NULL||head->next->next==NULL)\\n        return {-1,-1}; \\n        ListNode *curr=head->next;\\n        ListNode *pre=head;\\n        ListNode *nex=head->next->next;\\n        int count=1;\\n       while(nex)\\n       {\\n        if((curr->val>pre->val&&curr->val>nex->val)||(curr->val<pre->val&&curr->val<nex->val))\\n          v.push_back(count);\\n        count++;\\n        curr=curr->next;\\n        pre=pre->next;\\n        nex=nex->next;  \\n       } \\n       if(v.size()<2)\\n       return {-1,-1};\\n       sort(v.begin(),v.end());\\n       int mini=INT_MAX;\\n       for(int i=0;i<v.size()-1;i++)\\n       {\\n           int t=abs(v[i]-v[i+1]);\\n           if(mini>=t)\\n             mini=t;\\n       }\\n       int maxi=v[v.size()-1]-v[0];\\n       return {mini,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792729,
                "title": "c-code",
                "content": "\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n          vector<int>v;\\n    \\n         int count=1;\\n          int prev=head->val;\\n          ListNode*temp=head->next;\\n          while(temp->next!=NULL){\\n              if((temp->val<prev && temp->val<temp->next->val) ||      (temp->val>prev && temp->val>temp->next->val)){\\n                 v.push_back(count);\\n              }\\n\\n              count++;\\n              prev=temp->val;\\n              temp=temp->next;\\n              \\n          }\\n         \\n          if(v.size()<2){\\n              return {-1,-1};\\n           \\n          }\\n          int mindist=INT_MAX;\\n          for(int i=0;i<v.size()-1;i++){\\n              mindist=min(v[i+1]-v[i],mindist);\\n          }\\n            return {mindist, v.back()-v[0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n          vector<int>v;\\n    \\n         int count=1;\\n          int prev=head->val;\\n          ListNode*temp=head->next;\\n          while(temp->next!=NULL){\\n              if((temp->val<prev && temp->val<temp->next->val) ||      (temp->val>prev && temp->val>temp->next->val)){\\n                 v.push_back(count);\\n              }\\n\\n              count++;\\n              prev=temp->val;\\n              temp=temp->next;\\n              \\n          }\\n         \\n          if(v.size()<2){\\n              return {-1,-1};\\n           \\n          }\\n          int mindist=INT_MAX;\\n          for(int i=0;i<v.size()-1;i++){\\n              mindist=min(v[i+1]-v[i],mindist);\\n          }\\n            return {mindist, v.back()-v[0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791622,
                "title": "c-easy-to-understand-solution",
                "content": "# Explanation\\nThe function initializes a vector ans with two elements, both set to -1. This vector will store the result: the number of nodes between the first and last critical points (stored at index 1) and the minimum distance between any two consecutive critical points (stored at index 0).\\n\\nThe function then goes through a series of checks to find the critical points in the linked list. A critical point is a node whose value is either greater than its previous node and its next node or smaller than both of them.\\n\\nIt does this by using three pointers: prev, curr, and nxt, which respectively represent the previous node, the current node, and the next node.\\n\\nThe function starts by checking if there are at least four nodes in the linked list (i.e., head, prev, curr, and nxt). If there are fewer than four nodes, it means there are no critical points, so it immediately returns the ans vector with both values set to -1.\\n\\nIf there are four or more nodes in the list, the function then goes through the linked list node by node.\\n\\nIf the current node is not a critical point, it increments the i variable (which counts the number of nodes visited) and moves the prev, curr, and nxt pointers to the next nodes in the list.\\n\\nIf the current node is a critical point and it\\'s the first one encountered (firstCP==-1), the function sets firstCP and lastCP to the value of i. It then increments i and moves the pointers to the next nodes.\\n\\nIf the current node is a critical point and it\\'s not the first one encountered, the function calculates the distance between the current critical point and the previous one (i - lastCP) and updates minDis with the minimum of this distance and the previous value of minDis. It then updates lastCP to the current value of i, increments i, and moves the pointers to the next nodes.\\n\\nThe function continues this process until it reaches the end of the linked list.\\n\\nAfter processing all the nodes, the function checks if there was at least one critical point found. If there was only one critical point, it means there are no nodes between critical points, so it returns the ans vector with both values set to -1.\\n\\nIf there were multiple critical points, it means there are nodes between them. The function updates the ans vector with the number of nodes between the first and last critical points (lastCP - firstCP) at index 1 and the minimum distance between consecutive critical points at index 0 (minDis).\\n\\nFinally, the function returns the ans vector as the result.\\n\\n# Approach\\nIterative\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Please dont forget to UPVOTE\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n\\n        ListNode* prev=head;\\n        if(prev==NULL) return ans;\\n\\n        ListNode* curr=prev->next;\\n        if(curr==NULL) return ans;\\n\\n        ListNode* nxt=curr->next;\\n        if(nxt==NULL) return ans;\\n\\n        if(nxt->next==NULL) return ans;\\n\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDis=INT_MAX;\\n        int i=1;\\n        while(nxt!=NULL)\\n        {\\n            bool isCP=((curr->val>prev->val && curr->val>nxt->val) || \\n                        (curr->val<prev->val && curr->val<nxt->val)) ?\\n                            true : false;\\n            if(isCP==false)\\n            {\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true)\\n            {\\n                minDis=min(minDis,i-lastCP);\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n        }\\n        \\n        if(firstCP==lastCP) return ans;\\n        else\\n        {\\n            ans[1]=lastCP-firstCP;\\n            ans[0]=minDis;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n\\n        ListNode* prev=head;\\n        if(prev==NULL) return ans;\\n\\n        ListNode* curr=prev->next;\\n        if(curr==NULL) return ans;\\n\\n        ListNode* nxt=curr->next;\\n        if(nxt==NULL) return ans;\\n\\n        if(nxt->next==NULL) return ans;\\n\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDis=INT_MAX;\\n        int i=1;\\n        while(nxt!=NULL)\\n        {\\n            bool isCP=((curr->val>prev->val && curr->val>nxt->val) || \\n                        (curr->val<prev->val && curr->val<nxt->val)) ?\\n                            true : false;\\n            if(isCP==false)\\n            {\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true)\\n            {\\n                minDis=min(minDis,i-lastCP);\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n        }\\n        \\n        if(firstCP==lastCP) return ans;\\n        else\\n        {\\n            ans[1]=lastCP-firstCP;\\n            ans[0]=minDis;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791621,
                "title": "c-easy-to-understand-solution",
                "content": "# Explanation\\nThe function initializes a vector ans with two elements, both set to -1. This vector will store the result: the number of nodes between the first and last critical points (stored at index 1) and the minimum distance between any two consecutive critical points (stored at index 0).\\n\\nThe function then goes through a series of checks to find the critical points in the linked list. A critical point is a node whose value is either greater than its previous node and its next node or smaller than both of them.\\n\\nIt does this by using three pointers: prev, curr, and nxt, which respectively represent the previous node, the current node, and the next node.\\n\\nThe function starts by checking if there are at least four nodes in the linked list (i.e., head, prev, curr, and nxt). If there are fewer than four nodes, it means there are no critical points, so it immediately returns the ans vector with both values set to -1.\\n\\nIf there are four or more nodes in the list, the function then goes through the linked list node by node.\\n\\nIf the current node is not a critical point, it increments the i variable (which counts the number of nodes visited) and moves the prev, curr, and nxt pointers to the next nodes in the list.\\n\\nIf the current node is a critical point and it\\'s the first one encountered (firstCP==-1), the function sets firstCP and lastCP to the value of i. It then increments i and moves the pointers to the next nodes.\\n\\nIf the current node is a critical point and it\\'s not the first one encountered, the function calculates the distance between the current critical point and the previous one (i - lastCP) and updates minDis with the minimum of this distance and the previous value of minDis. It then updates lastCP to the current value of i, increments i, and moves the pointers to the next nodes.\\n\\nThe function continues this process until it reaches the end of the linked list.\\n\\nAfter processing all the nodes, the function checks if there was at least one critical point found. If there was only one critical point, it means there are no nodes between critical points, so it returns the ans vector with both values set to -1.\\n\\nIf there were multiple critical points, it means there are nodes between them. The function updates the ans vector with the number of nodes between the first and last critical points (lastCP - firstCP) at index 1 and the minimum distance between consecutive critical points at index 0 (minDis).\\n\\nFinally, the function returns the ans vector as the result.\\n\\n# Approach\\nIterative\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Please dont forget to UPVOTE\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n\\n        ListNode* prev=head;\\n        if(prev==NULL) return ans;\\n\\n        ListNode* curr=prev->next;\\n        if(curr==NULL) return ans;\\n\\n        ListNode* nxt=curr->next;\\n        if(nxt==NULL) return ans;\\n\\n        if(nxt->next==NULL) return ans;\\n\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDis=INT_MAX;\\n        int i=1;\\n        while(nxt!=NULL)\\n        {\\n            bool isCP=((curr->val>prev->val && curr->val>nxt->val) || \\n                        (curr->val<prev->val && curr->val<nxt->val)) ?\\n                            true : false;\\n            if(isCP==false)\\n            {\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true)\\n            {\\n                minDis=min(minDis,i-lastCP);\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n        }\\n        \\n        if(firstCP==lastCP) return ans;\\n        else\\n        {\\n            ans[1]=lastCP-firstCP;\\n            ans[0]=minDis;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please dont forget to UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n\\n        ListNode* prev=head;\\n        if(prev==NULL) return ans;\\n\\n        ListNode* curr=prev->next;\\n        if(curr==NULL) return ans;\\n\\n        ListNode* nxt=curr->next;\\n        if(nxt==NULL) return ans;\\n\\n        if(nxt->next==NULL) return ans;\\n\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDis=INT_MAX;\\n        int i=1;\\n        while(nxt!=NULL)\\n        {\\n            bool isCP=((curr->val>prev->val && curr->val>nxt->val) || \\n                        (curr->val<prev->val && curr->val<nxt->val)) ?\\n                            true : false;\\n            if(isCP==false)\\n            {\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n            else if(isCP==true)\\n            {\\n                minDis=min(minDis,i-lastCP);\\n                lastCP=i;\\n                i++;\\n                prev=prev->next;\\n                curr=curr->next;\\n                nxt=nxt->next;\\n            }\\n        }\\n        \\n        if(firstCP==lastCP) return ans;\\n        else\\n        {\\n            ans[1]=lastCP-firstCP;\\n            ans[0]=minDis;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762883,
                "title": "a-c-solution",
                "content": "please tell me everything wrong/bad about this code i need to improve this garbage\\n# Code\\n```\\nint* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize){\\n    int* arr = malloc(3 * sizeof(int));\\n    struct ListNode* prev = head;\\n    struct ListNode* tmp = head->next;\\n    int counter = 0;\\n    int min = 100000;\\n    int max = 0;\\n    arr[0] = -1;\\n    arr[1] = -1;\\n    arr[2] = -1;\\n    *returnSize = 2;\\n\\n    while(tmp->next) {\\n        if(tmp->val > prev->val && tmp->val > tmp->next->val || tmp->val < prev->val && tmp->val < tmp->next->val) {\\n            if(arr[0] == -1) {\\n                arr[0] = counter;\\n            }\\n            else {\\n                arr[1] = arr[2];\\n                arr[2] = counter;\\n            }\\n\\n            max = (arr[2] - arr[0] > max)? arr[2] - arr[0] : max;\\n\\n            if(arr[1] != -1) {\\n                min = ((arr[2] - arr[1]) < min)? (arr[2] - arr[1]) : min;\\n            }\\n            else {\\n                min = max;\\n            }\\n        }\\n        tmp = tmp->next;\\n        prev = prev->next;\\n        counter++;\\n    }\\n\\n    if(min == 100000 || max == 0) {\\n        arr[0] = arr[1] = -1;\\n    }\\n    else {\\n        arr[0] = min;\\n        arr[1] = max;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* nodesBetweenCriticalPoints(struct ListNode* head, int* returnSize){\\n    int* arr = malloc(3 * sizeof(int));\\n    struct ListNode* prev = head;\\n    struct ListNode* tmp = head->next;\\n    int counter = 0;\\n    int min = 100000;\\n    int max = 0;\\n    arr[0] = -1;\\n    arr[1] = -1;\\n    arr[2] = -1;\\n    *returnSize = 2;\\n\\n    while(tmp->next) {\\n        if(tmp->val > prev->val && tmp->val > tmp->next->val || tmp->val < prev->val && tmp->val < tmp->next->val) {\\n            if(arr[0] == -1) {\\n                arr[0] = counter;\\n            }\\n            else {\\n                arr[1] = arr[2];\\n                arr[2] = counter;\\n            }\\n\\n            max = (arr[2] - arr[0] > max)? arr[2] - arr[0] : max;\\n\\n            if(arr[1] != -1) {\\n                min = ((arr[2] - arr[1]) < min)? (arr[2] - arr[1]) : min;\\n            }\\n            else {\\n                min = max;\\n            }\\n        }\\n        tmp = tmp->next;\\n        prev = prev->next;\\n        counter++;\\n    }\\n\\n    if(min == 100000 || max == 0) {\\n        arr[0] = arr[1] = -1;\\n    }\\n    else {\\n        arr[0] = min;\\n        arr[1] = max;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758864,
                "title": "easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nstore the index of every critical point and find mini maxi\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCritical(ListNode* prev , ListNode* curr)\\n    {\\n        if( (prev->val < curr->val && curr->next->val < curr->val) ||\\n            (prev->val > curr->val && curr->next->val > curr->val) )\\n           {\\n               return true;\\n           }     \\n        else \\n        {\\n            return false;\\n        }\\n    }\\n\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int>ans;\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        int index = 2;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        while(curr->next != NULL)\\n        {\\n            if(isCritical(prev,curr))\\n            {\\n                ans.push_back(index);\\n                maxi = max(maxi,index);\\n                mini = min(mini,index);\\n            }\\n            prev = curr;    \\n            curr=curr->next;  \\n            index++;  \\n        }\\n        \\n        int n = ans.size();\\n        if(n < 2)return {-1,-1};\\n\\n        int maxDist = INT_MIN;\\n        int minDist = INT_MAX;\\n\\n        for(int i=1 ; i<n ; i++)\\n        {\\n            int dist = abs(ans[i]-ans[i-1]);\\n            minDist = min(dist,minDist);\\n        }\\n        maxDist = maxi - mini;\\n        return {minDist,maxDist};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool isCritical(ListNode* prev , ListNode* curr)\\n    {\\n        if( (prev->val < curr->val && curr->next->val < curr->val) ||\\n            (prev->val > curr->val && curr->next->val > curr->val) )\\n           {\\n               return true;\\n           }     \\n        else \\n        {\\n            return false;\\n        }\\n    }\\n\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int>ans;\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        int index = 2;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        while(curr->next != NULL)\\n        {\\n            if(isCritical(prev,curr))\\n            {\\n                ans.push_back(index);\\n                maxi = max(maxi,index);\\n                mini = min(mini,index);\\n            }\\n            prev = curr;    \\n            curr=curr->next;  \\n            index++;  \\n        }\\n        \\n        int n = ans.size();\\n        if(n < 2)return {-1,-1};\\n\\n        int maxDist = INT_MIN;\\n        int minDist = INT_MAX;\\n\\n        for(int i=1 ; i<n ; i++)\\n        {\\n            int dist = abs(ans[i]-ans[i-1]);\\n            minDist = min(dist,minDist);\\n        }\\n        maxDist = maxi - mini;\\n        return {minDist,maxDist};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745405,
                "title": "most-efficient-linear-time-constant-space-solution",
                "content": "Simple Linear Time Solution\\n```\\nclass Solution {\\npublic:\\n    bool isLocalMaxima(int a,int b,int c){\\n\\t// finding if the point is a local maxima or not\\n        return a>b and a>c;\\n    }\\n    bool isLocalMinima(int a,int b,int c){\\n\\t// finding if the point is local minimal or not\\n        return a<b and a<c;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\t// edge conditions checks\\n        if(!head and !head->next)return {-1,-1};\\n\\t// store the indexes of the local minima or local maxima\\n        vector<int> dist;\\n        ListNode *prevNode=nullptr, *node=head, *nextNode=head->next;\\n        int index=0;\\n        while(node and nextNode){\\n\\t\\t// prevnode null means we are in first node itset, discard the first node\\n\\t\\t// find if the node is local minima or local maxima\\n            if(prevNode and (isLocalMaxima(node->val,prevNode->val,nextNode->val) or isLocalMinima(node->val,prevNode->val,nextNode->val))){\\n                dist.push_back(index);\\n            }\\n\\t\\t// update the index value and pointers\\n            index+=1;\\n            prevNode=node;\\n            node=node->next;\\n            nextNode=nextNode->next;\\n        }\\n\\t\\t// if size less than 2, invalid return [-1,-1]\\n        if((int)dist.size()<2) return {-1, -1};\\n        \\n\\t\\t// max distance will the difference between last critical point and first critical point. Simple to prove.\\n\\t\\t// min distance we have to iterate over the index stored \\n        int ans_min=INT_MAX;\\n        for(int index=1;index<dist.size();index++){\\n            ans_min=min(ans_min,dist[index]-dist[index-1]);\\n        }\\n\\t\\t// return the values\\n        return {ans_min,dist[(int)dist.size()-1]-dist[0]};\\n    }\\n```\\nThe time complexity of the above algorithm is ```O(n)``` and space complexity is ```O(n)```, where n is the size of linked list we have. \\nWe can reduce the space complexity to ```O(1)``` by using the following code. Time complexity remains the same.\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLocalMaxima(int a,int b,int c){\\n        return a>b and a>c;\\n    }\\n    bool isLocalMinima(int a,int b,int c){\\n        return a<b and a<c;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head and !head->next)return {-1,-1};\\n        ListNode *prevNode=nullptr, *node=head, *nextNode=head->next;\\n        int index=0, prevIndex=0, firstIndex=0;\\n        int ans_min = INT_MAX, count=0;\\n        while(node and nextNode){\\n            if(prevNode and (isLocalMaxima(node->val,prevNode->val,nextNode->val) or isLocalMinima(node->val,prevNode->val,nextNode->val))){\\n                if(count==0){\\n                    firstIndex=index;\\n                    prevIndex=index;\\n                    count+=1; \\n                }else{\\n                    ans_min=min(ans_min,index-prevIndex);\\n                    count+=1;\\n                    prevIndex=index;\\n                }\\n                \\n            }\\n            index+=1;\\n            prevNode=node;\\n            node=node->next;\\n            nextNode=nextNode->next;\\n        }\\n        if(count<2) return {-1, -1};\\n        return {ans_min,prevIndex-firstIndex};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isLocalMaxima(int a,int b,int c){\\n\\t// finding if the point is a local maxima or not\\n        return a>b and a>c;\\n    }\\n    bool isLocalMinima(int a,int b,int c){\\n\\t// finding if the point is local minimal or not\\n        return a<b and a<c;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\t// edge conditions checks\\n        if(!head and !head->next)return {-1,-1};\\n\\t// store the indexes of the local minima or local maxima\\n        vector<int> dist;\\n        ListNode *prevNode=nullptr, *node=head, *nextNode=head->next;\\n        int index=0;\\n        while(node and nextNode){\\n\\t\\t// prevnode null means we are in first node itset, discard the first node\\n\\t\\t// find if the node is local minima or local maxima\\n            if(prevNode and (isLocalMaxima(node->val,prevNode->val,nextNode->val) or isLocalMinima(node->val,prevNode->val,nextNode->val))){\\n                dist.push_back(index);\\n            }\\n\\t\\t// update the index value and pointers\\n            index+=1;\\n            prevNode=node;\\n            node=node->next;\\n            nextNode=nextNode->next;\\n        }\\n\\t\\t// if size less than 2, invalid return [-1,-1]\\n        if((int)dist.size()<2) return {-1, -1};\\n        \\n\\t\\t// max distance will the difference between last critical point and first critical point. Simple to prove.\\n\\t\\t// min distance we have to iterate over the index stored \\n        int ans_min=INT_MAX;\\n        for(int index=1;index<dist.size();index++){\\n            ans_min=min(ans_min,dist[index]-dist[index-1]);\\n        }\\n\\t\\t// return the values\\n        return {ans_min,dist[(int)dist.size()-1]-dist[0]};\\n    }\\n```\n```O(n)```\n```O(n)```\n```O(1)```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLocalMaxima(int a,int b,int c){\\n        return a>b and a>c;\\n    }\\n    bool isLocalMinima(int a,int b,int c){\\n        return a<b and a<c;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(!head and !head->next)return {-1,-1};\\n        ListNode *prevNode=nullptr, *node=head, *nextNode=head->next;\\n        int index=0, prevIndex=0, firstIndex=0;\\n        int ans_min = INT_MAX, count=0;\\n        while(node and nextNode){\\n            if(prevNode and (isLocalMaxima(node->val,prevNode->val,nextNode->val) or isLocalMinima(node->val,prevNode->val,nextNode->val))){\\n                if(count==0){\\n                    firstIndex=index;\\n                    prevIndex=index;\\n                    count+=1; \\n                }else{\\n                    ans_min=min(ans_min,index-prevIndex);\\n                    count+=1;\\n                    prevIndex=index;\\n                }\\n                \\n            }\\n            index+=1;\\n            prevNode=node;\\n            node=node->next;\\n            nextNode=nextNode->next;\\n        }\\n        if(count<2) return {-1, -1};\\n        return {ans_min,prevIndex-firstIndex};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741620,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        if(!head->next->next) return {-1,-1} ;\\n\\n        vector<int> v;\\n        ListNode* h1=head;\\n        ListNode* h2=h1->next;\\n        ListNode* h3=h2->next;\\n        int i=1;\\n        while(h3){\\n            i++;\\n            if(h2->val < h1->val && h2->val < h3->val ){\\n                v.push_back(i);\\n            }\\n            else if(h2->val > h1->val && h2->val > h3->val ){\\n                v.push_back(i);\\n            }\\n            h1=h2;\\n            h2=h3;\\n            h3=h3->next;           \\n        }\\n        if(v.size()==0) return {-1,-1};\\n\\n        sort(v.begin(),v.end());\\n        int mini=100001,maxi=-1;\\n        bool flg=true;\\n        for(int i=0;i<v.size()-1;i++){\\n            if(mini > v[i+1]-v[i]){\\n                mini=min(mini,v[i+1]-v[i]);\\n                flg=false;\\n            }\\n            else if(maxi < v[i+1]-v[i]){\\n                maxi=max(maxi,v[i+1]-v[i]);\\n                flg=false;\\n            }\\n        }\\n        if(flg){\\n            return {-1,-1} ;\\n        }\\n        return {mini,v[v.size()-1]-v[0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        if(!head->next->next) return {-1,-1} ;\\n\\n        vector<int> v;\\n        ListNode* h1=head;\\n        ListNode* h2=h1->next;\\n        ListNode* h3=h2->next;\\n        int i=1;\\n        while(h3){\\n            i++;\\n            if(h2->val < h1->val && h2->val < h3->val ){\\n                v.push_back(i);\\n            }\\n            else if(h2->val > h1->val && h2->val > h3->val ){\\n                v.push_back(i);\\n            }\\n            h1=h2;\\n            h2=h3;\\n            h3=h3->next;           \\n        }\\n        if(v.size()==0) return {-1,-1};\\n\\n        sort(v.begin(),v.end());\\n        int mini=100001,maxi=-1;\\n        bool flg=true;\\n        for(int i=0;i<v.size()-1;i++){\\n            if(mini > v[i+1]-v[i]){\\n                mini=min(mini,v[i+1]-v[i]);\\n                flg=false;\\n            }\\n            else if(maxi < v[i+1]-v[i]){\\n                maxi=max(maxi,v[i+1]-v[i]);\\n                flg=false;\\n            }\\n        }\\n        if(flg){\\n            return {-1,-1} ;\\n        }\\n        return {mini,v[v.size()-1]-v[0]};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3736847,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        int i,previ,minv,maxv,diff;\\n        i=0;\\n        minv=INT_MAX;\\n        maxv=INT_MIN;\\n        diff=INT_MAX;\\n\\n        ListNode *prev,*curr;\\n        prev=head;\\n        curr=head->next;\\n\\n        while(curr->next)\\n        {\\n            if((curr->val>prev->val && curr->val>curr->next->val) || (curr->val<prev->val && curr->val<curr->next->val))\\n            {\\n                if(minv!=INT_MAX)\\n                {\\n                    diff=min(diff,i-previ);\\n                }\\n\\n                minv=min(minv,i);\\n                maxv=max(maxv,i);\\n                previ=i;\\n            }\\n\\n            i++;\\n\\n            prev=curr;\\n            curr=curr->next;\\n        }    \\n\\n        if(minv==INT_MAX || minv==maxv)\\n        {\\n            return {-1,-1};\\n        }\\n\\n        return {diff,maxv-minv};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        int i,previ,minv,maxv,diff;\\n        i=0;\\n        minv=INT_MAX;\\n        maxv=INT_MIN;\\n        diff=INT_MAX;\\n\\n        ListNode *prev,*curr;\\n        prev=head;\\n        curr=head->next;\\n\\n        while(curr->next)\\n        {\\n            if((curr->val>prev->val && curr->val>curr->next->val) || (curr->val<prev->val && curr->val<curr->next->val))\\n            {\\n                if(minv!=INT_MAX)\\n                {\\n                    diff=min(diff,i-previ);\\n                }\\n\\n                minv=min(minv,i);\\n                maxv=max(maxv,i);\\n                previ=i;\\n            }\\n\\n            i++;\\n\\n            prev=curr;\\n            curr=curr->next;\\n        }    \\n\\n        if(minv==INT_MAX || minv==maxv)\\n        {\\n            return {-1,-1};\\n        }\\n\\n        return {diff,maxv-minv};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726330,
                "title": "easy-to-understand-java-solution-very-intuitive-upvote",
                "content": "# Intuition\\nThe max distance will be between the first critial point and the last critial point. But  for the minimun we need to find it. So we store all the critial point in the array list and in the end iterate in the list and find the min and max. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null){\\n            return new int[]{-1, -1};\\n        }\\n\\n        List<Integer> al = new ArrayList<>();\\n\\n        int c = 0;\\n        int prev = head.val;\\n        int curr = -1;\\n\\n        while(head != null){\\n            curr = head.val;\\n\\n            if(head.next != null){\\n                if((curr > prev && curr > head.next.val) || (curr < prev && curr < head.next.val)){\\n                    al.add(c);\\n                }\\n            }\\n            \\n            prev = head.val;\\n            head= head.next;\\n            c++;\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n\\n        if(al.size() < 2) return new int[]{-1, -1};\\n\\n        for(int i = 0; i < al.size() - 1; i++){\\n            min = Math.min(min, al.get(i + 1) - al.get(i));\\n        }\\n\\n        return new int[]{min, al.get(al.size() - 1) - al.get(0)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null){\\n            return new int[]{-1, -1};\\n        }\\n\\n        List<Integer> al = new ArrayList<>();\\n\\n        int c = 0;\\n        int prev = head.val;\\n        int curr = -1;\\n\\n        while(head != null){\\n            curr = head.val;\\n\\n            if(head.next != null){\\n                if((curr > prev && curr > head.next.val) || (curr < prev && curr < head.next.val)){\\n                    al.add(c);\\n                }\\n            }\\n            \\n            prev = head.val;\\n            head= head.next;\\n            c++;\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n\\n        if(al.size() < 2) return new int[]{-1, -1};\\n\\n        for(int i = 0; i < al.size() - 1; i++){\\n            min = Math.min(min, al.get(i + 1) - al.get(i));\\n        }\\n\\n        return new int[]{min, al.get(al.size() - 1) - al.get(0)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712932,
                "title": "c-program",
                "content": "\\n\\n# Code\\n```\\nint *nodesBetweenCriticalPoints(struct ListNode *head, int *returnSize)\\n{\\n    int *arr = (int *)malloc(sizeof(int) * 2);\\n    int prev = 0;\\n    struct ListNode *temp = head;\\n    arr[0] = 0;\\n    arr[1] = 0;\\n    *returnSize=2;\\n    int prev_index = 0;\\n    int i = 1;\\n    int min=-1;\\n    if (head == NULL || head->next == NULL || head->next->next == NULL)\\n    {\\n        arr[0] = -1;\\n        arr[1] = -1;\\n        return arr;\\n    }\\n    while (temp->next != NULL)\\n    {\\n        if (temp == head)\\n        {\\n            prev = temp->val;\\n        }\\n        else\\n        {\\n            if ((temp->val > prev && temp->val > temp->next->val) || (temp->val < prev && temp->val < temp->next->val))\\n            {\\n                if (arr[1] == 0)\\n                {\\n                    arr[1] = i;\\n                    prev_index = i;\\n                    arr[0]=arr[1];\\n                }\\n                else\\n                {\\n                    arr[0] = i - prev_index;\\n                    prev_index = i;\\n                    if(min==-1)\\n                    {\\n                        min=arr[0];\\n                    }\\n                    else if(arr[0]<min)\\n                    {\\n                        min=arr[0];\\n                    }\\n                }\\n            }\\n            prev = temp->val;\\n        }\\n        temp = temp->next;\\n        i++;\\n    }\\n    arr[1] = prev_index - arr[1];\\n    arr[0]=min;\\n    if (arr[0] == 0 || arr[1] == 0)\\n    {\\n        arr[0] = arr[1] = -1;\\n        return arr;\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint *nodesBetweenCriticalPoints(struct ListNode *head, int *returnSize)\\n{\\n    int *arr = (int *)malloc(sizeof(int) * 2);\\n    int prev = 0;\\n    struct ListNode *temp = head;\\n    arr[0] = 0;\\n    arr[1] = 0;\\n    *returnSize=2;\\n    int prev_index = 0;\\n    int i = 1;\\n    int min=-1;\\n    if (head == NULL || head->next == NULL || head->next->next == NULL)\\n    {\\n        arr[0] = -1;\\n        arr[1] = -1;\\n        return arr;\\n    }\\n    while (temp->next != NULL)\\n    {\\n        if (temp == head)\\n        {\\n            prev = temp->val;\\n        }\\n        else\\n        {\\n            if ((temp->val > prev && temp->val > temp->next->val) || (temp->val < prev && temp->val < temp->next->val))\\n            {\\n                if (arr[1] == 0)\\n                {\\n                    arr[1] = i;\\n                    prev_index = i;\\n                    arr[0]=arr[1];\\n                }\\n                else\\n                {\\n                    arr[0] = i - prev_index;\\n                    prev_index = i;\\n                    if(min==-1)\\n                    {\\n                        min=arr[0];\\n                    }\\n                    else if(arr[0]<min)\\n                    {\\n                        min=arr[0];\\n                    }\\n                }\\n            }\\n            prev = temp->val;\\n        }\\n        temp = temp->next;\\n        i++;\\n    }\\n    arr[1] = prev_index - arr[1];\\n    arr[0]=min;\\n    if (arr[0] == 0 || arr[1] == 0)\\n    {\\n        arr[0] = arr[1] = -1;\\n        return arr;\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706978,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe difference between firstpoint and lastpoint of local min/max as max_d.\\nthe smallest difference between two adjacent indices (current i minus last) as min_d.\\nThe result is {min_d, last - first}.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // base case\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n        {\\n            return{-1,-1};\\n        }\\n        int min_distance=INT_MAX;\\n        int max_distance=INT_MIN;\\n\\n        int totalcp=0;\\n        int index=1;\\n\\n        ListNode*prev=head;\\n        ListNode*next=head->next;\\n\\n        // points declare for the maximum distance\\n        int firstpoint=INT_MAX;\\n        int lastpoint=INT_MIN;\\n\\n        int criticalpoint=-1;\\n\\n        while(head->next!=NULL)\\n        {\\n            if((head->val<prev->val)and(head->val<head->next->val))\\n            {\\n                // we got the local minima\\n                firstpoint=min(firstpoint,index);\\n                lastpoint=max(lastpoint,index);\\n\\n                if(criticalpoint!=-1)\\n                min_distance=min(min_distance,index-criticalpoint);\\n\\n                criticalpoint=index;\\n                totalcp++;\\n            }\\n            else if((head->val>prev->val)and(head->val>head->next->val))\\n            {\\n                // we got the local maxima\\n                firstpoint=min(firstpoint,index);\\n                lastpoint=max(lastpoint,index);\\n\\n                if(criticalpoint!=-1)\\n                min_distance=min(min_distance,index-criticalpoint);\\n\\n                criticalpoint=index;\\n                totalcp++;\\n            }\\n            index++;\\n            prev=head;\\n            head=head->next;\\n        }\\n\\n        if(totalcp<2)\\n        {\\n            return {-1,-1};\\n        }\\n\\n        max_distance=lastpoint-firstpoint;\\n\\n        return {min_distance,max_distance};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        // base case\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n        {\\n            return{-1,-1};\\n        }\\n        int min_distance=INT_MAX;\\n        int max_distance=INT_MIN;\\n\\n        int totalcp=0;\\n        int index=1;\\n\\n        ListNode*prev=head;\\n        ListNode*next=head->next;\\n\\n        // points declare for the maximum distance\\n        int firstpoint=INT_MAX;\\n        int lastpoint=INT_MIN;\\n\\n        int criticalpoint=-1;\\n\\n        while(head->next!=NULL)\\n        {\\n            if((head->val<prev->val)and(head->val<head->next->val))\\n            {\\n                // we got the local minima\\n                firstpoint=min(firstpoint,index);\\n                lastpoint=max(lastpoint,index);\\n\\n                if(criticalpoint!=-1)\\n                min_distance=min(min_distance,index-criticalpoint);\\n\\n                criticalpoint=index;\\n                totalcp++;\\n            }\\n            else if((head->val>prev->val)and(head->val>head->next->val))\\n            {\\n                // we got the local maxima\\n                firstpoint=min(firstpoint,index);\\n                lastpoint=max(lastpoint,index);\\n\\n                if(criticalpoint!=-1)\\n                min_distance=min(min_distance,index-criticalpoint);\\n\\n                criticalpoint=index;\\n                totalcp++;\\n            }\\n            index++;\\n            prev=head;\\n            head=head->next;\\n        }\\n\\n        if(totalcp<2)\\n        {\\n            return {-1,-1};\\n        }\\n\\n        max_distance=lastpoint-firstpoint;\\n\\n        return {min_distance,max_distance};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695820,
                "title": "one-pass-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev_val = head.val\\n        count, first = 1, 0\\n        current = head.next\\n        min_, max_ = 100000, 0\\n        \\n        while current.next:\\n            if (max(prev_val,current.next.val) < current.val) or (min(prev_val,current.next.val) > current.val):\\n                if not first:\\n                    first = count\\n                    prev_last = count\\n                else:\\n                    max_ = count - first\\n                    min_ = min(min_, count - prev_last)\\n                    prev_last = count\\n\\n            count = count + 1\\n            prev_val = current.val\\n\\n            current = current.next\\n\\n        return [min_,max_] if max_ else [-1,-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        prev_val = head.val\\n        count, first = 1, 0\\n        current = head.next\\n        min_, max_ = 100000, 0\\n        \\n        while current.next:\\n            if (max(prev_val,current.next.val) < current.val) or (min(prev_val,current.next.val) > current.val):\\n                if not first:\\n                    first = count\\n                    prev_last = count\\n                else:\\n                    max_ = count - first\\n                    min_ = min(min_, count - prev_last)\\n                    prev_last = count\\n\\n            count = count + 1\\n            prev_val = current.val\\n\\n            current = current.next\\n\\n        return [min_,max_] if max_ else [-1,-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684377,
                "title": "93-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n *Definition for singly-linked list.\\n *struct ListNode {\\n *int val;\\n *ListNode * next;\\n *ListNode() : val(0), next(nullptr) {}\\n *ListNode(int x) : val(x), next(nullptr) {}\\n *ListNode(int x, ListNode *next) : val(x), next(next) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n        vector<int> nodesBetweenCriticalPoints(ListNode *head)\\n        {\\n            vector<int> ans = { -1,\\n                -1\\n            };\\n            ListNode *prev = head;\\n            if (!prev)\\n            {\\n                return ans;\\n            }\\n            ListNode *curr = head->next;\\n            if (!curr)\\n            {\\n                return ans;\\n            }\\n            ListNode *nxt = head->next->next;\\n            if (!nxt)\\n            {\\n                return ans;\\n            }\\n\\n            int firstCp = -1;\\n            int lastCp = -1;\\n            int minDist = INT_MAX;\\n            int i = 1;\\n            while (nxt)\\n            {\\n                bool isCp = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                    (curr->val < prev->val && curr->val < nxt->val)) ? true : false;\\n                if (isCp && firstCp == -1)\\n                {\\n                    firstCp = i;\\n                    lastCp = i;\\n                }\\n                else if (isCp)\\n                {\\n                    minDist = min(minDist, i - lastCp);\\n                    lastCp = i;\\n                }\\n                ++i;\\n                prev = prev->next;\\n                curr = curr->next;\\n                nxt = nxt->next;\\n            }\\n            if (lastCp == firstCp)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                ans[0] = minDist;\\n                ans[1]=lastCp-firstCp;\\n            } \\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n *Definition for singly-linked list.\\n *struct ListNode {\\n *int val;\\n *ListNode * next;\\n *ListNode() : val(0), next(nullptr) {}\\n *ListNode(int x) : val(x), next(nullptr) {}\\n *ListNode(int x, ListNode *next) : val(x), next(next) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n        vector<int> nodesBetweenCriticalPoints(ListNode *head)\\n        {\\n            vector<int> ans = { -1,\\n                -1\\n            };\\n            ListNode *prev = head;\\n            if (!prev)\\n            {\\n                return ans;\\n            }\\n            ListNode *curr = head->next;\\n            if (!curr)\\n            {\\n                return ans;\\n            }\\n            ListNode *nxt = head->next->next;\\n            if (!nxt)\\n            {\\n                return ans;\\n            }\\n\\n            int firstCp = -1;\\n            int lastCp = -1;\\n            int minDist = INT_MAX;\\n            int i = 1;\\n            while (nxt)\\n            {\\n                bool isCp = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                    (curr->val < prev->val && curr->val < nxt->val)) ? true : false;\\n                if (isCp && firstCp == -1)\\n                {\\n                    firstCp = i;\\n                    lastCp = i;\\n                }\\n                else if (isCp)\\n                {\\n                    minDist = min(minDist, i - lastCp);\\n                    lastCp = i;\\n                }\\n                ++i;\\n                prev = prev->next;\\n                curr = curr->next;\\n                nxt = nxt->next;\\n            }\\n            if (lastCp == firstCp)\\n            {\\n                return ans;\\n            }\\n            else\\n            {\\n                ans[0] = minDist;\\n                ans[1]=lastCp-firstCp;\\n            } \\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682266,
                "title": "prev-and-curr-pointer-solution",
                "content": "# Intuition\\nCurrent and Prev Pointer \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStart traversing from the second node and maintain a variable that indicates prev value. At each step, check if given condition is satisfied and update the array with the current index. Now the array is filled with all the critical points indices. Now traverse the list and get the minimum difference. Get the maximum difference by subtracting last and first index of list. Return {-1, -1} in all other cases.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null)\\n            return new int[]{-1, -1};\\n        List<Integer> al = new ArrayList<>();\\n        int c = 0;\\n        int prev = head.val, curr = -1;\\n        head = head.next;\\n        while(head != null) {\\n            curr = head.val;\\n            if(head.next != null){\\n                if((curr > prev && curr > head.next.val) || (curr < prev && curr < head.next.val)){\\n                    al.add(c);\\n                }\\n            }\\n            prev = head.val;   \\n            head = head.next;\\n            c++;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        if(al.size() < 2)\\n            return new int[]{-1, -1};\\n        for(int i=1; i<al.size(); i++){\\n            min = Math.min(al.get(i) - al.get(i-1), min);\\n        }\\n        return new int[]{min, al.get(al.size()-1) - al.get(0)};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head == null || head.next == null)\\n            return new int[]{-1, -1};\\n        List<Integer> al = new ArrayList<>();\\n        int c = 0;\\n        int prev = head.val, curr = -1;\\n        head = head.next;\\n        while(head != null) {\\n            curr = head.val;\\n            if(head.next != null){\\n                if((curr > prev && curr > head.next.val) || (curr < prev && curr < head.next.val)){\\n                    al.add(c);\\n                }\\n            }\\n            prev = head.val;   \\n            head = head.next;\\n            c++;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        if(al.size() < 2)\\n            return new int[]{-1, -1};\\n        for(int i=1; i<al.size(); i++){\\n            min = Math.min(al.get(i) - al.get(i-1), min);\\n        }\\n        return new int[]{min, al.get(al.size()-1) - al.get(0)};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679472,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return {-1,-1};\\n        }\\n        ListNode* pre = head;\\n        ListNode* cur = head->next;\\n        // vector<int> v;\\n        int ct=2;\\n        int mn = 1e9+7;\\n        int mx = 0;\\n        int first=-1;\\n        int c = -1;\\n        int p=-1;\\n        while(cur!=NULL && cur->next!=NULL){\\n            ListNode* nxt = cur->next;\\n            if(cur->val > pre->val && cur->val > nxt->val){\\n                // v.push_back(ct);\\n                if(first==-1){\\n                    first = ct;\\n                    c = ct;\\n                }\\n                else{\\n                    p = c;\\n                    c = ct;\\n                    mn = min(mn,c-p);\\n                }\\n            }\\n            else if(cur->val < pre->val && cur->val < nxt->val){\\n                if(first==-1){\\n                    first = ct;\\n                    c = ct;\\n                }\\n                else{\\n                    p = c;\\n                    c = ct;\\n                    mn = min(mn,c-p);\\n                }\\n            }\\n            ct++;\\n            pre=cur;\\n            cur= cur->next;\\n        }\\n        if(p==-1){\\n            return {-1,-1};\\n        }\\n        mx = c-first;\\n        return {mn,mx};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if(head==NULL||head->next==NULL){\\n            return {-1,-1};\\n        }\\n        ListNode* pre = head;\\n        ListNode* cur = head->next;\\n        // vector<int> v;\\n        int ct=2;\\n        int mn = 1e9+7;\\n        int mx = 0;\\n        int first=-1;\\n        int c = -1;\\n        int p=-1;\\n        while(cur!=NULL && cur->next!=NULL){\\n            ListNode* nxt = cur->next;\\n            if(cur->val > pre->val && cur->val > nxt->val){\\n                // v.push_back(ct);\\n                if(first==-1){\\n                    first = ct;\\n                    c = ct;\\n                }\\n                else{\\n                    p = c;\\n                    c = ct;\\n                    mn = min(mn,c-p);\\n                }\\n            }\\n            else if(cur->val < pre->val && cur->val < nxt->val){\\n                if(first==-1){\\n                    first = ct;\\n                    c = ct;\\n                }\\n                else{\\n                    p = c;\\n                    c = ct;\\n                    mn = min(mn,c-p);\\n                }\\n            }\\n            ct++;\\n            pre=cur;\\n            cur= cur->next;\\n        }\\n        if(p==-1){\\n            return {-1,-1};\\n        }\\n        mx = c-first;\\n        return {mn,mx};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670781,
                "title": "c-solution-o-n-time-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\n        vector<int> ans{-1,-1};\\n\\n        ListNode* prev = head;\\n        if(!prev)return ans;\\n\\n        ListNode* curr = head->next;\\n        if(!curr)return ans;\\n\\n        ListNode* nxt = head->next->next;\\n        if(!nxt)return ans;\\n        \\n        int firstCp = -1;\\n        int LastCp = -1;\\n        int midCp = INT_MAX;\\n        int i = 1;\\n        while(nxt){\\n            if((prev->val>curr->val && curr->val<nxt->val) || (prev->val<curr->val && curr->val>nxt->val)){\\n                if(firstCp==-1){\\n                   firstCp = i;\\n                   LastCp = i;\\n                }else{\\n                    midCp = min(midCp, i-LastCp);\\n                    LastCp = i;\\n                }\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n\\n        }\\n\\n        if(firstCp==LastCp){\\n           return ans;\\n        }\\n            ans[0] = midCp;\\n            ans[1] = LastCp -  firstCp;\\n            return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n\\n        vector<int> ans{-1,-1};\\n\\n        ListNode* prev = head;\\n        if(!prev)return ans;\\n\\n        ListNode* curr = head->next;\\n        if(!curr)return ans;\\n\\n        ListNode* nxt = head->next->next;\\n        if(!nxt)return ans;\\n        \\n        int firstCp = -1;\\n        int LastCp = -1;\\n        int midCp = INT_MAX;\\n        int i = 1;\\n        while(nxt){\\n            if((prev->val>curr->val && curr->val<nxt->val) || (prev->val<curr->val && curr->val>nxt->val)){\\n                if(firstCp==-1){\\n                   firstCp = i;\\n                   LastCp = i;\\n                }else{\\n                    midCp = min(midCp, i-LastCp);\\n                    LastCp = i;\\n                }\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n\\n        }\\n\\n        if(firstCp==LastCp){\\n           return ans;\\n        }\\n            ans[0] = midCp;\\n            ans[1] = LastCp -  firstCp;\\n            return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654283,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1,-1};\\n        ListNode* prev = head;\\n        if(!prev) return ans;\\n\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n\\n        ListNode* nxt = head->next->next;\\n        if(!nxt) return ans;\\n\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        int i=1;\\n\\n        while(nxt){\\n            bool isCP = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                            (curr->val < prev->val && curr->val < nxt->val)    \\n                        ) ? true : false;\\n            if(isCP && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCP){\\n                minDist = min(minDist,i-lastCP);\\n                lastCP = i;\\n            }\\n            ++i;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n        if(firstCP == lastCP ){\\n            return ans;\\n        }\\n        else{\\n            ans[0]=minDist;\\n            ans[1]=lastCP-firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1,-1};\\n        ListNode* prev = head;\\n        if(!prev) return ans;\\n\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n\\n        ListNode* nxt = head->next->next;\\n        if(!nxt) return ans;\\n\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        int i=1;\\n\\n        while(nxt){\\n            bool isCP = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                            (curr->val < prev->val && curr->val < nxt->val)    \\n                        ) ? true : false;\\n            if(isCP && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCP){\\n                minDist = min(minDist,i-lastCP);\\n                lastCP = i;\\n            }\\n            ++i;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n        if(firstCP == lastCP ){\\n            return ans;\\n        }\\n        else{\\n            ans[0]=minDist;\\n            ans[1]=lastCP-firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648160,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* tmp = head->next ;\\n        vector<int>criticalIdx ;\\n        int prev = head->val ;\\n        int idx = 1 ;\\n        while(tmp!= nullptr && tmp->next != nullptr){\\n            if(tmp->val > prev && tmp->val > tmp->next->val)\\n                criticalIdx.push_back(idx) ;\\n            else if(tmp->val < prev && tmp->val < tmp->next->val)\\n                criticalIdx.push_back(idx) ;\\n            prev = tmp->val ;\\n            tmp = tmp->next ;\\n            idx++ ;    \\n        }\\n        if(criticalIdx.size() < 2)\\n            return {-1, -1} ;\\n        int minima = INT_MAX ;\\n        for(int i = 1; i < criticalIdx.size(); i++){\\n            minima = min(minima, criticalIdx[i] - criticalIdx[i-1]) ;\\n        }\\n        return {minima, criticalIdx.back() - criticalIdx.front()} ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* tmp = head->next ;\\n        vector<int>criticalIdx ;\\n        int prev = head->val ;\\n        int idx = 1 ;\\n        while(tmp!= nullptr && tmp->next != nullptr){\\n            if(tmp->val > prev && tmp->val > tmp->next->val)\\n                criticalIdx.push_back(idx) ;\\n            else if(tmp->val < prev && tmp->val < tmp->next->val)\\n                criticalIdx.push_back(idx) ;\\n            prev = tmp->val ;\\n            tmp = tmp->next ;\\n            idx++ ;    \\n        }\\n        if(criticalIdx.size() < 2)\\n            return {-1, -1} ;\\n        int minima = INT_MAX ;\\n        for(int i = 1; i < criticalIdx.size(); i++){\\n            minima = min(minima, criticalIdx[i] - criticalIdx[i-1]) ;\\n        }\\n        return {minima, criticalIdx.back() - criticalIdx.front()} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632167,
                "title": "very-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n\\t\\t{\\n\\t\\t\\t        vector<int>v;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint firstidx = -1;\\n\\t\\t\\t\\t\\tint lastidx  = -1;\\n\\t\\t\\t\\t\\tint prv = -1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint mindis = INT_MAX;\\n\\t\\t\\t\\t\\tint maxdis = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tListNode* temp = head;\\n\\t\\t\\t\\twhile(temp != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(temp->val);\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint idx = 0;\\n\\t\\t\\t\\twhile(idx < v.size())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(idx == 0 or idx == v.size()-1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//checking if the curr node is the critical node\\n\\t\\t\\t\\t\\t\\tif((v[idx] < v[idx - 1]) and (v[idx] < v[idx + 1]) or (v[idx] > v[idx-1]) and (v[idx] > v[idx+1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t//local minima critical point\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(mindis == INT_MAX) return {-1,-1};\\n\\t\\t\\t    return {mindis , lastidx-firstidx};\\n\\t\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n\\t\\t{\\n\\t\\t\\t        vector<int>v;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint firstidx = -1;\\n\\t\\t\\t\\t\\tint lastidx  = -1;\\n\\t\\t\\t\\t\\tint prv = -1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint mindis = INT_MAX;\\n\\t\\t\\t\\t\\tint maxdis = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tListNode* temp = head;\\n\\t\\t\\t\\twhile(temp != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(temp->val);\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint idx = 0;\\n\\t\\t\\t\\twhile(idx < v.size())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(idx == 0 or idx == v.size()-1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//checking if the curr node is the critical node\\n\\t\\t\\t\\t\\t\\tif((v[idx] < v[idx - 1]) and (v[idx] < v[idx + 1]) or (v[idx] > v[idx-1]) and (v[idx] > v[idx+1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t//local minima critical point\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(mindis == INT_MAX) return {-1,-1};\\n\\t\\t\\t    return {mindis , lastidx-firstidx};\\n\\t\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632024,
                "title": "auxiliary-vector-must-see-easy-to-understand",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n\\t\\t{\\n\\t\\t\\t    vector<int>v;\\n\\t\\t\\t\\t\\t//first of all we need to keep all the values into the array so \\n\\t\\t\\t\\t\\t//that we can access the nodes prev value and nodes after value\\n\\t\\t\\t\\t\\tint firstidx = -1;\\n\\t\\t\\t\\t\\tint lastidx  = -1;\\n\\t\\t\\t\\t\\tint prv = -1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint mindis = INT_MAX;\\n\\t\\t\\t\\t\\tint maxdis = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tListNode* temp = head;\\n\\t\\t\\t\\twhile(temp != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(temp->val);\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint idx = 0;\\n\\t\\t\\t\\twhile(idx < v.size())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(idx == 0 or idx == v.size()-1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//checking if the curr node is the critical node\\n\\t\\t\\t\\t\\t\\tif((v[idx] < v[idx - 1]) and (v[idx] < v[idx + 1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t//local minima critical point\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if((v[idx] > v[idx-1]) and (v[idx] > v[idx+1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//cout<<\"mindis = \"<<mindis<<\" \"<<\"maxdis = \"<<(lastidx - firstidx)<<endl;\\n\\t\\t\\t\\tif(mindis == INT_MAX) return {-1,-1};\\n\\t\\t\\t  \\n\\t\\t\\t  return {mindis , lastidx-firstidx};\\n\\t\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n\\t\\t{\\n\\t\\t\\t    vector<int>v;\\n\\t\\t\\t\\t\\t//first of all we need to keep all the values into the array so \\n\\t\\t\\t\\t\\t//that we can access the nodes prev value and nodes after value\\n\\t\\t\\t\\t\\tint firstidx = -1;\\n\\t\\t\\t\\t\\tint lastidx  = -1;\\n\\t\\t\\t\\t\\tint prv = -1;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tint mindis = INT_MAX;\\n\\t\\t\\t\\t\\tint maxdis = 0;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tListNode* temp = head;\\n\\t\\t\\t\\twhile(temp != NULL)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(temp->val);\\n\\t\\t\\t\\t\\ttemp = temp -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint idx = 0;\\n\\t\\t\\t\\twhile(idx < v.size())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(idx == 0 or idx == v.size()-1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t//checking if the curr node is the critical node\\n\\t\\t\\t\\t\\t\\tif((v[idx] < v[idx - 1]) and (v[idx] < v[idx + 1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t//local minima critical point\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if((v[idx] > v[idx-1]) and (v[idx] > v[idx+1]))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif(firstidx == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tfirstidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlastidx = idx;\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\tif(prv == -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t prv = idx;\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\telse if(prv != -1)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t  mindis = min(mindis , idx - prv);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprv = idx;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//cout<<\"mindis = \"<<mindis<<\" \"<<\"maxdis = \"<<(lastidx - firstidx)<<endl;\\n\\t\\t\\t\\tif(mindis == INT_MAX) return {-1,-1};\\n\\t\\t\\t  \\n\\t\\t\\t  return {mindis , lastidx-firstidx};\\n\\t\\t\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3614414,
                "title": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points-c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1, -1}; // minDist, maxDist\\n        ListNode* prev = head;\\n        if(prev == NULL){\\n            return ans;\\n        }\\n        ListNode* curr = head->next;\\n        if(curr == NULL){\\n            return ans;\\n        }\\n        ListNode* nxt = head->next->next;\\n        if(nxt == NULL){\\n            return ans;\\n        }\\n\\n        int firstCP = -1;\\n        int lastCP = -1; \\n        int minDist = INT_MAX;\\n        int i = 1;\\n\\n        while(nxt != NULL){\\n            bool cp = (((curr->val > prev->val) && (curr->val > nxt->val)) || \\n                        ((curr->val < prev->val) && (curr->val < nxt->val))) \\n                        ? true : false;\\n            if(cp == true && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(cp==true){\\n                minDist = min(minDist, i-lastCP);\\n                lastCP = i;\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n\\n        if(firstCP == lastCP){\\n            // only 1 CP found\\n            return ans;\\n        }else{\\n            ans[0] = minDist;\\n            ans[1] = lastCP - firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1, -1}; // minDist, maxDist\\n        ListNode* prev = head;\\n        if(prev == NULL){\\n            return ans;\\n        }\\n        ListNode* curr = head->next;\\n        if(curr == NULL){\\n            return ans;\\n        }\\n        ListNode* nxt = head->next->next;\\n        if(nxt == NULL){\\n            return ans;\\n        }\\n\\n        int firstCP = -1;\\n        int lastCP = -1; \\n        int minDist = INT_MAX;\\n        int i = 1;\\n\\n        while(nxt != NULL){\\n            bool cp = (((curr->val > prev->val) && (curr->val > nxt->val)) || \\n                        ((curr->val < prev->val) && (curr->val < nxt->val))) \\n                        ? true : false;\\n            if(cp == true && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(cp==true){\\n                minDist = min(minDist, i-lastCP);\\n                lastCP = i;\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n\\n        if(firstCP == lastCP){\\n            // only 1 CP found\\n            return ans;\\n        }else{\\n            ans[0] = minDist;\\n            ans[1] = lastCP - firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613571,
                "title": "easiest-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCritical(ListNode* prev,ListNode* head){\\n        if(head->val > prev->val && head->val > head->next->val)\\n            return true;\\n        if(head->val < prev->val && head->val < head->next->val)\\n            return true;\\n    return false;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* forward = head->next->next;\\n        if(!forward)    return {-1,-1};\\n\\n        int i = 1,maxDist = INT_MIN,minDist = INT_MAX;\\n        int firstCP = -1,lastCP = -1;\\n        while(forward){\\n            if(isCritical(prev,curr) && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCritical(prev,curr)){\\n                minDist = min(minDist,i-lastCP);\\n                lastCP = i;\\n            }\\n            ++i;\\n            prev = curr;\\n            curr = forward;\\n            forward = curr->next;//new current ka next\\n        }\\n        if(lastCP != firstCP)   maxDist = lastCP - firstCP;\\n    if(maxDist == INT_MIN)  maxDist = -1;\\n    if(minDist == INT_MAX)  minDist = -1;\\n    return {minDist,maxDist};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isCritical(ListNode* prev,ListNode* head){\\n        if(head->val > prev->val && head->val > head->next->val)\\n            return true;\\n        if(head->val < prev->val && head->val < head->next->val)\\n            return true;\\n    return false;\\n    }\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* forward = head->next->next;\\n        if(!forward)    return {-1,-1};\\n\\n        int i = 1,maxDist = INT_MIN,minDist = INT_MAX;\\n        int firstCP = -1,lastCP = -1;\\n        while(forward){\\n            if(isCritical(prev,curr) && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCritical(prev,curr)){\\n                minDist = min(minDist,i-lastCP);\\n                lastCP = i;\\n            }\\n            ++i;\\n            prev = curr;\\n            curr = forward;\\n            forward = curr->next;//new current ka next\\n        }\\n        if(lastCP != firstCP)   maxDist = lastCP - firstCP;\\n    if(maxDist == INT_MIN)  maxDist = -1;\\n    if(minDist == INT_MAX)  minDist = -1;\\n    return {minDist,maxDist};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599121,
                "title": "simple-approach-beat-100-in-time-constant-space",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios::sync_with_stdio(false);\\n        ListNode* prev  = head;\\n        ListNode* curr = prev -> next;\\n        ListNode* next = curr -> next;\\n        int _min = INT_MAX;\\n        int _max = INT_MIN;\\n        int firstOcc = -1;\\n        int lastOcc = -1;\\n        int i = 0;\\n        while(next){\\n            if((prev->val < curr->val && curr->val > next->val) || (prev->val > curr->val && curr->val < next->val)){\\n                if(firstOcc != -1){\\n                    _min = min(_min,i-lastOcc);\\n                    _max = max(_max,i-firstOcc);\\n                    lastOcc = i;\\n                }else{\\n                    firstOcc = i;\\n                    lastOcc = i;\\n                }\\n            }\\n\\n            prev = curr;\\n            curr = next;\\n            next = next -> next;\\n            i++;\\n        }\\n        if(_min == INT_MAX)\\n            _min = -1;\\n        if(_max == INT_MIN)\\n            _max = -1;\\n        return {_min,_max};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios::sync_with_stdio(false);\\n        ListNode* prev  = head;\\n        ListNode* curr = prev -> next;\\n        ListNode* next = curr -> next;\\n        int _min = INT_MAX;\\n        int _max = INT_MIN;\\n        int firstOcc = -1;\\n        int lastOcc = -1;\\n        int i = 0;\\n        while(next){\\n            if((prev->val < curr->val && curr->val > next->val) || (prev->val > curr->val && curr->val < next->val)){\\n                if(firstOcc != -1){\\n                    _min = min(_min,i-lastOcc);\\n                    _max = max(_max,i-firstOcc);\\n                    lastOcc = i;\\n                }else{\\n                    firstOcc = i;\\n                    lastOcc = i;\\n                }\\n            }\\n\\n            prev = curr;\\n            curr = next;\\n            next = next -> next;\\n            i++;\\n        }\\n        if(_min == INT_MAX)\\n            _min = -1;\\n        if(_max == INT_MIN)\\n            _max = -1;\\n        return {_min,_max};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592359,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(head.next.next==null) // base case\\n        {\\n            return new int[]{-1,-1};\\n        }\\n        int prev=head.val;\\n        head=head.next;\\n        int k=2;\\n        while(head.next!=null)\\n        {\\n            if(head.val<prev && head.val<head.next.val)\\n            {\\n                arr.add(k);\\n            }\\n            if(head.val>prev && head.val>head.next.val)\\n            {\\n                arr.add(k);\\n            }\\n            prev=head.val;\\n            k++;\\n            head=head.next;\\n        }\\n        int []arr1=new int[2];\\n        Collections.sort(arr);\\n        int n=arr.size();\\n        if(arr.size()>=2)\\n        {\\n            int min=Integer.MAX_VALUE;\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n                min=Math.min(arr.get(i+1)-arr.get(i),min);\\n            }\\n            arr1[0]=min;\\n            int max=arr.get(n-1)-arr.get(0);\\n            arr1[1]=max;\\n        }\\n        else \\n            return new int[]{-1,-1};\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        if(head.next.next==null) // base case\\n        {\\n            return new int[]{-1,-1};\\n        }\\n        int prev=head.val;\\n        head=head.next;\\n        int k=2;\\n        while(head.next!=null)\\n        {\\n            if(head.val<prev && head.val<head.next.val)\\n            {\\n                arr.add(k);\\n            }\\n            if(head.val>prev && head.val>head.next.val)\\n            {\\n                arr.add(k);\\n            }\\n            prev=head.val;\\n            k++;\\n            head=head.next;\\n        }\\n        int []arr1=new int[2];\\n        Collections.sort(arr);\\n        int n=arr.size();\\n        if(arr.size()>=2)\\n        {\\n            int min=Integer.MAX_VALUE;\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n                min=Math.min(arr.get(i+1)-arr.get(i),min);\\n            }\\n            arr1[0]=min;\\n            int max=arr.get(n-1)-arr.get(0);\\n            arr1[1]=max;\\n        }\\n        else \\n            return new int[]{-1,-1};\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588480,
                "title": "flying-monk",
                "content": "# Intuition\\n Traverse the linked list and try to search for the critical points using the given condition of critical points in the question by comparing current element its ajacent elements.\\n# Approach\\nStep 1: Use 3 pointers prev, curr, and nxt pointing to first 2 elements.(This will help you to check the critical point condtion).\\n    Step 2: return ans{-1, -1} if there are less than 3 nodes.(if any of prev, curr or nxt doesn\\'t exist).\\n    Step 3: Store the min-distance using last critical point and the the previous critical point just before the current critical point for each iteration if coidition hold. \\n\\n# Complexity\\n- Time complexity:\\n O(n) \\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1, -1};\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* nxt = curr->next;\\n        if(!prev || !curr || !nxt){\\n            return ans;\\n        }\\n        int i = 1;\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        while(nxt){\\n            bool isCP = ((curr->val < prev->val && curr->val < nxt->val) ||\\n                         (curr->val > prev->val && curr->val > nxt->val));\\n\\n            if(isCP && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCP ){\\n                minDist = min(minDist, i - lastCP);\\n                lastCP = i;\\n            }\\n            i++;\\n            nxt = nxt->next;\\n            prev = prev->next;\\n            curr = curr->next;\\n        }\\n\\n        if(firstCP == lastCP){\\n            return ans;\\n        }\\n        else{\\n            ans[0] = (minDist);\\n            ans[1] = (lastCP-firstCP);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {-1, -1};\\n        ListNode* prev = head;\\n        ListNode* curr = head->next;\\n        ListNode* nxt = curr->next;\\n        if(!prev || !curr || !nxt){\\n            return ans;\\n        }\\n        int i = 1;\\n        int firstCP = -1;\\n        int lastCP = -1;\\n        int minDist = INT_MAX;\\n        while(nxt){\\n            bool isCP = ((curr->val < prev->val && curr->val < nxt->val) ||\\n                         (curr->val > prev->val && curr->val > nxt->val));\\n\\n            if(isCP && firstCP == -1){\\n                firstCP = i;\\n                lastCP = i;\\n            }\\n            else if(isCP ){\\n                minDist = min(minDist, i - lastCP);\\n                lastCP = i;\\n            }\\n            i++;\\n            nxt = nxt->next;\\n            prev = prev->next;\\n            curr = curr->next;\\n        }\\n\\n        if(firstCP == lastCP){\\n            return ans;\\n        }\\n        else{\\n            ans[0] = (minDist);\\n            ans[1] = (lastCP-firstCP);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576220,
                "title": "java-5ms-90-and-clean-code",
                "content": "# Approach\\n1. Traverse the list and keep track of previous node while head.next != null, as well last first, last Critical point index\\n2. If you are on a critical point, store its position and determine the min/max between currentIndex and previousCritical point, currentIndex and firstCriticalPoint.\\n3. If firstCriticalPoint == lastCriticalPoint, then you have less than 2 critical points, so return [-1,-1]\\nElse return the answer array.   \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int prevVal = head.val;\\n        head = head.next;\\n        int[] answer = {Integer.MAX_VALUE, -1};\\n        int currentIndex = 2, firstCriticalPoint = -1, lastCriticalPoint = -1;\\n        while(head.next != null) {\\n            if ((prevVal < head.val && head.val > head.next.val) || (prevVal > head.val && head.val < head.next.val)) {\\n                if (firstCriticalPoint == -1) {\\n                    firstCriticalPoint = currentIndex;\\n                } else {\\n                    answer[0] = Math.min(answer[0], currentIndex - lastCriticalPoint);\\n                    answer[1] = Math.max(answer[1], currentIndex - firstCriticalPoint);\\n                }\\n                lastCriticalPoint = currentIndex;\\n            }\\n            currentIndex++;\\n            prevVal = head.val;\\n            head = head.next;\\n        }\\n        return firstCriticalPoint == lastCriticalPoint ? new int[]{-1,-1} : answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        int prevVal = head.val;\\n        head = head.next;\\n        int[] answer = {Integer.MAX_VALUE, -1};\\n        int currentIndex = 2, firstCriticalPoint = -1, lastCriticalPoint = -1;\\n        while(head.next != null) {\\n            if ((prevVal < head.val && head.val > head.next.val) || (prevVal > head.val && head.val < head.next.val)) {\\n                if (firstCriticalPoint == -1) {\\n                    firstCriticalPoint = currentIndex;\\n                } else {\\n                    answer[0] = Math.min(answer[0], currentIndex - lastCriticalPoint);\\n                    answer[1] = Math.max(answer[1], currentIndex - firstCriticalPoint);\\n                }\\n                lastCriticalPoint = currentIndex;\\n            }\\n            currentIndex++;\\n            prevVal = head.val;\\n            head = head.next;\\n        }\\n        return firstCriticalPoint == lastCriticalPoint ? new int[]{-1,-1} : answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562334,
                "title": "python3-clean-and-easy-solution",
                "content": "# Intuition\\n    please upvote if its useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(N log N)\\n- Space complexity:\\n    O(N)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        ans = []\\n        point = 0\\n        prev = head\\n        cur = head.next\\n\\n        while cur and cur.next:\\n            if prev.val < cur.val and cur.val > cur.next.val: \\n                <!-- ##_ get max value bettwen two values -->\\n                ans.append(point)\\n            elif prev.val > cur.val and cur.val < cur.next.val:\\n                <!-- ##_ get min value bettwen two values-->\\n                ans.append(point)\\n            point+=1\\n            prev = cur\\n            cur = cur.next\\n        \\n        ans.sort()\\n        min_dist = float(\"inf\")\\n        if len(ans) < 2:\\n            return [-1,-1]\\n        \\n        for i in range(len(ans)-1):\\n            min_dist = min(min_dist , ans[i+1] - ans[i])\\n        \\n        max_dist = ans[-1] - ans[0]\\n\\n        return [min_dist , max_dist]\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        ans = []\\n        point = 0\\n        prev = head\\n        cur = head.next\\n\\n        while cur and cur.next:\\n            if prev.val < cur.val and cur.val > cur.next.val: \\n                <!-- ##_ get max value bettwen two values -->\\n                ans.append(point)\\n            elif prev.val > cur.val and cur.val < cur.next.val:\\n                <!-- ##_ get min value bettwen two values-->\\n                ans.append(point)\\n            point+=1\\n            prev = cur\\n            cur = cur.next\\n        \\n        ans.sort()\\n        min_dist = float(\"inf\")\\n        if len(ans) < 2:\\n            return [-1,-1]\\n        \\n        for i in range(len(ans)-1):\\n            min_dist = min(min_dist , ans[i+1] - ans[i])\\n        \\n        max_dist = ans[-1] - ans[0]\\n\\n        return [min_dist , max_dist]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558154,
                "title": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    216 ms beats 95.56%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int last = -1, mid = -1, curr = -1;\\n        int f = 0, l = 0, mn = INT_MAX;\\n        int len = 0;\\n\\n        while(head) {\\n            int val = head -> val;\\n            last = mid;\\n            mid = curr;\\n            curr = val;\\n\\n            if(len >= 2 && ((mid > last && mid > curr) || (mid < last && mid < curr))) {\\n                if(f == 0) f = len, l = len;\\n                else {\\n                    mn = min(len - l, mn);\\n                    l = len;\\n                }\\n            }\\n\\n            head = head -> next;\\n            len++;\\n        }   \\n\\n        if(mn == INT_MAX) return {-1, -1};\\n\\n        return {mn, l - f};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        int last = -1, mid = -1, curr = -1;\\n        int f = 0, l = 0, mn = INT_MAX;\\n        int len = 0;\\n\\n        while(head) {\\n            int val = head -> val;\\n            last = mid;\\n            mid = curr;\\n            curr = val;\\n\\n            if(len >= 2 && ((mid > last && mid > curr) || (mid < last && mid < curr))) {\\n                if(f == 0) f = len, l = len;\\n                else {\\n                    mn = min(len - l, mn);\\n                    l = len;\\n                }\\n            }\\n\\n            head = head -> next;\\n            len++;\\n        }   \\n\\n        if(mn == INT_MAX) return {-1, -1};\\n\\n        return {mn, l - f};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553012,
                "title": "best-c-solution-with-0-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTraverse the linked list and find critical points by comparing nodes and store the index position of critical points into a vector.\\nafter that if vector is empty return {-1,-1} else\\nfind min difference between two adjacent element in vector and return \\nthat with the highest difference between first and last element of vector\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *ptr=head;\\n        ListNode *temp=head->next;\\n        vector<int> v;\\n        int c=1,d,m;\\n        while(temp->next!=NULL)\\n        {\\n            if(ptr->val>temp->val && temp->val<temp->next->val)\\n            {\\n                v.push_back(c);\\n                c++;\\n                 ptr=temp;\\n                temp=temp->next;\\n            }\\n            else if(ptr->val<temp->val && temp->val>temp->next->val)\\n            {\\n                v.push_back(c);\\n                c++;\\n                 ptr=temp;\\n                temp=temp->next;\\n            }\\n            else\\n            {\\n                c++;\\n                ptr=temp;\\n                temp=temp->next;\\n            }\\n        }\\n       \\n        if(v.size()==0 || v.size()==1)\\n        {\\n            return {-1,-1};\\n        }\\n        d=v.back();\\n        for(int i=0;i<v.size()-1;i++) \\n        {\\n             m=abs(v[i]-v[i+1]);\\n             d=min(d,m);\\n        }\\n        return {d,v.back()-v.front()};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ListNode *ptr=head;\\n        ListNode *temp=head->next;\\n        vector<int> v;\\n        int c=1,d,m;\\n        while(temp->next!=NULL)\\n        {\\n            if(ptr->val>temp->val && temp->val<temp->next->val)\\n            {\\n                v.push_back(c);\\n                c++;\\n                 ptr=temp;\\n                temp=temp->next;\\n            }\\n            else if(ptr->val<temp->val && temp->val>temp->next->val)\\n            {\\n                v.push_back(c);\\n                c++;\\n                 ptr=temp;\\n                temp=temp->next;\\n            }\\n            else\\n            {\\n                c++;\\n                ptr=temp;\\n                temp=temp->next;\\n            }\\n        }\\n       \\n        if(v.size()==0 || v.size()==1)\\n        {\\n            return {-1,-1};\\n        }\\n        d=v.back();\\n        for(int i=0;i<v.size()-1;i++) \\n        {\\n             m=abs(v[i]-v[i+1]);\\n             d=min(d,m);\\n        }\\n        return {d,v.back()-v.front()};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533121,
                "title": "c-solution",
                "content": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {INT_MAX, INT_MIN};\\n        ListNode* walker = head->next;\\n        int prev = head->val;\\n        \\n        int curr = 0, last_critical_point = -1, first_critical_point = -1;\\n        while (walker != NULL and walker->next != NULL) {\\n            int peak = walker->val > prev and walker->val > walker->next->val;\\n            int valley = walker->val < prev and walker->val < walker->next->val;\\n            if (peak or valley) {\\n                if (last_critical_point != -1) {\\n                    ans[0] = min(ans[0], curr - last_critical_point);\\n                }\\n                else {\\n                    first_critical_point = curr;\\n                }\\n                last_critical_point = curr;\\n            }\\n            curr++;\\n            prev = walker->val;\\n            walker = walker->next;\\n        }\\n        \\n        if (first_critical_point != last_critical_point) {\\n            ans[1] = last_critical_point - first_critical_point;\\n        }\\n        \\n        if (ans[0] == INT_MAX)\\n            ans[0] = -1;\\n        if (ans[1] == INT_MIN)\\n            ans[1] = -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans = {INT_MAX, INT_MIN};\\n        ListNode* walker = head->next;\\n        int prev = head->val;\\n        \\n        int curr = 0, last_critical_point = -1, first_critical_point = -1;\\n        while (walker != NULL and walker->next != NULL) {\\n            int peak = walker->val > prev and walker->val > walker->next->val;\\n            int valley = walker->val < prev and walker->val < walker->next->val;\\n            if (peak or valley) {\\n                if (last_critical_point != -1) {\\n                    ans[0] = min(ans[0], curr - last_critical_point);\\n                }\\n                else {\\n                    first_critical_point = curr;\\n                }\\n                last_critical_point = curr;\\n            }\\n            curr++;\\n            prev = walker->val;\\n            walker = walker->next;\\n        }\\n        \\n        if (first_critical_point != last_critical_point) {\\n            ans[1] = last_critical_point - first_critical_point;\\n        }\\n        \\n        if (ans[0] == INT_MAX)\\n            ans[0] = -1;\\n        if (ans[1] == INT_MIN)\\n            ans[1] = -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531744,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head==null || head.next==null || head.next.next==null)\\n            return new int[]{-1,-1}; \\n        ListNode curr= head.next,prev=head;\\n        int min=100001,max = 0,index=1,last=0,first=0;\\n        while(curr.next!=null){\\n            if((curr.val>prev.val && curr.val>curr.next.val) || (curr.val<prev.val && curr.val<curr.next.val)){\\n                    if(last==0){\\n                        first = index;\\n                        last = index;\\n                    }\\n                    else{\\n                    min = Math.min(min,index-last);\\n                    last = index;\\n                    }\\n                }\\n            prev = curr;\\n            curr = curr.next;\\n            index++;\\n        }\\n        if(first==0 || min==100001)\\n            return new int[]{-1,-1};\\n        return new int[]{min,last-first};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[] nodesBetweenCriticalPoints(ListNode head) {\\n        if(head==null || head.next==null || head.next.next==null)\\n            return new int[]{-1,-1}; \\n        ListNode curr= head.next,prev=head;\\n        int min=100001,max = 0,index=1,last=0,first=0;\\n        while(curr.next!=null){\\n            if((curr.val>prev.val && curr.val>curr.next.val) || (curr.val<prev.val && curr.val<curr.next.val)){\\n                    if(last==0){\\n                        first = index;\\n                        last = index;\\n                    }\\n                    else{\\n                    min = Math.min(min,index-last);\\n                    last = index;\\n                    }\\n                }\\n            prev = curr;\\n            curr = curr.next;\\n            index++;\\n        }\\n        if(first==0 || min==100001)\\n            return new int[]{-1,-1};\\n        return new int[]{min,last-first};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528176,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if (!head || !head->next || !head->next->next)\\n            return {-1, -1};\\n\\n        ListNode *prev = head;\\n        ListNode *curr = prev->next;\\n        ListNode *nxt = curr->next;\\n        vector<int> v;\\n        int cnt = 1;\\n\\n        while (nxt)\\n        {\\n            if ((curr->val > prev->val && curr->val > nxt->val) || (curr->val < prev->val && curr->val < nxt->val))\\n                v.push_back(cnt);\\n            cnt++;\\n            prev = curr;\\n            curr = nxt;\\n            nxt = nxt->next;\\n        }\\n\\n        if (v.size() < 2)\\n            return {-1, -1};\\n\\n        int mini = INT_MAX;\\n        for (int i = 1; i < v.size(); i++)\\n            mini = min(mini, v[i] - v[i - 1]);\\n\\n        return {mini, v.back() - v[0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        if (!head || !head->next || !head->next->next)\\n            return {-1, -1};\\n\\n        ListNode *prev = head;\\n        ListNode *curr = prev->next;\\n        ListNode *nxt = curr->next;\\n        vector<int> v;\\n        int cnt = 1;\\n\\n        while (nxt)\\n        {\\n            if ((curr->val > prev->val && curr->val > nxt->val) || (curr->val < prev->val && curr->val < nxt->val))\\n                v.push_back(cnt);\\n            cnt++;\\n            prev = curr;\\n            curr = nxt;\\n            nxt = nxt->next;\\n        }\\n\\n        if (v.size() < 2)\\n            return {-1, -1};\\n\\n        int mini = INT_MAX;\\n        for (int i = 1; i < v.size(); i++)\\n            mini = min(mini, v[i] - v[i - 1]);\\n\\n        return {mini, v.back() - v[0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517296,
                "title": "simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>res{-1,-1};\\n        ListNode*prev=head;\\n        ListNode*curr=head->next;\\n        ListNode*nxt=head->next->next;\\n        if(!prev || !curr || !nxt) return res;\\n\\n        int first_cp=-1;\\n        int last_cp=-1;\\n        int minDistance=INT_MAX;\\n        int i=1;\\n\\n        while(nxt!=NULL)\\n        {\\n            bool op= (prev->val>curr->val && nxt->val>curr->val) || (prev->val<curr->val && nxt->val<curr->val) ? true:false;\\n\\n            if(op && first_cp==-1)\\n            {\\n                first_cp=i;\\n                last_cp=i;\\n            }\\n            else if(op)\\n            {\\n                minDistance=min(minDistance,i-last_cp);\\n                last_cp=i;\\n            }\\n            i++;\\n\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n\\n        if(first_cp==last_cp) return res;\\n\\n        return {minDistance,last_cp-first_cp};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>res{-1,-1};\\n        ListNode*prev=head;\\n        ListNode*curr=head->next;\\n        ListNode*nxt=head->next->next;\\n        if(!prev || !curr || !nxt) return res;\\n\\n        int first_cp=-1;\\n        int last_cp=-1;\\n        int minDistance=INT_MAX;\\n        int i=1;\\n\\n        while(nxt!=NULL)\\n        {\\n            bool op= (prev->val>curr->val && nxt->val>curr->val) || (prev->val<curr->val && nxt->val<curr->val) ? true:false;\\n\\n            if(op && first_cp==-1)\\n            {\\n                first_cp=i;\\n                last_cp=i;\\n            }\\n            else if(op)\\n            {\\n                minDistance=min(minDistance,i-last_cp);\\n                last_cp=i;\\n            }\\n            i++;\\n\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n\\n        if(first_cp==last_cp) return res;\\n\\n        return {minDistance,last_cp-first_cp};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516423,
                "title": "o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>ans = {-1 , -1} ;// minDistance , maxDistance\\n       \\n       // previous Node\\n        ListNode* prev =head;\\n        if(!prev) return ans;\\n\\n       // Middle Node\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n\\n      // Aggae Wali Node\\n      ListNode* nxt = head->next->next;\\n      if(!nxt) return ans;\\n\\n      int firstCP = -1;\\n      int lastCP = -1;\\n      int minDistance = INT_MAX;\\n      int i = 1;\\n\\n      // Iterarte the loop\\n      while(nxt != NULL){\\n\\n         // check current value is less then or greater then previous or next node.\\n          bool isCP = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                        (curr->val < prev->val && curr->val < nxt->val))\\n                        ? true : false;\\n\\n         if(isCP && firstCP == -1){\\n             firstCP = i;\\n             lastCP = i;\\n\\n         }\\n         else if(isCP){\\n             minDistance = min(minDistance , i-lastCP);\\n             lastCP = i;\\n         }\\n         i++;\\n\\n         prev = prev->next;\\n         curr = curr->next;\\n         nxt = nxt->next; \\n\\n\\n      }\\n      if(lastCP == firstCP){\\n          // only 1 cp found;\\n          return ans;\\n      }\\n      else{\\n          ans[0] = minDistance;\\n          ans[1] = lastCP -firstCP;\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int>ans = {-1 , -1} ;// minDistance , maxDistance\\n       \\n       // previous Node\\n        ListNode* prev =head;\\n        if(!prev) return ans;\\n\\n       // Middle Node\\n        ListNode* curr = head->next;\\n        if(!curr) return ans;\\n\\n      // Aggae Wali Node\\n      ListNode* nxt = head->next->next;\\n      if(!nxt) return ans;\\n\\n      int firstCP = -1;\\n      int lastCP = -1;\\n      int minDistance = INT_MAX;\\n      int i = 1;\\n\\n      // Iterarte the loop\\n      while(nxt != NULL){\\n\\n         // check current value is less then or greater then previous or next node.\\n          bool isCP = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                        (curr->val < prev->val && curr->val < nxt->val))\\n                        ? true : false;\\n\\n         if(isCP && firstCP == -1){\\n             firstCP = i;\\n             lastCP = i;\\n\\n         }\\n         else if(isCP){\\n             minDistance = min(minDistance , i-lastCP);\\n             lastCP = i;\\n         }\\n         i++;\\n\\n         prev = prev->next;\\n         curr = curr->next;\\n         nxt = nxt->next; \\n\\n\\n      }\\n      if(lastCP == firstCP){\\n          // only 1 cp found;\\n          return ans;\\n      }\\n      else{\\n          ans[0] = minDistance;\\n          ans[1] = lastCP -firstCP;\\n      }\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505901,
                "title": "beats-83-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number[]}\\n */\\nvar nodesBetweenCriticalPoints = function(head) {\\n    const localMs = [];\\n\\n    let mid = 0;\\n    let prev = 0;\\n    let i = 1;\\n\\n    while (head) {\\n        i ++;\\n        if (!mid || !prev){\\n            [mid, prev] = [head.val, mid];  \\n            head = head.next;\\n            continue;\\n        }\\n\\n        if (mid > prev && mid > head.val || mid < prev && mid < head.val) {\\n            localMs.push(i - 2);\\n        }\\n\\n        [mid, prev] = [head.val, mid];\\n        head = head.next;\\n    }\\n\\n    if (localMs.length < 2) return [-1, -1];\\n    if (localMs.length === 2) return [localMs[1] - localMs[0], localMs[1] - localMs[0]];\\n\\n    let min = localMs[1] - localMs[0];\\n\\n    for (let i = 1; i < localMs.length; i ++) {\\n        min = Math.min(localMs[i] - localMs[i - 1], min);\\n        if (min === 1) break;\\n    }\\n\\n    return [min, localMs[localMs.length - 1] - localMs[0]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number[]}\\n */\\nvar nodesBetweenCriticalPoints = function(head) {\\n    const localMs = [];\\n\\n    let mid = 0;\\n    let prev = 0;\\n    let i = 1;\\n\\n    while (head) {\\n        i ++;\\n        if (!mid || !prev){\\n            [mid, prev] = [head.val, mid];  \\n            head = head.next;\\n            continue;\\n        }\\n\\n        if (mid > prev && mid > head.val || mid < prev && mid < head.val) {\\n            localMs.push(i - 2);\\n        }\\n\\n        [mid, prev] = [head.val, mid];\\n        head = head.next;\\n    }\\n\\n    if (localMs.length < 2) return [-1, -1];\\n    if (localMs.length === 2) return [localMs[1] - localMs[0], localMs[1] - localMs[0]];\\n\\n    let min = localMs[1] - localMs[0];\\n\\n    for (let i = 1; i < localMs.length; i ++) {\\n        min = Math.min(localMs[i] - localMs[i - 1], min);\\n        if (min === 1) break;\\n    }\\n\\n    return [min, localMs[localMs.length - 1] - localMs[0]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501949,
                "title": "solved-just-by-the-help-of-three-pointers",
                "content": "# Intuition\\nThe problem asks to find the minimum and maximum distance between any two consecutive critical points in a linked list. A critical point is defined as a node which is greater than its adjacent nodes or smaller than its adjacent nodes.\\n\\nOne approach to solve this problem is to traverse the linked list and identify the critical points, and store the indices of these points in a list. Then, we can sort the list of indices and compute the minimum and maximum distance between any two consecutive points.\\n\\n# Approach\\nTraverse the linked list and identify the critical points (i.e., the local maxima and minima). A point is considered critical if it is greater than the adjacent points on both sides or less than the adjacent points on both sides.\\nStore the indices of these critical points in a list.\\nSort the list of indices in non-decreasing order.\\nCompute the minimum and maximum distance between any two consecutive points in the sorted list of indices.\\nReturn the computed minimum and maximum distances.\\n# Complexity\\n**Time complexity:** O(nlogn) (due to sorting) where n is the number of nodes in the linked list.\\n**Space complexity:** O(n) for storing the indices of the critical points in a list.\\n\\n# Code\\n```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if not head or not head.next:\\n            return [-1, -1]\\n        \\n        prev = head\\n        head = head.next\\n        i = 1\\n        l = []\\n        \\n        while head and head.next is not None:\\n            if prev.val < head.val and head.val > head.next.val:\\n                l.append(i)\\n            elif prev.val > head.val and head.val < head.next.val:\\n                l.append(i)\\n            i += 1\\n            prev=head\\n            head = head.next\\n        \\n        if len(l) < 2:\\n            return [-1,-1]\\n        l=sorted(l)\\n        diff = 10**20\\n        n=len(l)\\n        for i in range(n-1):\\n            if l[i+1] - l[i] < diff:\\n                diff = l[i+1] - l[i]\\n        mindist = diff\\n        maxdist = l[-1]-l[0]\\n        \\n        return [mindist, maxdist]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        if not head or not head.next:\\n            return [-1, -1]\\n        \\n        prev = head\\n        head = head.next\\n        i = 1\\n        l = []\\n        \\n        while head and head.next is not None:\\n            if prev.val < head.val and head.val > head.next.val:\\n                l.append(i)\\n            elif prev.val > head.val and head.val < head.next.val:\\n                l.append(i)\\n            i += 1\\n            prev=head\\n            head = head.next\\n        \\n        if len(l) < 2:\\n            return [-1,-1]\\n        l=sorted(l)\\n        diff = 10**20\\n        n=len(l)\\n        for i in range(n-1):\\n            if l[i+1] - l[i] < diff:\\n                diff = l[i+1] - l[i]\\n        mindist = diff\\n        maxdist = l[-1]-l[0]\\n        \\n        return [mindist, maxdist]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489395,
                "title": "easy-method-basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1);\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n            vector<int>ans = {-1,-1};\\n        ListNode *prev = head;\\n        if(!prev){\\n            return ans;\\n        }\\n        ListNode *curr = head->next;\\n        if(!curr){\\n            return ans;\\n        }\\n        ListNode *nxt = head->next->next;\\n        if(!nxt){\\n            return ans;\\n        }\\n\\n        int firstCp = -1;\\n        int lastCp = -1;\\n        int minDis = INT_MAX;\\n        int i= 1;\\n        while(nxt){\\n            bool isCp = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                         (curr->val < prev->val && curr->val < nxt->val)) ? true : false ;\\n\\n\\n            if( isCp && firstCp == -1){\\n                firstCp = i;\\n                lastCp = i;\\n            }else if(isCp){\\n                minDis = min(minDis,i-lastCp);\\n                lastCp = i;\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n\\n        if(lastCp == firstCp){\\n            return ans;\\n        }else{\\n            ans[0] = minDis;\\n            ans[1] = lastCp - firstCp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n            vector<int>ans = {-1,-1};\\n        ListNode *prev = head;\\n        if(!prev){\\n            return ans;\\n        }\\n        ListNode *curr = head->next;\\n        if(!curr){\\n            return ans;\\n        }\\n        ListNode *nxt = head->next->next;\\n        if(!nxt){\\n            return ans;\\n        }\\n\\n        int firstCp = -1;\\n        int lastCp = -1;\\n        int minDis = INT_MAX;\\n        int i= 1;\\n        while(nxt){\\n            bool isCp = ((curr->val > prev->val && curr->val > nxt->val) ||\\n                         (curr->val < prev->val && curr->val < nxt->val)) ? true : false ;\\n\\n\\n            if( isCp && firstCp == -1){\\n                firstCp = i;\\n                lastCp = i;\\n            }else if(isCp){\\n                minDis = min(minDis,i-lastCp);\\n                lastCp = i;\\n            }\\n            i++;\\n            prev = prev->next;\\n            curr = curr->next;\\n            nxt = nxt->next;\\n        }\\n\\n        if(lastCp == firstCp){\\n            return ans;\\n        }else{\\n            ans[0] = minDis;\\n            ans[1] = lastCp - firstCp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485776,
                "title": "c-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans{-1,-1};\\n        ListNode* prev=head;\\n        if(!prev)\\n        {\\n            return ans;\\n        }\\n        ListNode* curr=head->next;\\n        if(!curr)\\n        {\\n            return ans;\\n        }\\n        ListNode* nxt=head->next->next;\\n        if(!nxt)\\n        {\\n            return ans;\\n        }\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDist=INT_MAX;\\n        int i=1;\\n        while(nxt)\\n        {\\n            bool isCP=((curr->val<prev->val && curr->val<nxt->val) || \\n            (curr->val>prev->val && curr->val>nxt->val))?true:false;\\n            if(isCP && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n            }\\n            else if(isCP)\\n            {\\n                minDist=min(minDist,i-lastCP);\\n                lastCP=i;\\n            }\\n            i++;\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n        if(firstCP==lastCP)\\n        {\\n            return ans;\\n        }\\n        else\\n        {\\n            ans[0]=minDist;\\n            ans[1]=lastCP-firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans{-1,-1};\\n        ListNode* prev=head;\\n        if(!prev)\\n        {\\n            return ans;\\n        }\\n        ListNode* curr=head->next;\\n        if(!curr)\\n        {\\n            return ans;\\n        }\\n        ListNode* nxt=head->next->next;\\n        if(!nxt)\\n        {\\n            return ans;\\n        }\\n        int firstCP=-1;\\n        int lastCP=-1;\\n        int minDist=INT_MAX;\\n        int i=1;\\n        while(nxt)\\n        {\\n            bool isCP=((curr->val<prev->val && curr->val<nxt->val) || \\n            (curr->val>prev->val && curr->val>nxt->val))?true:false;\\n            if(isCP && firstCP==-1)\\n            {\\n                firstCP=i;\\n                lastCP=i;\\n            }\\n            else if(isCP)\\n            {\\n                minDist=min(minDist,i-lastCP);\\n                lastCP=i;\\n            }\\n            i++;\\n            prev=prev->next;\\n            curr=curr->next;\\n            nxt=nxt->next;\\n        }\\n        if(firstCP==lastCP)\\n        {\\n            return ans;\\n        }\\n        else\\n        {\\n            ans[0]=minDist;\\n            ans[1]=lastCP-firstCP;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485214,
                "title": "very-easy-c-solution",
                "content": "#define node ListNode\\n#define pb push_back\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> ans(2);\\n        vector<int> cpoints;\\n        vector<int> clength;\\n        \\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n        {\\n            ans[0]=-1;\\n            ans[1]=-1;\\n            \\n            return ans;\\n        }\\n        else\\n        {\\n            //If length is valid\\n            node *p=head;\\n            node *c=head->next;\\n            node *n=c->next;\\n            \\n            int len=2;\\n            \\n            while(n!=NULL)\\n            {\\n                if((c->val > p->val and c->val>n->val) || (c->val < p->val and c->val < n->val))\\n                {\\n                    cpoints.pb(c->val);\\n                    clength.pb(len);\\n                }\\n                \\n                len++;\\n                p=c;\\n                c=n;\\n                n=n->next;\\n            }\\n        }\\n        \\n        if(cpoints.size()<2)\\n        {\\n            ans[0]=-1;\\n            ans[1]=-1;\\n            \\n            return ans;\\n        }\\n        \\n        //Mininum Len\\n        \\n        int min_len=INT_MAX;\\n        int i=0,j=i+1;\\n        while(i<cpoints.size()-1)\\n        {\\n            min_len=min(min_len,abs(clength[i]-clength[j]));\\n            i++,j++;\\n        }\\n        ans[0]=min_len;\\n        \\n        //Maximum Len\\n        \\n        ans[1]=abs(clength[0]-clength[clength.size()-1]);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> ans(2);\\n        vector<int> cpoints;\\n        vector<int> clength;\\n        \\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n        {\\n            ans[0]=-1;\\n            ans[1]=-1;\\n            \\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3483921,
                "title": "python3-convert-to-list",
                "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        temp=head\\n        l=[]\\n        while temp:\\n            l.append(temp.val)\\n            temp=temp.next\\n        \\n        n=len(l)\\n        critical=[]\\n        \\n        for i in range(1,n-1):\\n            if l[i]>l[i-1] and l[i]>l[i+1] or l[i]<l[i-1] and l[i]<l[i+1]:\\n                critical.append(i)\\n        \\n                \\n                \\n        n=len(critical)\\n        if n<=1:\\n            return [-1,-1]\\n        \\n        \\n        mn=min(critical[i+1]-critical[i] for i in range(n-1))\\n        mx=critical[-1]-critical[0]\\n        \\n        return [mn,mx]\\n        \\n        \\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        temp=head\\n        l=[]\\n        while temp:\\n            l.append(temp.val)\\n            temp=temp.next\\n        \\n        n=len(l)\\n        critical=[]\\n        \\n        for i in range(1,n-1):\\n            if l[i]>l[i-1] and l[i]>l[i+1] or l[i]<l[i-1] and l[i]<l[i+1]:\\n                critical.append(i)\\n        \\n                \\n                \\n        n=len(critical)\\n        if n<=1:\\n            return [-1,-1]\\n        \\n        \\n        mn=min(critical[i+1]-critical[i] for i in range(n-1))\\n        mx=critical[-1]-critical[0]\\n        \\n        return [mn,mx]\\n        \\n        \\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1763828,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "the_conqueror07",
                        "content": "vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> v;\\n        if(head!=NULL || head->next!=NULL || head->next->next!=NULL)\\n        return v={-1,-1};\\n\\n        int index=1;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* next = head->next->next;\\n        while(curr!=NULL && curr->next!=NULL)\\n        {\\n            next=curr->next;\\n\\n            if(curr->val > prev->val && curr->val > next->val)\\n            v.push_back(index);\\n            \\n            if(curr->val < prev->val && curr->val<next->val)\\n            v.push_back(index);\\n            \\n            prev=curr;\\n            curr=next;\\n            index++;\\n        }\\n        if(v.size()<2)\\n        return v={-1,-1};\\n\\n        if(v.size()==2)\\n        return v={v[1]-v[0],v[1]-v[0]};\\n\\n        vector<int> v1;\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            mini=min(mini,v[i+1]-v[i]);\\n        }\\n\\n        int t=v[v.size()-1]-v[0];\\n        v={mini,t};\\n\\n        return v;\\n    }  \\n\\nwhy is my code always returning -1,-1"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is my Straight Forward Approach:-**\\n\\n- Traverse the linked list and add each node\\'s value to an ArrayList.\\n- Iterate over the ArrayList from the second element to the second last element.\\n- Check if the current element is a critical point by comparing it with its adjacent elements.\\n- If the current element is a critical point and there is a previous critical point, calculate the distance between them and update the minimum distance and maximum distance.\\n- Update the index of the first critical point found, if it has not been set yet.\\n- Return the minimum distance and maximum distance. If no critical points were found, return [-1, -1]."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solutions/3516829/easy-to-understand-solution-with-a-straight-forward-approach/"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "My code worked very slow. Runtime 11.4%\\nCan someone recommend to me a book or YouTube channel for learning Algarithm."
                    }
                ]
            },
            {
                "id": 1984432,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "the_conqueror07",
                        "content": "vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> v;\\n        if(head!=NULL || head->next!=NULL || head->next->next!=NULL)\\n        return v={-1,-1};\\n\\n        int index=1;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* next = head->next->next;\\n        while(curr!=NULL && curr->next!=NULL)\\n        {\\n            next=curr->next;\\n\\n            if(curr->val > prev->val && curr->val > next->val)\\n            v.push_back(index);\\n            \\n            if(curr->val < prev->val && curr->val<next->val)\\n            v.push_back(index);\\n            \\n            prev=curr;\\n            curr=next;\\n            index++;\\n        }\\n        if(v.size()<2)\\n        return v={-1,-1};\\n\\n        if(v.size()==2)\\n        return v={v[1]-v[0],v[1]-v[0]};\\n\\n        vector<int> v1;\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            mini=min(mini,v[i+1]-v[i]);\\n        }\\n\\n        int t=v[v.size()-1]-v[0];\\n        v={mini,t};\\n\\n        return v;\\n    }  \\n\\nwhy is my code always returning -1,-1"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is my Straight Forward Approach:-**\\n\\n- Traverse the linked list and add each node\\'s value to an ArrayList.\\n- Iterate over the ArrayList from the second element to the second last element.\\n- Check if the current element is a critical point by comparing it with its adjacent elements.\\n- If the current element is a critical point and there is a previous critical point, calculate the distance between them and update the minimum distance and maximum distance.\\n- Update the index of the first critical point found, if it has not been set yet.\\n- Return the minimum distance and maximum distance. If no critical points were found, return [-1, -1]."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solutions/3516829/easy-to-understand-solution-with-a-straight-forward-approach/"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "My code worked very slow. Runtime 11.4%\\nCan someone recommend to me a book or YouTube channel for learning Algarithm."
                    }
                ]
            },
            {
                "id": 1891322,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "the_conqueror07",
                        "content": "vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> v;\\n        if(head!=NULL || head->next!=NULL || head->next->next!=NULL)\\n        return v={-1,-1};\\n\\n        int index=1;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* next = head->next->next;\\n        while(curr!=NULL && curr->next!=NULL)\\n        {\\n            next=curr->next;\\n\\n            if(curr->val > prev->val && curr->val > next->val)\\n            v.push_back(index);\\n            \\n            if(curr->val < prev->val && curr->val<next->val)\\n            v.push_back(index);\\n            \\n            prev=curr;\\n            curr=next;\\n            index++;\\n        }\\n        if(v.size()<2)\\n        return v={-1,-1};\\n\\n        if(v.size()==2)\\n        return v={v[1]-v[0],v[1]-v[0]};\\n\\n        vector<int> v1;\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            mini=min(mini,v[i+1]-v[i]);\\n        }\\n\\n        int t=v[v.size()-1]-v[0];\\n        v={mini,t};\\n\\n        return v;\\n    }  \\n\\nwhy is my code always returning -1,-1"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is my Straight Forward Approach:-**\\n\\n- Traverse the linked list and add each node\\'s value to an ArrayList.\\n- Iterate over the ArrayList from the second element to the second last element.\\n- Check if the current element is a critical point by comparing it with its adjacent elements.\\n- If the current element is a critical point and there is a previous critical point, calculate the distance between them and update the minimum distance and maximum distance.\\n- Update the index of the first critical point found, if it has not been set yet.\\n- Return the minimum distance and maximum distance. If no critical points were found, return [-1, -1]."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solutions/3516829/easy-to-understand-solution-with-a-straight-forward-approach/"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "My code worked very slow. Runtime 11.4%\\nCan someone recommend to me a book or YouTube channel for learning Algarithm."
                    }
                ]
            },
            {
                "id": 1766994,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "the_conqueror07",
                        "content": "vector<int> nodesBetweenCriticalPoints(ListNode* head) \\n    {\\n        vector<int> v;\\n        if(head!=NULL || head->next!=NULL || head->next->next!=NULL)\\n        return v={-1,-1};\\n\\n        int index=1;\\n        ListNode* prev=head;\\n        ListNode* curr=head->next;\\n        ListNode* next = head->next->next;\\n        while(curr!=NULL && curr->next!=NULL)\\n        {\\n            next=curr->next;\\n\\n            if(curr->val > prev->val && curr->val > next->val)\\n            v.push_back(index);\\n            \\n            if(curr->val < prev->val && curr->val<next->val)\\n            v.push_back(index);\\n            \\n            prev=curr;\\n            curr=next;\\n            index++;\\n        }\\n        if(v.size()<2)\\n        return v={-1,-1};\\n\\n        if(v.size()==2)\\n        return v={v[1]-v[0],v[1]-v[0]};\\n\\n        vector<int> v1;\\n        int mini=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            mini=min(mini,v[i+1]-v[i]);\\n        }\\n\\n        int t=v[v.size()-1]-v[0];\\n        v={mini,t};\\n\\n        return v;\\n    }  \\n\\nwhy is my code always returning -1,-1"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is my Straight Forward Approach:-**\\n\\n- Traverse the linked list and add each node\\'s value to an ArrayList.\\n- Iterate over the ArrayList from the second element to the second last element.\\n- Check if the current element is a critical point by comparing it with its adjacent elements.\\n- If the current element is a critical point and there is a previous critical point, calculate the distance between them and update the minimum distance and maximum distance.\\n- Update the index of the first critical point found, if it has not been set yet.\\n- Return the minimum distance and maximum distance. If no critical points were found, return [-1, -1]."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link :-)***\\nhttps://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solutions/3516829/easy-to-understand-solution-with-a-straight-forward-approach/"
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "My code worked very slow. Runtime 11.4%\\nCan someone recommend to me a book or YouTube channel for learning Algarithm."
                    }
                ]
            }
        ]
    }
]