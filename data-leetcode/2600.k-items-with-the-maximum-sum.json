[
    {
        "title": "K Items With the Maximum Sum",
        "question_content": "There is a bag that consists of items, each item&nbsp;has a number 1, 0, or -1 written on it.\nYou are given four non-negative integers numOnes, numZeros, numNegOnes, and k.\nThe bag initially contains:\n\n\tnumOnes items with 1s written on them.\n\tnumZeroes items with 0s written on them.\n\tnumNegOnes items with -1s written on them.\n\nWe want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.\n&nbsp;\nExample 1:\n\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\nOutput: 2\nExplanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\nExample 2:\n\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\nOutput: 3\nExplanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum.\n\n&nbsp;\nConstraints:\n\n\t0 <= numOnes, numZeros, numNegOnes <= 50\n\t0 <= k <= numOnes + numZeros + numNegOnes",
        "solutions": [
            {
                "id": 3342004,
                "title": "one-liner",
                "content": "We do not even need to use `numNegOnes`.\\n\\nIf `numOnes + numZeros` is not enough, we will have to pick `k - numZeros - numOnes` negatives.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - max(0, k - numZeros - numOnes)\\n```\\n**C++**\\n```cpp\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    return min(k, numOnes) - max(0, k - numOnes - numZeros);\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - max(0, k - numZeros - numOnes)\\n```\n```cpp\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    return min(k, numOnes) - max(0, k - numOnes - numZeros);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342008,
                "title": "conditions-very-simple-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes) return k;\\n        if(k <= numOnes + numZeros) return numOnes;\\n        return numOnes - (k - numOnes - numZeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes) return k;\\n        if(k <= numOnes + numZeros) return numOnes;\\n        return numOnes - (k - numOnes - numZeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342084,
                "title": "100-faster-beginner-friendly-c-greedy",
                "content": "To get the maximum sum possible we first need to select number of 1\\'s and then if k is still more then count of 1\\'s then we need to select some 0\\'s which will add 0 to our sum, after selecting 1\\'s and 0\\'s if k is still positive then we need to select -1\\'s which will reduce our sum.\\n\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n            int total=0;\\n\\t\\t\\t\\n            int select=min(numOnes,k);       //selecting ones \\n\\t\\t\\ttotal+=select;                            //adding to sum\\n            k-=select;                                  // reducing k\\n        \\n            select=min(numZeros,k);          // selecting 0\\'s if k is non zero otherwise select will be 0\\n            k-=select;                                 // reducing k if k is non zero\\n        \\n            select=min(numNegOnes,k);  // selecting -1\\'s if k is non zero otherwise select will be 0\\n            total-=select;                          //reducing the score by select because we selected select no of -1\\'s in case of k =0 we will reduce 0\\n        \\n            return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n            int total=0;\\n\\t\\t\\t\\n            int select=min(numOnes,k);       //selecting ones \\n\\t\\t\\ttotal+=select;                            //adding to sum\\n            k-=select;                                  // reducing k\\n        \\n            select=min(numZeros,k);          // selecting 0\\'s if k is non zero otherwise select will be 0\\n            k-=select;                                 // reducing k if k is non zero\\n        \\n            select=min(numNegOnes,k);  // selecting -1\\'s if k is non zero otherwise select will be 0\\n            total-=select;                          //reducing the score by select because we selected select no of -1\\'s in case of k =0 we will reduce 0\\n        \\n            return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344630,
                "title": "java-100-faster-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/45a833f9-09b5-4cee-a639-e243c8e3cff6_1679848667.9953527.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        \\n        int max = 0; // the maximum sum\\n        \\n        // while we still need to select k numbers\\n        while(k > 0){\\n            \\n            // if we have at least one 1 left, add it to the sum\\n            if(numOnes > 0){\\n                numOnes--;\\n                max++;\\n                k--;\\n            }\\n            // if we have at least one 0 left, skip it\\n            else if(numZeros > 0){\\n                numZeros--;\\n                k--;\\n            }\\n            // if we have at least one -1 left, add it to the sum\\n            else{\\n                numNegOnes--;\\n                max--;\\n                k--;\\n            }   \\n        } \\n        // if we did not select k numbers, return the maximum sum anyway\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        \\n        int max = 0; // the maximum sum\\n        \\n        // while we still need to select k numbers\\n        while(k > 0){\\n            \\n            // if we have at least one 1 left, add it to the sum\\n            if(numOnes > 0){\\n                numOnes--;\\n                max++;\\n                k--;\\n            }\\n            // if we have at least one 0 left, skip it\\n            else if(numZeros > 0){\\n                numZeros--;\\n                k--;\\n            }\\n            // if we have at least one -1 left, add it to the sum\\n            else{\\n                numNegOnes--;\\n                max--;\\n                k--;\\n            }   \\n        } \\n        // if we did not select k numbers, return the maximum sum anyway\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342171,
                "title": "easy-c-if-else-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust add min(k,numOnes) and then check after using numZeros k is left or not.Ans can be maximum as k and minimum as -k.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise ans as 0, check if(numOnes>0 && k>0) then add ans+=min(min(numOnes,k)), and reduce k by ans.\\n2. if (k>0) then reduce k by min(k,numZeros);\\n3. if(k>0) then substract ans by min(numNegOnes,k) and then at then end return the ans\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        if(numOnes>0 && k>0)\\n        {\\n            ans+=min(numOnes,k);\\n            k-=ans;\\n        }\\n        if(k>0 && numZeros>0)\\n        {\\n            k-=min(k,numZeros);\\n        }\\n        if(k>0 && numNegOnes>0)\\n        {\\n            ans-=min(numNegOnes,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        if(numOnes>0 && k>0)\\n        {\\n            ans+=min(numOnes,k);\\n            k-=ans;\\n        }\\n        if(k>0 && numZeros>0)\\n        {\\n            k-=min(k,numZeros);\\n        }\\n        if(k>0 && numNegOnes>0)\\n        {\\n            ans-=min(numNegOnes,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342114,
                "title": "one-line-solution-by-trippy-ek-line-ka-jugad",
                "content": "# Intuition\\nVERY EASY NOTHING TO THING\\n\\n# Approach\\nSS\\nJUST SMILE AND SOLVE\\n\\n# Complexity\\nNOTHING COMPLEX;\\n\\n# PLEASE UPVOTE\\n\\n# Code\\n```\\n//JAVA\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);\\n        \\n    }\\n}\\n```\\n# Code\\n```\\n// C++\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    return min(k, numOnes) - max(0, k - numOnes - numZeros);\\n}\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "```\\n//JAVA\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342618,
                "title": "c-o-1-time-space-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst preference will be given to +1 bags.\\nSecond preference will be given to 0 bags.\\nThird preference will be given to -1 bags.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If k is less than `numOnes` return k.\\n- If k is less than `numOnes` + `numZeroes` return `numOnes`.\\n- Else return `numOnes` - `(k - (numOnes+numZeroes))`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Time Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k) return k;\\n        if(numOnes + numZeros >=k) return numOnes;\\n        return numOnes - (k-numOnes-numZeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k) return k;\\n        if(numOnes + numZeros >=k) return numOnes;\\n        return numOnes - (k-numOnes-numZeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341881,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k)\\n        {\\n            return k;\\n        }\\n        int result=Math.min(numOnes,k);\\n        k-=numOnes+numZeros;\\n        if(k<0) \\n        {\\n            return result;\\n        }\\n        result-=Math.min(numNegOnes,k);\\n        return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k)\\n        {\\n            return k;\\n        }\\n        int result=Math.min(numOnes,k);\\n        k-=numOnes+numZeros;\\n        if(k<0) \\n        {\\n            return result;\\n        }\\n        result-=Math.min(numNegOnes,k);\\n        return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342183,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes >= k)\\n            return k;\\n        if(numOnes + numZeros >= k)\\n            return numOnes;\\n        k-=numZeros;\\n        k-=numOnes;\\n        return numOnes-k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes >= k)\\n            return k;\\n        if(numOnes + numZeros >= k)\\n            return numOnes;\\n        k-=numZeros;\\n        k-=numOnes;\\n        return numOnes-k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501364,
                "title": "c-math-time-space-o-1",
                "content": "if no of coins we want is less than no of 1\\'s coins than we must return no of coins that we want.\\n\\nif no of coins we want is greater no of 1\\'s and less than sum of no of 1\\'s ans 0\\'s than we return no of a that maximum sum.\\n\\nif no of coins we want is greater than sum of no of 1\\'s and 0\\'s than we return no of 1\\'s minus(-) no of -1\\'s that we extra add in our ans.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int a, int b, int c, int k) {\\n        if(a>=k)return k;\\n        if(a+b>=k) return a;\\n        return a-(k-a-b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int a, int b, int c, int k) {\\n        if(a>=k)return k;\\n        if(a+b>=k) return a;\\n        return a-(k-a-b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348476,
                "title": "easiest-o-1-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes)\\n            return k;\\n        else if (k <= numZeros + numOnes)\\n            return numOnes;    \\n        return numOnes - (k - (numZeros + numOnes));      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes)\\n            return k;\\n        else if (k <= numZeros + numOnes)\\n            return numOnes;    \\n        return numOnes - (k - (numZeros + numOnes));      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344897,
                "title": "python-3-1-line-t-m-93-93",
                "content": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n\\n        return k if k<= numOnes else numOnes - max(0, k-numOnes-numZeros)\\n```\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n\\n        return k if k<= numOnes else numOnes - max(0, k-numOnes-numZeros)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342453,
                "title": "3line-c-easy-to-understnad",
                "content": "````\\n    int kItemsWithMaximumSum(int a, int b, int c, int k) {\\n        if(a>=k){ return k;}\\n\\t\\telse if(a+b>=k){return a;}\\n\\t\\treturn a-(k-a-b);\\n    }\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "````\\n    int kItemsWithMaximumSum(int a, int b, int c, int k) {\\n        if(a>=k){ return k;}\\n\\t\\telse if(a+b>=k){return a;}\\n\\t\\treturn a-(k-a-b);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341902,
                "title": "easiest-solution-c-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        else{\\n        int sum = numOnes;\\n        k-=numOnes;\\n        if(k<=numZeros){\\n            return sum;\\n        }else{\\n            k-=numZeros;\\n            if(k<=numNegOnes){\\n                return sum-k;\\n            }\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        else{\\n        int sum = numOnes;\\n        k-=numOnes;\\n        if(k<=numZeros){\\n            return sum;\\n        }else{\\n            k-=numZeros;\\n            if(k<=numNegOnes){\\n                return sum-k;\\n            }\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385384,
                "title": "python-99-faster-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if numOnes > k:\\n            return k\\n        rem = k - numOnes - numZeros\\n        if rem <= 0:\\n            return numOnes\\n        return numOnes - rem\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if numOnes > k:\\n            return k\\n        rem = k - numOnes - numZeros\\n        if rem <= 0:\\n            return numOnes\\n        return numOnes - rem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342249,
                "title": "1-and-2-liner-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        arr = [1] * numOnes + [0] * numZeros + [-1] * numNegOnes\\n        return sum(arr[:k])\\n```\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes, 2 * numOnes + numZeros - k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        arr = [1] * numOnes + [0] * numZeros + [-1] * numNegOnes\\n        return sum(arr[:k])\\n```\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes, 2 * numOnes + numZeros - k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341973,
                "title": "short-clean-o-1-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        ans = Math.min(numOnes,k);\\n        k -= numOnes + numZeros;\\n        if( k < 0)  return ans;\\n        ans -= Math.min(numNegOnes,k);\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        ans = Math.min(numOnes,k);\\n        k -= numOnes + numZeros;\\n        if( k < 0)  return ans;\\n        ans -= Math.min(numNegOnes,k);\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341929,
                "title": "java-simple-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    var ans = 0;\\n    ans += Math.min(numOnes, k);\\n    k -= ans;\\n    \\n    if (k == 0) return ans;\\n    \\n    k -= Math.min(numZeros, k);\\n    \\n    if (k == 0) return ans;\\n    \\n    ans -= Math.min(numNegOnes, k);\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    var ans = 0;\\n    ans += Math.min(numOnes, k);\\n    k -= ans;\\n    \\n    if (k == 0) return ans;\\n    \\n    k -= Math.min(numZeros, k);\\n    \\n    if (k == 0) return ans;\\n    \\n    ans -= Math.min(numNegOnes, k);\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043062,
                "title": "k-items-with-the-maximum-sum-o-1-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(1)\\nSpace Complexity: O(1)\\n\\n```\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    if (k <= numOnes) {\\n        return k;\\n    }\\n    let sum = 0;\\n    if (numOnes) {\\n        sum += numOnes;\\n        k -= numOnes;\\n    }\\n    if (k > 0 && numZeros) {\\n        k -= numZeros;\\n    }\\n\\n    if (k > 0 && numNegOnes) {\\n        sum += k * -1;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    if (k <= numOnes) {\\n        return k;\\n    }\\n    let sum = 0;\\n    if (numOnes) {\\n        sum += numOnes;\\n        k -= numOnes;\\n    }\\n    if (k > 0 && numZeros) {\\n        k -= numZeros;\\n    }\\n\\n    if (k > 0 && numNegOnes) {\\n        sum += k * -1;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359207,
                "title": "python-solution-one-liner-chain-the-lists-and-sum",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return sum(list(chain([1] * numOnes + [0] * numZeros + [-1] * numNegOnes))[:k])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return sum(list(chain([1] * numOnes + [0] * numZeros + [-1] * numNegOnes))[:k])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347526,
                "title": "day-361-100-0ms-faster-easy-concise-clean-code-explained-meme-proof",
                "content": "![image.png](https://assets.leetcode.com/users/images/1fd1e138-1ab2-427e-8bec-d7624872c249_1679911416.3355732.png)\\n\\n# Intuition\\n##### \\u2022\\tThe function takes four integer arguments: numOnes, numZeros, numNegOnes, and k.\\n##### \\u2022\\tThe variable onesPicked is initialized to the minimum of k and numOnes. This is because picking the ones will give the maximum possible sum.\\n##### \\u2022\\tThe value of onesPicked is subtracted from k to get the remaining number of items to pick.\\n##### \\u2022\\tIf k has become 0, it means all the cards have been picked, so the function returns the number of ones picked.\\n##### \\u2022\\tThe variable zerosPicked is initialized to the minimum of the remaining k and numZeros.\\n##### \\u2022\\tThe value of zerosPicked is subtracted from k to get the remaining number of items to pick.\\n##### \\u2022\\tIf k has become 0, it means all the cards have been picked, so the function returns the number of ones picked.\\n##### \\u2022\\tThe variable negativeOnesPicked is initialized to the minimum of the remaining k and numNegOnes.\\n##### \\u2022\\tThe function returns onesPicked minus negativeOnesPicked, which gives the maximum possible sum of cards.\\n\\n##### \\u2022 Overall, this function picks the maximum number of available ones and zeros first and uses the remaining number of items to pick negative ones. This approach ensures that the maximum possible sum of cards is picked while staying within the limit of k items. The code is simple and efficient, with a time complexity of O(1).\\n\\n\\n\\n# Code\\n```c++ []\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    int onesPicked = min(k, numOnes);\\n    k -= onesPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int zerosPicked = min(k, numZeros);\\n    k -= zerosPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int negativeOnesPicked = min(k, numNegOnes);\\n    return onesPicked - negativeOnesPicked;\\n}\\n```\\n```java []\\npublic int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    int onesPicked = Math.min(k, numOnes);\\n    k -= onesPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int zerosPicked = Math.min(k, numZeros);\\n    k -= zerosPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int negativeOnesPicked = Math.min(k, numNegOnes);\\n    return onesPicked - negativeOnesPicked;\\n}\\n```\\n```python []\\ndef kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k):\\n    onesPicked = min(k, numOnes)\\n    k -= onesPicked\\n    if k == 0:\\n        return onesPicked\\n    zerosPicked = min(k, numZeros)\\n    k -= zerosPicked\\n    if k == 0:\\n        return onesPicked\\n    negativeOnesPicked = min(k, numNegOnes)\\n    return onesPicked - negativeOnesPicked\\n```\\n\\n\\n# Complexity\\n\\nhere\\'s the time complexity (TC) and space complexity (SC) of the kItemsWithMaximumSum function:\\n\\n##### \\u2022 Time Complexity: The function performs a fixed number of operations, regardless of the input size. Therefore, the function has a time complexity of O(1), which means it takes a constant amount of time to run.\\n\\n##### \\u2022 Space Complexity: The function uses a constant amount of memory to store the input arguments and the variables used in the function. Therefore, the function has a space complexity of O(1), which means it takes a constant amount of memory to run.\\n\\n##### \\u2022 In summary, the kItemsWithMaximumSum function has a time complexity of O(1) and a space complexity of O(1), which means it is a constant-time and constant-space algorithm. This makes it very efficient and suitable for real-time applications where performance is critical.\\n\\n# dry run 1\\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\\nOutput: 2\\n\\nhere\\'s a dry run of the function for the given input:\\n\\nnumOnes = 3\\nnumZeros = 2\\nnumNegOnes = 0\\nk = 2\\n\\nonesPicked = min(2, 3) = 2\\nk = 0\\nreturn 2\\nThe function first picks 2 ones (since k is less than or equal to the number of ones available), and then returns onesPicked since k has become 0. Therefore, the output is 2, which is the maximum possible sum of cards that can be picked within the limit of k=2.\\n# dry run 2\\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\\nOutput: 3\\nhere\\'s a dry run of the function for the given input:\\n\\nnumOnes = 3\\nnumZeros = 2\\nnumNegOnes = 0\\nk = 4\\n\\nonesPicked = min(4, 3) = 3\\nk = 1\\nzerosPicked = min(1, 2) = 1\\nk = 0\\nreturn 3\\nThe function first picks 3 ones (since k is less than or equal to the number of ones available), then picks 1 zero (since k is still greater than 0 and there are 2 zeros available), and then returns onesPicked since k has become 0. Therefore, the output is 3, which is the maximum possible sum of cards that can be picked within the limit of k=4.\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```c++ []\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    int onesPicked = min(k, numOnes);\\n    k -= onesPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int zerosPicked = min(k, numZeros);\\n    k -= zerosPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int negativeOnesPicked = min(k, numNegOnes);\\n    return onesPicked - negativeOnesPicked;\\n}\\n```\n```java []\\npublic int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n    int onesPicked = Math.min(k, numOnes);\\n    k -= onesPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int zerosPicked = Math.min(k, numZeros);\\n    k -= zerosPicked;\\n    if (k == 0) {\\n        return onesPicked;\\n    }\\n    int negativeOnesPicked = Math.min(k, numNegOnes);\\n    return onesPicked - negativeOnesPicked;\\n}\\n```\n```python []\\ndef kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k):\\n    onesPicked = min(k, numOnes)\\n    k -= onesPicked\\n    if k == 0:\\n        return onesPicked\\n    zerosPicked = min(k, numZeros)\\n    k -= zerosPicked\\n    if k == 0:\\n        return onesPicked\\n    negativeOnesPicked = min(k, numNegOnes)\\n    return onesPicked - negativeOnesPicked\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3346236,
                "title": "one-liner-javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nShamelessly stolen:\\nhttps://leetcode.com/problems/k-items-with-the-maximum-sum/solutions/3342004/one-liner/\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n  return Math.min(k, numOnes) - Math.max(0, k - numZeros - numOnes)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n  return Math.min(k, numOnes) - Math.max(0, k - numZeros - numOnes)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342215,
                "title": "greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        priority_queue<int> pq;\\n        while(numOnes--) pq.push(1);\\n        while(numZeros--) pq.push(0);\\n        while(numNegOnes--) pq.push(-1);\\n        \\n        int ans = 0;\\n        while(k--) ans += pq.top(), pq.pop();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        priority_queue<int> pq;\\n        while(numOnes--) pq.push(1);\\n        while(numZeros--) pq.push(0);\\n        while(numNegOnes--) pq.push(-1);\\n        \\n        int ans = 0;\\n        while(k--) ans += pq.top(), pq.pop();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342122,
                "title": "simple-in-c-solution",
                "content": "# Intuition\\nThe given code is a C++ solution to a problem where you are given three integers numOnes, numZeros, and numNegOnes representing the counts of the numbers 1, 0, and -1, respectively. The task is to find the maximum possible sum of \\'k\\' elements by choosing from these three numbers.\\n# Approach\\n - If \\'k\\' is 0, return 0.\\n - Add 1s to the sum until \\'k\\' is reached or no more 1s.\\n- Count 0s, but don\\'t change the sum, until \\'k\\' is reached or no more 0s.\\n- Subtract -1s from the sum until \\'k\\' is reached or no more -1s.\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k==0) return 0;\\n        int ans = 0;\\n        while(numOnes!=0){\\n            numOnes--;\\n            ans++;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n     while(numZeros!=0){\\n         numZeros--;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n         while(numNegOnes!=0){\\n            ans--;\\n              numNegOnes--;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you find this helpful",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k==0) return 0;\\n        int ans = 0;\\n        while(numOnes!=0){\\n            numOnes--;\\n            ans++;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n     while(numZeros!=0){\\n         numZeros--;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n         while(numNegOnes!=0){\\n            ans--;\\n              numNegOnes--;\\n            k--;\\n            if(k==0) return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341956,
                "title": "best-c-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust use simple math!\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k) return k;\\n        else\\n        {\\n            k= k - numOnes;\\n            if(numZeros>=k) return (numOnes);\\n            else\\n            {\\n                k = k - numZeros;\\n                return numOnes-k;\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes>=k) return k;\\n        else\\n        {\\n            k= k - numOnes;\\n            if(numZeros>=k) return (numOnes);\\n            else\\n            {\\n                k = k - numZeros;\\n                return numOnes-k;\\n                \\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838751,
                "title": "easy-begineer-math",
                "content": "Line by code explained ( no any algorithms used )\\n\\n# Complexity\\n- Time complexity:\\n   O(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res = 0 ; // to store final ans \\n        // we have taken two cases \\n        if(k <= numOnes + numZeros ){ // 1st case\\n           res = min( k ,numOnes); // in case [1,1,0,0,-1,-1] and k = 3, we take 1st k element to add like [1 , 1 ,0]\\n        }\\n        else{ // in case of k > numOnes + numZeros\\n            res = numOnes -( k -( numZeros + numOnes));\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res = 0 ; // to store final ans \\n        // we have taken two cases \\n        if(k <= numOnes + numZeros ){ // 1st case\\n           res = min( k ,numOnes); // in case [1,1,0,0,-1,-1] and k = 3, we take 1st k element to add like [1 , 1 ,0]\\n        }\\n        else{ // in case of k > numOnes + numZeros\\n            res = numOnes -( k -( numZeros + numOnes));\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700866,
                "title": "simple-solution-using-c-c-java-using-vector-c-array-c-arraylist-java",
                "content": "# Flow of Code\\n1. Intializing Vector A.\\n2. Pushing value 1 to A upto numOnes size.\\n3. Pushing value 0 to A upto numZeros size.\\n4. Pushing value -1 to A upto numNegOnes size.\\n5. Calculation the sum value upto k size in vector A and storing in variable S.\\n6. If S>=k return k as answer or return S as answer.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n        vector<int> A;\\n        for(int i=0;i<numOnes;i++)\\n            A.push_back(1);\\n        for(int i=0;i<numZeros;i++)\\n            A.push_back(0);\\n        for(int i=0;i<numNegOnes;i++)\\n            A.push_back(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A[i];\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }\\n};\\n```\\n\\n# Same Procedure Using C \\n**Please read the Flow of code in C++ and refer this C solution**\\n\\nIn C, I used the concept of array to solve the problem, but the logic is as same as explained in C++\\n\\n# C Code\\n```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int S=numOnes+numZeros+numNegOnes;\\n    int A[1000];\\n    if(S==0)\\n        A[1];\\n    else\\n        A[S];\\n    for(int i=0;i<numOnes;i++)\\n        A[i]=1;\\n    for(int i=numOnes;i<numOnes+numZeros;i++)\\n        A[i]=0;\\n    for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n        A[i]=-1;\\n    int C=0;\\n    for(int i=0;i<k;i++)\\n        C+=A[i];\\n    if(C>=k)\\n        return k;\\n    return C;\\n}\\n```\\n\\n# Same Procedure Using Java \\n**Please read the Flow of code in C++ and refer this java solution**\\n\\nIn java, I used the concept of ArrayList to solve the problem, but the logic is as same as explained in C++\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> A=new ArrayList<Integer>(1000);\\n        for(int i=0;i<numOnes;i++)\\n            A.add(1);\\n        for(int i=numOnes;i<numOnes+numZeros;i++)\\n            A.add(0);\\n        for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n            A.add(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A.get(i);\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }\\n}\\n```\\n**YOU CAN USE THE SAME PROCEDURE TO SOLVE ALSO IN PYTHON,JAVASCRIPT**\\n# Happy Coding...\\uD83E\\uDD1D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n        vector<int> A;\\n        for(int i=0;i<numOnes;i++)\\n            A.push_back(1);\\n        for(int i=0;i<numZeros;i++)\\n            A.push_back(0);\\n        for(int i=0;i<numNegOnes;i++)\\n            A.push_back(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A[i];\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }\\n};\\n```\n```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int S=numOnes+numZeros+numNegOnes;\\n    int A[1000];\\n    if(S==0)\\n        A[1];\\n    else\\n        A[S];\\n    for(int i=0;i<numOnes;i++)\\n        A[i]=1;\\n    for(int i=numOnes;i<numOnes+numZeros;i++)\\n        A[i]=0;\\n    for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n        A[i]=-1;\\n    int C=0;\\n    for(int i=0;i<k;i++)\\n        C+=A[i];\\n    if(C>=k)\\n        return k;\\n    return C;\\n}\\n```\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> A=new ArrayList<Integer>(1000);\\n        for(int i=0;i<numOnes;i++)\\n            A.add(1);\\n        for(int i=numOnes;i<numOnes+numZeros;i++)\\n            A.add(0);\\n        for(int i=numOnes+numZeros;i<numOnes+numZeros+numNegOnes;i++)\\n            A.add(-1);\\n        int S=0;\\n        for(int i=0;i<k;i++)\\n            S+=A.get(i);\\n        if(S>=k)\\n            return k;\\n        return S;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559548,
                "title": "solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        if(k<=numOnes) return k; \\n        if(k>numOnes){ \\n            sum+=numOnes;\\n            k-=numOnes;}\\n        if(k<=numZeros) return sum; \\n        if(k>numZeros){ \\n            k-=numZeros;}\\n        if(k<=numNegOnes){\\n            return sum-k; \\n        }return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        if(k<=numOnes) return k; \\n        if(k>numOnes){ \\n            sum+=numOnes;\\n            k-=numOnes;}\\n        if(k<=numZeros) return sum; \\n        if(k>numZeros){ \\n            k-=numZeros;}\\n        if(k<=numNegOnes){\\n            return sum-k; \\n        }return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543776,
                "title": "simplest-efficient-c-code-time-o-1-space-o-1",
                "content": "# Intuition\\nThe given problem requires finding the maximum sum of a subarray of length k from an array that contains three types of elements: 1, 0, and -1. We can approach this problem by counting the number of occurrences of each element in the array and then determining the maximum sum based on the given constraints.\\n\\n# Approach\\nTo solve the problem, we can compare the given length k with the counts of 1, 0, and -1 elements in the array. Based on the comparison, we determine the maximum sum by considering the available counts of 1 and 0 elements and calculating the required number of -1 elements needed to form the subarray of length k.\\n\\n# Complexity\\n- Time complexity: $O(1)$ - The function performs a fixed number of operations that do not depend on the size of the input.\\n\\n- Space complexity: $O(1)$ - The function uses a constant amount of space to store the variables.\\n\\n# Code\\n```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<=numOnes)\\n        return k;\\n    else if (k<=numOnes+numZeros)\\n        return numOnes;\\n    return numOnes - (k - numOnes - numZeros);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<=numOnes)\\n        return k;\\n    else if (k<=numOnes+numZeros)\\n        return numOnes;\\n    return numOnes - (k - numOnes - numZeros);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404556,
                "title": "java-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int o, int z, int n, int k) {\\n    if(k==0) return 0;\\n     int[] dp = new int[o+z+n];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            if(i<o)\\n            dp[i]=1;\\n            else if(i<o+z)\\n                dp[i]=0;\\n            else\\n                dp[i]=-1;\\n        }\\n        for(int i=1;i<dp.length;i++)\\n        {\\n            dp[i]=dp[i]+dp[i-1];\\n        }\\n        return dp[k-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int o, int z, int n, int k) {\\n    if(k==0) return 0;\\n     int[] dp = new int[o+z+n];\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            if(i<o)\\n            dp[i]=1;\\n            else if(i<o+z)\\n                dp[i]=0;\\n            else\\n                dp[i]=-1;\\n        }\\n        for(int i=1;i<dp.length;i++)\\n        {\\n            dp[i]=dp[i]+dp[i-1];\\n        }\\n        return dp[k-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387790,
                "title": "k-items-with-the-maximum-sum-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max_sum=0;\\n        if(k<numOnes)\\n        {\\n            max_sum = k;\\n        }\\n        else if(k==numOnes || k<=(numOnes+numZeros))\\n        {\\n            max_sum = numOnes;\\n        }\\n        else if(k<(numOnes+numZeros+abs(numNegOnes)))\\n        {\\n            max_sum = numOnes-(k-(numOnes+numZeros));\\n        }\\n        else if(k>=(numOnes+numZeros+abs(numNegOnes)))\\n        {\\n            max_sum = numOnes-numNegOnes;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max_sum=0;\\n        if(k<numOnes)\\n        {\\n            max_sum = k;\\n        }\\n        else if(k==numOnes || k<=(numOnes+numZeros))\\n        {\\n            max_sum = numOnes;\\n        }\\n        else if(k<(numOnes+numZeros+abs(numNegOnes)))\\n        {\\n            max_sum = numOnes-(k-(numOnes+numZeros));\\n        }\\n        else if(k>=(numOnes+numZeros+abs(numNegOnes)))\\n        {\\n            max_sum = numOnes-numNegOnes;\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357894,
                "title": "easy-solution-using-string-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    let one=\"1,\".repeat(numOnes);\\n       let zero=\"0,\".repeat(numZeros);\\n      let none=\"-1,\".repeat(numNegOnes);\\n       let tot=(one+zero+none).split(\",\");\\n      \\n      let sum=0,n=0,j=0;\\n      for(let i=0;i<k;i++)\\n      {\\n         n=Number(tot[j]);\\n         sum+=n;\\n         j++;\\n      }\\n\\n      return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    let one=\"1,\".repeat(numOnes);\\n       let zero=\"0,\".repeat(numZeros);\\n      let none=\"-1,\".repeat(numNegOnes);\\n       let tot=(one+zero+none).split(\",\");\\n      \\n      let sum=0,n=0,j=0;\\n      for(let i=0;i<k;i++)\\n      {\\n         n=Number(tot[j]);\\n         sum+=n;\\n         j++;\\n      }\\n\\n      return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356226,
                "title": "python-beginners-friendly-and-straight-forward-solution",
                "content": "We do not need the variable `numNegOnes`at all. If `k`is smaller than `numOnes` we can return `k`immediatelly. If `k`is less than the sum of `numOnes`and `numZeros`we can return `numOnes`since adding `0`to a **var** always results in **var**.\\nFinally if `k` is greater than sum from `numOnes`and `numZeros` we can subtract the sum of those variables from `k` and subtract this value from `numOnes`. \\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if k < numOnes:\\n            return k\\n        elif k <= numOnes + numZeros:\\n            return numOnes\\n        else:\\n            return numOnes - (k - (numOnes + numZeros))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if k < numOnes:\\n            return k\\n        elif k <= numOnes + numZeros:\\n            return numOnes\\n        else:\\n            return numOnes - (k - (numOnes + numZeros))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355893,
                "title": "simple-and-easy-to-understand-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        for(int i=0;i<numOnes;i++){\\n            if(k>0){\\n                ans+=1;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            if(k>0){\\n                ans+=0;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            if(k>0){\\n                ans-=1;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        for(int i=0;i<numOnes;i++){\\n            if(k>0){\\n                ans+=1;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            if(k>0){\\n                ans+=0;\\n                k--;\\n            }\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            if(k>0){\\n                ans-=1;\\n                k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353475,
                "title": "simple-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int maxi=0;\\n        if(k>numOnes+numZeros && numNegOnes!=0){\\n            maxi=k-(numOnes+numZeros);\\n            return numOnes-maxi;\\n        }\\n        \\n        else  {\\n            if(k>=numOnes){\\n                return numOnes;\\n            }\\n            else{\\n                return k;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int maxi=0;\\n        if(k>numOnes+numZeros && numNegOnes!=0){\\n            maxi=k-(numOnes+numZeros);\\n            return numOnes-maxi;\\n        }\\n        \\n        else  {\\n            if(k>=numOnes){\\n                return numOnes;\\n            }\\n            else{\\n                return k;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353240,
                "title": "swift-one-liner",
                "content": "**One-Liner, expanded.  O(n) (accepted answer)**\\n\\u26A0\\uFE0F- Don\\'t use O(n) solution in interview!! \\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        zip([numOnes, numZeros, numNegOnes], [1,0,-1])\\n            .lazy\\n            .flatMap { Array(repeating: $0.1, count: $0.0) }\\n            .prefix(k)\\n            .reduce(0, +)        \\n    }\\n}\\n```\\n\\n---\\n\\n**O(1) (accepted answer)**\\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        // note how `numNegOnes` is not needed, because constraint:\\n        // \"0 <= k <= numOnes + numZeros + numNegOnes\"\\n        min(k, numOnes) - max(0, k - numOnes - numZeros)  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        zip([numOnes, numZeros, numNegOnes], [1,0,-1])\\n            .lazy\\n            .flatMap { Array(repeating: $0.1, count: $0.0) }\\n            .prefix(k)\\n            .reduce(0, +)        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        // note how `numNegOnes` is not needed, because constraint:\\n        // \"0 <= k <= numOnes + numZeros + numNegOnes\"\\n        min(k, numOnes) - max(0, k - numOnes - numZeros)  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347926,
                "title": "one-liner-simple-intuition",
                "content": "# Intuition\\n\\nThe Maximum Positive Value we can get is Minimum of k and numOnes.\\n\\nIf k > numOnes + numZeros, we must select (k - numOnes - numZeros)Negative numbers as we need to select k numbers.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return (Math.min(k, numOnes)) + (-1 * Math.max(k - numOnes - numZeros, 0));\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - 1 * max(0, k - numOnes - numZeros)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min(numOnes, k) - 1 * max(k - numOnes - numZeros, 0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return (Math.min(k, numOnes)) + (-1 * Math.max(k - numOnes - numZeros, 0));\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - 1 * max(0, k - numOnes - numZeros)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min(numOnes, k) - 1 * max(k - numOnes - numZeros, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344770,
                "title": "simple-if-else-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIF-ELSE\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust tried with the testcases and got the solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        if(k<=numOnes){\\n            return k;\\n        }else if(k>numOnes){\\n            ans+=numOnes;\\n            k=k-numOnes;\\n            if(k>numZeros){\\n                ans+=0;\\n                k=k-numZeros;\\n                if(k<numNegOnes){\\n                    ans-=k;\\n                }else if(k>=numNegOnes){\\n                    ans-=k;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        if(k<=numOnes){\\n            return k;\\n        }else if(k>numOnes){\\n            ans+=numOnes;\\n            k=k-numOnes;\\n            if(k>numZeros){\\n                ans+=0;\\n                k=k-numZeros;\\n                if(k<numNegOnes){\\n                    ans-=k;\\n                }else if(k>=numNegOnes){\\n                    ans-=k;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343453,
                "title": "simple-o-n-solution-using-for-loop-only",
                "content": "# Intuition\\nSimple Self Explanatory solution using for loop in code.\\n\\n# Approach\\nWe will insert the 1\\'s,0\\'s and -1\\'s according to values and return the sum of first k elements. Since the vector will already be in descending order.\\n\\n# Complexity\\n- Time complexity: The time complexity of the solution will be O(n). To be precise, it will be O(max(max(no,nz),max(nn,k))). \\n\\n- Space complexity: It will be the same as time complexity i.e. it will be O(n). To be precise, it will be O(max(max(no,nz),max(nn,k))).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int no, int nz, int nn, int k) {\\n        vector <int> a;\\n        for(int i=0;i<no;i++)\\n        {\\n            a.push_back(1);\\n        }\\n        for(int i=0;i<nz;i++)\\n        {\\n            a.push_back(0);\\n        }\\n        for(int i=0;i<nn;i++)\\n        {\\n            a.push_back(-1);\\n        }\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum=sum+a[i];\\n        }\\n        return sum;        \\n    }\\n};\\n\\nPlease upvote if it helps!!",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int kItemsWithMaximumSum(int no, int nz, int nn, int k) {\\n        vector <int> a;\\n        for(int i=0;i<no;i++)\\n        {\\n            a.push_back(1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3343419,
                "title": "k-items-with-the-maximum-sum-in-one-line",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n     return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n     return Math.min(k, numOnes) - Math.max(0, k - numOnes - numZeros);   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343271,
                "title": "one-liner-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min(k,numOnes) + ((k-numOnes-numZeros)>0 ? (min(numNegOnes, k-numOnes-numZeros) * -1) : 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min(k,numOnes) + ((k-numOnes-numZeros)>0 ? (min(numNegOnes, k-numOnes-numZeros) * -1) : 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342947,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }\\n        while(numZeros>0){\\n            ans[i++]=0;\\n            numZeros--;\\n        }\\n        \\n        while(numNegOnes>0){\\n            ans[i++]=-1;\\n            numNegOnes--;\\n        }\\n        \\n        int sum=0;\\n        int j=0;\\n        while(k>0){\\n            \\n            sum+=ans[j++];\\n            \\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }\\n        while(numZeros>0){\\n            ans[i++]=0;\\n            numZeros--;\\n        }\\n        \\n        while(numNegOnes>0){\\n            ans[i++]=-1;\\n            numNegOnes--;\\n        }\\n        \\n        int sum=0;\\n        int j=0;\\n        while(k>0){\\n            \\n            sum+=ans[j++];\\n            \\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342791,
                "title": "java-easy",
                "content": "\\n# Solution:\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes) \\n            return k;\\n        if (k <= numOnes + numZeros) \\n            return numOnes;\\n        \\n        int kLeft = k - numOnes - numZeros;\\n        return numOnes - kLeft;\\n    }\\n}\\n```\\n### OR\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes + numZeros) \\n            return Math.min(numOnes, k);\\n        \\n        int kLeft = k - numOnes - numZeros;\\n        return numOnes - kLeft;\\n    }\\n}\\n```\\n### Time and Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes) \\n            return k;\\n        if (k <= numOnes + numZeros) \\n            return numOnes;\\n        \\n        int kLeft = k - numOnes - numZeros;\\n        return numOnes - kLeft;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes + numZeros) \\n            return Math.min(numOnes, k);\\n        \\n        int kLeft = k - numOnes - numZeros;\\n        return numOnes - kLeft;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342705,
                "title": "simple-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k)\\n    {\\n        \\n        vector<int> ans;\\n        \\n        \\n        while(numOnes--)\\n        {\\n            ans.push_back(1);\\n        }\\n        while(numZeros--)\\n        {\\n            ans.push_back(0);\\n        }\\n        \\n        while(numNegOnes--)\\n        {\\n            ans.push_back(-1);\\n        }\\n        \\n        \\n        int s=0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            s=s+ans[i];\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k)\\n    {\\n        \\n        vector<int> ans;\\n        \\n        \\n        while(numOnes--)\\n        {\\n            ans.push_back(1);\\n        }\\n        while(numZeros--)\\n        {\\n            ans.push_back(0);\\n        }\\n        \\n        while(numNegOnes--)\\n        {\\n            ans.push_back(-1);\\n        }\\n        \\n        \\n        int s=0;\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            s=s+ans[i];\\n        }\\n        \\n        return s;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342423,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        a=2*numOnes+numZeros-k\\n        return min(k,numOnes,a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        a=2*numOnes+numZeros-k\\n        return min(k,numOnes,a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342090,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }\\n        while(numZeros>0){\\n            ans[i++]=0;\\n            numZeros--;\\n        }\\n        while(numNegOnes>0){\\n            ans[i++]=-1;\\n            numNegOnes--;\\n        }\\n        int sum=0;\\n        int j=0;\\n        while(k>0){\\n            sum+=ans[j++];\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans[]=new int[numOnes+numZeros+numNegOnes];\\n        int i=0;\\n        while(numOnes>0){\\n            ans[i++]=1;\\n            numOnes--;\\n        }\\n        while(numZeros>0){\\n            ans[i++]=0;\\n            numZeros--;\\n        }\\n        while(numNegOnes>0){\\n            ans[i++]=-1;\\n            numNegOnes--;\\n        }\\n        int sum=0;\\n        int j=0;\\n        while(k>0){\\n            sum+=ans[j++];\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342087,
                "title": "o-1-solution-very-simple-code-c",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach\\nDescribe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        int a = min(numOnes,k);\\n        k -= a;\\n        ans += a;\\n            \\n        int b = min(numZeros,k);\\n        k -= b;\\n            \\n        int c = min(numNegOnes,k);\\n        ans -= c;\\n\\n        return ans;\\n    }\\n};\\n```\\n## Do let me know if you have any doubt in the solution\\u2714.\\n## Please upvote\\uD83D\\uDD3C if you liked the solution\\n## \\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/945d1086-e6fa-418c-b9db-f0ffe3083328_1679817112.9945686.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        int a = min(numOnes,k);\\n        k -= a;\\n        ans += a;\\n            \\n        int b = min(numZeros,k);\\n        k -= b;\\n            \\n        int c = min(numNegOnes,k);\\n        ans -= c;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341991,
                "title": "easy-to-understand-c-solution-beginner-friendly",
                "content": "# Complexity\\n- Time complexity: O(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        \\n        int sum=0;\\n        while(k--){\\n            if(numOnes > 0){\\n                sum += 1;\\n                numOnes--;\\n            }\\n            else if(numZeros > 0){\\n                numZeros--;\\n            }\\n            else{\\n                sum -= 1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        \\n        int sum=0;\\n        while(k--){\\n            if(numOnes > 0){\\n                sum += 1;\\n                numOnes--;\\n            }\\n            else if(numZeros > 0){\\n                numZeros--;\\n            }\\n            else{\\n                sum -= 1;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341990,
                "title": "c-java-python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/600a9175b06c42c9713cda8ed8724cb52a9d94ac) for solutions of weekly 338. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min({k, numOnes, 2*numOnes+numZeros-k}); \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, Math.min(numOnes, 2*numOnes+numZeros-k)); \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes, 2*numOnes+numZeros-k)\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return min({k, numOnes, 2*numOnes+numZeros-k}); \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return Math.min(k, Math.min(numOnes, 2*numOnes+numZeros-k)); \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes, 2*numOnes+numZeros-k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341897,
                "title": "easiest-solution-c-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        else{\\n        int sum = numOnes;\\n        k-=numOnes;\\n        if(k<=numZeros){\\n            return sum;\\n        }else{\\n            k-=numZeros;\\n            if(k<=numNegOnes){\\n                return sum-k;\\n            }\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        else{\\n        int sum = numOnes;\\n        k-=numOnes;\\n        if(k<=numZeros){\\n            return sum;\\n        }else{\\n            k-=numZeros;\\n            if(k<=numNegOnes){\\n                return sum-k;\\n            }\\n            }\\n        }\\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341884,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum =0;\\n        if(k > numOnes){\\n            sum += numOnes;\\n            k = k - numOnes;\\n        }\\n        else{\\n            sum += k;\\n            k =0;\\n        }\\n            k = k - numZeros;\\n      \\n        if(k > 0){\\n            if(k < numNegOnes){\\n                sum = sum -k;\\n            }\\n          else{\\n              sum = sum - numNegOnes;\\n          }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum =0;\\n        if(k > numOnes){\\n            sum += numOnes;\\n            k = k - numOnes;\\n        }\\n        else{\\n            sum += k;\\n            k =0;\\n        }\\n            k = k - numZeros;\\n      \\n        if(k > 0){\\n            if(k < numNegOnes){\\n                sum = sum -k;\\n            }\\n          else{\\n              sum = sum - numNegOnes;\\n          }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088944,
                "title": "easy-to-understand-beats-100-solution-c",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       if (k <= numOnes)\\n         return k;\\n       if (k <= numOnes + numZeros)\\n         return numOnes;\\n       return numOnes-(k-numOnes-numZeros);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       if (k <= numOnes)\\n         return k;\\n       if (k <= numOnes + numZeros)\\n         return numOnes;\\n       return numOnes-(k-numOnes-numZeros);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084702,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res = 0;\\n        int req = 0;\\n\\n        if (k <= numOnes) {\\n            return k;\\n        } else if (k > numOnes) {\\n            res = numOnes;\\n            req = k - numOnes;\\n        }\\n        if (req <= numZeros) {\\n            return res;\\n        } else if (req > numZeros) {\\n            req = req - numZeros;\\n        }\\n\\n        return req != 0 ? res - req : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res = 0;\\n        int req = 0;\\n\\n        if (k <= numOnes) {\\n            return k;\\n        } else if (k > numOnes) {\\n            res = numOnes;\\n            req = k - numOnes;\\n        }\\n        if (req <= numZeros) {\\n            return res;\\n        } else if (req > numZeros) {\\n            req = req - numZeros;\\n        }\\n\\n        return req != 0 ? res - req : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080129,
                "title": "best-method-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        while(k>0){\\n            if(numOnes >0){\\n                ans+=1;\\n                numOnes--;\\n                k--;\\n            }\\n            else if(numZeros >0){\\n                k--;\\n                numZeros--;\\n            }\\n            else {\\n                k--;\\n                ans-=1;\\n                numNegOnes--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n        while(k>0){\\n            if(numOnes >0){\\n                ans+=1;\\n                numOnes--;\\n                k--;\\n            }\\n            else if(numZeros >0){\\n                k--;\\n                numZeros--;\\n            }\\n            else {\\n                k--;\\n                ans-=1;\\n                numNegOnes--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079547,
                "title": "using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> rak=new ArrayList<>();\\n        for(int i=0;i<numOnes;i++){\\n            rak.add(1);\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            rak.add(0);\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            rak.add(-1);\\n        }\\n        Collections.sort(rak);\\n        int sum=0;\\n        for(int i=rak.size()-1;i >= rak.size() - k;i--){\\n            sum=sum+rak.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> rak=new ArrayList<>();\\n        for(int i=0;i<numOnes;i++){\\n            rak.add(1);\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            rak.add(0);\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            rak.add(-1);\\n        }\\n        Collections.sort(rak);\\n        int sum=0;\\n        for(int i=rak.size()-1;i >= rak.size() - k;i--){\\n            sum=sum+rak.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076205,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int diff = (k - (numOnes+numZeros));\\n        if(diff > 0)\\n            return numOnes-diff;\\n        if(numOnes <= k) return numOnes;\\n        else return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int diff = (k - (numOnes+numZeros));\\n        if(diff > 0)\\n            return numOnes-diff;\\n        if(numOnes <= k) return numOnes;\\n        else return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075561,
                "title": "clear-java-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int c=0,res=0;\\n        while(c<k){\\n            if(c<numOnes){\\n                res+=1;\\n                c++;\\n            }\\n            else if(c>=numOnes && c<numZeros+numOnes){\\n                c++;\\n            }\\n            else if(c>=numZeros+numOnes && c<numZeros+numOnes+numNegOnes){\\n                res-=1;\\n                c++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int c=0,res=0;\\n        while(c<k){\\n            if(c<numOnes){\\n                res+=1;\\n                c++;\\n            }\\n            else if(c>=numOnes && c<numZeros+numOnes){\\n                c++;\\n            }\\n            else if(c>=numZeros+numOnes && c<numZeros+numOnes+numNegOnes){\\n                res-=1;\\n                c++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075220,
                "title": "2600",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        if(numOnes>=k){\\n            return k;\\n        }else{\\n            ans+= numOnes;\\n            k-=numOnes;\\n            if(numZeros>=k){\\n                return numOnes;\\n            }\\n            else{\\n                k-=numZeros;\\n                return numOnes - k;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans = 0;\\n        if(numOnes>=k){\\n            return k;\\n        }else{\\n            ans+= numOnes;\\n            k-=numOnes;\\n            if(numZeros>=k){\\n                return numOnes;\\n            }\\n            else{\\n                k-=numZeros;\\n                return numOnes - k;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065655,
                "title": "easy-solution-using-conditional-statements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Mathematics\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou will understand once you go through the code\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int s=0;\\n        if(k<numOnes)\\n        s=s+k;\\n        else\\n        s=s+numOnes;\\n         k=k-numOnes;\\n        if(k>0)\\n        k=k-numZeros;\\n        if(k>0)\\n        s=s-k;\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int s=0;\\n        if(k<numOnes)\\n        s=s+k;\\n        else\\n        s=s+numOnes;\\n         k=k-numOnes;\\n        if(k>0)\\n        k=k-numZeros;\\n        if(k>0)\\n        s=s-k;\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065576,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        count = 0\\n        while numOnes > 0:\\n            if k == 0:\\n                break\\n            count += 1\\n            numOnes -= 1\\n            k -= 1\\n        \\n        while numZeros > 0:\\n            if k == 0:\\n                break\\n            count += 0\\n            numZeros -= 1\\n            k -= 1\\n\\n        while numNegOnes > 0:\\n            if k == 0:\\n                break\\n            count -= 1\\n            numNegOnes -= 1\\n            k -= 1\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        count = 0\\n        while numOnes > 0:\\n            if k == 0:\\n                break\\n            count += 1\\n            numOnes -= 1\\n            k -= 1\\n        \\n        while numZeros > 0:\\n            if k == 0:\\n                break\\n            count += 0\\n            numZeros -= 1\\n            k -= 1\\n\\n        while numNegOnes > 0:\\n            if k == 0:\\n                break\\n            count -= 1\\n            numNegOnes -= 1\\n            k -= 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059492,
                "title": "2600-simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        while(k--)\\n        {\\n            if(numOnes>0)\\n            {\\n                sum++;\\n                numOnes--;\\n            }\\n            else if(numZeros>0)\\n                numZeros--;\\n            else\\n            {\\n                sum--;\\n                numNegOnes--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        while(k--)\\n        {\\n            if(numOnes>0)\\n            {\\n                sum++;\\n                numOnes--;\\n            }\\n            else if(numZeros>0)\\n                numZeros--;\\n            else\\n            {\\n                sum--;\\n                numNegOnes--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058101,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(numOnes, k) if numOnes >= k else numOnes - max(0, (k - numOnes - numZeros))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        return min(numOnes, k) if numOnes >= k else numOnes - max(0, (k - numOnes - numZeros))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055905,
                "title": "using-pure-logic-no-big-concept-o-1-solution",
                "content": "# Intuition\\n*Checking all the test cases for which the code is going to run*\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int greater=0;\\n\\n        if(k<=numOnes)\\n        return k;\\n\\n        if(k>numOnes && k<=(numOnes+numZeros) )\\n        return numOnes;\\n\\n        if(k>(numOnes+numZeros)){\\n             greater=k-(numOnes+numZeros);\\n         return numOnes-greater;\\n        }\\n\\n        if(k>(numOnes+numZeros+numNegOnes)){\\n         greater=k-(numOnes+numZeros);\\n         return numOnes-greater;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int greater=0;\\n\\n        if(k<=numOnes)\\n        return k;\\n\\n        if(k>numOnes && k<=(numOnes+numZeros) )\\n        return numOnes;\\n\\n        if(k>(numOnes+numZeros)){\\n             greater=k-(numOnes+numZeros);\\n         return numOnes-greater;\\n        }\\n\\n        if(k>(numOnes+numZeros+numNegOnes)){\\n         greater=k-(numOnes+numZeros);\\n         return numOnes-greater;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055445,
                "title": "easy-java-solution-1-ms-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n            return k;\\n        if(k>numOnes && k<=numZeros+numOnes)\\n            return numOnes;\\n        else if(k>numOnes && k>numZeros+numOnes)\\n            return numOnes+(k-(numZeros+numOnes))*(-1);\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n            return k;\\n        if(k>numOnes && k<=numZeros+numOnes)\\n            return numOnes;\\n        else if(k>numOnes && k>numZeros+numOnes)\\n            return numOnes+(k-(numZeros+numOnes))*(-1);\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045206,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n            return k;\\n        if(k<=numOnes+numZeros)\\n            return numOnes;\\n        return numOnes-(k-(numOnes+numZeros));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n            return k;\\n        if(k<=numOnes+numZeros)\\n            return numOnes;\\n        return numOnes-(k-(numOnes+numZeros));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042854,
                "title": "k-items-with-the-maximum-sum-nitishman",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nStore all the ones, zeros and neg ones in an array and then sum those items untill we reach k\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1) First we get the total no of elements = numOnes + numZeros + numNegOnes and store it in a variable total\\n2) Create an array with length of total\\n3) Then we loop unitll total\\n    a) we then check if index i is less than numOnes if yes store 1 in the array i.e arr[i] = 1\\n    b) else we check if the index is greater or equal to numOnes and less than numOnes+numZeros if yes then store 0 in array arr[i] = 0. e.g {1 ,1 ,1 ,0 ,0} here >= 3 and < 5 so elements 3 and 4.  \\n    c) else if then no is greater than numOnes + numZeros if yes then store -1 in the array arr[i] = -1\\n4) Then we loop through the array untill k and store the it in sum\\n    i.e sum += arr[i];\\n5)Return the sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int total = numOnes+numZeros+numNegOnes;\\n        int[] result = new int[total];\\n        for(int i = 0;i < total;i++){\\n            if(i < numOnes)   {\\n                result[i] = 1;\\n            }else if(i >= numOnes && i< numOnes+numZeros){\\n                result[i] = 0;\\n            } else if(i >= numOnes+numZeros){\\n                result[i] = -1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0;i < k;i++){\\n            sum+= result[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int total = numOnes+numZeros+numNegOnes;\\n        int[] result = new int[total];\\n        for(int i = 0;i < total;i++){\\n            if(i < numOnes)   {\\n                result[i] = 1;\\n            }else if(i >= numOnes && i< numOnes+numZeros){\\n                result[i] = 0;\\n            } else if(i >= numOnes+numZeros){\\n                result[i] = -1;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0;i < k;i++){\\n            sum+= result[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037704,
                "title": "less-complication-program-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if(numOnes+numZeros>k):\\n            if(numOnes>k):\\n                return k\\n            else:\\n                return numOnes\\n        else:\\n            d=k-(numOnes+numZeros)\\n            return numOnes+(numZeros)*0-d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if(numOnes+numZeros>k):\\n            if(numOnes>k):\\n                return k\\n            else:\\n                return numOnes\\n        else:\\n            d=k-(numOnes+numZeros)\\n            return numOnes+(numZeros)*0-d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034844,
                "title": "python-simple-solution-loop",
                "content": "# Complexity\\n- Time complexity: $$O(m + n + k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n  def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n    sum_ = 0\\n    while numOnes and k:\\n      sum_ += 1\\n      k -= 1\\n      numOnes -= 1\\n    while numZeros and k:\\n      k -= 1\\n      numZeros -= 1\\n    while numNegOnes and k:\\n      k -= 1\\n      sum_ -= 1\\n      numNegOnes -= 1\\n    return sum_\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n  def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n    sum_ = 0\\n    while numOnes and k:\\n      sum_ += 1\\n      k -= 1\\n      numOnes -= 1\\n    while numZeros and k:\\n      k -= 1\\n      numZeros -= 1\\n    while numNegOnes and k:\\n      k -= 1\\n      sum_ -= 1\\n      numNegOnes -= 1\\n    return sum_\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026112,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n        return k;\\n        else if(k <= numOnes+numZeros)\\n        return numOnes;\\n\\n        int x = abs(numOnes+numZeros-k);\\n\\n        return numOnes-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n        return k;\\n        else if(k <= numOnes+numZeros)\\n        return numOnes;\\n\\n        int x = abs(numOnes+numZeros-k);\\n\\n        return numOnes-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023318,
                "title": "c-and-python-solutions",
                "content": "\\n```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int sum = 0; \\n\\n    while(k--) \\n        sum += numOnes > 0 ? (numOnes--, 1) :  \\n        (numZeros > 0 ? (numZeros--, 0) :  \\n        (numNegOnes--, -1));\\n\\n    return sum;\\n}\\n``` \\n``` \\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int: \\n        sum = 0  \\n        while k > 0 : \\n            if numOnes > 0 : \\n                sum += 1 \\n                numOnes-=1  \\n            elif numZeros > 0 : \\n                sum += 0 \\n                numZeros -=1; \\n            else :\\n                sum -=1 \\n                numNegOnes-=1  \\n            k -= 1\\n        return sum",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    int sum = 0; \\n\\n    while(k--) \\n        sum += numOnes > 0 ? (numOnes--, 1) :  \\n        (numZeros > 0 ? (numZeros--, 0) :  \\n        (numNegOnes--, -1));\\n\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019449,
                "title": "c-easy-code-beats-100-on-time-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int pos, int zero, int neg, int k) {\\n        if(pos >= k)\\n            return k;\\n        else if(pos+zero >= k)\\n            return pos;\\n        else\\n            return pos - (k - (pos+zero));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int pos, int zero, int neg, int k) {\\n        if(pos >= k)\\n            return k;\\n        else if(pos+zero >= k)\\n            return pos;\\n        else\\n            return pos - (k - (pos+zero));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012351,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        if(k>numOnes && k<=numOnes+numZeros){\\n            return numOnes;\\n        }\\n        \\n        if(k>numOnes+numZeros && k<=numOnes+numZeros+numNegOnes)\\n        return numOnes-(k-(numOnes+numZeros));\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes){\\n            return k;\\n        }\\n        if(k>numOnes && k<=numOnes+numZeros){\\n            return numOnes;\\n        }\\n        \\n        if(k>numOnes+numZeros && k<=numOnes+numZeros+numNegOnes)\\n        return numOnes-(k-(numOnes+numZeros));\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010090,
                "title": "1ms-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(k <= numOnes){\\n            sum += k;\\n            k = 0;\\n        }\\n        else{\\n            sum += numOnes;\\n            k -= numOnes;\\n        }\\n\\n        if(k>0){\\n            if(k <= numZeros){\\n                k = 0;\\n            }\\n            else{\\n                k -= numZeros;\\n            }\\n        }\\n\\n        if(k>0){\\n            if(k <= numNegOnes){\\n                sum -= k;\\n                k = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(k <= numOnes){\\n            sum += k;\\n            k = 0;\\n        }\\n        else{\\n            sum += numOnes;\\n            k -= numOnes;\\n        }\\n\\n        if(k>0){\\n            if(k <= numZeros){\\n                k = 0;\\n            }\\n            else{\\n                k -= numZeros;\\n            }\\n        }\\n\\n        if(k>0){\\n            if(k <= numNegOnes){\\n                sum -= k;\\n                k = 0;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007778,
                "title": "beginner-friendly-java-code-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n            return k;\\n        else{\\n            int max = numOnes;\\n            k = k - numOnes;\\n            if(k <= numZeros)\\n                return max;\\n            else{\\n                k = k - numZeros;\\n                for(int i=0; i<k; i++)\\n                    max--;\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n            return k;\\n        else{\\n            int max = numOnes;\\n            k = k - numOnes;\\n            if(k <= numZeros)\\n                return max;\\n            else{\\n                k = k - numZeros;\\n                for(int i=0; i<k; i++)\\n                    max--;\\n                return max;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996345,
                "title": "one-line-solution-beats-100-c-o-1-space-and-time",
                "content": "# Approach\\nif numOnes + numZeros are greater than or equals to k , return the minimum of numOnes, k else return the value of (numOnes-(k-numOnes-numZeros))\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return ((k<=numOnes+numZeros?min(numOnes,k):(numOnes-(k-numOnes-numZeros))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return ((k<=numOnes+numZeros?min(numOnes,k):(numOnes-(k-numOnes-numZeros))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995662,
                "title": "vey-easy-simple-beginner-friendly-beats-90-percent",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        a=[]\\n        x=0\\n        while(numOnes>0):\\n            a.append(1)\\n            numOnes=numOnes-1\\n        while(numZeros>0):\\n            a.append(0)\\n            numZeros=numZeros-1\\n        while(numNegOnes>0):\\n            a.append(-1)\\n            numNegOnes=numNegOnes-1\\n        for i in range(0,k):\\n            x=x+a[i]\\n        return x\\n        \\n\\n        \\n       \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        a=[]\\n        x=0\\n        while(numOnes>0):\\n            a.append(1)\\n            numOnes=numOnes-1\\n        while(numZeros>0):\\n            a.append(0)\\n            numZeros=numZeros-1\\n        while(numNegOnes>0):\\n            a.append(-1)\\n            numNegOnes=numNegOnes-1\\n        for i in range(0,k):\\n            x=x+a[i]\\n        return x\\n        \\n\\n        \\n       \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994939,
                "title": "c-using-math-constant-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes > k) return k;\\n\\n        if(numOnes == k) return k;\\n\\n        if(numOnes + numZeros >= k) return numOnes;\\n\\n        int x = k-(numOnes + numZeros);\\n\\n        return numOnes + (-1*x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes > k) return k;\\n\\n        if(numOnes == k) return k;\\n\\n        if(numOnes + numZeros >= k) return numOnes;\\n\\n        int x = k-(numOnes + numZeros);\\n\\n        return numOnes + (-1*x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986137,
                "title": "easily-beat-96-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        res=0\\n        while k>0 and numOnes>0:\\n            res+=1\\n            numOnes-=1\\n            k-=1\\n        while k>0 and numZeros>0:\\n            numZeros-=1\\n            k-=1\\n\\n        while k>0 and numNegOnes>0:\\n            res-=1\\n            numNegOnes-=1\\n            k-=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        res=0\\n        while k>0 and numOnes>0:\\n            res+=1\\n            numOnes-=1\\n            k-=1\\n        while k>0 and numZeros>0:\\n            numZeros-=1\\n            k-=1\\n\\n        while k>0 and numNegOnes>0:\\n            res-=1\\n            numNegOnes-=1\\n            k-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979957,
                "title": "easy-solution-100-ms-using-while-loop-and-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max=0;\\n     if(numOnes>=k) return k;\\n   \\n        while(numOnes!=0&&k!=0)\\n        {\\n            k--;\\n            numOnes--;\\n            max++;\\n        }\\n         while(numZeros!=0&&k!=0)\\n        {\\n            k--;\\n            numZeros--;\\n            \\n        }\\n          while(numNegOnes!=0&&k!=0)\\n        {\\n            k--;\\n            numNegOnes--;\\n            max--;\\n        }\\n    return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max=0;\\n     if(numOnes>=k) return k;\\n   \\n        while(numOnes!=0&&k!=0)\\n        {\\n            k--;\\n            numOnes--;\\n            max++;\\n        }\\n         while(numZeros!=0&&k!=0)\\n        {\\n            k--;\\n            numZeros--;\\n            \\n        }\\n          while(numNegOnes!=0&&k!=0)\\n        {\\n            k--;\\n            numNegOnes--;\\n            max--;\\n        }\\n    return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972485,
                "title": "two-different-ideas",
                "content": "# Unique Solution 1\\n```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        if k-numOnes > 0:\\n            maxSum = numOnes\\n            if (k - numOnes) - numZeros > 0:\\n                maxSum -= k - numOnes - numZeros\\n        else:\\n            maxSum = k\\n        \\n        return maxSum\\n```\\n# Unique Solution 2 using list\\n```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        queue = []\\n\\n        ones = numOnes * [1]\\n        queue.append(ones)\\n\\n        zeros = numZeros * [0]\\n        queue.append(zeros)\\n\\n        negs = numNegOnes * [-1]\\n        queue.append(negs)\\n\\n        flat_list = [item for sublist in queue for item in sublist]\\n\\n        return sum(flat_list[:k])\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        if k-numOnes > 0:\\n            maxSum = numOnes\\n            if (k - numOnes) - numZeros > 0:\\n                maxSum -= k - numOnes - numZeros\\n        else:\\n            maxSum = k\\n        \\n        return maxSum\\n```\n```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        queue = []\\n\\n        ones = numOnes * [1]\\n        queue.append(ones)\\n\\n        zeros = numZeros * [0]\\n        queue.append(zeros)\\n\\n        negs = numNegOnes * [-1]\\n        queue.append(negs)\\n\\n        flat_list = [item for sublist in queue for item in sublist]\\n\\n        return sum(flat_list[:k])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972189,
                "title": "easy-solution-using-greedy-method-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int count = 0;\\n        while(k>0&&numOnes>0){\\n        k-=1;\\n        numOnes--;\\n        count++;\\n        }\\n        while(k>0 && numZeros){\\n            numZeros--;\\n            k--;\\n        }\\n        while(k>0 && numNegOnes){\\n            numNegOnes--;\\n            k--;\\n            count--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int count = 0;\\n        while(k>0&&numOnes>0){\\n        k-=1;\\n        numOnes--;\\n        count++;\\n        }\\n        while(k>0 && numZeros){\\n            numZeros--;\\n            k--;\\n        }\\n        while(k>0 && numNegOnes){\\n            numNegOnes--;\\n            k--;\\n            count--;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967118,
                "title": "easy-c-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = min(numOnes, k); \\n        k -= sum;\\n        if(k > 0){\\n            k -= min(k, numZeros);\\n        }\\n        if(k > 0){\\n            sum -= min(k, numNegOnes);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = min(numOnes, k); \\n        k -= sum;\\n        if(k > 0){\\n            k -= min(k, numZeros);\\n        }\\n        if(k > 0){\\n            sum -= min(k, numNegOnes);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954419,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int  ans=0;\\n        for(int i=0;i<numOnes;i++){\\n            if(k>0){\\n                ans+=1;\\n                k-=1;\\n            }\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            if(k>0){\\n                ans+=0;\\n                k-=1;\\n            }\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            if(k>0){\\n                ans-=1;\\n                k-=1;\\n            }\\n        }\\n         return ans;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int  ans=0;\\n        for(int i=0;i<numOnes;i++){\\n            if(k>0){\\n                ans+=1;\\n                k-=1;\\n            }\\n        }\\n        for(int i=0;i<numZeros;i++){\\n            if(k>0){\\n                ans+=0;\\n                k-=1;\\n            }\\n        }\\n        for(int i=0;i<numNegOnes;i++){\\n            if(k>0){\\n                ans-=1;\\n                k-=1;\\n            }\\n        }\\n         return ans;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944401,
                "title": "swift-switch-case-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        \\n        switch (numOnes, numZeros) {\\n        case let (p, _) where p >= k:\\n            return k\\n        case let (p, z) where p < k && p + z >= k:\\n            return p\\n        case let (p, z) where p + z < k:\\n            let diff = k - (p + z)\\n            return p - diff\\n        default:\\n            return 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        \\n        switch (numOnes, numZeros) {\\n        case let (p, _) where p >= k:\\n            return k\\n        case let (p, z) where p < k && p + z >= k:\\n            return p\\n        case let (p, z) where p + z < k:\\n            let diff = k - (p + z)\\n            return p - diff\\n        default:\\n            return 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944194,
                "title": "easy-one-line-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        let ones = Array(repeating: 1, count: numOnes)\\n        let zeros = Array(repeating: 0, count: numZeros)\\n        let negative = Array(repeating: -1, count: numNegOnes)\\n        let result = ones + zeros + negative\\n        \\n        return result.prefix(k).reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int {\\n        let ones = Array(repeating: 1, count: numOnes)\\n        let zeros = Array(repeating: 0, count: numZeros)\\n        let negative = Array(repeating: -1, count: numNegOnes)\\n        let result = ones + zeros + negative\\n        \\n        return result.prefix(k).reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929056,
                "title": "easy-java-solution-with-1ms-runtime-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int s = 0;\\n        if(k<=numOnes)\\n        {\\n            s = k;\\n            return s;\\n        }\\n        if(k-numOnes>0 && k-(numOnes+numZeros)<=0)\\n        {\\n            s = numOnes;\\n            return s;\\n        }\\n        if(k-(numOnes+numZeros)>0)\\n        {\\n            s = numOnes+ (k-(numOnes+numZeros))*(-1);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int s = 0;\\n        if(k<=numOnes)\\n        {\\n            s = k;\\n            return s;\\n        }\\n        if(k-numOnes>0 && k-(numOnes+numZeros)<=0)\\n        {\\n            s = numOnes;\\n            return s;\\n        }\\n        if(k-(numOnes+numZeros)>0)\\n        {\\n            s = numOnes+ (k-(numOnes+numZeros))*(-1);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927947,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        while (k > 0){\\n            if (numOnes > 0){\\n                sum++;\\n                numOnes--;\\n            }\\n            else if (numZeros > 0){\\n                numZeros--;\\n            }\\n            else{\\n                sum--;\\n                numNegOnes--;\\n            }\\n            k--;\\n        }    \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        while (k > 0){\\n            if (numOnes > 0){\\n                sum++;\\n                numOnes--;\\n            }\\n            else if (numZeros > 0){\\n                numZeros--;\\n            }\\n            else{\\n                sum--;\\n                numNegOnes--;\\n            }\\n            k--;\\n        }    \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923099,
                "title": "maximum-number-of-zeros-and-non-negative-ones-and-ones-in-the-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int [] kitm = new int[numOnes+numZeros+numNegOnes];\\n        for(int i=0; i<kitm.length; i++){\\n            if(i<numOnes){\\n                kitm[i]=1;\\n            }\\n            else if(i<numOnes+numZeros){\\n                kitm[i]=0;\\n            }\\n            else{\\n                kitm[i]=-1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=kitm[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int [] kitm = new int[numOnes+numZeros+numNegOnes];\\n        for(int i=0; i<kitm.length; i++){\\n            if(i<numOnes){\\n                kitm[i]=1;\\n            }\\n            else if(i<numOnes+numZeros){\\n                kitm[i]=0;\\n            }\\n            else{\\n                kitm[i]=-1;\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=kitm[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922956,
                "title": "simplest-javascript-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    \\n    if(k<=(numOnes))\\n    return k;\\n    else if(k<=(numOnes+numZeros))\\n    return numOnes;\\n    else return(numOnes-(k-(numOnes+numZeros)))\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    \\n    if(k<=(numOnes))\\n    return k;\\n    else if(k<=(numOnes+numZeros))\\n    return numOnes;\\n    else return(numOnes-(k-(numOnes+numZeros)))\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922385,
                "title": "one-line-javascript-solution-beats-98-67",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n\\n    return Math.min(k, numOnes) + -Math.max(k - numOnes - numZeros, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n\\n    return Math.min(k, numOnes) + -Math.max(k - numOnes - numZeros, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909491,
                "title": "runtime-93-memory-72",
                "content": "# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        res = []\\n        for i in range(numOnes):\\n            res.append(1)\\n        for i in range(numZeros):\\n            res.append(0)\\n        for i in range(numNegOnes):\\n            res.append(-1)\\n        return sum(res[:k])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        res = []\\n        for i in range(numOnes):\\n            res.append(1)\\n        for i in range(numZeros):\\n            res.append(0)\\n        for i in range(numNegOnes):\\n            res.append(-1)\\n        return sum(res[:k])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907674,
                "title": "the-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] ans = new int[numOnes + numZeros + numNegOnes];\\n        int i = 0;\\n        while (numOnes > 0) {\\n            ans[i++] += 1;\\n            numOnes--;\\n        }\\n        while (numZeros > 0) {\\n            ans[i++] += 0;\\n            numZeros--;\\n        }\\n        while (numNegOnes > 0) {\\n            ans[i++] -= 1;\\n            numNegOnes--;\\n        }\\n        int sum = 0;\\n        int j = 0;\\n        while (k > 0) {\\n            sum += ans[j];\\n            j++;\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] ans = new int[numOnes + numZeros + numNegOnes];\\n        int i = 0;\\n        while (numOnes > 0) {\\n            ans[i++] += 1;\\n            numOnes--;\\n        }\\n        while (numZeros > 0) {\\n            ans[i++] += 0;\\n            numZeros--;\\n        }\\n        while (numNegOnes > 0) {\\n            ans[i++] -= 1;\\n            numNegOnes--;\\n        }\\n        int sum = 0;\\n        int j = 0;\\n        while (k > 0) {\\n            sum += ans[j];\\n            j++;\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890069,
                "title": "k-items-with-max-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        nums=[1]*numOnes+[0]*numZeros+[-1]*numNegOnes\\n        num=0\\n        for i in range(k):\\n            num+=nums[i]\\n        return num\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        nums=[1]*numOnes+[0]*numZeros+[-1]*numNegOnes\\n        num=0\\n        for i in range(k):\\n            num+=nums[i]\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885811,
                "title": "simple-java-c-c-code-beats-100-users-in-both-time-and-space",
                "content": "# Approach\\nUsed simple if else loops\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int ans=0;\\n        if(numOnes>=k)\\n        {\\n            ans=k;\\n        }\\n       \\n        else if(numOnes<k)\\n        {\\n            if(numOnes+numZeros>=k)\\n            {\\n                ans = numOnes;\\n            }\\n            else if(numOnes+numZeros<k)\\n            {\\n                ans = numOnes-1;\\n            }\\n        }\\n        else if(numOnes==0)\\n        {\\n            ans = 0;\\n        }\\n        if(numOnes+numZeros+numNegOnes==k)\\n        {\\n            ans = numOnes-numNegOnes;\\n        }\\n        else if(numOnes+numZeros<k)\\n        {\\n            ans = numOnes-(k-numOnes-numZeros);\\n        }\\n        \\n        \\n\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int ans=0;\\n        if(numOnes>=k)\\n        {\\n            ans=k;\\n        }\\n       \\n        else if(numOnes<k)\\n        {\\n            if(numOnes+numZeros>=k)\\n            {\\n                ans = numOnes;\\n            }\\n            else if(numOnes+numZeros<k)\\n            {\\n                ans = numOnes-1;\\n            }\\n        }\\n        else if(numOnes==0)\\n        {\\n            ans = 0;\\n        }\\n        if(numOnes+numZeros+numNegOnes==k)\\n        {\\n            ans = numOnes-numNegOnes;\\n        }\\n        else if(numOnes+numZeros<k)\\n        {\\n            ans = numOnes-(k-numOnes-numZeros);\\n        }\\n        \\n        \\n\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869346,
                "title": "basic-php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic math solutions\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $numOnes\\n     * @param Integer $numZeros\\n     * @param Integer $numNegOnes\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function kItemsWithMaximumSum($numOnes, $numZeros, $numNegOnes, $k) {\\n        $x = $numOnes + $numZeros;\\n        if($k <= $x){\\n            $ret = min($k,$numOnes);\\n        }\\n        else {\\n            $ret = $numOnes - $k + $x;\\n        }\\n        return $ret;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $numOnes\\n     * @param Integer $numZeros\\n     * @param Integer $numNegOnes\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function kItemsWithMaximumSum($numOnes, $numZeros, $numNegOnes, $k) {\\n        $x = $numOnes + $numZeros;\\n        if($k <= $x){\\n            $ret = min($k,$numOnes);\\n        }\\n        else {\\n            $ret = $numOnes - $k + $x;\\n        }\\n        return $ret;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863831,
                "title": "java-1ms-beats-100-00",
                "content": "# Intuition & Approach\\nAdd the groups of integers to our sum in order from most favorable group (ones) to least favorable (negative ones), decrementing `k` also as we go.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n        int sum = 0;  // what we\\'ll return\\n\\n        while (k > 0 && numOnes > 0) {\\n            ++sum;\\n            --numOnes;\\n            --k;\\n        }\\n\\n        while (k > 0 && numZeros > 0) {\\n            --numZeros;\\n            --k;\\n        }\\n\\n        while (k > 0 && numNegOnes > 0) {\\n            --sum;\\n            --numNegOnes;\\n            --k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n        int sum = 0;  // what we\\'ll return\\n\\n        while (k > 0 && numOnes > 0) {\\n            ++sum;\\n            --numOnes;\\n            --k;\\n        }\\n\\n        while (k > 0 && numZeros > 0) {\\n            --numZeros;\\n            --k;\\n        }\\n\\n        while (k > 0 && numNegOnes > 0) {\\n            --sum;\\n            --numNegOnes;\\n            --k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863578,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        while(k){\\n            if(numOnes){\\n                int mx = min(numOnes,k);\\n                sum+=mx;\\n                k-=mx;\\n                numOnes = 0;\\n                continue;\\n            }\\n            if(numZeros){\\n                int mx = min(numZeros,k);\\n                k-=mx;\\n                numZeros = 0;\\n                continue;\\n            }\\n            if(numNegOnes){\\n                int mx = min(numNegOnes,k);\\n                sum-=mx;\\n                k-=mx;\\n                numNegOnes = 0;\\n                continue;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        while(k){\\n            if(numOnes){\\n                int mx = min(numOnes,k);\\n                sum+=mx;\\n                k-=mx;\\n                numOnes = 0;\\n                continue;\\n            }\\n            if(numZeros){\\n                int mx = min(numZeros,k);\\n                k-=mx;\\n                numZeros = 0;\\n                continue;\\n            }\\n            if(numNegOnes){\\n                int mx = min(numNegOnes,k);\\n                sum-=mx;\\n                k-=mx;\\n                numNegOnes = 0;\\n                continue;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862132,
                "title": "java-two-easy-solutions",
                "content": "# SOLUTION : 1\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n\\n        int maxsum = Math.min(k,numOnes);\\n        int minsum = Math.max(0,k-numOnes-numZeros);\\n\\n        return maxsum - minsum;\\n\\n    }\\n}\\n\\n# Solution :2\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        \\n        int ans = 0;\\n\\n        ans = Math.min(k,numOnes);\\n\\n        k -= numOnes + numZeros;\\n\\n        if( k < 0)\\n        {\\n            return ans;\\n        }\\n\\n        ans -= Math.min(numNegOnes, k);\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n\\n        int maxsum = Math.min(k,numOnes);\\n        int minsum = Math.max(0,k-numOnes-numZeros);\\n\\n        return maxsum - minsum;\\n\\n    }\\n}\\n\\n# Solution :2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860568,
                "title": "easy-cpp-solution-naive-approach-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        // Add posisitve ones into sum\\n        if(k<numOnes){\\n            return k;\\n        }\\n        k -= numOnes;\\n        sum += numOnes;\\n        // reduce k for nodes with 0 value\\n        k -= numZeros;\\n        // if k is 0 OR negative (means target achieved) then\\n        if(k <= 0) \\n            return sum;\\n        // else return by subtracting the remaining as numNegOnes from sum\\n        return sum - k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        // Add posisitve ones into sum\\n        if(k<numOnes){\\n            return k;\\n        }\\n        k -= numOnes;\\n        sum += numOnes;\\n        // reduce k for nodes with 0 value\\n        k -= numZeros;\\n        // if k is 0 OR negative (means target achieved) then\\n        if(k <= 0) \\n            return sum;\\n        // else return by subtracting the remaining as numNegOnes from sum\\n        return sum - k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860457,
                "title": "swift-one-liner-o-1-time-o-1-space",
                "content": "This is my one line solution. \\n\\nIt turns out there is [a smaller one line solution](https://leetcode.com/problems/k-items-with-the-maximum-sum/solutions/3353240/swift-one-liner/) that removes the `min` involving `numNegOnes` because of the constraint `0 <= k <= numOnes + numZeros + numNegOnes`, but I did not missed that! \\n\\n# Code\\n```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int { \\n        min(numOnes, k) - min(max(0, k - numOnes - numZeros), numNegOnes)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kItemsWithMaximumSum(_ numOnes: Int, _ numZeros: Int, _ numNegOnes: Int, _ k: Int) -> Int { \\n        min(numOnes, k) - min(max(0, k - numOnes - numZeros), numNegOnes)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851376,
                "title": "simple-intuitive-brute-force-100-efficient",
                "content": "```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int count=0;\\n        while(k--){\\n            if(numOnes!=0){\\n                count++;\\n                numOnes--;\\n            }\\n            else if(numZeros!=0)\\n                numZeros--;\\n            else{\\n                count--;\\n                numNegOnes--;\\n            }\\n        }\\n        return count;\\n    }\\n```\\nPlease upvote if you like the approach :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int count=0;\\n        while(k--){\\n            if(numOnes!=0){\\n                count++;\\n                numOnes--;\\n            }\\n            else if(numZeros!=0)\\n                numZeros--;\\n            else{\\n                count--;\\n                numNegOnes--;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849052,
                "title": "math-solution-code-only",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k<=numOnes) return k;\\n        if (k>=numOnes+numZeros) return numOnes - (k-numOnes-numZeros);       \\n        return numOnes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k<=numOnes) return k;\\n        if (k>=numOnes+numZeros) return numOnes - (k-numOnes-numZeros);       \\n        return numOnes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847422,
                "title": "best-solution-python-less-space-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        sum=0\\n        for i in range(k):\\n            if numOnes>0:\\n                sum=sum+1\\n                numOnes-=1\\n            elif numOnes==0 and numZeros!=0:\\n                numZeros-=1\\n            elif numOnes==0 and numZeros==0:\\n                sum=sum-1\\n                numNegOnes-=1\\n        return sum\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kItemsWithMaximumSum(self, numOnes, numZeros, numNegOnes, k):\\n        sum=0\\n        for i in range(k):\\n            if numOnes>0:\\n                sum=sum+1\\n                numOnes-=1\\n            elif numOnes==0 and numZeros!=0:\\n                numZeros-=1\\n            elif numOnes==0 and numZeros==0:\\n                sum=sum-1\\n                numNegOnes-=1\\n        return sum\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840898,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (numOnes > k) return k;\\n        k -= numOnes + numZeros;\\n        if (k < 1) return numOnes;\\n        return numOnes - k;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (numOnes > k) return k;\\n        k -= numOnes + numZeros;\\n        if (k < 1) return numOnes;\\n        return numOnes - k;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838054,
                "title": "o-n-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] arr=new int[numOnes+numZeros+numNegOnes];\\n        int p=0,sum=0,i;\\n        for(i=1;i<=numOnes;i++)\\n            arr[p++]=1;\\n        for(i=1;i<=numZeros;i++)\\n            arr[p++]=0;\\n        for(i=1;i<=numNegOnes;i++)\\n            arr[p++]=-1;\\n\\n\\n        for(i=0;i<k;i++)\\n            sum+=arr[i];\\n\\n\\n        return sum;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] arr=new int[numOnes+numZeros+numNegOnes];\\n        int p=0,sum=0,i;\\n        for(i=1;i<=numOnes;i++)\\n            arr[p++]=1;\\n        for(i=1;i<=numZeros;i++)\\n            arr[p++]=0;\\n        for(i=1;i<=numNegOnes;i++)\\n            arr[p++]=-1;\\n\\n\\n        for(i=0;i<k;i++)\\n            sum+=arr[i];\\n\\n\\n        return sum;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823136,
                "title": "python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        x=min(k,numOnes)\\n        k-=x\\n        if(k>0):\\n            k-=min(numZeros,k)\\n        if(k>0):\\n            x-=min(numNegOnes,k)\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        x=min(k,numOnes)\\n        k-=x\\n        if(k>0):\\n            k-=min(numZeros,k)\\n        if(k>0):\\n            x-=min(numNegOnes,k)\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822237,
                "title": "my-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<= numOnes)\\n        return k;\\n    k -= numOnes;\\n    if(k<= numZeros)\\n        return numOnes;\\n    k -= numZeros;\\n    return numNegOnes <= k? numOnes - numNegOnes: numOnes - k;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k){\\n    if(k<= numOnes)\\n        return k;\\n    k -= numOnes;\\n    if(k<= numZeros)\\n        return numOnes;\\n    k -= numZeros;\\n    return numNegOnes <= k? numOnes - numNegOnes: numOnes - k;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3819060,
                "title": "java-100-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(numOnes > k){\\n            return k;\\n        }else{\\n            sum += numOnes;\\n            k -= numOnes;\\n            if(k < numZeros){\\n                return sum;\\n            }else{\\n                k -= numZeros;\\n                return sum - k;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(numOnes > k){\\n            return k;\\n        }else{\\n            sum += numOnes;\\n            k -= numOnes;\\n            if(k < numZeros){\\n                return sum;\\n            }else{\\n                k -= numZeros;\\n                return sum - k;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816516,
                "title": "k-items-with-the-maximum-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(numOnes>0)\\n            {sum=sum+1;\\n            numOnes--;}\\n            else if(numZeros>0)\\n            {numZeros--;}\\n            else if(numNegOnes>0)\\n            {\\n                sum=sum-1;\\n                numNegOnes--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(numOnes>0)\\n            {sum=sum+1;\\n            numOnes--;}\\n            else if(numZeros>0)\\n            {numZeros--;}\\n            else if(numNegOnes>0)\\n            {\\n                sum=sum-1;\\n                numNegOnes--;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814226,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(max(numZeros,numNegOnes))\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res=0;\\n        if(numOnes>=k) return k;\\n        else if(k>numOnes){\\n            res+=numOnes;\\n            k-=numOnes;\\n            for(int i=1;i<=numZeros;i++){\\n                k--;\\n                if(k==0) return res;\\n            }\\n            if(k!=0){\\n                for(int i=0;i<=numNegOnes;i++){\\n                    res-=1;\\n                    k--;\\n                    if(k==0) return res;\\n                }\\n            }\\n        }\\n        return numOnes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int res=0;\\n        if(numOnes>=k) return k;\\n        else if(k>numOnes){\\n            res+=numOnes;\\n            k-=numOnes;\\n            for(int i=1;i<=numZeros;i++){\\n                k--;\\n                if(k==0) return res;\\n            }\\n            if(k!=0){\\n                for(int i=0;i<=numNegOnes;i++){\\n                    res-=1;\\n                    k--;\\n                    if(k==0) return res;\\n                }\\n            }\\n        }\\n        return numOnes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810654,
                "title": "easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        r=[1]*numOnes + [0]*numZeros + [-1]*numNegOnes\\n        s=0\\n        for i in range(k):\\n            s+=r[i]\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        r=[1]*numOnes + [0]*numZeros + [-1]*numNegOnes\\n        s=0\\n        for i in range(k):\\n            s+=r[i]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798383,
                "title": "only-2-if-solution-in-c",
                "content": "# Intuition\\nI devised a solution based on the following concept: If the value of k is less than the number of ones (numOnes), then the maximum possible sum is simply k itself. On the other hand, if k is greater than numOnes, we can try to fill the difference between k and numOnes with the available number of zeros (numZeros) to maximize the sum. In this case, we will return numOnes since we can use all the ones and add as many zeros as possible to achieve the highest sum, essentially considering only the ones.\\n\\nHowever, if both numOnes and numZeros are not greater than k, it means we still have a shortfall to reach k. In this scenario, we can use the remaining difference (k minus numOnes and numZeros) as the number of -1\\'s to be used in the sum. This way, we cover the gap between the number of ones and zeros and the required k, achieving the highest possible sum.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k-numOnes <= 0) return k;\\n        if(k - numOnes - numZeros <= 0  ) return numOnes;\\n        return numOnes-(k-numOnes-numZeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k-numOnes <= 0) return k;\\n        if(k - numOnes - numZeros <= 0  ) return numOnes;\\n        return numOnes-(k-numOnes-numZeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796864,
                "title": "using-deque",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        temp = deque()\\n        new = deque()\\n        total = numOnes + numZeros + numNegOnes\\n        for i in range(total):\\n            if numOnes>0:\\n                temp.appendleft(1)\\n                numOnes -= 1\\n                continue\\n            if numZeros>0:\\n                temp.append(0)\\n                numZeros -= 1\\n                continue\\n            if numNegOnes > 0:\\n                new.append(-1)\\n                numNegOnes -= 1\\n\\n        temp.extend(new)\\n        x = list(temp)\\n            \\n            \\n    \\n        \\n        return sum(x[:k])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        temp = deque()\\n        new = deque()\\n        total = numOnes + numZeros + numNegOnes\\n        for i in range(total):\\n            if numOnes>0:\\n                temp.appendleft(1)\\n                numOnes -= 1\\n                continue\\n            if numZeros>0:\\n                temp.append(0)\\n                numZeros -= 1\\n                continue\\n            if numNegOnes > 0:\\n                new.append(-1)\\n                numNegOnes -= 1\\n\\n        temp.extend(new)\\n        x = list(temp)\\n            \\n            \\n    \\n        \\n        return sum(x[:k])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791746,
                "title": "java-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int s=0;\\n        for(int i=0;i<numOnes;i++)\\n        {\\n            a.add(1);\\n        }\\n        for(int i=0;i<numZeros;i++)\\n        {\\n            a.add(0);\\n        }\\n        for(int i=0;i<numNegOnes;i++)\\n        {\\n            a.add(-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            s=s+a.get(i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int s=0;\\n        for(int i=0;i<numOnes;i++)\\n        {\\n            a.add(1);\\n        }\\n        for(int i=0;i<numZeros;i++)\\n        {\\n            a.add(0);\\n        }\\n        for(int i=0;i<numNegOnes;i++)\\n        {\\n            a.add(-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            s=s+a.get(i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788493,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int O, int Z, int N, int k) {\\n        int p=O-k;\\n        if(p<0){\\n          p=O+Z-k;\\n          if(p<0){\\n              int a=k-O-Z;\\n              return O-a;\\n\\n          }\\n          return O;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int O, int Z, int N, int k) {\\n        int p=O-k;\\n        if(p<0){\\n          p=O+Z-k;\\n          if(p<0){\\n              int a=k-O-Z;\\n              return O-a;\\n\\n          }\\n          return O;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781199,
                "title": "easiest-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        while(numOnes!=0 && k!=0){\\n            sum+=1;\\n         numOnes--;\\n         k--;\\n        }\\n        while(numZeros!=0 && k!=0){\\n            sum+=0;\\n            numZeros--;\\n            k--;\\n        }\\n        while(numNegOnes!=0 && k!=0){\\n            sum+=-1;\\n            numNegOnes--;\\n            k--;\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        while(numOnes!=0 && k!=0){\\n            sum+=1;\\n         numOnes--;\\n         k--;\\n        }\\n        while(numZeros!=0 && k!=0){\\n            sum+=0;\\n            numZeros--;\\n            k--;\\n        }\\n        while(numNegOnes!=0 && k!=0){\\n            sum+=-1;\\n            numNegOnes--;\\n            k--;\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772559,
                "title": "o-1-soluion-java-2600-k-items-with-the-maximum-sum",
                "content": "\\n# Complexity\\n```\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(k <= numOnes){\\n            if(k < numOnes){\\n                sum += k; \\n            }else{\\n                sum += numOnes;\\n            }\\n        }\\n        else if(k >numOnes && k <= numOnes + numZeros){\\n            sum += numOnes;\\n        }\\n        else if(k > numOnes + numZeros && k<= numOnes + numZeros + numNegOnes){\\n            k -= (numOnes + numZeros);\\n            sum += numOnes - k;\\n        }\\n\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\n- Time complexity:O(1)\\n\\n- Space complexity:O(1)\\n```\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n\\n        if(k <= numOnes){\\n            if(k < numOnes){\\n                sum += k; \\n            }else{\\n                sum += numOnes;\\n            }\\n        }\\n        else if(k >numOnes && k <= numOnes + numZeros){\\n            sum += numOnes;\\n        }\\n        else if(k > numOnes + numZeros && k<= numOnes + numZeros + numNegOnes){\\n            k -= (numOnes + numZeros);\\n            sum += numOnes - k;\\n        }\\n\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764757,
                "title": "easy-o-1-time-and-space-complexity-solution",
                "content": "\\n```cpp\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes >k){\\n            return k;\\n        }\\n        if(numOnes+numZeros > k){\\n            return numOnes;\\n        }\\n\\t\\t\\n\\t\\t// Subtracting the total numbers with k to get the negative numbers which are not selected\\n\\t\\t// Then subtract that number with the total negative numbers to get the negative numbers used.\\n        numNegOnes = numNegOnes - ((numOnes + numZeros + numNegOnes) - k);\\n\\t\\t\\n\\t\\t// Next just subtract/ add the negative numbers selected\\n        return numOnes - numNegOnes;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```cpp\\nint kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes >k){\\n            return k;\\n        }\\n        if(numOnes+numZeros > k){\\n            return numOnes;\\n        }\\n\\t\\t\\n\\t\\t// Subtracting the total numbers with k to get the negative numbers which are not selected\\n\\t\\t// Then subtract that number with the total negative numbers to get the negative numbers used.\\n        numNegOnes = numNegOnes - ((numOnes + numZeros + numNegOnes) - k);\\n\\t\\t\\n\\t\\t// Next just subtract/ add the negative numbers selected\\n        return numOnes - numNegOnes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764242,
                "title": "straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int p , int z , int n , int k){\\n        vector<int>v;\\n        int sum=0 , i=0;\\n        while(p--){\\n            v.push_back(1);\\n        }\\n        while(z--){\\n            v.push_back(0);\\n        }\\n        while(n--){\\n            v.push_back(-1);\\n        }\\n        while(k--){\\n            sum+=v[i++];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int p , int z , int n , int k){\\n        vector<int>v;\\n        int sum=0 , i=0;\\n        while(p--){\\n            v.push_back(1);\\n        }\\n        while(z--){\\n            v.push_back(0);\\n        }\\n        while(n--){\\n            v.push_back(-1);\\n        }\\n        while(k--){\\n            sum+=v[i++];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752488,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    let sum = 0;\\n    let count = 0;\\n    const total = numOnes + numZeros\\n    for (let i = 0; i < k; i++) {\\n        count++\\n        if(count <= numOnes) sum++\\n        else if(count > total) sum--\\n    }\\n    return sum  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    let sum = 0;\\n    let count = 0;\\n    const total = numOnes + numZeros\\n    for (let i = 0; i < k; i++) {\\n        count++\\n        if(count <= numOnes) sum++\\n        else if(count > total) sum--\\n    }\\n    return sum  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748930,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    if (k <= numOnes) return k\\n    if (k <= numOnes + numZeros) return numOnes\\n    k -= numOnes + numZeros\\n    return numOnes - k\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    if (k <= numOnes) return k\\n    if (k <= numOnes + numZeros) return numOnes\\n    k -= numOnes + numZeros\\n    return numOnes - k\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747316,
                "title": "easy-c-solution-basic-if-else-cases-tc-sc-both-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O ( 1 )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O ( 1 )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n        {\\n            return k;\\n        }\\n        if(k <= (numOnes + numZeros))\\n        {\\n            return numOnes;\\n        }\\n        else\\n        {\\n            return numOnes + ((k - (numOnes + numZeros)) * (-1));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k <= numOnes)\\n        {\\n            return k;\\n        }\\n        if(k <= (numOnes + numZeros))\\n        {\\n            return numOnes;\\n        }\\n        else\\n        {\\n            return numOnes + ((k - (numOnes + numZeros)) * (-1));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747146,
                "title": "elvis-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return k - numOnes < 0\\n                ? k\\n                : k - numOnes - numZeros < 0\\n                    ? numOnes\\n                    : numOnes + (k - numOnes - numZeros) * (-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return k - numOnes < 0\\n                ? k\\n                : k - numOnes - numZeros < 0\\n                    ? numOnes\\n                    : numOnes + (k - numOnes - numZeros) * (-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745335,
                "title": "100-beating-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)return k;\\n        else if(k-numOnes <=numZeros) return numOnes;\\n        else return numOnes-(k-numOnes-numZeros);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)return k;\\n        else if(k-numOnes <=numZeros) return numOnes;\\n        else return numOnes-(k-numOnes-numZeros);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742535,
                "title": "java-o-1-solution",
                "content": "# Intuition\\nThe goal is to select k items with the maximum possible sum from three different categories: numOnes, numZeros, and numNegOnes. We need to consider the number of ones (numOnes), zeros (numZeros), and negative ones (numNegOnes) available to determine the maximum sum we can achieve.\\n\\n# Approach\\n1. If the number of ones (numOnes) is greater than or equal to k, we can simply select k ones to achieve the maximum sum of k. Thus, we return k as the answer.\\n2. If k is greater than the number of ones (numOnes), we need to consider the remaining items to achieve the maximum sum.\\n3. Calculate the remaining items needed after selecting all ones: a = k - numOnes.\\n4. If a is less than the number of zeros (numZeros), it means we have enough zeros to fill the remaining slots. In this case, the maximum sum we can achieve is the total number of ones (numOnes), as we can select all the ones and fill the remaining slots with zeros. Thus, we return numOnes as the answer.\\n5. If a is greater than or equal to the number of zeros (numZeros), it means we don\\'t have enough zeros to fill all the remaining slots. We need to consider negative ones (numNegOnes) as well.\\n6. Calculate the number of additional slots that still need to be filled after selecting all ones and zeros: p = a - numZeros.\\n7. Subtract p from the total number of ones (numOnes) to get the maximum sum we can achieve, as we have already accounted for all ones and filled the remaining slots with zeros.\\n8. Return the calculated maximum sum (ans) as the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n      if(numOnes>=k) return k;\\n      int ans = 0;\\n      if(k>numOnes){\\n        int a = k-numOnes;\\n        if(a<numZeros){\\n          ans = numOnes;\\n          return ans;\\n        }else{\\n          int p = a-numZeros;\\n          ans = numOnes-p;\\n        }\\n      }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n      if(numOnes>=k) return k;\\n      int ans = 0;\\n      if(k>numOnes){\\n        int a = k-numOnes;\\n        if(a<numZeros){\\n          ans = numOnes;\\n          return ans;\\n        }else{\\n          int p = a-numZeros;\\n          ans = numOnes-p;\\n        }\\n      }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740868,
                "title": "2-lines-code-vv-simple-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=(numOnes+numZeros))\\n        {\\n            return min(numOnes,k);\\n        }\\n        else\\n        {\\n            return numOnes-(k-(numOnes+numZeros));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=(numOnes+numZeros))\\n        {\\n            return min(numOnes,k);\\n        }\\n        else\\n        {\\n            return numOnes-(k-(numOnes+numZeros));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740245,
                "title": "java-simple-solution-for-kitemswithmaximumsum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        if(numOnes>=k)\\n        return k;\\n        else\\n        {\\n            sum=numOnes;\\n            k=k-numOnes;\\n            if(numZeros>=k)\\n            return sum;\\n            else\\n            {\\n                k-=numZeros;\\n            }\\n        }\\n        return sum-k;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum=0;\\n        if(numOnes>=k)\\n        return k;\\n        else\\n        {\\n            sum=numOnes;\\n            k=k-numOnes;\\n            if(numZeros>=k)\\n            return sum;\\n            else\\n            {\\n                k-=numZeros;\\n            }\\n        }\\n        return sum-k;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739515,
                "title": "simple-and-easy-solution-rust-tm",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n    pub fn k_items_with_maximum_sum(num_ones: i32, num_zeros: i32, num_neg_ones: i32, k: i32) -> i32 {\\n        let mut temp_k: i32 = k;\\n        let ones: i32 = if temp_k >= num_ones {temp_k -= num_ones; num_ones} else {let temp_k_2 = temp_k; temp_k = 0; temp_k_2};\\n        let zeros: i32 = if temp_k >= num_zeros {temp_k -= num_zeros; 0} else {temp_k = 0; 0};\\n        let neg_ones: i32 = if temp_k >= num_neg_ones {temp_k -= num_neg_ones; num_neg_ones} else {let temp_k_2 = temp_k; temp_k = 0; temp_k_2};\\n        // println!(\"ones:{}\\\\nzeros:{}\\\\nneg_ones:{}\", ones, zeros, neg_ones);\\n\\n        ones + zeros - neg_ones\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn k_items_with_maximum_sum(num_ones: i32, num_zeros: i32, num_neg_ones: i32, k: i32) -> i32 {\\n        let mut temp_k: i32 = k;\\n        let ones: i32 = if temp_k >= num_ones {temp_k -= num_ones; num_ones} else {let temp_k_2 = temp_k; temp_k = 0; temp_k_2};\\n        let zeros: i32 = if temp_k >= num_zeros {temp_k -= num_zeros; 0} else {temp_k = 0; 0};\\n        let neg_ones: i32 = if temp_k >= num_neg_ones {temp_k -= num_neg_ones; num_neg_ones} else {let temp_k_2 = temp_k; temp_k = 0; temp_k_2};\\n        // println!(\"ones:{}\\\\nzeros:{}\\\\nneg_ones:{}\", ones, zeros, neg_ones);\\n\\n        ones + zeros - neg_ones\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739383,
                "title": "a-simple-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        sum += Math.min(numOnes, k);\\n        k -= Math.min(numOnes, k);\\n        k -= Math.min(numZeros, k);\\n        sum -= Math.min(numNegOnes, k);\\n        k -= Math.min(numNegOnes, k);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = 0;\\n        sum += Math.min(numOnes, k);\\n        k -= Math.min(numOnes, k);\\n        k -= Math.min(numZeros, k);\\n        sum -= Math.min(numNegOnes, k);\\n        k -= Math.min(numNegOnes, k);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732942,
                "title": "c-o-1-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes) {\\n            return k;\\n        }\\n        if (k <= numOnes+numZeros) {\\n            return numOnes;\\n        }\\n        return numOnes - (k - numOnes - numZeros);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (k <= numOnes) {\\n            return k;\\n        }\\n        if (k <= numOnes+numZeros) {\\n            return numOnes;\\n        }\\n        return numOnes - (k - numOnes - numZeros);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732620,
                "title": "python3-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int\\n                             , numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - max(k - numOnes - numZeros, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int\\n                             , numNegOnes: int, k: int) -> int:\\n        return min(k, numOnes) - max(k - numOnes - numZeros, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727361,
                "title": "my-first-solution-that-i-posting-pre-junior-stage-c-solution-beats-100-runtime-98-memory",
                "content": "# Intuition\\nSolving this problem with two vars (count and numOnes)\\n# Approach\\n1)First of all , if we don\\'t need to do any operations with our 1s and 0s , we decreasing our 1s to time it will be = k.\\n\\n2)In second case , we need to do some simple , maybe little awkward operations to solve the problem (if(numOnes + numZeros < k)) , and my first action in the our second case , i\\'m creating the variable named count , to count bag capacity that already occupied by our numOnes and numZeros . \\n\\n3)And if count smaller than k i decreasing numOnes(counting the answer) , because to satisfy k ( !because! it\\'s not avalaible zeros , so we need decrease numOnes , no choice ) , then i\\'m increasing count to don\\'t have any endless cycle. \\n\\n4)After all i returning the numOnes , and the problem get solved . \\n\\n5???)Maybe there\\'s don\\'t need to have else case , i\\'ve no checked it , sorry  \\n\\nBB to y\\'all ! gl\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        //1)\\n        if(numOnes + numZeros >= k){while(numOnes > k){numOnes--;}return numOnes;}\\n        //2)\\n        else if(numOnes + numZeros < k){\\n            int count = numOnes + numZeros;\\n        //3 \\n            while(count < k){\\n                numOnes--;\\n                count++;\\n            }\\n        //4\\n            return numOnes;\\n        }\\n        //5???\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        //1)\\n        if(numOnes + numZeros >= k){while(numOnes > k){numOnes--;}return numOnes;}\\n        //2)\\n        else if(numOnes + numZeros < k){\\n            int count = numOnes + numZeros;\\n        //3 \\n            while(count < k){\\n                numOnes--;\\n                count++;\\n            }\\n        //4\\n            return numOnes;\\n        }\\n        //5???\\n        else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709426,
                "title": "c-easy-to-understand",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/7385b5f8-9366-42c6-8cba-fd34b6611e00_1688316987.6309757.png)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (numOnes >= k)\\n        {\\n            return k;\\n        }\\n\\n        if (numOnes + numZeros >= k)\\n        {\\n            return numOnes;\\n        }\\n\\n        for (int i = 1; i <= numNegOnes; i++)\\n        {\\n            if (numOnes + numZeros + i >= k)\\n            {\\n                return numOnes - i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if (numOnes >= k)\\n        {\\n            return k;\\n        }\\n\\n        if (numOnes + numZeros >= k)\\n        {\\n            return numOnes;\\n        }\\n\\n        for (int i = 1; i <= numNegOnes; i++)\\n        {\\n            if (numOnes + numZeros + i >= k)\\n            {\\n                return numOnes - i;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700926,
                "title": "one-liner-code-with-great-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep1\\nThe expression min(k, numOnes) calculates the minimum value between k and numOnes. This ensures that if k is greater than numOnes, the result will be numOnes because we cannot select more items than are available (numOnes represents the count of ones available).\\n\\nStep2\\nThe expression k - numZeros - numOnes calculates the remaining number of items (numNegOnes) that can be selected. It subtracts the count of zeros (numZeros) and the count of ones (numOnes) from k. This is done to ensure that we don\\'t select more zeros and ones than the available count (k represents the maximum number of items that can be selected).\\n\\nStep3\\nThe expression max(0, k - numZeros - numOnes) calculates the maximum value between 0 and the remaining number of items calculated in step 2. This ensures that we don\\'t have a negative count of remaining items, as a negative count doesn\\'t make sense in this context.\\n\\nStep4\\nThe expression min(k, numOnes) - max(0, k - numZeros - numOnes) subtracts the maximum count of remaining items (from step 3) from the minimum count of ones (from step 1). This gives us the final result, which represents the count of items to be selected from the available ones, while ensuring that we don\\'t exceed the maximum number of items (k) or have a negative count.\\n\\nThe result (ans) is returned as the output of the function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       int ans = min(k,numOnes) - max(0, k-numZeros-numOnes);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       int ans = min(k,numOnes) - max(0, k-numZeros-numOnes);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691658,
                "title": "java-easy-sol-using-if-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int x=0;\\n        if(k<=numOnes)\\n        x=k;\\n        if( k>numOnes && k<=(numOnes+numZeros))\\n        x=numOnes;\\n        if(k>(numOnes+numZeros) && k<=(numOnes+numZeros+numNegOnes)) \\n        x=(numOnes-(k-(numOnes+numZeros)));\\n\\n        return x;\\n\\n    }\\n}\\n\\n//numOnes 3, int numZeros 2, int numNegOnes 2   k=7\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int x=0;\\n        if(k<=numOnes)\\n        x=k;\\n        if( k>numOnes && k<=(numOnes+numZeros))\\n        x=numOnes;\\n        if(k>(numOnes+numZeros) && k<=(numOnes+numZeros+numNegOnes)) \\n        x=(numOnes-(k-(numOnes+numZeros)));\\n\\n        return x;\\n\\n    }\\n}\\n\\n//numOnes 3, int numZeros 2, int numNegOnes 2   k=7\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690726,
                "title": "python-easy-solution",
                "content": "e\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if k - numOnes < 1:\\n            return k\\n        elif k - numOnes - numZeros < 1:\\n            return numOnes\\n        else:\\n            return 2 * numOnes + numZeros - k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        if k - numOnes < 1:\\n            return k\\n        elif k - numOnes - numZeros < 1:\\n            return numOnes\\n        else:\\n            return 2 * numOnes + numZeros - k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688974,
                "title": "java-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes + numZeros >= k){\\n            return Math.min(numOnes,k);\\n        }else{\\n            return numOnes - (k - (numOnes + numZeros));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(numOnes + numZeros >= k){\\n            return Math.min(numOnes,k);\\n        }else{\\n            return numOnes - (k - (numOnes + numZeros));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676273,
                "title": "java-o-1",
                "content": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<numOnes){\\n            return k;\\n        }\\n        if(k<=numOnes+numZeros){\\n            return numOnes;\\n        }\\n        if(k>numOnes+numZeros){\\n            return numOnes+(k-numOnes-numZeros)*(-1);\\n        }\\n        return numOnes-numNegOnes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<numOnes){\\n            return k;\\n        }\\n        if(k<=numOnes+numZeros){\\n            return numOnes;\\n        }\\n        if(k>numOnes+numZeros){\\n            return numOnes+(k-numOnes-numZeros)*(-1);\\n        }\\n        return numOnes-numNegOnes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674894,
                "title": "easy-if-you-are-beginner-and-stupid-if-your-are-pro-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<numOnes;i++){\\n            ans.add(1);\\n        }\\n\\n        for(int j=0;j<numZeros;j++){\\n            ans.add(0);\\n        }\\n\\n        for(int i=0;i<numNegOnes;i++){\\n            ans.add(-1);\\n        }\\n\\n        System.out.println(ans.toString());\\nint sum =0;\\n        for(int i=0;i<ans.size();i++){\\n            if(i<k){\\n                sum += ans.get(i);\\n            }\\n        }\\n\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<numOnes;i++){\\n            ans.add(1);\\n        }\\n\\n        for(int j=0;j<numZeros;j++){\\n            ans.add(0);\\n        }\\n\\n        for(int i=0;i<numNegOnes;i++){\\n            ans.add(-1);\\n        }\\n\\n        System.out.println(ans.toString());\\nint sum =0;\\n        for(int i=0;i<ans.size();i++){\\n            if(i<k){\\n                sum += ans.get(i);\\n            }\\n        }\\n\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674371,
                "title": "o-1-complexity-easy-oneliner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int n1s, int n0s, int NegOnes, int k) {\\n        if(n1s > k) return k;\\n        if(n1s + n0s >= k) return n1s;\\n                        //actually it is sum = 1*nls+0*n0s\\n        else           //case when : (n1s + n0s) < k\\n        {\\n            return 1*n1s + (k-n1s-n0s)*(-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int n1s, int n0s, int NegOnes, int k) {\\n        if(n1s > k) return k;\\n        if(n1s + n0s >= k) return n1s;\\n                        //actually it is sum = 1*nls+0*n0s\\n        else           //case when : (n1s + n0s) < k\\n        {\\n            return 1*n1s + (k-n1s-n0s)*(-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672756,
                "title": "one-line-easy-to-understand-runtime-beats-74-15",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    return numOnes >= k ? k : numOnes + numZeros >= k ? numOnes : ((k - numOnes - numZeros) * -1) + numOnes \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} numOnes\\n * @param {number} numZeros\\n * @param {number} numNegOnes\\n * @param {number} k\\n * @return {number}\\n */\\nvar kItemsWithMaximumSum = function(numOnes, numZeros, numNegOnes, k) {\\n    return numOnes >= k ? k : numOnes + numZeros >= k ? numOnes : ((k - numOnes - numZeros) * -1) + numOnes \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3663419,
                "title": "simplest-java-solution-easy-to-understand-must-see-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max=0;\\n        \\n        while(k>0)\\n        {\\n        if(numOnes>0)\\n           {\\n               numOnes--;\\n               max++;\\n               k--;\\n           }\\n           else if(numZeros > 0)\\n           {\\n               numZeros--;\\n               k--;\\n           }\\n           else\\n           {\\n               numNegOnes--;\\n               max--;\\n               k--;\\n           }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int max=0;\\n        \\n        while(k>0)\\n        {\\n        if(numOnes>0)\\n           {\\n               numOnes--;\\n               max++;\\n               k--;\\n           }\\n           else if(numZeros > 0)\\n           {\\n               numZeros--;\\n               k--;\\n           }\\n           else\\n           {\\n               numNegOnes--;\\n               max--;\\n               k--;\\n           }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655782,
                "title": "k-items-with-maximum-sum-easy-approach-simple-and-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int ans=0;\\n        if(numOnes>0 && k>0)\\n        {\\n            ans+=min(numOnes,k);\\n            k-=ans;\\n        }\\n        if(k>0 && numZeros>0)\\n        {\\n            k-=min(k,numZeros);\\n        }\\n        if(k>0 && numNegOnes>0)\\n        {\\n            ans-=min(numNegOnes,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) \\n    {\\n        int ans=0;\\n        if(numOnes>0 && k>0)\\n        {\\n            ans+=min(numOnes,k);\\n            k-=ans;\\n        }\\n        if(k>0 && numZeros>0)\\n        {\\n            k-=min(k,numZeros);\\n        }\\n        if(k>0 && numNegOnes>0)\\n        {\\n            ans-=min(numNegOnes,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653511,
                "title": "easy-solution-beats-100-runtime-using-if-else-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPLEASE UPVOTE!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n        {\\n            return 1*k;\\n        }\\n        else if(k<=numOnes+numZeros)\\n        {\\n            return (1*(numOnes)+0*(k-numOnes));\\n        }\\n        else\\n        {\\n            return (1*numOnes+0*numZeros+(-1)*(k-numOnes-numZeros));\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        if(k<=numOnes)\\n        {\\n            return 1*k;\\n        }\\n        else if(k<=numOnes+numZeros)\\n        {\\n            return (1*(numOnes)+0*(k-numOnes));\\n        }\\n        else\\n        {\\n            return (1*numOnes+0*numZeros+(-1)*(k-numOnes-numZeros));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647499,
                "title": "beats-100-0ms-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       if(numOnes>=k)\\n         return k;\\n       else if(numOnes+numZeros>=k)\\n           return numOnes;\\n       else if(k>numOnes&&k>numZeros)    \\n           return numOnes-(k-(numOnes+numZeros)); \\n        return 0;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n       if(numOnes>=k)\\n         return k;\\n       else if(numOnes+numZeros>=k)\\n           return numOnes;\\n       else if(k>numOnes&&k>numZeros)    \\n           return numOnes-(k-(numOnes+numZeros)); \\n        return 0;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643327,
                "title": "while-if",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        ans=0\\n        while k:\\n            if numOnes:\\n                x=min(k,numOnes)\\n                ans+= x\\n                k-=x\\n                numOnes-=x\\n            if numZeros:\\n                x=min(k,numZeros)\\n                k-=x\\n                numOnes-=x\\n            if numNegOnes:\\n                x=min(k,numNegOnes)\\n                ans-= x\\n                k-=x\\n                numOnes-=x\\n\\n        return ans\\n            \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\\n        ans=0\\n        while k:\\n            if numOnes:\\n                x=min(k,numOnes)\\n                ans+= x\\n                k-=x\\n                numOnes-=x\\n            if numZeros:\\n                x=min(k,numZeros)\\n                k-=x\\n                numOnes-=x\\n            if numNegOnes:\\n                x=min(k,numNegOnes)\\n                ans-= x\\n                k-=x\\n                numOnes-=x\\n\\n        return ans\\n            \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631816,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return k <= numOnes + numZeros ? min(k, numOnes) : 2 * numOnes + numZeros - k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        return k <= numOnes + numZeros ? min(k, numOnes) : 2 * numOnes + numZeros - k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622882,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] res = new int[numOnes + numZeros + numNegOnes];\\n        for(int i = 0; i < numOnes; i++){\\n            res[i] = 1;\\n        }\\n\\n        for(int i = 0; i < numZeros; i++){\\n            res[i + numOnes] = 0;\\n        }\\n\\n        for(int i = 0; i < numNegOnes; i++){\\n            res[i + numOnes + numZeros] = -1;\\n        }\\n        //System.out.println(list);\\n        int sum = 0;\\n        for(int i = 0; i < k; i++){\\n            sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int[] res = new int[numOnes + numZeros + numNegOnes];\\n        for(int i = 0; i < numOnes; i++){\\n            res[i] = 1;\\n        }\\n\\n        for(int i = 0; i < numZeros; i++){\\n            res[i + numOnes] = 0;\\n        }\\n\\n        for(int i = 0; i < numNegOnes; i++){\\n            res[i + numOnes + numZeros] = -1;\\n        }\\n        //System.out.println(list);\\n        int sum = 0;\\n        for(int i = 0; i < k; i++){\\n            sum += res[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621606,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to just see that 1 will be given priority over 0 and -1 through greedy approach just run 3 wil loop with k condition \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple 3 while loop apporach \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n             while(k>0 && numOnes>0){\\n               ans++;\\n               numOnes--;\\n               k--;\\n           }\\n           \\n           while( k>0 && numZeros>0){\\n               ans+=0;\\n              numZeros--;\\n              k--;\\n           }\\n           \\n             while(k>0 && numNegOnes>0){\\n               ans+=-1;\\n               numNegOnes--;\\n               k--;\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int ans=0;\\n             while(k>0 && numOnes>0){\\n               ans++;\\n               numOnes--;\\n               k--;\\n           }\\n           \\n           while( k>0 && numZeros>0){\\n               ans+=0;\\n              numZeros--;\\n              k--;\\n           }\\n           \\n             while(k>0 && numNegOnes>0){\\n               ans+=-1;\\n               numNegOnes--;\\n               k--;\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610287,
                "title": "c-easy-and-readable-solution-faster-than-73",
                "content": "![image.png](https://assets.leetcode.com/users/images/e5c8dded-81c3-4fa4-8e56-f53605322ee7_1686160469.9059005.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = Math.Min(numOnes, k);\\n        k -= sum;\\n        k -= Math.Min(numZeros, k);\\n        return sum - Math.Min(numNegOnes, k);\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\\n        int sum = Math.Min(numOnes, k);\\n        k -= sum;\\n        k -= Math.Min(numZeros, k);\\n        return sum - Math.Min(numNegOnes, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1843761,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach :-)***\\n\\n- Initialize a variable sum to 0.\\n- If k is 0, return 0.\\n- Select the minimum of numOnes and k elements of 1s. Add this count to sum, subtract this count from k, and update the count of remaining 1s.\\n- Select the minimum of numZeros and k elements of 0s. Subtract this count from k.\\n- Select the minimum of numNegOnes and k elements of -1s. Subtract this count from k, and subtract this count from sum.\\n- Return sum as the maximum sum of k elements."
                    }
                ]
            }
        ]
    }
]