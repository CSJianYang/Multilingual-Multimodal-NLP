[
    {
        "title": "Find Palindrome With Fixed Length",
        "question_content": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.\n&nbsp;\nExample 1:\n\nInput: queries = [1,2,3,4,5,90], intLength = 3\nOutput: [101,111,121,131,141,999]\nExplanation:\nThe first few palindromes of length 3 are:\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\nThe 90th palindrome of length 3 is 999.\n\nExample 2:\n\nInput: queries = [2,4,6], intLength = 4\nOutput: [1111,1331,1551]\nExplanation:\nThe first six palindromes of length 4 are:\n1001, 1111, 1221, 1331, 1441, and 1551.\n\n&nbsp;\nConstraints:\n\n\t1 <= queries.length <= 5 * 104\n\t1 <= queries[i] <= 109\n\t1 <= intLength&nbsp;<= 15",
        "solutions": [
            {
                "id": 1886915,
                "title": "formula",
                "content": "Only the first `(intLength + 1) / 2` characters matter. The remaining characters are just a reflection.\\n\\nSay `intLength == 7`, so we consider only 4 characters. The minimum number is `1000` and maximum - `9999`.\\n\\nTherefore, we can have `9999 - 1000 + 1 == 9000` palindromes. To find out the palindrome, we add a `q - 1` to the minimum number, reverse, and concatenate.\\n\\nFor example, for query `8765`, the base number is `1000 + 8765 - 1 == 9764`. Concatenating it with `679`, we get `9764679` as the result.\\n\\n**C++**\\nThe code could be shorter if we use string operations, but I wanted to avoid those for the efficiency. \\n\\n```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint reverse(long long n, bool skip) {\\n    long long res = 0;\\n    for (n = skip ? n / 10 : n; n > 0; n /= 10)\\n        res = res * 10 + n % 10;\\n    return res;\\n}\\nvector<long long> kthPalindrome(vector<int>& queries, int sz) {\\n    vector<long long> res;\\n    long long start = pow(10, (sz + 1) / 2 - 1), end = pow(10, (sz + 1 ) / 2), mul = pow(10, sz / 2);    \\n    for (int q : queries)\\n        res.push_back(start + q > end ? -1 : \\n            (start + q - 1) * mul + reverse(start + q - 1, sz % 2));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887014,
                "title": "simple-java-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}else{\\n\\t\\t\\t\\tresult[i++]=-1;\\n\\t\\t\\t}\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n/*\\nFirst Palindrome of length 4 = \"10\"+\"01\"\\nFirst Palindrome of length 3 = \"10\"+\"_1\" (without first character 0)\\nFirst half can range from 10 (which is 10^1) to 99 (which is 10^2-1)\\n*/\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] result = new long[queries.length];\\n        int i = 0;\\n        for(int num: queries){\\n\\t\\t\\tlong half = (intLength+1)/2;//half for 3 =2, half for 4 = 2\\n\\t\\t\\tlong start = (long)Math.pow(10,half-1);\\n\\t\\t\\tlong end = (long)Math.pow(10,half)-1;\\n\\t\\t\\tif(num<=(end-start+1)){ //check if query is within range\\n\\t\\t\\t\\tString firstHalfOfPalindrome = ((start)+ (num-1))+\"\";\\n\\t\\t\\t\\tString secondHalf = (new StringBuffer(firstHalfOfPalindrome)).reverse().toString();\\n\\t\\t\\t\\tresult[i++] = Long.parseLong(firstHalfOfPalindrome+secondHalf.substring(intLength%2)); // since half is calculated as 1 extra for odd numbers, remove the first char for odd length in substring - 1001 vs 10+(0)1 \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1887170,
                "title": "python-half-of-the-palindromes",
                "content": "# **Intuition**\\nThe first half part of palindrome is ordered.\\nNot leading zeros allowd, so ther starts with 100000, 100001, 100002..\\nEvery number is added a base in pow of 10.\\n<br>\\n\\n# **Explanation**\\nFind the base that we need to add to every element.\\nThe pow equals to the half of the length `l`.\\n\\nFor each query index `q`,\\nwe firstly turn it `q - 1`, whichis 0-based index,\\nthen add it with the base.\\n\\nFinally we make it palindrome by add its reversed string.\\n<br>\\n\\n# **Complexity**\\nTime `O(nl)`\\nSpace `O(nl)`\\n<br>\\n\\n**Python**\\n```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def kthPalindrome(self, queries, l):\\n        base = 10 ** ((l - 1) / 2)\\n        res = [q - 1 + base for q in queries]\\n        for i,a in enumerate(res):\\n            a = str(a) + str(a)[-1 - l % 2::-1]\\n            res[i] = int(a) if len(a) == l else -1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886954,
                "title": "c-easy-stimulation-explanation",
                "content": "## Intuition\\n\\n**Case 1:**\\nintLength = 4 (even)\\nPalindromes will be\\n1001, 1111, 2222, ..., 9999\\n10 + 01\\n11 + 11\\n12 + 12\\nSo, we can take base value as 10 ^ (n / 2 - 1) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse it to make palindorme\\n\\n**Case 2:**\\nintLength = 5 (odd)\\nPalindromes will be\\n10001, 10101, 10201, ..., 11011, 11111, 11211, ..., 12021, 12121, 12321, ...\\n**10**0 + 01\\n**10**1 + 01\\n\\t:\\n\\t:\\n**11**0 + 11\\n**11**1 + 11\\n\\t:\\n\\t:\\n**12**0 + 21\\n**12**1 + 21\\nFor odd length, we can take base value as 10 ^ (n / 2) and add query - 1 (as we have to consider 0) to get the first half of palindrome, we can simply reverse and exclude the start digit to make palindorme\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Time Complexity:** O(q * l), where q = no of queries and l = intLength\\n**Space Complexity:** O(q * l), for result array",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<ll> result;\\n        ll start = intLength % 2 == 0 ? pow(10, intLength/2 - 1) : pow(10, intLength/2);\\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886972,
                "title": "java-detailed-explanation-with-the-reference-link",
                "content": "First, we can simplify the problem because we only need to look at the first half of the digits (rounding up if there are an odd number of digits). I will call the first set of digits significant digits and the rest non-significant digits.\\n\\nThis is because the non-significant digits must match the significant digits (in reverse). It is not possible to have another palindrome number with the same leading significant digits and different non-significant digits. The significant digits determine the entire palindrome number.\\n\\nNow, we just need to come up with an algorithm to generate the nth valid significant digits. This would be easier if we allowed for leading zeros, so we\\'ll come up with the algorithm that allows for leading zeros, then tweak the algorithm.\\n\\nThe first few palindromes (significant digits) would be:\\n\\n1: 0000\\n2: 0001\\n3: 0002\\n...\\n100: 0099\\nSo we can find the significant digits of the nth number by finding the decimal representation of (n-1).\\n\\nTo tweak the algorithm to work when not allowing leading zeros, we would start with a one as the leading digit:\\n\\n1: 1000\\n2: 1001\\n3: 1002\\n...\\n100: 1099\\nThis boils down to finding the decimal representation of (n-1) + 1000 = n + 999 and expanding into a full palindrome:\\n\\nExample: Find the 113th palindrome of length 9.\\n\\nDetermine number of digits to look at: Round up(9 / 2) = 5 --> only look at first 5 digits.\\nFind number to add to get rid of leading zeros: 10^(5-1) = 10000\\nUse formula: (113 - 1) + 10000 = 10112\\nExpanded into palindrome: 101121101\\nOn a side note, this algorithm could also be generalized to finding the nth palindrome of any ordered set of symbols (or alphabet).\\n\\nGeneralized algorithm:\\n\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nReference: https://stackoverflow.com/questions/11925840/how-to-calculate-nth-n-digit-palindrome-efficiently\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```\\n\\nPlease upvote if you find this helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        long maxNumber = 0;\\n        for(int i=0;i<intLength;i++){\\n            maxNumber = maxNumber*10+9;\\n        }\\n        for(int i=0;i<n;i++){\\n            int nth = queries[i]; \\n            int k = intLength;\\n            long temp = ((k&1) == 1) ? (k / 2) : (k/2 - 1);\\n            long palin = (long)Math.pow(10,temp);\\n            \\n            palin += nth - 1;\\n            temp = palin;\\n            if ((k&1)==1){\\n                palin/=10;\\n            }\\n        \\n            while(palin>0){\\n                temp  = temp*10 + palin%10;\\n                palin/=10;\\n            }\\n            if(maxNumber<temp || temp<0){\\n                temp = -1;\\n            }\\n            ans[i] = temp;\\n        }\\n        return ans;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887018,
                "title": "c-generate-palindromes",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n**Similar problems**:\\n* [479. Largest Palindrome Product (Hard)](https://leetcode.com/problems/largest-palindrome-product/)\\n* [866. Prime Palindrome (Medium)](https://leetcode.com/problems/prime-palindrome/)\\n* [906. Super Palindromes (Hard)](https://leetcode.com/problems/super-palindromes/)\\n* [2081. Sum of k-Mirror Numbers (Hard)](https://leetcode.com/problems/sum-of-k-mirror-numbers/)\\n\\n## Solution 1.\\n\\nLet `half` be the first half of the palindrome. The range of it is `begin = 10^((len-1)/2)` (inclusive) to `end = 10^((len+1)/2)` (exclusive).\\n\\nFor a given `rank = Q[i]`, `half = begin + Q[i] - 1`. We can use `getPalindrome` helper function to generate the palindrome.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-palindrome-with-fixed-length/\\n// Author: github.com/lzl124631x\\n// Time: O(QL)\\n// Space: O(1) extra space\\nclass Solution {\\n    long getPalindrome(long half, bool odd) {\\n        long pal = half;\\n        if (odd) half /= 10;\\n        for (; half; half /= 10) pal = pal * 10 + half % 10;\\n        return pal;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int len) {\\n        long begin = pow(10L, (len - 1) / 2), end = pow(10L, (len + 1) / 2);\\n        vector<long long> ans(Q.size(), -1);\\n        for (int i = 0; i < Q.size(); ++i) {\\n            long half = begin + Q[i] - 1;\\n            if (half < end) ans[i] = getPalindrome(half, len % 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887508,
                "title": "simple-pattern-recognition-with-explanation",
                "content": "If we have a string s of length k and string t which is reverse of s\\nthen we can make a palindrome of size of 2*k and 2*k-1 ( if we leave last character of s will adding t to s)\\nLet s=\"aab\" then t=\"baa\" and k=3\\npalindrome of length of 6 is \"aabbaa\" which is s+t\\npalindrome of length of 5 is \"aabaa\" which is s+t.substr(1)\\n\\n*Complexity*\\n\\nTime O(n)\\nSpace O(n) \\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        int k=(l+1)/2,start=pow(10,k-1),end=pow(10,k)-1;\\n        vector<long long> A;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int a=start+q[i]-1;     //Since the palindromes are in order \\'a\\' is the half palindeome of the required palindrome \\n            if(a>end)               //We want the number of length \\'k\\', if it crosses the length \\'k\\' then our output will be \\'-1\\'\\n            {\\n                A.push_back(-1);\\n                continue;\\n            }\\n            string s=to_string(a),t=s;\\n            reverse(t.begin(),t.end());\\n            if(l%2==0)\\n            {\\n                s+=t;               //Number is \"321\" then palindrome of even length will be \"321\" \"123\"\\n                A.push_back(stoll(s));\\n            }\\n            else\\n            {\\n                s+=t.substr(1);     //Number is \"321\" then palindrome of odd length will be \"321\" \"_23\"\\n                A.push_back(stoll(s));\\n            }\\n        }\\n        return A;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888763,
                "title": "java-solution-highly-commented-readable-easy-understanding",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int n) {\\n        long[] ans = new long[queries.length];\\n        \\n        int halfLength = (n+1)/2; //why n+1 because of odd length numbers\\n        \\n        long start = (long)Math.pow(10,halfLength-1);   //this you need to figure it out by taking example like n = 4\\n        long end = (long)Math.pow(10,halfLength)-1;     //this you need to figure it out\\n       \\n      long total = end-start+1;\\n      for(int i=0;i<queries.length;i++){\\n         if(queries[i]<=total){\\n             \\n             String left = Long.toString(start+queries[i]-1);   //little bitch trick\\n             \\n            StringBuilder temp = new StringBuilder(left);\\n             String right = temp.reverse().toString();\\n             \\n             //this to handling for odd strings example for 4 -> 1001 but for 3 also it is 1001\\n             //but we don\\'t want 1001 for 3 int length instead we want 101 so we have to remove o from right string which this formula likely to do\\n             ans[i] = Long.parseLong(left+right.substring(n%2));\\n             \\n         }\\n          else\\n             ans[i] = -1;\\n      }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887453,
                "title": "detailed-explanation-with-comments-easy-solution",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        //in length intLength only (intLength+1)/2 palindromes present\\n        \\n        //e.g. in 4 length (range between 1000 to 9999) only (90 substring present)\\n        //as in given example 1001, 1111, 1221, 1331, 1441, 1551,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only 4/2 length or (4+1)/2)\\n        \\n        //e.g. in 3 length (range between 100 to 999) only (90 substring present)\\n        //as in given example 101, 111, 121, 131, 141, 151,...\\n        //as we can see it has 10, 11, 12, 13, 14, 15 (only (3+1)/2 length)\\n        \\n        //bcz palindrome is made of left substring mirror to right substring\\n        //so we care about first half and we can made second half from first half easily\\n        \\n        // intLength is 4 or 3 we get palindrome_present=2 (we care about)\\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        \\n        \\n        for(int q:queries){\\n            \\n            //if queries[ith] is within the bound\\n            //r-l+1 because 10 to 99 we have all the palindrome (in total we have 99-10 +1)\\n            if(q<=(r-l+1)){\\n                \\n                //first half is the minimum value in range (which is l) + query number -1\\n                //-1 bcz we have l (10) number palindrome also\\n                String left_half=Long.toString(l+q-1);\\n                \\n                //second half is just mirror image (01)\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                \\n                //now for intLength 4 we have (1001) and 3 we have (1001)\\n                //we don\\'t need middle value (right half 0 index) if intLength is odd\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886921,
                "title": "generate-palindromes-by-splitting-in-half",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ogLength = intLength\\n        isOdd = intLength & 1\\n        if isOdd:\\n            intLength += 1\\n        k = intLength // 2\\n        k = 10 ** (k - 1)\\n        op = []\\n        for q in queries:\\n            pal = str(k + q - 1)\\n            if isOdd:\\n                pal += pal[::-1][1:]\\n            else:\\n                pal += pal[::-1]\\n            if len(pal) == ogLength:\\n                op.append(int(pal))\\n            else:\\n                op.append(-1)\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886956,
                "title": "python-simple-and-straightforward",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n        \\n        result = []\\n        \\n        for i in queries:\\n            result.append(self.generatePalindrome(intLength, i))\\n        \\n        return result\\n    \\n    def generatePalindrome(self, length, num):\\n        # index start from 0\\n\\t\\t# e.g. num =1 means we want to find the most smallest palindrome, then its index is 0\\n\\t\\t# e.g. num =2 means we want to find the second most smallest palindrome, then its index is 1\\n        index = num -1\\n        \\n\\t\\t# if the length is even\\n\\t\\t# we only think about the fisrt half of digits\\n        if length % 2 == 0:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2 -1))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                cur = cur + cur[::-1]\\n                cur = int(cur)\\n                return cur\\n\\t\\t\\t\\t\\n        # if the length is odd\\n\\t\\t# we consider first (length // 2 + 1) digits\\n        else:\\n            cur = int(\\'1\\' + \\'0\\' * (length // 2))\\n            maxLength = len(str(cur))\\n            cur += index\\n            \\n            if len(str(cur)) > maxLength:\\n                return -1\\n            \\n            else:\\n                cur = str(cur)\\n                temp = str(cur)[:-1]\\n                cur = cur + temp[::-1]\\n                cur = int(cur)\\n                return cur",
                "codeTag": "Java"
            },
            {
                "id": 1891452,
                "title": "simple-and-intuitive-pattern-based-c-solution",
                "content": "consider this, suppose you have 5 empty cells like this,\\n| __ | __ | __ | __ | __ |\\n| --- | --- | --- | --- | --- |\\n\\nhow many 5 digit numbers can you get (repetition of digits allowed)?\\nyou have 9 options (1-9) to put in first cell,\\n10 options (0-9) to put in from second to last cell.\\nso,\\n\\n| 9 | 10 | 10 | 10 | 10 |\\n| --- | --- | --- | --- | --- |\\n\\ni.e., you can get 90000 numbers (from 10000 to 99999) of 5 digits.\\n\\nNow, if I ask you to just concatenate these number reversely to themselves, so a number like, say,\\n\\n```48317``` will become ```4831771384```\\n\\nisn\\'t the new number a palindrome?\\n\\n___\\n\\nUsing the same logic, now consider this\\nif the length of palindrome number is \\'x\\', then the total number of palindromes with \\'x\\' length are as follows:\\n\\n| Length of the number | Total number of Palindromes possible |\\n| --- | --- |\\n| 1 | 9 |\\n| 2 | 9 |\\n| 3 | 90 |\\n| 4 | 90 |\\n| 5 | 900 |\\n| 6 | 900 |\\n| 7 | 9000 |\\n| 8 | 9000 |\\n| 9 | 90000 |\\n| 10 | 90000 |\\n\\nHow do we get the above table?\\nIf you don\\'t get it, its fine. just scratch your head a bit, that\\'s how your PSA will improve.\\n\\nAnyway, if you still don\\'t get it, here is the explanation.\\n\\nLet\\'s say the given length is 5, so we only need to consider first 3 cell. After that, we are only repeating the leading cells.\\nSo, for a given length of 5 digits > the possible number of palindromes are > 9* 10* 10.\\nThis will clear it up..\\n\\n| x1 | x2 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- |\\n\\n**OR** if the length was 6, then also total possible palindromes would be 900 as,\\n\\n| x1 | x2 | x3 | x3 | x2 | x1 |\\n| --- | --- | --- | --- | --- | --- |\\n\\n___\\n\\n\\n**NOW** moving on to the next part,\\nconsider the first and last palindrome with respect a specified length:\\n\\n| Length of the number | Total number of Palindromes possible | First Palindrome | Second Palindrome |\\n| --- | --- | --- | --- |\\n| 1 | 9 | 1 | 9 |\\n| 2 | 9 | 11 | 99 |\\n| 3 | 90 | 101 | 999 |\\n| 4 | 90 | 1001 | 9999 |\\n| 5 | 900 | 10001 | 99999 |\\n| 6 | 900 | 100001 | 999999 |\\n| 7 | 9000 | 1000001 | 9999999 |\\n| 8 | 9000 | 10000001 | 99999999 |\\n| 9 | 90000 | 100000001 | 999999999 |\\n| 10 | 90000 | 1000000001 | 9999999999 |\\n\\nAlso, observe that, let\\'s say for len==5, I am considering first 3 digits to generate a palindrome.\\nAnd the first 3 digits for the first palindrome would be: 100\\nfor the next, 101,\\nthen 102, 103, 104..and so on.\\ntherefore, for the nth palindrome >> 100 + (n-1)\\n\\nVoila !\\nAlgo is ready..\\n\\n\\n**Based** on the above logic, the code is as follows:\\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```48317```\n```4831771384```\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll nthpalindrome(int n, int len, int exp){\\n        \\n        ll n1 = pow(10,exp);\\n        ll n2 = n1+(n-1);\\n        \\n        string s1 = to_string(n2);\\n        string s2 = \"\";\\n        \\n        for(int i=1; i<=(len/2); i++){\\n            s2+=s1[i-1];\\n        }\\n        \\n        reverse(s2.begin(), s2.end());\\n        \\n        s1=s1+s2;\\n        \\n        ll ans = stoll(s1);\\n        \\n        return ans;\\n    }\\n    \\n    \\npublic:\\n    vector<ll> kthPalindrome(vector<int>& v, int len) {\\n        int n = v.size();\\n        vector<ll> ans(n,0);\\n        int exp;\\n        \\n        if(len%2){\\n            exp=len/2;\\n        }else{\\n            exp=len/2-1;\\n        }\\n        \\n        int lim = 9*pow(10,exp);\\n        \\n        for(int i=0; i<n; i++){\\n            int nth = v[i];\\n            if(nth>lim) ans[i]=-1;\\n            else ans[i]=nthpalindrome(nth,len,exp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104684,
                "title": "detail-explanation-for-any-language-code-in-cpp",
                "content": "**First two approaches are brute and takes more time**\\n\\n**Initial Brute Force approcah**\\n\\n```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\\n\\n**Improved version than Brute Force**\\n\\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\\n\\n**Simple and best Observing pattern**\\n\\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\\n\\n\\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Fell free to ask doubts and thank you happy coding***\\n***Please upvote***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String"
                ],
                "code": "```\\nIn brute force we generate a list of numbers of its size starting from pow(10,size) and \\nstore all palindromes number in that list and return that number\\n\\nTime Complexity - O( All Numbers of Size k* k )\\nMemory - O( All palindromes present in that Numbers )\\n```\n```\\nJust finding first palindrome and applying next palindrome logic to it\\nin that manner find all palindromes store and return it.\\n```\n```\\n here we will use the fact that palindrome is basically the concatenation of half of the string\\n by reversing it.\\n i.e abba -> ab + reverse(ab);\\n hence we will generate the palindrome of (intLength+1)/2 (first part ab)      \\n for both odd and even case.\\n \\n Then in case of even length we will reverse string and return it \\n In case of odd we will leave One as for odd i.e abdba -> ab + d + rev(ab)\\n \\n which is explained through example \\n \\n intLength = 3\\n \\n half= (3+1)/2 = 2\\n \\n here starting and ending implies range of ab\\n \\n so starting = 10^(half-1) = 10^1=10\\n ending =10^(half) -1 = 99\\n \\n now  to get particular nth number we have formula (starting+n-1)\\n \\n if n= 2  so that n element is 10+2-1=11\\n \\n now convert it to string s=11\\n \\n as k is even now rev=11\\n \\n now return s+rev = 11+11=1111\\n \\n -1 Case :\\n      This case occurs if N index is greater or No k lenght palindrome is present at that index\\n\\t  it is checked by using n>(ending-starting+1) range\\n```\n```\\n#define all(x) x.begin(),x.end()\\n\\nclass Solution {\\npublic:\\n    long long nthpalindrome(long long n,int k){\\n        \\n\\t\\t// calculating power to find starting index\\n        int half = (k+1)>>1;\\n        \\n\\t\\t// starting i.e 10\\n        int starting = pow(10,half-1);\\n        \\n\\t\\t// ending i.e 99\\n        int ending = pow(10,half)-1;\\n        \\n\\t\\t// if at nth index a palindrome of lenght K no exist\\n        if( n>(ending-starting+1) )\\n            return -1;\\n        \\n\\t\\t// convert to string\\n        string front = to_string(starting+n-1);\\n        \\n        string end;\\n        \\n        if( k%2 ){\\n\\t\\t// for odd case we leave last one i.e front= 123\\n\\t\\t// end = rev(12)  so ans = 123+ rev(12)= 123+21\\n            end=front.substr(0,half-1);\\n            reverse(all(end));\\n        }else{\\n\\t\\t// In case of even just reverse it\\n            end=front.substr(0,half);\\n            reverse(all(end));\\n        }\\n        \\n        \\n        return stoll(front+end);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        \\n        for( int x: queries )\\n            ans.push_back( nthpalindrome(x,intLength) );\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887591,
                "title": "c-simple-solution-easy-to-understand-with-comments-and-explaination",
                "content": "We need to create the first half of pallindrome first and then the second half by appending the first half in it from rigth to left.\\nFor this we should observe that max pallindrome length for given len will be 10^len, since we are going to create the first half therefore we need to take half of the len , i.e 10^(len/2).\\nAlso the middle digit will be always (query[i-1]-1) for each pallindrome so we need to add it and we get our half pallindrome. Using this we can create the full pallindrome.\\n\\nUPVOTE  if you like it!!\\n\\n```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string create(long long q, long long len)\\n    {\\n        long long k;\\n        \\n        if(len%2 == 0)\\n            k = len/2-1;\\n        else\\n            k=len/2;\\n        \\n        long long half_pall;\\n        \\n\\t\\t//creating half pallindrome by raising 10 to power of len/2\\n\\t\\thalf_pall = pow(10,k);\\n        half_pall+=(q-1);\\n        \\n        string full_pall = to_string(half_pall);\\n        \\n        if(len%2!=0)\\n        half_pall/=10;\\n        \\n\\t\\t//appending half pallindrome to itself in reverse to get full pallindrome\\n        while(half_pall > 0)\\n        {\\n            full_pall+=to_string(half_pall%10);\\n            half_pall/=10;\\n        }\\n\\t\\t\\n\\t\\t//if ans is possible then return string else return -1\\n        if(full_pall.size() == len)\\n            return full_pall;\\n        else\\n            return \"-1\";\\n        \\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        vector<long long> ans;\\n        \\n        for(int i=0 ;i<q.size(); i++)\\n        {\\n\\t\\t\\t//changing string returned by function to long long \\n            long long temp = stoll(create(q[i],len));\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887017,
                "title": "easy-approach-java",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887458,
                "title": "simplest-solution-o-queries-length-o-1-space-simple-maths",
                "content": "Approach:\\n![image](https://assets.leetcode.com/users/images/95ecc5b0-ea8d-4cd0-9f1d-397409f25b09_1648358183.97771.jpeg)\\n\\n\\nExample: n=69, k=3\\n\\n(n-1)  = 68;\\nadding 1\\n(n-1) + pow(10,k/2) = 68+10 = 78 (halfNum)\\n\\nans = 7887\\n\\nn = 90, k=4\\nn-1 = 89;\\npow(10,k/2-1) = 89+10 = 99 (halfNum)\\nans = 9999\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nplease upvote, if find helpful...",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(long long n, long long k) {\\n        \\n        if(n<=9 && k==1)\\n            return n;\\n        \\n        if(9*pow(10,(k-1)/2)<n)\\n            return -1;\\n       \\n        long long halfNum = (n-1) + pow(10,(k-1)/2);\\n        long long num = halfNum;\\n        if(k&1)\\n            halfNum /= 10;\\n        \\n        while(halfNum>0) {\\n            num = num*10+halfNum%10;\\n            halfNum /= 10;\\n        }\\n        \\n        return num;\\n            \\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for(int n:queries) {\\n            ans.push_back(solve(n,intLength));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724331,
                "title": "java-solution-beginner-friendly-half-of-the-palindrome-length",
                "content": "\\t\\tclass Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tres[i]=-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t return res;\\n\\t\\t\\t}\\n\\n\\t// for creating the reverse of the string\\n\\t\\t\\tstatic String reverse(String rev,int n){\\n\\t\\t\\t\\tString a = \"\";\\n\\t\\t\\t\\tfor (int i=0; i<n; i++) \\n\\t\\t\\t  { \\n\\t\\t\\t\\tchar ch= rev.charAt(i); \\n\\t\\t\\t\\ta= ch+a; \\n\\t\\t\\t  } \\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}\\n\\n\\t// for checking whether the string is palindrome or not\\n\\t\\t\\tstatic boolean palindrome(String ans){\\n\\t\\t\\t\\tString reve = \"\";\\n\\t\\t\\t\\tfor(int i=0;i<ans.length();i++){\\n\\t\\t\\t\\t\\treve =ans.charAt(i)+reve;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn reve.equals(ans);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\t\\tpublic long[] kthPalindrome(int[] queries, int l) {\\n\\t\\t\\t   long res[] = new long[queries.length];\\n\\t\\t\\t\\tint pw = l%2==0? (l/2)-1 : l/2;\\n\\t\\t\\t\\tint start =(int) Math.pow(10,pw);  //lower bound of the number to be palindrome\\n\\t\\t\\t\\tint end = ((int) Math.pow(10,pw+1))-1; //upper bound of the number to be palindrome\\n\\t\\t\\t\\t String ans = \"\";\\n\\n\\t\\t\\t\\tfor(int i=0; i<queries.length; i++){\\n\\t\\t\\t\\t\\tif(queries[i]<=end-start+1)  // for checking that does it exist in the range of upper and lower bound\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tans = Integer.toString(start + (queries[i]-1));// coverting int to string by using function\\n\\t\\t\\t\\t\\t\\tString rev = reverse(ans,l-ans.length());\\n\\t\\t\\t\\t\\t\\tans = ans +rev;\\n\\n\\t\\t\\t\\t\\t\\tif(palindrome(ans)){\\n\\t\\t\\t\\t\\t\\t\\tlong r = Long. parseLong(ans);// for converting string to long\\n\\t\\t\\t\\t\\t\\t\\tres[i]=r;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2178890,
                "title": "python3-math-solution-with-explanation",
                "content": "Taking into account the palindrome property, we want to work with only half of the digits, and get the rest as the same half, but in reverse order. For this purpose, we have a **helper** function, in which for even numbers the order of the left side is changed to receive the right part, and for odd numbers the last digit is removed and the order is also changed.\\nAlso, we want to precompute the number of palindromes for a given length **intLength** to avoid the case where the ordinal exceeds the possible number of palindromes.\\nRuntime leaves a lot to be desired, but hopefully the explanations will be helpful.\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        limit = [10, 19]\\n\\n        for i in range(3, intLength + 1):\\n            limit.append(limit[-1] + 9 * (10 ** int((i - 1) / 2)))\\n        \\n        def helper(num):\\n            left = str(num)\\n            \\n            if intLength % 2 == 0:\\n                right = str(num)[::-1]\\n            else:\\n                right = str(num)[:-1][::-1]\\n            \\n            return int(left + right)\\n\\t\\t         \\n        if intLength % 2 == 0:\\n            digits = intLength // 2 - 1\\n        else:\\n            digits = intLength // 2\\n\\t\\t\\n        for i in queries:\\n            if i <= limit[intLength - 1]:\\n                half = 10 ** digits + i - 1\\n                tmp = helper(half)\\n                \\n                if len(str(tmp)) <= intLength:\\n                    ans.append(tmp)\\n                else:\\n                    ans.append(-1)\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012405,
                "title": "easily-explained-each-step",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* here we will use the fact that palindrome is basically the concatenation of half of the string by reversing it.\\n    i.e abba -> ab + reverse(ab);\\n    hence we will generate the palindrome of intLength/2 or more conscisely (intLength+1)/2       for both odd and even case.\\n    Now we will define range by using simple formula i.e how many number can be formed using n digit-> pow(10,n-1);\\n    now for even length we will just reverse the formed string and concatenate it but for odd length we will take substring from length 1.\\n    i.e for abbba.only ba should be added.\\n    lastly if formed palindrome will be equal to original length then push it in ans else push -1;\\n    */\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n           vector<long long> result;\\n        long long start =  pow(10, (intLength+1)/2 - 1) ;\\n        \\n        for(int q: queries) { \\n            string s = to_string(start + q - 1);\\n            string palindrome = s;\\n            reverse(s.begin(), s.end());\\n            if(intLength % 2 == 0) {\\n                palindrome += s;\\n            } else {\\n                palindrome += s.substr(1, s.size() - 1);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// len of palindrome should be intLength, otherwise -1\\n            if (palindrome.size() == intLength)\\n                result.push_back(stoll(palindrome));\\n            else\\n                result.push_back(-1);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888574,
                "title": "simple-math-c",
                "content": "// simple c++\\n                   class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }\\n            if(l%2==0)\\n            {\\n                string x,y;\\n                y=s;\\n                x=s;\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }else{\\n                string x,y=s;\\n                x=s.substr(0,s.size()-1);\\n                reverse(x.begin(),x.end());\\n                y=y+x;\\n                temp=stoll(y);\\n            v[i]=temp;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> v(queries.size());\\n        int po=(l+1)/2;\\n        long long tt=pow(10,po)-1;\\n        long long res=pow(10,po-1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long temp=res;\\n            temp+=(queries[i]-1);\\n            string s=to_string(temp);\\n            if((tt-res+1)<queries[i])\\n            {\\n                v[i]=-1;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3169476,
                "title": "different-than-the-other-solutions-in-discussion-pattern-recognition",
                "content": "# Intuition\\ntaking c as the initial number and then reducing c and taking use of its modulud with 10.\\n\\n# Approach\\nBasically , here i first thought about maximum number of palindromes for a length n which will be 9 *10 ^(n-1/2) ( basically 9 bcoz we cant have number with terminal zeroes and 10^ power(n-1)/2 bcoz we can have 0 to 9 pairs of numbers making it 10 possible values). and now step by step we take modulo of c with 10 (lets say x) and then divide it by 10 untill it reaches 0 . So now we intialize our ans with x-1 or (x-1)(x-1) (if n is even) and then step by step we get values untill c becomes 0 we start appending it in pair for example if c=453 and n=7 then x =3 and later c=45 , so now x=5 , so at this point ans=525. and similarly ans=45254 but snce n=7, so final ans will be 104525401 but in case of n=8 , ans will be 14522541 and in case if n=5, 55255 (edge cases we have to add like if initial c has terminal 0 then x=9 )\\n\\n# Complexity\\n- Time complexity:\\nn*15 (where n is vector query size)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n\\n    long long int pow(int a,long long int n){\\n        if(n==0){\\n            return 1;\\n        }\\n        return (a*pow(a,n-1));\\n    }\\n    long long fun(long long int c,long long int n){\\n      \\n      long long int ans;\\n     long long  int f=(n-1)/2;\\n      if(c> (9* pow(10,f)) ){\\n          return -1;\\n      }\\n    long long   int d=c%10;\\n      c=c/10;\\n      long long int count=1;\\n     long long  int flag=0;\\n      if(d!=0){\\n          ans=d-1;\\n      }\\n      else if(d==0){\\n          ans=9;\\n          flag=1;\\n      }\\n      if(n%2==0){\\n          int e=ans*10+ans;\\n          ans=e;\\n          \\n          count++;\\n      }\\n      if(n==1){\\n         return (ans+1);        \\n      }\\n      if(n==2){\\n          return (ans+11);\\n      }\\n   \\n      while(count<n){\\n          if(c==0){\\n              d=0;\\n          }\\n          else if(c!=0){\\n             d=c%10;\\n             \\n          }\\n        \\n         \\n          if(c==0){\\n              int left=(n-count);\\n              left=left/2;\\n             \\n              ans=ans*pow(10,left)+1;\\n              \\n              count=count+left;\\n              \\n              d=pow(10,count+left-1)+ans;\\n              ans=d;\\n              return ans;\\n          }\\n        \\n          if(count==n-2){\\n              \\n            d=d+1;\\n            \\n          }\\n          \\n            if(flag==0){\\n                \\n           count++;\\n            \\n           ans=ans*10+d;\\n          \\n           count++;\\n           d=d*pow(10,count-1)+ans;\\n           ans=d;\\n           \\n            }\\n            else if(flag!=0){\\n               if(d==0){\\n                 d=9;\\n                  count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n                 \\n               }\\n               else if(d!=0){\\n                   \\n                   d=d-1;\\n                   flag=0;\\n                   count++;\\n               ans=ans*10+d;\\n               count++;\\n              d=d*pow(10,count-1)+ans;\\n              ans=d;\\n               }\\n\\n            }\\n          c=c/10;\\n           \\n      }\\n\\n\\n    return ans;\\n        \\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n     vector<long long> v;\\n\\n     long long int ans;\\n    \\n    long long  int n=intLength;\\n     \\n    long long  int i;\\n     for(i=0;i<queries.size();i++){\\n          \\n          v.push_back(fun(queries[i],intLength));\\n        \\n     }\\n\\n      return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055374,
                "title": "python-simple-maths",
                "content": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        \\n        if intLength%2 == 0:\\n            l = (intLength//2) - 1\\n        else:\\n            l = (intLength//2)\\n            \\n        for i in queries:\\n            x = str(10**l + i-1)\\n            \\n            if intLength%2 == 0:\\n                x = x + x[::-1]\\n            else:\\n                x = x + x[::-1][1:]\\n                \\n            if len(x) == intLength:\\n                ans.append(x)\\n            else:\\n                ans.append(-1)\\n                \\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2016117,
                "title": "javascript-half-reflection",
                "content": "**Intuition**\\n\\n```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\\nFrom above, we find out only **HALF digits** matter for making palindromes.\\n.\\nI\\'ll take `queries`=[5, 98], `intLength`=4 for example:\\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n# First 3 palindromes of 5-digits\\n`100`01, `101`01, `102`01\\n# Last 4 palindromes of 7-digits:\\n`9996`999, `9997`999, `9998`999, `9999`999\\n```\n```\\nvar kthPalindrome = function(queries, intLength) {\\n    let output=[];\\n\\t// 1. We use FIRST 2 digits to create palindromes: Math.floor((3+1)/2)=2\\n    let digit=Math.floor((intLength+1)/2);\\n\\t\\n    for(let i=0; i<queries.length; i++){\\n\\t\\t// 2A. Get Nth 2-digits numbers: 10*(2-1)-1+[5,98]=[14,107]\\n        let helper=10**(digit-1)-1+queries[i];\\n\\t\\t// 2B. Digits checking: 107>=100, which is INVALID \\n        if(helper>=10**digit){output.push(-1)}\\n        else{\\n\\t\\t\\tlet m=intLength-digit;\\n\\t\\t\\t// 3A. We still need m digits for REFLECTION: 14=>[\"1\",\"4\"]=>\"41\"\\n            let add=helper.toString().substr(0, m).split(\"\").reverse().join(\"\");\\n\\t\\t\\t// 3B. Multiply 10**m for reversed digits: 14=>1400=>1441 \\n            helper=helper*10**m+add*1;\\n            output.push(helper);\\n        }\\n    }\\n    return output; // [1441,-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012193,
                "title": "java-concise-solution-explained",
                "content": "Here is a list of palindrome:\\n```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\\nDid you see any pattern? the first two digits went from 10, 11, to 51. Increase by 1 each time, and the same thing occurs for even length palindromes.\\nThus, we can generate the first half in O(1) and simply reverse it to form the palindrome for each query! \\n\\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515\\n```\n```Java\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] ans = new long[queries.length];\\n        long sz = (long)Math.pow(10, (intLength-1)/2);\\n        for (int i = 0; i < queries.length; i++){\\n            if (queries[i] > 9 * sz){ // invalid\\n                ans[i] = -1;\\n            }else{\\n                long front = sz + queries[i]-1;\\n                StringBuilder back = new StringBuilder(\"\"+front);\\n                ans[i] = Long.parseLong(front+back.reverse().toString().substring(intLength % 2)); \\n\\t\\t\\t\\t// don\\'t take the first letter if the length is odd, otherwise it\\'d overlap.\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898077,
                "title": "easy-python-code-string-math-logic-95-faster",
                "content": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "# This is a Pure logic question You just have to find how the math is working and some basic logic\\nso what i did was if k is even lets say 4 then take the first 2 letters and reverse them and join\\neg .    1001-> 10 + 01  pow(10,1)\\nin this we just need 10 and revese that \\nif the value of k is odd lets say 5 then we need pow(10,2)-> 100\\neg. - 100+01 -> 10001\\nin this do not take the first digit of revesed string \\n\\n\\'\\'\\'\\n\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n        start=pow(10,n)\\n        for i in queries:\\n            ans=str(start+i-1)\\n            rev=ans[::-1]\\n            if L%2==0:\\n                st=ans+rev\\n            else:\\n                st=ans+rev[1:]\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n        return l1\\n\\'\\'\\'\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1892167,
                "title": "javascript-2217-find-palindrome-with-fixed-length",
                "content": "---\\n\\n- Understanding `99`th 8-digit palindrome is 10`98` `89`01 is key to understanding code below\\n\\n---\\n\\n**Weekly Contest 286**\\n- **Q1** answer - https://leetcode.com/problems/find-the-difference-of-two-arrays/discuss/1889224/JavaScript-2215.-Find-the-Difference-of-Two-Arrays\\n- **Q2** answer - https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/discuss/1890258/JavaScript-2216.-Minimum-Deletions-to-Make-Array-Beautiful\\n- **Q3** answer - https://leetcode.com/problems/find-palindrome-with-fixed-length/discuss/1892167/JavaScript-2217.-Find-Palindrome-With-Fixed-Length\\n  - **below**\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/384fb9f9-40d2-4c07-ac11-a5cdbcfc6637_1648510433.6626642.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar kthPalindrome = function (queries, len) {\\n    let lenAboutHalf = Math.pow(10, Math.ceil(len / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";                     // first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                               // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (len % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;                                        // full palindrome\\n        if (s.length > len) {\\n            ans.push(-1);                                              // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1888796,
                "title": "faster-than-100-00-of-c-easy-to-understand",
                "content": "Note the pattern, take length 4 as an example\\n* 1th 1001\\n* 2th 1111\\n* 3rd 1221\\n* 4th 1331\\n\\nwe split the string in half, and increase it query times then reverse to get the query-th palindrome.\\n1. we start with 10...01\\n2. add query-1 to the first half, simulating big integer adding.\\n\\t1. if we do not get overflow, reverse the other half.\\n\\t2. if we get overflow, remembering it to save some work.\\n\\nBelow is full code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& qs, int len) {\\n        string s(len, \\'0\\');\\n        vector<long long> res;\\n        int overflow = INT_MAX;\\n        for (auto q : qs) {\\n            if (q < overflow) {\\n                s.assign(len, \\'0\\');\\n                s[0] = \\'1\\';\\n                s.back() = \\'1\\';  // get 10...01 as start\\n                int carry = q-1; // set carry\\n                for (int ind = (len-1)/2; ind >= 0 && carry; ind--) {\\n                    int total = s[ind]-\\'0\\' + carry;\\n                    s[ind] = total % 10 + \\'0\\';\\n                    carry = total/10;\\n                }\\n                if (carry) {\\n                    overflow = q;\\n                    res.push_back(-1);\\n                    continue;\\n                } else {\\n                    if (len % 2) {\\n                        for (int i = 1; len/2+i <len; i++) {\\n                            s[i+len/2] = s[len/2-i];\\n                        }                        \\n                    } else {\\n                        for (int i = len/2-1, j = i+1; j < len; i--, j++) {\\n                            s[j] = s[i];\\n                        }                                                \\n                    }\\n                    res.push_back(atoll(s.c_str()));\\n                }\\n            } else {\\n                res.push_back(-1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888404,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }\\n                else\\n                {\\n                    b=a;\\n                }\\n                reverse(a.begin(),a.end());\\n                \\n                b+=a;\\n                \\n                long long p=stol(b);\\n                ans.push_back(p);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        \\n        int n=queries.size();\\n        \\n        int k=(intLength+1)/2;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            int tot=pow(10,k)-pow(10,k-1);\\n            if(queries[i]>tot)\\n                ans.push_back(-1);\\n            else\\n            {\\n                \\n                long long int str=pow(10,k-1)-1+queries[i];\\n                string a=to_string(str);\\n                string b=\" \";\\n                \\n                if(intLength%2==1)\\n                {\\n                    //cout<<a<<endl;\\n                    b=a.substr(0,a.size()-1);\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 1887714,
                "title": "simple-and-faster-than-100",
                "content": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n        # think the palindromes in half\\n        # e.g. len  = 4 we only consider the first 2 digits\\n        # half: 10, 11, 12, 13, 14, ..., 19, 20, \\n        # full: 1001, 1111, 1221, 1331, ...\\n        # e.g. len = 5 we consider the first 3 digits\\n        # half: 100, 101, 102, ...\\n        # full: 10001, 10101, 10201, ...\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        a=True\\n        if intLength%2!=0:  a=False\\n        ans=[]\\n        for i in queries:\\n            if a:\\n                t=str(10**(intLength//2 - 1)+i-1)\\n                t=int(t+t[::-1])\\n            else:\\n                t=str(10**(intLength//2)+i-1)\\n                t=int(t+t[:-1][::-1])\\n            if len(str(t))>intLength:   t=-1\\n            ans.append(t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887356,
                "title": "c-o-n-time-easy-to-understand",
                "content": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIdea : The first palindrome of any size starts as 100..001\\nWe can divide every palindrome in 2 parts. Traverse from 10..0 to 99...9 which is half the size of palindrome and make a reflection at the end point to convert into palindrome.",
                "solutionTags": [],
                "code": "```\\nint nmDig(int a){\\n    int ans =0;\\n    if(a==0) return 1;\\n    while(a) a/=10,ans++;\\n    return ans;\\n} // To Count number of Digits in a\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& Q, int IL) {\\n        int k=(IL-1)/2,j=0;\\n        while(k--) j+=9,j*=10;  j/=10;//j = 9...99\\n        vector<long long> ans;\\n        long long x,y;\\n        for(int i : Q){\\n\\t\\t x = i+j,y=i+j;\\n            if(nmDig(x) != (IL+1)/2){\\n                ans.push_back(-1); continue;\\n            }\\n            if(IL&1) x/=10;\\n            while(x) y=y*10+(x%10),x/=10;// make for example 1890 to 1890981\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887276,
                "title": "c-easy-to-understand-solution-with-detailed-explanation",
                "content": "We are given queries size as 5 * 10^4 , thus we have to solve each query in O(k) or O(1) time. \\nLet us take an example to understand approach to solve it, let intLength=3.\\nSo our sequence here will be 101,111,121,131,141,151,161,171,181,191,202,212,.....999.\\nWe can divide a palindrome into (intLength+1)/2 parts. So above sequence is of form `aba`.  Where `a` can change from 1 to 9, and `b` can change from 0 to 9. Thus total combinations are 9 * 10. \\n(Similarly if we have intLength=6. The palindrome will be of from `abccba` , and total combinations 9 * 10 * 10 .)\\nSo if we get a query of length greater than value of total combinations, we will add -1 to result vector.\\nOtherwise we will find corresponding palindrome. We will create `path` vector, to change values of `a`, `b` in above example. Initially value of `path` vector is `{1,0}` . Let our query is 55, we will first subtract 1 from it.\\nThen => 54 = 5 * 10 + 4 , thus value of `a` is 5 and value of `b` is 4.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long largestPosValue=9*pow(10,(intLength-1)/2);\\n        //Palindrome of length n, will be devided in (n+1)/2 parts\\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>largestPosValue)res.push_back(-1);\\n            else{\\n                string str=\"\";\\n                if(intLength==1){\\n                    str+=\\'1\\';\\n                }\\n                else{\\n                    str+=\\'1\\';\\n                    for(int j=0;j<intLength-2;j++)str+=\\'0\\';\\n                    str+=\\'1\\';\\n                }\\n                \\n                vector<int> paths((intLength+1)/2,0);\\n                paths[paths.size()-1]=1;\\n                int x=queries[i]-1,a=0;\\n                while(x>0){\\n                    paths[a++]+=x%10;\\n                    x/=10;\\n                }\\n                for(int j=paths.size()-1,z=0;j>=0;j--,z++){\\n                    str[z]=char(paths[j]+\\'0\\');\\n                    str[intLength-1-z]=char(paths[j]+\\'0\\');\\n                }\\n                \\n                res.push_back(stoll(str));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887275,
                "title": "python-o-n-with-explanation",
                "content": "If intLength is Even:\\n\\nWe only care about the left half, then add its reverse as the right half \\ne.g. intLength = 6, k = 2\\ncut the length in half, n = 6/2 = 3\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n-1) `\\nWhat is the kth number? (k = 2, starts with 100, the 2nd is 101)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half\\nleft = `101`, right = `101` -> together `101101` \\n\\nif intLength is Odd:\\n\\nWe only care about the left half, then add its **partial** reverse as the right half \\ne.g. intLength = 5, k = 3\\ncut the length in half, n = 5//2 = 2\\nwhat is the first number/starting number? (for this e.g., it should be 100)\\n`start = 10**(n) `\\nWhat is the kth number? (k = 3, starts with 100, the 3rd is 102)\\n`val = start + k - 1`\\nnow we have the left half, reverse it and get the right half, add the right half without the first digit which is in parentheses\\nleft = `102`, right = `(2)01` -> together `102(2)01` ->`10201`\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:       \\n\\t\\t# if intLengh is Even\\n        if intLength % 2 == 0:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n-1)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n        \\n\\t\\t# if intLengh is Odd\\n        else:\\n            n = intLength // 2\\n            res = []\\n            start = 10**(n)\\n            \\n            for k in queries:\\n                val = start + k-1\\n                pal = \\'\\'.join([str(val),str(val)[::-1][1:]])\\n                if len(pal) != intLength:\\n                    res.append(-1)\\n                else:\\n                    res.append(int(pal))\\n            return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887181,
                "title": "easy-approach-c",
                "content": "\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll givepali(int n, int k)\\n    {\\n        ll ans = 0;\\n        long long tem;\\n        if(k&1)\\n            tem = k/2;\\n        else\\n            tem = k/2-1;\\n        ll dig = (ll)powl(10, tem);\\n        dig += n - 1;\\n        ans  = dig;\\n\\n        if (k & 1){\\n            dig /= 10;\\n        }\\n\\n        while (dig)\\n        {\\n            ans = ans*10 + dig%10;\\n            dig /= 10;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\n    vector<long long> kthPalindrome(vector<int>& q, int k) {\\n        \\n        vector<ll> ans;\\n        int x = (k+1)/2;\\n        ll aa = 9*powl(10,x-1);\\n        for(int i=0; i<q.size(); ++i)\\n        {\\n            \\n            if(q[i]<=aa)\\n                ans.push_back(givepali(q[i],k));\\n            else\\n                ans.push_back(-1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917040,
                "title": "python-simple-solution-beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        res=[]\\n        ln=ceil(intLength/2)\\n        odd=intLength%2==1\\n        base=10**(ln-1)\\n        def getLalindrome(k:int)->int:\\n            val=str(k-1+base)\\n            if len(val)>ln:\\n                return -1\\n            return int(val+val[-2::-1]) if odd else int(val+val[::-1])\\n        for q in queries:\\n            res.append(getLalindrome(q))  \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822509,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629304,
                "title": "simple-and-clean-solution-easy-formula",
                "content": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(long long num,int len)\\n    {\\n        long long pal_num=num;\\n        if(len&1)num/=10;\\n        while(num)\\n        {\\n            pal_num*=10;\\n            pal_num+=(num%10);\\n            num/=10;\\n        }\\n        return pal_num;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) {\\n        int start=pow(10,((len+1)/2)-1);\\n        long long totalPal=(start==0?9:start*1ll*9);\\n        vector<long long> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(q[i]>totalPal)\\n            {\\n                ans.push_back(-1);\\n            }\\n            else\\n            {\\n                ans.push_back(helper(start+q[i]-1,len));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299422,
                "title": "2217-find-palindrome-with-fixed-length-simple-cpp-solution",
                "content": "* class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }\\n*             else\\n*             {\\n*                 s1=s1+ rev.substr(1,rev.size()-1);\\n*             }\\n*             if(s1.size()==intLength)\\n*                 res.push_back(stoll(s1));\\n*             else\\n*                 res.push_back(-1);\\n*         }\\n*         return res;\\n*     }\\n* };",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n* public:\\n*     vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n*          int n=(intLength%2==0)?(intLength/2)-1:(intLength/2);\\n*         vector<long long> res;\\n*         int n1=pow(10,n);\\n*         for(auto a:queries)\\n*         {\\n*             string s1=to_string(n1+a-1);\\n*             string rev=s1;\\n*             reverse(rev.begin(),rev.end());\\n*             if(intLength%2 ==0)\\n*             {\\n*                 s1=s1+rev;\\n*             }",
                "codeTag": "Java"
            },
            {
                "id": 2272812,
                "title": "python-no-string-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        left_digits = intLength // 2 + intLength % 2\\n        output = [-1 for _ in queries]\\n        \\n        for i, query in enumerate(queries):\\n            temp = 10 ** (left_digits - 1) + query - 1\\n            if temp < 10 ** left_digits:\\n                x = 0\\n                y = temp // 10 if intLength % 2 else temp\\n                while y > 0:\\n                    x = x * 10 + y % 10\\n                    y //= 10\\n                    temp *= 10\\n                output[i] = temp + x\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221612,
                "title": "python-math-string-reverse-93-38-faster",
                "content": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tresult=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tbase = 10**((intLength)//2 -1 )\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2 -1 ))\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbase = 10**((intLength)//2)\\n\\t\\t\\t\\ttemp2 = 9 * (10**(intLength//2))\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tif i>temp2:\\n\\t\\t\\t\\t\\tresult.append(-1)\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\ttemp = base + i-1\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-1::-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttemp1 = str(temp) + str(temp)[-2::-1]\\n\\t\\t\\t\\tresult.append(int(temp1))\\n\\n\\t\\t\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 1976285,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```\\n\\n***Consider upvote if usefull!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res= new long[queries.length];\\n        for(int i=0;i<queries.length;i++){\\n            res[i]=nthPalindrome(queries[i],intLength);\\n        }\\n        return res;\\n    }\\n    public long nthPalindrome(int nth, int kdigit)\\n    {\\n    long temp = (kdigit & 1)!=0 ? (kdigit / 2) : (kdigit/2 - 1);\\n    long palindrome = (long)Math.pow(10, temp);\\n    palindrome += nth - 1;\\n    long res1=palindrome;\\n    if ((kdigit & 1)>0)\\n        palindrome /= 10;\\n    while (palindrome>0)\\n    {\\n        res1=res1*10+(palindrome % 10);\\n        palindrome /= 10;\\n    }\\n    String g=\"\";\\n    g+=res1;\\n    if(g.length()!=kdigit)\\n        return -1;\\n    return res1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958366,
                "title": "python-simple-solution-half-the-palindrome-length",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n1 = 10**(intLength//2-1 if intLength%2==0 else intLength//2)\\n        for query in queries:\\n            n2 = n1 + (query-1)\\n            s = str(n2) + \\'\\'.join(reversed(str(n2)))[0 if intLength%2==0 else 1:]\\n            answer.append(int(s) if len(s) == intLength else -1)\\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 1943697,
                "title": "7-lines-python-solution-93-faster-memory-less-than-70",
                "content": "### ***Solution 1: Time O(n) / Memory O(n)***\\n```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, Q: List[int], k: int) -> List[int]:\\n        ans=[] ; s=\\'\\' ; n=ceil(k/2)-1\\n        for i in Q:\\n            x=str(10**n+i-1)\\n            if k%2==0: s=x+x[::-1]\\n            else: s=x+x[::-1][1:]\\n            ans.append(s if len(s)==k else -1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913402,
                "title": "explained-solution-in-easy-ways-step-by-step",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```\\n<strong> if you like the solution then hit the like button",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], L: int) -> List[int]:\\n        l1=[]\\n        st=\"\"\\n        \\n#         if we have 4 then break it 2 or we have 5 then also to 2\\n\\n        if L%2==0:\\n            n=L//2-1\\n        else:\\n            n=L//2\\n            \\n            \\n            \\n#         starting from that length like if we have 2 then 10 find the power if we have 3 then 100 continue from that string \\n        start=pow(10,n)\\n        for i in queries:\\n            print(start)\\n#             add that queries-1 in the start \\n            ans=str(start+i-1)\\n            \\n#         reverse that string \\n            rev=ans[::-1]\\n    \\n#           if the length is the even simple ad the reverse string    \\n            if L%2==0:\\n                st=ans+rev\\n            \\n#             other wise add from the 1 index like k=3 string 10 then we have to just add the 1 to make the final string 101\\n            else:\\n                st=ans+rev[1:]\\n            \\n#           if the string length matches the given length then add in the result otherwise -1\\n            if len(st)==L:\\n                l1.append(st)\\n            else:\\n                l1.append(-1)\\n            # print(st,l1)\\n        return l1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896836,
                "title": "java-simple-solution",
                "content": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "\\n\\n        int len=(intLength+1)/2;\\n        long left=(long)Math.pow(10,len-1);\\n        long right=(long)(Math.pow(10,len)-1);\\n        long ans[]=new long[queries.length];\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            long rang=right-left+1;\\n            if(queries[i]>rang)\\n                ans[i]=-1;\\n            else\\n            {\\n                String t1=Long.toString(left+queries[i]-1);\\n                String t2=(new StringBuffer(t1)).reverse().toString();\\n                ans[i]=Long.parseLong(t1+t2.substring(intLength%2));\\n                \\n\\n             }\\n        }\\n        return ans;\\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890445,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ##Consider both cases for even and odd length separately##\\n        \\n        l=0\\n        if intLength%2:\\n            l=intLength//2\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[:len(r)-1]\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        else:\\n            l=intLength//2-1\\n            tenpower=pow(10,l)\\n            res=[]\\n            for i in queries:\\n                val=str(tenpower+i-1)\\n                r=list(val)\\n                r=r[::-1]\\n                r=\"\".join(r)\\n                val=val+r\\n                if len(val)==intLength:\\n                    res.append(int(val))\\n                else:\\n                    res.append(-1)\\n        return res\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890166,
                "title": "find-palindrome-with-fixed-length",
                "content": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }\\n        return dc;\\n    }\\n    long long getKthPal(int k,int length)\\n    {\\n        long long half,dc,factor;\\n        long long num,ans;\\n        half=length/2;\\n        if(length%2==1)\\n        {\\n            num=pow(10,half);\\n            dc=half+1;\\n        }\\n        else \\n        {\\n            num=pow(10,half-1);\\n            dc=half;\\n        }\\n        num+=k-1;\\n        if(getDigitCount(num)>dc)return -1;\\n        if(dc==half)factor=1;\\n        else\\n        {\\n            factor=10;\\n            dc--;\\n        }\\n        while(dc>0)\\n        {\\n            num=num*10+((num/factor)%10);\\n            dc--;\\n            if(dc==0)break;\\n            factor*=100;\\n        }\\n        return num;\\n        \\n    \\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            ans.push_back(getKthPal(queries[i],intLength));\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getDigitCount(int num)\\n    {\\n        int dc=1;\\n        while(num>9)\\n        {\\n            dc++;\\n            num/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888538,
                "title": "scala-4-liner-using-tostring-tolong",
                "content": "Excluding silly `object Solution {}` and method definition part.\\nRead other links if you want explanation on why this addition works.\\nIn this solution, `toString` and `toLong` is used for for brevity. (If you think about it, palindrome is about strings, not numbers)\\nFor a string `s` denoting upper half of the palindrome, both `s.dropRight (1) ++ s.reverse` and `s ++ s.reverse` makes original palindrome. Choose appropriately depending on `intLength`.\\n\\n```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nobject Solution {\\n  def kthPalindrome (queries: Array[Int], intLength: Int): Array[Long] = {\\n    val begin = Iterator.fill ((intLength - 1) / 2) (10L).product\\n    queries map (n => if (n > begin * 9) -1 else (begin + n - 1).toString match {\\n      case str => (str.dropRight (intLength & 1) ++ str.reverse).toLong\\n    })\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1888449,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(long long n,int len)\\n    {\\n        long long pal=n;\\n        if(len%2)\\n        {\\n            n/=10;\\n        }\\n        while(n)\\n        {\\n            pal=pal*10+n%10;\\n            n=n/10;\\n        }\\n        return pal;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int len) \\n    {\\n        vector<long long>ans(q.size(),-1);\\n        long long start=pow(10,(len-1)/2);\\n        long long end=pow(10,(len+1)/2);\\n        int index=-1;\\n        for(auto &it:q)\\n        {\\n            it--;\\n            index++;\\n            if((start+it)<end)\\n            {\\n                ans[index]=find(start+it,len);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888163,
                "title": "c-first-half-of-palindrome-reverse-and-concatenate",
                "content": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long reverse_and_concatenate(long long num,int intLength){\\n        long long temp = num;\\n        \\n        if(intLength%2) temp /= 10;\\n        \\n        while(temp){\\n            int rem = temp%10;\\n            num = num*10+rem;\\n            temp /= 10;\\n        }\\n        \\n        return num;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> ans(n);\\n        \\n        long long start = pow(10,(intLength+1)/2-1);\\n        long long end = pow(10,(intLength+1)/2)-1;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            long long left_half = start + queries[i] - 1;\\n            if(left_half > end)   ans[i] = -1;\\n            else                  ans[i] = reverse_and_concatenate(left_half,intLength);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887449,
                "title": "half-palindrome-to-consider-beats-all-runtime-simle-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }\\n        return x;\\n    }\\n    int max(int a,int b){\\n        if(a>b)return a;\\n        return b;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        if(len == 1){\\n            vector<long long>v;\\n            for(auto &i:queries){\\n                if(i>=10)v.emplace_back(-1);\\n                else{\\n                    v.emplace_back(i);\\n                }\\n            }\\n            return v;\\n        }\\n        int startLen = (len+1)/2;\\n        map<long long,long long>m;\\n        long long cnt = 1;\\n        long long start = pow(10,startLen-1);\\n        long long end = pow(10,startLen)-1;\\n        long long maxi = 0;\\n        for(auto&i:queries){\\n            m[i]++;\\n            maxi = max(maxi,i);\\n        }\\n        long long limit = 9*pow(10,startLen-1);\\n        vector<long long>v;\\n        for(auto&i:queries){\\n            if(i>limit){\\n                v.emplace_back(-1);\\n            }\\n            else{\\n                m[i] = i + start -1;\\n                string x = to_string(m[i]);\\n                string y = x;\\n               \\n                if(len&1){\\n                    y.pop_back();\\n                }\\n                 reverse(y.begin(),y.end());\\n                x+=y;\\n                long long z = sto(x);\\n                v.emplace_back(z);\\n            }\\n        }\\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n    private:\\n    long long sto(string s){//string to integer\\n        long long x = 0;\\n        for(int i = 0 ; i < s.size();++i){\\n            x = x*10 + s[i]-\\'0\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1887330,
                "title": "c-simple-solution-with-explanation-o-no-of-queries-intlength-100-faster",
                "content": "Palindrome in increasing order:\\n* 1 digit : 1,2,3,4,5,6,7,8,9...\\n* 2 digits : **10**, **11**, **12**, **13**....\\n* 3 digits : **10**1, **11**1, **12**1, **13**1....\\n* 4 digits : **10**01, **11**11, **12**21, **13**31, ....\\n\\nWe see a trend that if we split the number in half, then first half starts from 1 or 10 or 100 and keep increasing **sequentially**. So first half for n palindrome will be (start + n -1).\\n\\nWe can leverage on this so that we can create any palindrome directly. \\n\\nOnce we have the first half we can reverse and create the second half and thus get the whole number. In case of odd number we have to reverse and remove first character to keep length same as palindrome.\\n\\n\\n```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long[] KthPalindrome(int[] queries, int intLength) {\\n        \\n        int d = (intLength + 1)/2; //length of first half\\n        var odd = intLength % 2 != 0; \\n        \\n        long start = 0;\\n        start = (long)Math.Pow(10, d-1); \\n        long end = (long)Math.Pow(10, d);//if we start from 10 we should go till 99 only else palindrome length will increase\\n        \\n        var arr = new long[queries.Length];        \\n        int count = 1;\\n        for(int i=0; i < queries.Length; i++)\\n        {            \\n            var str = (start + queries[i]-1).ToString();            \\n            var revStr = Reverse(str);\\n            if(odd)\\n                revStr = revStr.Substring(1);\\n            \\n            var numStr = str + revStr;            \\n            //Console.WriteLine($\"str : {str}, revStr : {revStr}\");            \\n            \\n            arr[i] = numStr.Length == intLength ? long.Parse(numStr) : -1;            \\n        }\\n        \\n        return arr;\\n    }\\n    \\n    public static string Reverse( string s )\\n    {\\n        char[] charArray = s.ToCharArray();\\n        Array.Reverse( charArray );\\n        return new string( charArray );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887307,
                "title": "python-straight-forward-solution-half-palindromes",
                "content": "The squence of the palindromes depend on the first half of the palindromes.\\n\\n1) Find a starting point when the number of length N is even or odd. For example, N=2, the half of the first palindromes is 1; N=3, the half of the first palindromes is 10; N=4, the half of the first palindromes is 10.\\n```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\\n2) Find the corresponding first half of the palindrome according to the sequence and get the remaining palindrome based on the first half. Still, the situation will be different when the length is even or odd.\\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nif intLength % 2 == 0 :\\n     power = intLength / 2 - 1\\nelse:\\n     power = (intLength - 1) /2\\n        \\nspoint = 1\\nfor i in range(int(power)):\\n     spoint = spoint * 10\\n```\n```\\nrnumber = []\\nif intLength % 2 == 0:\\n     for query in queries:\\n            number = (query + spoint - 1)\\n            if len(str(number)+str(number)[::-1]) > intLength:\\n                rnumber.append(-1)\\n            else:\\n                rnumber.append(int(str(number)+str(number)[::-1]))\\nelif intLength % 2 != 0:\\n     for query in queries:\\n           number = (query + spoint -1)\\n           if len(str(number)+str(number)[:-1][::-1]) > intLength:\\n               rnumber.append(-1)\\n           else:\\n               rnumber.append(int(str(number)+str(number)[:-1][::-1]))\\nreturn rnumber\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887277,
                "title": "c-solution-maths",
                "content": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nstring nthPalindrome(int n, int k){\\n\\tstring res=\"\";\\n\\tint temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n\\tint palindrome = (int)pow(10, temp);\\n\\tpalindrome += n - 1;\\n    res+=to_string(palindrome);\\n\\t\\n\\tif (k & 1)\\n\\t\\tpalindrome /= 10;\\n\\t\\t\\n\\twhile (palindrome)\\n\\t{\\n        res+=to_string( palindrome % 10);\\n\\t\\tpalindrome /= 10;\\n\\t}\\n    return res;\\n}\\n\\nvector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n\\t\\tvector<long long>ans;\\n   \\n        for(auto &it: queries){\\n           string ele= nthPalindrome(it, intLength);\\n            if(ele.size()!=intLength)ans.push_back(-1);\\n            else ans.push_back(stol(ele));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887259,
                "title": "javascript-typescript-solution-explained",
                "content": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// main idea:\\n// the 1st palindrome will always be of intLength length with 1 as the first and last digit\\n// each next palindrome is always just the previous one with its first half + 1\\n// i.e.:\\n// first: 1001 (first half = 10) | first: 101 (first half = 10)\\n// nth:   7887 (first half = 78) | kth:   595 (first half = 59)\\n// nth+1: 7997 (first half = 79) | kth+1: 606 (first half = 60)\\n// nth+2: 8008 (first half = 80) | kth+2: 616 (first half = 61)\\n\\nfunction kthPalindrome(queries: number[], intLength: number): number[] {\\n    if (intLength === 0) return queries.map(q => -1);\\n\\n\\t// calculate the 1st palindrome\\n    let init = 10**(intLength - 1);\\n    if (init !== 1) init++;\\n\\n\\t// get the first half of the first number as a string, i.e. 100 for 100001 or 10 for 101\\n\\tconst initString = init.toString(10);\\n\\tlet endOfFirstHalfIndex = Math.floor(intLength / 2 + 0.5);\\n\\tconst halfInitString = initString.slice(0, endOfFirstHalfIndex);\\n    \\n    function getNthPalindrome(index: number) {\\n        const nextHalfStr = (+halfInitString + index - 1).toString(10); // figure out the hirst half of the nth palindrome\\n        if (nextHalfStr.length > halfInitString.length) return -1; // we\\'ve over the intLength, return -1;\\n\\t\\t\\n\\t\\t// now we just have to complete palindrome by recreating the other half\\n\\t\\t// (remember to handle both odd and even intLength)\\n\\t\\tconst res = [];\\n        for (let i = 0, j = intLength - 1; i <= j; i++, j--) {\\n            res[i] = nextHalfStr[i];\\n            res[j] = res[i];\\n        }\\n        return +res.join(\\'\\');\\n    }\\n    \\n\\treturn queries.map(getNthPalindrome);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887197,
                "title": "intuitive-easy-to-understand-o-n-constructing-palindrome-optimized",
                "content": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "TO UNDERSTAND THIS, FIRST RUN THIS COMMENTED CODE TO SEE THE INTUTION\\n1. We just have to build half part of palindrome.\\n2. Have you noticed that Difference between two consutive palindromes.\\n\\n\\t\\t101\\n\\t\\t111\\n\\t\\t121\\n\\t\\t131\\n\\t\\t141\\n\\t\\t151\\n\\t\\t161\\n\\t\\t171\\n\\t\\t181\\n\\t\\t191\\n\\t\\t202\\n\\t\\t212\\n\\t\\t222\\n\\t\\t232\\n\\t\\t242\\n\\t\\t252\\n\\t\\t262\\n\\t\\t272\\n\\t\\t282\\n\\t\\t292\\n\\t\\t303\\n\\t\\t313\\n\\t\\t323\\n\\t\\t333\\n\\t\\t343\\n\\t\\t353\\n\\t\\t363\\n\\t\\t373\\n\\t\\t383\\n\\t\\t393\\n\\t\\t404\\n\\t\\t414\\n\\t\\t424\\n\\t\\t434\\n\\t\\t444\\n\\t\\t454\\n\\t\\t464\\n\\t\\t474\\n\\t\\t484\\n\\t\\t494\\n\\t\\t505\\n\\t\\t515\\n\\t\\t525\\n\\t\\t535\\n\\t\\t545\\n\\t\\t555\\n\\t\\t565\\n\\t\\t575\\n\\t\\t585\\n\\t\\t595\\n\\t\\t606\\n\\t\\t616\\n\\t\\t626\\n\\t\\t636\\n\\t\\t646\\n\\t\\t656\\n\\t\\t666\\n\\t\\t676\\n\\t\\t686\\n\\t\\t696\\n\\t\\t707\\n\\t\\t717\\n\\t\\t727\\n\\t\\t737\\n\\t\\t747\\n\\t\\t757\\n\\t\\t767\\n\\t\\t777\\n\\t\\t787\\n\\t\\t797\\n\\t\\t808\\n\\t\\t818\\n\\t\\t828\\n\\t\\t838\\n\\t\\t848\\n\\t\\t858\\n\\t\\t868\\n\\t\\t878\\n\\t\\t888\\n\\t\\t898\\n\\t\\t909\\n\\t\\t919\\n\\t\\t929\\n\\t\\t939\\n\\t\\t949\\n\\t\\t959\\n\\t\\t969\\n\\t\\t979\\n\\t\\t989\\n\\t\\t999\\n   ``` \\n\\t// for(int i=100;i<1000;i++)\\n        // {\\n        //     string s=to_string(i);\\n        //     string r=string(s.rbegin(),s.rend());\\n        //     if(r==s)\\n        //         cout<<r<<\" \"<<i+10<<endl;\\n        // }\\n\\n\\tvector<long long> kthPalindrome(vector<int>& a, int l) {\\n        vector<long long> ans;\\n        int y=(l+1)/2-1;\\n        long long k=1;\\n            k=pow(10,y);\\n        k--;\\n   \\n        int c=0,x=l/2;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            long long t = k+(long long)a[i];\\n            string s=to_string(t);\\n            if(l%2 && s.size()>x+1)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            if(l%2==0 && s.size()>x)\\n            {    ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string r=string(s.rbegin(),s.rend());\\n            if(l%2)\\n                s.pop_back();\\n            s+=r;\\n            t=stoll(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 1887178,
                "title": "c-o-n-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> ans;\\n        for (int q : queries) {\\n            ans.push_back(get(q, intLength));\\n        }\\n        return ans;\\n    }\\n    \\n    long long get(int q, int l) {\\n        if (l==1) return q<10 ? q : -1;\\n        \\n        long long temp = pow(10, l)/pow(10, l/2 + 1);;\\n        long long ans;\\n        \\n        temp += q-1;  \\n        \\n        ans = mirror(temp, l);\\n        if (ans>=pow(10, l)) return -1;\\n        return ans;\\n    }\\n    \\n    long long mirror(long long n, int len) {\\n        int c = len/2;\\n        auto tmp = n;\\n        auto rev = 0;\\n        if(len%2 != 0) tmp/=10;\\n        while (c--) {\\n            n*=10;\\n            n+=tmp%10;\\n            tmp/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887175,
                "title": "python-half-palindrome-pattern-observation",
                "content": "**Working:**\\nIf length `k` is 4 , \\nthen we start with left half of smallest palindrome (1001) , i,e `10` as initial value `ini`\\n- 2nd smallest: `11`  (`10+1`) (1111)\\n- 3rd smallest: `12`  (`10 +3`) (1221)\\n- 4th smallest: `13`  (`10 +3`) (1331)\\n- last smallest: `99` (9999)\\n\\n\\n**if we notice the pattern , we can see that `n`th smallest palindrome\\'s left half is the initial valiue `ini` + `n-1`**\\n\\n```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```\\n\\nIf you have any questions , feel free to ask\\n\\n**Happy Coding !**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def kthPalindrome(self, queries: List[int], k: int) -> List[int]:\\n        ans=[]\\n        for n in queries:\\n            dig = t=k//2 if k&1 else k//2-1\\n            ini = 10**t\\n            sol= ini+n-1\\n            if len(str(sol))>len(str(ini)):         #eg , when k=4 and our left half sol exceeds 99\\n                ans.append(-1)\\n                continue\\n            rev=sol\\n            if k&1:\\n                rev=rev//10\\n            while rev:\\n                sol=sol*10 + rev%10\\n                rev=rev//10\\n            ans.append(sol)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1887143,
                "title": "python3-simple-math-using-string",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        x=intLength//2 + intLength%2 -1\\n        startX=10**x\\n        maxY=int(\\'9\\'*(x+1))\\n        answ=[]\\n        for q in queries:\\n            y=startX + q -1 \\n            if maxY<y:\\n                answ.append(-1)\\n            else:\\n                s=str(y)\\n                if intLength%2:\\n                    s+=s[:-1][::-1]\\n                else:\\n                    s+=s[::-1]\\n                answ.append(int(s))      \\n        return answ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887142,
                "title": "c-ez-math-solution-explained-in-detail-191ms",
                "content": "The approach to this problem is we generate the number in halves since its a palindrome.\\n2 conditions will arise :\\n1.  intLength will be even\\n2.  intLength will be Odd\\n In both of these condtions we need to build the first half of the number differently. If intLength is even ( Eg : intLength=4 ) then we need to generate the first half as pow(10,intLength/2-1). If intLength is odd (Eg:intLength=3) then we need to geerate the first half as pow (10,intLength/2) since in palindrome numers of odd length the middle number occurs only once (eg : 121,13831 ).\\nWhile dealing with each query[i] , we add 1 minus it to the first Half of the number. As you see our first half of the number is complete.\\neg: inLength=3 query[i] =2;\\nfirstHalf=pow(10,1)+(2-1)=11\\n\\neg: intLength = 4, query[i] =5;\\nfirstHalf=pow(10,1)+(5-1)=14\\n\\nTo generate the other half of our number we have 2 cases :\\n1.  If intLength is even then the other half would be just the reverse of the firstHalf.\\n2.  if intLength is odd then the other half would be reverse of the firstHalf after doing firstHalf/10. To prevent overlap of the middle element.\\n  At the end we check whether our number is withing the given RANGE.\\n  NOTE: To prevent integer overflows we convert ourFirst half to string and find its length If the length is greater then intLength no need to generate the otherhalf since that number will be out of range.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long>ans;\\n        long long start=pow(10,intLength%2?intLength/2:intLength/2-1);\\n        long long range=pow(10,intLength);\\n        for(int i=0;i<queries.size();i++){\\n              unsigned long long first=(queries[i]-1)+start,tmp;\\n            string str=to_string(first);\\n            if(str.length()>intLength){\\n                ans.push_back(-1);\\n                continue;\\n            }          \\n            tmp=first;\\n            if(intLength%2)\\n            tmp/=10;\\n            while(tmp)\\n            {\\n                first=(first*10)+(tmp%10);\\n                tmp/=10;\\n            }\\n            if(first>=range||first<range/10)\\n                ans.push_back(-1);\\n            else\\n            ans.push_back(first);        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887102,
                "title": "python-easy-solution-beats-100",
                "content": "1. If length is even we need to select length/2 and append its reverse. For each l/2 number we will have 1 palindrome\\n2. if length s odd we need to select each length/2 append number 0 to 9 then append reverse of length/2 number. For each l/2 number we will have 10 palindrome\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        if intLength == 1:\\n            return [ i if i < 10 else -1 for i in queries ]\\n        else:\\n            start = 10**(intLength//2-1)\\n            end   = 10**(intLength)\\n            res = []\\n            for q in queries:\\n                q -= 1\\n                if intLength%2:\\n                    temp = str(start+q//10 ) + str(q%10) + str(start+q//10 )[::-1]\\n                else:\\n                    temp = str(start+q) +str(start+q )[::-1]\\n                temp = int(temp) if int(temp) < end else -1\\n                res.append(temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887093,
                "title": "python-easy-formula-short-code",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], n: int) -> List[int]:\\n        ans = []\\n        l = n // 2 if n & 1 else n // 2 - 1\\n        for q in queries:\\n            if q > 9 * 10**l:\\n                ans.append(-1)\\n            else:\\n                s = str(q - 1 + 10**l)\\n                s = s + (s[:-1][::-1] if n & 1 else s[::-1])\\n                ans.append(s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886998,
                "title": "c-o-n-of-digits",
                "content": "Count the `nth` palindrome for `ith` query, and store the resutls. `solve2` method is used to calculate the palindrome for the `ith` query.\\n\\nIf there are `n` queries and `k` be the number of digits, then time complexity would be `O(n*k).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve2(int queries, int intLength){\\n        int rex = (intLength & 1) ? (intLength / 2) : (intLength/2 - 1);\\n        int tex = (int)pow(10, rex);\\n        tex += queries - 1;\\n \\n        string res = \"\";\\n        res += to_string(tex);\\n        \\n        string r1 = \"\";\\n        if (intLength & 1)\\n            tex /= 10;\\n \\n        while (tex){\\n            r1 += to_string(tex%10);\\n            tex /= 10;\\n        }\\n        \\n        if(res.size() + r1.size() == intLength){\\n            return (stoll(res+r1));\\n        }\\n        return -1;\\n    }\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        int n = queries.size();\\n        \\n        for(int i =0;i <= n-1;i++){\\n            long long t1 = solve2(queries[i],intLength);\\n            res.push_back(t1);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886997,
                "title": "python-o-n-permutation-similar-to-find-nth-word-in-dictionary",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = []\\n        for i in range(len(queries)):\\n            if queries[i] > 9*(10**((intLength-1)//2)):\\n                ans.append(-1)\\n            else:\\n                if intLength > 1:\\n                    x = [1]+[0]*(intLength-2)+[1]\\n                else:\\n                    x = [1]\\n                queries[i] -= 1\\n                k = (intLength-1)//2\\n                while queries[i] > 0:\\n                    r = queries[i]%10\\n                    queries[i] = queries[i]//10\\n                    if k == intLength-k-1:\\n                        x[k] += r\\n                    else:\\n                        x[k] += r\\n                        x[intLength-k-1] += r\\n                    k -= 1\\n                ans.append(int(\"\".join([str(j) for j in x])))\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4079277,
                "title": "c-generating-palindrome-with-half-string-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) \\n    {\\n        vector<long long> ans;\\n        string pal;\\n        int power;\\n\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(intLength%2 == 0) power = intLength/2-1;\\n            else power = intLength/2;\\n\\n            if(pow(10, power+1) - pow(10, power) < queries[i])\\n                ans.push_back(-1);\\n            else\\n            {\\n                int temp = pow(10, power) + queries[i] - 1;\\n                pal = to_string(temp);\\n\\n                for(int i=intLength/2-1; i>=0; i--) pal += pal[i];\\n\\n                ans.push_back(stoll(pal));\\n            }\\n        }   \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994182,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n    start = pow(10, (intLength + 1) // 2 - 1)\\n    end = pow(10, (intLength + 1) // 2)\\n    mul = pow(10, intLength // 2)\\n\\n    def reverse(num: int) -> int:\\n      res = 0\\n      while num:\\n        res = res * 10 + num % 10\\n        num //= 10\\n      return res\\n\\n    def getKthPalindrome(query: int) -> int:\\n      prefix = start + query - 1\\n      return prefix * mul + reverse(prefix // 10 if intLength & 1 else prefix)\\n\\n    return [-1 if start + query > end else getKthPalindrome(query)\\n            for query in queries]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892801,
                "title": "golang-simple-solution-compute-half-of-the-palindrome",
                "content": "# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n  answer := make([]int64, len(queries))\\n  half := (intLength + 1)/2\\n  start := int(math.Pow10(half-1))\\n  var end int\\n  for i := 0; i < half; i++ {\\n    end = end * 10 + 9\\n  }\\n  // fmt.Printf(\"start: %d, end: %d\\\\n\", start, end)\\n  for i := 0; i < len(queries); i++ {\\n    if start + queries[i] - 1 > end {\\n      answer[i] = -1\\n      continue\\n    }\\n    // Now it is possible to make the palindrome\\n    answer[i] = makePalindrome(start + queries[i] - 1, intLength%2 == 1)\\n  }\\n  return answer\\n}\\n\\n// makePalindrome makes the palindrome by using the first half. It also accepts\\n// a flag that denotes whether the palindrome is odd length or even length. For odd length\\n// we skip duplicating the last digit\\nfunc makePalindrome(half int, odd bool) int64 {\\n  n := half\\n  if odd {\\n    n /= 10 // skip the last digit\\n  }\\n  res := int64(half)\\n  for ; n > 0; n /= 10 {\\n    res = res * 10 + int64(n%10)\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846571,
                "title": "python-simple-100-faster",
                "content": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        ans = []\\n        half_length = (intLength+1)//2 # this handles even and odd both \\n        left_bound = 10**(half_length-1)\\n        right_bound = 10**(half_length)-1\\n        \\n        for query in queries:\\n            if query>(right_bound-left_bound+1):\\n                ans.append(-1)\\n                continue\\n            # add the answers string\\n            left_palli = str(left_bound+query - 1)\\n            right_palli = left_palli[::-1]\\n            # queryth pallindrome will be formed once we combine both \\n            pallindrome = left_palli + right_palli[intLength%2:]\\n            ans.append(int(pallindrome))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723594,
                "title": "js-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe actual code is really messy but on paper it\\'s pretty simple.\\n\\nWe need:\\n\\n- Amount of possible answers for `intLength`, so we can check if query is out of range.\\n- Different approach for odd and even number of `intLength`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## setup\\n\\nFor the amount of possible answers, we can calculate it with math.\\n- odd: $$(10^n-10^{n-1})\\\\times10$$\\n- even: $$(10^n-10^{n-1})$$\\n\\nThe reason for subtracting $$10^{n-1}$$ is to prevent false answers. For example 1000 on right hand side, which mirrors to the left side as 0001. Let `intLength` to be 8, the answer will be `00011000`, or just `11000`.\\n\\nThe reason for $$\\\\times10$$ for odd `intLength` is for digit at the center (`0~9`).\\n\\n`n`, `tenPower` is pretty self explanatory, however the latter one is such a dumb variable name I suggest you come up with a better one.\\n\\n`tenPowerLess` is an awkward one. It needs to exists so we don\\'t run into annoying float precision problems, so I replaced `tenPower/10`. But in hindsight, I would make `tenPower` $$10^{n-1}$$ to make it look cleaner, but hey, it works.\\n\\n## Odd `intLength` Answers\\n\\nWe\\'ll calculate the middle digit together with left-side, so it\\'s easier to make sure the first digit is always non-zero, and incrementing left-side increments the result faster than incrementing the center digit or the right-side.\\n\\nRemember to $$-1$$ because `left` starts at 10*n.\\n\\nThen, reverse the right-side and add everything together.\\n\\n## Even `intLength` Answers\\n\\n`left` here starts at $$10^{n-1}$$. The rest is pretty much the same as odd `intLength` answers. Maybe you can try simplifying this if statement?\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function(queries, intLength) {\\n    const reverse = (n) => {\\n        let result = 0\\n        while(n){\\n            result=(result*10)+n%10;\\n            n=Math.floor(n/10);\\n        }\\n        return result;\\n    }\\n    const n = Math.floor(intLength/2);\\n    const tenPowerLess = 10**(n-1);\\n    const tenPower = tenPowerLess*10;\\n    const count = (tenPower - tenPowerLess) * ((intLength%2)? 10 : 1);\\n    return queries.map((value,index)=>{\\n        if (value>count) return -1;\\n        if (intLength%2) {\\n            const left = value-1+tenPower;\\n            return left*tenPower + reverse(Math.floor(left/10));\\n        } else {\\n            const left = tenPowerLess + value - 1;\\n            // console.log(index,left,tenPower,value)\\n            return left*tenPower + reverse(left);\\n        }\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707888,
                "title": "c-simple-short-clean-code",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```\\n//**It Take me 2 hour to solve this problem\\uD83D\\uDE13**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Adhoc Pattern\\n    //TC=O(N) N=size of queries\\n    //SC=O(N)\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n=queries.size();\\n        vector<long long> ans(n);\\n        for(int i=0;i<queries.size();i++){\\n            vector<int> v(intLength,0);\\n            v[0]=1,v[intLength-1]=1;\\n            int mid=intLength/2,no=queries[i];\\n            bool nonzero=false;\\n            //fill last digit of no  in vector v\\n            if(intLength%2!=0){\\n                v[mid]=(no%10)-1;\\n                no/=10;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                }\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n               \\n            }else{\\n                v[mid-1]=(no%10)-1;\\n                v[mid]=(no%10)-1;\\n                 no/=10;\\n                 //if it  first digit is  last digit then don\\'t need to do -1. so we do ++;\\n                if(mid==0 || mid==intLength-1){\\n                    v[mid]++;\\n                    v[mid-1]++;\\n                }\\n                //if last digit is 0 then chaged to 9\\n                if(v[mid]==-1){\\n                    v[mid]=9;\\n                    v[mid-1]=9;\\n                }else{\\n                    nonzero=true;\\n                }\\n                \\n                \\n            }\\n            int lo=-1,hi=-1;\\n            //even\\n            if(intLength%2==0){\\n                lo=mid-2;\\n                hi=mid+1;\\n            }else{\\n                //odd\\n                lo=mid-1;\\n                hi=mid+1;\\n            }\\n            bool flag=true;\\n            while(no>0 && lo>=0 && hi<intLength){\\n                int rem=no%10;\\n                no/=10;                \\n                if(nonzero==false){\\n                    v[lo]+=(rem-1);\\n                    v[hi]+=(rem-1);\\n                    if(v[lo]==-1){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;hi++;                   \\n                    if(rem!=0){\\n                        nonzero=true;\\n                    }   \\n                    continue;\\n                }\\n                \\n                    v[lo]+=rem;\\n                    v[hi]+=rem;\\n                    //can\\'t make palidrom\\n                    if(v[lo]==10){\\n                        ans[i]=-1;\\n                        flag=false;\\n                        break;\\n                    }                    \\n                    if(v[lo]==0 && nonzero==false){\\n                        v[lo]=9;\\n                        v[hi]=9;\\n                    }\\n                    lo--;\\n                    hi++;\\n                 \\n            }\\n            //intLenght shorter & no is large so can\\'t make palidrome\\n            if(no>0){\\n                ans[i]=-1;\\n                continue;\\n            }\\n            if(flag){\\n                long long curr=0;\\n                for(int j=0;j<v.size();j++){\\n                    curr=curr*10+v[j];\\n                }\\n                ans[i]=curr;\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664005,
                "title": "swift-version-of-most-voted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        /**\\n         \\n         Only the first (intLength + 1) / 2 characters matter. The remaining characters are just a reflection.\\n\\n         Say intLength == 7, so we consider only 4 characters. The minimum number is 1000 and maximum - 9999.\\n\\n         Therefore, we can have 9999 - 1000 + 1 == 9000 palindromes. To find out the palindrome, we add a q - 1 to the minimum number, reverse, and concatenate.\\n\\n         For example, for query 8765, the base number is 1000 + 8765 - 1 == 9764. Concatenating it with 679, we get 9764679 as the result.\\n         \\n         */\\n        let significantNums: Int = (intLength + 1) / 2\\n        let min = (pow(10, significantNums-1) as NSDecimalNumber).intValue // 10^s\\n        let max = (pow(10, significantNums) as NSDecimalNumber).intValue - 1 // 10^(s+1) - 1\\n        \\n        let numsAvailableOfIntLength = max - min + 1\\n        var ans: [Int] = []\\n        for q in queries {\\n            if q > numsAvailableOfIntLength {\\n                ans.append(-1)\\n                continue\\n            }\\n            let firstHalf = min + (q - 1)\\n            let firstHalfAsString = String(firstHalf)\\n            let numOfCharsToDrop = intLength % 2\\n            let stringForReverse = String(firstHalfAsString.dropLast(numOfCharsToDrop))\\n            let reversedHalf = String(stringForReverse.reversed())\\n            let palindrome = firstHalfAsString + reversedHalf\\n            ans.append(Int(palindrome) ?? -1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663559,
                "title": "1-line-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe k\\'th smallest palindrome of a certain length is basically the concatenation of the k\\'th smallest number of half that length rounded up and that number in reverse, potentially without the last digit if the length is odd\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIndexing a range to get the k\\'th number in the range easily\\n\\n# Complexity\\nn being len(queries):\\n\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        return [base:=range(int(10**(-(-intLength//2)-1)),int(10**(-(-intLength//2))))] and [(int(str(base[q-1])+str(base[q-1])[(-1 if intLength%2==0 else -2)::-1]) if q<=len(base) else -1) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528201,
                "title": "go-beginner",
                "content": "\\n# Code\\n```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nimport (\\n\\t\"math\"\\n\\t\"strconv\"\\n)\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    ret := make([]int64, len(queries))\\n    for i, q := range queries {\\n        ret[i] = GetNthPalindrome(q, intLength)\\n    }\\n    return ret\\n}\\n\\n\\nfunc GetNthPalindrome(nth, length int) int64 {\\n\\tif length == 1 {\\n\\t\\tif nth <= 9 {\\n\\t\\t\\treturn int64(nth)\\n\\t\\t} else {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t}\\n\\tdigits := make([]byte, length)\\n\\n\\toperationNumLength := length/2 + (length % 2)\\n\\ttargetNum := int(math.Pow(10, float64(operationNumLength-1))) + nth - 1\\n\\tmaxNum := int(math.Pow(10, float64(operationNumLength)))\\n\\tif targetNum >= maxNum {\\n\\t\\treturn -1\\n\\t}\\n\\thalfStr := strconv.Itoa(targetNum)\\n\\n\\tfor i, c := range halfStr {\\n\\t\\tnum := int(c - \\'0\\')\\n\\t\\tdigits[i] = byte(num)\\n\\t\\tdigits[length-i-1] = byte(num)\\n\\t}\\n\\n\\tstr := \"\"\\n\\n\\tfor _, v := range digits {\\n\\t\\tstr += strconv.Itoa(int(v))\\n\\t}\\n\\n\\tret, _ := strconv.Atoi(str)\\n\\treturn int64(ret)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3503806,
                "title": "easy-jaaava-solution-just-simple-maths-beats-95-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose intLength =4;\\nwe need to check intLength/2 as it should be a palindrome,so here first 2.\\n1st place can have 9 possible numbers(1-9),and second place can have 10 numbers(0-9),also any nth(n>2) place can have 10 possible numbers.\\nHence,total max palindrome possible are 9*pow(10,intLength/2-1).\\nCode is self explanatory..\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple trick is you should take n-1 to do the calculation.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n       \\n        int[] a = new int[intLength];\\n        long[] ans = new long[queries.length];\\n        if(intLength==1 || intLength==2){\\n        for(int i=0;i<ans.length;i++){\\n            if(queries[i]>9)ans[i]=-1;\\n            else{\\n            long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+queries[i];\\n                ans[i]=h;}\\n        }\\n        return ans;\\n        }\\n\\n        for(int i=0;i<ans.length;i++){\\n            int l=0,u=a.length-1,m=(u/2);\\n            l+=m;\\n            u-=m;\\n            double x= 9*Math.pow(10,l);\\n            if(queries[i]>(int)x)ans[i]=-1;\\n            else{\\n                int n = queries[i]-1;\\n                while(n>0 && l>0){\\n                a[u++]=n%10;\\n                a[l--]=n%10;\\n                n/=10;\\n                }\\n                if(n==0 ){\\n                    while(l>0){\\n                        a[u++]=0;\\n                        a[l--]=0;\\n                    }\\n                    a[u++]=1;\\n                    a[l--]=1;\\n                }\\n                else if(l==0){\\n                a[u++]=n%10+1;\\n                a[l--]=n%10+1;\\n                }\\n                long h=0;\\n                for(int k=0;k<intLength;k++)\\n                h = 10*h+a[k];\\n                ans[i]=h;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453217,
                "title": "python-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\nfirst half part of palindrome also are ordered, so we construct first half part of palindrome first, and construct palindrome with reversed first half part, and make query to 0-based first.\\nbecause the number can not have leading zeros, so we can use a base number to construct first half part,\\nbase number is half of intLength and first digit start from 1, the remain start from 0,\\ne,g., intLength = 3, so base number is 10\\nand queries[i] = 90, we make query to 0-based first, 89. And add it to base number, 99, \\nand construct palindrome with reversed number \\'99\\' + \\'9\\' = \\'999\\'\\n\\ntc is O(len(queries)*intLength), sc is O(len(queries))\\n\\'\\'\\'\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = 10 ** ((intLength - 1) // 2)\\n        ans = [q - 1 + base for q in queries]\\n        for idx, half in enumerate(ans):\\n            half = str(half) + str(half)[-1-intLength % 2::-1]\\n            ans[idx] = int(half) if len(half) == intLength else -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390629,
                "title": "javascript-half-at-a-time",
                "content": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthPalindrome = function (q, len) {\\n  let half = 10 ** (Math.ceil(len / 2) - 1);\\n\\n  let ans = [];\\n  for (let nth of q) {\\n    let palindrome = String(half + (nth - 1));\\n\\n    if (len % 2) {\\n      palindrome += [...palindrome.substring(0, palindrome.length - 1)]\\n        .reverse()\\n        .join(\"\");\\n    } else {\\n      palindrome += [...palindrome].reverse().join(\"\");\\n    }\\n\\n    palindrome.length > len ? ans.push(-1) : ans.push(+palindrome);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356616,
                "title": "transformation-of-input",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec kth_palindrome(queries :: [integer], int_length :: integer) :: [integer]\\n  def kth_palindrome(queries, int_length) do\\n    Enum.map(queries, fn query -> int_to_palindrome(query, int_length) end)\\n  end\\n\\n  defp int_to_palindrome(query, int_length) do\\n    half_length = ceil(int_length / 2)\\n    if query <= 10 ** (half_length - 1) * 9 do\\n      10 ** (half_length - 1) + query - 1\\n      |> Integer.to_string()\\n      |> (fn x ->\\n          rev =\\n            x\\n            |> String.codepoints()\\n            |> Enum.reverse()\\n            |> (fn [a | b] -> if(rem(int_length, 2) == 0, do: [a | b], else: b) end).()\\n            |> Enum.join()\\n          \\n          x <> rev\\n        end).()\\n      |> String.to_integer()\\n    else\\n      -1\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3330032,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int k = ceil(intLength / 2.0);\\n        int start = pow(10, k - 1);\\n        vector<long long> ans(queries.size(), -1);\\n        for(int i = 0; i < queries.size(); i++) {\\n            long long val = start + queries[i] - 1;\\n            string suffix = to_string(val);\\n            reverse(suffix.begin(), suffix.end());\\n            string res = to_string(val) + suffix.substr(intLength & 1);\\n            if(res.length() == intLength) ans[i] = stol(res);\\n        }       \\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc reverse(s []byte) string {\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        s[i], s[j] = s[j], s[i]\\n    }\\n    return string(s)\\n}\\n\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    var k int = (intLength  + 1) / 2\\n    var start int = int(math.Pow(10.0, float64(k - 1)))\\n    ans := make([]int64, len(queries))\\n    for i := 0; i < len(queries); i++ {\\n        val := start + queries[i] - 1\\n        prefix := strconv.Itoa(val) \\n        res := prefix + reverse([]byte(prefix))[intLength % 2:]\\n        ans[i] = -1\\n        if len(res) == intLength {ans[i], _ = strconv.ParseInt(res, 10, 64)}\\n    }       \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222118,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst I created a smallest pelindrom number of the given length by creating an int array each with index correspond to each int index, then there are two cases, one is whene it is odd and the other is when it is even. I iterate through all the indices in the given query to create each number. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe way I make the number is to see the remainder of the query[i]. As long as it is with in bond or greater than 0, I know I need to find a bigger number. The reason to substract 1 from query[i] is because the 1st  represent a 0 which should be number 1, the 9th represent 8, and 10th represent a 9. However, after the first index in the middle, the other index will have 1st represent a 1, and so 9 represent a 9, 10 represent a 0.\\n\\n# Complexity\\nLet the size of query be M, and the length be N. \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(MN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long[] kthPalindrome(int[] queries, int intLength) {\\n        int[] c;\\n        long[] rv = new long[queries.length];\\n        boolean oddOrE = intLength%2 == 0;\\n        int index;\\n        for(int i = 0; i < queries.length;i++) {\\n            c = new int[intLength];\\n            c[0] = 1;\\n            c[intLength-1] = 1;\\n            index = 1;\\n            if (oddOrE) {\\n                c[intLength/2] += (queries[i]-1)%10;\\n                c[intLength/2-1] = c[intLength/2];\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index-1 >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index-1] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            } else {\\n                c[intLength / 2] += (queries[i]-1)%10;\\n                queries[i] = (queries[i] -1) /10;\\n                while (queries[i] > 0 && intLength/2-index >= 0) {\\n                    c[intLength/2+index] = c[intLength/2+index] + queries[i]%10;\\n                    c[intLength/2-index] = c[intLength/2+index];\\n                    if(queries[i] % 10 ==0){\\n                        queries[i]/=10;\\n                    }\\n                    else{queries[i] = (queries[i]-1) / 10;}\\n                    index++;\\n                }\\n            }\\n            if(c[0] >= 10 || queries[i]!= 0){\\n                rv[i] = -1;\\n            }else{\\n                for(int j = 0; j < intLength;j++){\\n                    rv[i] = rv[i]*10 + c[j];\\n                }\\n            }\\n        }\\n        return rv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221998,
                "title": "dart-odd-even-approach",
                "content": "# Intuition\\nPick the middle of intLength and calculate left and reverse it and append to the right.\\n\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> kthPalindrome(List<int> queries, int intLength) {\\n    int oddLen = intLength ~/ 2;\\n    int evenLen = (intLength ~/ 2) - 1;\\n    int len = intLength.isEven ? evenLen : oddLen;\\n    int start = pow(10, len).toInt();\\n\\n    for (var i = 0; i < queries.length; i++) {\\n      var x = start + queries[i] - 1;\\n      var s = x.toString();\\n      if (intLength.isEven) {\\n        s += s.split(\\'\\').reversed.join();\\n      } else {\\n        s += s.substring(0, len).split(\\'\\').reversed.join();\\n      }\\n      if (s.length > intLength) {\\n        queries[i] = -1;\\n      } else {\\n        queries[i] = int.parse(s);\\n      }\\n    }\\n\\n    return queries;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219686,
                "title": "formula-in-go",
                "content": "\\n\\n# Code\\n```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math"
                ],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    answerArr := make([]int64, len(queries))\\n\\n    for i, v := range queries {\\n        answerArr[i] = getPalindrome(v, intLength)\\n    }\\n    return answerArr\\n}\\n\\nfunc getPalindrome(x int, intLengthIn int) int64 {\\n    \\n    // fmt.Println(\"1) Count\", int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)))\\n    \\n    if x > int(math.Pow10((intLengthIn + 1)/2)) - int(math.Pow10((intLengthIn - 1)/2)) {\\n        return int64(-1)\\n    }\\n    \\n    num := int((x - 1) + int(math.Pow10((intLengthIn - 1)/2))) * int(math.Pow10((intLengthIn)/2))\\n    // fmt.Println(\"2) num  \", num)\\n    x = (num / (int(math.Pow10((intLengthIn + 1)/2))))\\n    // fmt.Println(\"3) x    \", x)\\n    count := (intLengthIn)/2\\n    revx := 0\\n    for i := 1; x > 0; i++{\\n        // fmt.Println(\"--->\", x % 10)\\n        revx = revx + (x % 10) * int(math.Pow10(count - i))\\n        x = x / 10\\n    }\\n    // fmt.Println(\"4) revx \", revx)\\n    return int64(num + revx)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3200613,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nclass Solution {\\npublic:\\n    LL flip(LL val){\\n        LL ret = 0 ;\\n        while(val){\\n            ret = ret*10 + val%10 ;\\n            val /= 10 ;\\n        }\\n        return ret ;\\n    }\\n    \\n    LL getKth(int digit, int k){\\n        LL ret ;\\n        if(k > 9*pow(10, digit-1))\\n            return -1 ;\\n        return pow(10, digit-1) + k - 1;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<LL>ret ;\\n        for(int k : queries){\\n            if(intLength % 2 == 0)\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d) + b) ;\\n            }\\n            else\\n            {\\n                int d = intLength/2 ;\\n                LL a = getKth(d+1, k) ;\\n                if(a == -1)\\n                {\\n                    ret.push_back(-1) ;\\n                    continue ;\\n                }\\n                LL c = a%10 ;\\n                a /= 10 ;\\n                LL b = flip(a) ;\\n                ret.push_back( a*pow(10, d+1) + c*pow(10, d) + b ) ;\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182925,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        res = []\\n        for x in queries:\\n            temp = str(x + 10**((intLength-1)//2) - 1)\\n            if len(temp) > (intLength+1)//2:\\n                res.append(-1)\\n            else:\\n                if intLength%2 == 0:\\n                    temp += temp[::-1]\\n\\n                else:\\n                    temp += temp[-2::-1]\\n\\n                res.append(int(temp))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157951,
                "title": "python-short-solution-with-explanation-playing-with-half",
                "content": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\\nWith the definition above, the **half** of `kth Palindrome` is `s_half+k` if `s_half+k <= mx_half`\\nLet us walk a few examples with `x = 3`\\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\\n\\n\\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ns_half: 99...9 - There are \\'ceil(x/2)-1\\' 9s (starting point of half)\\nmx_half: 99...9 - There are \\'ceil(x/2)\\' 9s  (max value of half)\\n```\n```\\ns_half = 9, mx_half = 99\\nk = 2, the half of 2nd Palindrome is 9+2 = 11 <= mx_half --> 111\\nk = 90, the half of 90th Palindrome is 9+90 = 99 <= mx_half --> 999\\nk = 100, the half of 100th Palindrome is 9+100 = 109 > mx_half --> -1\\n```\n```\\ndef kthPalindrome(self, qs: List[int], x: int) -> List[int]:\\n\\tmx_half, s_half, ans = int(\\'9\\'*ceil(x/2)), int(\\'1\\'+\\'0\\'*(ceil(x/2)-1))-1, []\\n\\tfor i in qs:\\n\\t\\tans.append(-1)\\n\\t\\tif s_half+i<=mx_half:\\n\\t\\t\\tn = str(s_half+i)\\n\\t\\t\\tans[-1] = int(n+n[:x-len(n)][::-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3118842,
                "title": "swift-solution",
                "content": "\\n# Complexity\\n- Time complexity: On\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func kthPalindrome(_ queries: [Int], _ intLength: Int) -> [Int] {\\n        queries.map { getPlindrome($0, intLength)}\\n    }\\n\\n    func getPlindrome(_ n: Int, _ lenght: Int) -> Int {\\n    let halfCountNumbers = lenght.isMultiple(of: 2) ? lenght / 2 : lenght / 2 + 1\\n\\n    var number = 1\\n\\n    (0..<halfCountNumbers - 1).forEach { _ in\\n        number *= 10\\n    }\\n\\n    let max = number * 10 - number\\n    guard n <= max else { return -1 }\\n\\n    let result = number + n - 1\\n    let second = String(String(result).reversed())\\n    let first = String(result)\\n    let mainResult = Int(first + (lenght.isMultiple(of: 2) ? second : String(second.dropFirst())))!\\n    return mainResult\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073689,
                "title": "find-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n-->\\nThis is second task of all tasks on leetCode/ And this is difficult for me\\n\\nRecursive function - is very long time execute\\nAnd I did have an error \"Time limit exceed\" \\nThis dicision is not my. A save it for me\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} queries\\n * @param {number} intLength\\n * @return {number[]}\\n */\\nvar kthPalindrome = function(queries, intLength) {\\n   \\n    let lenAboutHalf = Math.pow(10, Math.ceil(intLength / 2) - 1);           // either half len +1 (odd length palindrome) or 1 less (for even length palindrome)\\n\\n    let ans = [];\\n    for (let nth of queries) {\\n        let first = lenAboutHalf + (nth - 1) + \"\";// first half of palindrome\\n        let n = first.length;\\n\\n        let second = \"\";                                              // second half of palindrome (first half reverse)\\n        for (let i = n - 1 - (intLength % 2); i >= 0; i--) {\\n            second = second + first[i];\\n        }\\n\\n        let s = first + second;             // full palindrome\\n        if (s.length > intLength) {\\n            ans.push(-1);             // found to be not possible\\n        } else {\\n            ans.push(+s);\\n        }\\n    }\\n\\n    return ans;\\n   \\n   /*\\n    var answer = [];\\n    if(intLength>15 || queries.length > Math.pow(10,4) * 5){\\n        return;\\n    }\\n \\n    function makePalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(0);\\n        }\\n        res[0] = 1;\\n        if(len > 1){\\n            res[len-1] = 1;\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n    function makeMaxPalindromByL(len) {\\n        var res = [];\\n        for(var i=0;i<len;i++){\\n            res.push(9);\\n        }\\n        return Number(res.join(\\'\\'));\\n    }\\n\\n            \\n    function incPalindrom(pal, intLength){\\n        var mas = (pal+\\'\\').split(\\'\\');\\n        var temp = parseInt(intLength/2);\\n\\n        // \\u0435\\u0441\\u043B\\u0438 \\u043D\\u0435\\u0447\\u0435\\u0442\\n        if(intLength%2) {\\n            function incMiddle(m) {\\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp]++;\\n                        return mas;\\n                    } else if(intLength !== 1) {\\n                        mas[temp] = 0;\\n                        return incMiddle(m+1);\\n                    } else return -1;\\n                } else if (m<=temp) {\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m]++;\\n                        \\n                        return mas;\\n                    } else {\\n                        mas[temp+m] = 0;\\n                        mas[temp-m] = 0;\\n                        \\n                        return incMiddle(m+1);\\n                    }\\n                } else return -1;\\n            }\\n            \\n            incMiddle(0);\\n        } else { // \\u0435\\u0441\\u043B\\u0438 \\u0447\\u0435\\u0442\\n        \\n            function incMiddle2(m) {\\n                \\n                if(m===0){\\n                    if(mas[temp] < 9){\\n                        mas[temp-1]++;\\n                        mas[temp]++;\\n\\n                        return mas;\\n                    } else {\\n                        mas[temp] = 0;\\n                        mas[temp-1] = 0;\\n                       return  incMiddle2(m+1);\\n                        \\n                    }\\n                } else if (m<=temp){\\n                    if(mas[temp+m] < 9){\\n                        mas[temp+m]++;\\n                        mas[temp-m-1]++;\\n                        return mas;\\n                    } else {\\n                        mas[temp+m]=0;\\n                        mas[temp-m-1]=0;\\n                        return incMiddle2(m+1);\\n                        \\n                    }\\n                } else return -1;\\n            }\\n            incMiddle2(0);\\n        }\\n        \\n        return Number(mas.join(\\'\\'));     \\n    }\\n  \\n    var start = makePalindromByL(intLength);\\n\\n    \\n    \\n    var allPalindroms = [start];\\n     var maxPal = makeMaxPalindromByL(intLength);\\n    \\n     var indexP = 0;\\n    while(start < maxPal  )  {\\n        allPalindroms[indexP] = start;\\n        start = incPalindrom(start, intLength);\\n   \\n        indexP++;\\n    }\\n    allPalindroms[indexP] = maxPal;\\n    var countPal = allPalindroms.length;\\n   \\n\\n\\n    for(var l=0; l<queries.length; l++){\\n        if(queries[l] > countPal) {\\n            answer[l] = -1;\\n        } else {\\n            answer[l] = allPalindroms[queries[l] - 1];\\n        }\\n    }\\n\\n  return answer;*/\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3027290,
                "title": "python-o-n-solution-explained-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe process palindromes in O(1) time for every query so the overall complexity is $$O(n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use an array of size n to store answers so the space complexity is $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\n        def numofpalins(n) :\\n            return (9 * pow(10, (n - 1) // 2))\\n\\n        ans = []\\n\\n        maxend = 0\\n        totalpalins = numofpalins(intLength)\\n        for i in queries:\\n                if i<=totalpalins:\\n                    maxend = max(maxend, i)\\n\\n        if intLength % 2 == 0:\\n            curlen = intLength // 2\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n\\n        if intLength % 2 != 0:\\n            curlen = math.ceil(intLength/2)\\n\\n            for i in queries:\\n                if i <= maxend:\\n                    curnum = (i-1) + (10 ** (curlen-1)) \\n                    temp = int( str(curnum) + str(curnum)[::-1][1:] )\\n                    ans.append(temp)\\n                else:\\n                    ans.append(-1)\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018933,
                "title": "c-using-pure-math-and-complete-detailed-explanation",
                "content": "# Intuition\\nUsing the knowledge of permutations we can find out how many possible palindromes can be made of a given length. Suppose if length is 5 so for first number we have 9 choices and till ceil(intLength / 2) digits we have 10 choices. As the number is palindrome so rest digits have one choice so we have 9 * 10 * 10 * 1 * 1 palindromes of intLength 5.\\nThen as the number is a palindrome we can find only the first part and then combining it with the reverse of it would be easy. So question is how to get the first part.\\nsuppose writing down 5 digit palindromes.\\n\\npalindrome      index\\n  10001           1\\n  10101           2\\n  10201           3\\n  10301           4\\nwe can see a pattern is being generated that for every palindrome the first part is 100 + index - 1. The 100 comes from the formula pow(10, ceil(intLength / 2) - 1) as ceil(intLength / 2) is the number of digits for first half we have to find. Finally we get our first half we can reverse it and add it to first half * 10^(floor(intLength / 2)).\\n# Approach\\nIterate over the queries array and apply the above math for each queries[i]. If queries[i] is > possible palindromes of intLength then append -1 in res else the whole procedure for finding palindrome.\\n\\n# Complexity\\n- Time complexity:\\nO(n) as the mathematical calculations require O(1) and we do them for whole queries so O(1) * O(n) gives O(n).\\n\\n- Space complexity:\\nO(n) extra space for result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long revNum(long long n) {\\n        long long res = 0;\\n        while (n > 0) {\\n            res *= 10;\\n            res += (n % 10);\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> res;\\n        long long possiblePalindromes = 9 * pow(10, ceil(intLength / 2.0) - 1);\\n        for (int i = 0; i < queries.size(); i++) {\\n            if (queries[i] > possiblePalindromes) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            long long palindrome;\\n            if (intLength % 2) {\\n                long long firstHalf = pow(10, floor(intLength / 2.0)) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf / 10);\\n            }\\n            else {\\n                long long firstHalf = pow(10, floor(intLength / 2.0) - 1) + queries[i] - 1;\\n                palindrome = firstHalf * pow(10, intLength - ceil(intLength / 2.0)) + revNum(firstHalf);\\n            }\\n            res.push_back(palindrome);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973251,
                "title": "typescript-solution",
                "content": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet res = [];\\n    let start = Math.pow(10, Math.floor((intLength + 1) / 2) - 1);\\n    let end = Math.pow(10, Math.floor((intLength + 1 ) / 2))\\n    for (let q of queries) {\\n        if (start + q > end) {\\n            res.push(-1);\\n        } else {\\n            const firstHalf = (start + q - 1).toString();\\n            const secondHalf = firstHalf.slice(0, Math.floor(intLength / 2)).split(\\'\\').reverse().join(\\'\\');\\n            res.push(Number.parseInt(firstHalf + secondHalf))\\n        }\\n    }\\n    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2971197,
                "title": "java-half-palindrome-formula",
                "content": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFormula :-\\nGiven: finding palindrome number n , palindrome has m symbols as digits , there are p symbols (10 symbols in decimal)\\n\\nLet q = ceiling(m / 2)\\nLet offset = p ^ (q - 1)\\nLet number = (n - 1) + offset\\nLet answer be number expanded as a palindrome\\n\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n = queries.length;\\n        long[] ans = new long[n];\\n        int q = (int) Math.ceil((double) intLength / 2);\\n        int offset = (int) Math.pow(10,q-1);\\n        for(int i = 0 ; i < n ; i++){\\n            String half = Integer.toString((queries[i] - 1) + offset);\\n            String halfCopy = half.substring(0,intLength % 2 == 0 ? q : q - 1);\\n            StringBuilder otherHalf = new StringBuilder();\\n            otherHalf.append(halfCopy);\\n            otherHalf.reverse();\\n            String curr = half.concat(otherHalf.toString());\\n            if (curr.length() > intLength){\\n                ans[i] = -1;\\n            }\\n            else{\\n                ans[i] = Long.parseLong(curr);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936433,
                "title": "java-solution-firsthalf",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long[] res = new long[queries.length];\\n        long min = (long) Math.pow(10, (intLength /2 + (intLength % 2) - 1));\\n        long max = (long) Math.pow(10, (intLength /2 + (intLength % 2))) -1;\\n        long multi = (long) Math.pow(10, intLength / 2);\\n        for(int i = 0; i< queries.length; i++){\\n            long firstHalf = min + queries[i] - 1;\\n            if(firstHalf > max) {\\n                res[i] = -1;\\n                continue;\\n            }\\n            long secondHalf = intLength %2 != 0? reverse(firstHalf / 10): reverse(firstHalf);\\n            res[i] = firstHalf * multi + secondHalf;\\n        }\\n        return res;\\n    }\\n\\n    public long reverse(long num){\\n        long res = 0;\\n        while(num != 0){\\n            long d = num %10;\\n            res = res*10 + d;\\n            num /= 10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867707,
                "title": "kotlin-fast-solution",
                "content": "Solution with using just formulas, **without** \"*all range iteration*\" and \"*toString()*\"\\n\\n```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun kthPalindrome(queries: IntArray, intLength: Int): LongArray {\\n        var res = LongArray(queries.size)\\n        \\n        val r = if(intLength % 2 == 0) 0 else 1\\n        val n = intLength / 2 + r\\n        \\n        val lo = Math.pow( 10.0, n.toDouble()-1 ).toLong()\\n        val hi = Math.pow( 10.0, n.toDouble()   ).toLong() - 1\\n        \\n        val dec = Math.pow( 10.0, n.toDouble()   ).toLong()\\n\\n        for((idx, v) in queries.withIndex()) {\\n            var d : Long = lo + v - 1\\n            if( d < lo || d > hi ) d = -1\\n            val s : Long =\\n                if( d == -1L ) {\\n                    d\\n                } else {\\n                    if( r == 1 ) {\\n                        if( d < 10 ) {\\n                            d\\n                        } else {\\n                            d / 10 * dec + revert(d)\\n                        }\\n                    } else {\\n                        d * dec + revert(d)\\n                    }\\n                }\\n            res[idx] = s\\n        }        \\n        \\n        return res\\n    }\\n        \\n    fun revert(i: Long): Long {\\n        var s = 0L\\n        var d = i\\n        var r = 0L\\n        while(true){\\n            r = d % 10\\n            d = d / 10            \\n            s = s * 10 + r\\n            if( d == 0L ) break\\n        }        \\n        return s\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815196,
                "title": "python3-short-code-using-math-better-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n\\t\\t# range = [10 ** (intLength - 1), 10 ** intLength - 1] --> inclusive\\n\\t\\t\\n        rootLength = (intLength + 1) // 2\\n        maxPossible = 10 ** (rootLength - 1) * 9\\n        root = str(10 ** (intLength - 1))[:rootLength]\\n        res = []\\n\\t\\t\\n        for q in queries:\\n\\t\\t\\n            if q > maxPossible:\\n                res.append(-1)\\n\\t\\t\\t\\t\\n            else:\\n                pre = str(int(root) + (q - 1))\\n                if intLength % 2 == 0:\\n                    res.append(int(pre + pre[::-1]))\\n                else:\\n                    res.append(int(pre + pre[:-1][::-1]))\\n\\t\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755086,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int l) {\\n        vector<long long> res;\\n        long long start;\\n        if(l%2)\\n            start = pow(10,l/2);\\n        else\\n            start = pow(10,l/2-1);\\n        \\n        long long end = pow(10,(l+1)/2);\\n        \\n        for(int q:queries){\\n            if(start+q>end){\\n                res.push_back(-1);\\n                continue;\\n            }\\n            \\n            long long firstHalf = start+q-1;\\n            string lhs = to_string(firstHalf);\\n            string rhs = lhs;\\n            if(l%2)\\n                rhs = rhs.substr(0,lhs.size()-1);\\n            \\n            reverse(rhs.begin(),rhs.end());\\n            string fin = lhs+rhs;\\n            res.push_back(stoll(fin));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740248,
                "title": "ruby-solution-easy-variable-names",
                "content": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef kth_palindrome(queries, int_length)\\n  half_length = (int_length + 1) / 2\\n  first_palindrome = 10.pow(half_length - 1)\\n  max_palindromes = first_palindrome * 9\\n  queries.map do |query|\\n    if query > max_palindromes\\n      -1\\n    else\\n      left_part = (first_palindrome + query - 1).to_s\\n      right_part = left_part.reverse\\n      right_part[0] = \\'\\' if int_length.odd?\\n      (left_part + right_part).to_i\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2731212,
                "title": "simple-easy-solution",
                "content": "**Please Upvote If You Fiind Useful**\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        rawnum = 10 ** int((intLength-1)/2)\\n        ans = []\\n        for x in queries :\\n            \\n            firsthalf = rawnum + x - 1\\n            stri = str(firsthalf)   \\n            stri += stri[::-1] if intLength%2 == 0 else stri[:len(stri)-1][::-1]   \\n            if len(stri) == intLength:\\n                ans.append(stri)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674221,
                "title": "c-to-string",
                "content": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        bool isOdd = intLength % 2;\\n        int len = intLength / 2 + isOdd;\\n        int start = pow(10, len-1);\\n        int maxN = pow(10, len) - start;\\n        \\n        \\n        vector<long long> res;\\n        for(auto x:queries){\\n            if(x > maxN) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            int y = start + x-1;\\n            auto s = to_string(y);\\n            auto t = s;\\n            reverse(t.begin(), t.end());\\n            if(isOdd) s.pop_back();\\n            auto z = stoll(s+t);\\n            res.push_back(z);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2662790,
                "title": "fast-python3-solution",
                "content": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def create_palindrome(self, base, query, intLength):\\n        start = f\"{base + query - 1}\"\\n        addIndex = intLength - len(start)\\n        palindrome = f\"{start}{start[:addIndex][::-1]}\"\\n        return int(palindrome)\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        palindromes = []\\n        base = 10**((intLength-1)//2)\\n        for query in queries:\\n            no_palins = base*10 - base\\n            if no_palins < query:\\n                palindromes.append(-1)\\n            else:\\n                palindrome = self.create_palindrome(base, query, intLength)\\n                palindromes.append(palindrome)\\n\\n        return palindromes\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636848,
                "title": "simple-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}\\n\\t\\tvector<long long> kthPalindrome(vector<int>& q, int il) {\\n\\t\\t\\tvector<long long> ans;\\n\\n\\t\\t\\tfor(int i =0 ; i<q.size(); i++)\\n\\t\\t\\t\\tans.push_back(find(q[i], il));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t# define ll longlong\\n\\n\\t\\tlong long find(int i, int l) {\\n\\t\\t\\tint base;\\n\\n\\t\\t\\tif(l%2==0)\\n\\t\\t\\t\\tbase = pow(10, l/2-1);\\n\\t\\t\\telse \\n\\t\\t\\t\\tbase = pow(10, l/2);\\n\\n\\t\\t\\tstring t = to_string(base+i-1);\\n\\t\\t\\tstring b = to_string(base);\\n\\t\\t\\tint n= t.length();\\n\\n\\t\\t\\tif(n>b.length()) \\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tif(l%2==1)\\n\\t\\t\\t\\tb=t.substr(0, n-1);\\n\\t\\t\\telse\\n\\t\\t\\t\\tb=t;\\n\\n\\t\\t\\treverse(b.begin(), b.end());\\n\\t\\t\\tt+=b;\\n\\n\\t\\t\\treturn stoll(t);\\n\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2553818,
                "title": "c-easy-maths-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long >ans;\\n        int val=(intLength-1)/2;\\n        long long  value=9*pow(10,val);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            if(queries[i]>value){\\n                ans.push_back(-1);\\n            }\\n            else{\\n                if(intLength%2){\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                else{\\n                    int cur=queries[i]-1;\\n                    \\n                    string s=\"\";\\n                    for(int j=0;j<intLength;j++){\\n                        s+=\\'0\\';\\n                    }\\n                    \\n                    for(int j=(intLength-1)/2;j>=0;j--){\\n                        int data=cur%10;\\n                        cur=cur/10;\\n                        if(j==0){\\n                            s[j]=1+data+\\'0\\';\\n                            s[intLength-1-j]=1+data+\\'0\\';\\n                        }\\n                        else{\\n                            s[j]=data+\\'0\\';\\n                            s[intLength-1-j]=data+\\'0\\';\\n                        }\\n                    }\\n                    // cout<<s<<endl;\\n                    ans.push_back(stoll(s));\\n                }\\n                \\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2553080,
                "title": "palindrome-with-fixed-length-java-easy-solution",
                "content": "```\\nRuntime: 150ms\\n```\\n```\\nMemory Usage: 100MB\\n```\\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nRuntime: 150ms\\n```\n```\\nMemory Usage: 100MB\\n```\n```\\nclass SolutionForPalindromeWithFixedLength{\\npublic static long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\tlong[] ans = new long[queries.length];\\n\\t\\tint hl = (intLength + 1) / 2;\\n\\t\\tString s1 = \"\";\\n\\t\\tString s2 = \"9\";\\n\\t\\tfor (int i = 0; i < (hl - 1); i++) {\\n\\t\\t\\ts1 += \"0\";\\n\\t\\t\\ts2 += \"9\";\\n\\t\\t}\\n\\t\\ts1 = \"1\" + s1;\\n\\t\\tint sp = Integer.parseInt(s1);\\n\\t\\tint lp = Integer.parseInt(s2);\\n\\t\\tif (intLength == 1) {\\n\\t\\t\\tsp = 1;\\n\\t\\t\\tlp = 9;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < queries.length; i++) {\\n\\t\\t\\tif (queries[i] - 1 + sp > lp) {\\n\\t\\t\\t\\tans[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans[i] = queries[i] - 1 + sp;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(intLength == 0) {\\n\\t\\t\\tArrays.fill(ans,-1);\\n\\t\\t}\\n\\t\\tif (intLength > 1) {\\n\\t\\t\\tif (intLength % 2 != 0) {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i] / 10;\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int i = 0; i < ans.length; i++) {\\n\\t\\t\\t\\t\\tif (ans[i] != -1) {\\n\\t\\t\\t\\t\\t\\tlong tans = ans[i];\\n\\t\\t\\t\\t\\t\\tString s = Long.toString(tans);\\n\\t\\t\\t\\t\\t\\tString sb = new StringBuffer(s).reverse().toString();\\n\\t\\t\\t\\t\\t\\tans[i] = Long.parseLong(Long.toString(ans[i]) + sb);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416530,
                "title": "simple-solution-in-python3",
                "content": "Just generate half of the number and mirror it.\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    \\n    def mirror(self, num, intLength):\\n        if intLength%2==0:\\n            num_mirror = int(str(num)[::-1])\\n            out = num_mirror + num * 10**(intLength//2)\\n        if intLength%2==1:\\n            num_mirror = int(str(num//10)[::-1])\\n            out = num * 10**(intLength//2) + num_mirror\\n        return out\\n    \\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        \\n        if intLength%2==0:\\n            start = 10**(intLength//2-1)\\n            end = 10**(intLength//2)\\n        if intLength%2==1:\\n            start = 10**(intLength//2)\\n            end = 10**(intLength//2+1)\\n        output = []\\n        for q in queries:\\n            if q > end-start:\\n                output.append(-1)\\n            else:\\n                output.append(self.mirror(start+q-1, intLength))\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376635,
                "title": "simple-java-solution-using-math-logic",
                "content": "queries = [1,2,3,4,5,90], intLength = 3\\noutput should be [101,111,121,131,141,999]\\n\\nif we add 9 to each element and append its mirror value to make its lenght equal to intLength we will get palindrome eg.\\n9+1=>10=>10+\"1\"=>101\\n9+2=>11=>11+\"1\"=>111\\n.\\n.\\n90+9=>99=>99+\"9\"=999\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int half = (intLength+1)/2;\\n        Double pow = Math.pow(10, half-1);\\n        int add = pow.intValue() - 1;\\n        long[] result = new long[queries.length];\\n        for(int i = 0; i< queries.length; i++){\\n            if(queries[i]>pow*10){\\n                result[i] = -1;\\n                continue;\\n            }\\n            String tempNum =Integer.toString(queries[i]+add);\\n            long tempResult =0;\\n            String tempString = null;\\n            if(intLength%2==0){\\n                tempString = tempNum + new StringBuilder(tempNum).reverse().toString();\\n                \\n            }\\n            else{\\n                String subString = tempNum.substring(0,intLength/2);\\n                tempString = tempNum + new StringBuilder(subString).reverse().toString();\\n                \\n            }\\n            if(tempString.length()<=intLength){\\n                tempResult = Long.parseLong(tempString);\\n            }\\n            else {\\n                tempResult = -1;\\n            }\\n            result[i] = tempResult;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369422,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        base = pow(10, (intLength+1)//2-1)\\n        ans = []\\n        for q in queries:\\n            response = str(base+q-1)+str(base+q-1)[::-1][intLength%2:]\\n            ans.append(int(response) if len(response) <= intLength else -1)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2329444,
                "title": "python-string-manipulation",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\n        res = []\\n        \\n        halflength = math.ceil(intLength/2)\\n        \\n        left_range = 10**(halflength-1)\\n        right_range = 10**halflength - 1\\n        num_in_range = right_range-left_range + 1\\n        is_odd = intLength % 2 != 0\\n\\n        for q in queries:\\n            if q > num_in_range:\\n                res.append(-1)\\n                continue\\n            \\n            #smallest value in range + q-1\\n            left_half = str(left_range + q - 1)\\n            right_half = left_half[::-1]\\n            \\n            #if value is odd, shave off middle value\\n            if is_odd:\\n                right_half = right_half[1:]\\n            res.append(int(left_half+right_half))\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259703,
                "title": "c-maths",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int m = (intLength + 1) / 2;\\n\\t\\tlong long f = pow(10, m - 1);\\n\\t\\tint n = queries.size();\\n\\t\\tvector<long long> ans(n);\\n\\t\\tlong long mx = 9 * f;\\n\\t\\tstring start = \"\";\\n\\t\\tfor (int i = 0; i < intLength; i++) start += \\'0\\';\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (queries[i] > mx) ans[i] = -1;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tstring s = start;\\n\\t\\t\\t\\tqueries[i]--;\\n\\t\\t\\t\\tlong long d = f;\\n\\t\\t\\t\\ts[0] = s[intLength - 1] = \\'0\\' + (1 + queries[i] / d);\\n\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\tint st = 1, en = intLength - 2;\\n\\t\\t\\t\\twhile (st <= en) {\\n\\t\\t\\t\\t\\ts[st] = s[en] = \\'0\\' + (queries[i] / d);\\n\\t\\t\\t\\t\\tqueries[i] %= d;\\n\\t\\t\\t\\t\\td /= 10;\\n\\t\\t\\t\\t\\tst++, en--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = stoll(s);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255323,
                "title": "python-simple-and-concise-solution",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        answer = []\\n        n = (intLength+1)//2 - 1\\n        \\n        for q in queries:\\n            num = str(10**n + q - 1)\\n            result = num + (num[:n+1-(intLength%2)])[::-1]\\n            if len(result) > intLength:\\n                answer.append(-1)\\n            else:\\n                answer.append(result)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249375,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int il) {\\n        int l=(il+1)/2;\\n        int ll=pow(10,l-1);\\n        int rl=pow(10,l)-1;\\n        int range=rl-ll+1;\\n        vector<long long>v;\\n        for(int i=0;i<q.size();i++){\\n            if(q[i]<=range){\\n               string a=to_string(ll+q[i]-1);\\n               string b=a;\\n                if(il%2==1)b.pop_back();\\n                reverse(b.begin(),b.end());\\n                string c=a+b;\\n                v.push_back(stoll(c));\\n            }\\n            else v.push_back(-1);\\n        }\\n        return v;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235628,
                "title": "showing-runtime-error-please-help",
                "content": "Please review this code :\\nThis code passes sample test cases as well as many test cases but on submitting it shows runtime error.\\nPlease help me in finding mistake.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n      //Finding range of pelindrome number to be found\\n        long long start = (int)pow(10,(intLength-1));\\n        long long end = (int)pow(10, intLength) - 1;\\n        \\n        vector<long long>vec;\\n        \\n        for(long long i = start+1; i <= end; i++){\\n            long long num = i, rev = 0;\\n            while(num!=0){\\n                rev=rev*10+(num%10);\\n                num/=10;\\n            }\\n\\t\\t\\t//Inserting only pelindrome numbers witihin that range\\n            if(i == rev) vec.push_back(rev);\\n        }\\n        //Checking if no any pelindrome found then return empty -1 status\\n        vector<long long> ans;\\n        if(vec.empty()){\\n            ans.push_back(-1);\\n            return ans;\\n        }\\n       //Getting answer of queries from vec array and pushing into ans vector\\n    for(int i = 0;i<queries.size();i++){\\n        ans.push_back(vec[queries[i]-1]);\\n    }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213521,
                "title": "java-kth-permutation-variation",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) \\n    {\\n        int n=queries.length;\\n        \\n        long ans[]=new long[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int k=queries[i];\\n            ans[i]=helper((long)k-1,intLength);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public long helper(long k,int len)\\n    {\\n        int fill=(len+1)/2;\\n        long max=9*(long)Math.pow(10,fill-1);\\n        \\n        if(k>=max)\\n        return -1L;\\n        \\n        long start=(long)Math.pow(10,fill-1);\\n        StringBuilder sb=new StringBuilder(Long.toString((k/start)+1));\\n        \\n        k=k%start;\\n        start=start/10;\\n        \\n        for(int i=2;i<=fill;i++)\\n        {\\n            sb=sb.append((k/start));\\n            k=k%start;\\n            start=start/10;\\n        }\\n        \\n        String x=sb.toString();\\n        sb=sb.reverse();\\n        \\n        if(len%2!=0)\\n        sb=sb.deleteCharAt(0);\\n        \\n        x+=sb.toString();\\n        \\n        long ans=Long.parseLong(x);\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191346,
                "title": "c-index-from-pow-10-length-2",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long> r;\\n        long long start,count,num,ans digitLen,d;\\n        bool bOddLen,firstSkipped=false;\\n        \\n        for (auto& q : queries) {\\n            bOddLen = intLength % 2 == 1;\\n            digitLen = (intLength-1) / 2;\\n\\n            start = pow(10, digitLen);\\n            count = pow(10,digitLen+1)-start;\\n            \\n            num = start + q - 1;\\n            if(q>count) {   r.push_back(-1);  continue; }\\n\\n            ans = num;\\n            firstSkipped = false;\\n            while (num) {\\n                d = num % 10;\\n                num = num / 10;\\n                if (bOddLen && !firstSkipped) {  firstSkipped = true;continue; }\\n                ans = ans * 10 + d;\\n            }\\n           r.push_back(ans);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186268,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        long long int base=(pow(10, (intLength-1)/2));\\n        long long int maxLimit= 9*base;\\n        \\n        vector<long long> res;\\n        long long int a,b;\\n        string str1, str2;\\n        for(auto q: queries) {\\n            if(q>maxLimit) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n            a=base+q-1;\\n            str1=to_string(a);\\n            str2=str1;\\n            if(intLength%2) \\n                str1.pop_back();\\n            reverse(str1.begin(), str1.end());\\n            str2+=str1; \\n            a=stoll(str2);\\n            res.push_back(a);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169448,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        s=[]\\n        c=0\\n        if intLength%2==0:\\n            c=intLength//2-1\\n        else:\\n            c=intLength//2\\n        d=[]\\n        for i in queries:\\n            d=str(10**c +i-1) \\n            if intLength%2==0:\\n                d+=d[::-1]\\n            else:\\n                 d+=d[::-1][1:]\\n            if len(d) == intLength:\\n                s.append(d)\\n            else:\\n                s.append(-1)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121018,
                "title": "simple-python",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```\\n\\t\\n![image](https://assets.leetcode.com/users/images/84116f73-3e47-4e16-a65b-920b807464a0_1654580823.6780982.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        p1 = \\'1\\'\\n        p1 += \\'0\\'*((intLength-1) // 2)  \\n        ans = []\\n        place = 9*(10**((intLength-1) // 2)) # numbers of palindrome in this intlength \\n        for i in queries:\\n            if i <= place:\\n                strTempt = str(int(p1)+i-1) \\n                strTempt += strTempt[::-1]\\n                if (intLength-1) % 2 !=1:\\n                    strTempt = strTempt[:intLength // 2]+ strTempt[intLength // 2 +1:] \\n                ans.append(int(strTempt))\\n            else:\\n                ans.append(-1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061159,
                "title": "c",
                "content": "\\t\\t#define ll unsigned long long int\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long k;\\n\\t\\t\\t\\tif(n%2==0){\\n\\t\\t\\t\\t\\tk = n/2 - 1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tk = n/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlong long m = 1;\\n\\t\\t\\t\\twhile(k--){\\n\\t\\t\\t\\t\\tm = m*10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvector<long long> res;\\n\\n\\t\\t\\t\\tfor(int i=0; i<q.size(); i++){\\n\\t\\t\\t\\t\\tll num = m;\\n\\t\\t\\t\\t\\tnum = num+(q[i]-1);\\n\\t\\t\\t\\t\\tlong long b;\\n\\n\\t\\t\\t\\t\\tif(n%2==1){\\n\\t\\t\\t\\t\\t\\tb = num/10;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tb = num;\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\twhile(b){\\n\\t\\t\\t\\t\\t\\tnum = num*10 + b%10;\\n\\t\\t\\t\\t\\t\\tb = b/10;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(num>h){\\n\\t\\t\\t\\t\\t\\tres.push_back(-1);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tres.push_back(num);\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<long long> kthPalindrome(vector<int>& q, int n) {\\n\\t\\t\\t\\tlong long h=0;\\n\\t\\t\\t\\tint j = n;\\n\\t\\t\\t\\twhile(j--){\\n\\t\\t\\t\\t\\th = h*10 + 9;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2035625,
                "title": "palindrome-with-fixed-length",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }\\n            else{\\n                \\n                int n=queries[i];\\n                \\n                // We can easily write the above sequence for nth\\n//                 palindrome as: (n-1) + 1000\\n//                 For k digit number, we can generalize above formula as:\\n\\n//                 If k is odd\\n//                 => num = (n-1) + 10k/2\\n//                 else \\n//                 => num = (n-1) + 10k/2 - 1 \\n\\n//                 Now rest half digits can be expanded by just \\n//                 printing the value of num in reverse order. \\n//                 But before this if k is odd then we have to truncate \\n//                 the last digit of a value num \\n                    \\n                    \\n                long long temp = (k & 1) ? (k / 2) : (k/2 - 1);\\n                long long num= (long long)pow(10LL, temp);\\n                num += n - 1;\\n                \\n                \\n                string ans=\"\";\\n                \\n                if(k&1){\\n                    if(num<10){\\n                        res.push_back(num);\\n                        continue;\\n                    }\\n                    \\n                    int t=num%10;\\n                    num=num/10;\\n                    \\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    ans+=to_string(t);\\n                    \\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }else{\\n                    ans+=to_string(num);\\n                    string temp=ans;\\n                    reverse(temp.begin(), temp.end());\\n                    ans+=temp;\\n                    \\n                    res.push_back(stoll(ans));\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        vector<long long>res;\\n        int k=intLength;\\n        long long Cpalk;\\n        \\n        //count total number of possible palindrome of kth digits\\n        long long p=(k&1)?((k+1)/2-1):(k/2-1);\\n        Cpalk=(long long)pow(10LL, p)*9;\\n        \\n        \\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //If value of queries is greater than possible number of palindrome of kth digit push_back -1\\n            \\n            if(Cpalk<queries[i]){\\n                res.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2004648,
                "title": "intuitive-easy-to-understand-c",
                "content": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long vecToInt(vector<int>& vec) {\\n        long long res = 0;\\n        for (int i = 0; i < vec.size(); i++) {\\n            res = res * 10 + vec[i];\\n        }\\n        return res;\\n    }\\n\\n    long long getMaxQuery(int len) {\\n        long long res = 9;\\n        if (len%2) len++;\\n        for (int i = 1; i < len/2; i++) {\\n            res *= 10;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int mx = getMaxQuery(intLength);\\n        \\n        vector<long long> res;\\n        for (int q : queries) {\\n            if (q > mx) {\\n                res.push_back(-1);\\n                continue;\\n            }\\n\\n            q--; // Because we\\'re dealing with 0 based index\\n\\n            vector<int> num(intLength, 0);\\n\\n            int l, r; // Starting from the middle and work our way to the boundaries\\n            if (intLength%2) l = r = intLength/2;\\n            else l = (intLength-1)/2, r = intLength/2;\\n\\n            while (l >= 0) {\\n                if (l == 0) {\\n                    // Handeling this case alone because the numbers range from 1 to 9 (9 numbers)\\n                    // we can\\'t have leading zeros\\n                    num[l] = num[r] = (q%9 + 1);\\n                } else {\\n                    // Numbers range from 0 to 9 (10 numbers)\\n                    num[l] = num[r] = (q%10);\\n                }\\n\\n                q /= 10;\\n                l--, r++;\\n            }\\n\\n            res.push_back(vecToInt(num));\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994229,
                "title": "python-first-half-maths",
                "content": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def kthPalindrome(self, queries, intLength):\\n        \"\"\"\\n        :type queries: List[int]\\n        :type intLength: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if intLength % 2 == 0:\\n            start = 10**(intLength/2 - 1)\\n            ma =  9*(10**(intLength/2 - 1))\\n        else:\\n            start = 10**(intLength/2)\\n            ma =  9*(10**(intLength/2))\\n        r = []\\n        for q in queries:\\n            if q > ma:\\n                r.append(-1)\\n                continue\\n            w = str(start + q - 1)\\n            if intLength == 1:\\n                r.append(w)\\n                continue\\n            if intLength % 2 != 0:\\n                r.append(w + w[0:len(w)-1][::-1])\\n                continue\\n            r.append(w + w[:][::-1])\\n        return r\\n            \\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973867,
                "title": "java-cut-the-number-into-half-and-everything-is-clear",
                "content": "for 4 digit number \\nthe first number is  1001;\\nthe second is          1111;\\nthe third is               1221;\\ncut the number into halves:\\n1: 10\\n2: 11\\n3: 12\\n...\\nn: 10+n-1;\\nthen and a reversed number to it. 12--->1221, 13-->1331\\n\\nNOTE: if it\\'s an odd length number, 12321, half is 123, when we add a reversed number to it, we need to remove the last digit 3 \\n\\n\\n\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        long minHalf=(long)Math.pow(10,(intLength-1)/2);\\n        long maxIndex=(long)Math.pow(10,(intLength+1)/2)-minHalf;\\n        boolean isOdd=intLength%2==1;\\n        long res[]=new long[queries.length];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=queries[i]>maxIndex?-1:helper(queries[i],minHalf,isOdd);\\n        }\\n        return res;\\n    }\\n    \\n    private long helper(long index,long minHalf,boolean isOdd){\\n        long half=minHalf+index-1;\\n        long res=half;\\n        if(isOdd){\\n            res/=10;\\n        }\\n        while(half!=0){\\n            res=res*10+half%10;\\n            half/=10;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967265,
                "title": "java-solve-for-half",
                "content": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic long[] kthPalindrome(int[] queries, int intLength) {\\n        var res = new long[queries.length];\\n        \\n        var halfLength = (intLength / 2) + (intLength % 2);\\n        var first = (int) Math.pow(10, halfLength - 1);\\n        var last = (int) Math.pow(10, halfLength) - 1;\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            var half = first + queries[i] - 1;\\n            var next = build(half, intLength);\\n            \\n            res[i] = half > last ? -1 : next;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private long build(long n, long l) {\\n        var res = n;\\n        \\n        if (l % 2 == 1) // for odd length, we skip the middle element\\n            n /= 10;\\n        \\n        \\n        while (n > 0) {\\n            res = res * 10 + n % 10;\\n            n /= 10;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946956,
                "title": "can-someone-help-me-with-what-i-did-wrong",
                "content": "I am getting time exceeded error, I do understand I am using 4 loops but in terms of thinking process, what could I have done better?\\n\\nHere is my code, and TIA\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        ans = [-1 for i in range(len(queries))]\\n        palindrome = []\\n        \\n        low = 10**(intLength-1)\\n        high = 10**intLength\\n        x = 0\\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i]>=high):\\n                queries[i] = -1\\n        \\n        while(low<=high):\\n            if(x<=max(queries)):\\n                str1 = str(low)\\n                str2 = str1[::-1]\\n                if(str1==str2):\\n                    palindrome.append(low)\\n                    x = x + 1\\n                \\n            low = low + 1\\n        \\n        \\n        for i in range(0, len(queries)):\\n            if(queries[i] != -1):\\n                try:\\n                    ans[i] = palindrome[queries[i]-1]\\n                except:\\n                    ans[i] = -1\\n        \\n            \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937935,
                "title": "golang-easy-manipulation-o-n-time-o-1-mem-100",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    half := (intLength - 1) / 2 + 1\\n    \\n    start := 1\\n    for i := 1; i < half; i++ {\\n       start *= 10 \\n    }\\n    \\n    numPalin := start * 9\\n    start--\\n    doubleLast := (intLength & 1) == 0\\n    \\n    ans := make([]int64, len(queries)) \\n    for i := range queries {\\n        if queries[i] > numPalin {\\n            ans[i] = -1\\n        } else {\\n            ans[i] = mirror(start + queries[i], doubleLast)\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc mirror(v int, doubleLast bool) int64 {\\n    ans := 0\\n    p := 1 // power of 10\\n    for v > 0 {\\n        d := v % 10 // digit\\n        v /= 10\\n        \\n        if p == 1 { // first\\n            if doubleLast {\\n                ans = d * 11\\n                p = 100\\n            } else {\\n                ans = d\\n                p = 10\\n            }\\n        } else {\\n            ans = 10 * (d * p + ans) + d\\n            p *= 100\\n        }\\n    } \\n    \\n    return int64(ans)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935424,
                "title": "the-general-rule-to-build-number-palindrome",
                "content": "To solve this problem with confidence, it is better to know the general rule behind number palindrome generation.\\n\\nTo build a palindrome from a number `n`, we can just reverse all the digits of `n` and concatenate them to create a palindrome. \\n\\nLet\\'s start from two base case:\\n\\n*  Build palindrome from a even-length number\\n\\n\\tGiven the number `12`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `12` is `21`, so we get a even-length palindrome `1221`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `12` to get `1`. The reversed number of `1` is `1`. `12`+`1` = `121`. \\n\\n\\tSo we can get two palindromes from a single even-length number: one is even-length and the other is odd-length.\\n\\n*  Build palindrome from a odd-length number\\n\\n\\tGiven the number `123`, try to build the palindromes from it.\\n\\n\\tThe reversed number of `123` is `321`, so we get a even-length palindrome `123321`. \\n\\n\\tTo get odd-length palindrome, we simply drop the last digit of `123` to get `12`. The reversed number of `12` is `21`. `123`+`21` = `12321`. \\n\\n\\tSo we can also get two palindromes from a single odd-length number: one is even-length and the other is odd-length.\\n\\nThe two cases can be generalized and summized as the following table:\\n( I call the number used to generate the palindrome the `seed` number, and its length the `seed len`.)\\n\\n```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```  \\n\\nNow let\\'s take a look another fact about the palindrome generation: **the order**.\\nTake single digit number for example, the palindromes are:\\n**odd length**\\n1 -> 1\\n2 -> 2\\n3 -> 3\\n4 -> 4\\n5 -> 5\\n6 -> 6\\n7 -> 7\\n8 -> 8\\n9 -> 9\\n\\n**even length**\\n1 -> 11\\n2 -> 22\\n3 -> 33\\n4 -> 44\\n5 -> 55\\n6 -> 66\\n7 -> 77\\n8 -> 88\\n9 -> 99\\n\\nYou can see the **generated palindromes are in the same order as the seed number**.\\n**It means if we want to generate the 9-th palindrome of length 1, we just take the 9-th seed and the generated palindrome will be the 9-th palindrome.***\\n\\nNow come back to the problem. It is asking palindrome of a given length, how do we know the seed length? We already know that for any number of length `n`, it can be used to build a palindrome of length `2n` or `2n-1`. So on the other side, **to get a palindrome of length `n`, it can be built from a seed number of length `(n+1)/2` .**\\n\\nOnce we know the seed length, the seed range can be calculated by \\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\\n\\nBy iterating every element in `quries` , we know the `queries[i]th` palindrome can be generated by `start seed + queries[i]` if it does not exceed `end seed`. A helper function `getPal` is then called to get the palindrome from this seed.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```\\n\\n\\n\\nSimilar problems\\nhttps://leetcode.com/problems/sum-of-k-mirror-numbers/\\nhttps://leetcode.com/problems/find-palindrome-with-fixed-length/\\n",
                "solutionTags": [],
                "code": "```\\nseed len  |  seed range   | even-length palindrome  | odd-length palindrome\\n1         | 1 ~ 9         | 11 ~ 99                 | 1 ~ 9\\n2         | 10 ~ 99       | 1001 ~ 9999             | 101 ~ 999\\n3         | 100 ~ 999     | 100001 ~ 999999         | 10001 ~ 99999\\n4         | 1000 ~ 9999   | 10000001 ~ 99999999     | 1000001 ~ 9999999\\n```\n```\\nstart seed=10^(seed_len-1) \\nend seed=10^seed_len - 1\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int seedLen = (intLength+1)/2;\\n        int start = pow(10, seedLen-1), end = pow(10, seedLen);\\n        int n = queries.size();\\n        vector<long long> ret;\\n        bool evenLen = intLength%2==0;\\n        for(int i=0; i<n; i++) {\\n            int seed = queries[i]+start-1;\\n            if(seed>=end)\\n                ret.push_back(-1);\\n            else\\n                ret.push_back(getPal(seed, evenLen));\\n        }\\n        return ret;\\n        \\n    }\\n    \\n    // get palindrome, \\n    // even: even length or not\\n    long long getPal(long long n, bool even) {\\n        long long t = n;\\n        if(!even)\\n            t /= 10;\\n        while(t) {\\n            n = n*10 + t%10;\\n            t/=10;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932368,
                "title": "java-math-time-on-space-o1",
                "content": "Runtime: 48 ms, faster than 82.51% of Java online submissions for Find Palindrome With Fixed Length.\\nMemory Usage: 51.1 MB, less than 97.47% of Java online submissions for Find Palindrome With Fixed Length.\\n```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long[] kthPalindrome(int[] queries, int intLength) {\\n    long ans[] = new long[queries.length];                                    //for answer\\n    int f_len = (intLength>>1) + (intLength&1);                               //for middle of polindrom\\n    char table[] = new char[intLength];                                       //for each digit of polindrome\\n    int id = 0;                                                               //for index of answer\\n    \\n    for(int n : queries){                                         \\n      Arrays.fill(table, \\'0\\');                                                //prepear for current number\\n      table[0] = \\'1\\';                                                         //and fill first number\\n      n--; \\n      for(int i = f_len; i > 0; n /= 10) table[--i] += n%10;                  //fill our table from begin to middle\\n      \\n      if(n == 0){                                                         //if such polindrome exist\\n        for(int i = 0, j = intLength - 1; i < j; ) table[j--] = table[i++];   //fill our polindrome from middle to end\\n        \\n        try {ans[id] = Long.parseLong(new String(table));}                    //try to convert into long\\n        catch (Exception e){ans[id] = -1;}\\n        \\n        id++;      \\n      }else ans[id++] = -1;                                               //if not exist                                           \\n    }\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929286,
                "title": "pure-manipulation-beats-98-5",
                "content": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "solutionTags": [
                    "Math"
                ],
                "code": "-The first thing to note, is that the first palindrome at any intLength starts with 1. For length 1 we have 1, for length 2 we have 11, length 3 we have 101. So i decided to only deal with one side of the possible solution for a  query. \\n\\n-I created an initial, which is the start of the first possible solution. As we loop through the query all we have to do is add the value in query -1 to initial to arrive at what one side of the palindrome will be. With this we can build the other side of the palindrome.\\n\\n-The next thing is determining when we have reached the limit of a query, i found that the limit of a query occurs at 9* initial.\\n\\n\\n        half=math.ceil(intLength/2)\\n        res=[]\\n        initial=int(\\'1\\'+(half-1)*\\'0\\')\\n    \\n        for query in queries:\\n            if query<=9*initial:\\n                new_half=initial+query-1\\n                string_half=str(new_half)#converts to str since we would do reversals later.\\n                \\n                if intLength%2: res.append(int(string_half[:]+string_half[::-1][1:]))\\n                else: res.append(int(string_half+string_half[::-1]))\\n                \\n            else:#From testing i found there are no more than 9*initial palindromes for an intLength\\n                res.append(-1)\\n        return res\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1915677,
                "title": "easy-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long fe(long long e,int a){\\n        long long b=e;\\n        if(a==0){\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        else{\\n            e=e/10;\\n            while(e){\\n                b=b*10+e%10;\\n                e=e/10;\\n            }\\n        }\\n        return b;\\n    }\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        long long a,c,d,e,f;\\n        int b;\\n        vector<long long>ans;\\n        b=l/2+(l%2);\\n        c=pow(10,b-1);\\n        d=pow(10,b)-1;\\n        for(int i=0;i<q.size();i++){\\n            a=q[i];\\n            e=c+a-1;\\n            if(e<=d){\\n                f=fe(e,l%2);\\n                ans.push_back(f);\\n            }\\n            else{\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908127,
                "title": "c",
                "content": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long[] KthPalindrome(int[] queries, int intLength)\\n    {\\n        List<long> list = new List<long>();\\n        long initialValue= (long)(Math.Pow(10, (intLength - 1) / 2));\\n        foreach (int n in queries)\\n            if (initialValue + n > initialValue * 10)\\n                list.Add(-1);\\n            else\\n            {\\n                if (intLength % 2 == 0)\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, intLength / 2) + ReverseLong(n - 1 + initialValue));\\n                else\\n                    list.Add((n - 1 + initialValue) * (long)Math.Pow(10, (intLength - 1) / 2) + ReverseLong((n - 1 + initialValue) / 10));\\n            }\\n        return list.ToArray();\\n    }\\n    public long ReverseLong(long num)\\n    {\\n        long result = 0;\\n        while (num > 0)\\n        {\\n            result = result * 10 + num % 10;\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906438,
                "title": "c-95-faster-time-complexity-o-n-log-n-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int check(int num,int len)\\n    {\\n        int n=0;\\n        if(len&1)\\n            n=len/2;\\n        else\\n            n=len/2-1;\\n        long long int ans=(long long int)pow(10,n)+num-1;\\n        unsigned long long int p=ans;\\n        if(len&1)\\n            ans/=10;\\n        while(ans)\\n        {\\n            p=p*10+ans%10;\\n            ans/=10;\\n        }\\n        return p;\\n    }\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        vector<long long int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            long long int k=0;\\n            k=check(queries[i],intLength);\\n            if(abs(k)>(long long int)(pow(10,intLength)-1))\\n                k=-1;\\n            ans.emplace_back(k);\\n        }\\n        return ans;\\n    }\\n};\\nany problem feel free to ask\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904351,
                "title": "half-length-based-c-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n[](http://www.google.com/url?sa=i&url=https%3A%2F%2Ftestbytessoftware.medium.com%2F50-funny-programming-memes-for-programmers-testbytes-ffa75eb8dcd7&psig=AOvVaw1BkpiZWnF48fPwGBAsVtlS&ust=1648924908713000&source=images&cd=vfe&ved=0CAsQjRxqFwoTCLjh4-TC8_YCFQAAAAAdAAAAABA4)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int len) {\\n        vector<long long>ans;\\n        \\n        ll arr[]={9,99,999,9999,99999,999999,9999999,99999999,999999999,9999999999,99999999999,999999999999,9999999999999,99999999999999,999999999999999};\\n        \\n        for(auto x:queries)\\n        {\\n            \\n            ll k=(len)/2;\\n            \\n            if(len%2==0)\\n                  k=(len)/2-1;\\n            \\n            ll base=pow(10ll,k);\\n            \\n            base+=(x-1);\\n            \\n            if(base>arr[k])\\n            {\\n                ans.push_back(-1);\\n                continue;\\n            }\\n            \\n            string s=to_string(base);\\n            \\n            if(len%2!=0)\\n            {\\n                for(int i=k-1;i>=0;i--)\\n                    s+=s[i];\\n            }\\n            else\\n            {\\n                for(int i=k;i>=0;i--)\\n                    s+=s[i];\\n            } \\n            ans.push_back(stol(s));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902080,
                "title": "c-clean-and-easy-to-understand-short-explain",
                "content": "Steps:\\n1.Calculate the pairs of Palindrome for both even and odd pattern by (intLength+1)/2;\\n2.Generate evary result from left/right of Palindrome to center.\\n\\n```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        public long[] KthPalindrome(int[] queries, int intLength)\\n        {\\n            long[] res = new long[queries.Length];\\n            //maxCount for each intLength from 1 to 15\\n            Dictionary<int, long> maxCountDict = new Dictionary<int, long>();\\n            for(int i = 1; i <= 15; i++)\\n            {\\n                long count = 9;\\n                int j = i-1;\\n                while (j-- > 0)\\n                    count *= 10;\\n                maxCountDict.Add(i, count);\\n            }\\n            //how many palindrome pairs\\n            int pair = (intLength + 1) / 2;\\n            for (int i=0; i < queries.Length; i++)\\n            {\\n                //out of range, assign -1\\n                if (queries[i] > maxCountDict[pair]) res[i] = -1;\\n                else\\n                {\\n                    //from left/right to center, hold all digits\\n                    long[] list = new long[intLength];\\n                    long curr = queries[i];\\n                    for (int j = 0; j < pair; j++)\\n                    {\\n                        //get current index by divide to next total count of 10^(pair - j - 1)\\n                        long count = (long)Math.Pow(10, pair - j - 1);\\n                        long k = curr / count;\\n                        if (curr % count == 0) k--;//if mod is 0, need k--\\n                        curr -= k * count;\\n                        list[j] = k;\\n                        list[intLength-1-j] = k;//work for both odd and even intLength, only issue is double assign for the center of odd pattern\\n                    }\\n                    //remove leading zero\\n                    list[0] = list[0] + 1;\\n                    list[intLength-1] = list[0];//this will work for intLength=1, avoid duplicate +1\\n                    res[i] = long.Parse(String.Join(\"\", list));\\n                }\\n            }\\n            return res;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901337,
                "title": "simple-and-easy-well-commented-c-solution-for-better-undestanding",
                "content": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            } else {\\n                //substr(pos, length) -> pos = position of first character and length of string\\n                //0001 -> 001\\n                temp = temp + rev.substr(1, rev.size()-1);\\n            }\\n            \\n            //Edge case that string should fall under the given length\\n            if(temp.size() == intLength){\\n                \\n                //stoll is used to convert string to long long\\n                ans.push_back(stoll(temp));\\n            }else {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        \\n        //for taking the power if intLength is 7 which is odd then 10^(7/2) i.e., 10^3 and if its 6 which is even the 10^(6/2-1) i.e., 10^2\\n        int power = intLength%2==0 ? (intLength/2-1) : (intLength/2);\\n        int start = pow(10, power);\\n        \\n        vector<long long> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            \\n            //according to the observation 10+ query no. if its length is 3 & if length is 4 then it will start from 100 + query no.\\n            //start+ queries[i] - 1 -> 100 + 1 - 1 = 100\\n            string temp = to_string(start+ queries[i] - 1);\\n            \\n            //rev will store temp and will reverse it\\n            //reverse(100) -> 001\\n            string rev = temp;\\n            reverse(rev.begin(), rev.end());\\n            \\n            //intLength is even then 100+001 -> 100001 as its stored in string\\n            if(intLength%2==0){\\n                temp = temp + rev;\\n                \\n            //if intLength is odd then 1000+001 -> 1000001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901150,
                "title": "golang-o-n-solution",
                "content": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n\\thalfWidth := intLength/2 + intLength%2\\n\\tfirstValue, maxValue := 1, 9\\n\\tfor i := 1; i < halfWidth; i++ {\\n\\t\\tfirstValue *= 10\\n\\t\\tmaxValue = maxValue*10 + 9\\n\\t}\\n\\tmaxQuery := maxValue - firstValue + 1\\n\\tanswers := make([]int64, 0, len(queries))\\n\\tfor _, query := range queries {\\n\\t\\tif query > maxQuery {\\n\\t\\t\\tanswers = append(answers, -1)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\thalfAnswer := firstValue + query - 1\\n\\t\\thalfAnswerString := strconv.Itoa(halfAnswer)\\n\\t\\tshift := 1\\n\\t\\tpairAnswer := 0\\n\\t\\tfor width := halfWidth; width < intLength; width++ {\\n\\t\\t\\tpairAnswer += shift * int(halfAnswerString[width-halfWidth]-\\'0\\')\\n\\t\\t\\tshift *= 10\\n\\t\\t}\\n        answers = append(answers, int64(halfAnswer*shift+pairAnswer))\\n\\t}\\n\\treturn answers\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1898708,
                "title": "python-solution-beats-75",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], inl: int) -> List[int]:\\n\\t\\t\\tres = []\\n\\t\\t\\tif inl == 1:\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tif i > 9:\\n\\t\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tres.append(i)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\tif inl % 2:\\n\\t\\t\\t\\tx = inl // 2\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tm = m[1:]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\t\\t\\telse:\\n\\t\\t\\t\\tx = inl // 2 - 1\\n\\t\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\t\\tnum = 10 ** x\\n\\t\\t\\t\\t\\tnum = num + (i-1)\\n\\t\\t\\t\\t\\tm = str(num)\\n\\t\\t\\t\\t\\tm = m[::-1]\\n\\t\\t\\t\\t\\tele = int(str(num) + m)\\n\\t\\t\\t\\t\\tif ele >= 10**inl:\\n\\t\\t\\t\\t\\t\\tele = -1 \\n\\t\\t\\t\\t\\tres.append(ele)\\n\\t\\t\\t\\treturn res\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1897455,
                "title": "one-pass-98-speed",
                "content": "![image](https://assets.leetcode.com/users/images/8a4495ca-4645-4298-8116-5a5d3474ba51_1648642223.1228337.png)\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        half = intLength // 2\\n        odd = intLength % 2\\n        half += odd\\n        max_num = pow(10, half)\\n        base = max_num // 10 - 1\\n\\n        def query(i: int) -> int:\\n            n = base + i\\n            if n < max_num:\\n                s = str(n)\\n                s += s[::-1][odd::]\\n                return int(s)\\n            else:\\n                return -1\\n\\n        return [query(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896729,
                "title": "95-faster-easy-python3-solution-find-palindrome-with-fixed-length",
                "content": "# upvote if useful\\n![image](https://assets.leetcode.com/users/images/ece1fee8-e10c-40ec-b49f-74c5bcb685cb_1648623154.3350413.png)\\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, q: List[int], l: int) -> List[int]:\\n        ans = []\\n        if l%2==0:\\n            x = (l//2)-1\\n        else:\\n            x = l//2\\n        #print(x)\\n        for i in q:\\n            a = str(10**x+i-1)\\n            b = a[::-1]\\n            if l%2==0:\\n                a = a+b\\n            else:\\n                a = a+b[1:]\\n            if len(a)==l:\\n                ans.append(a)\\n            else:\\n                ans.append(-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896517,
                "title": "python-easy-solution-time-o-n-fastest-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n\\t\\t\\tres=[]\\n\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\tpow = (intLength//2)-1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tpow = intLength//2\\n\\t\\t\\tfor i in queries:\\n\\t\\t\\t\\tans = str(10**pow + i-1)\\n\\t\\t\\t\\trev=ans[::-1]\\n\\t\\t\\t\\tif intLength%2==0:\\n\\t\\t\\t\\t\\tans+=rev\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans+=rev[1:]\\n\\t\\t\\t\\tif len(ans)==intLength:\\n\\t\\t\\t\\t\\tres.append(int(ans))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres.append(-1)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1895998,
                "title": "c-easy-to-understand-observational-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long hf;\\n    string getHalf(int q){\\n        int st=pow(10,hf-1);\\n        return to_string(st+q-1);\\n    }\\n    vector<long long> kthPalindrome(vector<int>& queries, int mxl) {\\n        vector<long long> ans;\\n        hf=mxl/2+(mxl%2?1:0);\\n        for(auto&q:queries){\\n            string gh= getHalf(q);\\n            string oh=mxl%2?gh.substr(0,gh.size()-1):gh;\\n            reverse(oh.begin(),oh.end());\\n            gh+=oh;\\n            if(gh.size()==mxl)ans.push_back(stoll(gh));\\n            else ans.push_back(-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895534,
                "title": "observation-based-question-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        vector<long long> res;\\n        int pw = n % 2 == 0 ? (n/2 - 1) : (n/2);\\n        int st = pow(10,pw);\\n        \\n        for(auto q : queries){\\n            string ans = to_string(st + q - 1);\\n            string rev = ans;\\n            if(n % 2) rev.pop_back();\\n            reverse(rev.begin(),rev.end());\\n            ans += rev;\\n            if(ans.size() == n) res.push_back(stoll(ans));\\n            else res.push_back(-1);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894601,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\\n        int n = queries.size();\\n        vector<long long> sol(n);\\n        int len = (intLength + 1) / 2;\\n        auto getLen = [] (long long v) {\\n            int len = 0;\\n            while (v > 0) {\\n                v /= 10;\\n                ++len;\\n            }\\n            return len;\\n        };\\n        auto getPal = [&] (long long v) {\\n            long long value = v;\\n            if (intLength & 1) {\\n                value /= 10;\\n            }\\n            while (value > 0) {\\n                int d = value % 10;\\n                v = v * 10 + d;\\n                value /= 10;\\n            }\\n            return v;\\n        };\\n        long long val = pow(10, len - 1);\\n        for (int i = 0; i < n; i++) {\\n            long long v = queries[i] - 1;\\n            long long val1 = val + v;\\n            if (getLen(val1) > len) {\\n                sol[i] = -1;\\n            }\\n            else {\\n                sol[i] = getPal(val1);\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894170,
                "title": "golang",
                "content": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc kthPalindrome(queries []int, intLength int) []int64 {\\n    base := 1\\n    for i := 0; i < (intLength - 1) / 2; i++ {\\n        base *= 10\\n    }\\n    \\n    res := make([]int64, len(queries))\\n    \\n    for i, q := range queries {\\n        if q - 1 >= 9 * base {\\n            res[i] = -1\\n            continue\\n        }\\n        a := base - 1 + q             \\n        b := a\\n        if intLength % 2 == 1 {\\n            b /= 10\\n        }\\n        for b > 0 {\\n            a = a * 10 + b % 10\\n            b /= 10\\n        }\\n        res[i] = int64(a)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894091,
                "title": "python-two-similar-solutions",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```\\n\\nIn the first one we check the length of the string, in the second one we check that the number does not exceed a certain threshold (should be a bit faster, I think).\\n\\n`~odd` is an odd way to write `-1 - odd`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        odd = intLength&1\\n        h = intLength//2 + odd\\n        x = 10**(h - 1)\\n        return [int(n+n[~odd::-1]) if len(n := str(x+q-1)) <= h else -1 for q in queries]\\n        # return [int((n := str(y))+n[~odd::-1]) if (y := x+q-1) < 10*x else -1 for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893895,
                "title": "recursively-obtaining-palindrome-python",
                "content": "##### How to obtain the palindrome:\\nWe need to figure out a pattern to relaiably obtain the correct palindrome given the intlength and query number. Let\\'s see how bigger palindromes are related to the smaller palindromes. \\n\\nFor example, using intLength 3, the first 11 palindromes are 101, 111, 121... 191, 202. Notice that after 10 iterations, the outer number increases. For a palindrome of intLength 1, there are 9 palindromes (1-9), with 0 being excluded. \\n\\nFrom this example, we can see that each outer most number can contain 10 smaller palindromes  inside it (0 is included as long as it is not the outer most number). And we can deduce that the largest palindrome for intLength 3 is 999 with a query number of 90 (the example was kind enough to give this clue). \\n\\nFrom this observation, we can conclude a couple things:\\n* The relationship between large palindromes and small palindrome\\n* The max Query number given the intLength (1:9, 2:9, 3:90, 4:90, 5:900...) \\n\\nUsing these observations, we can get the outer most palindrome number by dividing a base number which changes based on the current intLength. \\n\\n```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        def helper(num, length, pos):\\n            if length == 0:\\n                # base case\\n                return 0\\n            elif length == 1:\\n                # base case\\n                return num*(10**pos)\\n            else:\\n\\t\\t\\t\\t# (length-1//2) because we want to get the correct base number\\n\\t\\t\\t\\t# length = 1,2 we want base number 1\\n\\t\\t\\t\\t# length = 3,4 we want base number 10 and so on\\n                base = 10**(max(0,(length-1)//2))\\n                n, newNum = divmod(num,base)\\n            if intLength == length:\\n                # n+1 because in order to form a valid palindrome, our outer numbers needs to\\n                # be from 1-9, 10 is not possible since we ruled them out in the beginning (max_base)\\n                return (n+1)*(10**(length-1)) + (n+1) + helper(newNum, length-2, pos+1)\\n            else:\\n                return n*(10**(length-1+pos)) + n*(10**pos) + helper(newNum, length-2, pos+1)\\n                \\n        ans = []\\n        # if query number exceeds max_base, this means it is not possible to form a palidnrome\\n        max_base = int(10**((max(0,intLength-1)//2)) * 9) \\n        if intLength == 1:\\n            # handles special case, not sure how to handle every case in the helper function without making it ugly\\n            return [x if x < 10 else -1 for x in queries]\\n        for n in queries:\\n            if n > max_base:\\n                ans.append(-1)\\n            else:\\n                # queries number starts from 0 instead of 1 (n-1)\\n                res = helper(n-1, intLength, 0)\\n                ans.append(res)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1893534,
                "title": "rust-iter-rev-collect-o-n",
                "content": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn kth_palindrome(queries: Vec<i32>, int_length: i32) -> Vec<i64> {\\n        let mut res = vec![];\\n        let p_len = int_length;\\n        let mut is_odd = true;\\n        if p_len % 2 == 0 {\\n            is_odd = false;\\n        }\\n        let half = if is_odd {\\n            p_len / 2 + 1\\n        } else {\\n            p_len / 2\\n        };\\n        let half = half as u32;\\n        let start = 10_i32.pow(half - 1);\\n        let end = start * 10;\\n        \\n        for q in queries {\\n            if q > end - start {\\n                res.push(-1);\\n                continue\\n            }\\n            let pal = start + q - 1;\\n            // println!(\"pal is {:?}\", pal);\\n            let mut cs: Vec<char> = pal.to_string().chars().collect();\\n            if is_odd {\\n                cs.pop();\\n            }\\n            let last_half: String = cs.iter().rev().collect();\\n            // println!(\"es is {:?}\", es);\\n            let mut curr = pal.to_string();\\n            curr.push_str(&last_half[..]);\\n            // println!(\"curr is {:?}\", curr);\\n            let curr:i64 = curr.parse().map_or(0, |v| v);\\n            // println!(\"curr is {:?}\", curr);\\n            res.push(curr);\\n        }\\n        \\n        res\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893181,
                "title": "python-easy-to-understand-solution-with-simple-explanation-faster-than-90",
                "content": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        n = intLength//2\\n        if(intLength%2==0):\\n            ## even length (2n)  n>=1\\n            ##          - only need to consider left half, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**(n-1) (first digit (0,9], remaining n-1 digits [0,9] ))\\n            ##                  => smallest 1*10**(n-1) (first digit=1, remaining n-1 digits = 0)\\n            total_palindrome = 9*(10**(n-1))\\n            first_smallest = 1*(10**(n-1))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**n)+self.flip(kth_smallest))\\n        else:\\n            ## odd length (2n+1)  n>=0\\n            ##          - only need to consider left half and middle one, flip left half to get remaining right half\\n            ##                  => total number of palindrome 9*10**n (first digit (0,9], remaining n digits [0,9] ))\\n            ##                  => smallest 1*10**n (first digit=1, remaining n digits = 0)\\n            total_palindrome = 9*(10**(n))\\n            first_smallest = 1*(10**(n))\\n            res = []\\n            for k in queries:\\n                kth_smallest = first_smallest + (k-1)\\n                if(k>total_palindrome):\\n                    res.append(-1)\\n                else:\\n                    res.append(kth_smallest*(10**(n))+self.flip(kth_smallest//10))\\n        return res\\n    \\n    def flip(self, number):\\n        return int(str(number)[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892003,
                "title": "c-sol-for-those-who-couldn-t-find-the-formula",
                "content": "Remember t = queries[x] - 1.\\nRest of the code is simple brute.\\n```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& queries, int n) {\\n        int q = queries.size();\\n        int k = n/2 + n%2;\\n        vector<long long> res(q);\\n        for(int x = 0; x < q; x++)\\n        {\\n            int t = queries[x]-1;\\n            vector<int> temp(k, 0);\\n            for(int y = 0; y < k && t; y++)\\n            {\\n                int i = t%10;\\n                temp[y] = i;\\n                t = t/10;\\n            }\\n            if(t || temp[k-1] == 9)\\n            {\\n                res[x] = -1;\\n                continue;\\n            }\\n            temp[k-1]++;\\n            string s = \"\";\\n            for(int y = 0; y < k; y++)\\n                s += to_string(temp[y]);\\n            string tt = s;\\n            if(n%2)\\n                tt.erase(tt.begin());\\n            reverse(s.begin(), s.end());\\n            s = s + tt;\\n            res[x] = stoll(s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891773,
                "title": "c-faster-than-100-memory-less-than-100-simple",
                "content": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }\\n            else{\\n                long long ans = a-1 + n;\\n                int temp = ans;\\n                if(l%2==1)\\n                    temp/=10;\\n                \\n                while(temp){\\n                    ans = ans*10 + temp%10;\\n                    temp/=10;\\n                }\\n                v.push_back(ans);\\n            }\\n        \\n        return v;\\n    }\\n};\\n\\nHit like if found helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> kthPalindrome(vector<int>& q, int l) {\\n        \\n        int a = pow(10,l/2);\\n        if(l%2==0)\\n            a = pow(10,(l/2)-1);\\n        \\n        int last=9;\\n        if(l%2==0)\\n            last = 0;\\n        \\n        for(int i=1;i<=l/2;i++)\\n            last = last*10 + 9;\\n        \\n        vector<long long> v;\\n        \\n        for(auto n : q)\\n            if(last-a+1 < n){\\n                v.push_back(-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1891734,
                "title": "python-easy-solution-with-explanation",
                "content": "There\\'s a pattern, so the idea is to find the starting number for the first half.\\nThe starting number can be:\\n```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\\n`10 ** ((intLength + odd) // 2 - 1)`\\nOnce you find it, except for the edge case when it\\'s 0, everything else is easy.\\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n0\\n1\\n10\\n100\\n1000\\n......\\n```\n```python\\n        odd = intLength % 2 != 0\\n        startNum = 10 ** ((intLength + odd) // 2 - 1)\\n        res = []\\n        \\n        for n in queries:\\n            currNum = str(startNum + n - 1)\\n            currNum = currNum + currNum[::-1][odd:]\\n            if startNum == 0: currNum += 1\\n            if len(currNum) > intLength: res.append(-1)\\n            else: res.append(int(currNum))\\n            \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891710,
                "title": "ruby",
                "content": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} queries\\n# @param {Integer} int_length\\n# @return {Integer[]}\\ndef kth_palindrome(queries, int_length)\\n   res = []\\n   queries.each do |elem|\\n     res << pdm(elem, int_length)\\n   end\\n   res\\nend\\n\\ndef pdm(position, length)\\n    if length == 1\\n        return -1 if position.to_s.length > length\\n        (position.to_s == position.to_s.reverse) ? position : -1\\n    elsif length == 2\\n        num = position*11\\n        return -1 if num.to_s.length > length\\n        (num.to_s == num.to_s.reverse) ? num : -1\\n    elsif length % 2 == 0\\n        fp = 10**((length/2)-1) + (position-1)\\n        lp = fp.to_s.reverse\\n        p = (fp.to_s + lp)\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    else\\n        fp = 10**(length/2) + (position-1)\\n        lp = fp.to_s.reverse[1..-1]\\n        p = fp.to_s+lp\\n        return -1 if p.length > length\\n        (p == p.reverse) ? p.to_i : -1\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1891421,
                "title": "javascript-solution",
                "content": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nvar kthPalindrome = function(queries, intLength) {\\n         let count = Math.floor((intLength+1)/2);\\n        let start = Math.pow(10,count-1);\\n        let ans =[];\\n        for(let i=0;i<queries.length;i++) {\\n            let q = queries[i];\\n            let half = start+q-1;\\n                let rev = half.toString().split(\"\").reverse().join(\"\");\\n            if(intLength%2==0){\\n                let num = (half+rev);\\n                if(num.length == intLength){\\n                 ans.push(Number(num));\\n                } else {\\n                 ans.push(-1);\\n                }\\n            } else {\\n                let num = ((half+rev.slice(1)));\\n                if(num.length == intLength){\\n                     ans.push(Number(num));\\n                }  else {\\n                 ans.push(-1);\\n                }\\n            }\\n        }\\n        return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891413,
                "title": "my-java-solution-by-observing-the-1-2-3-4-10-11-12-13-100-101-102-pattern",
                "content": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        // 11 22 33 44 55\\n        // 101 111 121 131 141\\n        // 1001 1111 1221 1331 1441\\n        // 10001 10101 10201 ....... we can observe the pattern that its liek 1, 2, 3, 4 or 10, 11, 12, 13 or 100, 101, 102 etc\\n        List<String> store = new ArrayList<>();\\n        int powerFactor = 0;\\n        boolean isEven = false;\\n        if (intLength % 2 == 0) {\\n            powerFactor = (int)(Math.pow(10, (intLength / 2) - 1));\\n            isEven = true;\\n        }\\n        else {\\n            powerFactor = (int)(Math.pow(10, intLength / 2));\\n        }\\n        for (int query : queries) {\\n            StringBuilder sb = new StringBuilder();\\n            int kthPalindromeStart = powerFactor + query - 1;\\n            sb.append(kthPalindromeStart);\\n            String normal = sb.toString();\\n            String reversed = sb.reverse().toString();\\n            sb = new StringBuilder();\\n            if (isEven) {\\n                // 100 -> we reverse fully to get 001 and append both to get 100001\\n                sb.append(normal).append(reversed);\\n            }\\n            else {\\n                //100 -> we reverse the first 2 letters to get 01 and append both to get 10001\\n                sb.append(normal).append(reversed.substring(1));\\n            }\\n            if (sb.length() == intLength)\\n                store.add(sb.toString());\\n            else\\n                store.add(\"-1\");\\n        }\\n        //System.out.println\\n        long [] result = new long [store.size()];\\n        int index = 0;\\n        for (String value : store) {\\n            result[index++] = Long.valueOf(value);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891407,
                "title": "java-solution-100-time-space-complexity-simple-reverse",
                "content": "\\tclass Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic long computeNumber(long num, boolean check) {\\n\\t\\t\\tlong result = num;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tif (!check)\\n\\t\\t\\t\\tnum /= 10;\\n\\n\\t\\t\\tlong reversed = 0;\\n\\t\\t\\tfor (; num != 0; num /= 10) {\\n\\t\\t\\t\\treversed = reversed * 10 + num % 10;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (long)(result * Math.pow(10, count)) + reversed;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic long[] kthPalindrome(int[] queries, int intLength) {\\n\\t\\t\\tlong[] result = new long[queries.length];\\n\\n\\t\\t\\tlong start = (long)Math.pow(10, (intLength + 1)/2 - 1);\\n\\t\\t\\tlong end = (long)Math.pow(10, (intLength + 1)/2);\\n\\n\\t\\t\\tboolean even = (intLength % 2 == 0);\\n\\t\\t\\tfor (int i = 0; i < queries.length; i++)\\n\\t\\t\\t\\tif (start + queries[i] > end)\\n\\t\\t\\t\\t\\tresult[i] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[i] = computeNumber(start + queries[i] - 1, even);\\n\\n\\t\\t\\treturn result;\\n\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1750340,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576553,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1832575,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1759419,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 2033331,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1997398,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1718627,
                "content": [
                    {
                        "username": "dc_devesh7",
                        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach would be iterating through every K-digit number and check if it is a palindrome and store all palindromes in another array. However, this is clearly not efficient. \\n\\nHow do we make it faster? We know palindromes look same from both ends. So instead of checking all numbers of length k, we can generate numbers of length k/2 and concating it to its own reflection gives us a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets say we need palindrome of length 8. For this, we generate numbers of length 4 and add its reflection to create a palindrome.\\nExample:\\n1: 1000 ----------> Palindrome = 1000 + 0001 = 10000001\\n2: 1001 ----------> Palindrome = 1001 + 1001 = 10011001\\n3: 1002 ----------> Palindrome = 1002 + 2001 = 10022001\\n4: 1003 ----------> Palindrome = 1003 + 3001 = 10033001\\n.\\n.\\n.\\n.\\n100: 1099 ----------> Palindrome = 1099 + 9901 = 10999901\\n\\n> Here by generating first 100 4-digit numbers, we also subsequently generated first 100 8-digit palindromes. We can see a pattern here.\\n\\n> To get nth palindrome having k-digits, we have ( n-1 ) + ( 10^(p/2) ) \\nwhere p = math.ceil(k/2)\\n\\nThis is for even digit cases. For odd digit cases, we generate numbers of length math.ceil(intLength/2) and while adding the reflection, we ignore the middle element."
                    },
                    {
                        "username": "mrvyomgupta",
                        "content": "Example 1:\\n \\nInput: queries = [1,2,3,4,5,90], intLength = 3\\nOutput: [101,111,121,131,141,999]\\nExplanation:\\nThe first few palindromes of length 3 are:\\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...       **201 is not a palindrome**\\nThe 90th palindrome of length 3 is 999.\\n\\n\\n201 is a palindrome OMEGALUL?\\n"
                    },
                    {
                        "username": "DeviIPrince",
                        "content": "202\\n"
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "how to know time limit to solve problem"
                    },
                    {
                        "username": "kmp1084",
                        "content": "If you know the formula you can do the question! If you set out to derive the formula during an interview. Brave! Good Luck!"
                    },
                    {
                        "username": "siddhi1794",
                        "content": "The question needs better explanation. I read the examples but didn\\'t get them fully."
                    },
                    {
                        "username": "mohamednasr24",
                        "content": "Look, list which in input is indexes of palindrome numbers which their length is n \\nL = [1,2,3], n = 1 \\npalindrome numbers of 1 digit are: 1, 2, 3, \\u2026., 9\\nso ans is [1, 2, 3] \\n\\nL = [1, 2, 3, 9], n = 2 \\npalindrome numbers of 2 digits are: 11, 22, 33, \\u2026., 99 \\nso ans is [11, 22, 33, 99] "
                    },
                    {
                        "username": "Deep_down",
                        "content": "i am stuck anybody give me the reputation :)   ^^^ please upvote\\n"
                    },
                    {
                        "username": "viksa14",
                        "content": "class Solution:\\n    def kthPalindrome(self, queries: List[int], intLength: int) -> List[int]:\\n        length = str(1)+str(0)*(intLength-1)\\n        minlength = int(length)\\n        maxlength = str(9)*(intLength)\\n        maxlength = int(maxlength) \\n        lst = []\\n        def recurr(x):\\n            x_temp = x \\n            temp = 0\\n            while(x!=0):\\n                temp = (temp*10)+(x%10)\\n                x = x//10\\n            if temp==x_temp:\\n                return True\\n            else:\\n                return False\\n        hash = {}\\n        result = []\\n        count = 0\\n        for i in range(minlength,maxlength+1):\\n            if recurr(i)==True:\\n                hash[count] = i\\n                count = count+1\\n        print(hash)\\n        for q in queries:\\n            try:\\n                result.append(hash[q-1])   \\n            except:\\n                result.append(-1)\\n        return result\\n        # return hash\\ngetting Time limit exceed can anyone help?\\n\\n\\n\\n\\n                    \\n\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Escape the Spreading Fire",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code> which represents a field. Each cell has one of three values:</p>\n\n<ul>\n\t<li><code>0</code> represents grass,</li>\n\t<li><code>1</code> represents fire,</li>\n\t<li><code>2</code> represents a wall that you and fire cannot pass through.</li>\n</ul>\n\n<p>You are situated in the top-left cell, <code>(0, 0)</code>, and you want to travel to the safehouse at the bottom-right cell, <code>(m - 1, n - 1)</code>. Every minute, you may move to an <strong>adjacent</strong> grass cell. <strong>After</strong> your move, every fire cell will spread to all <strong>adjacent</strong> cells that are not walls.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse</em>. If this is impossible, return <code>-1</code>. If you can <strong>always</strong> reach the safehouse regardless of the minutes stayed, return <code>10<sup>9</sup></code>.</p>\n\n<p>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.</p>\n\n<p>A cell is <strong>adjacent</strong> to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg\" style=\"width: 650px; height: 404px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The figure above shows the scenario where you stay in the initial position for 3 minutes.\nYou will still be able to safely reach the safehouse.\nStaying for more than 3 minutes will not allow you to safely reach the safehouse.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg\" style=\"width: 515px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The figure above shows the scenario where you immediately move towards the safehouse.\nFire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\nThus, -1 is returned.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg\" style=\"width: 174px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,0,0],[2,2,0],[1,2,0]]\n<strong>Output:</strong> 1000000000\n<strong>Explanation:</strong> The figure above shows the initial grid.\nNotice that the fire is contained by walls and you will always be able to safely reach the safehouse.\nThus, 10<sup>9</sup> is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 300</code></li>\n\t<li><code>4 &lt;= m * n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>.</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1994594,
                "title": "python-explanation-with-pictures-two-bfs-solutions",
                "content": "## Solution 1. BFS + Binary Search\\n\\nForget about staying for `x` days, suppose we move on day `0` and let\\'s just sort it out how it works.\\n\\nAccording to the problem we move before fire does, here I change the order so we can only step in the safe cells, rather than stepping in a safe cell and get burned on the same day. The result is the same as long as we take care of the bottom-right cell.\\n\\nWithin the same day, the fire spreads first, then we move to the neighboring cells that are not burned. Please refer to the picture below, each row stands for one day. \\n\\n> We can use BFS to find and update all the cells with fire or the safe cells.\\n\\n![image](https://assets.leetcode.com/users/images/2ac8e2e4-c702-4a91-ae36-928d6caa9aa8_1651342218.958268.png)\\n\\n\\n---\\n\\nHow do we know if we can reach bottom-right cell?\\nSince the fire spreads before our move on the same day, \\n- If we reach the bottom-right cell **one or more days after** it burned, we fail.\\n- If we reach the bottom-right cell **on the same day or before** it burned , we success.\\n\\nTake a look at the picture below.\\n\\n![image](https://assets.leetcode.com/users/images/ac0809dc-7db5-48ac-aebd-0f9d3c97ec8d_1651342226.796414.png)\\n\\n\\n---\\n\\nNow back to the question itself, let\\'s find out how long we can stay:\\n\\nSuppose we stay for `x` days and fail, we should try staying for a shorter time, that is `x-1` days.\\nIf we stay for `x` days and success, we should try staying for a longer time, that is `x+1` days.\\n\\n> It\\'s a classic binary search problem.\\n\\n![image](https://assets.leetcode.com/users/images/01529b5e-5169-407e-919d-ecc4405c3810_1651342234.138182.png)\\n\\n\\n---\\n\\nMy code is ugly, please refer to others :)\\n\\n**python**\\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        fires, seen = [], set()\\n        f = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    fires.append((i, j))\\n                    seen.add((i, j))\\n                    f.append((i, j))\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        # If we stay for \\'days\\' days.\\n        def helper(days):\\n            fire, seen = fires[::], set()\\n            \\n            # Let the fire spreads for \\'days\\' days.\\n            while days > 0:\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reach us before we move, we fail.\\n                            if ni == 0 and nj == 0:\\n                                return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                days -= 1\\n\\n            # Then let the fire and us move by turn (fire first).\\n            safe = [(0, 0)]\\n            while safe:\\n                \\n                # Fire spreads first.\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reaches bot-right cell, if we are just one step close to bot-right cell\\n                            # We can still reach it, otherwise we fail. (Please refer to picture 2)\\n                            if ni == m - 1 and nj == n - 1:\\n                                if not ((m - 2, n - 1) in safe or (m - 1, n - 2) in safe):\\n                                    return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                \\n                # We move then.\\n                newsafe = []\\n                for i, j in safe:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        # If we can reach bot-right cell, success.\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:   \\n                            seen.add((ni, nj))\\n                            newsafe.append((ni, nj))\\n                safe = newsafe[::]\\n                \\n            # If there is no more cell for us to move before reaching bot-right cell, we fail.\\n            return False\\n\\n\\n        # check if always safe:\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n        f = collections.deque([(0, 0)])\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    if ni == m - 1 and nj == n - 1:\\n                        return 10 ** 9 \\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n\\n\\n        # Binary search to find maximum days:\\n        l, r = 0, 10 ** 4\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if helper(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n\\n        return l if helper(l) else -1\\n```\\n\\n\\n---\\n\\n## Solution 2. BFS.\\n\\nThanks to [cza_wudi\\'s](https://leetcode.com/problems/escape-the-spreading-fire/discuss/1994681/Python-Simple-Bfs-35-lines-of-code-No-Binary-Search-Here) solution.\\n\\nWe only need to run BFS for two times, to find the earliest arrival time of people and fire.\\n\\n![image](https://assets.leetcode.com/users/images/a6889711-b33a-4a83-85ba-970345734044_1651355216.8753972.png)\\n\\n\\nWe can only focus time difference on the bottom-right grid. The reason is that on a valid path from top-left to bot-right, the time difference of `fire_time - people_time` is **non-increasing**. \\n<br>\\nRefer to the picture below, suppose we are ahead of fire by `2` days on an arbitary cell in the path, meaning the fire will arrive at this cell `2` days later. Since the fire can spread according to this path, meaning we are ahead of fire by at most `2` days in the rest of the path.\\n\\n![image](https://assets.leetcode.com/users/images/d7860306-f1a6-46a4-ad72-03847894e5d6_1651355221.5912876.png)\\n\\n<br>\\nTherefore, the time difference at the bot-right cell gives the upper-bound of the number of days we can stay.\\n\\n\\nBecareful of some edge cases:\\n>If we can\\'t arrive bot-right cell, answer is `-1`.\\n>\\n>If the fire can\\'t arrive bot-right cell, answer is `10 ** 9`.\\n>\\n>We arrive the bot-right cell `x` days ahead of fire, meaning \\n>- we can stay for `x` extra days.\\n>- we can stay for `x-1` extra days.\\n>\\n>depends on if we are \\'followed\\' by fire. \\n\\n![image](https://assets.leetcode.com/users/images/02e6bd55-2454-449f-8a4f-6ea335526e90_1651355225.0702298.png)\\n\\n\\n**python**\\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        ppl_time = [[-1] * n for _ in range(m)]\\n        fire_time = [[-1] * n for _ in range(m)]\\n        \\n        # BFS for people\\'s arrival for each cell.\\n        ppl_front = collections.deque([(0, 0, 0)])\\n        while ppl_front:\\n            cx, cy, days = ppl_front.popleft()\\n            ppl_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and ppl_time[nx][ny] == -1:\\n                    ppl_front.append((nx, ny, days + 1))\\n        \\n        \\n        # BFS for fire\\'s arrival for each cell.\\n        fire_front = collections.deque([(x, y, 0) for x in range(m) for y in range(n) if A[x][y] == 1])\\n        while fire_front:\\n            cx, cy, days = fire_front.popleft()\\n            fire_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and fire_time[nx][ny] == -1:\\n                    fire_front.append((nx, ny, days + 1))\\n        \\n        # Check the arrival days for the bottom-right cell.\\n        ppl_arrival = ppl_time[-1][-1]\\n        fire_arrival = fire_time[-1][-1]\\n        \\n        # Some edge cases.\\n        if ppl_arrival == -1:\\n            return -1\\n        if fire_arrival == -1:\\n            return 10 ** 9\\n        if fire_arrival < ppl_arrival:\\n            return -1\\n\\n        # Whether we are \\'followed\\' by fire on both two pathes toward bot-right cell.\\n        diff = fire_arrival - ppl_arrival\\n        ppl_1, ppl_2 = ppl_time[-1][-2], ppl_time[-2][-1]\\n        \\n        fire_1, fire_2 = fire_time[-1][-2], fire_time[-2][-1]\\n        if ppl_1 > -1 and ppl_2 > -1 and (fire_1 - ppl_1 > diff or fire_2 - ppl_2 > diff):\\n            return diff\\n        return diff - 1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        fires, seen = [], set()\\n        f = collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    fires.append((i, j))\\n                    seen.add((i, j))\\n                    f.append((i, j))\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        # If we stay for \\'days\\' days.\\n        def helper(days):\\n            fire, seen = fires[::], set()\\n            \\n            # Let the fire spreads for \\'days\\' days.\\n            while days > 0:\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reach us before we move, we fail.\\n                            if ni == 0 and nj == 0:\\n                                return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                days -= 1\\n\\n            # Then let the fire and us move by turn (fire first).\\n            safe = [(0, 0)]\\n            while safe:\\n                \\n                # Fire spreads first.\\n                newfire = []\\n                for i, j in fire:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                            # If the fire reaches bot-right cell, if we are just one step close to bot-right cell\\n                            # We can still reach it, otherwise we fail. (Please refer to picture 2)\\n                            if ni == m - 1 and nj == n - 1:\\n                                if not ((m - 2, n - 1) in safe or (m - 1, n - 2) in safe):\\n                                    return False\\n                            seen.add((ni, nj))\\n                            newfire.append((ni, nj))\\n                fire = newfire[::]\\n                \\n                # We move then.\\n                newsafe = []\\n                for i, j in safe:\\n                    for di, dj in dirs:\\n                        ni, nj = i + di, j + dj\\n                        # If we can reach bot-right cell, success.\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:   \\n                            seen.add((ni, nj))\\n                            newsafe.append((ni, nj))\\n                safe = newsafe[::]\\n                \\n            # If there is no more cell for us to move before reaching bot-right cell, we fail.\\n            return False\\n\\n\\n        # check if always safe:\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n        f = collections.deque([(0, 0)])\\n        while f:\\n            i, j = f.popleft()\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if 0 <= ni < m and 0 <= nj < n and A[ni][nj] == 0 and (ni, nj) not in seen:\\n                    if ni == m - 1 and nj == n - 1:\\n                        return 10 ** 9 \\n                    seen.add((ni, nj))\\n                    f.append((ni, nj))\\n\\n\\n        # Binary search to find maximum days:\\n        l, r = 0, 10 ** 4\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if helper(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n\\n        return l if helper(l) else -1\\n```\n```\\ndef maximumMinutes(self, A: List[List[int]]) -> int:\\n        m, n = len(A), len(A[0])\\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        \\n        ppl_time = [[-1] * n for _ in range(m)]\\n        fire_time = [[-1] * n for _ in range(m)]\\n        \\n        # BFS for people\\'s arrival for each cell.\\n        ppl_front = collections.deque([(0, 0, 0)])\\n        while ppl_front:\\n            cx, cy, days = ppl_front.popleft()\\n            ppl_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and ppl_time[nx][ny] == -1:\\n                    ppl_front.append((nx, ny, days + 1))\\n        \\n        \\n        # BFS for fire\\'s arrival for each cell.\\n        fire_front = collections.deque([(x, y, 0) for x in range(m) for y in range(n) if A[x][y] == 1])\\n        while fire_front:\\n            cx, cy, days = fire_front.popleft()\\n            fire_time[cx][cy] = days\\n            for dx, dy in dirs:\\n                nx, ny = cx + dx, cy + dy\\n                if 0 <= nx < m and 0 <= ny < n and A[nx][ny] == 0 and fire_time[nx][ny] == -1:\\n                    fire_front.append((nx, ny, days + 1))\\n        \\n        # Check the arrival days for the bottom-right cell.\\n        ppl_arrival = ppl_time[-1][-1]\\n        fire_arrival = fire_time[-1][-1]\\n        \\n        # Some edge cases.\\n        if ppl_arrival == -1:\\n            return -1\\n        if fire_arrival == -1:\\n            return 10 ** 9\\n        if fire_arrival < ppl_arrival:\\n            return -1\\n\\n        # Whether we are \\'followed\\' by fire on both two pathes toward bot-right cell.\\n        diff = fire_arrival - ppl_arrival\\n        ppl_1, ppl_2 = ppl_time[-1][-2], ppl_time[-2][-1]\\n        \\n        fire_1, fire_2 = fire_time[-1][-2], fire_time[-2][-1]\\n        if ppl_1 > -1 and ppl_2 > -1 and (fire_1 - ppl_1 > diff or fire_2 - ppl_2 > diff):\\n            return diff\\n        return diff - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995157,
                "title": "solution-intuition-explanation-with-pictures",
                "content": "![image](https://assets.leetcode.com/users/images/344e53d0-3f79-4519-bcb1-99e8f10d6142_1651341141.7053227.jpeg)\\n![image](https://assets.leetcode.com/users/images/36ef4823-5dce-47a1-a3c5-03390bbac818_1651341145.2645786.jpeg)\\n![image](https://assets.leetcode.com/users/images/3179ac6b-1af7-4e5b-9b78-4e3533fe0619_1651341149.4040053.jpeg)\\n![image](https://assets.leetcode.com/users/images/f3b707ad-632a-4d15-901e-73725f3d7a54_1651341163.7910142.jpeg)\\n![image](https://assets.leetcode.com/users/images/4304ef09-a819-4534-9c59-2f85594babfa_1651341166.5201292.jpeg)\\n![image](https://assets.leetcode.com/users/images/094eed91-a5c0-4986-9054-e2ea6297e3c7_1651341168.5422208.jpeg)\\n![image](https://assets.leetcode.com/users/images/7696c91a-47e1-440c-bc7b-aaf3cd21c3f2_1651341170.8717854.jpeg)\\n![image](https://assets.leetcode.com/users/images/074d9e58-6623-4de7-aa15-62e74be1688a_1651341173.355559.jpeg)\\n![image](https://assets.leetcode.com/users/images/a2db5eec-b23e-452d-8f94-80fc5b9539f8_1651341174.188486.jpeg)\\n\\n\\nCode - \\n\\n```java\\n\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || visited[ii][jj] == 1 || grid[ii][jj] == 2) continue;\\n                if (ii == n - 1 && jj == m - 1 && dist[ii][jj] >= at.third + 1) return true;\\n                if (dist[ii][jj] <= at.third + 1) continue;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n                visited[ii][jj] = 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean inBounds(int i, int j, int n, int m) {\\n        return (0 <= i && i < n && 0 <= j && j < m);\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][] dist = new int[n][m];\\n\\n        for (int[] r : dist) Arrays.fill(r, Integer.MAX_VALUE);\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.add(new Pair<>(i, j, 0));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || grid[ii][jj] == 2 || dist[ii][jj] <= at.third + 1) continue;\\n                dist[ii][jj] = 1 + at.third;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n            }\\n        }\\n\\n        int left = 0;\\n        int right = 1_000_000_000;\\n\\n        int ans = -1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ok(grid, dist, mid)) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else right = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    static class Pair<T, K, L> {\\n        T first;\\n        K second;\\n        L third;\\n\\n        public Pair(T first, K second, L third) {\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\n\\nclass Solution {\\n\\n    public boolean ok(int[][] grid, int[][] dist, int wait_time) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n        Q.add(new Pair<>(0, 0, wait_time));\\n\\n        int[][] visited = new int[n][m];\\n        visited[0][0] = 1;\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || visited[ii][jj] == 1 || grid[ii][jj] == 2) continue;\\n                if (ii == n - 1 && jj == m - 1 && dist[ii][jj] >= at.third + 1) return true;\\n                if (dist[ii][jj] <= at.third + 1) continue;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n                visited[ii][jj] = 1;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean inBounds(int i, int j, int n, int m) {\\n        return (0 <= i && i < n && 0 <= j && j < m);\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        int[][] dist = new int[n][m];\\n\\n        for (int[] r : dist) Arrays.fill(r, Integer.MAX_VALUE);\\n\\n        Queue<Pair<Integer, Integer, Integer>> Q = new LinkedList<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.add(new Pair<>(i, j, 0));\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while (!Q.isEmpty()) {\\n            Pair<Integer, Integer, Integer> at = Q.poll();\\n            int[][] moves = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n            for (int[] to : moves) {\\n                int ii = at.first + to[0];\\n                int jj = at.second + to[1];\\n                if (!inBounds(ii, jj, n, m) || grid[ii][jj] == 2 || dist[ii][jj] <= at.third + 1) continue;\\n                dist[ii][jj] = 1 + at.third;\\n                Q.add(new Pair<>(ii, jj, 1 + at.third));\\n            }\\n        }\\n\\n        int left = 0;\\n        int right = 1_000_000_000;\\n\\n        int ans = -1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (ok(grid, dist, mid)) {\\n                ans = mid;\\n                left = mid + 1;\\n            } else right = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    static class Pair<T, K, L> {\\n        T first;\\n        K second;\\n        L third;\\n\\n        public Pair(T first, K second, L third) {\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994681,
                "title": "python-simple-bfs-35-lines-of-code-no-binary-search-here",
                "content": "**Idea:**\\n1. Run BFS for two times, calculate the minimum number of steps fire/person can move to the each empty cell in the grid, store those numbers in fire_moves[-1][-1] and person_moves[-1][-1]\\n1. If person can never reach the destination (i.e. **preson_moves[-1][-1] < 0**) or **fire_moves[-1][-1] < person_moves[-1][-1]** which means that person can never move to the destination before fire, return -1. (*In my code below, I used the early termination logic when running BFS for personmoves, so it is a little bit differen*t.)\\n1. Else if fire can never reach the destination, which means that it will not block the person anytime in his path, return 10^9\\n1. Otherwise, return fire_moves[-1][-1] - person_moves[-1][-1] - 1. Here we also need to consider the edge case when fire and person arrives at the destination at the same time\\n\\n**My Solution:**\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        max_val = 1000000000\\n        rows, cols = len(grid), len(grid[0])\\n        fire_moves = [[-1] * cols for _ in range(rows)]\\n        person_moves = [[-1] * cols for _ in range(rows)]\\n\\n        def bfs(frontier, board, is_fire=True):\\n            while frontier:\\n                r, c, step = frontier.popleft()\\n\\t\\t\\t\\tboard[r][c] = step\\n                for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                    nr, nc = dr + r, dc + c\\n                    if cols > nc >= 0 and rows > nr >= 0 > board[nr][nc] and \\\\\\n                            grid[nr][nc] != 2 and (is_fire or fire_moves[nr][nc] < 0 or fire_moves[nr][nc] > step + 1 or (\\n                            fire_moves[nr][nc] == step + 1 and nr == rows - 1 and nc == cols - 1)):\\n                        frontier.append((nr, nc, step + 1))\\n\\n        bfs(deque([(r, c, 0) for r in range(rows) for c in range(cols) if grid[r][c] == 1]), fire_moves)\\n        bfs(deque([(0, 0, 0)]), person_moves, is_fire=False)\\n\\n        dest_fire, dest_move = fire_moves[-1][-1], person_moves[-1][-1]\\n        if dest_move < 0: return -1\\n        if dest_fire < 0: return max_val\\n        if dest_fire == dest_move: return 0\\n\\n        diff = dest_fire - dest_move\\n        if rows > 1 and cols > 1:\\n            path1, path2 = person_moves[-1][-2], person_moves[-2][-1]\\n            diff1, diff2 = fire_moves[-1][-2] - path1, fire_moves[-2][-1] - path2\\n            if path1 >= 0 and path2 >= 0 and (diff1 > diff or diff2 > diff):\\n                return diff\\n        return diff - 1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        max_val = 1000000000\\n        rows, cols = len(grid), len(grid[0])\\n        fire_moves = [[-1] * cols for _ in range(rows)]\\n        person_moves = [[-1] * cols for _ in range(rows)]\\n\\n        def bfs(frontier, board, is_fire=True):\\n            while frontier:\\n                r, c, step = frontier.popleft()\\n\\t\\t\\t\\tboard[r][c] = step\\n                for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:\\n                    nr, nc = dr + r, dc + c\\n                    if cols > nc >= 0 and rows > nr >= 0 > board[nr][nc] and \\\\\\n                            grid[nr][nc] != 2 and (is_fire or fire_moves[nr][nc] < 0 or fire_moves[nr][nc] > step + 1 or (\\n                            fire_moves[nr][nc] == step + 1 and nr == rows - 1 and nc == cols - 1)):\\n                        frontier.append((nr, nc, step + 1))\\n\\n        bfs(deque([(r, c, 0) for r in range(rows) for c in range(cols) if grid[r][c] == 1]), fire_moves)\\n        bfs(deque([(0, 0, 0)]), person_moves, is_fire=False)\\n\\n        dest_fire, dest_move = fire_moves[-1][-1], person_moves[-1][-1]\\n        if dest_move < 0: return -1\\n        if dest_fire < 0: return max_val\\n        if dest_fire == dest_move: return 0\\n\\n        diff = dest_fire - dest_move\\n        if rows > 1 and cols > 1:\\n            path1, path2 = person_moves[-1][-2], person_moves[-2][-1]\\n            diff1, diff2 = fire_moves[-1][-2] - path1, fire_moves[-2][-1] - path2\\n            if path1 >= 0 and path2 >= 0 and (diff1 > diff or diff2 > diff):\\n                return diff\\n        return diff - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016835,
                "title": "no-bs",
                "content": "This is a very daunting problem - difficult to code, frustrating edge cases...\\n\\nThe solution - once you figure it out - is quite straightforward. No need for a binary search.\\n\\nWe use BFS to calculate steps from the person to the safehouse, and the closest distance from any fire to the safehouse. The difference between fire distance and person steps is our answer. This is how the BFS grid looks for fire and person, based on Example 1 (see problem description):\\n\\n![image](https://assets.leetcode.com/users/images/2a7d5bc4-911b-492a-b5d3-31b446ee0356_1651946723.3738.png)\\n\\nSo, the result is `3` (`14 - 10 - 1`). Note that we subtract one - to make sure fire would not catch up to the person during the \"spread\" phase.\\n\\nEasy, right?\\n\\nNot. This is the frustrating edge case. If a person reaches the safehouse, they escape even if the fire spreads to the safehouse in the same minute. So, when the safehouse is the first cell when person and fire cross their paths, we do not subtract one.\\n\\nI could not figure it out myself, but our community is awesome. To check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one. For the following example, the result is `2`, not `1`:\\n\\n![image](https://assets.leetcode.com/users/images/8d7678ed-57fd-4ad9-bcde-bf1d392df09c_1651946753.399552.png)\\n\\n**C++**\\nThe `step` function returns the number of steps to the safehouse, and two adjacent to the safehouse cells.\\n```cpp\\nint maximumMinutes(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    deque<pair<int, int>> fire, person({{0, 0}});\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 1) \\n                fire.push_back({i, j});\\n    auto steps = [&](deque<pair<int, int>> &pos) {\\n        vector<vector<int>> st(m, vector<int>(n));\\n        while(!pos.empty()) {\\n            auto [i, j] = pos.front();\\n            pos.pop_front();\\n            for (auto [di, dj] : vector<pair<int, int>>{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}) {\\n                int x = i + di, y = j + dj;\\n                if (min(x, y) >= 0 && x < m && y < n && g[x][y] == 0 && st[x][y] == 0) {\\n                    st[x][y] = st[i][j] + 1;\\n                    pos.push_back({x, y});\\n                }\\n            }\\n        }\\n        return array<int, 3>{st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]};\\n    };\\n    auto f = steps(fire), p = steps(person);\\n    if (f[0] == 0 && p[0] != 0)\\n        return 1000000000;\\n    if (int diff = f[0] - p[0]; p[0] != 0 && diff >= 0)\\n        return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff);\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumMinutes(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    deque<pair<int, int>> fire, person({{0, 0}});\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (g[i][j] == 1) \\n                fire.push_back({i, j});\\n    auto steps = [&](deque<pair<int, int>> &pos) {\\n        vector<vector<int>> st(m, vector<int>(n));\\n        while(!pos.empty()) {\\n            auto [i, j] = pos.front();\\n            pos.pop_front();\\n            for (auto [di, dj] : vector<pair<int, int>>{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}) {\\n                int x = i + di, y = j + dj;\\n                if (min(x, y) >= 0 && x < m && y < n && g[x][y] == 0 && st[x][y] == 0) {\\n                    st[x][y] = st[i][j] + 1;\\n                    pos.push_back({x, y});\\n                }\\n            }\\n        }\\n        return array<int, 3>{st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]};\\n    };\\n    auto f = steps(fire), p = steps(person);\\n    if (f[0] == 0 && p[0] != 0)\\n        return 1000000000;\\n    if (int diff = f[0] - p[0]; p[0] != 0 && diff >= 0)\\n        return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff);\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995289,
                "title": "python-bfs-solution",
                "content": "# **Explanation**\\nThe general idea is same to most of other solution:\\n1. We firstly spread the `fires`, find out when the fires reach out each cell.\\n2. Then we binary search the biggest minutes that we can stay at `(0, 0)`,\\nfor each test, we do another `bfs` from `(0, 0)`,\\ncheck if we can reach `(m - 1, n - 1)`.\\n\\nSuggest you checking other good explanation on this part.\\n\\n\\n# **Tricks**\\nHere I explain some tricks to improve the solution\\n\\n**1. Initialize  `A[i][j] = inf`**\\nUsually in `bfs`,\\nwe will apply a `visited` array to mark the visited cell.\\nAnd we need to note down the earliest visiting time for each cell.\\nIn my impletation, I initialize all `A[i][j] = inf`,\\nso if `A[i][j]` is `inf` in the end, it\\'s not reachable.\\n\\n**2. Set fire `A[i][j] = 0`**\\nWe can not pass the fire,\\nand we have already handle the initial firre cell,\\nso we can set Set `A[i][j] = 0`\\n\\n**3. Wall is fire**\\nSame we can not pass the wall,\\nwall is a fire that won\\'t spread.\\nso we can set wall `A[i][j] = 0`.\\n\\n**4. Save duplicate BFS**\\nMost solution do duplicate BFS.\\nSpread the fire is BFS,\\nEscape from (0, 0) is also a BFS.\\nNo need to duplicate the code,\\nI take advantage of a same bfs code block.\\n\\n**5. One more second for Safehouse**\\nNote that even if the fire spreads to the safehouse immediately after you have reached it, \\nit will be counted as safely reaching the safehouse.\\n\\nI got one WA for this dirty case,\\nI find this corner case annoying and it doesn\\'t make sense to me at all.\\n\\nIt sounds like safehouse can be burn down in one second.\\nWait, maybe it\\'s not hard to handle thinking in this way.\\n\\nAssume `A[i][j]` is the time point for fire reaching cell `(i, j)`,\\nwe can simply do `A[m-1][n-1] += 1`,\\ngive one more second to the safehouse.\\n\\n\\n**6. Python Build-in bisect**\\nPython can help binary search, \\nsave me 7 lines of binary search template.\\n<br>\\n\\n**Python**\\n```py\\nclass Solution(object):\\n    def maximumMinutes(self, A):\\n        m, n = len(A), len(A[0])\\n        inf = 10 ** 10\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if A[i][j] == 1]\\n        A = [[inf if a < 2 else -1 for a in r] for r in A]\\n\\n        def bfs(queue, seen):\\n            for i, j, t in queue:\\n                if seen[i][j] < inf: continue\\n                seen[i][j] = t\\n                for di,dj in d:\\n                    x, y = i + di, j + dj\\n                    if 0 <= x < m and 0 <= y < n and seen[x][y] >= inf and t + 1 < A[x][y]:\\n                        queue.append([x, y, t + 1])\\n        \\n        def die(t):\\n            seen = [[inf + 10] * n for i in range(m)]\\n            bfs([[0, 0, t]], seen)\\n            return seen[-1][-1] > A[-1][-1]\\n\\n        bfs(fires, A)\\n        A[-1][-1] += 1\\n        return bisect_left(range(10**9 + 1), True, key=die) - 1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution(object):\\n    def maximumMinutes(self, A):\\n        m, n = len(A), len(A[0])\\n        inf = 10 ** 10\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if A[i][j] == 1]\\n        A = [[inf if a < 2 else -1 for a in r] for r in A]\\n\\n        def bfs(queue, seen):\\n            for i, j, t in queue:\\n                if seen[i][j] < inf: continue\\n                seen[i][j] = t\\n                for di,dj in d:\\n                    x, y = i + di, j + dj\\n                    if 0 <= x < m and 0 <= y < n and seen[x][y] >= inf and t + 1 < A[x][y]:\\n                        queue.append([x, y, t + 1])\\n        \\n        def die(t):\\n            seen = [[inf + 10] * n for i in range(m)]\\n            bfs([[0, 0, t]], seen)\\n            return seen[-1][-1] > A[-1][-1]\\n\\n        bfs(fires, A)\\n        A[-1][-1] += 1\\n        return bisect_left(range(10**9 + 1), True, key=die) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994962,
                "title": "java-binary-search-bfs-with-explanation-beats-100",
                "content": "To begin with, I will show some cases need to be handled.\\n\\n### Sample Cases\\n```\\ncase 1: fire and person meets on safehouse --> ok\\ncase 2: fire and person meets on any cell  --> fail\\ncase 3: fire reach house before person     --> fail\\n```\\n\\n### Flow\\n#### BFS\\nTo simplify the question, first we just check if the safehouse is reachable. \\n(ignore the minutes to stay in initial position for now)\\n\\n1. use two BFS for fires and person \\n2. first do `fire` traversal, then `person` since the person and fire cannot be the same grid (case 2)\\n3. during the traversal (or called spread), if the `person` is able to reach `grid[m][n]`, return `true` (case 1)\\n4. after each round of the spread, if `fire` already spreads to `grid[m][n]`, return `false` (case 3)\\n\\n#### Binary Search\\nAbout the minutes to stay, actually it means how many times we let the `fire` spread before `person` start to spread.\\nTherefore, we can just conduct a function that spread `i` times for `fire` first.\\n\\nSince the `i` is unknown, and could be really large (`m*n`), the efficient way is using binary search for `i`.\\n\\nGiven a function `reachable(int i)`, which returns true if the person is able to reach safehouse by letting fires spread `i` times first.\\nThen try to find the right-most index `i` from `0` to `MAX` where  `reachable(i) == true`\\n\\nEdge cases: \\n- if `i < 0` return `-1` (impossible to reach)\\n- if `i > MAX` return `10^9` (can always reach)\\n\\n### Solution\\n```java\\nint[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\npublic int maximumMinutes(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    List<int[]> fires = new ArrayList<>();\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                fires.add(new int[]{i, j});\\n            }\\n        }\\n    }\\n\\n    int l = -1, r = m * n;\\n    while (l < r) {\\n        int mid = l + (r - l) / 2 + 1;\\n        if (reachable(grid, mid, fires)) l = mid;\\n        else r = mid - 1;\\n    }\\n    return l == m * n ? (int) 1e9 : l;\\n}\\n\\nboolean reachable(int[][] grid, int move, List<int[]> fires) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = clone(grid);\\n\\n    Queue<int[]> fire = new LinkedList<>();\\n    fire.addAll(fires);\\n    while (!fire.isEmpty() && move-- > 0) {\\n        if (spread(fire, copy)) return false;\\n    }\\n\\n    Queue<int[]> person = new LinkedList<>();\\n    person.add(new int[]{0, 0});\\n    while (!person.isEmpty()) {\\n        boolean onFire = spread(fire, copy);\\n        if (spread(person, copy)) return true;\\n        if (onFire) return false;\\n    }\\n    return false;\\n}\\n\\n// return true if it spreads to safehouse\\nboolean spread(Queue<int[]> queue, int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int size = queue.size();\\n\\n    while (size-- > 0) {\\n        int[] cell = queue.remove();\\n        for (int[] d : directions) {\\n            int x = cell[0] + d[0] , y = cell[1] + d[1];\\n            if (x == m - 1 && y == n - 1) return true;\\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0) {\\n                grid[x][y] = -1;\\n                queue.add(new int[]{x, y});\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint[][] clone(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            copy[i][j] = grid[i][j];\\n        }\\n    }\\n    return copy;\\n}\\n```\\n\\nPlease let me know if that\\'s helpful for you, thanks!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\ncase 1: fire and person meets on safehouse --> ok\\ncase 2: fire and person meets on any cell  --> fail\\ncase 3: fire reach house before person     --> fail\\n```\n```java\\nint[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\npublic int maximumMinutes(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    List<int[]> fires = new ArrayList<>();\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] == 1) {\\n                fires.add(new int[]{i, j});\\n            }\\n        }\\n    }\\n\\n    int l = -1, r = m * n;\\n    while (l < r) {\\n        int mid = l + (r - l) / 2 + 1;\\n        if (reachable(grid, mid, fires)) l = mid;\\n        else r = mid - 1;\\n    }\\n    return l == m * n ? (int) 1e9 : l;\\n}\\n\\nboolean reachable(int[][] grid, int move, List<int[]> fires) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = clone(grid);\\n\\n    Queue<int[]> fire = new LinkedList<>();\\n    fire.addAll(fires);\\n    while (!fire.isEmpty() && move-- > 0) {\\n        if (spread(fire, copy)) return false;\\n    }\\n\\n    Queue<int[]> person = new LinkedList<>();\\n    person.add(new int[]{0, 0});\\n    while (!person.isEmpty()) {\\n        boolean onFire = spread(fire, copy);\\n        if (spread(person, copy)) return true;\\n        if (onFire) return false;\\n    }\\n    return false;\\n}\\n\\n// return true if it spreads to safehouse\\nboolean spread(Queue<int[]> queue, int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int size = queue.size();\\n\\n    while (size-- > 0) {\\n        int[] cell = queue.remove();\\n        for (int[] d : directions) {\\n            int x = cell[0] + d[0] , y = cell[1] + d[1];\\n            if (x == m - 1 && y == n - 1) return true;\\n            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 0) {\\n                grid[x][y] = -1;\\n                queue.add(new int[]{x, y});\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\nint[][] clone(int[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] copy = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            copy[i][j] = grid[i][j];\\n        }\\n    }\\n    return copy;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994970,
                "title": "c-beats-100-time-memory-clean-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Hint:\\n            1. First run bfs from all fire points and let them spread out everywhere possible\\n            2. Do not run multiple BFS, single BFS is good enough\\n            3. Our target is to find the minimun time for a fire to reach every [cell]\\n            4. After that we can do binary search on the answer.\\n            5. [binary search validation function]\\n                a. We can do another bfs for our protagonist\\n                b. Now we will know if depending on the current time if we can visite a cell or not\\n                c. Meaning if a cell gets fired up before we reach there that means we can\\'t go on to that cell.\\n\\t\\t\\t\\td. Need to remember if it is the final cell then it is ok if our protagonist and the fire reaches there at the same time.\\n                \\n    */\\n    \\n    \\n    #define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\\n    #define ULL             unsigned long long\\n    #define LL              long long\\n    #define eps             1e-9\\n    #define inf             0x3f3f3f3f\\n    #define INF             2e18\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    #define ff first\\n    #define ss second\\n    #define Cube(a) ((a)*(a)*(a))\\n    #define Sqr(a)  ((a)*(a))\\n    int n, m;\\n    int fire_time[300][300];\\n    int dis[300][300];\\n    \\n    int fx[9] = {-1,+0,+1,+0,+1,+1,-1,-1,+0};\\n    int fy[9] = {+0,-1,+0,+1,+1,-1,+1,-1,+0};\\n    \\n    int invalid(int x, int y, vector<vector<int>>& grid) {\\n        return x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 2;\\n    }\\n    \\n    void calculate_fire(vector<vector<int>>& grid) {\\n        queue < pair<int, int> > Q;\\n        memset(fire_time, inf, sizeof fire_time);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.push({i, j});\\n                    fire_time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff;\\n            int y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                if (fire_time[nx][ny] > fire_time[x][y] + 1) {\\n                    fire_time[nx][ny] = fire_time[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimum_time_to_reach_end(int wait, vector<vector<int>>& grid) {\\n        memset(dis, inf, sizeof dis);\\n        queue <pair<int, int>> Q; \\n        Q.push({0, 0});\\n        dis[0][0] = wait;\\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff, y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                int new_min = min(dis[nx][ny], dis[x][y] + 1);\\n                if (nx == n - 1 && ny == m - 1 && new_min <= fire_time[nx][ny]) return new_min;\\n                if (new_min >= fire_time[nx][ny]) continue;\\n                if (dis[nx][ny] > dis[x][y] + 1) {\\n                    dis[nx][ny] = dis[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n        \\n        return inf + 1;\\n    }\\n    \\n    int find_lazyness(vector<vector<int>>& grid) {\\n        if (fire_time[n - 1][m - 1] == inf) {\\n            return minimum_time_to_reach_end(0, grid) < inf ? 1e9 : -1;\\n        }\\n        int max_possible = (n * m) + 1;\\n        int low = 0, high = max_possible, max_wait = -1;\\n        while(low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (minimum_time_to_reach_end(mid, grid) <= fire_time[n - 1][m - 1]) {\\n                low = mid + 1;\\n                max_wait = mid;\\n            } else high = mid - 1;\\n        }\\n        \\n        return max_wait == max_possible ? 1e9 : max_wait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        calculate_fire(grid);\\n        return find_lazyness(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        Hint:\\n            1. First run bfs from all fire points and let them spread out everywhere possible\\n            2. Do not run multiple BFS, single BFS is good enough\\n            3. Our target is to find the minimun time for a fire to reach every [cell]\\n            4. After that we can do binary search on the answer.\\n            5. [binary search validation function]\\n                a. We can do another bfs for our protagonist\\n                b. Now we will know if depending on the current time if we can visite a cell or not\\n                c. Meaning if a cell gets fired up before we reach there that means we can\\'t go on to that cell.\\n\\t\\t\\t\\td. Need to remember if it is the final cell then it is ok if our protagonist and the fire reaches there at the same time.\\n                \\n    */\\n    \\n    \\n    #define FastRead        ios_base::sync_with_stdio(0);cin.tie(0)\\n    #define ULL             unsigned long long\\n    #define LL              long long\\n    #define eps             1e-9\\n    #define inf             0x3f3f3f3f\\n    #define INF             2e18\\n    #define all(a)          a.begin(),a.end()\\n    #define Unique(a)       sort(all(a)),a.erase(unique(all(a)),a.end())\\n    #define ff first\\n    #define ss second\\n    #define Cube(a) ((a)*(a)*(a))\\n    #define Sqr(a)  ((a)*(a))\\n    int n, m;\\n    int fire_time[300][300];\\n    int dis[300][300];\\n    \\n    int fx[9] = {-1,+0,+1,+0,+1,+1,-1,-1,+0};\\n    int fy[9] = {+0,-1,+0,+1,+1,-1,+1,-1,+0};\\n    \\n    int invalid(int x, int y, vector<vector<int>>& grid) {\\n        return x < 0 || y < 0 || x >= n || y >= m || grid[x][y] == 2;\\n    }\\n    \\n    void calculate_fire(vector<vector<int>>& grid) {\\n        queue < pair<int, int> > Q;\\n        memset(fire_time, inf, sizeof fire_time);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    Q.push({i, j});\\n                    fire_time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff;\\n            int y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                if (fire_time[nx][ny] > fire_time[x][y] + 1) {\\n                    fire_time[nx][ny] = fire_time[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minimum_time_to_reach_end(int wait, vector<vector<int>>& grid) {\\n        memset(dis, inf, sizeof dis);\\n        queue <pair<int, int>> Q; \\n        Q.push({0, 0});\\n        dis[0][0] = wait;\\n        while(!Q.empty()) {\\n            pair <int, int> cur = Q.front(); Q.pop();\\n            int x = cur.ff, y = cur.ss;\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + fx[i];\\n                int ny = y + fy[i];\\n                if (invalid(nx, ny, grid)) continue;\\n                int new_min = min(dis[nx][ny], dis[x][y] + 1);\\n                if (nx == n - 1 && ny == m - 1 && new_min <= fire_time[nx][ny]) return new_min;\\n                if (new_min >= fire_time[nx][ny]) continue;\\n                if (dis[nx][ny] > dis[x][y] + 1) {\\n                    dis[nx][ny] = dis[x][y] + 1;\\n                    Q.push({nx, ny});\\n                }\\n            }\\n        }\\n        \\n        return inf + 1;\\n    }\\n    \\n    int find_lazyness(vector<vector<int>>& grid) {\\n        if (fire_time[n - 1][m - 1] == inf) {\\n            return minimum_time_to_reach_end(0, grid) < inf ? 1e9 : -1;\\n        }\\n        int max_possible = (n * m) + 1;\\n        int low = 0, high = max_possible, max_wait = -1;\\n        while(low <= high) {\\n            int mid = (low + high) >> 1;\\n            if (minimum_time_to_reach_end(mid, grid) <= fire_time[n - 1][m - 1]) {\\n                low = mid + 1;\\n                max_wait = mid;\\n            } else high = mid - 1;\\n        }\\n        \\n        return max_wait == max_possible ? 1e9 : max_wait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        calculate_fire(grid);\\n        return find_lazyness(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998530,
                "title": "c-two-bfs-no-binary-search",
                "content": "I use two BFS to find fire traversal time and people traversal time.\\n\\nNote that if you can reach the safehouse before the fire,\\nit also means that you don\\'t encounter the fire in the path.\\n\\nThe answer should be `firetime[m-1][n-1]-peopletime[m-1][n-1] - 1` .\\n\\nHowever, there is one more thing to consider.\\nWe can encounter the fire at the safehouse, \\nbut we cannot meet it in the path.\\nTherefore, `if( (firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff) )` ,\\nwhich also means we only meet the fire at the safehouse,\\nwe should return  `firetime[m-1][n-1]-peopletime[m-1][n-1] - 1` .\\nOtherwise, we encounter the fire on our way,\\nso we have to be one step ahead.\\nThe answer should be `firetime[m-1][n-1]-peopletime[m-1][n-1] - 2` in this case.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> firetime(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        // push fire positions into queue, and set the time as 0\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    q.push(make_pair(i, j));\\n                    firetime[i][j] = 0;\\n                }\\n            }\\n        }\\n        int time = 0;\\n        pair<int, int> xy;\\n        int x,y;\\n        // use BFS to find fire spread time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && firetime[x-1][y]==INT_MAX){\\n                    q.push(make_pair(x-1, y));\\n                    firetime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && firetime[x+1][y]==INT_MAX){\\n                    q.push(make_pair(x+1, y));\\n                    firetime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && firetime[x][y-1]==INT_MAX){\\n                    q.push(make_pair(x, y-1));\\n                    firetime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && firetime[x][y+1]==INT_MAX){\\n                    q.push(make_pair(x, y+1));\\n                    firetime[x][y+1] = time;\\n                }\\n            }\\n        }\\n        vector<vector<int>> peopletime(m, vector<int>(n, INT_MAX));\\n        time = 0;\\n        // push the initial position of the top left cell into the queue\\n        // and set the time as 0\\n        q.push(make_pair(0, 0));\\n        peopletime[0][0] = 0;\\n        // use BFS to find the traversal time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && peopletime[x-1][y]==INT_MAX && firetime[x-1][y]>time){\\n                    q.push(make_pair(x-1, y));\\n                    peopletime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && peopletime[x+1][y]==INT_MAX && firetime[x+1][y]>time){\\n                    q.push(make_pair(x+1, y));\\n                    peopletime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && peopletime[x][y-1]==INT_MAX && firetime[x][y-1]>time){\\n                    q.push(make_pair(x, y-1));\\n                    peopletime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && peopletime[x][y+1]==INT_MAX && firetime[x][y+1]>time){\\n                    q.push(make_pair(x, y+1));\\n                    peopletime[x][y+1] = time;\\n                }\\n                if(((x==m-2 && y==n-1) || (x==m-1 && y==n-2))&&(firetime[m-1][n-1]<=time)){\\n                    q.push(make_pair(m-1, n-1));\\n                    peopletime[m-1][n-1] = time;\\n                }\\n            }\\n        }\\n        // if you cannot reach the safehouse or fire reaches the safehouse first,\\n        // return -1\\n        if(peopletime[m-1][n-1]==INT_MAX || firetime[m-1][n-1]<peopletime[m-1][n-1]){\\n            return -1;\\n        }\\n        // if fire can never reach the safehouse,\\n        // return 1000000000\\n        if(firetime[m-1][n-1]==INT_MAX){\\n            return 1000000000;\\n        }\\n        if(firetime[m-1][n-1]==peopletime[m-1][n-1]){\\n            return 0;\\n        }\\n        int diff = (firetime[m-1][n-1]-peopletime[m-1][n-1]);\\n        if(m>1 && n>1){\\n            if(peopletime[m-2][n-1]!=INT_MAX && peopletime[m-1][n-2]!=INT_MAX && ((firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> firetime(m, vector<int>(n, INT_MAX));\\n        queue<pair<int, int>> q;\\n        // push fire positions into queue, and set the time as 0\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    q.push(make_pair(i, j));\\n                    firetime[i][j] = 0;\\n                }\\n            }\\n        }\\n        int time = 0;\\n        pair<int, int> xy;\\n        int x,y;\\n        // use BFS to find fire spread time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && firetime[x-1][y]==INT_MAX){\\n                    q.push(make_pair(x-1, y));\\n                    firetime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && firetime[x+1][y]==INT_MAX){\\n                    q.push(make_pair(x+1, y));\\n                    firetime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && firetime[x][y-1]==INT_MAX){\\n                    q.push(make_pair(x, y-1));\\n                    firetime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && firetime[x][y+1]==INT_MAX){\\n                    q.push(make_pair(x, y+1));\\n                    firetime[x][y+1] = time;\\n                }\\n            }\\n        }\\n        vector<vector<int>> peopletime(m, vector<int>(n, INT_MAX));\\n        time = 0;\\n        // push the initial position of the top left cell into the queue\\n        // and set the time as 0\\n        q.push(make_pair(0, 0));\\n        peopletime[0][0] = 0;\\n        // use BFS to find the traversal time\\n        while(!q.empty()){\\n            int points = q.size();\\n            time++;\\n            for(int i=0; i<points; i++){\\n                xy = q.front();\\n                q.pop();\\n                x = xy.first, y = xy.second;\\n                if(x-1>=0 && grid[x-1][y]==0 && peopletime[x-1][y]==INT_MAX && firetime[x-1][y]>time){\\n                    q.push(make_pair(x-1, y));\\n                    peopletime[x-1][y] = time;\\n                }\\n                if(x+1<m && grid[x+1][y]==0 && peopletime[x+1][y]==INT_MAX && firetime[x+1][y]>time){\\n                    q.push(make_pair(x+1, y));\\n                    peopletime[x+1][y] = time;\\n                }\\n                if(y-1>=0 && grid[x][y-1]==0 && peopletime[x][y-1]==INT_MAX && firetime[x][y-1]>time){\\n                    q.push(make_pair(x, y-1));\\n                    peopletime[x][y-1] = time;\\n                }\\n                if(y+1<n && grid[x][y+1]==0 && peopletime[x][y+1]==INT_MAX && firetime[x][y+1]>time){\\n                    q.push(make_pair(x, y+1));\\n                    peopletime[x][y+1] = time;\\n                }\\n                if(((x==m-2 && y==n-1) || (x==m-1 && y==n-2))&&(firetime[m-1][n-1]<=time)){\\n                    q.push(make_pair(m-1, n-1));\\n                    peopletime[m-1][n-1] = time;\\n                }\\n            }\\n        }\\n        // if you cannot reach the safehouse or fire reaches the safehouse first,\\n        // return -1\\n        if(peopletime[m-1][n-1]==INT_MAX || firetime[m-1][n-1]<peopletime[m-1][n-1]){\\n            return -1;\\n        }\\n        // if fire can never reach the safehouse,\\n        // return 1000000000\\n        if(firetime[m-1][n-1]==INT_MAX){\\n            return 1000000000;\\n        }\\n        if(firetime[m-1][n-1]==peopletime[m-1][n-1]){\\n            return 0;\\n        }\\n        int diff = (firetime[m-1][n-1]-peopletime[m-1][n-1]);\\n        if(m>1 && n>1){\\n            if(peopletime[m-2][n-1]!=INT_MAX && peopletime[m-1][n-2]!=INT_MAX && ((firetime[m-2][n-1]-peopletime[m-2][n-1])>diff || (firetime[m-1][n-2]-peopletime[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994708,
                "title": "binary-search-bfs-c",
                "content": "**Idea:**\\n\\nIf we are able to start at time T and reach the end, we can always start at any lesser time and reach.\\nFor reference: In first example we can reach at any time <=3\\n\\nSo we can binary search the answer, maximum time starting at which we can reach the end.\\n\\n1. `canReach`: given a grid, having fire at some positions it returns whether the person would be able to reach the end\\n2. `spreadFire`: returns a grid after spreading fire for time T.\\n\\nTime complexity: `O( (n*m) * log(n*m) ) ` due to Binary Search + BFS\\nSpace complexity: `O( n*m )`\\n\\n```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997920,
                "title": "java-with-visual-explanation-and-detailed-comments-2258-escapethespreadingfire",
                "content": "### Illustration:\\n\\n**Example Input**:\\n`[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]`\\n\\nBelow is an illustration on how the values of the cells in the `grid` gets modified.\\n\\n![image](https://assets.leetcode.com/users/images/370f6122-23bc-4e2f-b1c6-5ef6568d43c8_1651405273.8621764.png)\\n\\n---\\n\\n### Logic:\\n- Initialization\\n\\t- Set `INF` as `10^9`.\\n\\t- Set all grass to `INF`\\n\\t- Set all Walls to `-1`\\n\\t- Set all Fire to `0`\\n\\t- Note:\\n\\t\\t- Here, using the same \"grid\" object to store the modified values\\n\\t\\t- If the value of the cell is `negative` or `0`, we cannot move to that cell as it has a wall or it is on fire\\n\\t\\t- If the value of the cell is positive `val`, then, that means it takes fire to get to that cell in `val` minutes\\n- **Spread fire** to Neighbours (Using BFS)\\n\\t- For each cell that has Fire\\n\\t\\t- Modify the cell value to the minimum no of minutes it takes to catch fire\\n- Find the **maximum initial delay** (Using Binary Search)\\n\\t- **Binary search** from `0` to `No. of cells in grid`\\n\\t\\t- For the given mid initial delay (in minutes), check if the person can escape to the safehouse safely or not\\n\\t\\t\\t- If person **can** reach SafeHouse safely\\n\\t\\t\\t\\t- Update **left** to **mid+1** (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\t\\t- **Update answer** with mid value\\n\\t\\t\\t- If person **cannot** reach SafeHouse safely\\n\\t\\t\\t\\t- Update **right** to **mid-1** (If mid is not possible, then, anything above that is also not possible)\\n\\n---\\n\\n### Java Code:\\n**Declare the INF variable**:\\n```\\nprivate int INF = 1000000000;\\n```\\n**Main method**:\\n```\\npublic int maximumMinutes(int[][] grid) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\n\\tfor (int i = 0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If grass\\n\\t\\t\\t\\tgrid[i][j] = INF;                              // Set to infinity\\n\\t\\t\\telse if (grid[i][j] == 2)                       // If wall\\n\\t\\t\\t\\tgrid[i][j] = -1;                               // Set to -1\\n\\t\\t\\telse if (grid[i][j] == 1)                       // If fire\\n\\t\\t\\t\\tgrid[i][j] = 0;                                // Set to 0\\n\\n\\tfor (int i=0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If fire\\n\\t\\t\\t\\tspreadFireUsingBFS(grid, i, j);                // Spread the fire to it\\'s neighbours, using BFS\\n\\n\\treturn findInitialDelayMinutesUsingBinarySearch(grid);  // Find initial delay in minutes, using Binary Search and BFS\\n}\\n```\\n**Spread fire to Neighbouring cells (using BFS)**:\\n```\\nprivate void spreadFireUsingBFS(int[][] grid, int startI, int startJ) {\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(startI,startJ));\\n\\tint val = 0;\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)  // If out of bounds\\n\\t\\t\\t\\tcontinue;                                              // Skip cell\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] < val)              // If current cell caught fire already\\n\\t\\t\\t\\tcontinue;                                              // Skip cell (As we only need the minimum minutes it take to catch fire on a cell)\\n\\n\\t\\t\\tgrid[i][j] = val;                                       // Update value of the cell with the minute it catches Fire\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                               // Add Neighbours to Queue\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tval++;\\n\\t}\\n}\\n```\\n**Use Binary Search, to find the maximum initial delay**:\\n```\\nprivate int findInitialDelayMinutesUsingBinarySearch(int[][] grid) {\\n\\tInteger ans = null;\\n\\tint max = grid.length * grid[0].length;\\n\\tint l = 0, r = max;\\n\\twhile (l <= r) {\\n\\t\\tint mid = l + (r-l)/2;                             // Binary Search\\n\\t\\tif (checkIfPersonEscapeUsingBFS(grid, mid)) {      // If person can reach SafeHouse safely (Find using BFS)\\n\\t\\t\\tl = mid + 1;                                      // Update left to mid+1 (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\tans = ans == null ? mid : Math.max(ans, mid);     // Update answer with mid value\\n\\t\\t} else {                                           // If person cannot reach SafeHouse safely\\n\\t\\t\\tr = mid - 1;                                      // Update right to mid-1 (If mid is not possible, then, anything above that is also no possible)\\n\\t\\t}\\n\\t}\\n\\tif (ans == null)                                       // Can\\'t reach SafeHouse even without any delay\\n\\t\\treturn -1;                                            // return -1\\n\\telse if (ans == max)                                   // Can reach SafeHouse even with infinite delay\\n\\t\\treturn INF;                                           // return 10^9\\n\\treturn ans;                                            // Can reach after delay of \"ans\" minutes, return ans\\n}\\n```\\n**For the given initial delay (in minutes), check if the person can escape to the safehouse safely**:\\n```\\nprivate boolean checkIfPersonEscapeUsingBFS(int[][] grid, int minutes) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(0,0));                                           // Start at (0,0)\\n\\tint[][] visited = new int[n][m];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)    // If out of bounds\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tif (visited[i][j] == 1)                                   // If already visited\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tvisited[i][j] = 1;                                        // Mark visited\\n\\t\\t\\tif (i == n-1 && j == m-1)                                    // If reached the SafeHouse\\n\\t\\t\\t\\treturn (grid[i][j] == INF || grid[i][j] >= minutes);  // If reached safely, return true, else false\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] <= minutes)           // If current cell is currently on fire\\n\\t\\t\\t\\tcontinue;                                                // skip cell\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                                 // Check Neighbours\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tminutes++;                                                    // Increment minutes\\n\\t}\\n\\treturn false;\\n}\\n```\\n**Method to print the cells** (Not needed):\\n```\\nprivate void print(int[][] grid) {                // Call this method to print current state of the cells\\n\\tint m = grid[0].length;\\n\\tSystem.out.println();\\n\\tfor (int[] cell : grid) {\\n\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\tSystem.out.print(cell[j] + \"    \");\\n\\t\\tSystem.out.println();\\n\\t}\\n}\\n```\\n\\n---\\n\\nComplexity as per Leetcode [submission](https://leetcode.com/submissions/detail/690875446/):\\n**Runtime**: 231 ms\\n**Memory Usage**: 117.7 MB",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nprivate int INF = 1000000000;\\n```\n```\\npublic int maximumMinutes(int[][] grid) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\n\\tfor (int i = 0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If grass\\n\\t\\t\\t\\tgrid[i][j] = INF;                              // Set to infinity\\n\\t\\t\\telse if (grid[i][j] == 2)                       // If wall\\n\\t\\t\\t\\tgrid[i][j] = -1;                               // Set to -1\\n\\t\\t\\telse if (grid[i][j] == 1)                       // If fire\\n\\t\\t\\t\\tgrid[i][j] = 0;                                // Set to 0\\n\\n\\tfor (int i=0; i<n; i++)\\n\\t\\tfor (int j=0; j<m; j++)\\n\\t\\t\\tif (grid[i][j] == 0)                            // If fire\\n\\t\\t\\t\\tspreadFireUsingBFS(grid, i, j);                // Spread the fire to it\\'s neighbours, using BFS\\n\\n\\treturn findInitialDelayMinutesUsingBinarySearch(grid);  // Find initial delay in minutes, using Binary Search and BFS\\n}\\n```\n```\\nprivate void spreadFireUsingBFS(int[][] grid, int startI, int startJ) {\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(startI,startJ));\\n\\tint val = 0;\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)  // If out of bounds\\n\\t\\t\\t\\tcontinue;                                              // Skip cell\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] < val)              // If current cell caught fire already\\n\\t\\t\\t\\tcontinue;                                              // Skip cell (As we only need the minimum minutes it take to catch fire on a cell)\\n\\n\\t\\t\\tgrid[i][j] = val;                                       // Update value of the cell with the minute it catches Fire\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                               // Add Neighbours to Queue\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tval++;\\n\\t}\\n}\\n```\n```\\nprivate int findInitialDelayMinutesUsingBinarySearch(int[][] grid) {\\n\\tInteger ans = null;\\n\\tint max = grid.length * grid[0].length;\\n\\tint l = 0, r = max;\\n\\twhile (l <= r) {\\n\\t\\tint mid = l + (r-l)/2;                             // Binary Search\\n\\t\\tif (checkIfPersonEscapeUsingBFS(grid, mid)) {      // If person can reach SafeHouse safely (Find using BFS)\\n\\t\\t\\tl = mid + 1;                                      // Update left to mid+1 (If mid is possible, then, anything below that is also possible)\\n\\t\\t\\tans = ans == null ? mid : Math.max(ans, mid);     // Update answer with mid value\\n\\t\\t} else {                                           // If person cannot reach SafeHouse safely\\n\\t\\t\\tr = mid - 1;                                      // Update right to mid-1 (If mid is not possible, then, anything above that is also no possible)\\n\\t\\t}\\n\\t}\\n\\tif (ans == null)                                       // Can\\'t reach SafeHouse even without any delay\\n\\t\\treturn -1;                                            // return -1\\n\\telse if (ans == max)                                   // Can reach SafeHouse even with infinite delay\\n\\t\\treturn INF;                                           // return 10^9\\n\\treturn ans;                                            // Can reach after delay of \"ans\" minutes, return ans\\n}\\n```\n```\\nprivate boolean checkIfPersonEscapeUsingBFS(int[][] grid, int minutes) {\\n\\tint n = grid.length, m = grid[0].length;\\n\\tQueue<Pair<Integer,Integer>> q = new LinkedList<>();\\n\\tq.add(new Pair<>(0,0));                                           // Start at (0,0)\\n\\tint[][] visited = new int[n][m];\\n\\twhile (!q.isEmpty()) {\\n\\t\\tint size = q.size();\\n\\t\\twhile (size-- > 0) {\\n\\t\\t\\tPair<Integer, Integer> pair = q.poll();\\n\\t\\t\\tint i = pair.getKey(), j = pair.getValue();\\n\\t\\t\\tif (i<0 || j<0 || i>=grid.length || j>=grid[0].length)    // If out of bounds\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tif (visited[i][j] == 1)                                   // If already visited\\n\\t\\t\\t\\tcontinue;                                                // Skip cell\\n\\t\\t\\tvisited[i][j] = 1;                                        // Mark visited\\n\\t\\t\\tif (i == n-1 && j == m-1)                                    // If reached the SafeHouse\\n\\t\\t\\t\\treturn (grid[i][j] == INF || grid[i][j] >= minutes);  // If reached safely, return true, else false\\n\\t\\t\\tif (grid[i][j] != INF && grid[i][j] <= minutes)           // If current cell is currently on fire\\n\\t\\t\\t\\tcontinue;                                                // skip cell\\n\\n\\t\\t\\tq.add(new Pair<>(i-1,j));                                 // Check Neighbours\\n\\t\\t\\tq.add(new Pair<>(i+1,j));\\n\\t\\t\\tq.add(new Pair<>(i,j-1));\\n\\t\\t\\tq.add(new Pair<>(i,j+1));\\n\\t\\t}\\n\\t\\tminutes++;                                                    // Increment minutes\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\nprivate void print(int[][] grid) {                // Call this method to print current state of the cells\\n\\tint m = grid[0].length;\\n\\tSystem.out.println();\\n\\tfor (int[] cell : grid) {\\n\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\tSystem.out.print(cell[j] + \"    \");\\n\\t\\tSystem.out.println();\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995447,
                "title": "c-commented-explanation-beginner-friendly-bfs-binary-search",
                "content": "/*\\n         \\n          Pre-Requisites : BFS + BINARY SEARCH\\n\\n         \\n          Step 1 --> Try to find out the minimum time to reach a cell (not the walls) by spreading the fire.\\n          \\n          \\n          \\n         Step 2 --> If the fire is not able to spread to the final destination (m-1,n-1)\\n         then there arises two cases :-\\n         \\n         Case 1. If our hero is able to reach the bottom-right cell , then returns 1e9\\n         \\n         Case 2. If our hero is not able to reach the bottom-right cell , then return -1\\n         [Here may be all of the possible paths are blocked by atleast one wall]\\n         \\n         \\n         \\n         Step 3 --> Now the main funda is to use binary search on answer (i.e the initial waiting time) ,\\n\\t\\t like if we are able to reach destination by wasting 20 minutes , then we can do the same for 10 minutes for sure.\\n         \\n*/\\n    \\n\\t\\n\\t\\nclass Solution {\\npublic:\\n    \\n    int m,n;\\n    \\n    // Four Directional Co-ordinates.\\n    \\n    int dx[4]={0,0,1,-1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    /* fire_time[i][j] stores the minimum time takes to spread the fire from their   \\n       initial positions to current cell [i,j] */\\n    \\n    int fire_time[302][302];\\n    \\n    /* dis[i][j] stores the minimum time to reach the cell [i,j] by our hero ,\\n       by successfully wasting (t) amount of time initially. */\\n    \\n    int dis[302][302];\\n    \\n    \\n    \\n    int minimum_time_to_reach_bottom_right(int waste_time,vector<vector<int>>&grid){\\n        \\n        queue<pair<int,int>>q;\\n        \\n        q.push({0,0});\\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                dis[i][j]=1e9;\\n            }\\n        }\\n        \\n        dis[0][0]=waste_time; // After wasting (t) amount of time our hero starts his journey from (0,0) cell.\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front();\\n            q.pop();\\n            \\n            int x=curr.first;\\n            int y=curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2){\\n                    \\n                    continue;\\n                    \\n                }\\n                \\n                int new_min=min(dis[nx][ny],dis[x][y]+1);\\n                \\n                if(nx==m-1 && ny==n-1 && new_min<=fire_time[nx][ny]){\\n                    return new_min;\\n                }\\n                \\n                if(new_min>=fire_time[nx][ny]){\\n                    continue;\\n                }\\n                \\n                if(dis[nx][ny]>dis[x][y]+1){\\n                    dis[nx][ny]=dis[x][y]+1;\\n                    q.push({nx,ny});\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return 1e9+1;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find_maximum_time(vector<vector<int>>&grid){\\n        \\n        // Base Case --> When the fire is not able to reach (m-1,n-1) cell.\\n        \\n        if(fire_time[m-1][n-1]==1e9){\\n            \\n            if(minimum_time_to_reach_bottom_right(0,grid)>=1e9){\\n                return -1;\\n            }\\n            \\n            else{\\n                return 1e9;\\n            }\\n            \\n        }\\n        \\n        \\n        // Binary Search on answer.\\n        \\n        int low=0,high=(m*n)+1;\\n        \\n        int ans=-1;\\n        \\n        while(low<=high){\\n            \\n            int mid=(low+high)/2;\\n            \\n            if(minimum_time_to_reach_bottom_right(mid,grid)<=fire_time[m-1][n-1]){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            \\n            else{\\n                high=mid-1;\\n            }\\n            \\n        }\\n        \\n        if(ans>=(m*n)+1){\\n            return 1e9;\\n        }\\n        \\n        else{\\n            return ans;\\n        }\\n        \\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        \\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                fire_time[i][j]=1e9;\\n            }\\n        }\\n        \\n        \\n        queue<pair<int,int>>q; // Here we use Multi-Source BFS to calculate the minimum time to reach cell (i,j) from all the initially given fire-points.\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==1){\\n                    \\n                    q.push({i,j});\\n                    \\n                    fire_time[i][j]=0;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        while(!q.empty()){\\n            \\n            auto curr=q.front();\\n            q.pop();\\n            \\n            int x=curr.first;\\n            int y=curr.second;\\n            \\n            for(int i=0;i<4;i++){\\n                \\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]!=2){\\n                    \\n                    if(fire_time[nx][ny]>fire_time[x][y]+1){\\n                        \\n                        fire_time[nx][ny]=fire_time[x][y]+1;\\n                        \\n                        q.push({nx,ny});\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        int ans=find_maximum_time(grid);\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int m,n;\\n    \\n    // Four Directional Co-ordinates.\\n    \\n    int dx[4]={0,0,1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1994556,
                "title": "c-bfs-binary-search",
                "content": "For each grid cell, pre-calculate the min time fire needs to get there using BFS.\\nUse Binary search to get the maximum wait time\\n\\n```\\nclass Solution {\\n    static constexpr int dir[5] = {-1, 0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int R = grid.size(),\\n            C = grid[0].size();\\n        \\n        vector<vector<int>> fire(R, vector<int>(C, INT_MAX));\\n        queue<array<int, 3>> q;\\n        for(int r=0; r<R; ++r){\\n            for(int c=0; c<C; ++c){\\n                if(grid[r][c] == 1){\\n                    fire[r][c] = 0;\\n                    q.push({r, c, 0});\\n                }\\n                else if(grid[r][c] == 2)\\n                    fire[r][c] = -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto [r, c, t] = q.front();\\n            q.pop();\\n            for(int i=0; i<4; ++i){\\n                int nr = r + dir[i],\\n                    nc = c + dir[i+1];\\n                if(nr>=0 && nr<R && nc>=0 && nc<C && fire[nr][nc]>t+1){\\n                    fire[nr][nc] = t+1;\\n                    q.push({nr, nc, t+1});\\n                }\\n            }\\n        }\\n        int l = 0,\\n            r = R*C + 1;\\n        vector<vector<int>> visited(R, vector<int>(C));\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            for(auto& row:visited)\\n                fill(row.begin(), row.end(), INT_MAX);\\n            if(possible(0, 0, mid, visited, fire))\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return r == R*C + 1 ? 1e9 : r;\\n    }\\nprivate:\\n    bool possible(int r, int c, int t, vector<vector<int>>& visited, vector<vector<int>>& fire) {\\n        if(r == fire.size()-1 && c == fire[0].size()-1)\\n            return true;\\n        if(fire[r][c] == t)\\n            return false;\\n        visited[r][c] = t;\\n        for(int i=0; i<4; ++i){\\n            int nr = r + dir[i],\\n                nc = c + dir[i+1];\\n            if(nr>=0 && nr<fire.size() && nc>=0 && nc<fire[0].size() && visited[nr][nc]>t+1 && fire[nr][nc]>=t+1 && possible(nr, nc, t+1, visited, fire))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static constexpr int dir[5] = {-1, 0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int R = grid.size(),\\n            C = grid[0].size();\\n        \\n        vector<vector<int>> fire(R, vector<int>(C, INT_MAX));\\n        queue<array<int, 3>> q;\\n        for(int r=0; r<R; ++r){\\n            for(int c=0; c<C; ++c){\\n                if(grid[r][c] == 1){\\n                    fire[r][c] = 0;\\n                    q.push({r, c, 0});\\n                }\\n                else if(grid[r][c] == 2)\\n                    fire[r][c] = -1;\\n            }\\n        }\\n        while(!q.empty()){\\n            auto [r, c, t] = q.front();\\n            q.pop();\\n            for(int i=0; i<4; ++i){\\n                int nr = r + dir[i],\\n                    nc = c + dir[i+1];\\n                if(nr>=0 && nr<R && nc>=0 && nc<C && fire[nr][nc]>t+1){\\n                    fire[nr][nc] = t+1;\\n                    q.push({nr, nc, t+1});\\n                }\\n            }\\n        }\\n        int l = 0,\\n            r = R*C + 1;\\n        vector<vector<int>> visited(R, vector<int>(C));\\n        while(l <= r){\\n            int mid = l + ((r-l)>>1);\\n            for(auto& row:visited)\\n                fill(row.begin(), row.end(), INT_MAX);\\n            if(possible(0, 0, mid, visited, fire))\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        \\n        return r == R*C + 1 ? 1e9 : r;\\n    }\\nprivate:\\n    bool possible(int r, int c, int t, vector<vector<int>>& visited, vector<vector<int>>& fire) {\\n        if(r == fire.size()-1 && c == fire[0].size()-1)\\n            return true;\\n        if(fire[r][c] == t)\\n            return false;\\n        visited[r][c] = t;\\n        for(int i=0; i<4; ++i){\\n            int nr = r + dir[i],\\n                nc = c + dir[i+1];\\n            if(nr>=0 && nr<fire.size() && nc>=0 && nc<fire[0].size() && visited[nr][nc]>t+1 && fire[nr][nc]>=t+1 && possible(nr, nc, t+1, visited, fire))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044276,
                "title": "python-easy-to-understand-bfs-binary-search-solution",
                "content": "The three steps in the solution:\\nstep 1: spread the fire with **BFS**\\nstep 2: check edge cases\\nstep 3: find the optimal time using **Binary Search**\\n\\nbasically the fire array, for each cell marks the time that the fire has reached there.\\nthen all we need to do is binary search and try to minimize the time as much as possible.\\n\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        # speard the fire and fill the \"fire\" array\\n        def bfsFire():\\n            q = deque()\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n            dist = 0\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if fire[i][j] != float(\\'inf\\'):\\n                        continue\\n                    fire[i][j] = dist\\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float(\\'inf\\'): q.append((i + 1, j))\\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float(\\'inf\\'): q.append((i - 1, j))\\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float(\\'inf\\'): q.append((i, j + 1))\\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float(\\'inf\\'): q.append((i, j - 1))\\n                dist += 1\\n\\n        # check if we can reach the house after waiting \"time\" time\\n        def bfsCanReach(time):\\n            q = deque()\\n            q.append((0, 0))\\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\\n                        return True\\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\\n                        continue\\n                    curGrid[i][j] = \"#\"\\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\\n                time += 1\\n            return False\\n\\n        bfsFire()\\n\\n        # edge cases\\n        canReachHouse = bfsCanReach(0)\\n        if not canReachHouse:\\n            return -1\\n        if canReachHouse and fire[m - 1][n - 1] == float(\\'inf\\'):\\n            return 10 ** 9\\n\\n        # binary search to find best time\\n        left, right = 0, 10 ** 9\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if bfsCanReach(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        # speard the fire and fill the \"fire\" array\\n        def bfsFire():\\n            q = deque()\\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n            dist = 0\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if fire[i][j] != float(\\'inf\\'):\\n                        continue\\n                    fire[i][j] = dist\\n                    if i < m - 1 and grid[i + 1][j] == 0 and fire[i + 1][j] == float(\\'inf\\'): q.append((i + 1, j))\\n                    if i > 0 and grid[i - 1][j] == 0 and fire[i - 1][j] == float(\\'inf\\'): q.append((i - 1, j))\\n                    if j < n - 1 and grid[i][j + 1] == 0 and fire[i][j + 1] == float(\\'inf\\'): q.append((i, j + 1))\\n                    if j > 0 and grid[i][j - 1] == 0 and fire[i][j - 1] == float(\\'inf\\'): q.append((i, j - 1))\\n                dist += 1\\n\\n        # check if we can reach the house after waiting \"time\" time\\n        def bfsCanReach(time):\\n            q = deque()\\n            q.append((0, 0))\\n            curGrid = [[grid[i][j] for j in range(n)] for i in range(m)]\\n            while q:\\n                size = len(q)\\n                for _ in range(size):\\n                    i, j = q.popleft()\\n                    if i == m - 1 and j == n - 1 and time <= fire[i][j]:\\n                        return True\\n                    if fire[i][j] <= time or curGrid[i][j] == \"#\":\\n                        continue\\n                    curGrid[i][j] = \"#\"\\n                    if i < m - 1 and curGrid[i + 1][j] == 0: q.append((i + 1, j))\\n                    if i > 0 and curGrid[i - 1][j] == 0: q.append((i - 1, j))\\n                    if j < n - 1 and curGrid[i][j + 1] == 0: q.append((i, j + 1))\\n                    if j > 0 and curGrid[i][j - 1] == 0: q.append((i, j - 1))\\n                time += 1\\n            return False\\n\\n        bfsFire()\\n\\n        # edge cases\\n        canReachHouse = bfsCanReach(0)\\n        if not canReachHouse:\\n            return -1\\n        if canReachHouse and fire[m - 1][n - 1] == float(\\'inf\\'):\\n            return 10 ** 9\\n\\n        # binary search to find best time\\n        left, right = 0, 10 ** 9\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if bfsCanReach(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2000883,
                "title": "c-100-faster-100-memory-efficient",
                "content": "class Solution {\\npublic:\\n    vector<pair<int,int>>dirs={{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    int subract(int x,int y){\\n        if(x==INT_MAX)return INT_MAX;\\n        return x-y;\\n    }\\n    void findFireTime(vector<vector<int>>&grid,vector<vector<int>>&fireTime){\\n        queue<tuple<int,int,int>>q;\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)q.push({i,j,0});\\n            }\\n        }\\n        vector<vector<int>>vis(grid);\\n        while(!q.empty()){\\n            auto [i,j,time]=q.front();q.pop();\\n            fireTime[i][j]=time;\\n            vis[i][j]=1;\\n            for(auto dir:dirs){\\n                int x=i+dir.first,y=j+dir.second;\\n                if(x>=0 && x<m && y>=0 && y<n && !vis[x][y])q.push({x,y,time+1});\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>fireTime(m,vector<int>(n,INT_MAX));\\n        \\n        findFireTime(grid,fireTime);// min time for fire to reach each cell\\n        priority_queue<tuple<int,int,int,int>>pq;\\n        vector<vector<int>>vis(grid);\\n        pq.push({fireTime[0][0],0,0,0});// amongst all paths to reach last cell, the best will be the one in which the minimum value for diff(diff is the difference between time for fire to reach and time for person to reach from first cell)amongst every cell in that path, is maximum\\n        while(!pq.empty()){\\n            auto [diff,i,j,time]=pq.top();pq.pop();\\n            if(vis[i][j])continue;\\n            if(i==m-1 && j==n-1){\\n                if(diff==INT_MAX)return (int)1e9;\\n                if(diff<0)return -1;\\n                return diff;\\n            }\\n            vis[i][j]=1;\\n            for(auto dir:dirs){\\n                int x=i+dir.first,y=j+dir.second;\\n                if(x>=0 && x<m && y>=0 && y<n && !vis[x][y]){\\n                    if(x==m-1 && y==n-1)pq.push({min(diff,subract(fireTime[x][y],(time+1))),x,y,time+1});//if we reach last cell exactly when fire arrives, its valid but in every other cell we need to reach before fire arrives\\n                    else pq.push({min(diff,subract(fireTime[x][y],(time+2))),x,y,time+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<pair<int,int>>dirs={{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 3161988,
                "title": "2-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*M*Log(N*M))\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nconst marker = -1000000003\\nlet moves = [[0, 1], [1, 0], [-1, 0], [0, -1]]\\nvar maximumMinutes = function(grid) {\\n    let lastGrassAffectedByFireMin = spreadFireBfs(grid);\\n    markUnreachedCells(grid);\\n    let maxMin = Math.min(lastGrassAffectedByFireMin, getLastMin(grid, 0, 0))\\n\\n    if(grid[0][0] === marker && findPath(grid, 1000000000) !== -1){\\n        return 1000000000;\\n    }\\n    let res = -1\\n    let start = 0;\\n    let end = maxMin;\\n    let mid = -1\\n    while(start <= end){\\n        mid = Math.floor((start + end) / 2);\\n        res = findPath(grid, mid);\\n        if(res == -1){\\n            end = mid -1\\n        } else {\\n            start = mid + 1\\n        }\\n    }\\n    if(res == -1){\\n        if(mid == -1){\\n            return -1\\n        }\\n        return mid -1;\\n    }\\n    return mid;\\n};\\n\\nfunction findPath(grid, startMin){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let currentMin = startMin;\\n    let set = new Set();\\n    \\n    if (getLastMin(grid, 0, 0) < startMin) {\\n        return -1\\n    }\\n\\n    let queue = [[0, 0]]\\n\\n    while (queue.length){\\n        let nextQueue = []\\n        for(let c of queue){\\n            if(c[0] === n-1 && c[1] === m-1){\\n                return startMin;\\n            }\\n            let key = `${c[0]}_${c[1]}`;\\n            let lastMin = getLastMin(grid, c[0], c[1]);\\n            if (!set.has(key) && (lastMin > currentMin || grid[c[0]][c[1]] === marker)) {\\n                set.add(key);\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] !== 2 && (getLastMin(grid, nmi, nmj) > currentMin || grid[nmi][nmj] === marker)){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue;\\n        currentMin++;\\n    }\\n\\n    return -1\\n}\\n\\nfunction getLastMin(grid, i, j){\\n    return -(grid[i][j] + 1)\\n}\\n\\nfunction markUnreachedCells(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] == 0){\\n                grid[i][j] = marker;\\n            }\\n        }\\n    }\\n}\\n\\nfunction spreadFireBfs(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let queue = collectStartPoints(grid);\\n\\n    let minNumber = -1;\\n    while (queue.length) {\\n        let nextQueue = [];\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i];\\n            \\n            if(grid[c[0]][c[1]] === 0 || grid[c[0]][c[1]] === -1) {\\n                grid[c[0]][c[1]] = minNumber;\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] === 0){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        minNumber--;\\n        queue = nextQueue;\\n    }\\n\\n    return -(minNumber + 2)\\n}\\n\\nfunction collectStartPoints(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length;\\n\\n    const result = [];\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] === 1){\\n                grid[i][j] = -1;\\n                result.push([i, j]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nconst marker = -1000000003\\nlet moves = [[0, 1], [1, 0], [-1, 0], [0, -1]]\\nvar maximumMinutes = function(grid) {\\n    let lastGrassAffectedByFireMin = spreadFireBfs(grid);\\n    markUnreachedCells(grid);\\n    let maxMin = Math.min(lastGrassAffectedByFireMin, getLastMin(grid, 0, 0))\\n\\n    if(grid[0][0] === marker && findPath(grid, 1000000000) !== -1){\\n        return 1000000000;\\n    }\\n    let res = -1\\n    let start = 0;\\n    let end = maxMin;\\n    let mid = -1\\n    while(start <= end){\\n        mid = Math.floor((start + end) / 2);\\n        res = findPath(grid, mid);\\n        if(res == -1){\\n            end = mid -1\\n        } else {\\n            start = mid + 1\\n        }\\n    }\\n    if(res == -1){\\n        if(mid == -1){\\n            return -1\\n        }\\n        return mid -1;\\n    }\\n    return mid;\\n};\\n\\nfunction findPath(grid, startMin){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let currentMin = startMin;\\n    let set = new Set();\\n    \\n    if (getLastMin(grid, 0, 0) < startMin) {\\n        return -1\\n    }\\n\\n    let queue = [[0, 0]]\\n\\n    while (queue.length){\\n        let nextQueue = []\\n        for(let c of queue){\\n            if(c[0] === n-1 && c[1] === m-1){\\n                return startMin;\\n            }\\n            let key = `${c[0]}_${c[1]}`;\\n            let lastMin = getLastMin(grid, c[0], c[1]);\\n            if (!set.has(key) && (lastMin > currentMin || grid[c[0]][c[1]] === marker)) {\\n                set.add(key);\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] !== 2 && (getLastMin(grid, nmi, nmj) > currentMin || grid[nmi][nmj] === marker)){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n        queue = nextQueue;\\n        currentMin++;\\n    }\\n\\n    return -1\\n}\\n\\nfunction getLastMin(grid, i, j){\\n    return -(grid[i][j] + 1)\\n}\\n\\nfunction markUnreachedCells(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] == 0){\\n                grid[i][j] = marker;\\n            }\\n        }\\n    }\\n}\\n\\nfunction spreadFireBfs(grid){\\n    let n = grid.length;\\n    let m = grid[0].length;\\n    let queue = collectStartPoints(grid);\\n\\n    let minNumber = -1;\\n    while (queue.length) {\\n        let nextQueue = [];\\n        for(let i = 0; i < queue.length; i++){\\n            let c = queue[i];\\n            \\n            if(grid[c[0]][c[1]] === 0 || grid[c[0]][c[1]] === -1) {\\n                grid[c[0]][c[1]] = minNumber;\\n                for(let move of moves){\\n                    let nmi = move[0] + c[0];\\n                    let nmj = move[1] + c[1];\\n                    if(nmi >= 0 && nmi < n && nmj >= 0 && nmj < m && grid[nmi][nmj] === 0){\\n                        nextQueue.push([nmi, nmj]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        minNumber--;\\n        queue = nextQueue;\\n    }\\n\\n    return -(minNumber + 2)\\n}\\n\\nfunction collectStartPoints(grid) {\\n    let n = grid.length;\\n    let m = grid[0].length;\\n\\n    const result = [];\\n    for(let i = 0; i < n; i++){\\n        for(let j = 0; j < m; j++){\\n            if(grid[i][j] === 1){\\n                grid[i][j] = -1;\\n                result.push([i, j]);\\n            }\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994936,
                "title": "python-binary-search-priority-queue-dijkstra-o-mn-log-mn-2",
                "content": "Fire has higher priority than the escaper.\\nIf a cell is already visited(occupied) by a fire the escaper cannot visit the cell.\\nAll the fires start to spread from the beginning.\\ncheck(start): check whether it is possible to escape when started from the time start.\\nDo binary search for the start time.\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ESCAPER, FIRE, WALL = 1, 0, 2\\n        fires = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j))\\n        def check(start):\\n            visited = set()\\n            heap = [(start,ESCAPER,0,0)]\\n            first_reach = float(\\'inf\\')\\n            for i,j in fires:\\n                heap.append((0,FIRE,i,j))\\n            heapify(heap)\\n            while heap:\\n                d, t, r, c = heappop(heap)\\n                if t == ESCAPER and (r,c) == (m-1,n-1) and (first_reach == float(\\'inf\\') or first_reach == d): \\n                    return True\\n                if (r,c) in visited: continue\\n                if (r,c) == (m-1, n-1):\\n                    first_reach = min(first_reach, d)\\n                visited.add((r,c))\\n                for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                    if (0 <= r+dr < m) and (0 <= c+dc < n) and grid[r+dr][c+dc] != WALL:\\n                        heappush(heap, (d+1,t,r+dr,c+dc))\\n            return False\\n        left, right = -1, m*n-1\\n        while left < right:\\n            mid = (left + right +1)//2\\n            if check(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        if left == m*n-1:\\n            return 10**9\\n        return left\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "Fire has higher priority than the escaper.\\nIf a cell is already visited(occupied) by a fire the escaper cannot visit the cell.\\nAll the fires start to spread from the beginning.\\ncheck(start): check whether it is possible to escape when started from the time start.\\nDo binary search for the start time.\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        ESCAPER, FIRE, WALL = 1, 0, 2\\n        fires = []\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j))\\n        def check(start):\\n            visited = set()\\n            heap = [(start,ESCAPER,0,0)]\\n            first_reach = float(\\'inf\\')\\n            for i,j in fires:\\n                heap.append((0,FIRE,i,j))\\n            heapify(heap)\\n            while heap:\\n                d, t, r, c = heappop(heap)\\n                if t == ESCAPER and (r,c) == (m-1,n-1) and (first_reach == float(\\'inf\\') or first_reach == d): \\n                    return True\\n                if (r,c) in visited: continue\\n                if (r,c) == (m-1, n-1):\\n                    first_reach = min(first_reach, d)\\n                visited.add((r,c))\\n                for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                    if (0 <= r+dr < m) and (0 <= c+dc < n) and grid[r+dr][c+dc] != WALL:\\n                        heappush(heap, (d+1,t,r+dr,c+dc))\\n            return False\\n        left, right = -1, m*n-1\\n        while left < right:\\n            mid = (left + right +1)//2\\n            if check(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        if left == m*n-1:\\n            return 10**9\\n        return left\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1994700,
                "title": "java-solution-using-bfs-with-explanation-comments",
                "content": "The idea is to run BFS from all the Fires until it reaches the destination and note down the time it reaches a particular cell.\\n\\nNow run a BFS from the starting node and keep track of minimum difference between fire reaching a cell and person reaching a cell.\\n\\nIf fire reaches a cell before or same time as person, you can not go to that cell or any path that passes through that cell.\\nException: If it\\'s the destination cell, both can reach at same time.\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] times = new int[m][n];\\n        for(int[] row : times) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int[] dir = new int[]{-1, 0, 1, 0, -1};\\n        \\n\\t\\t// Queue for running BFS\\n        Deque<int[]> fires = new ArrayDeque<>();\\n\\t\\t\\n        for(int row = 0; row < m; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) {\\n                    times[row][col] = 0;\\n                    fires.offer(new int[]{row, col});\\n                }\\n            }\\n        }\\n        \\n        int time = 1;\\n        while(!fires.isEmpty()) {\\n            int size = fires.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                int[] pos = fires.poll();\\n                \\n                for(int j = 0; j < 4; j++) {\\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n                    \\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] == Integer.MAX_VALUE) {\\n                        times[x][y] = time;\\n                        fires.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        fires.clear();\\n        \\n        int ans = Integer.MAX_VALUE;\\n        fires.offer(new int[]{0, 0});\\n        grid[0][0] = 2;\\n\\n        time = 1;\\n        while(!fires.isEmpty() && grid[m - 1][n - 1] == 0) {\\n            int size = fires.size();\\n            \\n            int t = Integer.MIN_VALUE;\\n            \\n            for(int i = 0; i < size && grid[m - 1][n - 1] == 0; i++) {\\n                int[] pos = fires.poll();\\n            \\n                for(int j = 0; j < 4 && grid[m - 1][n - 1] == 0; j++) {\\n                    \\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n\\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] >= time) {\\n                        if (x == m - 1 && y == n - 1) {\\n                            t = times[x][y] - time;\\n                            grid[x][y] = 2;\\n                            break;\\n                        }\\n\\n                        grid[x][y] = 2;\\n                        fires.offer(new int[]{x, y});\\n                        \\n\\t\\t\\t\\t\\t\\t// if times[x][y] == Integer.MAX_VALUE, fire will never reach this cell and it will contribute maximum wait time\\n                        t = Math.max(t, times[x][y] == Integer.MAX_VALUE ? 1000000000 : times[x][y] - time - 1);\\n                    }\\n                }\\n            }\\n            \\n            ans = Math.min(ans, t);\\n            \\n            time++;\\n        }\\n        \\n\\t\\t// You can never reach the safe house\\n        if (grid[m - 1][n - 1] != 2) {\\n            return -1;\\n        }\\n        \\n\\t\\t// you can reach the safe house but fire can not\\n        if (times[m - 1][n - 1] == Integer.MAX_VALUE) {\\n            return 1000000000;\\n        }\\n        \\n        return ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] times = new int[m][n];\\n        for(int[] row : times) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int[] dir = new int[]{-1, 0, 1, 0, -1};\\n        \\n\\t\\t// Queue for running BFS\\n        Deque<int[]> fires = new ArrayDeque<>();\\n\\t\\t\\n        for(int row = 0; row < m; row++) {\\n            for(int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) {\\n                    times[row][col] = 0;\\n                    fires.offer(new int[]{row, col});\\n                }\\n            }\\n        }\\n        \\n        int time = 1;\\n        while(!fires.isEmpty()) {\\n            int size = fires.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                int[] pos = fires.poll();\\n                \\n                for(int j = 0; j < 4; j++) {\\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n                    \\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] == Integer.MAX_VALUE) {\\n                        times[x][y] = time;\\n                        fires.offer(new int[]{x, y});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        fires.clear();\\n        \\n        int ans = Integer.MAX_VALUE;\\n        fires.offer(new int[]{0, 0});\\n        grid[0][0] = 2;\\n\\n        time = 1;\\n        while(!fires.isEmpty() && grid[m - 1][n - 1] == 0) {\\n            int size = fires.size();\\n            \\n            int t = Integer.MIN_VALUE;\\n            \\n            for(int i = 0; i < size && grid[m - 1][n - 1] == 0; i++) {\\n                int[] pos = fires.poll();\\n            \\n                for(int j = 0; j < 4 && grid[m - 1][n - 1] == 0; j++) {\\n                    \\n                    int x = pos[0] + dir[j];\\n                    int y = pos[1] + dir[j + 1];\\n\\n                    if (x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && times[x][y] >= time) {\\n                        if (x == m - 1 && y == n - 1) {\\n                            t = times[x][y] - time;\\n                            grid[x][y] = 2;\\n                            break;\\n                        }\\n\\n                        grid[x][y] = 2;\\n                        fires.offer(new int[]{x, y});\\n                        \\n\\t\\t\\t\\t\\t\\t// if times[x][y] == Integer.MAX_VALUE, fire will never reach this cell and it will contribute maximum wait time\\n                        t = Math.max(t, times[x][y] == Integer.MAX_VALUE ? 1000000000 : times[x][y] - time - 1);\\n                    }\\n                }\\n            }\\n            \\n            ans = Math.min(ans, t);\\n            \\n            time++;\\n        }\\n        \\n\\t\\t// You can never reach the safe house\\n        if (grid[m - 1][n - 1] != 2) {\\n            return -1;\\n        }\\n        \\n\\t\\t// you can reach the safe house but fire can not\\n        if (times[m - 1][n - 1] == Integer.MAX_VALUE) {\\n            return 1000000000;\\n        }\\n        \\n        return ans == Integer.MAX_VALUE || ans == Integer.MIN_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012842,
                "title": "c-dfs-bfs-easy-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\nprivate:\\n\\n    int ans = -1;\\n\\n    void helper(int r, int c, int m, int n, bool flag, int current, int propogate, vector<vector<int>> &minutes, vector<vector<bool>> &visited, unordered_set<string> &us){\\n\\n        string now = to_string(r) + \"->\" + to_string(c) + \"->\" + to_string(propogate);\\n\\n        if(us.find(now) == us.end()){\\n\\n        visited[r][c] = true;\\n\\n        if(r == m - 1 and c == n - 1){\\n            if(flag) ans = 1e9;\\n            ans = max(ans, propogate);\\n            visited[r][c] = false;\\n            return;\\n        }\\n\\n        if(minutes[r][c] - 1 - current < 0) return;\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        for(int k = 0 ; k < 4 ; k++){\\n            int dR = dr[k] + r;\\n            int dC = dc[k] + c;\\n\\n            if(dR == m - 1 and dC == n - 1 and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 1), minutes, visited, us);\\n            }\\n\\n            else if(dR >= 0 and dR < m and dC >= 0 and dC < n and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 2), minutes, visited, us);\\n            }\\n\\n        }\\n\\n        visited[r][c] = false;\\n        us.insert(now);\\n        }\\n\\n    }\\n\\n\\n    bool check(int r, int c, int m, int n, vector<vector<int>> &grid){\\n        return (r >= 0 and r < m and c >= 0 and c < n and grid[r][c] != 2);\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time in which fire will reach to the cell with the help of BFS.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> minutes(m, vector<int> (n, 1e9));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j ++){\\n                if(grid[i][j] == 1){\\n                    minutes[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else if(grid[i][j] == 2){\\n                    minutes[i][j] = -1;\\n                }\\n            }\\n        }\\n\\n        int current = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto front = q.front();\\n                q.pop();\\n                int r = front.first;\\n                int c = front.second;\\n                int dr[4] = {-1, 1, 0, 0};\\n                int dc[4] = {0, 0, -1, 1};\\n                for(int k = 0 ; k < 4 ; k++){\\n                    int dR = dr[k] + r;\\n                    int dC = dc[k] + c;\\n                    if(check(dR, dC, m, n, grid)){\\n                        if(current < minutes[dR][dC])\\n                        {\\n                            minutes[dR][dC] = current;\\n                            q.push({dR, dC});\\n                        }\\n                    }\\n                }\\n            }\\n            current += 1;\\n        }\\n\\n        vector<vector<bool>> visited(m, vector<bool> (n, false));\\n\\n        unordered_set<string> us;\\n\\n        helper(0, 0, m, n, (minutes[0][0] == 1e9), 0, minutes[0][0] - 1, minutes, visited, us);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n\\n    int ans = -1;\\n\\n    void helper(int r, int c, int m, int n, bool flag, int current, int propogate, vector<vector<int>> &minutes, vector<vector<bool>> &visited, unordered_set<string> &us){\\n\\n        string now = to_string(r) + \"->\" + to_string(c) + \"->\" + to_string(propogate);\\n\\n        if(us.find(now) == us.end()){\\n\\n        visited[r][c] = true;\\n\\n        if(r == m - 1 and c == n - 1){\\n            if(flag) ans = 1e9;\\n            ans = max(ans, propogate);\\n            visited[r][c] = false;\\n            return;\\n        }\\n\\n        if(minutes[r][c] - 1 - current < 0) return;\\n\\n        int dr[4] = {-1, 1, 0, 0};\\n        int dc[4] = {0, 0, -1, 1};\\n\\n        for(int k = 0 ; k < 4 ; k++){\\n            int dR = dr[k] + r;\\n            int dC = dc[k] + c;\\n\\n            if(dR == m - 1 and dC == n - 1 and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 1), minutes, visited, us);\\n            }\\n\\n            else if(dR >= 0 and dR < m and dC >= 0 and dC < n and !visited[dR][dC]){\\n                helper(dR, dC, m, n, flag or (minutes[dR][dC] == 1e9), current + 1, min(propogate, minutes[dR][dC] - current - 2), minutes, visited, us);\\n            }\\n\\n        }\\n\\n        visited[r][c] = false;\\n        us.insert(now);\\n        }\\n\\n    }\\n\\n\\n    bool check(int r, int c, int m, int n, vector<vector<int>> &grid){\\n        return (r >= 0 and r < m and c >= 0 and c < n and grid[r][c] != 2);\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        // Intution\\n        // The idea in here is really very simple. We will find the time in which fire will reach to the cell with the help of BFS.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> minutes(m, vector<int> (n, 1e9));\\n\\n        queue<pair<int, int>> q;\\n\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j ++){\\n                if(grid[i][j] == 1){\\n                    minutes[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n                else if(grid[i][j] == 2){\\n                    minutes[i][j] = -1;\\n                }\\n            }\\n        }\\n\\n        int current = 1;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto front = q.front();\\n                q.pop();\\n                int r = front.first;\\n                int c = front.second;\\n                int dr[4] = {-1, 1, 0, 0};\\n                int dc[4] = {0, 0, -1, 1};\\n                for(int k = 0 ; k < 4 ; k++){\\n                    int dR = dr[k] + r;\\n                    int dC = dc[k] + c;\\n                    if(check(dR, dC, m, n, grid)){\\n                        if(current < minutes[dR][dC])\\n                        {\\n                            minutes[dR][dC] = current;\\n                            q.push({dR, dC});\\n                        }\\n                    }\\n                }\\n            }\\n            current += 1;\\n        }\\n\\n        vector<vector<bool>> visited(m, vector<bool> (n, false));\\n\\n        unordered_set<string> us;\\n\\n        helper(0, 0, m, n, (minutes[0][0] == 1e9), 0, minutes[0][0] - 1, minutes, visited, us);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228139,
                "title": "halt-for-n-minutes-and-catch-fire-99-without-bs",
                "content": "First, we replace the values in the matrix by the following rules: \\n* obstacle = -1\\n* grass = inf\\n* fire = 0 (and put a couple of indexes in the queue)\\n\\nThen each cell is assigned the minimum possible value of time in which it can be covered by the flame.  Obstacles and fireproof cells remain -1 and inf, respectively. The result is something similar to the Paint-madskills below:\\n![image](https://assets.leetcode.com/users/images/92fe8fcb-ee13-40b6-a2cf-10055fc5b120_1656781336.5038226.png)\\n\\nNext, we are long and tedious searching for ways: the next cell can be stepped on if  a)is not a wall b)we did not come from it c)its value is greater than the updated counter time (which is essentially the number of cells we visited). This is all solved with a single check cur_grid[i][j] > time, since obstacles = -1 and having visited a cell we put -1 in the local cur_grid matrix (yep, for the space we use this is just a disaster). \\nDon\\'t forget that it is possible to jump into the shelter at the same time as the fire! For each path, look for the minimum difference between the time we hit a cell and its value(=time fire reaches that cell). Choose the LARGEST such number out of all successful paths (could reach the shelter), that will be the answer\\n\\n\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid):\\n\\t\\t\\tm, n = len(grid), len(grid[0])\\n\\t\\t\\tqueue = deque()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tel = grid[i][j]\\n\\t\\t\\t\\t\\tif el == 2:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\t\\t\\telif not el:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = float(inf)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tqueue.append([i, j])\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ti, j = queue.popleft()\\n\\t\\t\\t\\tstatus = grid[i][j]\\n\\t\\t\\t\\tif j + 1 < n and grid[i][j+1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j+1] == inf: queue.append([i, j+1])\\n\\t\\t\\t\\t\\tgrid[i][j+1] = min(grid[i][j+1], status + 1)\\n\\n\\t\\t\\t\\tif j - 1 > -1 and grid[i][j-1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j-1] == inf: queue.append([i, j-1])\\n\\t\\t\\t\\t\\tgrid[i][j-1] = min(grid[i][j-1], status + 1)\\n\\n\\t\\t\\t\\tif i + 1 < m and grid[i+1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i+1][j] == inf: queue.append([i+1, j])\\n\\t\\t\\t\\t\\tgrid[i+1][j] = min(grid[i+1][j], status + 1)\\n\\n\\t\\t\\t\\tif i - 1 > -1 and grid[i-1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i-1][j] == inf: queue.append([i-1, j])\\n\\t\\t\\t\\t\\tgrid[i-1][j] = min(grid[i-1][j], status + 1)\\n\\n\\t\\t\\tres, flag = 0, 0 #flag is used to check if we have found at least one path\\n\\n\\t\\t\\tdef func(cur_grid=grid, i=0, j=0, time=1, tmp=float(inf)):\\n\\t\\t\\t\\tnonlocal res, flag            \\n\\t\\t\\t\\tcur_grid[i][j] = -1\\n\\n\\t\\t\\t\\t# the check is carried out in this way since we are satisfied\\n\\t\\t\\t\\t# with getting into the shelter at the same time as the flames:\\n\\t\\t\\t\\tif ((i, j+1) == (m-1, n-1) or (i+1, j) == (m-1, n-1)) and cur_grid[-1][-1] >= time:\\n\\t\\t\\t\\t\\tflag = 1\\n\\t\\t\\t\\t\\tres = max(res, min(tmp, cur_grid[-1][-1] - time))\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif j + 1 < n and cur_grid[i][j+1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j + 1, time + 1, min(tmp, cur_grid[i][j+1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif j - 1 > -1 and cur_grid[i][j-1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j - 1, time + 1, min(tmp, cur_grid[i][j-1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i + 1 < m and cur_grid[i+1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i+1, j, time + 1, min(tmp, cur_grid[i+1][j] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i - 1 > -1 and cur_grid[i-1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i-1, j, time + 1, min(tmp, cur_grid[i-1][j] - time - 1))\\n\\n\\t\\t\\tfunc()\\n\\n\\t\\t\\tif not flag:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\treturn min(10**9, res)   \\n\\t\\t\\t\\nI could have written a general function that determines whether you can go to a given cell based on the given conditions, but got lazy, so ugly repeating fragments, sorry\\nGuess I got lucky on my check, but\\n![image](https://assets.leetcode.com/users/images/d6714c54-f0fc-4bc1-9e01-06082b2ab355_1656777500.7328482.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "First, we replace the values in the matrix by the following rules: \\n* obstacle = -1\\n* grass = inf\\n* fire = 0 (and put a couple of indexes in the queue)\\n\\nThen each cell is assigned the minimum possible value of time in which it can be covered by the flame.  Obstacles and fireproof cells remain -1 and inf, respectively. The result is something similar to the Paint-madskills below:\\n![image](https://assets.leetcode.com/users/images/92fe8fcb-ee13-40b6-a2cf-10055fc5b120_1656781336.5038226.png)\\n\\nNext, we are long and tedious searching for ways: the next cell can be stepped on if  a)is not a wall b)we did not come from it c)its value is greater than the updated counter time (which is essentially the number of cells we visited). This is all solved with a single check cur_grid[i][j] > time, since obstacles = -1 and having visited a cell we put -1 in the local cur_grid matrix (yep, for the space we use this is just a disaster). \\nDon\\'t forget that it is possible to jump into the shelter at the same time as the fire! For each path, look for the minimum difference between the time we hit a cell and its value(=time fire reaches that cell). Choose the LARGEST such number out of all successful paths (could reach the shelter), that will be the answer\\n\\n\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid):\\n\\t\\t\\tm, n = len(grid), len(grid[0])\\n\\t\\t\\tqueue = deque()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tel = grid[i][j]\\n\\t\\t\\t\\t\\tif el == 2:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = -1\\n\\t\\t\\t\\t\\telif not el:\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = float(inf)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tqueue.append([i, j])\\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 0\\n\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ti, j = queue.popleft()\\n\\t\\t\\t\\tstatus = grid[i][j]\\n\\t\\t\\t\\tif j + 1 < n and grid[i][j+1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j+1] == inf: queue.append([i, j+1])\\n\\t\\t\\t\\t\\tgrid[i][j+1] = min(grid[i][j+1], status + 1)\\n\\n\\t\\t\\t\\tif j - 1 > -1 and grid[i][j-1] > 0:\\n\\t\\t\\t\\t\\tif grid[i][j-1] == inf: queue.append([i, j-1])\\n\\t\\t\\t\\t\\tgrid[i][j-1] = min(grid[i][j-1], status + 1)\\n\\n\\t\\t\\t\\tif i + 1 < m and grid[i+1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i+1][j] == inf: queue.append([i+1, j])\\n\\t\\t\\t\\t\\tgrid[i+1][j] = min(grid[i+1][j], status + 1)\\n\\n\\t\\t\\t\\tif i - 1 > -1 and grid[i-1][j] > 0:\\n\\t\\t\\t\\t\\tif grid[i-1][j] == inf: queue.append([i-1, j])\\n\\t\\t\\t\\t\\tgrid[i-1][j] = min(grid[i-1][j], status + 1)\\n\\n\\t\\t\\tres, flag = 0, 0 #flag is used to check if we have found at least one path\\n\\n\\t\\t\\tdef func(cur_grid=grid, i=0, j=0, time=1, tmp=float(inf)):\\n\\t\\t\\t\\tnonlocal res, flag            \\n\\t\\t\\t\\tcur_grid[i][j] = -1\\n\\n\\t\\t\\t\\t# the check is carried out in this way since we are satisfied\\n\\t\\t\\t\\t# with getting into the shelter at the same time as the flames:\\n\\t\\t\\t\\tif ((i, j+1) == (m-1, n-1) or (i+1, j) == (m-1, n-1)) and cur_grid[-1][-1] >= time:\\n\\t\\t\\t\\t\\tflag = 1\\n\\t\\t\\t\\t\\tres = max(res, min(tmp, cur_grid[-1][-1] - time))\\n\\n\\t\\t\\t\\telse:\\n\\n\\t\\t\\t\\t\\tif j + 1 < n and cur_grid[i][j+1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j + 1, time + 1, min(tmp, cur_grid[i][j+1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif j - 1 > -1 and cur_grid[i][j-1] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i, j - 1, time + 1, min(tmp, cur_grid[i][j-1] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i + 1 < m and cur_grid[i+1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i+1, j, time + 1, min(tmp, cur_grid[i+1][j] - time - 1))\\n\\n\\t\\t\\t\\t\\tif i - 1 > -1 and cur_grid[i-1][j] > time:\\n\\t\\t\\t\\t\\t\\tfunc(cur_grid, i-1, j, time + 1, min(tmp, cur_grid[i-1][j] - time - 1))\\n\\n\\t\\t\\tfunc()\\n\\n\\t\\t\\tif not flag:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\treturn min(10**9, res)   \\n\\t\\t\\t\\nI could have written a general function that determines whether you can go to a given cell based on the given conditions, but got lazy, so ugly repeating fragments, sorry\\nGuess I got lucky on my check, but\\n![image](https://assets.leetcode.com/users/images/d6714c54-f0fc-4bc1-9e01-06082b2ab355_1656777500.7328482.jpeg)\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2186057,
                "title": "c-commented-code-bfs-binary-search",
                "content": "```\\n\\nclass Solution {\\n    int n{0};\\n    int m{0};\\n    vector<vector<int>> fireTime;\\n    vector<int> rowDir, colDir;\\npublic:\\n    Solution(){\\n        rowDir.assign({-1,+0,+1,+0});\\n        colDir.assign({+0,-1,+0,+1});\\n    }\\n    // check if cell indices are valid\\n    bool isValid(int nx, int ny, vector<vector<int>>& grid){\\n        if(nx<0 || nx>=n || ny<0 || ny>=m || grid[nx][ny]==2){\\n            return false;\\n        }\\n        return true;\\n    }\\n    // spread fire and compute time\\n    void spreadFire(vector<vector<int>>& grid){\\n        queue<pair<int,int>> gridCells;\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] == 1){// store cells which are initially on fire\\n                    gridCells.push({i, j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n        // bfs - compute fire spreading time\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                // adjacent cell have greater fire time update to smaller reachable time\\n                if(fireTime[nx][ny] > fireTime[x][y]+1){\\n                    fireTime[nx][ny] = fireTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minTimeToReachEnd(int waitTime, vector<vector<int>>& grid){ // wait time is the time person can wait at initial position\\n        vector<vector<int>> personTime(n, vector<int>(m, INT_MAX));\\n        personTime[0][0] = waitTime;\\n        \\n        queue<pair<int,int>> gridCells;\\n        gridCells.push({0, 0});\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                int currMin = min(personTime[nx][ny], personTime[x][y]+1);\\n                \\n                if(nx==n-1 && ny==m-1 && currMin <= fireTime[n-1][m-1]){ // if we reached safe house and person time is valid\\n                    return currMin;\\n                }\\n                if(currMin >= fireTime[nx][ny]){ // adjacent cell fire time is greater and person time, then person will die\\n                    continue;\\n                }\\n                \\n                if(personTime[nx][ny] > personTime[x][y]+1){\\n                    personTime[nx][ny] = personTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n                 \\n            }\\n        }\\n        return INT_MAX;\\n    }\\n    \\n    int computeMaxWaitingTime(vector<vector<int>>& grid){\\n        // edge case:\\n        // if fire cannot reach safe house, then we have two possibilities\\n        // fire cannot spread to the path from grid(0,0) --> grid(n-1)(m-1), path exist, so answer == INFINITE\\n        // or fire can spread to person\\'s path but road is blocked to reach destination, path doesnt exist, so answer is -1, i.e not reachable\\n        if(fireTime[n-1][m-1] == INT_MAX){\\n           return (minTimeToReachEnd(0, grid) < INT_MAX ? 1000000000 : -1);\\n        }\\n        \\n        // compute maxWait time for fire reachable to safe house\\n        int low = 0;\\n        int high = n*m;\\n        int maxWait = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool isReachable = minTimeToReachEnd(mid, grid) <= fireTime[n-1][m-1];\\n            if(isReachable){\\n                low = mid + 1;\\n                maxWait = mid;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return maxWait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        fireTime.resize(300, vector<int>(300, INT_MAX));\\n        spreadFire(grid);\\n        \\n        return computeMaxWaitingTime(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n    int n{0};\\n    int m{0};\\n    vector<vector<int>> fireTime;\\n    vector<int> rowDir, colDir;\\npublic:\\n    Solution(){\\n        rowDir.assign({-1,+0,+1,+0});\\n        colDir.assign({+0,-1,+0,+1});\\n    }\\n    // check if cell indices are valid\\n    bool isValid(int nx, int ny, vector<vector<int>>& grid){\\n        if(nx<0 || nx>=n || ny<0 || ny>=m || grid[nx][ny]==2){\\n            return false;\\n        }\\n        return true;\\n    }\\n    // spread fire and compute time\\n    void spreadFire(vector<vector<int>>& grid){\\n        queue<pair<int,int>> gridCells;\\n        \\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j] == 1){// store cells which are initially on fire\\n                    gridCells.push({i, j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n        // bfs - compute fire spreading time\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                // adjacent cell have greater fire time update to smaller reachable time\\n                if(fireTime[nx][ny] > fireTime[x][y]+1){\\n                    fireTime[nx][ny] = fireTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n            }\\n        }\\n    }\\n    \\n    int minTimeToReachEnd(int waitTime, vector<vector<int>>& grid){ // wait time is the time person can wait at initial position\\n        vector<vector<int>> personTime(n, vector<int>(m, INT_MAX));\\n        personTime[0][0] = waitTime;\\n        \\n        queue<pair<int,int>> gridCells;\\n        gridCells.push({0, 0});\\n        while(!gridCells.empty()){\\n            auto curr = gridCells.front(); gridCells.pop();\\n            int x = curr.first;\\n            int y = curr.second;\\n            \\n            for(int i=0; i<4; ++i){// explore 4-adjacent cells\\n                int nx = x + rowDir[i];\\n                int ny = y + colDir[i];\\n                if(isValid(nx, ny, grid) == false){\\n                    continue;\\n                }\\n                int currMin = min(personTime[nx][ny], personTime[x][y]+1);\\n                \\n                if(nx==n-1 && ny==m-1 && currMin <= fireTime[n-1][m-1]){ // if we reached safe house and person time is valid\\n                    return currMin;\\n                }\\n                if(currMin >= fireTime[nx][ny]){ // adjacent cell fire time is greater and person time, then person will die\\n                    continue;\\n                }\\n                \\n                if(personTime[nx][ny] > personTime[x][y]+1){\\n                    personTime[nx][ny] = personTime[x][y]+1;\\n                    gridCells.push({nx, ny});\\n                }\\n                 \\n            }\\n        }\\n        return INT_MAX;\\n    }\\n    \\n    int computeMaxWaitingTime(vector<vector<int>>& grid){\\n        // edge case:\\n        // if fire cannot reach safe house, then we have two possibilities\\n        // fire cannot spread to the path from grid(0,0) --> grid(n-1)(m-1), path exist, so answer == INFINITE\\n        // or fire can spread to person\\'s path but road is blocked to reach destination, path doesnt exist, so answer is -1, i.e not reachable\\n        if(fireTime[n-1][m-1] == INT_MAX){\\n           return (minTimeToReachEnd(0, grid) < INT_MAX ? 1000000000 : -1);\\n        }\\n        \\n        // compute maxWait time for fire reachable to safe house\\n        int low = 0;\\n        int high = n*m;\\n        int maxWait = -1;\\n        \\n        while(low <= high){\\n            int mid = low + (high-low)/2;\\n            bool isReachable = minTimeToReachEnd(mid, grid) <= fireTime[n-1][m-1];\\n            if(isReachable){\\n                low = mid + 1;\\n                maxWait = mid;\\n            }else{\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return maxWait;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        fireTime.resize(300, vector<int>(300, INT_MAX));\\n        spreadFire(grid);\\n        \\n        return computeMaxWaitingTime(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049955,
                "title": "python-simple-bfs-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        h,l=10**9,0\\n        dist=[[sys.maxsize]*n for _ in range(m)]   #shortest time at which block (i,j) is burnt\\n        directions=[(0,1),(1,0),(-1,0),(0,-1)]\\n        q=collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dist[i][j]=0\\n                    q.append((i,j,0))\\n        while q:\\n            i,j,val=q.popleft()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==0 and dist[ni][nj]>val+1:\\n                    dist[ni][nj]=val+1\\n                    q.append((ni,nj,val+1))\\n        def solve(tar):\\n            if tar>=dist[0][0]:\\n                return False\\n            dq=collections.deque()\\n            dq.append((0,0,tar))\\n            visited=[[0]*n for _ in range(m)]\\n            while dq:\\n                i,j,val=dq.popleft()\\n                for di,dj in directions:\\n                    ni,nj=i+di,j+dj\\n                    if ni==m-1 and nj==n-1 and val+1<=dist[ni][nj]:  #equal to coz of special case mentioned in question\\n                        return True\\n                    if 0<=ni<m and 0<=nj<n and grid[ni][nj]!=2 and not visited[ni][nj] and val+1<dist[ni][nj]:\\n                        dq.append((ni,nj,val+1))\\n                        visited[ni][nj]=1\\n            return False\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return -1 if not solve(0) else h\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        h,l=10**9,0\\n        dist=[[sys.maxsize]*n for _ in range(m)]   #shortest time at which block (i,j) is burnt\\n        directions=[(0,1),(1,0),(-1,0),(0,-1)]\\n        q=collections.deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    dist[i][j]=0\\n                    q.append((i,j,0))\\n        while q:\\n            i,j,val=q.popleft()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==0 and dist[ni][nj]>val+1:\\n                    dist[ni][nj]=val+1\\n                    q.append((ni,nj,val+1))\\n        def solve(tar):\\n            if tar>=dist[0][0]:\\n                return False\\n            dq=collections.deque()\\n            dq.append((0,0,tar))\\n            visited=[[0]*n for _ in range(m)]\\n            while dq:\\n                i,j,val=dq.popleft()\\n                for di,dj in directions:\\n                    ni,nj=i+di,j+dj\\n                    if ni==m-1 and nj==n-1 and val+1<=dist[ni][nj]:  #equal to coz of special case mentioned in question\\n                        return True\\n                    if 0<=ni<m and 0<=nj<n and grid[ni][nj]!=2 and not visited[ni][nj] and val+1<dist[ni][nj]:\\n                        dq.append((ni,nj,val+1))\\n                        visited[ni][nj]=1\\n            return False\\n        while l<h:\\n            mid=l+(h-l+1)//2\\n            if solve(mid):\\n                l=mid\\n            else:\\n                h=mid-1\\n        return -1 if not solve(0) else h\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036105,
                "title": "c-2-bfs-solution",
                "content": "```\\nclass Node{\\npublic:\\n    int x, y;\\n    Node(int x, int y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int x, int y, int rows, int cols){\\n        if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;\\n        return 1;\\n    }\\n    \\n    void bfs(queue<Node> &bfsQ, vector<vector<int>> &time, vector<vector<int>>& grid){\\n        int rows = grid.size(), cols = grid[0].size();\\n        int level = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        while(!bfsQ.empty()){\\n            int qSize = bfsQ.size();\\n            while(qSize--){\\n                Node curr = bfsQ.front();\\n                bfsQ.pop();\\n                int x = curr.x, y = curr.y;\\n                if(time[x][y] == -1){\\n                    time[x][y] = level;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int nx = x + dir[k][0];\\n                    int ny = y + dir[k][1];\\n                    if(isPossible(nx, ny, rows, cols) and grid[nx][ny] == 0 and time[nx][ny] == -1){\\n                        bfsQ.push(Node(nx, ny));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        queue<Node> bfsQ;\\n        bfsQ.push(Node(0,0));\\n        vector<vector<int>> timePerson(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timePerson, grid);\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if(grid[i][j] == 1) bfsQ.push(Node(i, j));\\n            }\\n        }\\n        vector<vector<int>> timeFire(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timeFire, grid);\\n        int timeForPersonToReach = timePerson[rows - 1][cols - 1];\\n        int timeForFireToReach = timeFire[rows - 1][cols - 1];\\n        if(timeForPersonToReach == -1) return -1; \\n        if(timeForFireToReach == -1) return 1e9;\\n        if(timeForPersonToReach > timeForFireToReach) return -1;\\n        int differenceInArrival = timeForFireToReach - timeForPersonToReach;\\n        int diffFromLeft =  timeFire[rows - 1][cols - 2] - timePerson[rows - 1][cols - 2];\\n        int diffFromRight = timeFire[rows - 2][cols - 1] - timePerson[rows - 2][cols - 1];\\n        if(timePerson[rows - 1][cols - 2] != -1 and timePerson[rows - 2][cols - 1] != -1 and diffFromLeft > differenceInArrival or diffFromRight > differenceInArrival){\\n            return differenceInArrival;\\n        }\\n        return differenceInArrival - 1;\\n    }\\n};\\n```\\nTC: O(rows * cols)\\nSC: O(rows * cols)",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    int x, y;\\n    Node(int x, int y){\\n        this->x = x;\\n        this->y = y;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    bool isPossible(int x, int y, int rows, int cols){\\n        if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;\\n        return 1;\\n    }\\n    \\n    void bfs(queue<Node> &bfsQ, vector<vector<int>> &time, vector<vector<int>>& grid){\\n        int rows = grid.size(), cols = grid[0].size();\\n        int level = 0;\\n        int dir[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n        while(!bfsQ.empty()){\\n            int qSize = bfsQ.size();\\n            while(qSize--){\\n                Node curr = bfsQ.front();\\n                bfsQ.pop();\\n                int x = curr.x, y = curr.y;\\n                if(time[x][y] == -1){\\n                    time[x][y] = level;\\n                }\\n                for(int k = 0; k < 4; k++){\\n                    int nx = x + dir[k][0];\\n                    int ny = y + dir[k][1];\\n                    if(isPossible(nx, ny, rows, cols) and grid[nx][ny] == 0 and time[nx][ny] == -1){\\n                        bfsQ.push(Node(nx, ny));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        queue<Node> bfsQ;\\n        bfsQ.push(Node(0,0));\\n        vector<vector<int>> timePerson(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timePerson, grid);\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                if(grid[i][j] == 1) bfsQ.push(Node(i, j));\\n            }\\n        }\\n        vector<vector<int>> timeFire(rows, vector<int>(cols, -1));\\n        bfs(bfsQ, timeFire, grid);\\n        int timeForPersonToReach = timePerson[rows - 1][cols - 1];\\n        int timeForFireToReach = timeFire[rows - 1][cols - 1];\\n        if(timeForPersonToReach == -1) return -1; \\n        if(timeForFireToReach == -1) return 1e9;\\n        if(timeForPersonToReach > timeForFireToReach) return -1;\\n        int differenceInArrival = timeForFireToReach - timeForPersonToReach;\\n        int diffFromLeft =  timeFire[rows - 1][cols - 2] - timePerson[rows - 1][cols - 2];\\n        int diffFromRight = timeFire[rows - 2][cols - 1] - timePerson[rows - 2][cols - 1];\\n        if(timePerson[rows - 1][cols - 2] != -1 and timePerson[rows - 2][cols - 1] != -1 and diffFromLeft > differenceInArrival or diffFromRight > differenceInArrival){\\n            return differenceInArrival;\\n        }\\n        return differenceInArrival - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010299,
                "title": "c-bfs-dijkstra",
                "content": "\\n```cpp\\nclass Solution {\\n  public:\\n    int maximumMinutes(vector<vector<int>> &g) {\\n        this->grid = move(g);\\n\\n        m = grid.size();\\n        n = grid[0].size();\\n        queue<array<int, 2>> q;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    fire[i][j] = 1e9;\\n                }\\n            }\\n        }\\n\\n        while (not q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny) and fire[nx][ny] == 1e9) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        memset(late, -1, sizeof late);\\n        late[m - 1][n - 1] = fire[m - 1][n - 1];\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({late[m - 1][n - 1], m - 1, n - 1});\\n\\n        while (not pq.empty()) {\\n            auto [d, x, y] = pq.top();\\n            pq.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny)) {\\n                    int nd = pre(min(d, fire[nx][ny]));\\n                    if (late[nx][ny] < nd) {\\n                        late[nx][ny] = nd;\\n                        pq.push({nd, nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return late[0][0];\\n    }\\n\\n  private:\\n    int m;\\n    int n;\\n\\n    int fire[305][305];\\n    int late[305][305];\\n    vector<vector<int>> grid;\\n\\n    const int dx[4] = {0, 0, 1, -1};\\n    const int dy[4] = {1, -1, 0, 0};\\n\\n    inline bool is_vaild(int &x, int &y) {\\n        if (x >= 0 and x < m and y >= 0 and y < n) {\\n            return grid[x][y] != 2;\\n        }\\n        return false;\\n    }\\n\\n    inline int pre(int x) { return x == 1e9 ? x : x - 1; }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n  public:\\n    int maximumMinutes(vector<vector<int>> &g) {\\n        this->grid = move(g);\\n\\n        m = grid.size();\\n        n = grid[0].size();\\n        queue<array<int, 2>> q;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    fire[i][j] = 1e9;\\n                }\\n            }\\n        }\\n\\n        while (not q.empty()) {\\n            auto [x, y] = q.front();\\n            q.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny) and fire[nx][ny] == 1e9) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    q.push({nx, ny});\\n                }\\n            }\\n        }\\n\\n        memset(late, -1, sizeof late);\\n        late[m - 1][n - 1] = fire[m - 1][n - 1];\\n\\n        priority_queue<array<int, 3>> pq;\\n        pq.push({late[m - 1][n - 1], m - 1, n - 1});\\n\\n        while (not pq.empty()) {\\n            auto [d, x, y] = pq.top();\\n            pq.pop();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n\\n                if (is_vaild(nx, ny)) {\\n                    int nd = pre(min(d, fire[nx][ny]));\\n                    if (late[nx][ny] < nd) {\\n                        late[nx][ny] = nd;\\n                        pq.push({nd, nx, ny});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return late[0][0];\\n    }\\n\\n  private:\\n    int m;\\n    int n;\\n\\n    int fire[305][305];\\n    int late[305][305];\\n    vector<vector<int>> grid;\\n\\n    const int dx[4] = {0, 0, 1, -1};\\n    const int dy[4] = {1, -1, 0, 0};\\n\\n    inline bool is_vaild(int &x, int &y) {\\n        if (x >= 0 and x < m and y >= 0 and y < n) {\\n            return grid[x][y] != 2;\\n        }\\n        return false;\\n    }\\n\\n    inline int pre(int x) { return x == 1e9 ? x : x - 1; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998016,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n    void find(vector<vector<int>>&mat,vector<vector<int>>&dis)\\n    {\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    dis[i][j]=0;\\n                }\\n                if(mat[i][j]==2)\\n                {\\n                    dis[i][j]=-1;\\n                }\\n            }\\n        }\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==INT_MAX&&mat[nx][ny]==0)\\n                    {\\n                        dis[nx][ny]=level;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    bool check(vector<vector<int>>&dis,int mid)\\n    {\\n        queue<vector<int>>q;\\n        q.push({0,0,mid});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp[0];\\n            int y=temp[1];\\n            int cost=temp[2];\\n            vis[x][y]=1;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return true;\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]!=-1&&!vis[nx][ny]&&(cost+1<dis[nx][ny]||(nx==n-1&&ny==m-1&&cost+1<=dis[nx][ny])))\\n                {\\n                    q.push({nx,ny,cost+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>&mat) \\n    {\\n         n=mat.size();\\n         m=mat[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        find(mat,dis);\\n        int l=0;\\n        int r=1e9;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(dis,mid))\\n            {\\n                l=mid+1;\\n                ans=mid;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n    void find(vector<vector<int>>&mat,vector<vector<int>>&dis)\\n    {\\n        queue<pair<int,int>>q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    q.push({i,j});\\n                    dis[i][j]=0;\\n                }\\n                if(mat[i][j]==2)\\n                {\\n                    dis[i][j]=-1;\\n                }\\n            }\\n        }\\n        int level=1;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]==INT_MAX&&mat[nx][ny]==0)\\n                    {\\n                        dis[nx][ny]=level;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n    }\\n    bool check(vector<vector<int>>&dis,int mid)\\n    {\\n        queue<vector<int>>q;\\n        q.push({0,0,mid});\\n        int vis[n][m];\\n        memset(vis,0,sizeof(vis));\\n        while(q.size())\\n        {\\n            auto temp=q.front();\\n            q.pop();\\n            int x=temp[0];\\n            int y=temp[1];\\n            int cost=temp[2];\\n            vis[x][y]=1;\\n            if(x==n-1&&y==m-1)\\n            {\\n                return true;\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dis[nx][ny]!=-1&&!vis[nx][ny]&&(cost+1<dis[nx][ny]||(nx==n-1&&ny==m-1&&cost+1<=dis[nx][ny])))\\n                {\\n                    q.push({nx,ny,cost+1});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>&mat) \\n    {\\n         n=mat.size();\\n         m=mat[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        find(mat,dis);\\n        int l=0;\\n        int r=1e9;\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(check(dis,mid))\\n            {\\n                l=mid+1;\\n                ans=mid;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995149,
                "title": "java-binary-search-bfs-dfs",
                "content": "Assume the question says that you have to wait **n** minutes before starting, and we want to find if there is a solution or not. How do you solve this question ? \\n\\nThe main problem is, how can we know when will the fire reach the cell that I am on ?\\n\\nFor this issue we can do BFS, starting from each initial fire cell, expand to all neighboring cells, each cell we move the fire to we **save the time that it took us to reach to it**, since we are doing BFS we gurantee that its the minimum time.\\n\\nfor simplicity, we can change the way the grid looks by making -1 = wall  and any value above 0 is the time it take for the fire to reach this cell.\\n\\nNow that we know when will the fire reach each cell, we can do DFS to know if there is a solution, assuming that my start the time is **n**, each time we go to a nieghbor in the DFS we increase time by 1, if a fire reach a cell at the same time as us or before us then we don\\'t have a solution in this path. \\n\\n**Edge case** if we reach the end (house) and the fire reached this cell at the same time as us we are safe.\\n\\nNow we know that for a given **n** minutes wait, we can find if there is a solution or not.\\n\\nif waiting **n** minutes works then definitely waiting less minutes also works, \\n\\nif waiting **n** minutes does not work then definitely waiting more minutes will not work.\\n\\nThe question asks for a the maximum minutes we can wait, so we can do binary search on the **n** we want to wait for, starting from 0 and ending with 10^9\\n\\n\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n    \\n\\t\\tint[] dx = new int[]{0,1,0,-1};\\n\\t\\tint[] dy = new int[]{1,0,-1,0};\\n\\n\\t\\tpublic int maximumMinutes(int[][] grid) {\\n\\n\\t\\t\\tint result = -1;\\n\\t\\t\\t//start is 0 max is 10^9\\n\\t\\t\\tint start = 0;\\n\\t\\t\\tint end = 1000000000;\\n\\n\\t\\t\\t//binary search on minutes to wait\\n\\t\\t\\twhile(start <= end){\\n\\n\\t\\t\\t\\t//waitmintues is mid \\n\\t\\t\\t\\tint waitMinutes =  start + (end - start)/2;\\n\\n\\t\\t\\t\\t//add to queue fire \\n\\t\\t\\t\\tDeque<int[]> q = new ArrayDeque<>();\\n\\t\\t\\t\\tint[][] temp = new int[grid.length][grid[0].length];\\n\\n\\t\\t\\t\\t//clone the grid so we don\\'t change by reference\\n\\t\\t\\t\\tfor(int i=0 ; i < grid.length ; i++){\\n\\t\\t\\t\\t\\ttemp[i] = grid[i].clone();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//add all fire start to q \\n\\t\\t\\t\\t//make wall == -1 and fire = 1 so we can track fire later-on\\n\\t\\t\\t\\taddFireToQ(q, temp);\\n\\n\\t\\t\\t\\t//using bfs get the time that the fire will reach each cell\\n\\t\\t\\t\\texpandFire(temp,q);\\n\\n\\t\\t\\t\\t//use dfs to find if there is a path from start to finish \\n\\t\\t\\t\\t//taking in consideration that the start point have wait time waitMinutes\\n\\t\\t\\t\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\t\\t\\t\\tif(findPath(temp,0,0,visited,waitMinutes)){\\n\\t\\t\\t\\t\\t//if we found one that work, try bigger time -> binary search\\n\\t\\t\\t\\t\\tresult = waitMinutes;\\n\\t\\t\\t\\t\\tstart = waitMinutes+1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tend = waitMinutes-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tprivate void addFireToQ(Deque<int[]> q, int[][] temp){\\n\\t\\t\\tfor(int i=0 ; i < temp.length ; i++){\\n\\t\\t\\t\\tfor(int j=0 ; j < temp[0].length ; j++){\\n\\t\\t\\t\\t\\tif(temp[i][j] == 1){\\n\\t\\t\\t\\t\\t\\ttemp[i][j] = 0;\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t\\t\\t\\t\\t}else if(temp[i][j] == 2){\\n\\t\\t\\t\\t\\t\\ttemp[i][j] = -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate void expandFire(int[][] temp, Deque<int[]> q){\\n\\t\\t\\tint minutes = 0;\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\tfor(int i=0 ; i < size ; i++){\\n\\t\\t\\t\\t\\tint[] current = q.poll();\\n\\t\\t\\t\\t\\ttemp[current[0]][current[1]] = minutes;\\n\\t\\t\\t\\t\\tfor(int k=0 ; k < 4 ; k++){\\n\\t\\t\\t\\t\\t\\tint x = current[0] + dx[k];\\n\\t\\t\\t\\t\\t\\tint y = current[1] + dy[k];\\n\\t\\t\\t\\t\\t\\tif(x < 0 || x >= temp.length || y < 0 || y >= temp[x].length || temp[x][y] == -1 || temp[x][y] > 0){\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tq.add(new int[]{x,y});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tminutes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate boolean findPath(int[][] grid, int i, int j, boolean[][] visited, int currentTime){\\n\\n\\t\\t\\t//if out of bound or visited false\\n\\t\\t\\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] == -1 || visited[i][j]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//if i fire reached the grid before person at any grid except finish point then false\\n\\t\\t\\tif(grid[i][j] <= currentTime && grid[i][j] != 0 && (i != grid.length-1 || j != grid[0].length-1)){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//we have edge case 1 -> we reach end at the same time as fire -> true \\n\\t\\t\\tif(i == grid.length-1 && j == grid[0].length-1 && (grid[i][j] >= currentTime || grid[i][j] == 0))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tboolean result = false;\\n\\t\\t\\tvisited[i][j]  = true;\\n\\t\\t\\tfor(int k=0 ; k < 4 ; k++){\\n\\t\\t\\t\\tint x = i + dx[k];\\n\\t\\t\\t\\tint y = j + dy[k];\\n\\t\\t\\t\\tif(!result)\\n\\t\\t\\t\\t\\tresult |= findPath(grid,x,y,visited, currentTime+1);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n\\t\\tint[] dx = new int[]{0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 4063011,
                "title": "c-jayash-s-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int t,vector<vector<int>>& vis,vector<vector<int>>& dis){\\n        if(i==vis.size()-1 && j==vis[0].size()-1) return 1;\\n        if(dis[i][j]==t) return 0;\\n        int dx[]={0,0,1,-1};\\n        int dy[]={1,-1,0,0};\\n        vis[i][j]=t;\\n        for(int k=0;k<4;k++){\\n            int nx=dx[k]+i,ny=dy[k]+j;\\n            if(nx<0 || ny<0 || nx>=vis.size() || ny>=vis[0].size()) continue;\\n            if(vis[nx][ny]>t+1 && dis[nx][ny]>=t+1 && dfs(nx,ny,t+1,vis,dis)) return 1;\\n        }\\n        return 0;\\n    }\\n    int chk(int tm,vector<vector<int>>& a){\\n        queue<vector<int>> q;\\n        vector<vector<int>> dis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        vector<vector<int>> vis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<a[0].size();j++){\\n                if(a[i][j]==1) q.push({i,j,0}),dis[i][j]=0;\\n                else if(a[i][j]==2) dis[i][j]=-1;\\n            }\\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int cx=q.front()[0],cy=q.front()[1],t=q.front()[2];q.pop();\\n                int dx[]={0,0,1,-1};\\n                int dy[]={1,-1,0,0};\\n                for(int j=0;j<4;j++){\\n                    int nx=dx[j]+cx,ny=dy[j]+cy;\\n                    if(nx<0 || ny<0 || nx>=a.size() || ny>=a[0].size() || dis[nx][ny]<=t+1) continue;\\n                    q.push({nx,ny,t+1});\\n                    dis[nx][ny]=1+t;\\n                }\\n            }\\n        }\\n        return dfs(0,0,tm,vis,dis);\\n    }\\n    int maximumMinutes(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        int l=-1,r=n*m+100,ans=-1;\\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            if(chk(m,a)) ans=m,l=m;\\n            else r=m;\\n        }\\n        if(ans>=n*m) return 1000000000;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i,int j,int t,vector<vector<int>>& vis,vector<vector<int>>& dis){\\n        if(i==vis.size()-1 && j==vis[0].size()-1) return 1;\\n        if(dis[i][j]==t) return 0;\\n        int dx[]={0,0,1,-1};\\n        int dy[]={1,-1,0,0};\\n        vis[i][j]=t;\\n        for(int k=0;k<4;k++){\\n            int nx=dx[k]+i,ny=dy[k]+j;\\n            if(nx<0 || ny<0 || nx>=vis.size() || ny>=vis[0].size()) continue;\\n            if(vis[nx][ny]>t+1 && dis[nx][ny]>=t+1 && dfs(nx,ny,t+1,vis,dis)) return 1;\\n        }\\n        return 0;\\n    }\\n    int chk(int tm,vector<vector<int>>& a){\\n        queue<vector<int>> q;\\n        vector<vector<int>> dis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        vector<vector<int>> vis(a.size(),vector<int> (a[0].size(),INT_MAX));\\n        for(int i=0;i<a.size();i++){\\n            for(int j=0;j<a[0].size();j++){\\n                if(a[i][j]==1) q.push({i,j,0}),dis[i][j]=0;\\n                else if(a[i][j]==2) dis[i][j]=-1;\\n            }\\n        }\\n        while(q.size()){\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                int cx=q.front()[0],cy=q.front()[1],t=q.front()[2];q.pop();\\n                int dx[]={0,0,1,-1};\\n                int dy[]={1,-1,0,0};\\n                for(int j=0;j<4;j++){\\n                    int nx=dx[j]+cx,ny=dy[j]+cy;\\n                    if(nx<0 || ny<0 || nx>=a.size() || ny>=a[0].size() || dis[nx][ny]<=t+1) continue;\\n                    q.push({nx,ny,t+1});\\n                    dis[nx][ny]=1+t;\\n                }\\n            }\\n        }\\n        return dfs(0,0,tm,vis,dis);\\n    }\\n    int maximumMinutes(vector<vector<int>>& a) {\\n        int n=a.size(),m=a[0].size();\\n        int l=-1,r=n*m+100,ans=-1;\\n        while(r-l>1){\\n            int m=l+(r-l)/2;\\n            if(chk(m,a)) ans=m,l=m;\\n            else r=m;\\n        }\\n        if(ans>=n*m) return 1000000000;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917558,
                "title": "c-bfs-binary-search",
                "content": "# Code\\n```\\npublic class Solution {\\n    int[] dir_x = {1, -1, 0, 0}, dir_y = {0, 0, 1, -1};\\n    public int MaximumMinutes(int[][] grid) {\\n        int l = 0, r = (int)1e9 + 1;\\n        while(l < r){\\n            int mid = l + r >> 1;\\n            if(!Escape(grid, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        if(!Escape(grid, 0)) return -1;\\n        if(Escape(grid, (int)1e9)) return (int)1e9;\\n        return l - 1;\\n    }\\n\\n    public bool Escape(int[][] grid, int mins){\\n        int n = grid.Length, m = grid[0].Length;\\n        int[][] map = new int[n][];\\n        for(int i = 0; i < n; i++){\\n            map[i] = new int[m];\\n            for(int j = 0; j < m; j++)\\n                map[i][j] = grid[i][j];\\n        }\\n\\n        Queue<int[]> q1 = new(), q2 = new();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(map[i][j] == 1)\\n                    q1.Enqueue(new int[]{i, j});\\n            }\\n        }\\n\\n        if(mins != 0){\\n            while(q1.Count > 0 && mins-- > 0){\\n                int size = q1.Count;\\n                while(size-- != 0){\\n                    var p = q1.Dequeue();\\n                    int x = p[0], y = p[1];\\n                    if(x == 0 && y == 0)\\n                        return false;\\n                    for(int i = 0; i < 4; i++){\\n                        int dx = x + dir_x[i], dy = y + dir_y[i];\\n                        if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                            continue;\\n                        if(map[dx][dy] == 0){\\n                            map[dx][dy] = 1;\\n                            q1.Enqueue(new int[]{dx, dy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        q2.Enqueue(new int[]{0, 0});\\n        map[0][0] = -1;\\n        while(q1.Count > 0 && q2.Count > 0){\\n            int size1 = q1.Count, size2 = q2.Count;\\n            while(size2-- != 0){\\n                var p = q2.Dequeue();\\n                int x = p[0], y = p[1];\\n            \\n                if(map[n - 1][m - 1] == -1) \\n                    return true;\\n                if(map[x][y] == 1) continue;\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] != 0) continue;\\n                    if(dx == n - 1 && dy == m - 1)\\n                        return true;\\n                    map[dx][dy] = -1;\\n                    q2.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n\\n            while(size1-- != 0){\\n                var p = q1.Dequeue();\\n                int x = p[0], y = p[1];\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] == 1 || map[dx][dy] == 2) continue; \\n                    map[dx][dy] = 1;\\n                    q1.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n        }\\n\\n        while(q2.Count > 0 && map[n - 1][m - 1] != -1){\\n            var p = q2.Dequeue();\\n            int x = p[0], y = p[1];\\n            for(int i = 0; i < 4; i++){\\n                int dx = x + dir_x[i], dy = y + dir_y[i];\\n                if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                    continue;\\n                if(map[dx][dy] != 0) continue;\\n                map[dx][dy] = -1;\\n                if(map[n - 1][m - 1] == -1) return true;\\n                q2.Enqueue(new int[]{dx, dy});\\n            }\\n        }\\n  \\n        if(q1.Count == 0 && map[n - 1][m - 1] == -1)\\n            return true; \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    int[] dir_x = {1, -1, 0, 0}, dir_y = {0, 0, 1, -1};\\n    public int MaximumMinutes(int[][] grid) {\\n        int l = 0, r = (int)1e9 + 1;\\n        while(l < r){\\n            int mid = l + r >> 1;\\n            if(!Escape(grid, mid))\\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        if(!Escape(grid, 0)) return -1;\\n        if(Escape(grid, (int)1e9)) return (int)1e9;\\n        return l - 1;\\n    }\\n\\n    public bool Escape(int[][] grid, int mins){\\n        int n = grid.Length, m = grid[0].Length;\\n        int[][] map = new int[n][];\\n        for(int i = 0; i < n; i++){\\n            map[i] = new int[m];\\n            for(int j = 0; j < m; j++)\\n                map[i][j] = grid[i][j];\\n        }\\n\\n        Queue<int[]> q1 = new(), q2 = new();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(map[i][j] == 1)\\n                    q1.Enqueue(new int[]{i, j});\\n            }\\n        }\\n\\n        if(mins != 0){\\n            while(q1.Count > 0 && mins-- > 0){\\n                int size = q1.Count;\\n                while(size-- != 0){\\n                    var p = q1.Dequeue();\\n                    int x = p[0], y = p[1];\\n                    if(x == 0 && y == 0)\\n                        return false;\\n                    for(int i = 0; i < 4; i++){\\n                        int dx = x + dir_x[i], dy = y + dir_y[i];\\n                        if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                            continue;\\n                        if(map[dx][dy] == 0){\\n                            map[dx][dy] = 1;\\n                            q1.Enqueue(new int[]{dx, dy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        q2.Enqueue(new int[]{0, 0});\\n        map[0][0] = -1;\\n        while(q1.Count > 0 && q2.Count > 0){\\n            int size1 = q1.Count, size2 = q2.Count;\\n            while(size2-- != 0){\\n                var p = q2.Dequeue();\\n                int x = p[0], y = p[1];\\n            \\n                if(map[n - 1][m - 1] == -1) \\n                    return true;\\n                if(map[x][y] == 1) continue;\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] != 0) continue;\\n                    if(dx == n - 1 && dy == m - 1)\\n                        return true;\\n                    map[dx][dy] = -1;\\n                    q2.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n\\n            while(size1-- != 0){\\n                var p = q1.Dequeue();\\n                int x = p[0], y = p[1];\\n                for(int i = 0; i < 4; i++){\\n                    int dx = x + dir_x[i], dy = y + dir_y[i];\\n                    if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                        continue;\\n                    if(map[dx][dy] == 1 || map[dx][dy] == 2) continue; \\n                    map[dx][dy] = 1;\\n                    q1.Enqueue(new int[]{dx, dy});\\n                }\\n            }\\n        }\\n\\n        while(q2.Count > 0 && map[n - 1][m - 1] != -1){\\n            var p = q2.Dequeue();\\n            int x = p[0], y = p[1];\\n            for(int i = 0; i < 4; i++){\\n                int dx = x + dir_x[i], dy = y + dir_y[i];\\n                if(dx < 0 || dy < 0 || dx >= n || dy >= m)\\n                    continue;\\n                if(map[dx][dy] != 0) continue;\\n                map[dx][dy] = -1;\\n                if(map[n - 1][m - 1] == -1) return true;\\n                q2.Enqueue(new int[]{dx, dy});\\n            }\\n        }\\n  \\n        if(q1.Count == 0 && map[n - 1][m - 1] == -1)\\n            return true; \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653210,
                "title": "96-faster-java-sol-no-bs-required-edge-cases-explained-double-bfs-method",
                "content": "//two bfs method\\n\\n    class Solution {\\n    int m,n;\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        m=grid.length;\\n        n=grid[0].length;\\n        int [][]fire = new int[grid.length][grid[0].length];\\n        int [][]people = new int[grid.length][grid[0].length];\\n        bfsFire(fire,grid);\\n        bfsPeople(people,grid);\\n        int firetime = fire[m-1][n-1];\\n        int peopletime = people[m-1][n-1];\\n        //at first check if people can reach or not bot-right \\n         if(peopletime==0)\\n            return -1;\\n        //secondly check if fire can reach or not bot-right\\n        //cuz if we keep the fire reach or not cond above people reach or not cond , then even if the people cannot reach the bot-right cond is true ,  we will be returning \"1e9\" if the fire cannot reach bot-right but duh , people cannot reach there as well so returning -1 is the priority here \\n        if(firetime<0)\\n            return (int)1e9;\\n       \\n        int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n                \\n    }\\n    int dir[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void bfsFire(int[][] fire,int[][] grid){\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        //initilise the queue with fire coordinates\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++){\\n                fire[i][j]=-1;\\n                if(grid[i][j]==1){\\n                    queue.offer(new int[]{i,j});\\n                    fire[i][j]=0;\\n                }\\n                    \\n            }\\n        int min=1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                int coor[] = queue.poll();\\n                int row = coor[0];\\n                int col = coor[1];\\n                for(int i=0;i<4;i++){\\n                    int rowdash = row+dir[i][0];\\n                    int coldash = col+dir[i][1];\\n                    \\n                    if(rowdash<0||rowdash>=m||coldash<0||coldash>=n||fire[rowdash][coldash]>=0\\n                       ||grid[rowdash][coldash]==2)\\n                        continue;\\n                    fire[rowdash][coldash] = min;\\n                    queue.offer(new int[]{rowdash,coldash});\\n                }\\n            }\\n            min++;\\n        }\\n    }\\n      void bfsPeople(int[][] people,int[][] grid){\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        //initilise the queue with people initial coordinate\\n        queue.offer(new int[]{0,0});\\n        int min=1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n               int coor[] = queue.poll();\\n                int row = coor[0];\\n                int col = coor[1];\\n                for(int i=0;i<4;i++){\\n                    int rowdash = row+dir[i][0];\\n                    int coldash = col+dir[i][1];\\n                    \\n                    if(rowdash<0||rowdash>=m||coldash<0||coldash>=n||people[rowdash][coldash]>0\\n                       ||grid[rowdash][coldash]==2)\\n                        continue;\\n                    people[rowdash][coldash] = min;\\n                    queue.offer(new int[]{rowdash,coldash});\\n                }\\n            }\\n            min++;\\n        }\\n    }\\n    }\\n\\t\\nThis is the frustrating edge case. If a person reaches the safehouse, they escape even if the fire spreads to the safehouse in the same minute. So, when the safehouse is the first cell when person and fire cross their paths, we do not subtract one.\\n\\n\\n\\nTo check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one. \\n     \\n\\t    int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    int m,n;\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        m=grid.length;\\n        n=grid[0].length;\\n        int [][]fire = new int[grid.length][grid[0].length];\\n        int [][]people = new int[grid.length][grid[0].length];\\n        bfsFire(fire,grid);\\n        bfsPeople(people,grid);\\n        int firetime = fire[m-1][n-1];\\n        int peopletime = people[m-1][n-1];\\n        //at first check if people can reach or not bot-right \\n         if(peopletime==0)\\n            return -1;\\n        //secondly check if fire can reach or not bot-right\\n        //cuz if we keep the fire reach or not cond above people reach or not cond , then even if the people cannot reach the bot-right cond is true ,  we will be returning \"1e9\" if the fire cannot reach bot-right but duh , people cannot reach there as well so returning -1 is the priority here \\n        if(firetime<0)\\n            return (int)1e9;\\n       \\n        int diff = firetime-peopletime;\\n        if(diff<0)\\n            return -1;\\n        int northdiff = fire[m-2][n-1] - people[m-2][n-1];\\n        int westdiff = fire[m-1][n-2] - people[m-1][n-2];\\n        if(northdiff > diff || westdiff > diff)\\n            return diff;\\n        return diff-1;\\n                \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2472329,
                "title": "python-binary-search-for-minutes-waited-bfs-till-nearest-fire",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        inf = 10 ** 9\\n        n, m = len(grid), len(grid[0])\\n        distances = [[inf] * m for _ in range(n)]\\n\\n        # get neighbors of a cell\\n        def nbs(i, j):\\n            return [(ni, nj) for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != 2]\\n\\n        # calculate distances to the nearest fire using bfs\\n        fires = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1]\\n        q = deque()\\n\\n        for i, j in fires:\\n            distances[i][j] = 0\\n            q.append((i, j, 0))\\n\\n        while len(q):\\n            i, j, d = q.popleft()\\n            for ni, nj in nbs(i, j):\\n                if distances[ni][nj] == inf:\\n                    q.append((ni, nj, d + 1))\\n                    distances[ni][nj] = d + 1\\n\\n        # checks if connected after waiting w minutes\\n        def connected(w):\\n            q.clear()\\n            att = {(0, 0)}\\n            q.append((0, 0, 0))\\n\\n            while len(q):\\n                i, j, d = q.popleft()\\n                if (i, j) == (n - 1, m - 1):\\n                    return True\\n\\n                for ni, nj in nbs(i, j):\\n                    if (ni, nj) in att: continue\\n                    final = 1 if ((ni, nj) == (n - 1, m - 1)) else 0\\n\\n                    if distances[ni][nj] > w + d + 1 - final:\\n                        q.append((ni, nj, d + 1))\\n                        att.add((ni, nj))\\n\\n            return False\\n\\n        big = 2 * (10 ** 4) + 10\\n        l, r = -1, big\\n\\n        # binary search for the most minutes you can wait\\n        while r - l >= 2:\\n            mid = (l + r) // 2\\n            if connected(mid):\\n                l = mid\\n            else:\\n                r = mid\\n\\n        return l if r != big else 10 ** 9\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        inf = 10 ** 9\\n        n, m = len(grid), len(grid[0])\\n        distances = [[inf] * m for _ in range(n)]\\n\\n        # get neighbors of a cell\\n        def nbs(i, j):\\n            return [(ni, nj) for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]\\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] != 2]\\n\\n        # calculate distances to the nearest fire using bfs\\n        fires = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1]\\n        q = deque()\\n\\n        for i, j in fires:\\n            distances[i][j] = 0\\n            q.append((i, j, 0))\\n\\n        while len(q):\\n            i, j, d = q.popleft()\\n            for ni, nj in nbs(i, j):\\n                if distances[ni][nj] == inf:\\n                    q.append((ni, nj, d + 1))\\n                    distances[ni][nj] = d + 1\\n\\n        # checks if connected after waiting w minutes\\n        def connected(w):\\n            q.clear()\\n            att = {(0, 0)}\\n            q.append((0, 0, 0))\\n\\n            while len(q):\\n                i, j, d = q.popleft()\\n                if (i, j) == (n - 1, m - 1):\\n                    return True\\n\\n                for ni, nj in nbs(i, j):\\n                    if (ni, nj) in att: continue\\n                    final = 1 if ((ni, nj) == (n - 1, m - 1)) else 0\\n\\n                    if distances[ni][nj] > w + d + 1 - final:\\n                        q.append((ni, nj, d + 1))\\n                        att.add((ni, nj))\\n\\n            return False\\n\\n        big = 2 * (10 ** 4) + 10\\n        l, r = -1, big\\n\\n        # binary search for the most minutes you can wait\\n        while r - l >= 2:\\n            mid = (l + r) // 2\\n            if connected(mid):\\n                l = mid\\n            else:\\n                r = mid\\n\\n        return l if r != big else 10 ** 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466425,
                "title": "java-bfs-bfs-without-any-bs-pun-intended",
                "content": "This is a great problem. Thanks to [leet_go](https://leetcode.com/leet_go/) for the algorithm and [Bakerston](https://leetcode.com/Bakerston/) for the explanation. Bakerston\\'s explanation is great, however I could not understand one of the edge cases from the wording though I understood it from the examples. I have elaborated a bit on his/her examples.\\n\\nThe maximum time the person can wait before starting a succesful traversal to any point depends on the difference in arrival times of the fire and the person at that point. We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\nThis is because the difference is strictly non-increasing in path and since we want the minimum  difference accross all points, looking at the end will suffice. Example-\\n            \\nConsider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\nNow consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\nThere is a very tricky edge case though. If Fire arrives at the same time as the person in a given location except for the end then all paths through that path become non viable. Example below.\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\nIn the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other cells is an escape location. Imagine that the person just disappears instantly. Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can  wait just one unit.\\n```\\nclass Solution {\\n    int[][] directions = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] fireTimes = new int[m][n];\\n        int[][] personTimes = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(fireTimes[i], -1);\\n            Arrays.fill(personTimes[i], -1);\\n        }\\n        \\n        updateEarliestArrivalTimes(0, 0, personTimes, grid);\\n        // No path for person\\n        if (personTimes[m-1][n-1] == -1) return -1;\\n        \\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 1) updateEarliestArrivalTimes(i, j, fireTimes, grid);\\n            }\\n        }\\n        //No Path for fire\\n        if (fireTimes[m-1][n-1] == -1) return 1000000000;\\n        /**\\n            The maximum time the person can wait before starting a succesful traversal to any point depends\\n            on the difference in arrival times of the fire and the person at that point.\\n            We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\n            This is because the difference is strictly non-increasing in path and since we want the minimum \\n            difference accross all points, looking at the end will suffice. Example-\\n            \\n            Consider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\n            \\n            \\n             Now consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\n            \\n            There is a very tricky edge case though. If Fire arrives earlier at any point in ALL possible paths to the destination,\\n            then we\\'ll lose one waiting unit. Example below-\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\n            In the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. \\n            This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other\\n            cells is an escape location. Imagine that the person just disappears instantly. \\n            Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n            In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will \\n            get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can\\n            wait just one unit.\\n        **/\\n        int diff = fireTimes[m-1][n-1] - personTimes[m-1][n-1];\\n        if (diff < 0) return -1;\\n        \\n        if (fireTimes[m-2][n-1] - personTimes[m-2][n-1] <= diff && fireTimes[m-1][n-2] - personTimes[m-1][n-2] <= diff) return diff-1;\\n        return diff;\\n    }\\n    \\n    public void updateEarliestArrivalTimes(int startRow, int startCol, int[][] arrivalTimes, int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        Deque<int[]> q = new ArrayDeque();\\n        q.add(new int[]{startRow, startCol, 0});\\n        arrivalTimes[startRow][startCol] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] node = q.poll();\\n            int row = node[0], col = node[1], t = node[2];\\n            for (int[] d : directions){\\n                int x = row+d[0], y = col+d[1];\\n                if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && (arrivalTimes[x][y] == -1 || arrivalTimes[x][y] > t+1)){\\n                    arrivalTimes[x][y] = t+1;\\n                    q.offer(new int[]{x, y, t+1});\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] directions = new int[][]{{1,0}, {-1,0}, {0,1}, {0,-1}};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] fireTimes = new int[m][n];\\n        int[][] personTimes = new int[m][n];\\n        \\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(fireTimes[i], -1);\\n            Arrays.fill(personTimes[i], -1);\\n        }\\n        \\n        updateEarliestArrivalTimes(0, 0, personTimes, grid);\\n        // No path for person\\n        if (personTimes[m-1][n-1] == -1) return -1;\\n        \\n        for (int i = 0; i < grid.length; i++){\\n            for (int j = 0; j < grid[0].length; j++){\\n                if (grid[i][j] == 1) updateEarliestArrivalTimes(i, j, fireTimes, grid);\\n            }\\n        }\\n        //No Path for fire\\n        if (fireTimes[m-1][n-1] == -1) return 1000000000;\\n        /**\\n            The maximum time the person can wait before starting a succesful traversal to any point depends\\n            on the difference in arrival times of the fire and the person at that point.\\n            We don\\'t really care about all points on the person\\'s path(leading up to the final point).\\n            This is because the difference is strictly non-increasing in path and since we want the minimum \\n            difference accross all points, looking at the end will suffice. Example-\\n            \\n            Consider the path 3-9 below. The difference in arrival times is constant from the first intersection\\n            \\n            (F)         8--9\\n                           |          \\n            (P)   3--4--5--6(10)--7(11)--8(12)--9(13)\\n                              |\\n                              7(11)--8(12)\\n                              \\n            \\n            \\n             Now consider the case where there is a shorter path for the fire on to 3-9. In this case the difference actuall drops\\n            \\n            (F)         8--9-------------- \\n                           |             |  \\n            (P)   3--4--5--6(10)--7(11)--8(10)--9(11)\\n                              |\\n                              7(11)--8(12)\\n                              \\n           \\n            \\n            There is a very tricky edge case though. If Fire arrives earlier at any point in ALL possible paths to the destination,\\n            then we\\'ll lose one waiting unit. Example below-\\n            \\n            Person              Fire\\n                 10                 8\\n                  9                 9  \\n            6  7  8         12  11  10\\n            In the above case if the person started with a delay of he/she will reach destination at time 10, which is the same as the fire\\'s arrival time. \\n            This is okay since fire spreads after the person moves, the destination is going to be available to the person and the detination unlike other\\n            cells is an escape location. Imagine that the person just disappears instantly. \\n            Note that the person will be in the penultimate position(with fire arrival time 11) at time 9 which is good. The other path doesn\\'t matter.\\n            \\n            Person              Fire\\n                 10                 12\\n                  9                 11  \\n            6  7  8           8  9  10\\n            \\n            In the above case however a wait of 2 is not going to work because the person will be reaching the penultimate position(9) at time 9 and will \\n            get burnt because the fire will arrive before he/she can make the next jump. Same applies to the penultimate position 11. In this case we can\\n            wait just one unit.\\n        **/\\n        int diff = fireTimes[m-1][n-1] - personTimes[m-1][n-1];\\n        if (diff < 0) return -1;\\n        \\n        if (fireTimes[m-2][n-1] - personTimes[m-2][n-1] <= diff && fireTimes[m-1][n-2] - personTimes[m-1][n-2] <= diff) return diff-1;\\n        return diff;\\n    }\\n    \\n    public void updateEarliestArrivalTimes(int startRow, int startCol, int[][] arrivalTimes, int[][] grid){\\n        int m = grid.length, n = grid[0].length;\\n        Deque<int[]> q = new ArrayDeque();\\n        q.add(new int[]{startRow, startCol, 0});\\n        arrivalTimes[startRow][startCol] = 0;\\n        \\n        while(!q.isEmpty()){\\n            int[] node = q.poll();\\n            int row = node[0], col = node[1], t = node[2];\\n            for (int[] d : directions){\\n                int x = row+d[0], y = col+d[1];\\n                if (0 <= x && x < m && 0 <= y && y < n && grid[x][y] == 0 && (arrivalTimes[x][y] == -1 || arrivalTimes[x][y] > t+1)){\\n                    arrivalTimes[x][y] = t+1;\\n                    q.offer(new int[]{x, y, t+1});\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313244,
                "title": "c-code-bfs-dijkstras",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    void djk(int x,int y,int n,int m,vector<vector<int>> &v,vector<vector<int>> &dist,bool flag){\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,greater<pair<int,vector<int>>>> q;\\n        if (flag){\\n             for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (v[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                    \\n                    q.push({0,{x,y}});\\n                    dist[x][y]=0;\\n                }\\n            }\\n        }\\n        }\\n        else{\\n            q.push({0,{0,0}});\\n            dist[0][0]=0;\\n        }\\n        \\n        \\n        while (!q.empty()){\\n          pair<int,vector<int>> p=q.top();\\n          q.pop();\\n            \\n            \\n         for (int i=0; i<4; i++){\\n             int l=p.second[0]+dx[i];\\n             int r=p.second[1]+dy[i];\\n             \\n             if (l>=0 && r>=0 && l<n && r<m && v[l][r]!=2){\\n                 if (dist[l][r]>p.first+1){\\n                     dist[l][r]=p.first+1;\\n                     q.push({dist[l][r],{l,r}});\\n                 }\\n             }\\n         }\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& v) {\\n        int i,j;\\n        int n=v.size(),m=v[0].size();\\n        \\n        vector<vector<int>> fire(n,vector<int> (m,1e9+5)),human(n,vector<int> (m,1e9+5));\\n        \\n       \\n        djk(0,0,v.size(),v[0].size(),v,fire,true);\\n        djk(0,0,v.size(),v[0].size(),v,human,false);\\n        \\n        \\n     \\n     \\n      if(human[n-1][m-1]==1e9+5 || fire[n-1][m-1]<human[n-1][m-1]){\\n            return -1;\\n      }\\n      if(fire[n-1][m-1]==1e9+5){\\n            return 1000000000;\\n      }\\n        \\n      int diff=fire[n-1][m-1]-human[n-1][m-1];\\n      swap(n,m);\\n        \\n       if(m>1 && n>1){\\n            if(human[m-2][n-1]!=1e9+5 && human[m-1][n-2]!=1e9+5 && ((fire[m-2][n-1]-human[m-2][n-1])>diff || (fire[m-1][n-2]-human[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n      return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    \\n    void djk(int x,int y,int n,int m,vector<vector<int>> &v,vector<vector<int>> &dist,bool flag){\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,greater<pair<int,vector<int>>>> q;\\n        if (flag){\\n             for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (v[i][j]==1){\\n                    x=i;\\n                    y=j;\\n                    \\n                    q.push({0,{x,y}});\\n                    dist[x][y]=0;\\n                }\\n            }\\n        }\\n        }\\n        else{\\n            q.push({0,{0,0}});\\n            dist[0][0]=0;\\n        }\\n        \\n        \\n        while (!q.empty()){\\n          pair<int,vector<int>> p=q.top();\\n          q.pop();\\n            \\n            \\n         for (int i=0; i<4; i++){\\n             int l=p.second[0]+dx[i];\\n             int r=p.second[1]+dy[i];\\n             \\n             if (l>=0 && r>=0 && l<n && r<m && v[l][r]!=2){\\n                 if (dist[l][r]>p.first+1){\\n                     dist[l][r]=p.first+1;\\n                     q.push({dist[l][r],{l,r}});\\n                 }\\n             }\\n         }\\n        }\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& v) {\\n        int i,j;\\n        int n=v.size(),m=v[0].size();\\n        \\n        vector<vector<int>> fire(n,vector<int> (m,1e9+5)),human(n,vector<int> (m,1e9+5));\\n        \\n       \\n        djk(0,0,v.size(),v[0].size(),v,fire,true);\\n        djk(0,0,v.size(),v[0].size(),v,human,false);\\n        \\n        \\n     \\n     \\n      if(human[n-1][m-1]==1e9+5 || fire[n-1][m-1]<human[n-1][m-1]){\\n            return -1;\\n      }\\n      if(fire[n-1][m-1]==1e9+5){\\n            return 1000000000;\\n      }\\n        \\n      int diff=fire[n-1][m-1]-human[n-1][m-1];\\n      swap(n,m);\\n        \\n       if(m>1 && n>1){\\n            if(human[m-2][n-1]!=1e9+5 && human[m-1][n-2]!=1e9+5 && ((fire[m-2][n-1]-human[m-2][n-1])>diff || (fire[m-1][n-2]-human[m-1][n-2]>diff))){\\n                return diff;\\n            }\\n        }\\n      return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171813,
                "title": "c-bfs-binary-search-detailed-explanation",
                "content": "\\n        \\n         we use multisource BFS to find the time stamp at which fire arrives at each cell,\\n         t[i][j] represents the time it took for the fire to reach that point\\n         the cells where fire originate is marked at -2, and walls are marked at -1\\n\\n         another thing to note is that, at any cell (other than the safehouse), we should arrive before the fire\\n         means t[i][j] - our_time_of_arrival > 0\\n         and for safehouse t[i][j] - our_time_of_arrival >= 0 (given in the question)\\n\\n\\n\\n         lets say we did not wait at all at the origin, then for each cell, t[i][j] - t0 > 0 (and equal to for safehouse)\\n         but lets say, we wait for k units of time at the origin, then at every cell, we arrive at (k + t0)\\n\\n         so for every cell in the path, t[i][j] - (k + t0) > 0\\n         hence k will be a valid waiting time only when we have a path, such that for every cell (i, j) in that path\\n         t[i][j] - (k + t0) > 0 !(i = m - 1 && j = n - 1)\\n         and t[i][j] - (k + t0) > 0 (i = m - 1 && j = n - 1)\\n\\n         t0 for each cell can easily be found using BFS, and whether or not a cell is good to enter into, can be found by using the above inequality\\n\\n         now how to find the maximum k?\\n        note that if we find a path for a given k (such that the above inequality holds for every cell),\\n        then for every k2 < k, we still find a path, because that inequality will still hold\\n        hence k is monotonic and we can use binary search\\n\\n        for the 1e9 case, we check whether we have a path, where every cell never got burnt, means fire never reached any cell of that path, then we can simply return 1e9\\n        if binary search does not find any k, it will return -1 by default\\n\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n    bool doesNonFirePath(int i, int j, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> visited(rows, vector<bool> (cols, false));\\n        if (t[0][0] != 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        visited[0][0] = true;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            auto [i, j] = q.front(); q.pop();\\n            for (auto d : dirs) {\\n                int ni = i + d[0];\\n                int nj = j + d[1];\\n                if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj] && t[ni][nj] == 0) {\\n                    visited[ni][nj] = true;\\n                    q.push({ni, nj});\\n                    if (ni == rows - 1 && nj == cols - 1) return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n    bool isValid(int mid, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n\\n        if (t[0][0] - mid <= 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); vis[0][0] = true;\\n\\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) return true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] != -1 && t[ni][nj] - (mid + level + 1) > 0 || (ni == rows - 1 && nj == cols - 1 && t[ni][nj] - (mid + level + 1) >= 0)) {\\n                        vis[ni][nj] = true;\\n                        if (ni == rows - 1 && nj == cols - 1) return true;\\n                        q.push({ni, nj});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int rows = g.size();\\n        int cols = g[0].size();\\n\\n        // 0 -> grass, 1 -> fire, 2 -> wall\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n        vector<vector<int>> t(rows, vector<int> (cols, 0));\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (g[i][j] == 2) t[i][j] = -1;\\n                if (g[i][j] == 1) {\\n                    q.push({i, j});\\n                    t[i][j] = -2;\\n                    vis[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        bool fireReached = false; // this variable is useless\\n\\n        \\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) fireReached = true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0  && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] == 0) {\\n                        vis[ni][nj] = true;\\n                        q.push({ni, nj});\\n                        t[ni][nj] = level + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        if (doesNonFirePath(0, 0, t)) return 1e9;\\n\\n\\n\\n        int low = 0, high = rows * cols;\\n        int res = -1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(mid, t)) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n\\n                high = mid - 1;\\n            }\\n        }\\n\\n\\n        return res;\\n\\n\\n\\n    }\\n\\n\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\n    bool doesNonFirePath(int i, int j, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> visited(rows, vector<bool> (cols, false));\\n        if (t[0][0] != 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        visited[0][0] = true;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            auto [i, j] = q.front(); q.pop();\\n            for (auto d : dirs) {\\n                int ni = i + d[0];\\n                int nj = j + d[1];\\n                if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj] && t[ni][nj] == 0) {\\n                    visited[ni][nj] = true;\\n                    q.push({ni, nj});\\n                    if (ni == rows - 1 && nj == cols - 1) return true;\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n\\n    bool isValid(int mid, vector<vector<int>> &t) {\\n        int rows = t.size();\\n        int cols = t[0].size();\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n\\n        if (t[0][0] - mid <= 0) return false;\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); vis[0][0] = true;\\n\\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) return true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] != -1 && t[ni][nj] - (mid + level + 1) > 0 || (ni == rows - 1 && nj == cols - 1 && t[ni][nj] - (mid + level + 1) >= 0)) {\\n                        vis[ni][nj] = true;\\n                        if (ni == rows - 1 && nj == cols - 1) return true;\\n                        q.push({ni, nj});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int rows = g.size();\\n        int cols = g[0].size();\\n\\n        // 0 -> grass, 1 -> fire, 2 -> wall\\n        queue<pair<int, int>> q;\\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\\n        vector<vector<int>> t(rows, vector<int> (cols, 0));\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (g[i][j] == 2) t[i][j] = -1;\\n                if (g[i][j] == 1) {\\n                    q.push({i, j});\\n                    t[i][j] = -2;\\n                    vis[i][j] = true;\\n                }\\n            }\\n        }\\n\\n        bool fireReached = false; // this variable is useless\\n\\n        \\n        for (int level = 0; !q.empty(); level++) {\\n            int sz = q.size();\\n            while (sz--) {\\n                auto [i, j] = q.front(); q.pop();\\n                if (i == rows - 1 && j == cols - 1) fireReached = true;\\n                for (auto d : dirs) {\\n                    int ni = i + d[0];\\n                    int nj = j + d[1];\\n                    if (ni >= 0  && nj >= 0 && ni < rows && nj < cols && !vis[ni][nj] && t[ni][nj] == 0) {\\n                        vis[ni][nj] = true;\\n                        q.push({ni, nj});\\n                        t[ni][nj] = level + 1;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        if (doesNonFirePath(0, 0, t)) return 1e9;\\n\\n\\n\\n        int low = 0, high = rows * cols;\\n        int res = -1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (isValid(mid, t)) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n\\n                high = mid - 1;\\n            }\\n        }\\n\\n\\n        return res;\\n\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126299,
                "title": "c-bfs-binary-search-explained-with-comments",
                "content": "### **Approach:**\\n**1. For each grid cell, pre-calculate the min time fire needs to get there using BFS.\\n2. Use Binary search to get the maximum wait time**\\n*  We can do another bfs for the person.\\n*   Now we will know if on the current time if we can visit a cell or not.\\n*   If a cell catches fire before person reaches there that means person can\\'t go on to that cell.\\n* \\tNeed to remember if it is the final cell then it is ok if the person and the fire reaches there at the same time.\\n\\n#### **Code (with comments)**:\\n```\\nclass Solution {\\npublic:\\n    \\n    //max waiting time\\n    #define MAX_T 1e9\\n        \\n    struct triplet{  // for storing tripet in queue\\n        long r,c,t;\\n    };\\n    \\n    //for checking if we wait maxT min at initial pos then, \\n    //is it possible to reach to home or not?\\n    bool isPossible(long maxT,  vector<vector<int>> &fire, vector<vector<int>> &directions){\\n        int m=fire.size();\\n        int n=fire[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        visited[0][0]=true; // mark start idx as visited\\n        \\n        queue<triplet> q;\\n        q.push({0,0,maxT}); \\n        \\n        while(!q.empty()){\\n            auto [r,c,t]=q.front();\\n            q.pop();\\n\\n            if(r==m-1 && c==n-1)\\n                return true; // reached home\\n            \\n            if(fire[r][c]<=t)  //fire reached to person at same time or before he reached \\n                continue;\\n            \\n            for(int i=0;i<directions.size(); i++){\\n                int nR=r+directions[i][0]; // new row\\n                int nC=c+directions[i][1]; // new Col\\n                \\n               if(min(nR, nC)>=0 && nR<m && nC<n && fire[nR][nC]!=-1 && t+1 <= fire[nR][nC]){\\n                   if(!visited[nR][nC]){\\n                       visited[nR][nC]=true; //make it visited\\n                       q.push({nR, nC, t+1}); // push in queue to check adj\\n                   }\\n               }\\n            }\\n        }\\n        \\n        //Spiderman: No way Home :(\\n        \\n        return false; //cannot reach if waited maxT min at initial pos/no way possibe\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> fire(m,vector<int>(n, INT_MAX));\\n        //store the time to reach fire at a pos, intially infinite Time\\n        \\n        queue<pair<int,int>> q; \\n      \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ //if fire cell\\n                    fire[i][j]=0;  // the cells which are on fire in the start\\n                    q.push({i,j});\\n                }    \\n                else if(grid[i][j]==2) // fire cannot reach the wall cells\\n                {\\n                    fire[i][j]=-1;  // so store -1 if wall is there \\n                }\\n            }\\n        }\\n\\n        //for going in all 4 directions\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        \\n        while(!q.empty()){\\n            auto [row,col]=q.front();\\n            q.pop();\\n                \\n            for(int j=0;j<directions.size();j++){\\n                int newRow=row + directions[j][0];\\n                int newCol=col + directions[j][1];\\n                \\n                // fire[newRow][newCOl]=-1 -> wall cell \\n                if(min(newRow,newCol)>=0 && newRow<m && newCol<n && fire[newRow][newCol]!=-1){ // is valid coord.\\n                    if(fire[newRow][newCol] > fire[row][col] + 1){ // if previously stored time was greater \\n                   \\n                      fire[newRow][newCol]= fire[row][col] +1 ; \\n                      q.push({newRow,newCol});\\n                   }\\n                }\\n            } \\n        }\\n        \\n        //Use Binary seach to find the maxWaiting Time\\n        //Our search space will be from 0 to 10^9 min\\n        \\n        long l=0, h=MAX_T, maxWaitingTime=-1;\\n        \\n        while(l<=h){\\n            long mid=l+(h-l)/2;\\n            if(isPossible(mid, fire, directions))\\n            {\\n                //store the max time till now which is possible\\n                maxWaitingTime=max(maxWaitingTime,mid);\\n                // if we can wait this longer then try to wait longer\\n                l=mid+1;\\n            }else{\\n                //check for waitaing for shorter period instead\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return maxWaitingTime;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //max waiting time\\n    #define MAX_T 1e9\\n        \\n    struct triplet{  // for storing tripet in queue\\n        long r,c,t;\\n    };\\n    \\n    //for checking if we wait maxT min at initial pos then, \\n    //is it possible to reach to home or not?\\n    bool isPossible(long maxT,  vector<vector<int>> &fire, vector<vector<int>> &directions){\\n        int m=fire.size();\\n        int n=fire[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        visited[0][0]=true; // mark start idx as visited\\n        \\n        queue<triplet> q;\\n        q.push({0,0,maxT}); \\n        \\n        while(!q.empty()){\\n            auto [r,c,t]=q.front();\\n            q.pop();\\n\\n            if(r==m-1 && c==n-1)\\n                return true; // reached home\\n            \\n            if(fire[r][c]<=t)  //fire reached to person at same time or before he reached \\n                continue;\\n            \\n            for(int i=0;i<directions.size(); i++){\\n                int nR=r+directions[i][0]; // new row\\n                int nC=c+directions[i][1]; // new Col\\n                \\n               if(min(nR, nC)>=0 && nR<m && nC<n && fire[nR][nC]!=-1 && t+1 <= fire[nR][nC]){\\n                   if(!visited[nR][nC]){\\n                       visited[nR][nC]=true; //make it visited\\n                       q.push({nR, nC, t+1}); // push in queue to check adj\\n                   }\\n               }\\n            }\\n        }\\n        \\n        //Spiderman: No way Home :(\\n        \\n        return false; //cannot reach if waited maxT min at initial pos/no way possibe\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> fire(m,vector<int>(n, INT_MAX));\\n        //store the time to reach fire at a pos, intially infinite Time\\n        \\n        queue<pair<int,int>> q; \\n      \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){ //if fire cell\\n                    fire[i][j]=0;  // the cells which are on fire in the start\\n                    q.push({i,j});\\n                }    \\n                else if(grid[i][j]==2) // fire cannot reach the wall cells\\n                {\\n                    fire[i][j]=-1;  // so store -1 if wall is there \\n                }\\n            }\\n        }\\n\\n        //for going in all 4 directions\\n        vector<vector<int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n        \\n        while(!q.empty()){\\n            auto [row,col]=q.front();\\n            q.pop();\\n                \\n            for(int j=0;j<directions.size();j++){\\n                int newRow=row + directions[j][0];\\n                int newCol=col + directions[j][1];\\n                \\n                // fire[newRow][newCOl]=-1 -> wall cell \\n                if(min(newRow,newCol)>=0 && newRow<m && newCol<n && fire[newRow][newCol]!=-1){ // is valid coord.\\n                    if(fire[newRow][newCol] > fire[row][col] + 1){ // if previously stored time was greater \\n                   \\n                      fire[newRow][newCol]= fire[row][col] +1 ; \\n                      q.push({newRow,newCol});\\n                   }\\n                }\\n            } \\n        }\\n        \\n        //Use Binary seach to find the maxWaiting Time\\n        //Our search space will be from 0 to 10^9 min\\n        \\n        long l=0, h=MAX_T, maxWaitingTime=-1;\\n        \\n        while(l<=h){\\n            long mid=l+(h-l)/2;\\n            if(isPossible(mid, fire, directions))\\n            {\\n                //store the max time till now which is possible\\n                maxWaitingTime=max(maxWaitingTime,mid);\\n                // if we can wait this longer then try to wait longer\\n                l=mid+1;\\n            }else{\\n                //check for waitaing for shorter period instead\\n                h=mid-1;\\n            }\\n        }\\n        \\n        return maxWaitingTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085348,
                "title": "python-bfs-only",
                "content": "80% runtime, 70% memory. I haven\\'t tried heavily optimizing.\\n\\n```python\\nfrom collections import deque\\n\\n\\nMAX_TIME = 10**9\\n\\n\\ndef adj(coord, dir):\\n    # Convenience function for computing adjacent coordinate.\\n    # `dir` is in [0, 1, 2, 3]\\n    i, j = coord\\n    if dir == 0:\\n        return (i+1, j)\\n    if dir == 1:\\n        return (i, j+1)\\n    if dir == 2:\\n        return (i-1, j)\\n    if dir == 3:\\n        return (i, j-1)\\n    raise Exception()\\n\\n\\ndef get_adj(a, i, j, dir, fail=0):\\n    # Convenience function for getting value of 2D list at adjacent coordinate.\\n    # Return `fail` if the adjacent coordinate is out of bounds.\\n    w = len(a[0])\\n    h = len(a)\\n    if dir == 0:\\n        return a[i+1][j] if i < h - 1 else fail\\n    if dir == 1:\\n        return a[i][j+1] if j < w - 1 else fail\\n    if dir == 2:\\n        return a[i-1][j] if i > 0 else fail\\n    if dir == 3:\\n        return a[i][j-1] if j > 0 else fail\\n    raise Exception()\\n    \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        w = len(grid[0])\\n        h = len(grid)\\n        \\n        # BFS fire.\\n        # In each cell record first time step at which fire arrives. \\n        fire = [[-1]*w for _ in range(h)]\\n        q = deque()\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j] == 1:\\n                    fire[i][j] = 0\\n                    q.append((i, j))\\n        while q:\\n            i, j = q.pop()\\n            t = fire[i][j]\\n            for dir in range(4):\\n                if get_adj(fire, i, j, dir) == -1 and get_adj(grid, i, j, dir, 2) != 2:\\n                    k, l = adj((i, j), dir)\\n                    fire[k][l] = t + 1\\n                    q.appendleft((k, l))\\n        \\n        # BFS player.\\n        # In each cell, record the tuple (time, min_diff) where\\n        #    `time` is the time it takes the player to reach the cell along the \"best\" path\\n        #    and `min_diff` is the cumulative min (along cells in \"best\" path) difference between fire time and player time.\\n        # The \"best\" path up to any cell is the path with the maximum `min_diff` up to that cell.\\n        player = [[(-1, -1)]*w for _ in range(h)]\\n        player[0][0] = (\\n            0,\\n            fire[0][0] - 1 if fire[0][0] >= 0 else MAX_TIME)\\n        q = deque()\\n        q.append((0,0))\\n        while q:\\n            i, j = q.pop()\\n            t, min_diff = player[i][j]\\n            t += 1  # Time step of the adjacent cells\\n            for dir in range(4):\\n                if get_adj(grid, i, j, dir, fail=2) != 2:  # Treat out of bounds like walls\\n                    k, l = adj((i, j), dir)\\n                    fire_time = fire[k][l]\\n                    offset = 0 if k == h-1 and l == w-1 else -1  # Special case for handling safehouse\\n                    next_min_diff = min(\\n                        min_diff,\\n                        fire[k][l] - t + offset if fire[k][l] >= 0 else MAX_TIME)\\n                    if next_min_diff > player[k][l][1]:\\n                        player[k][l] = (t, next_min_diff)\\n                        q.appendleft((k, l))\\n                        \\n        return player[-1][-1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom collections import deque\\n\\n\\nMAX_TIME = 10**9\\n\\n\\ndef adj(coord, dir):\\n    # Convenience function for computing adjacent coordinate.\\n    # `dir` is in [0, 1, 2, 3]\\n    i, j = coord\\n    if dir == 0:\\n        return (i+1, j)\\n    if dir == 1:\\n        return (i, j+1)\\n    if dir == 2:\\n        return (i-1, j)\\n    if dir == 3:\\n        return (i, j-1)\\n    raise Exception()\\n\\n\\ndef get_adj(a, i, j, dir, fail=0):\\n    # Convenience function for getting value of 2D list at adjacent coordinate.\\n    # Return `fail` if the adjacent coordinate is out of bounds.\\n    w = len(a[0])\\n    h = len(a)\\n    if dir == 0:\\n        return a[i+1][j] if i < h - 1 else fail\\n    if dir == 1:\\n        return a[i][j+1] if j < w - 1 else fail\\n    if dir == 2:\\n        return a[i-1][j] if i > 0 else fail\\n    if dir == 3:\\n        return a[i][j-1] if j > 0 else fail\\n    raise Exception()\\n    \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        w = len(grid[0])\\n        h = len(grid)\\n        \\n        # BFS fire.\\n        # In each cell record first time step at which fire arrives. \\n        fire = [[-1]*w for _ in range(h)]\\n        q = deque()\\n        for i in range(h):\\n            for j in range(w):\\n                if grid[i][j] == 1:\\n                    fire[i][j] = 0\\n                    q.append((i, j))\\n        while q:\\n            i, j = q.pop()\\n            t = fire[i][j]\\n            for dir in range(4):\\n                if get_adj(fire, i, j, dir) == -1 and get_adj(grid, i, j, dir, 2) != 2:\\n                    k, l = adj((i, j), dir)\\n                    fire[k][l] = t + 1\\n                    q.appendleft((k, l))\\n        \\n        # BFS player.\\n        # In each cell, record the tuple (time, min_diff) where\\n        #    `time` is the time it takes the player to reach the cell along the \"best\" path\\n        #    and `min_diff` is the cumulative min (along cells in \"best\" path) difference between fire time and player time.\\n        # The \"best\" path up to any cell is the path with the maximum `min_diff` up to that cell.\\n        player = [[(-1, -1)]*w for _ in range(h)]\\n        player[0][0] = (\\n            0,\\n            fire[0][0] - 1 if fire[0][0] >= 0 else MAX_TIME)\\n        q = deque()\\n        q.append((0,0))\\n        while q:\\n            i, j = q.pop()\\n            t, min_diff = player[i][j]\\n            t += 1  # Time step of the adjacent cells\\n            for dir in range(4):\\n                if get_adj(grid, i, j, dir, fail=2) != 2:  # Treat out of bounds like walls\\n                    k, l = adj((i, j), dir)\\n                    fire_time = fire[k][l]\\n                    offset = 0 if k == h-1 and l == w-1 else -1  # Special case for handling safehouse\\n                    next_min_diff = min(\\n                        min_diff,\\n                        fire[k][l] - t + offset if fire[k][l] >= 0 else MAX_TIME)\\n                    if next_min_diff > player[k][l][1]:\\n                        player[k][l] = (t, next_min_diff)\\n                        q.appendleft((k, l))\\n                        \\n        return player[-1][-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034662,
                "title": "a-solution",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\ntemplate<typename a, typename b, typename c>\\nclass tri {\\npublic:\\n    a x;\\n    b y;\\n    c z;\\n    tri(a x, b y, c z) {\\n        this->x = x;\\n        this->y = y;\\n        this->z = z;\\n    }\\n    tri() {\\n        this->x = *(new a);\\n        this->y = *(new b);\\n        this->z = *(new c);\\n    }\\n};\\n\\nll res = LLONG_MIN;\\n\\nvoid travel(const vector<vector<int>>& v) {\\n    queue<vector<ll>>q;\\n    q.push({ 0,0,1,0, LLONG_MAX });\\n    vector<vector<bool>>vis(v.size(), vector<bool>(v[0].size(), false));\\n    while (!q.empty()) {\\n        ll i = q.front()[0], j = q.front()[1], time = q.front()[2], tmnsf = q.front()[3], mnsf = q.front()[4];\\n        q.pop();\\n        if (i < 0 || i >= v.size() || j < 0 || j >= v[0].size() || v[i][j]>0 || (v[i][j] && abs(v[i][j]) < time) || vis[i][j])\\n            continue;\\n        vis[i][j] = true;\\n        ll cur = abs(v[i][j]), ans = cur - time - (i != v.size() - 1 || j != v[0].size() - 1);\\n        bool pre = true;\\n        if (mnsf == LLONG_MAX || ans < mnsf - tmnsf - 1) {\\n            mnsf = cur;\\n            tmnsf = time;\\n            pre = false;\\n        }\\n        if (i == v.size() - 1 && j == v[0].size() - 1) {\\n            if (mnsf)\\n                res = max(res, mnsf - tmnsf - (pre ? 1 : 0));\\n            else\\n                res = mod - 7;\\n            vis[i][j]=false;\\n            continue;\\n        }\\n        if (abs(v[i][j]) == time)\\n            continue;\\n        q.push({ i, j + 1, time + 1, tmnsf, mnsf });\\n        q.push({ i + 1, j, time + 1, tmnsf, mnsf });\\n        q.push({ i - 1, j, time + 1, tmnsf, mnsf });\\n        q.push({ i, j - 1, time + 1, tmnsf, mnsf });\\n    }\\n}\\n\\nint maximumMinutes(vector<vector<int>>& v) {\\n    queue<tri<ll, ll, ll>> q;\\n    const ll m = v.size(), n = v[0].size();\\n    for (ll i = 0;i < m;i++) {\\n        for (ll j = 0;j < n;j++) {\\n            if (v[i][j] == 1) {\\n                v[i][j] = -1;\\n                q.push({ i, j + 1 ,-2 });\\n                q.push({ i + 1, j ,-2 });\\n                q.push({ i, j - 1,-2 });\\n                q.push({ i - 1, j ,-2 });\\n            }\\n        }\\n    }\\n    while (!q.empty()) {\\n        ll i = q.front().x, j = q.front().y, k = q.front().z;\\n        q.pop();\\n        if (i < 0 || i >= m || j < 0 || j >= n || v[i][j]>0 || (v[i][j] && abs(v[i][j]) <= abs(k)))\\n            continue;\\n        v[i][j] = k;\\n        --k;\\n        q.push({ i, j + 1, k });\\n        q.push({ i + 1, j, k });\\n        q.push({ i, j - 1, k });\\n        q.push({ i - 1, j, k });\\n    }\\n    travel(v);\\n    if (res == LLONG_MIN)\\n        res = -1;\\n    return res;\\n}\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\ntypedef long long ll;\\n#define endl \\'\\\\n\\'\\nconst ll mod = 1e9 + 7;\\n\\ntemplate<typename a, typename b, typename c>\\nclass tri {\\npublic:\\n    a x;\\n    b y;\\n    c z;\\n    tri(a x, b y, c z) {\\n        this->x = x;\\n        this->y = y;\\n        this->z = z;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2013907,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int inf=1e9;\\n    int dr[4]={0,0,1,-1};\\n    int dc[4]={1,-1,0,0};\\n    vector<vector<int>>last;\\n    vector<vector<int>>grid;\\n    int m,n;\\n    bool check(int target)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int step=0;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                if(x==m-1&&y==n-1&&(last[x][y]>=step+target||last[x][y]==inf))return true;\\n                q.pop();\\n                if(vis[x][y])continue;\\n                vis[x][y]=true;\\n                if(grid[x][y]==2)continue;\\n                if(last[x][y]!=inf && last[x][y]<=step+target)continue;\\n                // cout << x << \" \" << y << \" \" << last[x][y] << \" \" << step+target << endl;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int nx=x+dr[k],ny=y+dc[k];\\n                    if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                    q.push({nx,ny});\\n                }\\n            }\\n            step++;\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        this->grid=grid;\\n        last.resize(m,vector<int>(n,inf));\\n        queue<pair<int,int>>q;\\n        int step=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=1)continue;\\n                q.push({i,j});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(last[x][y]==inf&&grid[x][y]!=2)\\n                {\\n                    last[x][y]=step;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int nx=x+dr[k],ny=y+dc[k];\\n                        if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int l=0,r=1e9+1;\\n        while(l<r)\\n        {\\n            int mid=(l+r)>>1;\\n            if(check(mid))l=mid+1;\\n            else r=mid;\\n        }\\n        l--;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inf=1e9;\\n    int dr[4]={0,0,1,-1};\\n    int dc[4]={1,-1,0,0};\\n    vector<vector<int>>last;\\n    vector<vector<int>>grid;\\n    int m,n;\\n    bool check(int target)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int step=0;\\n        vector<vector<bool>>vis(m,vector<bool>(n,false));\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                if(x==m-1&&y==n-1&&(last[x][y]>=step+target||last[x][y]==inf))return true;\\n                q.pop();\\n                if(vis[x][y])continue;\\n                vis[x][y]=true;\\n                if(grid[x][y]==2)continue;\\n                if(last[x][y]!=inf && last[x][y]<=step+target)continue;\\n                // cout << x << \" \" << y << \" \" << last[x][y] << \" \" << step+target << endl;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int nx=x+dr[k],ny=y+dc[k];\\n                    if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                    q.push({nx,ny});\\n                }\\n            }\\n            step++;\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        this->grid=grid;\\n        last.resize(m,vector<int>(n,inf));\\n        queue<pair<int,int>>q;\\n        int step=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=1)continue;\\n                q.push({i,j});\\n            }\\n        }\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz)\\n            {\\n                sz--;\\n                int x=q.front().first,y=q.front().second;\\n                q.pop();\\n                if(last[x][y]==inf&&grid[x][y]!=2)\\n                {\\n                    last[x][y]=step;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int nx=x+dr[k],ny=y+dc[k];\\n                        if(nx<0||ny<0||nx>=m||ny>=n)continue;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        int l=0,r=1e9+1;\\n        while(l<r)\\n        {\\n            int mid=(l+r)>>1;\\n            if(check(mid))l=mid+1;\\n            else r=mid;\\n        }\\n        l--;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2005231,
                "title": "cpp-simple-140-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool cango(int x, int y, vector<vector<int>>&grid){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(grid[x][y] != 0) return false;\\n        return true;\\n    }\\n    \\n    int xx[4] = {0, 0, -1, 1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    bool check(int val, vector<vector<int>> grid, vector<pair<int, int>> fire){\\n        \\n        vector<vector<int>> dp1 = vector<vector<int>>(n, vector<int>(m, -1));\\n        vector<vector<int>> dp2 = vector<vector<int>>(n, vector<int>(m, -1));\\n        \\n        dp1[0][0] = 1;\\n        \\n        for(int j=0;j<val;j++){\\n            vector<pair<int, int>> ffire;\\n            if(fire.size() == 0) break;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == 0 && y + yy[i] == 0) return false;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            fire = ffire;\\n            ffire = {};\\n        }\\n        \\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp1[x+xx[i]][y+yy[i]] == -1){\\n                        dp1[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n            vector<pair<int, int>> ffire;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            \\n            fire = ffire;\\n            ffire = {};\\n            \\n            if(man.size() == 0) return false;\\n            if(fire.size() == 0) return true;\\n       \\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    bool hadpath(vector<vector<int>>&grid){\\n        int dp[n][m];\\n        memset(dp, -1, sizeof(dp));\\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp[x+xx[i]][y+yy[i]] == -1){\\n                        dp[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        vector<pair<int, int>> fire;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) fire.push_back({i, j});\\n            }\\n        }\\n        \\n        int lo = 0;\\n        int hi = 1e9;\\n        \\n        if(!hadpath(grid)) return -1; \\n        \\n        while(hi - lo > 1){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, grid, fire)) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(check(hi, grid, fire)) return hi;\\n        else if(check(lo, grid, fire)) return lo;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool cango(int x, int y, vector<vector<int>>&grid){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(grid[x][y] != 0) return false;\\n        return true;\\n    }\\n    \\n    int xx[4] = {0, 0, -1, 1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    bool check(int val, vector<vector<int>> grid, vector<pair<int, int>> fire){\\n        \\n        vector<vector<int>> dp1 = vector<vector<int>>(n, vector<int>(m, -1));\\n        vector<vector<int>> dp2 = vector<vector<int>>(n, vector<int>(m, -1));\\n        \\n        dp1[0][0] = 1;\\n        \\n        for(int j=0;j<val;j++){\\n            vector<pair<int, int>> ffire;\\n            if(fire.size() == 0) break;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == 0 && y + yy[i] == 0) return false;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            fire = ffire;\\n            ffire = {};\\n        }\\n        \\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp1[x+xx[i]][y+yy[i]] == -1){\\n                        dp1[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n            vector<pair<int, int>> ffire;\\n            for(auto&it: fire){\\n                int x = it.first;\\n                int y = it.second;\\n                dp2[x][y] = 1;\\n                for(int i=0;i<4;i++){\\n                    if(cango(x + xx[i], y + yy[i], grid) && dp2[x+xx[i]][y+yy[i]] == -1){\\n                        dp2[x+xx[i]][y+yy[i]] = 1;\\n                        grid[x+xx[i]][y+yy[i]] = 1;\\n                        if(x+xx[i] == n-1 && y + yy[i] == m-1) return false;\\n                        ffire.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            \\n            fire = ffire;\\n            ffire = {};\\n            \\n            if(man.size() == 0) return false;\\n            if(fire.size() == 0) return true;\\n       \\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    bool hadpath(vector<vector<int>>&grid){\\n        int dp[n][m];\\n        memset(dp, -1, sizeof(dp));\\n        vector<pair<int, int>> man;\\n        man.push_back({0, 0});\\n        \\n        while(man.size()){\\n            vector<pair<int, int>> tman;\\n            for(auto&it: man){\\n                int x = it.first;\\n                int y = it.second;\\n                if(grid[x][y] != 0) continue;\\n                for(int i=0;i<4;i++){\\n                    if(x + xx[i] == n-1 && y + yy[i] == m-1) return true;\\n                    if(cango(x+xx[i], y+yy[i], grid) && dp[x+xx[i]][y+yy[i]] == -1){\\n                        dp[x+xx[i]][y+yy[i]] = 1;\\n                        tman.push_back({x+xx[i], y+yy[i]});\\n                    }\\n                }\\n            }\\n            man = tman;\\n            tman = {};\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        vector<pair<int, int>> fire;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) fire.push_back({i, j});\\n            }\\n        }\\n        \\n        int lo = 0;\\n        int hi = 1e9;\\n        \\n        if(!hadpath(grid)) return -1; \\n        \\n        while(hi - lo > 1){\\n            int mid = lo + (hi-lo)/2;\\n            if(check(mid, grid, fire)) lo = mid;\\n            else hi = mid-1;\\n        }\\n        if(check(hi, grid, fire)) return hi;\\n        else if(check(lo, grid, fire)) return lo;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996020,
                "title": "simple-binary-search-bfs-c-solution",
                "content": "YOU MUST NOT MISS THIS CONDITION :)\\n![image](https://assets.leetcode.com/users/images/c58d05ea-22b7-4f94-88c7-a9a26b16d9ca_1651389789.9018068.png)\\n\\n\\n\\n```\\n#define ff first\\n#define ss second\\n\\nint maximumMinutes(vector<vector<int>>& mat) {\\n        \\n        int infy = 2e9 ; // have to take 2e9 // I was taking initially this as 1e9 + 7 ! its wrong accordingly how \\n        // I had implemented the binary search ! \\n        \\n        int n = mat.size() , m = mat[0].size() ;\\n        \\n        vector<vector<int>> fireReach(n , vector<int>(m , infy)) ;\\n        vector<vector<bool>> vis(n , vector<bool>(m , 0)) ;\\n        queue<pair<int,int>> q ;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(mat[i][j] == 1){\\n                    fireReach[i][j] = 0; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n         \\n        // Validator for Row Col ! \\n        auto valid = [&](int i , int j) -> bool {\\n            return (i >= 0 and j >= 0 and i<n and j < m and vis[i][j] == 0 and mat[i][j] != 2) ; \\n        } ; \\n    \\n        // bfs for Fire ! \\n        while(q.size()){\\n            auto p  = q.front() ; \\n            q.pop() ; \\n            int cost = fireReach[p.ff][p.ss] ; \\n            \\n            for(int k = 0; k<4 ; k++){\\n                int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                if(valid(i , j)) {\\n                    vis[i][j] = 1 ;\\n                    fireReach[i][j] = cost + 1 ; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n        \\n        \\n        // CHECKER for binary search! \\n        auto canbe = [&](int time) -> bool {\\n             queue<pair<int,int>> q ; \\n             q.push({0 , 0}) ; \\n             vector<vector<int>> reach(n , vector<int>(m , infy)) ;\\n             vis = vector<vector<bool>>(n , vector<bool>(m , 0)) ;\\n             reach[0][0] = time ; \\n             vis[0][0] = true ; \\n\\n             while(q.size()){\\n                auto p  = q.front() ; \\n                if(p.ff == n-1 and p.ss == m-1) {\\n                    return true ;\\n                }\\n                q.pop() ; \\n                int cost = reach[p.ff][p.ss] ; \\n\\n                for(int k = 0; k<4 ; k++){\\n                    int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                    if(valid(i , j)) {\\n                        if(fireReach[i][j] == cost + 1){ // CRITICAL EDGE CASE TO BE CONSIDERED ! \\n                            if(i == n-1 and j == m-1) return true ; \\n                        }else \\n                            if(fireReach[i][j] > cost + 1){\\n                            vis[i][j] = 1 ;\\n                            reach[i][j] = cost + 1 ; \\n                            q.push({i , j}) ;    \\n                        }\\n                    }\\n                }\\n             }\\n             return false ; \\n        } ; \\n        \\n        \\n        // BINARY SEARCH ! \\n        int l = 0 , h = 1e9 ; \\n        int ans = -1 ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                l = mid + 1 ;\\n            }else h = mid - 1 ; \\n        }\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ff first\\n#define ss second\\n\\nint maximumMinutes(vector<vector<int>>& mat) {\\n        \\n        int infy = 2e9 ; // have to take 2e9 // I was taking initially this as 1e9 + 7 ! its wrong accordingly how \\n        // I had implemented the binary search ! \\n        \\n        int n = mat.size() , m = mat[0].size() ;\\n        \\n        vector<vector<int>> fireReach(n , vector<int>(m , infy)) ;\\n        vector<vector<bool>> vis(n , vector<bool>(m , 0)) ;\\n        queue<pair<int,int>> q ;\\n        \\n        for(int i = 0 ; i<n ; i++){\\n            for(int j = 0 ; j<m ; j++){\\n                if(mat[i][j] == 1){\\n                    fireReach[i][j] = 0; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n         \\n        // Validator for Row Col ! \\n        auto valid = [&](int i , int j) -> bool {\\n            return (i >= 0 and j >= 0 and i<n and j < m and vis[i][j] == 0 and mat[i][j] != 2) ; \\n        } ; \\n    \\n        // bfs for Fire ! \\n        while(q.size()){\\n            auto p  = q.front() ; \\n            q.pop() ; \\n            int cost = fireReach[p.ff][p.ss] ; \\n            \\n            for(int k = 0; k<4 ; k++){\\n                int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                if(valid(i , j)) {\\n                    vis[i][j] = 1 ;\\n                    fireReach[i][j] = cost + 1 ; \\n                    q.push({i , j}) ; \\n                }\\n            }\\n        }\\n        \\n        \\n        // CHECKER for binary search! \\n        auto canbe = [&](int time) -> bool {\\n             queue<pair<int,int>> q ; \\n             q.push({0 , 0}) ; \\n             vector<vector<int>> reach(n , vector<int>(m , infy)) ;\\n             vis = vector<vector<bool>>(n , vector<bool>(m , 0)) ;\\n             reach[0][0] = time ; \\n             vis[0][0] = true ; \\n\\n             while(q.size()){\\n                auto p  = q.front() ; \\n                if(p.ff == n-1 and p.ss == m-1) {\\n                    return true ;\\n                }\\n                q.pop() ; \\n                int cost = reach[p.ff][p.ss] ; \\n\\n                for(int k = 0; k<4 ; k++){\\n                    int i = p.ff + di[k] , j = p.ss + dj[k]  ; \\n                    if(valid(i , j)) {\\n                        if(fireReach[i][j] == cost + 1){ // CRITICAL EDGE CASE TO BE CONSIDERED ! \\n                            if(i == n-1 and j == m-1) return true ; \\n                        }else \\n                            if(fireReach[i][j] > cost + 1){\\n                            vis[i][j] = 1 ;\\n                            reach[i][j] = cost + 1 ; \\n                            q.push({i , j}) ;    \\n                        }\\n                    }\\n                }\\n             }\\n             return false ; \\n        } ; \\n        \\n        \\n        // BINARY SEARCH ! \\n        int l = 0 , h = 1e9 ; \\n        int ans = -1 ; \\n        while(l <= h){\\n            int mid = (l + h)/2 ; \\n            if(canbe(mid)){\\n                ans = mid ; \\n                l = mid + 1 ;\\n            }else h = mid - 1 ; \\n        }\\n        \\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995832,
                "title": "c-no-binary-search-easy-explanation-two-bfs-only-134-ms-24-3-mb",
                "content": "- Creating a map for fire spread i.e. fire_times[i][j] = min time for fire to reach {i,j}\\n- traversing for all possible paths between (0,0) to (m-1,n-1)\\n- finding min waiting time on a single path from (0,0) to (m-1,n-1)\\n- taking max across all possible paths\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> fire_times(m, vector<int>(n, INT_MAX));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j]==1) {\\n                    q.push({i, j});\\n                    fire_times[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// creating fire_times : map of min time it will take fire to reach any point\\n        int mnt = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                auto [i,j] = q.front(); q.pop();\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y]== INT_MAX){\\n                        fire_times[x][y] = min(fire_times[x][y], mnt);\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n\\t\\t// traversing all possible paths from (0,0) to (m-1,n-1)\\n\\t\\t// and finding min waiting time for a path and then taking max across paths\\n        queue<tuple<int, int, int>> qp;\\n        qp.push({0,0,1e9});\\n        mnt =1;\\n        int res = -1;\\n        while(!qp.empty()){\\n            int qpsize = qp.size();\\n            while(qpsize--){\\n                auto [i, j, min_] = qp.front(); qp.pop();\\n                grid[i][j] = 1;\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x == m-1 && y == n-1 && fire_times[x][y] >= mnt) {\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt);\\n                        grid[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tres = max(res, next_min);   // taking max across paths\\n                    }\\n                    else if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y] > mnt){\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt - 1);\\n                        grid[i][j] = 1;\\n                        qp.push({x,y, next_min});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dirs = {{0,1}, {1,0}, {-1,0}, {0,-1}};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        queue<pair<int, int>> q;\\n        vector<vector<int>> fire_times(m, vector<int>(n, INT_MAX));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j]==1) {\\n                    q.push({i, j});\\n                    fire_times[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// creating fire_times : map of min time it will take fire to reach any point\\n        int mnt = 1;\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            while(qsize--){\\n                auto [i,j] = q.front(); q.pop();\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y]== INT_MAX){\\n                        fire_times[x][y] = min(fire_times[x][y], mnt);\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n\\t\\t// traversing all possible paths from (0,0) to (m-1,n-1)\\n\\t\\t// and finding min waiting time for a path and then taking max across paths\\n        queue<tuple<int, int, int>> qp;\\n        qp.push({0,0,1e9});\\n        mnt =1;\\n        int res = -1;\\n        while(!qp.empty()){\\n            int qpsize = qp.size();\\n            while(qpsize--){\\n                auto [i, j, min_] = qp.front(); qp.pop();\\n                grid[i][j] = 1;\\n                for(auto dir: dirs){\\n                    int x = i + dir.first;\\n                    int y = j + dir.second;\\n                    if(x == m-1 && y == n-1 && fire_times[x][y] >= mnt) {\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt);\\n                        grid[i][j] = 1;\\n\\t\\t\\t\\t\\t\\tres = max(res, next_min);   // taking max across paths\\n                    }\\n                    else if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] == 0 && fire_times[x][y] > mnt){\\n                        int next_min = (fire_times[x][y] == INT_MAX) ? min_ : min(min_, fire_times[x][y] - mnt - 1);\\n                        grid[i][j] = 1;\\n                        qp.push({x,y, next_min});\\n                    }\\n                }\\n            }\\n            mnt++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995585,
                "title": "bfs-java-binary-search",
                "content": "```\\nclass Solution {\\n    static int [][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int prevfire = 0;\\n        List<Pair> arr = new ArrayList<>();\\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                 if(grid[i][j]==1)q.add(new Pair(i,j));\\n                 else if(grid[i][j]==2)arr.add(new Pair(i,j));\\n            }\\n        }\\n        int [][] dp = new int[grid.length][grid[0].length];\\n        for(int []a:dp)Arrays.fill(a,Integer.MAX_VALUE);\\n        for(Pair rem:arr)dp[rem.i][rem.j] = -2;\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                dp[rem.i][rem.j] = level;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<grid.length  && y>=0 && y<grid[0].length && dp[x][y]==Integer.MAX_VALUE)q.add(new Pair(rem.i + dir[k][0],rem.j + dir[k][1]));\\n                }\\n            }\\n            level++;\\n        }\\n        int max = -1;\\n        int high = (int)Math.pow(10,9),low = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            boolean val = check(mid,dp);\\n            if(val){\\n                max = Math.max(mid,max);\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return max;\\n    }\\n    public boolean check(int wait,int [][]dp){\\n        Queue<Pair> q = new LinkedList<>();\\n        if(wait>=dp[0][0])return false;\\n        boolean [][] visited = new boolean[dp.length][dp[0].length];\\n        q.add(new Pair(0,0));\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                visited[rem.i][rem.j] = true;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<dp.length  && y>=0 && y<dp[0].length && (wait + level + 1<dp[x][y] || (x==dp.length-1 && y==dp[0].length-1 && dp[x][y]==wait + level + 1)) && dp[x][y]!=-2 && !visited[x][y]){\\n                        if(x==dp.length-1 && y==dp[0].length-1)return true;\\n                        q.add(new Pair(x,y));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n    \\n    public void printm(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int [][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    class Pair{\\n        int i;\\n        int j;\\n        Pair(int i,int j){\\n            this.i = i;\\n            this.j = j;\\n        }\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int prevfire = 0;\\n        List<Pair> arr = new ArrayList<>();\\n        Queue<Pair> q = new LinkedList<>();\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                 if(grid[i][j]==1)q.add(new Pair(i,j));\\n                 else if(grid[i][j]==2)arr.add(new Pair(i,j));\\n            }\\n        }\\n        int [][] dp = new int[grid.length][grid[0].length];\\n        for(int []a:dp)Arrays.fill(a,Integer.MAX_VALUE);\\n        for(Pair rem:arr)dp[rem.i][rem.j] = -2;\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                dp[rem.i][rem.j] = level;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<grid.length  && y>=0 && y<grid[0].length && dp[x][y]==Integer.MAX_VALUE)q.add(new Pair(rem.i + dir[k][0],rem.j + dir[k][1]));\\n                }\\n            }\\n            level++;\\n        }\\n        int max = -1;\\n        int high = (int)Math.pow(10,9),low = 0;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            boolean val = check(mid,dp);\\n            if(val){\\n                max = Math.max(mid,max);\\n                low = mid + 1;\\n            }\\n            else high = mid -1;\\n        }\\n        return max;\\n    }\\n    public boolean check(int wait,int [][]dp){\\n        Queue<Pair> q = new LinkedList<>();\\n        if(wait>=dp[0][0])return false;\\n        boolean [][] visited = new boolean[dp.length][dp[0].length];\\n        q.add(new Pair(0,0));\\n        int level = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int t=0;t<size;t++){\\n                Pair rem = q.remove();\\n                visited[rem.i][rem.j] = true;\\n                for(int k=0;k<dir.length;k++){\\n                    int x = rem.i + dir[k][0];\\n                    int y = rem.j + dir[k][1];\\n                    if(x>=0 && x<dp.length  && y>=0 && y<dp[0].length && (wait + level + 1<dp[x][y] || (x==dp.length-1 && y==dp[0].length-1 && dp[x][y]==wait + level + 1)) && dp[x][y]!=-2 && !visited[x][y]){\\n                        if(x==dp.length-1 && y==dp[0].length-1)return true;\\n                        q.add(new Pair(x,y));\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return false;\\n    }\\n    \\n    public void printm(int [][] matrix){\\n        for(int []a:matrix){\\n            for(int b:a)System.out.print(b + \" \");\\n            System.out.println();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995574,
                "title": "javascript-double-bfs",
                "content": "I\\'m sure there\\'s a cleaner way to do this.\\n\\nStart by finding the time it takes for the fire to reach each cell. For this we can do a simple BFS.\\n\\nI\\'m replacing walls with # and fire with _ just so it\\'s easier to read. Given the first example, we get:\\n\\n```\\n[6,  #,  4,  3,  2,  1,  2]\\n[5,  4,  3,  #,  #,  _,  1]\\n[6,  #,  2,  1,  _,  #,  2]\\n[7,  8,  #,  #,  #, 14,  #]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\\n\\nNow find the maximum delay for each point starting from the origin.\\n\\nFor instance, to reach ```[0, 1]```, we know the fire will get there in 5 minutes, so we have to arrive there by 4 minutes. This means our max delay to arrive at any cell is the time it takes the fire to get there - 1 - the time it takes us to get there or ```timeToFire[row][col] - 1 - timeToReach[row][col]```.\\n\\nThe only annoying exception to this rule is we can reach the end at the same time as the fire.\\n\\n```\\n[0, 1, 2, 3, 4, 5, 6,  7,  8]\\n[#, #, #, #, #, #, #,  #,  9]\\n[_, #, #, #, 6, 7, 8,  #, 10]\\n[1, 2, 3, 4, 5, #, 9, 10, 11]\\n```\\n\\nBFS from the origin, and count the max delay to each point, keeping in mind some edge cases\\n- if the next cell isn\\'t the end, the next max delay is 1 less than the time it takes the fire to get there\\n- if the fire can\\'t get there, the next max delay is the min of our current delay and 1,000,000,000 per the instructions\\n- we may want to overwrite the max delay to certain points - just ignoring a cell if it\\'s been visited may not work. There could be a longer path to a particular point, but the shorter one got cut-off by fire earlier.\\n\\n\\n```\\nvar maximumMinutes = function(grid) {\\n  const MAX = 10 ** 9;\\n  const [m, n] = [grid.length, grid[0].length];\\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n  const queue = [];\\n  const timeToFire = grid\\n    .map((row, r) => row.map((val, c) => {\\n      if (val === 1) queue.push([r, c]);\\n      return val > 0 ? 0 : -1;\\n    }));\\n  \\n  let time = 1;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (timeToFire[rNext]?.[cNext] === undefined || timeToFire[rNext][cNext] >= 0) continue;\\n        \\n        timeToFire[rNext][cNext] = time;\\n        queue.push([rNext, cNext]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  time = 1;\\n  const maxDelay = grid.map((row) => row.map(() => -1));\\n  maxDelay[0][0] = timeToFire[0][0] >= 0 ? timeToFire[0][0] - 1 : MAX;\\n  queue.push([0, 0, maxDelay[0][0]]);\\n  \\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col, delay] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (grid[rNext]?.[cNext] === undefined || grid[rNext][cNext] === 2) continue;\\n        \\n\\t\\tconst isEnd = rNext === m - 1 && cNext === n -1 ;\\n        const additionalTimeNeeded = isEnd ? 0 : 1;\\n\\t\\tconst maxPossibleDelay = timeToFire[rNext][cNext] >= 0\\n\\t\\t\\t? timeToFire[rNext][cNext] - time - additionalTimeNeeded\\n\\t\\t\\t: MAX\\n        const nextDelay = Math.min(delay, maxPossibleDelay);\\n\\t\\tconst visited = maxDelay[rNext][cNext] >= 0;\\n        \\n        if (nextDelay < 0 || (visited && maxDelay[rNext][cNext] >= nextDelay)) continue;\\n        \\n        maxDelay[rNext][cNext] = nextDelay;\\n        queue.push([rNext, cNext, nextDelay]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  return maxDelay[m - 1][n - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n[6,  #,  4,  3,  2,  1,  2]\\n[5,  4,  3,  #,  #,  _,  1]\\n[6,  #,  2,  1,  _,  #,  2]\\n[7,  8,  #,  #,  #, 14,  #]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\n```[0, 1]```\n```timeToFire[row][col] - 1 - timeToReach[row][col]```\n```\\n[0, 1, 2, 3, 4, 5, 6,  7,  8]\\n[#, #, #, #, #, #, #,  #,  9]\\n[_, #, #, #, 6, 7, 8,  #, 10]\\n[1, 2, 3, 4, 5, #, 9, 10, 11]\\n```\n```\\nvar maximumMinutes = function(grid) {\\n  const MAX = 10 ** 9;\\n  const [m, n] = [grid.length, grid[0].length];\\n  const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];\\n  const queue = [];\\n  const timeToFire = grid\\n    .map((row, r) => row.map((val, c) => {\\n      if (val === 1) queue.push([r, c]);\\n      return val > 0 ? 0 : -1;\\n    }));\\n  \\n  let time = 1;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (timeToFire[rNext]?.[cNext] === undefined || timeToFire[rNext][cNext] >= 0) continue;\\n        \\n        timeToFire[rNext][cNext] = time;\\n        queue.push([rNext, cNext]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  time = 1;\\n  const maxDelay = grid.map((row) => row.map(() => -1));\\n  maxDelay[0][0] = timeToFire[0][0] >= 0 ? timeToFire[0][0] - 1 : MAX;\\n  queue.push([0, 0, maxDelay[0][0]]);\\n  \\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i -= 1) {\\n      const [row, col, delay] = queue.shift();\\n      \\n      for (const [rDiff, cDiff] of directions) {\\n        const rNext = row + rDiff;\\n        const cNext = col + cDiff;\\n        \\n        if (grid[rNext]?.[cNext] === undefined || grid[rNext][cNext] === 2) continue;\\n        \\n\\t\\tconst isEnd = rNext === m - 1 && cNext === n -1 ;\\n        const additionalTimeNeeded = isEnd ? 0 : 1;\\n\\t\\tconst maxPossibleDelay = timeToFire[rNext][cNext] >= 0\\n\\t\\t\\t? timeToFire[rNext][cNext] - time - additionalTimeNeeded\\n\\t\\t\\t: MAX\\n        const nextDelay = Math.min(delay, maxPossibleDelay);\\n\\t\\tconst visited = maxDelay[rNext][cNext] >= 0;\\n        \\n        if (nextDelay < 0 || (visited && maxDelay[rNext][cNext] >= nextDelay)) continue;\\n        \\n        maxDelay[rNext][cNext] = nextDelay;\\n        queue.push([rNext, cNext, nextDelay]);\\n      }\\n    }\\n    \\n    time += 1;\\n  }\\n  \\n  return maxDelay[m - 1][n - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995532,
                "title": "go-bfs-binary-search-explanation-commented-code",
                "content": "The idea is to let the person and fire move simultaneously, and check whether the person survives.\\n\\nThis is done with BFS. Each step, the person moves into any area where there is no fire currently, and the person has not visited before. If the person reaches the end, then the person survives.\\n\\nNote that since the fire moves after the person, it is possible for fire to cover an area where a person went in the prior loop. So, we must check whether fire is covering the area the person is currently in within the BFS loop.\\n\\nAssuming that the person waits a number of turns, then the cases are:\\n\\n1. Person cannot beat the fire after waiting no turns at all => return -1\\n2. Person survives after waiting `m*n` turns => return 1e9 (fire must be unable to reach the end)\\n3. Person dies if waiting >= some number of turns\\n\\nFor the third case, perform binary search. \\n\\n```go\\n\\nconst (\\n\\tfire   = 1 << 0\\n\\twall   = 1 << 1\\n\\tperson = 1 << 2\\n)\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tgrid[0][0] |= person\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\t// Bounds / wall check\\n\\tok := func(i, j int) bool {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n && grid[i][j]&wall == 0\\n\\t}\\n\\n\\t// Collect original fire positions\\n\\torigFires := [][2]int{}\\n\\tstate := make([][]int, m)\\n\\tfor i := range grid {\\n\\t\\tstate[i] = make([]int, n)\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tif grid[i][j] == fire {\\n\\t\\t\\t\\torigFires = append(origFires, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tcurrFire := make([][2]int, len(origFires))\\n\\tnextFire := make([][2]int, 0, len(origFires))\\n\\tcurrPerson := [][2]int{}\\n\\tnextPerson := [][2]int{}\\n\\n\\tdirs := [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\n\\t// Check whether a person can reach the end after waiting a number of turns\\n\\tsurvivesAfterTurns := func(turnsToWait int) bool {\\n\\t\\t// Reset state\\n\\t\\tfor i := range grid {\\n\\t\\t\\tcopy(state[i], grid[i])\\n\\t\\t}\\n\\t\\tcurrFire = currFire[:len(origFires)]\\n\\t\\tcurrPerson = currPerson[:0]\\n\\t\\tcopy(currFire, origFires)\\n\\n\\t\\t// Perform BFS\\n\\t\\t// If there is no place left for the fire or person to move, then the person\\n\\t\\t// will die (by virtue of being stuck somewhere)\\n\\t\\t// Note that t<=turnsToWait+1 is necessary because the person is only added\\n\\t\\t// to `currPerson` after turnsToWait+1\\n\\t\\tfor t := 1; len(currFire) > 0 || len(currPerson) > 0 || t <= turnsToWait+1; t++ {\\n\\t\\t\\tnextPerson = nextPerson[:0]\\n\\t\\t\\tnextFire = nextFire[:0]\\n\\t\\t\\tif t == turnsToWait+1 {\\n\\t\\t\\t\\tcurrPerson = append(currPerson, [2]int{0, 0})\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each person position one step further\\n\\t\\t\\tfor _, p := range currPerson {\\n\\t\\t\\t\\t// Note that the fire can cover the person\\'s current position due to the\\n\\t\\t\\t\\t// ordering of the current and next loop:\\n\\t\\t\\t\\tif state[p[0]][p[1]]&fire > 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := p[0]+d[0], p[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&person > 0 || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person survives\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= person\\n\\t\\t\\t\\t\\tnextPerson = append(nextPerson, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each fire one step further\\n\\t\\t\\tfor _, f := range currFire {\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := f[0]+d[0], f[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person dies\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= fire\\n\\t\\t\\t\\t\\tnextFire = append(nextFire, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnextFire, currFire = currFire, nextFire\\n\\t\\t\\tnextPerson, currPerson = currPerson, nextPerson\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\t// Fast-track\\n\\tif !survivesAfterTurns(0) { // person will never survive\\n\\t\\treturn -1\\n\\t}\\n\\tif survivesAfterTurns(m * n) { // person cannot die\\n\\t\\treturn 1e9\\n\\t}\\n\\n\\t// Perform binary search, finding the lowest number of turns which results in\\n\\t// the death of the person.\\n\\tlo, hi := 0, m*n\\n\\tfor lo < hi {\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tif survivesAfterTurns(mid) {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t} else {\\n\\t\\t\\thi = mid\\n\\t\\t}\\n\\t}\\n\\treturn lo - 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n\\nconst (\\n\\tfire   = 1 << 0\\n\\twall   = 1 << 1\\n\\tperson = 1 << 2\\n)\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tgrid[0][0] |= person\\n\\n\\tm, n := len(grid), len(grid[0])\\n\\n\\t// Bounds / wall check\\n\\tok := func(i, j int) bool {\\n\\t\\treturn i >= 0 && j >= 0 && i < m && j < n && grid[i][j]&wall == 0\\n\\t}\\n\\n\\t// Collect original fire positions\\n\\torigFires := [][2]int{}\\n\\tstate := make([][]int, m)\\n\\tfor i := range grid {\\n\\t\\tstate[i] = make([]int, n)\\n\\t\\tfor j := range grid[i] {\\n\\t\\t\\tif grid[i][j] == fire {\\n\\t\\t\\t\\torigFires = append(origFires, [2]int{i, j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tcurrFire := make([][2]int, len(origFires))\\n\\tnextFire := make([][2]int, 0, len(origFires))\\n\\tcurrPerson := [][2]int{}\\n\\tnextPerson := [][2]int{}\\n\\n\\tdirs := [][]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}\\n\\n\\t// Check whether a person can reach the end after waiting a number of turns\\n\\tsurvivesAfterTurns := func(turnsToWait int) bool {\\n\\t\\t// Reset state\\n\\t\\tfor i := range grid {\\n\\t\\t\\tcopy(state[i], grid[i])\\n\\t\\t}\\n\\t\\tcurrFire = currFire[:len(origFires)]\\n\\t\\tcurrPerson = currPerson[:0]\\n\\t\\tcopy(currFire, origFires)\\n\\n\\t\\t// Perform BFS\\n\\t\\t// If there is no place left for the fire or person to move, then the person\\n\\t\\t// will die (by virtue of being stuck somewhere)\\n\\t\\t// Note that t<=turnsToWait+1 is necessary because the person is only added\\n\\t\\t// to `currPerson` after turnsToWait+1\\n\\t\\tfor t := 1; len(currFire) > 0 || len(currPerson) > 0 || t <= turnsToWait+1; t++ {\\n\\t\\t\\tnextPerson = nextPerson[:0]\\n\\t\\t\\tnextFire = nextFire[:0]\\n\\t\\t\\tif t == turnsToWait+1 {\\n\\t\\t\\t\\tcurrPerson = append(currPerson, [2]int{0, 0})\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each person position one step further\\n\\t\\t\\tfor _, p := range currPerson {\\n\\t\\t\\t\\t// Note that the fire can cover the person\\'s current position due to the\\n\\t\\t\\t\\t// ordering of the current and next loop:\\n\\t\\t\\t\\tif state[p[0]][p[1]]&fire > 0 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := p[0]+d[0], p[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&person > 0 || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person survives\\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= person\\n\\t\\t\\t\\t\\tnextPerson = append(nextPerson, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move each fire one step further\\n\\t\\t\\tfor _, f := range currFire {\\n\\t\\t\\t\\tfor _, d := range dirs {\\n\\t\\t\\t\\t\\ti, j := f[0]+d[0], f[1]+d[1]\\n\\t\\t\\t\\t\\tif !ok(i, j) || state[i][j]&fire > 0 {\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif i == m-1 && j == n-1 { // Reached the end => person dies\\n\\t\\t\\t\\t\\t\\treturn false\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstate[i][j] |= fire\\n\\t\\t\\t\\t\\tnextFire = append(nextFire, [2]int{i, j})\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnextFire, currFire = currFire, nextFire\\n\\t\\t\\tnextPerson, currPerson = currPerson, nextPerson\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\n\\t// Fast-track\\n\\tif !survivesAfterTurns(0) { // person will never survive\\n\\t\\treturn -1\\n\\t}\\n\\tif survivesAfterTurns(m * n) { // person cannot die\\n\\t\\treturn 1e9\\n\\t}\\n\\n\\t// Perform binary search, finding the lowest number of turns which results in\\n\\t// the death of the person.\\n\\tlo, hi := 0, m*n\\n\\tfor lo < hi {\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tif survivesAfterTurns(mid) {\\n\\t\\t\\tlo = mid + 1\\n\\t\\t} else {\\n\\t\\t\\thi = mid\\n\\t\\t}\\n\\t}\\n\\treturn lo - 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995225,
                "title": "java-binary-search-bfs-concise-and-elegant",
                "content": "```\\nclass Solution {\\n    private static final int[] x = new int[]{1, 0, -1, 0};\\n    private static final int[] y = new int[]{0, 1, 0, -1};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int l = 0;\\n        int h = 1000000000;\\n        \\n        int ans = -1;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n    \\n            if(canPass(m, grid)){\\n                ans = m;\\n                l = m+1;\\n            }else h = m-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean canPass(int time, int[][] grid){\\n        \\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n        int[][] visited = new int[grid.length][grid[0].length];\\n        \\n        Queue<Integer> fireQueue = spreadFire(time, visited, grid);\\n        if(visited[R-1][C-1] == 1 || visited[0][0] == 1) return false; // House already on fire \\n            \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0][0]++;\\n        \\n        int currStep = 0;\\n        while(!queue.isEmpty()){\\n            \\n            spreadFireOnce(fireQueue, visited, grid);\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR == R-1 && newC == C-1) return true;\\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C  || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n            \\n            if(visited[R-1][C-1] == 1) return false; // House already on fire \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private Queue spreadFire(int time, int[][] visited, int[][] grid){\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                if(grid[i][j] == 1){\\n                    queue.offer(i*C + j);\\n                }\\n            }\\n        }\\n        \\n        while(time > 0 && !queue.isEmpty()){\\n            time--;\\n            spreadFireOnce(queue, visited, grid);\\n        }\\n        \\n        return queue;\\n    }\\n    \\n    private void spreadFireOnce(Queue<Integer> queue, int[][] visited, int[][] grid){\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n        \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[] x = new int[]{1, 0, -1, 0};\\n    private static final int[] y = new int[]{0, 1, 0, -1};\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int l = 0;\\n        int h = 1000000000;\\n        \\n        int ans = -1;\\n        while(l <= h){\\n            int m = l + (h-l)/2;\\n    \\n            if(canPass(m, grid)){\\n                ans = m;\\n                l = m+1;\\n            }else h = m-1;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean canPass(int time, int[][] grid){\\n        \\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n        int[][] visited = new int[grid.length][grid[0].length];\\n        \\n        Queue<Integer> fireQueue = spreadFire(time, visited, grid);\\n        if(visited[R-1][C-1] == 1 || visited[0][0] == 1) return false; // House already on fire \\n            \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        visited[0][0]++;\\n        \\n        int currStep = 0;\\n        while(!queue.isEmpty()){\\n            \\n            spreadFireOnce(fireQueue, visited, grid);\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR == R-1 && newC == C-1) return true;\\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C  || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n            \\n            if(visited[R-1][C-1] == 1) return false; // House already on fire \\n        }\\n        \\n        return false;\\n    }\\n    \\n    private Queue spreadFire(int time, int[][] visited, int[][] grid){\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        for(int i=0; i<R; i++){\\n            for(int j=0; j<C; j++){\\n                if(grid[i][j] == 1){\\n                    queue.offer(i*C + j);\\n                }\\n            }\\n        }\\n        \\n        while(time > 0 && !queue.isEmpty()){\\n            time--;\\n            spreadFireOnce(queue, visited, grid);\\n        }\\n        \\n        return queue;\\n    }\\n    \\n    private void spreadFireOnce(Queue<Integer> queue, int[][] visited, int[][] grid){\\n        int R = grid.length;\\n        int C = grid[0].length;\\n        \\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int cell = queue.poll();\\n                int cellR = cell/C;\\n                int cellC = cell%C;\\n                \\n                for(int d=0; d<4; d++){\\n                    int newR = cellR + x[d];\\n                    int newC = cellC + y[d];\\n                    \\n                    if(newR < 0 || newR >= R || newC < 0 || newC >= C || grid[newR][newC] == 2 || visited[newR][newC] == 1) continue;\\n                    \\n                    visited[newR][newC]++;\\n                    queue.offer(newR*C + newC);\\n                }\\n            }\\n        \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995131,
                "title": "python-bfs-max-heap",
                "content": "**Explanation**:\\n**step1**: First calculate the shortest time that a fire reaches a cell using plain BFS\\n**step2**: Do BFS for the person starting at (0, 0), but we also maintain the closest to fire of those cells in the path, using the steps we took and the time the fire takes to reach the cell. Using max heap, we know its through that cell that you can wait the longest.\\n```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\t# store the fastest time the fire reaches the cell i, j\\n\\tfire = [[inf]*n for _ in range(m)]\\n\\tdr = (1, 0, -1, 0, 1)\\n\\t# lambda fucntion to check for indices out of grid \\n\\tvalid = lambda r, c: 0 <= r < m and 0 <= c < n\\n\\n\\t# do BFS\\n\\tq = deque()\\n\\tfor i, j in product(range(m), range(n)):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tq.append([i, j])\\n\\t\\t\\tfire[i][j] = 0\\n\\tsize = len(q); steps = 0\\n\\twhile q:\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tr, c = q.popleft()\\n\\t\\t\\tfire[r][c] = steps\\n\\t\\t\\tfor d in range(4):\\n\\t\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\t\\tif not valid(newr,newc) or fire[newr][newc] != inf or grid[newr][newc] == 2:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tq.append([newr, newc])\\n\\t\\tsize, steps = len(q), steps + 1\\n\\n\\t# dfs BFS for the person starting at [f, 0, 0, 0]: [f, r, c, s] => f - steps away from a fire when the person reaches cell r, c, with a step of s\\n\\theap = [[-fire[0][0]+1, 0, 0, 0]]\\n\\tvisited = [[False]*n for _ in range(m)]\\n\\twhile heap:\\n\\t\\tfr, r, c, steps = heappop(heap)\\n\\t\\t# fire reaches faster than person, ignore this path\\n\\t\\tif fire[r][c] < steps:\\n\\t\\t\\tcontinue\\n\\t\\t# reached the house \\n\\t\\tif (r, c) == (m-1, n-1):\\n\\t\\t\\tif fr == -inf:\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn -fr\\n\\t\\t# for non house cell, the person should pass the cell earlier if both reached equal, ignore this path\\n\\t\\tif steps == fire[r][c]:\\n\\t\\t\\tcontinue\\n\\t\\tvisited[r][c] = True\\n\\t\\tfor d in range(4):\\n\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\tif not valid(newr, newc) or visited[newr][newc] or grid[newr][newc] == 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t# heappush this path, but updating fr, the shortest nearby fire on the path, used max heap, that\\'s why max(-ve dist)\\n\\t\\t\\theappush(heap, [max(fr, -(fire[newr][newc] - steps - 1) + (0 if (newr, newc) == (m-1, n-1) else 1)), newr, newc, steps + 1])\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\t# store the fastest time the fire reaches the cell i, j\\n\\tfire = [[inf]*n for _ in range(m)]\\n\\tdr = (1, 0, -1, 0, 1)\\n\\t# lambda fucntion to check for indices out of grid \\n\\tvalid = lambda r, c: 0 <= r < m and 0 <= c < n\\n\\n\\t# do BFS\\n\\tq = deque()\\n\\tfor i, j in product(range(m), range(n)):\\n\\t\\tif grid[i][j] == 1:\\n\\t\\t\\tq.append([i, j])\\n\\t\\t\\tfire[i][j] = 0\\n\\tsize = len(q); steps = 0\\n\\twhile q:\\n\\t\\tfor _ in range(size):\\n\\t\\t\\tr, c = q.popleft()\\n\\t\\t\\tfire[r][c] = steps\\n\\t\\t\\tfor d in range(4):\\n\\t\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\t\\tif not valid(newr,newc) or fire[newr][newc] != inf or grid[newr][newc] == 2:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tq.append([newr, newc])\\n\\t\\tsize, steps = len(q), steps + 1\\n\\n\\t# dfs BFS for the person starting at [f, 0, 0, 0]: [f, r, c, s] => f - steps away from a fire when the person reaches cell r, c, with a step of s\\n\\theap = [[-fire[0][0]+1, 0, 0, 0]]\\n\\tvisited = [[False]*n for _ in range(m)]\\n\\twhile heap:\\n\\t\\tfr, r, c, steps = heappop(heap)\\n\\t\\t# fire reaches faster than person, ignore this path\\n\\t\\tif fire[r][c] < steps:\\n\\t\\t\\tcontinue\\n\\t\\t# reached the house \\n\\t\\tif (r, c) == (m-1, n-1):\\n\\t\\t\\tif fr == -inf:\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn -fr\\n\\t\\t# for non house cell, the person should pass the cell earlier if both reached equal, ignore this path\\n\\t\\tif steps == fire[r][c]:\\n\\t\\t\\tcontinue\\n\\t\\tvisited[r][c] = True\\n\\t\\tfor d in range(4):\\n\\t\\t\\tnewr, newc = r + dr[d], c + dr[d + 1]\\n\\t\\t\\tif not valid(newr, newc) or visited[newr][newc] or grid[newr][newc] == 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t# heappush this path, but updating fr, the shortest nearby fire on the path, used max heap, that\\'s why max(-ve dist)\\n\\t\\t\\theappush(heap, [max(fr, -(fire[newr][newc] - steps - 1) + (0 if (newr, newc) == (m-1, n-1) else 1)), newr, newc, steps + 1])\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994895,
                "title": "c-code-with-comments-binary-search-bfs",
                "content": "## **The Basic Approach**\\nGiven that we have waited `k` minutes, can we determine if we\\'d be able to reach the safehouse now. We use a predicate function that answers this question (more on that later).\\n  Now, we know that the grid-size is `m * n`. So, the time range of interest for us is `m * n` (plus some to indicate infinity) minutes. We binary search over this range to find the largest `k` that lets the person reach the Safehouse.\\n\\n### **What happens in the predicate function?**\\n- We use two queues (`person` and `fire` in code) to store the frontier of the possible positions that the person can occupy and the frontier of the expanding fires, repectively.\\n- We let the fire rage for `k` minutes i.e. expand its frontier (`fire`) outwards. If it reaches the Person at `(0, 0)` or burnes the safehouse at `(m-1, n-1)`, we lose.\\n- Then we let the `fire` frontier and the person\\'s possible positions frontier (`person`) expand minute by minute\\n\\t- If the person reaches the safe house, we win\\n\\t- If the fire leaves no possible positions left for the person OR burns the safe-house before the person can get to it, we lose\\n\\nThe code below essentially follows this approach:\\n```\\nclass Solution {\\n    constexpr static int GRASS = 0;\\n    constexpr static int FIRE = 1;\\n    constexpr static int WALL = 2;\\n    constexpr static int PERSON = 4;\\n\\n    struct pos{\\n        int r, c;\\n    };\\n\\n    bool can_reach_after_mins(int k, vector<vector<int>> grid, queue<pos> person, queue<pos> fire) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        auto is_valid_pos = [&](int r, int c) {\\n            return r >= 0 && r < m && c >= 0 && c < n;\\n        };\\n\\n        // To explore neigbours in E, W, N, S directions\\n        // for i in 0..4: d[i] is step for row and d[i+1] is for column\\n        //                      N    E    S    W\\n        constexpr int d[] = {-1,  0,   1,   0,  -1};\\n\\n        // Must be signed\\n        int fire_sz, person_sz;\\n\\n        // Let the fire rage for k minutes, person waits at (0,0)\\n        while(k --> 0 && (fire_sz = fire.size())) {\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Person got burned while waiting or Safehouse got burned while waiting\\n                    if(grid[nr][nc] == PERSON || (nr == m-1 && nc ==  n-1))\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n        // The fire and the possible positions that person can move to\\n        // both step with time, first the person and then the fire\\n        // We take this order because problem states that if in the same time-step\\n        // the person reached Safe-house that the fire reaches the Safe-house,\\n        // person is still considered safe.\\n        //   Because we\\'re not taking things simultaneusly, it might happen that\\n        // the fire is able to burn one of the potential positons that the person\\n        // can move. So, we have to check each time.\\n        while((person_sz = person.size())) {\\n            // first the person moves\\n            while(person_sz --> 0) {\\n                auto [r, c] = person.front();\\n                person.pop();\\n\\n                // The fire burnt this potential position in the last step,\\n                // can\\'t use it anymore :(\\n                if(grid[r][c] == FIRE)\\n                    continue;\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] != GRASS)\\n                        continue;\\n\\n                    // Reached Safehouse!\\n                    // We can be sure that the fire hasn\\'t burnt it in the previous step\\n                    // because then we\\'d already have returned (with failure)!\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return true;\\n\\n                    person.push({nr, nc});\\n                    grid[nr][nc] = PERSON;\\n                }\\n            }\\n\\n            // Now the fire moves\\n            fire_sz = fire.size();\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Fire burnt Safe-House, we\\'ve lost :(\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }            \\n            }\\n        }\\n\\n        // If we haven\\'t reached Safe-House yet, we can\\'t ever!\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        // Degenarate cases:\\n        // Person is already on fire or the Safehouse is already burnt\\n        if(grid[0][0] == FIRE || grid[m-1][n-1] == FIRE)\\n            return -1;\\n        \\n        // fire stores the expanding frontier of fire\\n        // person stores the expanding frontier of potential positions that person can be at\\n        queue<pos> fire, person;\\n        \\n        // Place person at starting position and update frontier\\n        grid[0][0] = PERSON;\\n        person.push({0, 0});\\n\\n        // Update frontier for fire\\n        for(int r = 0; r < m; r++) {\\n            for(int c = 0; c < n; c++) {\\n                if(grid[r][c] == FIRE)\\n                    fire.push({r, c});\\n            }\\n        }\\n\\n        int lo = 0;\\n        // We keep this higher than m*n to distinguish the case when we can wait\\n        // infinite amount of time.\\n        int hi = m * n + 5;\\n\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2;\\n            if(can_reach_after_mins(mid, grid, person, fire)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        // lo is now possibly the largest amount of time between [0, m*n + 5]\\n        // that person can wait. Possibly, so we need to verify at \"lo\" one last time.\\n        if(can_reach_after_mins(lo, grid, person,fire)) {\\n            // The infinity case!\\n            if(lo > m * n)\\n                return 1\\'000\\'000\\'000;\\n            \\n            // normal case\\n            return lo;\\n        }\\n\\n        // Impossible case\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    constexpr static int GRASS = 0;\\n    constexpr static int FIRE = 1;\\n    constexpr static int WALL = 2;\\n    constexpr static int PERSON = 4;\\n\\n    struct pos{\\n        int r, c;\\n    };\\n\\n    bool can_reach_after_mins(int k, vector<vector<int>> grid, queue<pos> person, queue<pos> fire) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        auto is_valid_pos = [&](int r, int c) {\\n            return r >= 0 && r < m && c >= 0 && c < n;\\n        };\\n\\n        // To explore neigbours in E, W, N, S directions\\n        // for i in 0..4: d[i] is step for row and d[i+1] is for column\\n        //                      N    E    S    W\\n        constexpr int d[] = {-1,  0,   1,   0,  -1};\\n\\n        // Must be signed\\n        int fire_sz, person_sz;\\n\\n        // Let the fire rage for k minutes, person waits at (0,0)\\n        while(k --> 0 && (fire_sz = fire.size())) {\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Person got burned while waiting or Safehouse got burned while waiting\\n                    if(grid[nr][nc] == PERSON || (nr == m-1 && nc ==  n-1))\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n        // The fire and the possible positions that person can move to\\n        // both step with time, first the person and then the fire\\n        // We take this order because problem states that if in the same time-step\\n        // the person reached Safe-house that the fire reaches the Safe-house,\\n        // person is still considered safe.\\n        //   Because we\\'re not taking things simultaneusly, it might happen that\\n        // the fire is able to burn one of the potential positons that the person\\n        // can move. So, we have to check each time.\\n        while((person_sz = person.size())) {\\n            // first the person moves\\n            while(person_sz --> 0) {\\n                auto [r, c] = person.front();\\n                person.pop();\\n\\n                // The fire burnt this potential position in the last step,\\n                // can\\'t use it anymore :(\\n                if(grid[r][c] == FIRE)\\n                    continue;\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] != GRASS)\\n                        continue;\\n\\n                    // Reached Safehouse!\\n                    // We can be sure that the fire hasn\\'t burnt it in the previous step\\n                    // because then we\\'d already have returned (with failure)!\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return true;\\n\\n                    person.push({nr, nc});\\n                    grid[nr][nc] = PERSON;\\n                }\\n            }\\n\\n            // Now the fire moves\\n            fire_sz = fire.size();\\n            while(fire_sz --> 0) {\\n                auto [r, c] = fire.front();\\n                fire.pop();\\n\\n                for(int i = 0; i < 4; i++) {\\n                    auto nr = r + d[i];\\n                    auto nc = c + d[i+1];\\n\\n                    if(!is_valid_pos(nr, nc) || grid[nr][nc] == FIRE || grid[nr][nc] == WALL)\\n                        continue;\\n\\n                    // Fire burnt Safe-House, we\\'ve lost :(\\n                    if(nr == m - 1 && nc == n - 1)\\n                        return false;\\n\\n                    grid[nr][nc] = FIRE;\\n                    fire.push({nr,nc});\\n                }            \\n            }\\n        }\\n\\n        // If we haven\\'t reached Safe-House yet, we can\\'t ever!\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const auto m = grid.size();\\n        const auto n = grid[0].size();\\n\\n        // Degenarate cases:\\n        // Person is already on fire or the Safehouse is already burnt\\n        if(grid[0][0] == FIRE || grid[m-1][n-1] == FIRE)\\n            return -1;\\n        \\n        // fire stores the expanding frontier of fire\\n        // person stores the expanding frontier of potential positions that person can be at\\n        queue<pos> fire, person;\\n        \\n        // Place person at starting position and update frontier\\n        grid[0][0] = PERSON;\\n        person.push({0, 0});\\n\\n        // Update frontier for fire\\n        for(int r = 0; r < m; r++) {\\n            for(int c = 0; c < n; c++) {\\n                if(grid[r][c] == FIRE)\\n                    fire.push({r, c});\\n            }\\n        }\\n\\n        int lo = 0;\\n        // We keep this higher than m*n to distinguish the case when we can wait\\n        // infinite amount of time.\\n        int hi = m * n + 5;\\n\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo + 1)/2;\\n            if(can_reach_after_mins(mid, grid, person, fire)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        // lo is now possibly the largest amount of time between [0, m*n + 5]\\n        // that person can wait. Possibly, so we need to verify at \"lo\" one last time.\\n        if(can_reach_after_mins(lo, grid, person,fire)) {\\n            // The infinity case!\\n            if(lo > m * n)\\n                return 1\\'000\\'000\\'000;\\n            \\n            // normal case\\n            return lo;\\n        }\\n\\n        // Impossible case\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994654,
                "title": "binary-search-bfs-o-n-m-log-1e9",
                "content": "First for every grass cell find the smallest time the fire will get on it using bfs. Secondly use binary search over the range to calculate whether we can wait that much amount of time before we start moving from {0, 0}\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long>> a;\\n    int n, m;\\n    \\n    bool good(long mn) {\\n        vector<vector<bool>> vis(n, vector<bool> (m, 0));\\n        vis[0][0] = 1;\\n        \\n        queue<array<long, 3>> q;\\n        q.push({0, 0, mn});\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            long dis = q.front()[2];\\n            \\n            q.pop();\\n            \\n            if(x == n - 1 and y == m - 1) {\\n                return 1;\\n            }\\n            if(a[x][y] <= dis) {\\n                continue;\\n            }\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and !vis[i][j] and a[x][y] != -1 and dis + 1 <= a[i][j]) {\\n                    q.push({i, j, dis + 1});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        \\n        a.resize(n, vector<long> (m, 1e10));\\n        \\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(grid[i][j] == 1) {\\n                    a[i][j] = 0;\\n                    q.push({i, j});\\n                } else if(grid[i][j] == 2) {\\n                    a[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and a[i][j] != -1 and a[x][y] + 1 < a[i][j]) {\\n                    a[i][j] = a[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        long l = 0, r = 1e9, best = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r - l) / 2;\\n            if(good(mid)) {\\n                best = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long>> a;\\n    int n, m;\\n    \\n    bool good(long mn) {\\n        vector<vector<bool>> vis(n, vector<bool> (m, 0));\\n        vis[0][0] = 1;\\n        \\n        queue<array<long, 3>> q;\\n        q.push({0, 0, mn});\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            long dis = q.front()[2];\\n            \\n            q.pop();\\n            \\n            if(x == n - 1 and y == m - 1) {\\n                return 1;\\n            }\\n            if(a[x][y] <= dis) {\\n                continue;\\n            }\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and !vis[i][j] and a[x][y] != -1 and dis + 1 <= a[i][j]) {\\n                    q.push({i, j, dis + 1});\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        \\n        a.resize(n, vector<long> (m, 1e10));\\n        \\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < m; ++j) {\\n                if(grid[i][j] == 1) {\\n                    a[i][j] = 0;\\n                    q.push({i, j});\\n                } else if(grid[i][j] == 2) {\\n                    a[i][j] = -1;\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            int dx[] = {1, -1, 0, 0};\\n            int dy[] = {0, 0, 1, -1};\\n            \\n            for(int t = 0; t < 4; ++t) {\\n                int i = x + dx[t];\\n                int j = y + dy[t];\\n                \\n                if(min(i, j) >= 0 and i < n and j < m and a[i][j] != -1 and a[x][y] + 1 < a[i][j]) {\\n                    a[i][j] = a[x][y] + 1;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        long l = 0, r = 1e9, best = -1;\\n        \\n        while(l <= r) {\\n            long mid = l + (r - l) / 2;\\n            if(good(mid)) {\\n                best = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039752,
                "title": "java-easiest-solution-bfs-binary-search-run-time-23-ms",
                "content": "# Intuition\\nMost easiest solution.it is extremely easy to understand with classic BFS & Binary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)log(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n     private static boolean isPossible(int[][] grid, int[][] fireTime, int wait_time) {\\n\\t    \\t \\n            \\n            boolean[][] visited = new boolean[m][n];\\n\\t    \\tQueue<int[]> q = new LinkedList<>();\\n\\t    \\tint curTime=wait_time;\\n\\t         q.add(new int[]{0,0});\\n            \\n\\t         \\n\\t         visited[0][0] = true;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n                 curTime++;\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              int cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny])continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && fireTime[nx][ny]>=curTime)return true;\\n                      if(fireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=true;;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    public int maximumMinutes(int[][] grid) {\\n          m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint fireTime[][]=new int[m][n];\\n\\t    \\tfor(int ft[]:fireTime) {\\n\\t    \\t\\tArrays.fill(ft, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\tint curTime=0;\\n\\t    \\tQueue<int[]>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t    \\t\\t\\t\\tfireTime[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\tcurTime++;\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tfireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t        fireTime[nx][ny]=curTime;\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=(m*n)+1;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,fireTime,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans==m*n+1?(int)1e9:ans;\\n\\t    }\\n\\t    \\n\\t   \\n\\t   \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n     private static boolean isPossible(int[][] grid, int[][] fireTime, int wait_time) {\\n\\t    \\t \\n            \\n            boolean[][] visited = new boolean[m][n];\\n\\t    \\tQueue<int[]> q = new LinkedList<>();\\n\\t    \\tint curTime=wait_time;\\n\\t         q.add(new int[]{0,0});\\n            \\n\\t         \\n\\t         visited[0][0] = true;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n                 curTime++;\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              int cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny])continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && fireTime[nx][ny]>=curTime)return true;\\n                      if(fireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=true;;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    public int maximumMinutes(int[][] grid) {\\n          m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint fireTime[][]=new int[m][n];\\n\\t    \\tfor(int ft[]:fireTime) {\\n\\t    \\t\\tArrays.fill(ft, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\tint curTime=0;\\n\\t    \\tQueue<int[]>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new int[]{i,j});\\n\\t    \\t\\t\\t\\tfireTime[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\tcurTime++;\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint cur[] = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=cur[0]+dir[0];\\n\\t            \\t  int ny=cur[1]+dir[1];\\n\\t            \\t  \\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tfireTime[nx][ny]<=curTime)continue;\\n\\t    \\t\\t\\t\\t        fireTime[nx][ny]=curTime;\\n\\t    \\t\\t\\t\\tq.add(new int[]{nx,ny});\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=(m*n)+1;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,fireTime,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans==m*n+1?(int)1e9:ans;\\n\\t    }\\n\\t    \\n\\t   \\n\\t   \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039436,
                "title": "java-easiest-solution-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   static class Tuple{\\n\\t        int row;\\n\\t        int col;\\n\\t        int time;\\n\\n\\t        public Tuple(int row,int col,int time) {\\n\\t            this.row=row;\\n\\t            this.col=col;\\n\\t            this.time=time;\\n\\t        }\\n\\t    }\\n\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n    m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint dist[][]=new int[m][n];\\n\\t    \\tfor(int r[]:dist) {\\n\\t    \\t\\tArrays.fill(r, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\tQueue<Tuple>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new Tuple(i,j,0));\\n\\t    \\t\\t\\t\\tdist[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\t\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\tTuple it=q.poll();\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tfor(int dir[]:dirs) {\\n\\t    \\t\\t\\t\\tint nx=it.row+dir[0];\\n\\t    \\t\\t\\t\\tint ny=it.col+dir[1];\\n\\t    \\t\\t\\t\\tint time=it.time;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tdist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\tdist[nx][ny]=time+1;\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=1_000_000_000;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,dist,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans;\\n\\t    }\\n\\t    \\n\\t    private static boolean isPossible(int[][] grid, int[][] dist, int wait_time) {\\n\\t    \\t \\n\\t    \\tQueue<Tuple> q = new LinkedList<>();\\n\\t    \\t\\n\\t         q.add(new Tuple(0, 0, wait_time));\\n\\n\\t         int[][] visited = new int[m][n];\\n\\t         visited[0][0] = 1;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              Tuple it = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=it.row+dir[0];\\n\\t            \\t  int ny=it.col+dir[1];\\n\\t            \\t  int time=it.time;\\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny]==1)continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && dist[nx][ny]>=time+1)return true;\\n                      if(dist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=1;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   static class Tuple{\\n\\t        int row;\\n\\t        int col;\\n\\t        int time;\\n\\n\\t        public Tuple(int row,int col,int time) {\\n\\t            this.row=row;\\n\\t            this.col=col;\\n\\t            this.time=time;\\n\\t        }\\n\\t    }\\n\\n\\t\\n\\tstatic int m,n;\\n\\tstatic int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n    m=grid.length;\\n\\t    \\tn=grid[0].length;\\n\\t    \\t\\n\\t    \\tint dist[][]=new int[m][n];\\n\\t    \\tfor(int r[]:dist) {\\n\\t    \\t\\tArrays.fill(r, Integer.MAX_VALUE);\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\tQueue<Tuple>q=new LinkedList<>();\\n\\t    \\t\\n\\t    \\tfor(int i=0;i<m;i++) {\\n\\t    \\t\\tfor(int j=0;j<n;j++) {\\n\\t    \\t\\t\\tif(grid[i][j]==1){\\n\\t    \\t\\t\\t\\tq.add(new Tuple(i,j,0));\\n\\t    \\t\\t\\t\\tdist[i][j]=0;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\n\\t    \\twhile(!q.isEmpty()) {\\n\\t    \\t\\tint size=q.size();\\n\\t    \\t\\t\\n\\t    \\t\\twhile(size-->0) {\\n\\t    \\t\\t\\tTuple it=q.poll();\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tfor(int dir[]:dirs) {\\n\\t    \\t\\t\\t\\tint nx=it.row+dir[0];\\n\\t    \\t\\t\\t\\tint ny=it.col+dir[1];\\n\\t    \\t\\t\\t\\tint time=it.time;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tif(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||\\n\\t    \\t\\t\\t\\t\\t\\tdist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\tdist[nx][ny]=time+1;\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t}\\n\\t    \\t\\t\\n\\t    \\t\\tint left=0;\\n\\t    \\t\\tint right=1_000_000_000;\\n\\t    \\t\\tint ans=-1;\\n\\t    \\t\\t\\n\\t    \\t\\twhile(left<=right) {\\n\\t    \\t\\t\\t\\n\\t    \\t\\t\\tint mid=left+(right-left)/2;\\n\\t    \\t\\t\\tif(isPossible(grid,dist,mid)) {\\n\\t    \\t\\t\\t\\tans=mid;\\n\\t    \\t\\t\\t\\tleft=mid+1;\\n\\t    \\t\\t\\t}else \\n\\t    \\t\\t\\t\\tright=mid-1;\\n\\t    \\t\\t\\t\\n\\t    \\t\\t}\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\t\\n\\t    \\treturn ans;\\n\\t    }\\n\\t    \\n\\t    private static boolean isPossible(int[][] grid, int[][] dist, int wait_time) {\\n\\t    \\t \\n\\t    \\tQueue<Tuple> q = new LinkedList<>();\\n\\t    \\t\\n\\t         q.add(new Tuple(0, 0, wait_time));\\n\\n\\t         int[][] visited = new int[m][n];\\n\\t         visited[0][0] = 1;\\n\\n\\t         while (!q.isEmpty()) {\\n\\t        \\t int size=q.size();\\n\\t        \\t while(size-->0) {\\n\\t        \\t\\t \\n\\t              Tuple it = q.poll();\\n\\t              for(int dir[]:dirs) {\\n\\t            \\t  int nx=it.row+dir[0];\\n\\t            \\t  int ny=it.col+dir[1];\\n\\t            \\t  int time=it.time;\\n\\t            \\t  if(nx<0 || nx>=m || ny<0 || ny>=n || grid[nx][ny]==2||visited[nx][ny]==1)continue;\\n\\t            \\t  if(nx==m-1 && ny==n-1 && dist[nx][ny]>=time+1)return true;\\n                      if(dist[nx][ny]<=time+1)continue;\\n\\t    \\t\\t\\t\\t\\n\\t    \\t\\t\\t\\tq.add(new Tuple(nx,ny,1+time));\\n\\t    \\t\\t\\t\\tvisited[nx][ny]=1;\\n\\t            \\t  \\n\\t              }\\n\\n\\t            }\\n\\t         }\\n\\t        \\n\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034442,
                "title": "java-simple-solution-2-level-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int m,n;\\n   int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        \\n    m=grid.length;\\n    n=grid[0].length;\\n    int [][]fire = new int[m][n];\\n    int [][]people = new int[m][n];\\n    bfsFire(fire,grid);\\n    bfsPeople(people,grid);\\n    int firetime = fire[m-1][n-1];\\n    int peopletime = people[m-1][n-1];\\n    \\n     if(peopletime==0)\\n        return -1;\\n     \\n    if(firetime<0)\\n        return (int)1e9;\\n   \\n    int diff = firetime-peopletime;\\n    if(diff<0)\\n        return -1;\\n    int updiff = fire[m-2][n-1] - people[m-2][n-1];\\n\\n    int leftdiff = fire[m-1][n-2] - people[m-1][n-2];\\n    if(updiff > diff || leftdiff > diff)\\n        return diff;\\n    return diff-1;\\n            \\n}\\n\\nvoid bfsFire(int[][] fire,int[][] grid){\\n    \\n    Queue<int[]> qf = new LinkedList<>();\\n   \\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++){\\n            fire[i][j]=-1;\\n            if(grid[i][j]==1){\\n                qf.offer(new int[]{i,j});\\n                fire[i][j]=0;\\n            }\\n                \\n        }\\n    int fmin=1;\\n    while(!qf.isEmpty()){\\n        int size = qf.size();\\n        while(size-->0){\\n            int cur[] = qf.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||fire[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                fire[nx][ny] = fmin;\\n                qf.offer(new int[]{nx,ny});\\n            }\\n        }\\n        fmin++;\\n    }\\n}\\n  void bfsPeople(int[][] people,int[][] grid){\\n    \\n    Queue<int[]> qp = new LinkedList<>();\\n   \\n    qp.offer(new int[]{0,0});\\n    int pmin=1;\\n    while(!qp.isEmpty()){\\n        int size = qp.size();\\n        while(size-->0){\\n            int cur[] = qp.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||people[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                people[nx][ny] = pmin;\\n                qp.offer(new int[]{nx,ny});\\n            }\\n        }\\n        pmin++;\\n    }\\n}\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int m,n;\\n   int dirs[][] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        \\n    m=grid.length;\\n    n=grid[0].length;\\n    int [][]fire = new int[m][n];\\n    int [][]people = new int[m][n];\\n    bfsFire(fire,grid);\\n    bfsPeople(people,grid);\\n    int firetime = fire[m-1][n-1];\\n    int peopletime = people[m-1][n-1];\\n    \\n     if(peopletime==0)\\n        return -1;\\n     \\n    if(firetime<0)\\n        return (int)1e9;\\n   \\n    int diff = firetime-peopletime;\\n    if(diff<0)\\n        return -1;\\n    int updiff = fire[m-2][n-1] - people[m-2][n-1];\\n\\n    int leftdiff = fire[m-1][n-2] - people[m-1][n-2];\\n    if(updiff > diff || leftdiff > diff)\\n        return diff;\\n    return diff-1;\\n            \\n}\\n\\nvoid bfsFire(int[][] fire,int[][] grid){\\n    \\n    Queue<int[]> qf = new LinkedList<>();\\n   \\n    for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++){\\n            fire[i][j]=-1;\\n            if(grid[i][j]==1){\\n                qf.offer(new int[]{i,j});\\n                fire[i][j]=0;\\n            }\\n                \\n        }\\n    int fmin=1;\\n    while(!qf.isEmpty()){\\n        int size = qf.size();\\n        while(size-->0){\\n            int cur[] = qf.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||fire[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                fire[nx][ny] = fmin;\\n                qf.offer(new int[]{nx,ny});\\n            }\\n        }\\n        fmin++;\\n    }\\n}\\n  void bfsPeople(int[][] people,int[][] grid){\\n    \\n    Queue<int[]> qp = new LinkedList<>();\\n   \\n    qp.offer(new int[]{0,0});\\n    int pmin=1;\\n    while(!qp.isEmpty()){\\n        int size = qp.size();\\n        while(size-->0){\\n            int cur[] = qp.poll();\\n\\n            for(int dir[]:dirs){\\n                int  nx=cur[0]+dir[0];\\n                int  ny=cur[1]+dir[1];\\n                \\n                if(nx<0||nx>=m||ny<0||ny>=n||people[nx][ny]>0\\n                   ||grid[nx][ny]==2)\\n                    continue;\\n                people[nx][ny] = pmin;\\n                qp.offer(new int[]{nx,ny});\\n            }\\n        }\\n        pmin++;\\n    }\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979626,
                "title": "python-bfs-no-bs-corner-case-explained-fast-af",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use binary search to track distance of each cell\\'s shortes pat from out desired locations : Fire and Agent.\\n\\nThe idea is at the location of the safehouse, we know time taken by the person and fire to reach there, so the wait time would be fireTime-agentTime\\n\\nThe corner cases are as follows:\\n\\n- fire spreads faster than agent can reach  \\n```\\n    if fireTime < agentTime:\\n        return -1\\n```\\n- fire cant reach\\n```\\n    if fireTime == 10**9 and fireTime > agentTime :\\n        return 10**9\\n```\\n- agnet walled off and cant reach\\n```\\n    if agentTime == 10**9:\\n        return -1\\n```\\n- fire reches before agent\\n```\\n    diff = fireTime - agentTime\\n    \\n    if diff <0:\\n        return -1\\n```\\n\\nThe most complicated cases are when fire and agent have seperate paths and only converge at the safehouse\\n\\nShoutout to https://leetcode.com/problems/escape-the-spreading-fire/solutions/2653210/96-faster-java-sol-no-bs-required-edge-cases-explained-double-bfs-method/ for giving the code behind this\\n\\n- **when they arrive through differenet paths , we assume the agent moves in asynchronously first, then the fire catches on** \\n    - we calculate the difference between the two at a cell above and cell to the left\\n    - if either of these values are greater than diff , then they  come in different paths\\n    - here we do not subtract -1\\n- else we subtract res by 1 as they come in same path and agent must be ahead of the flames\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mxn)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:       \\n        \\n        # for row in range(len(grid)):\\n        #     print(grid[row])\\n\\n\\n        height = len(grid)\\n        width = len(grid[0])\\n        \\n        src =  (0,0)\\n        dest = (height-1,width-1)\\n        \\n        src_i , src_j = src\\n        dest_i, dest_j = dest\\n\\n        # Game rigged from the start\\n        if grid[src_i][src_j] != 0 and grid[dest_i][dest_j] != 0:\\n            print(\"missfire?\")\\n            return -1\\n\\n        # BFSQ for fire\\n        fireQ = collections.deque()        \\n\\n        fire_plane =  [[10**9 for _ in range(width)] for _ in range(height)]\\n        agent_plane = [[10**9 for _ in range(width)] for _ in range(height)]\\n        \\n\\n        # bfsQ for our agent\\n        agentQ = collections.deque()\\n        agent_plane[src_i][src_j]=0\\n        agentQ.append(src)\\n\\n        # populate initial matrices\\n        for h in range(height):\\n            for w in range(width):\\n                # multisourceBFS for fore\\n                if grid[h][w]==1:\\n                    fire_plane[h][w] = 0                    \\n                    fireQ.append((h,w))\\n\\n        def bfs(queue , board , isAgent):\\n            directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\n            # BFS to obtain shortest path to destination\\n            while len(queue)>0:\\n                i,j = queue.popleft()\\n\\n                for dir_i , dir_j in directions:\\n\\n                    di = i + dir_i \\n                    dj =  j + dir_j\\n\\n                    if 0<=di<height and 0<=dj<width and board[di][dj] == 10**9 and grid[di][dj] != 2 :\\n\\n                        board[di][dj] = board[i][j]+1                        \\n                        queue.append((di,dj))\\n                        \\n            # print(\"isAgent\",isAgent)\\n            # for row in range(len(board)):\\n            #     print(board[row])\\n            # print(\"/////////////////////////////\")\\n\\n        # bfs for fire\\n        bfs(fireQ,fire_plane,False)\\n        # bfs for agent\\n        bfs(agentQ,agent_plane,True)\\n\\n        \\n\\n        fireTime = fire_plane[-1][-1]\\n        agentTime = agent_plane[-1][-1]\\n\\n        # fire spreads faster than agent can reach \\n        if fireTime < agentTime:\\n            return -1\\n\\n        # fire cant reach\\n        if fireTime == 10**9 and fireTime > agentTime :\\n            return 10**9\\n\\n        # agnet walled off and cant reach\\n        if agentTime == 10**9:\\n            return -1\\n\\n        diff = fireTime - agentTime\\n        \\n        if diff <0:\\n            return -1\\n        # both reach safehouse from 2nd last row \\n        downDiff = fire_plane[-2][-1] - agent_plane[-2][-1]\\n\\n        # both reach safehouse from last row \\n        rightDiff = fire_plane[-1][-2] - agent_plane[-1][-2]\\n\\n\\n\\n        if downDiff > diff or rightDiff > diff:\\n            return diff\\n\\n        return diff -1\\n\\n        # return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n    if fireTime < agentTime:\\n        return -1\\n```\n```\\n    if fireTime == 10**9 and fireTime > agentTime :\\n        return 10**9\\n```\n```\\n    if agentTime == 10**9:\\n        return -1\\n```\n```\\n    diff = fireTime - agentTime\\n    \\n    if diff <0:\\n        return -1\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:       \\n        \\n        # for row in range(len(grid)):\\n        #     print(grid[row])\\n\\n\\n        height = len(grid)\\n        width = len(grid[0])\\n        \\n        src =  (0,0)\\n        dest = (height-1,width-1)\\n        \\n        src_i , src_j = src\\n        dest_i, dest_j = dest\\n\\n        # Game rigged from the start\\n        if grid[src_i][src_j] != 0 and grid[dest_i][dest_j] != 0:\\n            print(\"missfire?\")\\n            return -1\\n\\n        # BFSQ for fire\\n        fireQ = collections.deque()        \\n\\n        fire_plane =  [[10**9 for _ in range(width)] for _ in range(height)]\\n        agent_plane = [[10**9 for _ in range(width)] for _ in range(height)]\\n        \\n\\n        # bfsQ for our agent\\n        agentQ = collections.deque()\\n        agent_plane[src_i][src_j]=0\\n        agentQ.append(src)\\n\\n        # populate initial matrices\\n        for h in range(height):\\n            for w in range(width):\\n                # multisourceBFS for fore\\n                if grid[h][w]==1:\\n                    fire_plane[h][w] = 0                    \\n                    fireQ.append((h,w))\\n\\n        def bfs(queue , board , isAgent):\\n            directions = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\n            # BFS to obtain shortest path to destination\\n            while len(queue)>0:\\n                i,j = queue.popleft()\\n\\n                for dir_i , dir_j in directions:\\n\\n                    di = i + dir_i \\n                    dj =  j + dir_j\\n\\n                    if 0<=di<height and 0<=dj<width and board[di][dj] == 10**9 and grid[di][dj] != 2 :\\n\\n                        board[di][dj] = board[i][j]+1                        \\n                        queue.append((di,dj))\\n                        \\n            # print(\"isAgent\",isAgent)\\n            # for row in range(len(board)):\\n            #     print(board[row])\\n            # print(\"/////////////////////////////\")\\n\\n        # bfs for fire\\n        bfs(fireQ,fire_plane,False)\\n        # bfs for agent\\n        bfs(agentQ,agent_plane,True)\\n\\n        \\n\\n        fireTime = fire_plane[-1][-1]\\n        agentTime = agent_plane[-1][-1]\\n\\n        # fire spreads faster than agent can reach \\n        if fireTime < agentTime:\\n            return -1\\n\\n        # fire cant reach\\n        if fireTime == 10**9 and fireTime > agentTime :\\n            return 10**9\\n\\n        # agnet walled off and cant reach\\n        if agentTime == 10**9:\\n            return -1\\n\\n        diff = fireTime - agentTime\\n        \\n        if diff <0:\\n            return -1\\n        # both reach safehouse from 2nd last row \\n        downDiff = fire_plane[-2][-1] - agent_plane[-2][-1]\\n\\n        # both reach safehouse from last row \\n        rightDiff = fire_plane[-1][-2] - agent_plane[-1][-2]\\n\\n\\n\\n        if downDiff > diff or rightDiff > diff:\\n            return diff\\n\\n        return diff -1\\n\\n        # return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973663,
                "title": "c-binary-search-multi-source-bfs-accepted",
                "content": "# Approach\\n- Create a N*M matrix (Where each cell indicates the earliest time when fire will arrive. )\\n- Start from minimum possible time and check can we reach top to bottom while starting at startTime time.\\n- - If we can reach bottom increase time and check again.\\n- - If not Decrease the time.\\n> ### We will use Binary search to automate this process.\\n- Code looks Scary and long but try to understand it stepwise, its simple and most of it are precalculations;\\n\\n# Complexity\\n- Time complexity:\\n$$O( (n*m )*log(n*m))$$ [ If wrong please mention :( ]\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    vector<vector<int>> minFireTime;\\n\\n    // Boundary Check Functions\\n    bool isValid(int i,int j,int n,int m,vector<vector<int>> &grid){\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==1 || minFireTime[i][j]!=0 || minFireTime[i][j] == -1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool chalaJayega(int i,int j,int n,int m){\\n        if(i<0 || i>=n || j<0 || j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /* Heart of the code : It recieves a 2D matrix (containing earliest time cell will catch \\uD83D\\uDD25) */\\n    bool jalJayega(int startTime){\\n        if(startTime>minFireTime[0][0] && minFireTime[0][0]!=0)return false; // You\\'re too late \\uD83D\\uDD25 is already there on start position (Just Return)\\n        int n=minFireTime.size();\\n        int m=minFireTime[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[0][0]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(!chalaJayega(newX,newY,n,m) || visited[newX][newY]==1){\\n                        continue; // Out of Bounds or Already in Queue/Visited\\n                    }\\n                    if(minFireTime[newX][newY]==0 || startTime+1<minFireTime[newX][newY]){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }\\n                    if(newX==n-1 && newY==m-1) return (minFireTime[i][j]==0 || minFireTime[newX][newY]>startTime); // You\\'ve reached bottom check for time constraints and return;\\n                }\\n            }\\n            startTime++; // As mentioned in question fire will increase with increasing steps\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        minFireTime.resize(n,vector<int>(m,0));\\n        int time=0;\\n\\n        /* Building out info matrix (minFireTime)*/\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    minFireTime[i][j]=time;\\n                    q.push({i,j}); // Insert into queue for BFS\\n                }else if(grid[i][j]==2){\\n                    minFireTime[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        /* Perform multisource BFS on fire as there are multiple cells containg \\uD83D\\uDD25*/\\n\\n        while(!q.empty()){\\n            time++;\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(isValid(newX,newY,n,m,grid)){\\n                        minFireTime[newX][newY]=time;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        /* Binary Search Template for Min-Max / Max-Min Problems */\\n\\n        int ans=-1;\\n        int left=0;\\n        int right=1e9;\\n\\n        /* Try some edge cases to save time \\uD83E\\uDEE0 */\\n        if(jalJayega(right))return right; \\n        if(!jalJayega(left))return -1;\\n\\n        /* Binary Search */\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(jalJayega(mid)){\\n                ans=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return ans;\\n\\n        /* All Done Check Time and Space Complexity */\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    vector<vector<int>> minFireTime;\\n\\n    // Boundary Check Functions\\n    bool isValid(int i,int j,int n,int m,vector<vector<int>> &grid){\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==1 || minFireTime[i][j]!=0 || minFireTime[i][j] == -1){\\n            return false;\\n        }\\n        return true;\\n    }\\n    bool chalaJayega(int i,int j,int n,int m){\\n        if(i<0 || i>=n || j<0 || j>=m){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /* Heart of the code : It recieves a 2D matrix (containing earliest time cell will catch \\uD83D\\uDD25) */\\n    bool jalJayega(int startTime){\\n        if(startTime>minFireTime[0][0] && minFireTime[0][0]!=0)return false; // You\\'re too late \\uD83D\\uDD25 is already there on start position (Just Return)\\n        int n=minFireTime.size();\\n        int m=minFireTime[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vector<vector<int>> visited(n,vector<int>(m,0));\\n        visited[0][0]=true;\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(!chalaJayega(newX,newY,n,m) || visited[newX][newY]==1){\\n                        continue; // Out of Bounds or Already in Queue/Visited\\n                    }\\n                    if(minFireTime[newX][newY]==0 || startTime+1<minFireTime[newX][newY]){\\n                        visited[newX][newY]=1;\\n                        q.push({newX,newY});\\n                    }\\n                    if(newX==n-1 && newY==m-1) return (minFireTime[i][j]==0 || minFireTime[newX][newY]>startTime); // You\\'ve reached bottom check for time constraints and return;\\n                }\\n            }\\n            startTime++; // As mentioned in question fire will increase with increasing steps\\n        }\\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<int,int>> q;\\n        minFireTime.resize(n,vector<int>(m,0));\\n        int time=0;\\n\\n        /* Building out info matrix (minFireTime)*/\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    minFireTime[i][j]=time;\\n                    q.push({i,j}); // Insert into queue for BFS\\n                }else if(grid[i][j]==2){\\n                    minFireTime[i][j]=-1;\\n                }\\n            }\\n        }\\n\\n        /* Perform multisource BFS on fire as there are multiple cells containg \\uD83D\\uDD25*/\\n\\n        while(!q.empty()){\\n            time++;\\n            int size=q.size();\\n            while(size--){\\n                auto [i,j]=q.front();\\n                q.pop();\\n                for(int k=0;k<4;k++){\\n                    int newX=i+dx[k];\\n                    int newY=j+dy[k];\\n                    if(isValid(newX,newY,n,m,grid)){\\n                        minFireTime[newX][newY]=time;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n        }\\n\\n        /* Binary Search Template for Min-Max / Max-Min Problems */\\n\\n        int ans=-1;\\n        int left=0;\\n        int right=1e9;\\n\\n        /* Try some edge cases to save time \\uD83E\\uDEE0 */\\n        if(jalJayega(right))return right; \\n        if(!jalJayega(left))return -1;\\n\\n        /* Binary Search */\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(jalJayega(mid)){\\n                ans=mid;\\n                left=mid+1;\\n            }else{\\n                right=mid-1;\\n            }\\n        }\\n        return ans;\\n\\n        /* All Done Check Time and Space Complexity */\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963591,
                "title": "c-binary-search-bfs-graph-easy-to-undersand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private int[][] directions = new int[4][];\\n    private int RowLimit = 0;\\n    private int ColumnLimit = 0;\\n    private const int Fire = 1;\\n    private const int Wall = 2;\\n\\n    class Path\\n    {\\n        public int Row { get; set; }\\n\\n        public int Column { get; set; }\\n\\n        public Path(int row, int column)\\n        {\\n            Row = row;\\n            Column = column;\\n        }\\n    }\\n\\n    public Solution()\\n    {\\n        directions[0] = new[] { 0, 1 };\\n        directions[1] = new[] { 1, 0 };\\n        directions[2] = new[] { -1, 0 };\\n        directions[3] = new[] { 0, -1 };\\n    }\\n\\n    public int MaximumMinutes(int[][] grid)\\n    {\\n        RowLimit = grid.Length;\\n        ColumnLimit = grid[0].Length;\\n\\n        var left = 0;\\n        var right = RowLimit * ColumnLimit;\\n        var answer = -1;\\n\\n        var initialFire = new List<IList<int>>();\\n\\n        for (int i = 0; i < RowLimit; i++)\\n        {\\n            for (int j = 0; j < ColumnLimit; j++)\\n            {\\n                if (grid[i][j] == Fire)\\n                {\\n                    initialFire.Add(new List<int> { i, j });\\n                }\\n            }\\n        }\\n\\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var result = IsValidCombination(grid, mid, initialFire);\\n\\n        // If step cound is not equal to zero and we can traverse graph it means that fire can\\'t reach player, so in that case we can return 10^9\\n            if (result.IsValid && !result.IsFireSpreading)\\n            {\\n                return (int)1e9;\\n            }\\n            \\n            if (result.IsValid)\\n            {\\n                answer = mid;\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    (bool IsValid, bool IsFireSpreading) IsValidCombination(int[][] grid, int value, List<IList<int>> fire)\\n    {\\n        var fireQueue = new Queue<Path>();\\n        var visited = new bool[RowLimit, ColumnLimit];\\n        var fireMap = new int[RowLimit, ColumnLimit];\\n\\n        foreach (var coordinates in fire)\\n        {\\n            var element = new Path(coordinates[0], coordinates[1]);\\n            fireQueue.Enqueue(element);\\n            fireMap[element.Row, element.Column] = Fire;\\n            visited[element.Row, element.Column] = true;\\n        }\\n\\n        var steps = value;\\n        while (steps > 0 && fireQueue.Count != 0)\\n        {\\n            steps--;\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n        }\\n\\n        if (visited[0, 0])\\n        {\\n            return (false, steps == 0);\\n        }\\n\\n        var playerSteps = new Queue<Path>();\\n        var playerVisits = new bool[RowLimit, ColumnLimit];\\n        playerSteps.Enqueue(new Path(0,0 ));\\n        playerVisits[0, 0] = true;\\n        \\n        while (playerSteps.Count != 0)\\n        {\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n\\n            var count = playerSteps.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                var playerPosition = playerSteps.Dequeue();\\n\\n                // Handle case when fire on house but we still can enter\\n                if (playerPosition.Row == RowLimit - 1 && playerPosition.Column == ColumnLimit - 1)\\n                {\\n                    return (true, steps == 0);\\n                }\\n            \\n                foreach (var direction in directions)\\n                {\\n                    var nextRow = playerPosition.Row + direction[0];\\n                    var nextColumn = playerPosition.Column + direction[1];\\n                    \\n                    if (nextRow == RowLimit - 1 && nextColumn == ColumnLimit - 1 && fireMap[playerPosition.Row, playerPosition.Column] != Fire)\\n                    {\\n                        return (true, steps == 0);\\n                    }\\n                    \\n                    if (IsValidHumanStep(nextColumn, nextRow, grid, fireMap) && !playerVisits[nextRow, nextColumn])\\n                    {\\n                        playerVisits[nextRow, nextColumn] = true;\\n                        playerSteps.Enqueue(new Path(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (false, steps == 0);\\n    }\\n\\n    void FireSpreadingStep(Queue<Path> fireQueue, int[,] fireMap, bool[,] visited, int[][] grid)\\n    {\\n        var count = fireQueue.Count;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            var currentFire = fireQueue.Dequeue();\\n            foreach (var direction in directions)\\n            {\\n                var nextRow = currentFire.Row + direction[0];\\n                var nextColumn = currentFire.Column + direction[1];\\n\\n                if (IsValidFireStep(nextColumn, nextRow, grid) && !visited[nextRow, nextColumn])\\n                {\\n                    visited[nextRow, nextColumn] = true;\\n                    fireMap[nextRow, nextColumn] = Fire;\\n                    fireQueue.Enqueue(new Path(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool IsValidFireStep(int column, int row, int[][] grid)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall;\\n    }\\n\\n    bool IsValidHumanStep(int column, int row, int[][] grid, int[,] fireMap)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall && fireMap[row, column] != Fire;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[][] directions = new int[4][];\\n    private int RowLimit = 0;\\n    private int ColumnLimit = 0;\\n    private const int Fire = 1;\\n    private const int Wall = 2;\\n\\n    class Path\\n    {\\n        public int Row { get; set; }\\n\\n        public int Column { get; set; }\\n\\n        public Path(int row, int column)\\n        {\\n            Row = row;\\n            Column = column;\\n        }\\n    }\\n\\n    public Solution()\\n    {\\n        directions[0] = new[] { 0, 1 };\\n        directions[1] = new[] { 1, 0 };\\n        directions[2] = new[] { -1, 0 };\\n        directions[3] = new[] { 0, -1 };\\n    }\\n\\n    public int MaximumMinutes(int[][] grid)\\n    {\\n        RowLimit = grid.Length;\\n        ColumnLimit = grid[0].Length;\\n\\n        var left = 0;\\n        var right = RowLimit * ColumnLimit;\\n        var answer = -1;\\n\\n        var initialFire = new List<IList<int>>();\\n\\n        for (int i = 0; i < RowLimit; i++)\\n        {\\n            for (int j = 0; j < ColumnLimit; j++)\\n            {\\n                if (grid[i][j] == Fire)\\n                {\\n                    initialFire.Add(new List<int> { i, j });\\n                }\\n            }\\n        }\\n\\n        while (left <= right)\\n        {\\n            var mid = left + (right - left) / 2;\\n            var result = IsValidCombination(grid, mid, initialFire);\\n\\n        // If step cound is not equal to zero and we can traverse graph it means that fire can\\'t reach player, so in that case we can return 10^9\\n            if (result.IsValid && !result.IsFireSpreading)\\n            {\\n                return (int)1e9;\\n            }\\n            \\n            if (result.IsValid)\\n            {\\n                answer = mid;\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    (bool IsValid, bool IsFireSpreading) IsValidCombination(int[][] grid, int value, List<IList<int>> fire)\\n    {\\n        var fireQueue = new Queue<Path>();\\n        var visited = new bool[RowLimit, ColumnLimit];\\n        var fireMap = new int[RowLimit, ColumnLimit];\\n\\n        foreach (var coordinates in fire)\\n        {\\n            var element = new Path(coordinates[0], coordinates[1]);\\n            fireQueue.Enqueue(element);\\n            fireMap[element.Row, element.Column] = Fire;\\n            visited[element.Row, element.Column] = true;\\n        }\\n\\n        var steps = value;\\n        while (steps > 0 && fireQueue.Count != 0)\\n        {\\n            steps--;\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n        }\\n\\n        if (visited[0, 0])\\n        {\\n            return (false, steps == 0);\\n        }\\n\\n        var playerSteps = new Queue<Path>();\\n        var playerVisits = new bool[RowLimit, ColumnLimit];\\n        playerSteps.Enqueue(new Path(0,0 ));\\n        playerVisits[0, 0] = true;\\n        \\n        while (playerSteps.Count != 0)\\n        {\\n            FireSpreadingStep(fireQueue, fireMap, visited, grid);\\n\\n            var count = playerSteps.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                var playerPosition = playerSteps.Dequeue();\\n\\n                // Handle case when fire on house but we still can enter\\n                if (playerPosition.Row == RowLimit - 1 && playerPosition.Column == ColumnLimit - 1)\\n                {\\n                    return (true, steps == 0);\\n                }\\n            \\n                foreach (var direction in directions)\\n                {\\n                    var nextRow = playerPosition.Row + direction[0];\\n                    var nextColumn = playerPosition.Column + direction[1];\\n                    \\n                    if (nextRow == RowLimit - 1 && nextColumn == ColumnLimit - 1 && fireMap[playerPosition.Row, playerPosition.Column] != Fire)\\n                    {\\n                        return (true, steps == 0);\\n                    }\\n                    \\n                    if (IsValidHumanStep(nextColumn, nextRow, grid, fireMap) && !playerVisits[nextRow, nextColumn])\\n                    {\\n                        playerVisits[nextRow, nextColumn] = true;\\n                        playerSteps.Enqueue(new Path(nextRow, nextColumn));\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (false, steps == 0);\\n    }\\n\\n    void FireSpreadingStep(Queue<Path> fireQueue, int[,] fireMap, bool[,] visited, int[][] grid)\\n    {\\n        var count = fireQueue.Count;\\n\\n        for (int i = 0; i < count; i++)\\n        {\\n            var currentFire = fireQueue.Dequeue();\\n            foreach (var direction in directions)\\n            {\\n                var nextRow = currentFire.Row + direction[0];\\n                var nextColumn = currentFire.Column + direction[1];\\n\\n                if (IsValidFireStep(nextColumn, nextRow, grid) && !visited[nextRow, nextColumn])\\n                {\\n                    visited[nextRow, nextColumn] = true;\\n                    fireMap[nextRow, nextColumn] = Fire;\\n                    fireQueue.Enqueue(new Path(nextRow, nextColumn));\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool IsValidFireStep(int column, int row, int[][] grid)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall;\\n    }\\n\\n    bool IsValidHumanStep(int column, int row, int[][] grid, int[,] fireMap)\\n    {\\n        return 0 <= row && row < RowLimit && 0 <= column && column < ColumnLimit &&\\n               grid[row][column] != Wall && fireMap[row, column] != Fire;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926898,
                "title": "python3-bfs-heap-beats-95-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst use BFS to calculate each cell\\'s last day it can ba passed\\nThen use a heap started from the last cell with the last day we can pass to the cell until reached the start point.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst use BFS to calculate each cell\\'s last day it can ba passed\\nThen use a heap started from the last cell with the last day we can pass to the cell\\nIn each iteration, we add the neighbor of the current cell with the last day which be the maximum of `current last day - 1` (as it takes 1 day to pass to next cell) or `the neighbor\\'s last day`.\\nOnce we reached the start point, we check:\\n1. if the last day we can pass is less than 0 which means it does not exists a path\\n2. if the last day equals to INF means it can take as longer as it wants, we return 10 ** 9\\n3. Return the last day\\n# Complexity\\nThe time complexity of this code is determined by the breadth-first search (BFS) and heap operations. Let\\'s break down the major parts of the code:\\n\\n1. Building the `last_day_pass` array using BFS: This step visits each cell in the grid once, and for each cell, it explores its neighbors in the grid. So, the time complexity for this step is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n\\n2. Building the heap: The heap is built by adding cells to the heap based on their `last_day_pass` values. In the worst case, all cells are added to the heap, which would result in O(m * n * log(m * n)) time complexity due to the heap operations.\\n\\n3. Extracting cells from the heap: The while loop extracts cells from the heap until it\\'s empty. In the worst case, it can extract all cells in the heap, which would also result in O(m * n * log(m * n)) time complexity due to the heap operations.\\n\\nCombining these time complexities, the overall time complexity of the code is dominated by the heap operations, which is O(m * n * log(m * n)).\\n\\nAs for space complexity, the major space-consuming data structures are:\\n\\n- `last_day_pass`: O(m * n) space\\n- `q`: The BFS queue, in the worst case, could store all cells in the grid, so O(m * n) space\\n- `heap`: The heap, in the worst case, could store all cells in the grid, so O(m * n) space\\n- `visited`: A set to track visited cells, in the worst case, could store all cells in the grid, so O(m * n) space\\n\\nThe overall space complexity is O(m * n) due to these data structures.\\n- Time complexity: O(m * n * log(m * n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        INF = float(\\'inf\\')\\n        last_day_pass = [[INF] * n for _ in range(m)]\\n        q = deque()\\n        visited = set()        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n                    visited.add((i, j))\\n                    last_day_pass[i][j] = -1\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                last_day_pass[x+d0][y+d1] = last_day_pass[x][y] + 1\\n                q.append((x+d0, y+d1))\\n\\n        heap = [(-last_day_pass[m-1][n-1]-1, m-1, n-1)]\\n        visited = set()\\n        while heap:\\n            last_day, x, y = heapq.heappop(heap)\\n            if x == 0 and y == 0:\\n                if -last_day < 0:\\n                    return -1              \\n                return -last_day if -last_day != INF else 10 ** 9\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or grid[x+d0][y+d1] > 0 or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                heapq.heappush(heap, (max(last_day+1, -last_day_pass[x+d0][y+d1]), x+d0, y+d1))\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        INF = float(\\'inf\\')\\n        last_day_pass = [[INF] * n for _ in range(m)]\\n        q = deque()\\n        visited = set()        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] > 0:\\n                    if grid[i][j] == 1:\\n                        q.append((i, j))\\n                    visited.add((i, j))\\n                    last_day_pass[i][j] = -1\\n        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        \\n        while q:\\n            x, y = q.popleft()\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                last_day_pass[x+d0][y+d1] = last_day_pass[x][y] + 1\\n                q.append((x+d0, y+d1))\\n\\n        heap = [(-last_day_pass[m-1][n-1]-1, m-1, n-1)]\\n        visited = set()\\n        while heap:\\n            last_day, x, y = heapq.heappop(heap)\\n            if x == 0 and y == 0:\\n                if -last_day < 0:\\n                    return -1              \\n                return -last_day if -last_day != INF else 10 ** 9\\n            for d0, d1 in dirs:\\n                if not 0 <= x+d0 < m or not 0 <= y+d1 < n or grid[x+d0][y+d1] > 0 or (x+d0, y+d1) in visited:\\n                    continue\\n                visited.add((x+d0, y+d1))\\n                heapq.heappush(heap, (max(last_day+1, -last_day_pass[x+d0][y+d1]), x+d0, y+d1))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921790,
                "title": "easy-soln-c-beginners-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:int m ,n ;\\nint dx[4] = {-1,0,1,0} ;\\nint dy[4] = {0,1,0,-1} ;bool flag=false;\\nbool val(int i ,int j, int m,int n){\\n    if(i<0||j<0||i>=m||j>=n) return false ;return true ;\\n}\\nbool fire_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n    for(int i=0;i<m;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==1)\\n            {\\n                q.push({i,j});\\n                vis[i][j]=1;\\n            }\\n        }\\n    }while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\nbool man_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     q.push({0,0});\\n   while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        if(man_end(grid)==false)return -1;\\n        if(fire_end(grid)==false)return 1e9;\\n      //  n=grid[0].size();\\n        int low=0;\\n        int high=m*(n+1);int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            vector<vector<int>>fire_vis(m,vector<int>(n,0));\\n              queue<pair<int,pair<int,int>>>q;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(grid[i][j] == 1) {\\n                         //cout<<i<<\" \"<<j<<endl;\\n                         q.push({0,{i,j}}) ;\\n                         fire_vis[i][j] = 1;\\n                    }\\n                }\\n            }//cout<<q.size()<<endl;\\n            int k=mid;\\n            while(k--)\\n            {\\n                 int t = q.size() ;\\n                 while(t--){\\n                     auto i = q.front() ;\\n                     q.pop() ;\\n                     for(int d=0;d<4;d++){\\n                         int nx = i.second.first+dx[d] ;\\n                         int ny = i.second.second+dy[d] ;\\n                         if(val(nx,ny,m,n) && grid[nx][ny] ==0 && !fire_vis[nx][ny]){\\n                             fire_vis[nx][ny] = 1 ;\\n                             q.push({0,{nx,ny}}) ;\\n                         }\\n                     }  \\n                 }\\n            }\\n            queue<pair<int,pair<int,int>>>pq;\\n            pq.push({0,{0,0}});bool fir=false;bool person=false;\\n           vector<vector<int>>person_vis(m,vector<int>(n,0)); person_vis[0][0]=1;\\n \\n            vector<vector<int>>vis(m,vector<int>(n,0));\\n            vector<vector<int>>time(m,vector<int>(n,0));\\n\\n            while(!q.empty())\\n            {\\n                 int sz=q.size();\\n                 while(sz--)\\n                 {\\n                     auto t=q.front();\\n                     q.pop();\\n                     int r=t.second.first;\\n                     int c=t.second.second;\\n                     int tim=t.first;if(r==m-1&&c==n-1)\\n                     {\\n                         cout<<\"aa gya last tk fire\";\\n                         fir=true;\\n                     }\\n                     for(int j=0;j<4;j++)\\n                     {\\n                         int nr=r+dx[j];\\n                         int nc=c+dy[j];\\n                         if(val(nr,nc,m,n)&&!fire_vis[nr][nc]&&grid[nr][nc]==0&&!vis[nr][nc])\\n                         {\\n                             vis[nr][nc]=1;\\n                             q.push({tim+1,{nr,nc}});\\n                             time[nr][nc]=tim+1;\\n                         }\\n                     }\\n                 }         \\n                 \\n            } if(fir==false)\\n            {cout<<\"ghusa\"<<endl;\\n                flag=true;\\n                \\n            }\\n\\n            while(!pq.empty())\\n            {\\n                int sz=pq.size();\\n                while(sz--)\\n                {\\n                  auto t=pq.front();\\n                  pq.pop();\\n                  int r=t.second.first;\\n                  int c=t.second.second;\\n                  int tim=t.first;\\n                  if(r==m-1&&c==n-1)person=true;\\n                  for(int j=0;j<4;j++)\\n                    {\\n                        int nr=r+dx[j];\\n                        int nc=c+dy[j];\\n                    \\n                        if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!fire_vis[nr][nc]&&!person_vis[nr][nc]\\n                        &&time[nr][nc]>=tim+1&&time[r][c]>tim)\\n                        {\\n                           // cout<<nr<<\" \"<<nc<<\" \"<<time[nr][nc]<<\" \"<<tim+1<<endl;\\n                           person_vis[nr][nc]=1;\\n                            pq.push({tim+1,{nr,nc}});\\n                            //time[nr][nc]=tim+1;\\n                        }\\n\\n                    }\\n                }\\n\\n            }/*for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    cout<<person_vis[i][j];\\n                }cout<<endl;\\n            }*/// cout<<person<<endl;\\n            if(person)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }else if(!person)\\n            {\\n                high=mid-1;\\n            }\\n\\n        }//if(flag&&ans==-1)return 1e9;\\n        //if(ans==0)return -1;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int m ,n ;\\nint dx[4] = {-1,0,1,0} ;\\nint dy[4] = {0,1,0,-1} ;bool flag=false;\\nbool val(int i ,int j, int m,int n){\\n    if(i<0||j<0||i>=m||j>=n) return false ;return true ;\\n}\\nbool fire_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n    for(int i=0;i<m;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==1)\\n            {\\n                q.push({i,j});\\n                vis[i][j]=1;\\n            }\\n        }\\n    }while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\nbool man_end(vector<vector<int>>& grid)\\n{\\n    queue<pair<int,int>>q;\\n     vector<vector<int>>vis(m,vector<int>(n,0));\\n     q.push({0,0});\\n   while(!q.empty())\\n    {\\n        int sz=q.size();\\n        while(sz--)\\n        {\\n            auto t=q.front();q.pop();\\n            int r=t.first;\\n            int c=t.second;\\n            if(r==m-1&&c==n-1)return true;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nr=r+dx[k];\\n                int nc=c+dy[k];\\n                if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!vis[nr][nc])\\n                {\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n\\n        }\\n    }return false;\\n}\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m=grid.size(); n=grid[0].size();\\n        if(man_end(grid)==false)return -1;\\n        if(fire_end(grid)==false)return 1e9;\\n      //  n=grid[0].size();\\n        int low=0;\\n        int high=m*(n+1);int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            vector<vector<int>>fire_vis(m,vector<int>(n,0));\\n              queue<pair<int,pair<int,int>>>q;\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    if(grid[i][j] == 1) {\\n                         //cout<<i<<\" \"<<j<<endl;\\n                         q.push({0,{i,j}}) ;\\n                         fire_vis[i][j] = 1;\\n                    }\\n                }\\n            }//cout<<q.size()<<endl;\\n            int k=mid;\\n            while(k--)\\n            {\\n                 int t = q.size() ;\\n                 while(t--){\\n                     auto i = q.front() ;\\n                     q.pop() ;\\n                     for(int d=0;d<4;d++){\\n                         int nx = i.second.first+dx[d] ;\\n                         int ny = i.second.second+dy[d] ;\\n                         if(val(nx,ny,m,n) && grid[nx][ny] ==0 && !fire_vis[nx][ny]){\\n                             fire_vis[nx][ny] = 1 ;\\n                             q.push({0,{nx,ny}}) ;\\n                         }\\n                     }  \\n                 }\\n            }\\n            queue<pair<int,pair<int,int>>>pq;\\n            pq.push({0,{0,0}});bool fir=false;bool person=false;\\n           vector<vector<int>>person_vis(m,vector<int>(n,0)); person_vis[0][0]=1;\\n \\n            vector<vector<int>>vis(m,vector<int>(n,0));\\n            vector<vector<int>>time(m,vector<int>(n,0));\\n\\n            while(!q.empty())\\n            {\\n                 int sz=q.size();\\n                 while(sz--)\\n                 {\\n                     auto t=q.front();\\n                     q.pop();\\n                     int r=t.second.first;\\n                     int c=t.second.second;\\n                     int tim=t.first;if(r==m-1&&c==n-1)\\n                     {\\n                         cout<<\"aa gya last tk fire\";\\n                         fir=true;\\n                     }\\n                     for(int j=0;j<4;j++)\\n                     {\\n                         int nr=r+dx[j];\\n                         int nc=c+dy[j];\\n                         if(val(nr,nc,m,n)&&!fire_vis[nr][nc]&&grid[nr][nc]==0&&!vis[nr][nc])\\n                         {\\n                             vis[nr][nc]=1;\\n                             q.push({tim+1,{nr,nc}});\\n                             time[nr][nc]=tim+1;\\n                         }\\n                     }\\n                 }         \\n                 \\n            } if(fir==false)\\n            {cout<<\"ghusa\"<<endl;\\n                flag=true;\\n                \\n            }\\n\\n            while(!pq.empty())\\n            {\\n                int sz=pq.size();\\n                while(sz--)\\n                {\\n                  auto t=pq.front();\\n                  pq.pop();\\n                  int r=t.second.first;\\n                  int c=t.second.second;\\n                  int tim=t.first;\\n                  if(r==m-1&&c==n-1)person=true;\\n                  for(int j=0;j<4;j++)\\n                    {\\n                        int nr=r+dx[j];\\n                        int nc=c+dy[j];\\n                    \\n                        if(val(nr,nc,m,n)&&grid[nr][nc]==0&&!fire_vis[nr][nc]&&!person_vis[nr][nc]\\n                        &&time[nr][nc]>=tim+1&&time[r][c]>tim)\\n                        {\\n                           // cout<<nr<<\" \"<<nc<<\" \"<<time[nr][nc]<<\" \"<<tim+1<<endl;\\n                           person_vis[nr][nc]=1;\\n                            pq.push({tim+1,{nr,nc}});\\n                            //time[nr][nc]=tim+1;\\n                        }\\n\\n                    }\\n                }\\n\\n            }/*for(int i=0;i<m;i++)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    cout<<person_vis[i][j];\\n                }cout<<endl;\\n            }*/// cout<<person<<endl;\\n            if(person)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }else if(!person)\\n            {\\n                high=mid-1;\\n            }\\n\\n        }//if(flag&&ans==-1)return 1e9;\\n        //if(ans==0)return -1;\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3910838,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can efficiently check whether we can reach the house for any guessed answer. So we can just binary search for the correct answer.\\n\\n# Complexity\\n- Time complexity: $O(M*N*log(1000000000)) = O(M*N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(M*N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nconst VISITED: i32 = -1;\\nconst GRASS: i32 = 0;\\nconst FIRE: i32 = 1;\\n\\nfn can_reach_house(mut grid: Vec<Vec<i32>>, mut time: i32) -> bool {\\n    let (m, n) = (grid.len(), grid[0].len());\\n    let mut fire = VecDeque::new();\\n    let mut player = VecDeque::from([(0, 0)]);\\n\\n    for (i, row) in grid.iter().enumerate() {\\n        for (j, &cell) in row.iter().enumerate() {\\n            if cell == FIRE {\\n                fire.push_back((i, j));\\n            }\\n        }\\n    }\\n\\n    while !player.is_empty() {\\n        let size = fire.len();\\n        for _ in 0..size {\\n            let (i, j) = fire.pop_front().unwrap();\\n\\n            grid[i][j] = FIRE;\\n            if (i == m - 1 && j == n - 1) && time > 0 { return false }\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] > GRASS { continue }\\n                fire.push_back((ni, nj));\\n            }\\n        }\\n\\n        time -= 1;\\n        if time >= 0 && !fire.is_empty() { continue }\\n\\n        let size = player.len();\\n        for _ in 0..size {\\n            let (i, j) = player.pop_front().unwrap();\\n            if i == m - 1 && j == n - 1 { return true }\\n            if grid[i][j] == FIRE { continue }\\n            grid[i][j] = VISITED;\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] != GRASS { continue }\\n                player.push_back((ni, nj));\\n            }\\n        }\\n    }\\n    false\\n}\\n\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut lo = -1;\\n        let mut hi = 1_000_000_000;\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if can_reach_house(grid.clone(), mid) { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nconst VISITED: i32 = -1;\\nconst GRASS: i32 = 0;\\nconst FIRE: i32 = 1;\\n\\nfn can_reach_house(mut grid: Vec<Vec<i32>>, mut time: i32) -> bool {\\n    let (m, n) = (grid.len(), grid[0].len());\\n    let mut fire = VecDeque::new();\\n    let mut player = VecDeque::from([(0, 0)]);\\n\\n    for (i, row) in grid.iter().enumerate() {\\n        for (j, &cell) in row.iter().enumerate() {\\n            if cell == FIRE {\\n                fire.push_back((i, j));\\n            }\\n        }\\n    }\\n\\n    while !player.is_empty() {\\n        let size = fire.len();\\n        for _ in 0..size {\\n            let (i, j) = fire.pop_front().unwrap();\\n\\n            grid[i][j] = FIRE;\\n            if (i == m - 1 && j == n - 1) && time > 0 { return false }\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] > GRASS { continue }\\n                fire.push_back((ni, nj));\\n            }\\n        }\\n\\n        time -= 1;\\n        if time >= 0 && !fire.is_empty() { continue }\\n\\n        let size = player.len();\\n        for _ in 0..size {\\n            let (i, j) = player.pop_front().unwrap();\\n            if i == m - 1 && j == n - 1 { return true }\\n            if grid[i][j] == FIRE { continue }\\n            grid[i][j] = VISITED;\\n\\n            let (i, j) = (i as i32, j as i32);\\n            for (ni, nj) in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] {\\n                if ni < 0 || nj < 0 || ni as usize >= m || nj as usize >= n { continue }\\n                let (ni, nj) = (ni as usize, nj as usize);\\n\\n                if grid[ni][nj] != GRASS { continue }\\n                player.push_back((ni, nj));\\n            }\\n        }\\n    }\\n    false\\n}\\n\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut lo = -1;\\n        let mut hi = 1_000_000_000;\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if can_reach_house(grid.clone(), mid) { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872804,
                "title": "easy-binary-search-and-bfs-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool xx=false;\\n    int ischeck(int mid,int n,int m,vector<vector<int>>&ans){\\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{0,0},mid});\\n      vector<vector<int>>vis(n,vector<int>(m,0));\\n      vis[0][0]=1;\\n       int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      if(mid>=ans[0][0]){\\n        return false;\\n      }\\n      while(!q.empty()){\\n        int row=q.front().first.first;\\n        int col=q.front().first.second;\\n        int val=q.front().second;\\n        if(row==n-1 and col==m-1){\\n          xx=true;\\n          return true;\\n        }\\n        q.pop();\\n        for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and vis[nrow][ncol]==0 and ans[nrow][ncol]!=-1 and ((ans[nrow][ncol]>(val+1)|| (nrow==n-1 and ncol==m-1 and (val+1<=ans[n-1][m-1]))))){\\n              q.push({{nrow,ncol},val+1});\\n              vis[nrow][ncol]=1;\\n              \\n            }\\n          }\\n      }\\n      return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n      int m=grid[0].size();\\n         queue<pair<int,int>>q;\\n      vector<vector<int>>ans(n,vector<int>(m,1e9));\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          if(grid[i][j]==1){\\n            ans[i][j]=0;\\n              q.push({i,j});\\n          }\\n          else if(grid[i][j]==2){\\n            ans[i][j]=-1;\\n          }\\n        }\\n      }\\n      int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      while(!q.empty()){\\n          int row=q.front().first;\\n          int col=q.front().second;\\n          q.pop();\\n          for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and ans[nrow][ncol]!=-1){\\n              if(ans[nrow][ncol]>ans[row][col]+1){\\n                ans[nrow][ncol]=ans[row][col]+1;\\n                q.push({nrow,ncol});\\n              }\\n            }\\n          }\\n      }\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          cout<<ans[i][j]<<\" \";\\n        }\\n        cout<<endl;\\n      }\\n      int low=0;\\n      int high=1e9;\\n      int fans=0;\\n      while(low<=high){\\n        int mid=(low+high)/2;\\n        if(ischeck(mid,n,m,ans)==true){\\n          fans=max(fans,mid);\\n          low=mid+1;\\n        }\\n        else{\\n          high=mid-1;\\n        }\\n      }\\n      if(fans>1e4){\\n        return 1e9;\\n      }\\n     if(fans==0 and xx==false){\\n       return -1;\\n     }\\n\\n      return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool xx=false;\\n    int ischeck(int mid,int n,int m,vector<vector<int>>&ans){\\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{0,0},mid});\\n      vector<vector<int>>vis(n,vector<int>(m,0));\\n      vis[0][0]=1;\\n       int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      if(mid>=ans[0][0]){\\n        return false;\\n      }\\n      while(!q.empty()){\\n        int row=q.front().first.first;\\n        int col=q.front().first.second;\\n        int val=q.front().second;\\n        if(row==n-1 and col==m-1){\\n          xx=true;\\n          return true;\\n        }\\n        q.pop();\\n        for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and vis[nrow][ncol]==0 and ans[nrow][ncol]!=-1 and ((ans[nrow][ncol]>(val+1)|| (nrow==n-1 and ncol==m-1 and (val+1<=ans[n-1][m-1]))))){\\n              q.push({{nrow,ncol},val+1});\\n              vis[nrow][ncol]=1;\\n              \\n            }\\n          }\\n      }\\n      return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      int n=grid.size();\\n      int m=grid[0].size();\\n         queue<pair<int,int>>q;\\n      vector<vector<int>>ans(n,vector<int>(m,1e9));\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          if(grid[i][j]==1){\\n            ans[i][j]=0;\\n              q.push({i,j});\\n          }\\n          else if(grid[i][j]==2){\\n            ans[i][j]=-1;\\n          }\\n        }\\n      }\\n      int delrow[]={-1,0,0,1};\\n      int delcol[]={0,1,-1,0};\\n      while(!q.empty()){\\n          int row=q.front().first;\\n          int col=q.front().second;\\n          q.pop();\\n          for(int i=0;i<4;i++){\\n            int nrow=delrow[i]+row;\\n            int ncol=delcol[i]+col;\\n            if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and ans[nrow][ncol]!=-1){\\n              if(ans[nrow][ncol]>ans[row][col]+1){\\n                ans[nrow][ncol]=ans[row][col]+1;\\n                q.push({nrow,ncol});\\n              }\\n            }\\n          }\\n      }\\n      for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n          cout<<ans[i][j]<<\" \";\\n        }\\n        cout<<endl;\\n      }\\n      int low=0;\\n      int high=1e9;\\n      int fans=0;\\n      while(low<=high){\\n        int mid=(low+high)/2;\\n        if(ischeck(mid,n,m,ans)==true){\\n          fans=max(fans,mid);\\n          low=mid+1;\\n        }\\n        else{\\n          high=mid-1;\\n        }\\n      }\\n      if(fans>1e4){\\n        return 1e9;\\n      }\\n     if(fans==0 and xx==false){\\n       return -1;\\n     }\\n\\n      return fans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3864678,
                "title": "kotlin-solution-by-bfs-plus-dijkstra-s-algorithm",
                "content": "# Approach\\nBFS to emulate fire spreding and Dijkstra\\'s Algorithm to find last day when we can start escaping from this point. \\n\\n# Complexity\\n- Time complexity:\\n$$O(col \\\\cdot row \\\\cdot \\\\log{(col \\\\cdot row)})$$ - Dijkstra with Heap\\n\\n\\n- Space complexity:\\n$$O(col \\\\cdot row)$$ - `visited[row][col]`\\n\\n# Code\\n```\\nclass Solution {\\n    private val moves = listOf(-1 to 0, 0 to -1, 0 to 1, 1 to 0)\\n    private val MAX_ANS = 1_000_000_000\\n\\n    data class Path(val maxM: Int, val x: Int, val y: Int)\\n\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val rowCnt = grid.size\\n        val colCnt = grid.last().size\\n\\n        val map = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n        val fireCells = LinkedList<Pair<Int, Int>>()\\n\\n        grid.withIndex().forEach { (i, row) ->\\n            row.withIndex().forEach { (j, cell) ->\\n                when (cell) {\\n                    1 -> {\\n                        fireCells += i to j\\n                        map[i][j] = 0\\n                    }\\n                    2 -> map[i][j] = -1\\n                }\\n            }\\n        }\\n\\n        while (fireCells.isNotEmpty()) {\\n            val cell = fireCells.removeFirst()\\n\\n            fun Pair<Int, Int>.possibleFireMoves(): List<Pair<Int, Int>> =\\n                moves.map { (this.first + it.first) to (this.second + it.second) }\\n                    .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                    .filter { map[it.first][it.second] == Int.MAX_VALUE }\\n\\n            cell.possibleFireMoves().forEach { (x, y) ->\\n                map[x][y] = map[cell.first][cell.second] + 1\\n                fireCells.add(x to y)\\n            }\\n        }\\n\\n        if (map[rowCnt - 1][colCnt - 1] != Int.MAX_VALUE) map[rowCnt - 1][colCnt - 1] += 1\\n\\n        val queue = PriorityQueue<Path> { a, b -> -a.maxM.compareTo(b.maxM) }\\n        val visited = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n\\n        queue.add(Path(minOf(map[rowCnt - 1][colCnt - 1] - 1, MAX_ANS), x = rowCnt - 1, y = colCnt - 1))\\n\\n        while (queue.isNotEmpty()) {\\n            queue.poll().also { (maxM, x, y) ->\\n                if (visited[x][y] < Int.MAX_VALUE) return@also\\n                visited[x][y] = maxM\\n\\n                fun Pair<Int, Int>.possibleMoves(): List<Pair<Int, Int>> =\\n                    moves.map { (this.first + it.first) to (this.second + it.second) }\\n                        .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                        .filter { visited[it.first][it.second] == Int.MAX_VALUE }\\n                        .filter { map[it.first][it.second] != -1 }\\n\\n\\n                (x to y).possibleMoves().forEach { (newX, newY) ->\\n                    queue.add(Path(minOf(map[newX][newY] - 1, if (maxM == MAX_ANS) MAX_ANS else maxM - 1), newX, newY))\\n                }\\n            }\\n        }\\n\\n        return if (visited[0][0] == Int.MAX_VALUE || visited[0][0] < 0) -1 else visited[0][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private val moves = listOf(-1 to 0, 0 to -1, 0 to 1, 1 to 0)\\n    private val MAX_ANS = 1_000_000_000\\n\\n    data class Path(val maxM: Int, val x: Int, val y: Int)\\n\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val rowCnt = grid.size\\n        val colCnt = grid.last().size\\n\\n        val map = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n        val fireCells = LinkedList<Pair<Int, Int>>()\\n\\n        grid.withIndex().forEach { (i, row) ->\\n            row.withIndex().forEach { (j, cell) ->\\n                when (cell) {\\n                    1 -> {\\n                        fireCells += i to j\\n                        map[i][j] = 0\\n                    }\\n                    2 -> map[i][j] = -1\\n                }\\n            }\\n        }\\n\\n        while (fireCells.isNotEmpty()) {\\n            val cell = fireCells.removeFirst()\\n\\n            fun Pair<Int, Int>.possibleFireMoves(): List<Pair<Int, Int>> =\\n                moves.map { (this.first + it.first) to (this.second + it.second) }\\n                    .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                    .filter { map[it.first][it.second] == Int.MAX_VALUE }\\n\\n            cell.possibleFireMoves().forEach { (x, y) ->\\n                map[x][y] = map[cell.first][cell.second] + 1\\n                fireCells.add(x to y)\\n            }\\n        }\\n\\n        if (map[rowCnt - 1][colCnt - 1] != Int.MAX_VALUE) map[rowCnt - 1][colCnt - 1] += 1\\n\\n        val queue = PriorityQueue<Path> { a, b -> -a.maxM.compareTo(b.maxM) }\\n        val visited = Array(rowCnt) { Array(colCnt) { Int.MAX_VALUE } }\\n\\n        queue.add(Path(minOf(map[rowCnt - 1][colCnt - 1] - 1, MAX_ANS), x = rowCnt - 1, y = colCnt - 1))\\n\\n        while (queue.isNotEmpty()) {\\n            queue.poll().also { (maxM, x, y) ->\\n                if (visited[x][y] < Int.MAX_VALUE) return@also\\n                visited[x][y] = maxM\\n\\n                fun Pair<Int, Int>.possibleMoves(): List<Pair<Int, Int>> =\\n                    moves.map { (this.first + it.first) to (this.second + it.second) }\\n                        .filter { it.first in 0 until rowCnt && it.second in 0 until colCnt }\\n                        .filter { visited[it.first][it.second] == Int.MAX_VALUE }\\n                        .filter { map[it.first][it.second] != -1 }\\n\\n\\n                (x to y).possibleMoves().forEach { (newX, newY) ->\\n                    queue.add(Path(minOf(map[newX][newY] - 1, if (maxM == MAX_ANS) MAX_ANS else maxM - 1), newX, newY))\\n                }\\n            }\\n        }\\n\\n        return if (visited[0][0] == Int.MAX_VALUE || visited[0][0] < 0) -1 else visited[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825464,
                "title": "easy-explanation-bfs-binary-search-dfs",
                "content": "# Approach\\n- First perform a multi source BFS, and for each tile get the time it takes for fire to reach it.\\n- Then perform binary search on possible time values the person can wait at the starting position.\\n    - lower_bound: 0 mins\\n    - upper_bound: INF or 1e9 (in case of no fire) \\n- All now remains is to check if the person, if stalled for `x` minutes at the starting position can reach `grid[n-1][m-1` or not.\\n- Perform a DFS from `0,0`, if at any point fire has reached before or at the same time as you, then `return false`. If you have reached the last tile `return true`.\\n- Edge Case: At the last tile if fire reaches at the same time as you, then also `return true`, so handle this case seperately.\\n\\n# Complexity\\n- Time complexity:\\n    - BFS: O(n*m)\\n    - Binary Search: O(log(n*m))\\n    - DFS: O(n*m);\\n    - We are doing a DFS on every search.\\n    - Final TC: O(nm) + O(log(nm) * nm)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dr[5] = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int n,int m,int x,int y){\\n        if(x >= n || y >= m || x < 0 || y < 0)\\n            return false;\\n        return true;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        //for each tile get the earliest time fire will reach it using BFS\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> fireTime (n,vector<int> (m,INT_MAX));\\n        vector<vector<bool>> vis (n,vector<bool> (m));\\n\\n        queue<pair<int,int>> q;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({i,j});\\n                    vis[i][j] = 1;\\n                    fireTime[i][j] = 0;\\n                }\\n                else if(grid[i][j] == 2){\\n                    //marking wall as visited so we don\\'t push it to queue\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        } \\n\\n        while(!q.empty()){\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++){\\n                if(isValid(n, m, x + dr[i], y + dr[i+1]) && !vis[x+dr[i]][y+dr[i+1]]){\\n                    fireTime[x+dr[i]][y+dr[i+1]] = fireTime[x][y] + 1;\\n                    vis[x+dr[i]][y+dr[i+1]] = 1;\\n                    q.push({x+dr[i],y+dr[i+1]});\\n                }\\n            }\\n        }  \\n\\n        auto check = [&](int time) {\\n\\n            vector<vector<bool>> visDFS (n,vector<bool> (m));\\n\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(grid[i][j] == 2){\\n                        //marking walls as visited \\n                        visDFS[i][j] = 1;\\n                    }\\n                }\\n            }\\n\\n            //try out all paths with DFS\\n            function<bool(int,int,int)> dfs = [&](int x,int y,int fireTimeFromOrigin) {\\n                if(x == n-1 && y == m-1) {\\n                    // first check if reached or not then check for fire\\n                    if(fireTime[x][y] >= time + fireTimeFromOrigin)\\n                        return true;\\n                    return false;\\n                }\\n                if(fireTime[x][y] <= time + fireTimeFromOrigin) return false;;\\n                visDFS[x][y] = 1;\\n                bool result = 0;\\n                for(int i=0;i<4;i++){\\n                    if(isValid(n, m, x + dr[i], y + dr[i+1]) && !visDFS[x+dr[i]][y+dr[i+1]]){\\n                        result |= dfs(x+dr[i],y+dr[i+1], fireTimeFromOrigin + 1);\\n                    }\\n                }\\n                return result;\\n            };\\n            \\n            return dfs(0,0,0);\\n        };\\n\\n        //binary search on time stayed\\n        int l = 0;\\n        int r = 1e9;\\n        int maxTime = -1;\\n        while(r >= l){\\n            int mid = l + (r - l) / 2;\\n            if(check(mid)){\\n                maxTime = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dr[5] = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int n,int m,int x,int y){\\n        if(x >= n || y >= m || x < 0 || y < 0)\\n            return false;\\n        return true;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        //for each tile get the earliest time fire will reach it using BFS\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> fireTime (n,vector<int> (m,INT_MAX));\\n        vector<vector<bool>> vis (n,vector<bool> (m));\\n\\n        queue<pair<int,int>> q;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({i,j});\\n                    vis[i][j] = 1;\\n                    fireTime[i][j] = 0;\\n                }\\n                else if(grid[i][j] == 2){\\n                    //marking wall as visited so we don\\'t push it to queue\\n                    vis[i][j] = 1;\\n                }\\n            }\\n        } \\n\\n        while(!q.empty()){\\n            pair<int,int> cell = q.front();\\n            q.pop();\\n            int x = cell.first;\\n            int y = cell.second;\\n            for(int i=0;i<4;i++){\\n                if(isValid(n, m, x + dr[i], y + dr[i+1]) && !vis[x+dr[i]][y+dr[i+1]]){\\n                    fireTime[x+dr[i]][y+dr[i+1]] = fireTime[x][y] + 1;\\n                    vis[x+dr[i]][y+dr[i+1]] = 1;\\n                    q.push({x+dr[i],y+dr[i+1]});\\n                }\\n            }\\n        }  \\n\\n        auto check = [&](int time) {\\n\\n            vector<vector<bool>> visDFS (n,vector<bool> (m));\\n\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(grid[i][j] == 2){\\n                        //marking walls as visited \\n                        visDFS[i][j] = 1;\\n                    }\\n                }\\n            }\\n\\n            //try out all paths with DFS\\n            function<bool(int,int,int)> dfs = [&](int x,int y,int fireTimeFromOrigin) {\\n                if(x == n-1 && y == m-1) {\\n                    // first check if reached or not then check for fire\\n                    if(fireTime[x][y] >= time + fireTimeFromOrigin)\\n                        return true;\\n                    return false;\\n                }\\n                if(fireTime[x][y] <= time + fireTimeFromOrigin) return false;;\\n                visDFS[x][y] = 1;\\n                bool result = 0;\\n                for(int i=0;i<4;i++){\\n                    if(isValid(n, m, x + dr[i], y + dr[i+1]) && !visDFS[x+dr[i]][y+dr[i+1]]){\\n                        result |= dfs(x+dr[i],y+dr[i+1], fireTimeFromOrigin + 1);\\n                    }\\n                }\\n                return result;\\n            };\\n            \\n            return dfs(0,0,0);\\n        };\\n\\n        //binary search on time stayed\\n        int l = 0;\\n        int r = 1e9;\\n        int maxTime = -1;\\n        while(r >= l){\\n            int mid = l + (r - l) / 2;\\n            if(check(mid)){\\n                maxTime = mid;\\n                l = mid + 1;\\n            }\\n            else{\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799283,
                "title": "bfs-binary-search-real-life-based-bfs-problem-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //at first we have to see for a particular (row,col) the time when the fire  reach the (row,col)\\n\\n    bool ispossible(int row,int col,vector<vector<int>>&fire,vector<vector<int>>&grid,int mid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vis[row][col] = mid;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({mid,{row,col}});//I started after mid seconds ///mid second is my starting point \\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n\\n        while(!q.empty()){\\n            \\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            if(row == n-1 && col == m-1)return true;//I am able to reach the end \\n\\n            //I will visit each cell exactly once ....so BFS and Visited Matrix \\n\\n            for(int i=0;i<4;i++){\\n\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && grid[nrow][ncol] == 0 && !vis[nrow][ncol]){\\n\\n                    if(fire[nrow][ncol] > 1 + t){//current node = (nrow,ncol) got fire later \\\\\\n                    //before than i can move \\n                        vis[nrow][ncol] = 1 + t;\\n                        q.push({1+t,{nrow,ncol}});\\n                    }\\n                    else if(nrow == n-1 && ncol == m-1){\\n                        if( fire[nrow][ncol] >= 1 + t){\\n                            vis[nrow][ncol] = 1 + t;\\n                            q.push({1+t,{nrow,ncol}});\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        queue<pair<int,pair<int,int>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>fire(n,vector<int>(m,1e9));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({0,{i,j}});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        \\n        while(q.empty() == false){\\n\\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                 && fire[nrow][ncol] == 1e9 && grid[nrow][ncol] == 0){\\n                     fire[nrow][ncol] = 1 + t;\\n                     q.push({fire[nrow][ncol],{nrow,ncol}});\\n                 }\\n            }\\n        }\\n\\n        //for wall (i,j)...always fire[i][j] = 1e9 for all rest positions either fire will reach or not able to reach means fire reachs at time = 1e9\\n\\n        //fire[i][j] represent the time when the fire will reach the node = (i,j);\\n\\n        int low = 0;\\n        int high = 1e5;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(ispossible(0,0,fire,grid,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(ans == 1e5)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    //at first we have to see for a particular (row,col) the time when the fire  reach the (row,col)\\n\\n    bool ispossible(int row,int col,vector<vector<int>>&fire,vector<vector<int>>&grid,int mid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        vis[row][col] = mid;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({mid,{row,col}});//I started after mid seconds ///mid second is my starting point \\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n\\n        while(!q.empty()){\\n            \\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n\\n            q.pop();\\n\\n            if(row == n-1 && col == m-1)return true;//I am able to reach the end \\n\\n            //I will visit each cell exactly once ....so BFS and Visited Matrix \\n\\n            for(int i=0;i<4;i++){\\n\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m && grid[nrow][ncol] == 0 && !vis[nrow][ncol]){\\n\\n                    if(fire[nrow][ncol] > 1 + t){//current node = (nrow,ncol) got fire later \\\\\\n                    //before than i can move \\n                        vis[nrow][ncol] = 1 + t;\\n                        q.push({1+t,{nrow,ncol}});\\n                    }\\n                    else if(nrow == n-1 && ncol == m-1){\\n                        if( fire[nrow][ncol] >= 1 + t){\\n                            vis[nrow][ncol] = 1 + t;\\n                            q.push({1+t,{nrow,ncol}});\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\n        queue<pair<int,pair<int,int>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>fire(n,vector<int>(m,1e9));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    q.push({0,{i,j}});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        \\n        while(q.empty() == false){\\n\\n            int t = q.front().first;\\n            int row = q.front().second.first;\\n            int col = q.front().second.second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m \\n                 && fire[nrow][ncol] == 1e9 && grid[nrow][ncol] == 0){\\n                     fire[nrow][ncol] = 1 + t;\\n                     q.push({fire[nrow][ncol],{nrow,ncol}});\\n                 }\\n            }\\n        }\\n\\n        //for wall (i,j)...always fire[i][j] = 1e9 for all rest positions either fire will reach or not able to reach means fire reachs at time = 1e9\\n\\n        //fire[i][j] represent the time when the fire will reach the node = (i,j);\\n\\n        int low = 0;\\n        int high = 1e5;\\n        int ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(ispossible(0,0,fire,grid,mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        if(ans == 1e5)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768181,
                "title": "java-log-m-n-n-m-using-multi-node-bfs-and-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(m+n)N*M\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N*M\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean found = false;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n     class Mypair {\\n        int x , y , time;\\n        public Mypair(int x , int y ,int time){\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n\\n    }\\n\\n    // can we reach end starting from 0,0 with wait time  = initialWaitTime\\n    public boolean canReachEnd(int[][] grid, int[][] time,int initialWaitTime, int n ,int m){\\n        \\n        Queue<Mypair> qe = new LinkedList<>();\\n        boolean[][] vis = new boolean[n][m];\\n        for(int i = 0; i< n; i++){\\n            Arrays.fill(vis[i],false);\\n        }\\n\\n        qe.add(new Mypair(0,0,initialWaitTime));\\n\\n        vis[0][0] = true;\\n\\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            if(tt.x == n-1 && tt.y == m-1){\\n                found = true;\\n                return true;\\n            }\\n            \\n             for(int a = 0 ;a< 4;a++){\\n\\n                    if(  tt.y+dir[a][1]<m &&\\n                        tt.y+dir[a][1]>=0 &&\\n                        tt.x+dir[a][0]<n &&\\n                        tt.x+dir[a][0]>=0 && \\n                        grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 &&\\n                        !vis[tt.x+dir[a][0]][tt.y+dir[a][1]] \\n                        ) {\\n                            if(tt.time+1 < time[tt.x+dir[a][0]][tt.y+dir[a][1]] || time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || (tt.time+1 <= time[tt.x+dir[a][0]][tt.y+dir[a][1]] && tt.x+dir[a][0]==n-1 && tt.y+dir[a][1]==m-1) ){\\n                            vis[tt.x+dir[a][0]][tt.y+dir[a][1]] = true;\\n                           \\n                            qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],tt.time+1));\\n\\n                            }\\n                         }\\n\\n             }\\n        }\\n\\n        return false;\\n    }\\n\\n    public void calMinTimeToBurn(int[][] grid , int[][] time, int n, int m){\\n        Queue<Mypair> qe = new LinkedList<>();\\n        int i , j;\\n        // do multiple level bfs starting with all fire nodes\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    qe.add(new Mypair(i,j,0));\\n                }\\n            }\\n        }\\n\\n             \\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            for(int a = 0 ;a<4;a++){\\n                if(tt.y+dir[a][1]<m &&\\n                 tt.y+dir[a][1]>=0 && \\n                 tt.x+dir[a][0]<n &&\\n                  tt.x+dir[a][0]>=0 && \\n                  grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 )\\n                  {\\n                      // check if the fire has not reached child node or the child node is already burned but with a greater time\\n                    if(time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || time[tt.x+dir[a][0]][tt.y+dir[a][1]]> 1+time[tt.x][tt.y]) {\\n                        \\n                        qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],0));\\n                        time[tt.x+dir[a][0]][tt.y+dir[a][1]] = time[tt.x][tt.y]+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n       \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int i, j, ans = -1;\\n        int[][] time = new int[n][m];\\n        \\n        calMinTimeToBurn(grid,time,n , m);\\n\\n        //tim[0][0] will be min time to reach the fire to staring node. So ans should be between 0 to time[0][0];\\n        int  l =0 , hi = time[0][0];\\n      \\n\\n        while( l <= hi){\\n\\n            int mid = l + (hi - l) / 2;\\n           \\n            if(canReachEnd(grid, time, mid, n ,m )){\\n                ans = mid;\\n                l = mid +1 ;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        if(time[0][0] == 0 && found){\\n            return 1000000000;\\n        }\\n\\n        return !found? -1: ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean found = false;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n\\n     class Mypair {\\n        int x , y , time;\\n        public Mypair(int x , int y ,int time){\\n            this.x = x;\\n            this.y = y;\\n            this.time = time;\\n        }\\n\\n    }\\n\\n    // can we reach end starting from 0,0 with wait time  = initialWaitTime\\n    public boolean canReachEnd(int[][] grid, int[][] time,int initialWaitTime, int n ,int m){\\n        \\n        Queue<Mypair> qe = new LinkedList<>();\\n        boolean[][] vis = new boolean[n][m];\\n        for(int i = 0; i< n; i++){\\n            Arrays.fill(vis[i],false);\\n        }\\n\\n        qe.add(new Mypair(0,0,initialWaitTime));\\n\\n        vis[0][0] = true;\\n\\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            if(tt.x == n-1 && tt.y == m-1){\\n                found = true;\\n                return true;\\n            }\\n            \\n             for(int a = 0 ;a< 4;a++){\\n\\n                    if(  tt.y+dir[a][1]<m &&\\n                        tt.y+dir[a][1]>=0 &&\\n                        tt.x+dir[a][0]<n &&\\n                        tt.x+dir[a][0]>=0 && \\n                        grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 &&\\n                        !vis[tt.x+dir[a][0]][tt.y+dir[a][1]] \\n                        ) {\\n                            if(tt.time+1 < time[tt.x+dir[a][0]][tt.y+dir[a][1]] || time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || (tt.time+1 <= time[tt.x+dir[a][0]][tt.y+dir[a][1]] && tt.x+dir[a][0]==n-1 && tt.y+dir[a][1]==m-1) ){\\n                            vis[tt.x+dir[a][0]][tt.y+dir[a][1]] = true;\\n                           \\n                            qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],tt.time+1));\\n\\n                            }\\n                         }\\n\\n             }\\n        }\\n\\n        return false;\\n    }\\n\\n    public void calMinTimeToBurn(int[][] grid , int[][] time, int n, int m){\\n        Queue<Mypair> qe = new LinkedList<>();\\n        int i , j;\\n        // do multiple level bfs starting with all fire nodes\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    qe.add(new Mypair(i,j,0));\\n                }\\n            }\\n        }\\n\\n             \\n        while(!qe.isEmpty()){\\n            Mypair tt = qe.poll();\\n            for(int a = 0 ;a<4;a++){\\n                if(tt.y+dir[a][1]<m &&\\n                 tt.y+dir[a][1]>=0 && \\n                 tt.x+dir[a][0]<n &&\\n                  tt.x+dir[a][0]>=0 && \\n                  grid[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 )\\n                  {\\n                      // check if the fire has not reached child node or the child node is already burned but with a greater time\\n                    if(time[tt.x+dir[a][0]][tt.y+dir[a][1]]==0 || time[tt.x+dir[a][0]][tt.y+dir[a][1]]> 1+time[tt.x][tt.y]) {\\n                        \\n                        qe.add(new Mypair(tt.x+dir[a][0],tt.y+dir[a][1],0));\\n                        time[tt.x+dir[a][0]][tt.y+dir[a][1]] = time[tt.x][tt.y]+1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int maximumMinutes(int[][] grid) {\\n       \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int i, j, ans = -1;\\n        int[][] time = new int[n][m];\\n        \\n        calMinTimeToBurn(grid,time,n , m);\\n\\n        //tim[0][0] will be min time to reach the fire to staring node. So ans should be between 0 to time[0][0];\\n        int  l =0 , hi = time[0][0];\\n      \\n\\n        while( l <= hi){\\n\\n            int mid = l + (hi - l) / 2;\\n           \\n            if(canReachEnd(grid, time, mid, n ,m )){\\n                ans = mid;\\n                l = mid +1 ;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        if(time[0][0] == 0 && found){\\n            return 1000000000;\\n        }\\n\\n        return !found? -1: ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718079,
                "title": "python-binary-search-bfs-solution-with-explanation",
                "content": "We can use binary search to find the last moment we can stay in the left top corner and still have a way to go to safehouse.\\nsearch space is ```[0, row * col]```, \\n```check(min)``` function return ```True``` means we can stay in the left top corner with ```min``` minutes and still have a way to go to safehouse,\\nif so, we can try to stay longer, if not, stay shorter.\\n\\nFor each each minute, the fire will burn adjacent grass cells.\\n```fire_cells``` store border of fire area, ```fire_set``` store the cells in the fire area.\\n\\nIf we can stay in the left top corner with ```row * col``` minute (the worst thing is that the fire burns all grass cells), and still have a way to go safehouse, which means we alway have a way to go safehouse.\\n\\ntc is O(row * col * log (row * col)), sc is O(row * col).\\n\\n### python\\n```python\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        row_num, col_num = len(grid), len(grid[0])\\n\\t\\t# delta x and y for 4-neighbors\\n\\t\\t#       -1, 0\\n\\t\\t#   0,-1  x   0,1\\n\\t\\t#        1,0\\n\\t\\t# clockwise from 0,1: 0,1,0,-1,0, note 0,1 -> 1,0 = 010\\n        dirs = [0,1,0,-1,0]\\n        \\n\\t\\t# check function: return True means we can stay in the left top corner with `stay` minutes and still have a way to go to safehouse\\n        def check(stay):\\n\\t\\t\\t\\n            fire_cells = [] # border of fire area\\n\\t\\t\\t\\n            fire_set = set() # fire area\\n\\t\\t\\t\\n\\t\\t\\t# initialize the fire area at time point 0\\n            for i, row in enumerate(grid):\\n                for j, n in enumerate(row):\\n                    if n == 1:\\n                        fire_cells.append((i, j))\\n                        fire_set.add((i, j))\\n\\t\\t\\t\\n            # spread_fire() is to update the fire area after 1 minute\\n            def spread_fire():\\n\\t\\t\\t\\t\\n                nonlocal fire_cells # assign a new border\\n\\t\\t\\t\\t\\n                tmp = [] # new border array stores the border of fire area\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell on the border of fire area\\n                for x, y in fire_cells:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                    for i in range(len(dirs)-1):\\n                        nex_x, nex_y = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and it is grass cell and is not in fire area\\n                        if 0 <= nex_x < row_num and 0 <= nex_y < col_num and grid[nex_x][nex_y] == 0 and (nex_x, nex_y) not in fire_set: \\n                            fire_set.add((nex_x, nex_y))\\n                            tmp.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update border list\\n                fire_cells = tmp\\n\\t\\t\\t\\n            # let the fire burn for `stay` minutes\\n            while stay and fire_cells: \\n                spread_fire()\\n                stay -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# if left top corner and safehouse have been in fire area, GG\\n            if (0, 0) in fire_set or (row_num-1, col_num-1) in fire_set: return False\\n\\t\\t\\t\\n\\t\\t\\t# bfs, find a way to go to safehouse\\n            q = deque([(0, 0)])\\n\\t\\t\\t\\n\\t\\t\\t# the cell we have visited\\n            visited = set([(0, 0)])\\n            \\n            while q:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell we can reach at current moment\\n                for _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get position of cell\\n                    cur_x, cur_y = q.popleft()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if cell is not in fire area\\n                    if (cur_x, cur_y) not in fire_set:\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                        for i in range(len(dirs)-1):\\n                            nex_x, nex_y = cur_x + dirs[i], cur_y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and neighbor have not been visited and is a grass cell and not in fire area\\n                            if 0 <= nex_x < row_num and 0 <= nex_y < col_num and (nex_x, nex_y) not in visited and (nex_x, nex_y) not in fire_set and grid[nex_x][nex_y] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# if neighbor is safehouse, return True\\n                                if nex_x == row_num - 1 and nex_y == col_num - 1: return True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# add to visited set and queue\\n                                visited.add((nex_x, nex_y))\\n                                q.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update fire area for each minute\\n                spread_fire()\\n\\t\\t\\t\\n\\t\\t\\t# no way to go to safehouse, GG\\n            return False\\n\\t\\t\\n\\t\\t# search space is [0, row * col]\\n        l = 0\\n        r = row_num * col_num\\n\\t\\t\\n        while l <= r:\\n            m = (l + r) // 2\\n\\t\\t\\t\\n\\t\\t\\t# if True, try to stay longer\\n            if check(m): l = m + 1\\n\\t\\t\\t\\n\\t\\t\\t# stay shorter\\n            else: r = m - 1\\n\\t\\t\\n        # If we can stay in the left top corner with row * col minute, we alway have a way to go safehouse\\n        return r if r < row_num * col_num else 10 ** 9\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```[0, row * col]```\n```check(min)```\n```True```\n```min```\n```fire_cells```\n```fire_set```\n```row * col```\n```python\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        row_num, col_num = len(grid), len(grid[0])\\n\\t\\t# delta x and y for 4-neighbors\\n\\t\\t#       -1, 0\\n\\t\\t#   0,-1  x   0,1\\n\\t\\t#        1,0\\n\\t\\t# clockwise from 0,1: 0,1,0,-1,0, note 0,1 -> 1,0 = 010\\n        dirs = [0,1,0,-1,0]\\n        \\n\\t\\t# check function: return True means we can stay in the left top corner with `stay` minutes and still have a way to go to safehouse\\n        def check(stay):\\n\\t\\t\\t\\n            fire_cells = [] # border of fire area\\n\\t\\t\\t\\n            fire_set = set() # fire area\\n\\t\\t\\t\\n\\t\\t\\t# initialize the fire area at time point 0\\n            for i, row in enumerate(grid):\\n                for j, n in enumerate(row):\\n                    if n == 1:\\n                        fire_cells.append((i, j))\\n                        fire_set.add((i, j))\\n\\t\\t\\t\\n            # spread_fire() is to update the fire area after 1 minute\\n            def spread_fire():\\n\\t\\t\\t\\t\\n                nonlocal fire_cells # assign a new border\\n\\t\\t\\t\\t\\n                tmp = [] # new border array stores the border of fire area\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell on the border of fire area\\n                for x, y in fire_cells:\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                    for i in range(len(dirs)-1):\\n                        nex_x, nex_y = x + dirs[i], y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and it is grass cell and is not in fire area\\n                        if 0 <= nex_x < row_num and 0 <= nex_y < col_num and grid[nex_x][nex_y] == 0 and (nex_x, nex_y) not in fire_set: \\n                            fire_set.add((nex_x, nex_y))\\n                            tmp.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update border list\\n                fire_cells = tmp\\n\\t\\t\\t\\n            # let the fire burn for `stay` minutes\\n            while stay and fire_cells: \\n                spread_fire()\\n                stay -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# if left top corner and safehouse have been in fire area, GG\\n            if (0, 0) in fire_set or (row_num-1, col_num-1) in fire_set: return False\\n\\t\\t\\t\\n\\t\\t\\t# bfs, find a way to go to safehouse\\n            q = deque([(0, 0)])\\n\\t\\t\\t\\n\\t\\t\\t# the cell we have visited\\n            visited = set([(0, 0)])\\n            \\n            while q:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each cell we can reach at current moment\\n                for _ in range(len(q)):\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# get position of cell\\n                    cur_x, cur_y = q.popleft()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if cell is not in fire area\\n                    if (cur_x, cur_y) not in fire_set:\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# get 4-neighbor of each cell\\n                        for i in range(len(dirs)-1):\\n                            nex_x, nex_y = cur_x + dirs[i], cur_y + dirs[i+1]\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# if position of neighbor is valid and neighbor have not been visited and is a grass cell and not in fire area\\n                            if 0 <= nex_x < row_num and 0 <= nex_y < col_num and (nex_x, nex_y) not in visited and (nex_x, nex_y) not in fire_set and grid[nex_x][nex_y] == 0:\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# if neighbor is safehouse, return True\\n                                if nex_x == row_num - 1 and nex_y == col_num - 1: return True\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t# add to visited set and queue\\n                                visited.add((nex_x, nex_y))\\n                                q.append((nex_x, nex_y))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# update fire area for each minute\\n                spread_fire()\\n\\t\\t\\t\\n\\t\\t\\t# no way to go to safehouse, GG\\n            return False\\n\\t\\t\\n\\t\\t# search space is [0, row * col]\\n        l = 0\\n        r = row_num * col_num\\n\\t\\t\\n        while l <= r:\\n            m = (l + r) // 2\\n\\t\\t\\t\\n\\t\\t\\t# if True, try to stay longer\\n            if check(m): l = m + 1\\n\\t\\t\\t\\n\\t\\t\\t# stay shorter\\n            else: r = m - 1\\n\\t\\t\\n        # If we can stay in the left top corner with row * col minute, we alway have a way to go safehouse\\n        return r if r < row_num * col_num else 10 ** 9\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707992,
                "title": "check-top-and-left-of-n-1-m-1-before-comparing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int di[4] = {0,1,0,-1};\\n    int dj[4] = {1,0,-1,0};\\n    bool ispossible(int wait_time,vector<vector<int>>& grid,\\n     vector<vector<int>>& fire )\\n    {\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       vector<vector<int>> person (n, vector<int> (m , INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n       person[0][0] = wait_time;\\n       int cnt = wait_time+1;\\n       while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(ni != n-1 && nj!= m-1 && fire[ni][nj] <= cnt)\\n                        continue; \\n                        if(person[ni][nj] > cnt)\\n                        {\\n                            person[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n        }\\n        int x = (   (person[n-1][m-2] < fire[n-1][m-2]) | \\n        (person[n-2][m-1] < fire[n-2][m-1])  );\\n        return (  x && person[n-1][m-1] <= fire[n-1][m-1]);\\n\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       vector<vector<int>> fire (n, vector<int> (m , INT_MAX));\\n\\n        queue<pair<int,int>> q;\\n       for (int i  = 0; i < n; i++)\\n       {\\n           for (int j = 0; j < m; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   fire[i][j] = 0;\\n                   q.push({i,j});\\n               }\\n           }\\n       }\\n\\n   int cnt = 1;\\n       while(!q.empty())\\n        {\\n         \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n    if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(fire[ni][nj] > cnt)\\n                        {\\n                            fire[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n\\n\\n        }\\n            // for (int i = 0; i < n; i++)\\n            // {\\n            //     for (int j = 0; j <m; j++)\\n            //     {\\n            //         cout<<fire[i][j] <<\\' \\';\\n\\n            //     }\\n            //     cout<<endl;\\n            // }\\n    \\n\\n       //binary search on waiting time\\n       //t t t f f f \\n        int lo = 0, hi = n*m;\\n\\n        if(!ispossible(lo,grid,fire))\\n        {\\n            return -1;\\n        }\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return (int)1e9;\\n        }\\n\\n        while( hi - lo > 1)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(ispossible(mid,grid, fire))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            hi = mid - 1;\\n    \\n        }\\n\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return hi;\\n        }\\n        else\\n\\n        return lo;\\n\\n\\n\\n       \\n\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int di[4] = {0,1,0,-1};\\n    int dj[4] = {1,0,-1,0};\\n    bool ispossible(int wait_time,vector<vector<int>>& grid,\\n     vector<vector<int>>& fire )\\n    {\\n       int n = grid.size();\\n       int m = grid[0].size();\\n       vector<vector<int>> person (n, vector<int> (m , INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n       person[0][0] = wait_time;\\n       int cnt = wait_time+1;\\n       while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n            if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(ni != n-1 && nj!= m-1 && fire[ni][nj] <= cnt)\\n                        continue; \\n                        if(person[ni][nj] > cnt)\\n                        {\\n                            person[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n        }\\n        int x = (   (person[n-1][m-2] < fire[n-1][m-2]) | \\n        (person[n-2][m-1] < fire[n-2][m-1])  );\\n        return (  x && person[n-1][m-1] <= fire[n-1][m-1]);\\n\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      \\n        int n = grid.size();\\n        int m = grid[0].size();\\n       vector<vector<int>> fire (n, vector<int> (m , INT_MAX));\\n\\n        queue<pair<int,int>> q;\\n       for (int i  = 0; i < n; i++)\\n       {\\n           for (int j = 0; j < m; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   fire[i][j] = 0;\\n                   q.push({i,j});\\n               }\\n           }\\n       }\\n\\n   int cnt = 1;\\n       while(!q.empty())\\n        {\\n         \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                auto it = q.front();\\n                int ci = it.first;\\n                int cj = it.second;\\n                q.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int ni = ci+ di[k];\\n                    int nj = cj+ dj[k];\\n\\n    if(ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] != 2)\\n                    {\\n                        if(fire[ni][nj] > cnt)\\n                        {\\n                            fire[ni][nj] = cnt;\\n                            q.push({ni,nj});\\n                        }\\n\\n                    }\\n                }\\n\\n\\n            }\\n            cnt++;\\n\\n\\n        }\\n            // for (int i = 0; i < n; i++)\\n            // {\\n            //     for (int j = 0; j <m; j++)\\n            //     {\\n            //         cout<<fire[i][j] <<\\' \\';\\n\\n            //     }\\n            //     cout<<endl;\\n            // }\\n    \\n\\n       //binary search on waiting time\\n       //t t t f f f \\n        int lo = 0, hi = n*m;\\n\\n        if(!ispossible(lo,grid,fire))\\n        {\\n            return -1;\\n        }\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return (int)1e9;\\n        }\\n\\n        while( hi - lo > 1)\\n        {\\n            int mid = lo + (hi-lo)/2;\\n            if(ispossible(mid,grid, fire))\\n            {\\n                lo = mid;\\n            }\\n            else\\n            hi = mid - 1;\\n    \\n        }\\n\\n        if(ispossible(hi,grid,fire))\\n        {\\n            return hi;\\n        }\\n        else\\n\\n        return lo;\\n\\n\\n\\n       \\n\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3702538,
                "title": "c-bfs-binaryseach",
                "content": "# Intuition\\nspread the fire to all cells first and note the time it take to reach the fire upto particular cells this could be done by bfs\\n// then apply binary search and find the mid it will denote the time for which person would wait for inital pos;\\n//then check whether a person can still reach to deastination by waiting for time mid\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    void fireSpread(vector<vector<int>> &grid, vector<vector<int>> &timeFire)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                { // fire\\n                    pq.push({i, j});\\n                    timeFire[i][j] = 0;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (pq.size() > 0)\\n        {\\n            int size = pq.size();\\n            cur++;\\n            for (int k = 0; k < size; k++)\\n            {\\n                int row = pq.front().first;\\n                int col = pq.front().second;\\n\\n                pq.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nr = row + drow[i];\\n                    int nc = col + dcol[i];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (timeFire[nr][nc] != -1)\\n                        {\\n                            continue;\\n                        }\\n                        timeFire[nr][nc] = cur;\\n                        pq.push({nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    bool validPath(vector<vector<int>> &grid, vector<vector<int>> &timeFire, int time)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, int>> pq;\\n        pq.push({0, 0});\\n        vis[0][0] = 1;\\n        \\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!pq.empty())\\n        {\\n            time++;\\n            int size = pq.size();\\n            for (int i = 0; i < size; i++)\\n            {\\n                int xx = pq.front().first;\\n                int yy = pq.front().second;\\n                pq.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int nr = xx + drow[k];\\n                    int nc = yy + dcol[k];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (nr == n - 1 && nc == m - 1)\\n                        {\\n                            if (timeFire[nr][nc] != -1 && timeFire[nr][nc] < time)\\n                            {\\n                                continue;\\n                            }\\n                            return true;\\n                        }\\n                        if (timeFire[nr][nc] != -1 && timeFire[nr][nc] <= time)\\n                        {\\n                            continue;\\n                        }\\n                        if (vis[nr][nc] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        pq.push({nr, nc});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> timeFire(n, vector<int>(m, -1));\\n        fireSpread(grid, timeFire);\\n\\n        int ans = -1;\\n        int low = 0;\\n        int high = 1e9;\\n        while (low <=high)\\n        {\\n            int mid = (low + high) >> 1;\\n            if (validPath(grid,  timeFire, mid))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void fireSpread(vector<vector<int>> &grid, vector<vector<int>> &timeFire)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int, int>> pq;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                { // fire\\n                    pq.push({i, j});\\n                    timeFire[i][j] = 0;\\n                }\\n            }\\n        }\\n        int cur = 0;\\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (pq.size() > 0)\\n        {\\n            int size = pq.size();\\n            cur++;\\n            for (int k = 0; k < size; k++)\\n            {\\n                int row = pq.front().first;\\n                int col = pq.front().second;\\n\\n                pq.pop();\\n                for (int i = 0; i < 4; i++)\\n                {\\n                    int nr = row + drow[i];\\n                    int nc = col + dcol[i];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (timeFire[nr][nc] != -1)\\n                        {\\n                            continue;\\n                        }\\n                        timeFire[nr][nc] = cur;\\n                        pq.push({nr, nc});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    bool validPath(vector<vector<int>> &grid, vector<vector<int>> &timeFire, int time)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        queue<pair<int, int>> pq;\\n        pq.push({0, 0});\\n        vis[0][0] = 1;\\n        \\n        int drow[] = {-1, 0, 1, 0};\\n        int dcol[] = {0, 1, 0, -1};\\n        while (!pq.empty())\\n        {\\n            time++;\\n            int size = pq.size();\\n            for (int i = 0; i < size; i++)\\n            {\\n                int xx = pq.front().first;\\n                int yy = pq.front().second;\\n                pq.pop();\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int nr = xx + drow[k];\\n                    int nc = yy + dcol[k];\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < m)\\n                    {\\n                        if (grid[nr][nc] == 2)\\n                        {\\n                            continue;\\n                        }\\n                        if (nr == n - 1 && nc == m - 1)\\n                        {\\n                            if (timeFire[nr][nc] != -1 && timeFire[nr][nc] < time)\\n                            {\\n                                continue;\\n                            }\\n                            return true;\\n                        }\\n                        if (timeFire[nr][nc] != -1 && timeFire[nr][nc] <= time)\\n                        {\\n                            continue;\\n                        }\\n                        if (vis[nr][nc] == 1)\\n                        {\\n                            continue;\\n                        }\\n                        pq.push({nr, nc});\\n                        vis[nr][nc] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> timeFire(n, vector<int>(m, -1));\\n        fireSpread(grid, timeFire);\\n\\n        int ans = -1;\\n        int low = 0;\\n        int high = 1e9;\\n        while (low <=high)\\n        {\\n            int mid = (low + high) >> 1;\\n            if (validPath(grid,  timeFire, mid))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617774,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n\\n        queue<pair<int, int>> q;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        auto check = [&](int a, int b)\\n        {\\n            return a >= 0 and a < n and b >= 0 and b < m;\\n        };\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n\\n            q.pop();\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int x = dx[k] + it.first;\\n                int y = dy[k] + it.second;\\n\\n                if (check(x, y) and grid[x][y] == 0 and dist[x][y] == INT_MAX)\\n                {\\n                    q.push({x, y});\\n                    dist[x][y] = dist[it.first][it.second] + 1;\\n                }\\n            }\\n        }\\n        auto bcheck = [&](int mid)\\n        {\\n            queue<pair<int, int>> pq;\\n\\n            pq.push({0, 0});\\n\\n            int cnt = 1;\\n            vector<vector<int>> dist1(n, vector<int>(m, -1));\\n\\n            dist1[0][0] = 0;\\n            while (!pq.empty())\\n            {\\n                auto it = pq.front();\\n\\n                pq.pop();\\n\\n                if (it.first == n - 1 and it.second == m - 1)\\n                {\\n                    return 1;\\n                }\\n\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int x = dx[k] + it.first;\\n                    int y = dy[k] + it.second;\\n\\n                    if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and dist[x][y] > 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                    else if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and x == n - 1 and y == m - 1 and dist[x][y] == 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n\\n        int l = 0, r = 1e9;\\n\\n        int ans = -1;\\n\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n\\n            if (bcheck(mid))\\n            {\\n                l = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumMinutes(vector<vector<int>> &grid)\\n    {\\n\\n        int n = grid.size();\\n\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));\\n\\n        queue<pair<int, int>> q;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    dist[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n\\n        auto check = [&](int a, int b)\\n        {\\n            return a >= 0 and a < n and b >= 0 and b < m;\\n        };\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n\\n            q.pop();\\n\\n            for (int k = 0; k < 4; k++)\\n            {\\n                int x = dx[k] + it.first;\\n                int y = dy[k] + it.second;\\n\\n                if (check(x, y) and grid[x][y] == 0 and dist[x][y] == INT_MAX)\\n                {\\n                    q.push({x, y});\\n                    dist[x][y] = dist[it.first][it.second] + 1;\\n                }\\n            }\\n        }\\n        auto bcheck = [&](int mid)\\n        {\\n            queue<pair<int, int>> pq;\\n\\n            pq.push({0, 0});\\n\\n            int cnt = 1;\\n            vector<vector<int>> dist1(n, vector<int>(m, -1));\\n\\n            dist1[0][0] = 0;\\n            while (!pq.empty())\\n            {\\n                auto it = pq.front();\\n\\n                pq.pop();\\n\\n                if (it.first == n - 1 and it.second == m - 1)\\n                {\\n                    return 1;\\n                }\\n\\n                for (int k = 0; k < 4; k++)\\n                {\\n                    int x = dx[k] + it.first;\\n                    int y = dy[k] + it.second;\\n\\n                    if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and dist[x][y] > 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                    else if (check(x, y) and grid[x][y] == 0 and dist1[x][y] == -1 and x == n - 1 and y == m - 1 and dist[x][y] == 1 + dist1[it.first][it.second] + mid)\\n                    {\\n                        pq.push({x, y});\\n                        dist1[x][y] = dist1[it.first][it.second] + 1;\\n                    }\\n                }\\n            }\\n            return 0;\\n        };\\n\\n        int l = 0, r = 1e9;\\n\\n        int ans = -1;\\n\\n        while (l <= r)\\n        {\\n            int mid = (l + r) / 2;\\n\\n            if (bcheck(mid))\\n            {\\n                l = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605572,
                "title": "easy-to-understand-c-solution-binary-search-bfs-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int maximum = 1000000000;\\n    \\n    int bottom_reaching_time(int wait, vector<vector<int>>& fire, vector<vector<int>>& grid)\\n    {\\n        int r = grid.size(), c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        vector<vector<int>> person(r, vector<int>(c, maximum));\\n        person[0][0] = wait;\\n\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >=0 && y >= 0 && x < r && y < c && grid[x][y] != 2)\\n                    {\\n                        int min_time = min(person[x][y], person[i][j] + 1);\\n                        \\n                        if(x == r - 1 && y == c - 1 && min_time <= fire[r - 1][c - 1])\\n                            return min_time;\\n                        \\n                        if(min_time < fire[x][y])\\n                        {\\n                            if(person[x][y] > person[i][j] + 1)    \\n                            {\\n                                person[x][y] = person[i][j] + 1;\\n                                q.push({x, y}); \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maximum + 1;\\n    }\\n\\n    void fire_spread(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& fire)\\n    {\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    fire[i][j] = -1;\\n                else if(grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >= 0 && y >= 0 && x < r && y < c && fire[x][y] != -1 && fire[x][y] > fire[i][j] + 1)\\n                    {\\n                        fire[x][y] = 1 + fire[i][j];\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size();\\n        \\n        vector<vector<int>> fire(r, vector<int>(c, maximum));\\n        fire_spread(r, c, grid, fire);\\n\\n        if(fire[r - 1][c - 1] == maximum)\\n        {\\n            if(bottom_reaching_time(0, fire, grid) >= maximum)\\n                return -1;\\n            else \\n                return maximum;\\n        }\\n\\n        int low = 0, high = (r * c) + 1, ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(bottom_reaching_time(mid, fire, grid) <= fire[r - 1][c - 1])\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        if(ans >= (r * c) + 1)\\n            return maximum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int maximum = 1000000000;\\n    \\n    int bottom_reaching_time(int wait, vector<vector<int>>& fire, vector<vector<int>>& grid)\\n    {\\n        int r = grid.size(), c = grid[0].size();\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        vector<vector<int>> person(r, vector<int>(c, maximum));\\n        person[0][0] = wait;\\n\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >=0 && y >= 0 && x < r && y < c && grid[x][y] != 2)\\n                    {\\n                        int min_time = min(person[x][y], person[i][j] + 1);\\n                        \\n                        if(x == r - 1 && y == c - 1 && min_time <= fire[r - 1][c - 1])\\n                            return min_time;\\n                        \\n                        if(min_time < fire[x][y])\\n                        {\\n                            if(person[x][y] > person[i][j] + 1)    \\n                            {\\n                                person[x][y] = person[i][j] + 1;\\n                                q.push({x, y}); \\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return maximum + 1;\\n    }\\n\\n    void fire_spread(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& fire)\\n    {\\n        queue<pair<int, int>> q;\\n        for(int i = 0; i < r; i++)\\n        {\\n            for(int j = 0; j < c; j++)\\n            {\\n                if(grid[i][j] == 2)\\n                    fire[i][j] = -1;\\n                else if(grid[i][j] == 1)\\n                {\\n                    q.push({i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(q.size())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto [i, j] = q.front();\\n                q.pop();\\n                for(auto it: dir)\\n                {\\n                    int x = i + it.first;\\n                    int y = j + it.second;\\n                    if(x >= 0 && y >= 0 && x < r && y < c && fire[x][y] != -1 && fire[x][y] > fire[i][j] + 1)\\n                    {\\n                        fire[x][y] = 1 + fire[i][j];\\n                        q.push({x, y});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int r = grid.size(), c = grid[0].size();\\n        \\n        vector<vector<int>> fire(r, vector<int>(c, maximum));\\n        fire_spread(r, c, grid, fire);\\n\\n        if(fire[r - 1][c - 1] == maximum)\\n        {\\n            if(bottom_reaching_time(0, fire, grid) >= maximum)\\n                return -1;\\n            else \\n                return maximum;\\n        }\\n\\n        int low = 0, high = (r * c) + 1, ans = -1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(bottom_reaching_time(mid, fire, grid) <= fire[r - 1][c - 1])\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n        if(ans >= (r * c) + 1)\\n            return maximum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599755,
                "title": "bfs-with-binary-search",
                "content": "# Intuition\\ntwo bfs at the same time - one with source as all the initial fire cells and the other with person as the source. to find the latest time, we can use binary search.\\n\\n# Approach\\nbinary search with multiple bfs\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n        int end = n*m;\\n        int start = 0;\\n        int mid = start + (end-start)/2;\\n        int[][] gridCopy = new int[n][m];\\n        \\n        while(start < end){\\n            mid = start + (end-start)/2;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    gridCopy[i][j] = grid[i][j];\\n                }\\n            }\\n            if(canReach(gridCopy, dirs, mid, n, m)){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        return mid == n*m - 1 ? 1000000000 : (!canReach(grid, dirs, mid, n, m)) ? mid - 1 : mid;  \\n    }\\n\\n    private boolean canReach(int[][] grid, int[][] dirs, int mid, int n, int m) {\\n\\n        Queue<int[]> fireQueue = new LinkedList<>();\\n        for(int i=0; i < n; i++) {\\n            for(int j =0; j< m; j++) {\\n                if(grid[i][j] == 1) {\\n                    fireQueue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n\\n        int time =0;\\n\\n        while(!fireQueue.isEmpty()) {\\n\\n            if(mid == 0) {\\n                break;\\n            }\\n            int size = fireQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == 0 && y == 0) {\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n            time++;\\n            if(time >= mid) {\\n                break;\\n            }\\n        }\\n\\n        Queue<int[]> personQueue = new LinkedList<>();\\n        personQueue.add(new int[] {0, 0});\\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        while(!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n            int fireSize = fireQueue.size();\\n            for(int i =0; i< fireSize; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        if(canReachAtTheSameTime(personQueue, n, m, dirs)) {\\n                            return true;\\n                        }\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n\\n            int size = personQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = personQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        return true;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0 && !visited[x][y]) {\\n                        visited[x][y] = true;\\n                        personQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private boolean canReachAtTheSameTime(Queue<int[]> personQueue, int n, int m, int[][] dirs) {\\n        int size = personQueue.size();\\n        for(int i =0; i< size; i++) {\\n            int[] curr = personQueue.poll();\\n            for(int[] dir : dirs) {\\n                int x = curr[0] + dir[0];\\n                int y = curr[1] + dir[1];\\n                if(x == n-1 && y == m-1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] dirs = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\\n        int end = n*m;\\n        int start = 0;\\n        int mid = start + (end-start)/2;\\n        int[][] gridCopy = new int[n][m];\\n        \\n        while(start < end){\\n            mid = start + (end-start)/2;\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    gridCopy[i][j] = grid[i][j];\\n                }\\n            }\\n            if(canReach(gridCopy, dirs, mid, n, m)){\\n                start = mid+1;\\n            }else{\\n                end = mid;\\n            }\\n        }\\n        return mid == n*m - 1 ? 1000000000 : (!canReach(grid, dirs, mid, n, m)) ? mid - 1 : mid;  \\n    }\\n\\n    private boolean canReach(int[][] grid, int[][] dirs, int mid, int n, int m) {\\n\\n        Queue<int[]> fireQueue = new LinkedList<>();\\n        for(int i=0; i < n; i++) {\\n            for(int j =0; j< m; j++) {\\n                if(grid[i][j] == 1) {\\n                    fireQueue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n\\n        int time =0;\\n\\n        while(!fireQueue.isEmpty()) {\\n\\n            if(mid == 0) {\\n                break;\\n            }\\n            int size = fireQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == 0 && y == 0) {\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n            time++;\\n            if(time >= mid) {\\n                break;\\n            }\\n        }\\n\\n        Queue<int[]> personQueue = new LinkedList<>();\\n        personQueue.add(new int[] {0, 0});\\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        while(!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n            int fireSize = fireQueue.size();\\n            for(int i =0; i< fireSize; i++) {\\n                int[] curr = fireQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        if(canReachAtTheSameTime(personQueue, n, m, dirs)) {\\n                            return true;\\n                        }\\n                        return false;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0) {\\n                        grid[x][y] = 1;\\n                        fireQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n\\n            int size = personQueue.size();\\n            for(int i =0; i< size; i++) {\\n                int[] curr = personQueue.poll();\\n                for(int[] dir : dirs) {\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x == n-1 && y == m-1) {\\n                        return true;\\n                    }\\n                    if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0 && !visited[x][y]) {\\n                        visited[x][y] = true;\\n                        personQueue.add(new int[] {x, y});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    private boolean canReachAtTheSameTime(Queue<int[]> personQueue, int n, int m, int[][] dirs) {\\n        int size = personQueue.size();\\n        for(int i =0; i< size; i++) {\\n            int[] curr = personQueue.poll();\\n            for(int[] dir : dirs) {\\n                int x = curr[0] + dir[0];\\n                int y = curr[1] + dir[1];\\n                if(x == n-1 && y == m-1) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549660,
                "title": "easy-bfs-runtime-23-ms-beats-66-67",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][] walk;\\n    int[][] fire;\\n    public int maximumMinutes(int[][] arr) {\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        walk = new int[n][m];\\n        fire = new int[n][m];\\n\\n        walkType(walk,arr);\\n        fireType(fire,arr);\\n\\n        if(walk[n - 1][m - 1] != Integer.MAX_VALUE){\\n            if (fire[n - 1][m - 1] == Integer.MAX_VALUE) return 1000000000;\\n            int diff = fire[n - 1][m - 1] - walk[n - 1][m - 1];\\n            if (diff > 0){\\n                if(check(arr)) return diff;\\n                else return diff - 1;\\n            }\\n            if (diff < 0) return -1;\\n            if (diff == 0){\\n                int get = talk(arr);\\n                if (get >= 2) return 0;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void fireType(int[][] fire, int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : fire) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (arr[i][j] == 1){\\n                    fire[i][j] = 0;\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] != 2 && fire[d_i][d_j] > fire[i][j] + 1){\\n                    fire[d_i][d_j] = fire[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n    }\\n\\n    public void walkType(int[][] walk,int[][] arr){\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : walk) Arrays.fill(a, Integer.MAX_VALUE);\\n        walk[0][0] = 0;\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] == 0 && walk[d_i][d_j] > walk[i][j] + 1){\\n                    walk[d_i][d_j] = walk[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n\\n    }\\n    public boolean check(int i, int j, int n, int m){\\n        return (i > -1 && i < n) && (j > -1 && j < m);\\n    }\\n    public int talk(int [][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n        int cnt = 0;\\n        if (arr[n - 2][m - 2] != 2){\\n            if (walk[n - 2][m - 2] != fire[n - 2][m - 2]) cnt++;\\n        }\\n        if (arr[n - 2][m - 1] != 2){\\n            if (walk[n - 2][m - 1] != fire[n - 2][m - 1]) cnt++;\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            if (walk[n - 1][m - 2] != fire[n - 1][m - 2]) cnt++;\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public boolean check(int[][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        Set< Integer > set = new HashSet<>();\\n        if (arr[n - 2][m - 1] != 2){\\n            set.add(walk[n - 2][m - 1] - fire[n - 2][m - 1]);\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            set.add(walk[n - 1][m - 2] - fire[n - 1][m - 2]);\\n        }\\n\\n        return set.size() == 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    int[][] walk;\\n    int[][] fire;\\n    public int maximumMinutes(int[][] arr) {\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        walk = new int[n][m];\\n        fire = new int[n][m];\\n\\n        walkType(walk,arr);\\n        fireType(fire,arr);\\n\\n        if(walk[n - 1][m - 1] != Integer.MAX_VALUE){\\n            if (fire[n - 1][m - 1] == Integer.MAX_VALUE) return 1000000000;\\n            int diff = fire[n - 1][m - 1] - walk[n - 1][m - 1];\\n            if (diff > 0){\\n                if(check(arr)) return diff;\\n                else return diff - 1;\\n            }\\n            if (diff < 0) return -1;\\n            if (diff == 0){\\n                int get = talk(arr);\\n                if (get >= 2) return 0;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void fireType(int[][] fire, int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : fire) Arrays.fill(a, Integer.MAX_VALUE);\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (arr[i][j] == 1){\\n                    fire[i][j] = 0;\\n                    queue.add(new int[]{i,j});\\n                }\\n            }\\n        }\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] != 2 && fire[d_i][d_j] > fire[i][j] + 1){\\n                    fire[d_i][d_j] = fire[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n    }\\n\\n    public void walkType(int[][] walk,int[][] arr){\\n\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        for(int[] a : walk) Arrays.fill(a, Integer.MAX_VALUE);\\n        walk[0][0] = 0;\\n\\n        Queue< int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        while (!queue.isEmpty()){\\n\\n            int[] l = queue.remove();\\n\\n            int i = l[0], j = l[1];\\n\\n            int[] c_i = {1,0,0,-1};\\n            int[] c_j = {0,1,-1,0};\\n\\n            for (int k = 0; k < 4 ; k++) {\\n                int d_i = i + c_i[k], d_j = j + c_j[k];\\n                if (check(d_i, d_j, n, m) && arr[d_i][d_j] == 0 && walk[d_i][d_j] > walk[i][j] + 1){\\n                    walk[d_i][d_j] = walk[i][j] + 1;\\n                    queue.add(new int[]{d_i,d_j});\\n                }\\n            }\\n        }\\n\\n    }\\n    public boolean check(int i, int j, int n, int m){\\n        return (i > -1 && i < n) && (j > -1 && j < m);\\n    }\\n    public int talk(int [][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n        int cnt = 0;\\n        if (arr[n - 2][m - 2] != 2){\\n            if (walk[n - 2][m - 2] != fire[n - 2][m - 2]) cnt++;\\n        }\\n        if (arr[n - 2][m - 1] != 2){\\n            if (walk[n - 2][m - 1] != fire[n - 2][m - 1]) cnt++;\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            if (walk[n - 1][m - 2] != fire[n - 1][m - 2]) cnt++;\\n        }\\n\\n        return cnt;\\n\\n    }\\n    public boolean check(int[][] arr){\\n\\n        int n = arr.length, m = arr[0].length;\\n\\n        Set< Integer > set = new HashSet<>();\\n        if (arr[n - 2][m - 1] != 2){\\n            set.add(walk[n - 2][m - 1] - fire[n - 2][m - 1]);\\n        }\\n        if (arr[n - 1][m - 2] != 2){\\n            set.add(walk[n - 1][m - 2] - fire[n - 1][m - 2]);\\n        }\\n\\n        return set.size() == 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522519,
                "title": "python-bfs-and-binary-search-simple-for-undestanding-code-with-comments",
                "content": "# Intuition\\n**How we could traverse?**\\n*BFS*\\n**And how much we should wait till do this BFS?**\\n*We can suppose... oh, wait, binary search can do that for us.*\\n\\n\\n# Approach\\nAs simple as it described: BFS + binary search\\n\\n# Complexity\\n- Time complexity:\\n$$O((m*n) * log (m*n))$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        def valid(grid: List[List[int]], row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n and grid[row][col] == 0\\n        \\n        def bfs(grid: List[List[int]], t: int) -> bool:\\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n            seen = set((0, 0))\\n            queue = deque([(0, 0, 0, 0)])\\n\\n            fire_seen = set(fires)\\n            fire_queue = deque(fires)\\n\\n            fire_time = 0\\n            \\n            # Let\\'s check: \\n            # 1. Are we in fire?\\n            # 2. Is exit in fire?\\n            if not valid(grid, 0, 0) or not valid(grid, m - 1, n - 1):\\n                return False\\n\\n            # Now we can go and then fire\\'s spreading:\\n            while queue:\\n                if fire_time >= t:\\n                    for _ in range(len(queue)):\\n                        row, col, prev_row, prev_col = queue.popleft()\\n\\n                        if row == m - 1 and col == n - 1 and valid(grid, prev_row, prev_col) and valid(grid, row, col):\\n                            return True\\n\\n                        if valid(grid, prev_row, prev_col):\\n                            for dx, dy in directions:\\n                                new_row, new_col = row + dx, col + dy\\n\\n                                if valid(grid, new_row, new_col) and (new_row, new_col) not in seen:\\n                                    queue.append((new_row, new_col, row, col))\\n                                    seen.add((new_row, new_col))\\n\\n                if fire_queue:\\n                    fire_time += 1\\n                    for _ in range(len(fire_queue)):\\n                        fire_row, fire_col = fire_queue.popleft()\\n                        grid[fire_row][fire_col] = 1\\n\\n                        for dx, dy in directions:\\n                            new_fire_row, new_fire_col = fire_row + dx, fire_col + dy\\n\\n                            if valid(grid, new_fire_row, new_fire_col):\\n                                fire_queue.append((new_fire_row, new_fire_col))\\n                                \\n                if not fire_queue:\\n                    fire_time = t\\n\\n            return False\\n\\n        import copy\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        fires = []\\n\\n        # Get all fires for bfs starts positions\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    fires.append((row, col))\\n\\n        # Can we actually go through this?\\n        if not bfs(copy.deepcopy(grid), 0):\\n            return -1\\n    \\n        # Can fire get to us?\\n        if bfs(copy.deepcopy(grid), m *n):\\n            return pow(10, 9)\\n\\n        # Let\\'s fo through this:\\n        left, right = 0, m * n\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n\\n            if bfs(copy.deepcopy(grid), mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        def valid(grid: List[List[int]], row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n and grid[row][col] == 0\\n        \\n        def bfs(grid: List[List[int]], t: int) -> bool:\\n            directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n            seen = set((0, 0))\\n            queue = deque([(0, 0, 0, 0)])\\n\\n            fire_seen = set(fires)\\n            fire_queue = deque(fires)\\n\\n            fire_time = 0\\n            \\n            # Let\\'s check: \\n            # 1. Are we in fire?\\n            # 2. Is exit in fire?\\n            if not valid(grid, 0, 0) or not valid(grid, m - 1, n - 1):\\n                return False\\n\\n            # Now we can go and then fire\\'s spreading:\\n            while queue:\\n                if fire_time >= t:\\n                    for _ in range(len(queue)):\\n                        row, col, prev_row, prev_col = queue.popleft()\\n\\n                        if row == m - 1 and col == n - 1 and valid(grid, prev_row, prev_col) and valid(grid, row, col):\\n                            return True\\n\\n                        if valid(grid, prev_row, prev_col):\\n                            for dx, dy in directions:\\n                                new_row, new_col = row + dx, col + dy\\n\\n                                if valid(grid, new_row, new_col) and (new_row, new_col) not in seen:\\n                                    queue.append((new_row, new_col, row, col))\\n                                    seen.add((new_row, new_col))\\n\\n                if fire_queue:\\n                    fire_time += 1\\n                    for _ in range(len(fire_queue)):\\n                        fire_row, fire_col = fire_queue.popleft()\\n                        grid[fire_row][fire_col] = 1\\n\\n                        for dx, dy in directions:\\n                            new_fire_row, new_fire_col = fire_row + dx, fire_col + dy\\n\\n                            if valid(grid, new_fire_row, new_fire_col):\\n                                fire_queue.append((new_fire_row, new_fire_col))\\n                                \\n                if not fire_queue:\\n                    fire_time = t\\n\\n            return False\\n\\n        import copy\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n        fires = []\\n\\n        # Get all fires for bfs starts positions\\n        for row in range(m):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    fires.append((row, col))\\n\\n        # Can we actually go through this?\\n        if not bfs(copy.deepcopy(grid), 0):\\n            return -1\\n    \\n        # Can fire get to us?\\n        if bfs(copy.deepcopy(grid), m *n):\\n            return pow(10, 9)\\n\\n        # Let\\'s fo through this:\\n        left, right = 0, m * n\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n\\n            if bfs(copy.deepcopy(grid), mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496529,
                "title": "my-solutions",
                "content": "**1. Use the BFS and the binary search**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int original_grass = 0;\\n  static constexpr int grass = numeric_limits<int>::max();   // which means the fire cannot reach\\n  static constexpr int original_wall = 2;\\n  static constexpr int fire = 0;\\n  static constexpr int wall = fire;   // the wall has the same effect with the fire\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<q_node_t> q;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == original_grass) {\\n          grid[r][c] = grass;\\n        } else if (grid[r][c] == original_wall) {\\n          grid[r][c] = wall;\\n        } else {\\n          // grid[r][c] should be `fire`\\n          grid[r][c] = fire;\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n \\n    int time = -1;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        grid[r][c] = time;\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && grid[nr][nc] == grass) {\\n            q.emplace(nr, nc);\\n            visited[nr][nc] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    int low = 0;\\n    int high = rows * cols;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      if (can_reach(grid, mid)) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    if (high == rows * cols) {\\n      return can_wait_for_any_time;\\n    }\\n    return high - 1;\\n  }\\n  \\n private:\\n  bool can_reach(const vector<vector<int>> &grid, const int initial_time) {\\n    if (initial_time >= grid.front().front()) {\\n      return false;\\n    }\\n    \\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    q.emplace(0, 0);\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    visited[0][0] = true;\\n    int time = initial_time;\\n    bool ret = false;\\n    while (!ret && !q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc]) {\\n            continue;\\n          }\\n        \\n          if (nr == rows - 1 && nc == cols - 1) {\\n            ret = time <= grid[nr][nc];\\n            break;\\n          }\\n\\n          if (time >= grid[nr][nc]) {\\n            continue;\\n          }\\n          \\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the BFS**\\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int grass = 0;\\n  static constexpr int wall = 2;\\n  static constexpr int fire = 1;\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  static constexpr int infinite = numeric_limits<int>::max();\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const auto [player_time_to_safehouse, player_time_to_above_safehouse, player_time_to_left_safehouse] = get_player_information(grid);\\n    if (player_time_to_safehouse == infinite) {\\n      return unreachable;\\n    }\\n    \\n    const auto [fire_time_to_safehouse, fire_time_to_above_safehouse, fire_time_to_left_safehouse] = get_fire_information(grid);\\n    if (fire_time_to_safehouse == infinite) {\\n      return can_wait_for_any_time;\\n    }\\n    \\n    if (fire_time_to_safehouse < player_time_to_safehouse) {\\n      return unreachable;\\n    }\\n    \\n    // fire_time_to_safehouse >= player_time_to_safehouse\\n    const int diff_time_to_safehouse = fire_time_to_safehouse - player_time_to_safehouse;\\n    const int diff_time_to_above_safehouse = fire_time_to_above_safehouse - player_time_to_above_safehouse;\\n    const int diff_time_to_left_safehouse = fire_time_to_left_safehouse - player_time_to_left_safehouse;\\n    if (player_time_to_above_safehouse == infinite ||\\n        player_time_to_left_safehouse == infinite ||\\n        (diff_time_to_safehouse == diff_time_to_above_safehouse &&\\n         diff_time_to_safehouse == diff_time_to_left_safehouse)) {\\n      return diff_time_to_safehouse - 1;\\n    }\\n    return diff_time_to_safehouse;\\n  }\\n  \\n private:\\n  tuple<int, int, int> get_player_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q({make_pair(0, 0)});\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    visited[0][0] = true;\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  tuple<int, int, int> get_fire_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fire) {\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  /**\\n   * @return: a tuple which includes three elements,\\n   *          1. the time to reach the safehouse (the cell `grid[rows - 1][cols - 1]`)\\n   *          2. the time to reach the above cell of the safehouse (the cell `grid[rows - 2][cols - 1]`)\\n   *          2. the time to reach the left cell of the safehouse (the cell `grid[rows - 1][cols - 2]`)\\n   */\\n  tuple<int, int, int> bfs(const vector<vector<int>> &grid, queue<q_node_t> &q, vector<vector<bool>> &visited) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int time = -1;\\n    int time_to_safehouse = infinite;\\n    int time_to_above_safehouse = infinite;\\n    int time_to_left_safehouse = infinite;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          time_to_safehouse = time;\\n        } else if (r == rows - 2 && c == cols - 1) {\\n          time_to_above_safehouse = time;\\n        } else if (r == rows - 1 && c == cols - 2) {\\n          time_to_left_safehouse = time;\\n        }\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] || grid[nr][nc] == wall) {\\n            continue;\\n          }\\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return make_tuple(time_to_safehouse, time_to_above_safehouse, time_to_left_safehouse);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int original_grass = 0;\\n  static constexpr int grass = numeric_limits<int>::max();   // which means the fire cannot reach\\n  static constexpr int original_wall = 2;\\n  static constexpr int fire = 0;\\n  static constexpr int wall = fire;   // the wall has the same effect with the fire\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    queue<q_node_t> q;\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == original_grass) {\\n          grid[r][c] = grass;\\n        } else if (grid[r][c] == original_wall) {\\n          grid[r][c] = wall;\\n        } else {\\n          // grid[r][c] should be `fire`\\n          grid[r][c] = fire;\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n \\n    int time = -1;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        grid[r][c] = time;\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc] && grid[nr][nc] == grass) {\\n            q.emplace(nr, nc);\\n            visited[nr][nc] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    int low = 0;\\n    int high = rows * cols;\\n    while (low < high) {\\n      const int mid = low + (high - low) / 2;\\n      if (can_reach(grid, mid)) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    if (high == rows * cols) {\\n      return can_wait_for_any_time;\\n    }\\n    return high - 1;\\n  }\\n  \\n private:\\n  bool can_reach(const vector<vector<int>> &grid, const int initial_time) {\\n    if (initial_time >= grid.front().front()) {\\n      return false;\\n    }\\n    \\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    q.emplace(0, 0);\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    visited[0][0] = true;\\n    int time = initial_time;\\n    bool ret = false;\\n    while (!ret && !q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc]) {\\n            continue;\\n          }\\n        \\n          if (nr == rows - 1 && nc == cols - 1) {\\n            ret = time <= grid[nr][nc];\\n            break;\\n          }\\n\\n          if (time >= grid[nr][nc]) {\\n            continue;\\n          }\\n          \\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n private:\\n  using q_node_t = pair<int, int>;   // {the row, the column}\\n  static constexpr int directions[] = {0, -1, 0, 1, 0};\\n  static constexpr int n_directions = 4;\\n  static constexpr int grass = 0;\\n  static constexpr int wall = 2;\\n  static constexpr int fire = 1;\\n  static constexpr int can_wait_for_any_time = 1000000000;\\n  static constexpr int infinite = numeric_limits<int>::max();\\n  static constexpr int unreachable = -1;\\n  \\n public:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    const auto [player_time_to_safehouse, player_time_to_above_safehouse, player_time_to_left_safehouse] = get_player_information(grid);\\n    if (player_time_to_safehouse == infinite) {\\n      return unreachable;\\n    }\\n    \\n    const auto [fire_time_to_safehouse, fire_time_to_above_safehouse, fire_time_to_left_safehouse] = get_fire_information(grid);\\n    if (fire_time_to_safehouse == infinite) {\\n      return can_wait_for_any_time;\\n    }\\n    \\n    if (fire_time_to_safehouse < player_time_to_safehouse) {\\n      return unreachable;\\n    }\\n    \\n    // fire_time_to_safehouse >= player_time_to_safehouse\\n    const int diff_time_to_safehouse = fire_time_to_safehouse - player_time_to_safehouse;\\n    const int diff_time_to_above_safehouse = fire_time_to_above_safehouse - player_time_to_above_safehouse;\\n    const int diff_time_to_left_safehouse = fire_time_to_left_safehouse - player_time_to_left_safehouse;\\n    if (player_time_to_above_safehouse == infinite ||\\n        player_time_to_left_safehouse == infinite ||\\n        (diff_time_to_safehouse == diff_time_to_above_safehouse &&\\n         diff_time_to_safehouse == diff_time_to_left_safehouse)) {\\n      return diff_time_to_safehouse - 1;\\n    }\\n    return diff_time_to_safehouse;\\n  }\\n  \\n private:\\n  tuple<int, int, int> get_player_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q({make_pair(0, 0)});\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    visited[0][0] = true;\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  tuple<int, int, int> get_fire_information(const vector<vector<int>> &grid) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    queue<q_node_t> q;\\n    vector<vector<bool>> visited(rows, vector<bool>(cols));\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        if (grid[r][c] == fire) {\\n          q.emplace(r, c);\\n          visited[r][c] = true;\\n        }\\n      }\\n    }\\n    return bfs(grid, q, visited);\\n  }\\n  \\n  /**\\n   * @return: a tuple which includes three elements,\\n   *          1. the time to reach the safehouse (the cell `grid[rows - 1][cols - 1]`)\\n   *          2. the time to reach the above cell of the safehouse (the cell `grid[rows - 2][cols - 1]`)\\n   *          2. the time to reach the left cell of the safehouse (the cell `grid[rows - 1][cols - 2]`)\\n   */\\n  tuple<int, int, int> bfs(const vector<vector<int>> &grid, queue<q_node_t> &q, vector<vector<bool>> &visited) {\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    int time = -1;\\n    int time_to_safehouse = infinite;\\n    int time_to_above_safehouse = infinite;\\n    int time_to_left_safehouse = infinite;\\n    while (!q.empty()) {\\n      ++time;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const auto [r, c] = q.front();\\n        q.pop();\\n        if (r == rows - 1 && c == cols - 1) {\\n          time_to_safehouse = time;\\n        } else if (r == rows - 2 && c == cols - 1) {\\n          time_to_above_safehouse = time;\\n        } else if (r == rows - 1 && c == cols - 2) {\\n          time_to_left_safehouse = time;\\n        }\\n        for (int d = 0; d < n_directions; ++d) {\\n          const int nr = r + directions[d];\\n          const int nc = c + directions[d + 1];\\n          if (nr < 0 || nr >= rows || nc < 0 || nc >= cols || visited[nr][nc] || grid[nr][nc] == wall) {\\n            continue;\\n          }\\n          q.emplace(nr, nc);\\n          visited[nr][nc] = true;\\n        }\\n      }\\n    }\\n    return make_tuple(time_to_safehouse, time_to_above_safehouse, time_to_left_safehouse);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404064,
                "title": "python-simple-bfs-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        m,n = len(grid),len(grid[0])\\n\\n        fires, dist = [], [[float(\"inf\")]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j,0))\\n                    dist[i][j] = 0\\n\\n        while fires:\\n            x,y,t = fires.pop(0)\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and dist[nx][ny] > t+1:\\n                    dist[nx][ny] = t+1\\n                    fires.append((nx,ny,t+1))\\n\\n        def is_possible(t): \\n            stack, visited = [(0,0,t)], [[0]*n for _ in range(m)]\\n\\n            while stack:\\n                x,y,val = stack.pop(0)\\n\\n                for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                    if nx == m-1 and ny == n-1 and val+1 <= dist[nx][ny]:\\n                        return True\\n\\n                    if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and visited[nx][ny] == 0 and val+1 < dist[nx][ny]:\\n                        stack.append((nx,ny,val+1))\\n                        visited[nx][ny] = 1\\n\\n            return False\\n\\n        low, high = 0, 10**9\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if is_possible(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid):\\n        m,n = len(grid),len(grid[0])\\n\\n        fires, dist = [], [[float(\"inf\")]*n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    fires.append((i,j,0))\\n                    dist[i][j] = 0\\n\\n        while fires:\\n            x,y,t = fires.pop(0)\\n\\n            for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and dist[nx][ny] > t+1:\\n                    dist[nx][ny] = t+1\\n                    fires.append((nx,ny,t+1))\\n\\n        def is_possible(t): \\n            stack, visited = [(0,0,t)], [[0]*n for _ in range(m)]\\n\\n            while stack:\\n                x,y,val = stack.pop(0)\\n\\n                for nx,ny in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]:\\n                    if nx == m-1 and ny == n-1 and val+1 <= dist[nx][ny]:\\n                        return True\\n\\n                    if 0 <= nx <= m-1 and 0 <= ny <= n-1 and grid[nx][ny] == 0 and visited[nx][ny] == 0 and val+1 < dist[nx][ny]:\\n                        stack.append((nx,ny,val+1))\\n                        visited[nx][ny] = 1\\n\\n            return False\\n\\n        low, high = 0, 10**9\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n\\n            if is_possible(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298474,
                "title": "binary-search-with-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Since the cell is relatively small, we can use high/low guessing game to find the min wait time\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* First we spread the fire for each wait time, then we move, then we spread the fire again\\n* Before the move, make sure to check weather fire reached this cell\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * m * log(m * n)) where n and m are grid dimensions\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\n\\n    List<int[]> initialFires = new ArrayList<>();\\n    int[][] directions = new int[][] {\\n        new int[] {1, 0},\\n        new int[] {-1, 0},\\n        new int[] {0, 1},\\n        new int[] {0, -1}\\n    };\\n\\n    public int maximumMinutes(int[][] grid) {\\n        // save places where we have fires on the initial grid: we\\'ll need them repeatedly\\n        for (int x = 0; x < grid.length; x++) {\\n            for (int y = 0; y < grid[0].length; y++) {\\n                if (grid[x][y] == 1) {\\n                    initialFires.add(new int[] {x, y});\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = grid.length * grid[0].length;\\n        // edge case: we can always complete the path\\n        if (canWait(high, grid)) {\\n            return 1000000000;\\n        }\\n        // edge case: we can never complete the part\\n        if (!canWait(low, grid)) {\\n            return -1;\\n        }\\n        // play high/low guessing game, trying to find the max wait time using binary search\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (canWait(middle, grid)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canWait(int wait, int[][] initialGrid) {\\n        // make a copy of the grid, so we can traverse it and change without impacting next try to traverse\\n        int[][] grid = new int[initialGrid.length][initialGrid[0].length];\\n        for (int i = 0; i < initialGrid.length; i++) {\\n            grid[i] = Arrays.copyOf(initialGrid[i], initialGrid[i].length);\\n        }\\n        // initial fire spreading while we are waiting\\n        Queue<int[]> firesQueue = new LinkedList<>();\\n        for (int[] fire : initialFires) {\\n            firesQueue.offer(fire);\\n        }\\n        for (int i = 0; i < wait; i++) {\\n            if (firesQueue.size() == 0) {\\n                break;\\n            }\\n            if (!spreadFire(firesQueue, grid)) {\\n                return false;\\n            }\\n            // fire reached the end goal. If it did, we never will.\\n            if (grid[0][0] == 1) {\\n                return false;\\n            }\\n        }\\n        // start moving\\n        Queue<int[]> movesQueue = new LinkedList<>();\\n        movesQueue.offer(new int[] {0, 0});\\n        grid[0][0] = -1;\\n        while (movesQueue.peek() != null) {\\n            int currentMoves = movesQueue.size();\\n            for (int i = 0; i < currentMoves; i++) {\\n                int[] current = movesQueue.poll();\\n                // this will be false if fire spread to this field on the previous turn\\n                if (grid[current[0]][current[1]] != 1) {\\n                    for (int[] direction : directions) {\\n                        int x = current[0] + direction[0];\\n                        int y = current[1] + direction[1];\\n                        // we reached the goal, yey!\\n                        if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                            return true;\\n                        }\\n                        // possible next cell, go there!\\n                        if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == 0) {\\n                            grid[x][y] = -1;\\n                            movesQueue.offer(new int[] {x, y});                    \\n                        }  \\n                    }\\n                }\\n            }\\n            // spread fire\\n           if (!spreadFire(firesQueue, grid)) {\\n               return false;\\n           }\\n        }\\n        // we have nowhere else to go, we failed to reach the goal\\n        return false;\\n    }\\n\\n    private boolean spreadFire(Queue<int[]> firesQueue, int[][] grid) {\\n        // make a fire spread for 1 turn. \\n        int currentFires = firesQueue.size();\\n        for (int j = 0; j < currentFires; j++) {\\n            int[] fire = firesQueue.poll();\\n            for (int[] direction : directions) {\\n                int x = fire[0] + direction[0];\\n                int y = fire[1] + direction[1];\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    // fire reached the end goal. If it did, we never will\\n                    return false;\\n                }\\n                if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] < 1) {\\n                    grid[x][y] = 1;\\n                    firesQueue.offer(new int[] {x, y});\\n                }  \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<int[]> initialFires = new ArrayList<>();\\n    int[][] directions = new int[][] {\\n        new int[] {1, 0},\\n        new int[] {-1, 0},\\n        new int[] {0, 1},\\n        new int[] {0, -1}\\n    };\\n\\n    public int maximumMinutes(int[][] grid) {\\n        // save places where we have fires on the initial grid: we\\'ll need them repeatedly\\n        for (int x = 0; x < grid.length; x++) {\\n            for (int y = 0; y < grid[0].length; y++) {\\n                if (grid[x][y] == 1) {\\n                    initialFires.add(new int[] {x, y});\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = grid.length * grid[0].length;\\n        // edge case: we can always complete the path\\n        if (canWait(high, grid)) {\\n            return 1000000000;\\n        }\\n        // edge case: we can never complete the part\\n        if (!canWait(low, grid)) {\\n            return -1;\\n        }\\n        // play high/low guessing game, trying to find the max wait time using binary search\\n        while (low <= high) {\\n            int middle = low + (high - low) / 2;\\n            if (canWait(middle, grid)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canWait(int wait, int[][] initialGrid) {\\n        // make a copy of the grid, so we can traverse it and change without impacting next try to traverse\\n        int[][] grid = new int[initialGrid.length][initialGrid[0].length];\\n        for (int i = 0; i < initialGrid.length; i++) {\\n            grid[i] = Arrays.copyOf(initialGrid[i], initialGrid[i].length);\\n        }\\n        // initial fire spreading while we are waiting\\n        Queue<int[]> firesQueue = new LinkedList<>();\\n        for (int[] fire : initialFires) {\\n            firesQueue.offer(fire);\\n        }\\n        for (int i = 0; i < wait; i++) {\\n            if (firesQueue.size() == 0) {\\n                break;\\n            }\\n            if (!spreadFire(firesQueue, grid)) {\\n                return false;\\n            }\\n            // fire reached the end goal. If it did, we never will.\\n            if (grid[0][0] == 1) {\\n                return false;\\n            }\\n        }\\n        // start moving\\n        Queue<int[]> movesQueue = new LinkedList<>();\\n        movesQueue.offer(new int[] {0, 0});\\n        grid[0][0] = -1;\\n        while (movesQueue.peek() != null) {\\n            int currentMoves = movesQueue.size();\\n            for (int i = 0; i < currentMoves; i++) {\\n                int[] current = movesQueue.poll();\\n                // this will be false if fire spread to this field on the previous turn\\n                if (grid[current[0]][current[1]] != 1) {\\n                    for (int[] direction : directions) {\\n                        int x = current[0] + direction[0];\\n                        int y = current[1] + direction[1];\\n                        // we reached the goal, yey!\\n                        if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                            return true;\\n                        }\\n                        // possible next cell, go there!\\n                        if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] == 0) {\\n                            grid[x][y] = -1;\\n                            movesQueue.offer(new int[] {x, y});                    \\n                        }  \\n                    }\\n                }\\n            }\\n            // spread fire\\n           if (!spreadFire(firesQueue, grid)) {\\n               return false;\\n           }\\n        }\\n        // we have nowhere else to go, we failed to reach the goal\\n        return false;\\n    }\\n\\n    private boolean spreadFire(Queue<int[]> firesQueue, int[][] grid) {\\n        // make a fire spread for 1 turn. \\n        int currentFires = firesQueue.size();\\n        for (int j = 0; j < currentFires; j++) {\\n            int[] fire = firesQueue.poll();\\n            for (int[] direction : directions) {\\n                int x = fire[0] + direction[0];\\n                int y = fire[1] + direction[1];\\n                if (x == grid.length - 1 && y == grid[0].length - 1) {\\n                    // fire reached the end goal. If it did, we never will\\n                    return false;\\n                }\\n                if (x >= 0 && y >= 0 && x < grid.length && y < grid[0].length && grid[x][y] < 1) {\\n                    grid[x][y] = 1;\\n                    firesQueue.offer(new int[] {x, y});\\n                }  \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295128,
                "title": "very-easy-self-explanatory-binary-search-bfs-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define v64 vector<ll>\\n    #define  vv64 vector<v64>\\n    int n, m;\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,-1,0,1};\\n    bool isValid(int x, int y){\\n        return x>=0 and x<n and y>=0 and y<m;\\n    }\\n\\n    bool isValidPos(int x, int y, vv64 &fire, int time){\\n        if(time==fire[x][y] and x==n-1 and y==m-1)\\n            return true;\\n        if(fire[x][y]<=time)\\n            return false;\\n        return true;\\n    }\\n\\n    bool check(vector<vector<int>> &grid, int time, vv64 &fire){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vv64 timer(n, v64(m,1e16));\\n        timer[0][0] = time;\\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(isValidPos(nx, ny, fire, timer[x][y]+1)){\\n                        if(timer[nx][ny] > timer[x][y] + 1)\\n                        {\\n                            timer[nx][ny] = timer[x][y] + 1;\\n                            q.push({nx, ny});   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return timer[n-1][m-1]!=1e16;\\n    }\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        vv64 fire(n, v64(m,1e16));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    fire[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }  \\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(fire[nx][ny] > fire[x][y] + 1){\\n                        fire[nx][ny] = fire[x][y] + 1;\\n                        q.push({nx,ny});\\n                    }\\n\\n                }\\n            }\\n        }\\n        ll low=0, high=1e9, ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(grid, mid, fire))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    #define v64 vector<ll>\\n    #define  vv64 vector<v64>\\n    int n, m;\\n    int dx[4] = {-1,0,1,0};\\n    int dy[4] = {0,-1,0,1};\\n    bool isValid(int x, int y){\\n        return x>=0 and x<n and y>=0 and y<m;\\n    }\\n\\n    bool isValidPos(int x, int y, vv64 &fire, int time){\\n        if(time==fire[x][y] and x==n-1 and y==m-1)\\n            return true;\\n        if(fire[x][y]<=time)\\n            return false;\\n        return true;\\n    }\\n\\n    bool check(vector<vector<int>> &grid, int time, vv64 &fire){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vv64 timer(n, v64(m,1e16));\\n        timer[0][0] = time;\\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(isValidPos(nx, ny, fire, timer[x][y]+1)){\\n                        if(timer[nx][ny] > timer[x][y] + 1)\\n                        {\\n                            timer[nx][ny] = timer[x][y] + 1;\\n                            q.push({nx, ny});   \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return timer[n-1][m-1]!=1e16;\\n    }\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        vv64 fire(n, v64(m,1e16));\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j] == 1){\\n                    fire[i][j]=0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }  \\n        while(!q.empty()){\\n            auto f=q.front(); q.pop();\\n            int x = f.first, y=f.second;\\n            for(int k=0; k<4; k++){\\n                int nx = x + dx[k];\\n                int ny = y + dy[k];\\n                if(isValid(nx, ny) and grid[nx][ny]!=2){\\n                    if(fire[nx][ny] > fire[x][y] + 1){\\n                        fire[nx][ny] = fire[x][y] + 1;\\n                        q.push({nx,ny});\\n                    }\\n\\n                }\\n            }\\n        }\\n        ll low=0, high=1e9, ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(check(grid, mid, fire))\\n            {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291503,
                "title": "using-2-bfs-super-easy-and-understandable-c",
                "content": "# Approach\\n2 BFS for each fire and person and atlast taking difference in time they will reach the destination.\\n\\n# Complexity\\n- Time complexity:O(2(n*m))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ppl_time(n,vector<int>(m,-1));\\n        vector<vector<int>>fire_time(n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>>q1;\\n        queue<pair<int,pair<int,int>>>q2;\\n        q1.push({0,{0,0}});\\n        int dir[4][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!q1.empty()){                      //for ppl reach\\n            int days=q1.front().first;\\n            int r=q1.front().second.first;\\n            int c=q1.front().second.second;\\n            ppl_time[r][c]=days;\\n            q1.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&ppl_time[x][y]==-1)\\n                    q1.push({days+1,{x,y}});\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==1)\\n                    q2.push({0,{i,j}});\\n        while(!q2.empty()){                      //for fire reach\\n            int days=q2.front().first;\\n            int r=q2.front().second.first;\\n            int c=q2.front().second.second;\\n            fire_time[r][c]=days;\\n            q2.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&fire_time[x][y]==-1)\\n                    q2.push({days+1,{x,y}});\\n            }\\n        }\\n        int ppl_arr=ppl_time[n-1][m-1];\\n        int fire_arr=fire_time[n-1][m-1];\\n        if(ppl_arr==-1)\\n            return -1;\\n        if(fire_arr==-1)\\n            return 1e9;\\n        if(fire_arr<ppl_arr)\\n            return -1;\\n        int diff=fire_arr-ppl_arr;\\n        int ppl_1=ppl_time[n-2][m-1],ppl_2=ppl_time[n-1][m-2];\\n        int fire_1=fire_time[n-2][m-1],fire_2=fire_time[n-1][m-2];\\n        if(ppl_1>-1 and ppl_2>-1 and (fire_1-ppl_1>diff or fire_2-ppl_2>diff))\\n            return diff;\\n        return diff-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>ppl_time(n,vector<int>(m,-1));\\n        vector<vector<int>>fire_time(n,vector<int>(m,-1));\\n        queue<pair<int,pair<int,int>>>q1;\\n        queue<pair<int,pair<int,int>>>q2;\\n        q1.push({0,{0,0}});\\n        int dir[4][4]={{-1,0},{1,0},{0,-1},{0,1}};\\n        while(!q1.empty()){                      //for ppl reach\\n            int days=q1.front().first;\\n            int r=q1.front().second.first;\\n            int c=q1.front().second.second;\\n            ppl_time[r][c]=days;\\n            q1.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&ppl_time[x][y]==-1)\\n                    q1.push({days+1,{x,y}});\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==1)\\n                    q2.push({0,{i,j}});\\n        while(!q2.empty()){                      //for fire reach\\n            int days=q2.front().first;\\n            int r=q2.front().second.first;\\n            int c=q2.front().second.second;\\n            fire_time[r][c]=days;\\n            q2.pop();\\n            for(int i=0;i<4;i++){\\n                int x=r+dir[i][0];\\n                int y=c+dir[i][1];\\n                if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]==0&&fire_time[x][y]==-1)\\n                    q2.push({days+1,{x,y}});\\n            }\\n        }\\n        int ppl_arr=ppl_time[n-1][m-1];\\n        int fire_arr=fire_time[n-1][m-1];\\n        if(ppl_arr==-1)\\n            return -1;\\n        if(fire_arr==-1)\\n            return 1e9;\\n        if(fire_arr<ppl_arr)\\n            return -1;\\n        int diff=fire_arr-ppl_arr;\\n        int ppl_1=ppl_time[n-2][m-1],ppl_2=ppl_time[n-1][m-2];\\n        int fire_1=fire_time[n-2][m-1],fire_2=fire_time[n-1][m-2];\\n        if(ppl_1>-1 and ppl_2>-1 and (fire_1-ppl_1>diff or fire_2-ppl_2>diff))\\n            return diff;\\n        return diff-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263913,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut fire: VecDeque<(usize, usize)> = VecDeque::new();\\n        let mut person: VecDeque<(usize, usize)> = VecDeque::new();\\n        for (i, grid_i) in grid.iter().enumerate().take(m) {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate().take(n) {\\n                if grid_i_j == 1 {\\n                    fire.push_back((i, j));\\n                }\\n            }\\n        }\\n        person.push_back((0, 0));\\n        let steps = |pos: &mut VecDeque<(usize, usize)>| {\\n            let mut st = vec![vec![0; n]; m];\\n            while let Some((i, j)) = pos.pop_front() {\\n                for (di, dj) in &[(0, 1), (1, 0), (0, -1), (-1, 0)] {\\n                    let (x, y) = (i as i32 + di, j as i32 + dj);\\n                    if x >= 0 && y >= 0 && x < m as i32 && y < n as i32 {\\n                        let (x, y) = (x as usize, y as usize);\\n                        if grid[x][y] == 0 && st[x][y] == 0 {\\n                            st[x][y] = st[i][j] + 1;\\n                            pos.push_back((x, y));\\n                        }\\n                    }\\n                }\\n            }\\n            let (a, b, c) = (st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]);\\n            [a, b, c]\\n        };\\n        let f = steps(&mut fire);\\n        let p = steps(&mut person);\\n        if f[0] == 0 && p[0] != 0 {\\n            return 1000000000;\\n        }\\n        let diff = f[0] - p[0];\\n        if p[0] != 0 && diff >= 0 {\\n            return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff) as i32;\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_minutes(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut fire: VecDeque<(usize, usize)> = VecDeque::new();\\n        let mut person: VecDeque<(usize, usize)> = VecDeque::new();\\n        for (i, grid_i) in grid.iter().enumerate().take(m) {\\n            for (j, &grid_i_j) in grid_i.iter().enumerate().take(n) {\\n                if grid_i_j == 1 {\\n                    fire.push_back((i, j));\\n                }\\n            }\\n        }\\n        person.push_back((0, 0));\\n        let steps = |pos: &mut VecDeque<(usize, usize)>| {\\n            let mut st = vec![vec![0; n]; m];\\n            while let Some((i, j)) = pos.pop_front() {\\n                for (di, dj) in &[(0, 1), (1, 0), (0, -1), (-1, 0)] {\\n                    let (x, y) = (i as i32 + di, j as i32 + dj);\\n                    if x >= 0 && y >= 0 && x < m as i32 && y < n as i32 {\\n                        let (x, y) = (x as usize, y as usize);\\n                        if grid[x][y] == 0 && st[x][y] == 0 {\\n                            st[x][y] = st[i][j] + 1;\\n                            pos.push_back((x, y));\\n                        }\\n                    }\\n                }\\n            }\\n            let (a, b, c) = (st[m - 1][n - 1], st[m - 2][n - 1], st[m - 1][n - 2]);\\n            [a, b, c]\\n        };\\n        let f = steps(&mut fire);\\n        let p = steps(&mut person);\\n        if f[0] == 0 && p[0] != 0 {\\n            return 1000000000;\\n        }\\n        let diff = f[0] - p[0];\\n        if p[0] != 0 && diff >= 0 {\\n            return diff - (f[1] - p[1] <= diff && f[2] - p[2] <= diff) as i32;\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3199952,
                "title": "bi-thread-of-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust simulate the fire spread and human movement\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBreadth first search for both human and fire.\\nMark the cells in the way we could identify who arrive first.\\n\\nthe last step is intersting and need pay attention.\\nIf the fire spread to the safe home from both directions at the same time, human will have no chance to reach the safe home at the same time frame. that mean human should start early. If fire approach from upper or left cell, while human approach from another cell, human may start later. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int: \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dr(i,j):\\n            if i > 0:\\n                yield i-1,j\\n            if i < m - 1:\\n                yield i+1,j\\n            if j > 0:\\n                yield i,j-1\\n            if j < n - 1:\\n                yield i,j+1\\n        fire = []\\n        path = [(0,0)]\\n        for i, r in enumerate(grid):\\n            for j, c in enumerate(r):\\n                if c == 1: \\n                    fire.append((i,j))\\n        grid[0][0] =3\\n        human = None\\n        for step in range(m*n):\\n            # neither the human nor the fire reach the destination\\n            if not path and not human:\\n                return -1\\n            # human reach while fire never\\n            if not fire and human:\\n                return 1000000000\\n            # human on the way\\n            if not human:\\n                safe = []\\n                for i,j in path:\\n                    for ni,nj in dr(i,j):\\n                        if grid[ni][nj] == 0:\\n                            grid[ni][nj] = 3\\n                            safe.append((ni,nj))\\n            # fire spread\\n            spread = []\\n            for i,j in fire:\\n                # spread.append()\\n                for ni,nj in dr(i,j):\\n                    if grid[ni][nj] == 0 or grid[ni][nj] == 3:\\n                        spread.append((ni,nj))\\n                        grid[ni][nj] = 1 \\n            if not human:\\n                # human reach the destination\\n                if (m-1,n-1) in safe:\\n                    # if fire reach at the same time\\n                    if (m-1,n-1) in spread:\\n                        return 0 \\n                    # when human reach, whether from upper, or from left\\n                    human = step, (m-2, n-1) in path, (m-1, n-2) in path\\n                else:\\n                    # fire may spead to some of the place where human is heading to. only the places fire not spead to might be the safe path\\n                    path = [(hi,hj) for hi,hj in safe if grid[hi][hj] == 3] \\n            # fire reach destination\\n            if (m-1,n-1) in spread:\\n                # if human not reach yet\\n                if not human:\\n                    return -1\\n                # the direction the fire approach\\n                up, left = (m-2, n-1) in fire, (m-1, n-2) in fire\\n                # if both direction\\n                if up and left: \\n                    early = 1\\n                # if human approch from another direction other than fire\\n                elif up and human[2] or left and human[1]:\\n                    early = 0\\n                else:\\n                # fire and human approch from the same direction\\n                    early = 1 \\n                return step - human[0] - early\\n            fire = spread\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int: \\n        m = len(grid)\\n        n = len(grid[0])\\n        def dr(i,j):\\n            if i > 0:\\n                yield i-1,j\\n            if i < m - 1:\\n                yield i+1,j\\n            if j > 0:\\n                yield i,j-1\\n            if j < n - 1:\\n                yield i,j+1\\n        fire = []\\n        path = [(0,0)]\\n        for i, r in enumerate(grid):\\n            for j, c in enumerate(r):\\n                if c == 1: \\n                    fire.append((i,j))\\n        grid[0][0] =3\\n        human = None\\n        for step in range(m*n):\\n            # neither the human nor the fire reach the destination\\n            if not path and not human:\\n                return -1\\n            # human reach while fire never\\n            if not fire and human:\\n                return 1000000000\\n            # human on the way\\n            if not human:\\n                safe = []\\n                for i,j in path:\\n                    for ni,nj in dr(i,j):\\n                        if grid[ni][nj] == 0:\\n                            grid[ni][nj] = 3\\n                            safe.append((ni,nj))\\n            # fire spread\\n            spread = []\\n            for i,j in fire:\\n                # spread.append()\\n                for ni,nj in dr(i,j):\\n                    if grid[ni][nj] == 0 or grid[ni][nj] == 3:\\n                        spread.append((ni,nj))\\n                        grid[ni][nj] = 1 \\n            if not human:\\n                # human reach the destination\\n                if (m-1,n-1) in safe:\\n                    # if fire reach at the same time\\n                    if (m-1,n-1) in spread:\\n                        return 0 \\n                    # when human reach, whether from upper, or from left\\n                    human = step, (m-2, n-1) in path, (m-1, n-2) in path\\n                else:\\n                    # fire may spead to some of the place where human is heading to. only the places fire not spead to might be the safe path\\n                    path = [(hi,hj) for hi,hj in safe if grid[hi][hj] == 3] \\n            # fire reach destination\\n            if (m-1,n-1) in spread:\\n                # if human not reach yet\\n                if not human:\\n                    return -1\\n                # the direction the fire approach\\n                up, left = (m-2, n-1) in fire, (m-1, n-2) in fire\\n                # if both direction\\n                if up and left: \\n                    early = 1\\n                # if human approch from another direction other than fire\\n                elif up and human[2] or left and human[1]:\\n                    early = 0\\n                else:\\n                # fire and human approch from the same direction\\n                    early = 1 \\n                return step - human[0] - early\\n            fire = spread\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198035,
                "title": "binary-search-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int kt[301][301],high,low,mid,b,ans=-1;\\n    queue<tuple<int,int,int>> A;\\n    int bfs(vector<vector<int>>& grid)\\n    {\\n        queue<pair<int,int>> D;\\n        int x,y;\\n        D.push(make_pair(0,0));\\n        kt[0][0]=1;\\n        while(D.empty()==0)\\n        {\\n            x=D.front().first;\\n            y=D.front().second;\\n            D.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return 0;\\n            if(check(x-1,y,grid)==0&&kt[y][x-1]==0)\\n            {\\n                kt[y][x-1]=1;\\n                D.push(make_pair(x-1,y));\\n            }\\n            if(check(x+1,y,grid)==0&&kt[y][x+1]==0)\\n            {\\n                kt[y][x+1]=1;\\n                D.push(make_pair(x+1,y));\\n            }\\n            if(check(x,y-1,grid)==0&&kt[y-1][x]==0)\\n            {\\n                kt[y-1][x]=1;\\n                D.push(make_pair(x,y-1));\\n            }\\n            if(check(x,y+1,grid)==0&&kt[y+1][x]==0)\\n            {\\n                kt[y+1][x]=1;\\n                D.push(make_pair(x,y+1));\\n            }\\n        }\\n        return 1;\\n    }\\n    int check(int x,int y,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&grid[y][x]==0) return 0;\\n        return 1;\\n    }\\n    void huy(int x, int y, int value ,vector<vector<int>>& F)\\n    {\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            F[y][x]=value+1;\\n            A.push(make_tuple(x,y,value+1));\\n        }\\n    }\\n    void picaro(int x,int y,int time,vector<vector<int>> & F,queue<tuple<int,int,int>>& B,vector<vector<int>>& grid)\\n    {\\n        if(x==F[0].size()-1&&y==F.size()-1&&time<=F[y][x])\\n        {\\n            b=1;\\n            return;\\n        }\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&grid[y][x]==0&&time<F[y][x]&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            B.push(make_tuple(x,y,time));\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        if(bfs(grid)==1) return -1;\\n        memset(kt,0,sizeof(kt));\\n        int x,y,value,time;\\n        vector<vector<int>> F(grid.size(),vector<int>(grid[0].size(),1e9));\\n        for(int i=0;i<=grid.size()-1;i++)\\n        {\\n            for(int j=0;j<=grid[0].size()-1;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    A.push(make_tuple(j,i,0));\\n                }\\n                if(grid[i][j]!=0) kt[i][j]=1;\\n            }\\n        }\\n        while(A.empty()==0)\\n        {\\n            x=get<0>(A.front());\\n            y=get<1>(A.front());\\n            value=get<2>(A.front());\\n            high=max(high,value);\\n            A.pop();\\n            huy(x-1,y,value,F);\\n            huy(x+1,y,value,F);\\n            huy(x,y-1,value,F);\\n            huy(x,y+1,value,F);\\n        }\\n        if(F[0][0]==1e9) return 1e9;\\n        high--;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            queue<tuple<int,int,int>> B;\\n            b=0;\\n            memset(kt,0,sizeof(kt));\\n            if(F[0][0]>mid)\\n                B.push(make_tuple(0,0,mid));\\n            while(B.empty()==0&&b==0)\\n            {\\n                x=get<0>(B.front());\\n                y=get<1>(B.front());\\n                time=get<2>(B.front());\\n                B.pop();\\n                picaro(x-1,y,time+1,F,B,grid);\\n                picaro(x+1,y,time+1,F,B,grid);\\n                picaro(x,y-1,time+1,F,B,grid);\\n                picaro(x,y+1,time+1,F,B,grid);\\n            }\\n            if(b==1)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kt[301][301],high,low,mid,b,ans=-1;\\n    queue<tuple<int,int,int>> A;\\n    int bfs(vector<vector<int>>& grid)\\n    {\\n        queue<pair<int,int>> D;\\n        int x,y;\\n        D.push(make_pair(0,0));\\n        kt[0][0]=1;\\n        while(D.empty()==0)\\n        {\\n            x=D.front().first;\\n            y=D.front().second;\\n            D.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return 0;\\n            if(check(x-1,y,grid)==0&&kt[y][x-1]==0)\\n            {\\n                kt[y][x-1]=1;\\n                D.push(make_pair(x-1,y));\\n            }\\n            if(check(x+1,y,grid)==0&&kt[y][x+1]==0)\\n            {\\n                kt[y][x+1]=1;\\n                D.push(make_pair(x+1,y));\\n            }\\n            if(check(x,y-1,grid)==0&&kt[y-1][x]==0)\\n            {\\n                kt[y-1][x]=1;\\n                D.push(make_pair(x,y-1));\\n            }\\n            if(check(x,y+1,grid)==0&&kt[y+1][x]==0)\\n            {\\n                kt[y+1][x]=1;\\n                D.push(make_pair(x,y+1));\\n            }\\n        }\\n        return 1;\\n    }\\n    int check(int x,int y,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&grid[y][x]==0) return 0;\\n        return 1;\\n    }\\n    void huy(int x, int y, int value ,vector<vector<int>>& F)\\n    {\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            F[y][x]=value+1;\\n            A.push(make_tuple(x,y,value+1));\\n        }\\n    }\\n    void picaro(int x,int y,int time,vector<vector<int>> & F,queue<tuple<int,int,int>>& B,vector<vector<int>>& grid)\\n    {\\n        if(x==F[0].size()-1&&y==F.size()-1&&time<=F[y][x])\\n        {\\n            b=1;\\n            return;\\n        }\\n        if(x>=0&&x<=F[0].size()-1&&y>=0&&y<=F.size()-1&&grid[y][x]==0&&time<F[y][x]&&kt[y][x]==0)\\n        {\\n            kt[y][x]=1;\\n            B.push(make_tuple(x,y,time));\\n        }\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        if(bfs(grid)==1) return -1;\\n        memset(kt,0,sizeof(kt));\\n        int x,y,value,time;\\n        vector<vector<int>> F(grid.size(),vector<int>(grid[0].size(),1e9));\\n        for(int i=0;i<=grid.size()-1;i++)\\n        {\\n            for(int j=0;j<=grid[0].size()-1;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    A.push(make_tuple(j,i,0));\\n                }\\n                if(grid[i][j]!=0) kt[i][j]=1;\\n            }\\n        }\\n        while(A.empty()==0)\\n        {\\n            x=get<0>(A.front());\\n            y=get<1>(A.front());\\n            value=get<2>(A.front());\\n            high=max(high,value);\\n            A.pop();\\n            huy(x-1,y,value,F);\\n            huy(x+1,y,value,F);\\n            huy(x,y-1,value,F);\\n            huy(x,y+1,value,F);\\n        }\\n        if(F[0][0]==1e9) return 1e9;\\n        high--;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            queue<tuple<int,int,int>> B;\\n            b=0;\\n            memset(kt,0,sizeof(kt));\\n            if(F[0][0]>mid)\\n                B.push(make_tuple(0,0,mid));\\n            while(B.empty()==0&&b==0)\\n            {\\n                x=get<0>(B.front());\\n                y=get<1>(B.front());\\n                time=get<2>(B.front());\\n                B.pop();\\n                picaro(x-1,y,time+1,F,B,grid);\\n                picaro(x+1,y,time+1,F,B,grid);\\n                picaro(x,y-1,time+1,F,B,grid);\\n                picaro(x,y+1,time+1,F,B,grid);\\n            }\\n            if(b==1)\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173596,
                "title": "intuitive-python-solution-with-basic-explanation-and-approach",
                "content": "# Intuition\\nBFS on fire and unique paths to reach bottom right\\n# Approach\\nFirst let fire spread then start moving on unique paths while taking count of maximum time you can wait before stepping on that part and carry it forward till last bottom left but keeping in mind you can enter home at the same time fire reaches there you will still be safe\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n^2)$$\\n\\n- Space complexity:\\n    $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        #get all times till which the fire whill reach all of the places\\n        # get all paths and then compare timings\\n        hasFire=False\\n        fIns=[]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    fIns.append((i,j))\\n                    hasFire=True\\n                    grid[i][j]=(grid[i][j],0)\\n                    continue\\n                grid[i][j]=(grid[i][j],float(\\'inf\\'))\\n        \\n\\n        q=deque()\\n        for x,y in fIns:\\n            q.append((x,y,0))\\n        \\n        while q:\\n            x,y,dist = q.popleft()\\n            for i,j in [(x+1,y),(x,y+1),(x,y-1),(x-1,y)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if grid[i][j][0]==0:\\n                        q.append((i,j,dist+1))\\n                        grid[i][j]=(1,dist+1)\\n\\n        # all unique paths\\n        q=deque()\\n        q.append((0,0,grid[0][0][1]-1,0))\\n        vis=set()\\n        vis.add((0,0))\\n        maxWait=-float(\\'inf\\')\\n        while q:\\n            x,y,minDif,dist = q.popleft()\\n            if x==len(grid)-1 and y==len(grid[0])-1:\\n                maxWait=max(maxWait,minDif)\\n                continue\\n            for i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if i==len(grid)-1 and j==len(grid[0])-1:\\n                        if grid[i][j][1]>=dist+1:\\n                            dif = grid[i][j][1]-dist-1\\n                            q.append((i,j,min(dif,minDif),dist+1))\\n                        continue\\n                    if (grid[i][j][0]==1 or grid[i][j][0]==0) and grid[i][j][1]>dist+1 and (i,j) not in vis:\\n                        dif = grid[i][j][1]-dist-2\\n                        q.append((i,j,min(dif,minDif),dist+1))\\n                        vis.add((i,j))\\n\\n        if maxWait==float(\\'inf\\'):\\n            return 10**9\\n        if maxWait==-float(\\'inf\\'):\\n            return -1\\n        return maxWait\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        #get all times till which the fire whill reach all of the places\\n        # get all paths and then compare timings\\n        hasFire=False\\n        fIns=[]\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    fIns.append((i,j))\\n                    hasFire=True\\n                    grid[i][j]=(grid[i][j],0)\\n                    continue\\n                grid[i][j]=(grid[i][j],float(\\'inf\\'))\\n        \\n\\n        q=deque()\\n        for x,y in fIns:\\n            q.append((x,y,0))\\n        \\n        while q:\\n            x,y,dist = q.popleft()\\n            for i,j in [(x+1,y),(x,y+1),(x,y-1),(x-1,y)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if grid[i][j][0]==0:\\n                        q.append((i,j,dist+1))\\n                        grid[i][j]=(1,dist+1)\\n\\n        # all unique paths\\n        q=deque()\\n        q.append((0,0,grid[0][0][1]-1,0))\\n        vis=set()\\n        vis.add((0,0))\\n        maxWait=-float(\\'inf\\')\\n        while q:\\n            x,y,minDif,dist = q.popleft()\\n            if x==len(grid)-1 and y==len(grid[0])-1:\\n                maxWait=max(maxWait,minDif)\\n                continue\\n            for i,j in [(x+1,y),(x,y+1),(x-1,y),(x,y-1)]:\\n                if 0<=i<len(grid) and 0<=j<len(grid[0]):\\n                    if i==len(grid)-1 and j==len(grid[0])-1:\\n                        if grid[i][j][1]>=dist+1:\\n                            dif = grid[i][j][1]-dist-1\\n                            q.append((i,j,min(dif,minDif),dist+1))\\n                        continue\\n                    if (grid[i][j][0]==1 or grid[i][j][0]==0) and grid[i][j][1]>dist+1 and (i,j) not in vis:\\n                        dif = grid[i][j][1]-dist-2\\n                        q.append((i,j,min(dif,minDif),dist+1))\\n                        vis.add((i,j))\\n\\n        if maxWait==float(\\'inf\\'):\\n            return 10**9\\n        if maxWait==-float(\\'inf\\'):\\n            return -1\\n        return maxWait\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129761,
                "title": "c-bfs-simple",
                "content": "# Intuition\\nIntuition is, I need to test in an efficient manner, how long can can I wait in 0,0 cell before I can safely reach the safe house.\\n\\n# Approach\\n1. Spread the fire throughout the grid using BFS and note down the time it takes the fire to reach each cell. The cell where fire cannot reach (may be because the fire is bounded by walls), let the default time be INT_MAX in those cells. While doing this step, record the maximum time (max_time) the fire took to spread.\\n2. Do a binary search on answer between 0 and max_time calculated from above step.\\n3. While doing a binary search for the answer between 0 and max_time, the mid value will be my initial time (indicating, I waited that much in the 0,0 cell). Do a BFS, while not going to the cells where the fire has spread at time t <= mid value except the safehouse cell.\\n4. If the answer == max_time, return 1e9, else return answer.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(log(m * n) * (m + n))$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool canReachDestination(vector<vector<int>>& grid, vector<vector<int>>& fireTime, int t) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n\\n        vector<int> directions = {-1, 0, 1, 0, -1};\\n        std::deque<vector<int>> dq{{0, 0, t}};\\n        visited[0][0] = 1;\\n        while (!dq.empty()) {\\n            const auto& cell = dq.front();\\n            int row = cell[0], col = cell[1], time = cell[2];\\n            dq.pop_front();\\n\\n            if (row == n - 1 && col == m - 1 && (time <= fireTime[row][col] || fireTime[row][col] == -1)) {\\n                return true;\\n            }\\n\\n            if (fireTime[row][col] != -1 && fireTime[row][col] <= time) {\\n                continue;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && !visited[newRow][newCol]) {\\n                    visited[newRow][newCol] = 1;\\n                    dq.push_back({newRow, newCol, time + 1});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> fireTimeGrid(n, vector<int>(m, -1));\\n\\n        std::deque<vector<int>> dq;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dq.push_back({i, j, 0});\\n                    fireTimeGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        vector<int> directions{-1, 0, 1, 0, -1};\\n        // Do BFS in fireTimeGrid and spread the fire\\n        // while updating each cell with the time the fire will reach that cell\\n        int maxTime = 0;\\n        while (!dq.empty()) {\\n            const auto& fire = dq.front();\\n            int row = fire[0], col = fire[1], t = fire[2];\\n            maxTime = std::max(maxTime, t);\\n            dq.pop_front();\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && fireTimeGrid[newRow][newCol] == -1) {\\n                    fireTimeGrid[newRow][newCol] = t + 1;\\n                    dq.push_back({newRow, newCol, t + 1});\\n                }\\n            }            \\n        }\\n\\n        // Do BFS for the person to travel from 0,0 to n - 1, m - 1\\n        int left = 0, right = maxTime;\\n        int result = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canReachDestination(grid, fireTimeGrid, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result == maxTime ? 1e9 : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canReachDestination(vector<vector<int>>& grid, vector<vector<int>>& fireTime, int t) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> visited(n, vector<int>(m, 0));\\n\\n        vector<int> directions = {-1, 0, 1, 0, -1};\\n        std::deque<vector<int>> dq{{0, 0, t}};\\n        visited[0][0] = 1;\\n        while (!dq.empty()) {\\n            const auto& cell = dq.front();\\n            int row = cell[0], col = cell[1], time = cell[2];\\n            dq.pop_front();\\n\\n            if (row == n - 1 && col == m - 1 && (time <= fireTime[row][col] || fireTime[row][col] == -1)) {\\n                return true;\\n            }\\n\\n            if (fireTime[row][col] != -1 && fireTime[row][col] <= time) {\\n                continue;\\n            }\\n\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && !visited[newRow][newCol]) {\\n                    visited[newRow][newCol] = 1;\\n                    dq.push_back({newRow, newCol, time + 1});\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> fireTimeGrid(n, vector<int>(m, -1));\\n\\n        std::deque<vector<int>> dq;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    dq.push_back({i, j, 0});\\n                    fireTimeGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        vector<int> directions{-1, 0, 1, 0, -1};\\n        // Do BFS in fireTimeGrid and spread the fire\\n        // while updating each cell with the time the fire will reach that cell\\n        int maxTime = 0;\\n        while (!dq.empty()) {\\n            const auto& fire = dq.front();\\n            int row = fire[0], col = fire[1], t = fire[2];\\n            maxTime = std::max(maxTime, t);\\n            dq.pop_front();\\n            for (int i = 0; i < 4; ++i) {\\n                int newRow = row + directions[i];\\n                int newCol = col + directions[i + 1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m\\n                    && grid[newRow][newCol] != 2 && fireTimeGrid[newRow][newCol] == -1) {\\n                    fireTimeGrid[newRow][newCol] = t + 1;\\n                    dq.push_back({newRow, newCol, t + 1});\\n                }\\n            }            \\n        }\\n\\n        // Do BFS for the person to travel from 0,0 to n - 1, m - 1\\n        int left = 0, right = maxTime;\\n        int result = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (canReachDestination(grid, fireTimeGrid, mid)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result == maxTime ? 1e9 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102349,
                "title": "kotlin",
                "content": "# Intuition\\nI tried with regular BSF and queue DFS to find the fire and person meet time. Which ended up checking lot of conditions\\n\\nAnother approch is in one pass calculate toatl fire distance and another pass find the person disctance to `m-1` to `n-1`.\\n\\nInput\\n![image.png](https://assets.leetcode.com/users/images/e828ea54-da7a-4de5-ae3f-0bf3d77ce58b_1674749719.7705944.png)\\nfireDistance\\n![image.png](https://assets.leetcode.com/users/images/e0b9b8b2-dcfb-4ba8-b5e8-72c9bf55c176_1674749743.114985.png)\\npersonDistance\\n![image.png](https://assets.leetcode.com/users/images/c5849378-f86a-4450-b20e-65cc2a2b82ed_1674749753.9500437.png)\\n\\nIn the end take `last or distance[m-1][n-1]`, `leftOfLast or distance[m-1][n-2]`, and `topToLast or distance[m-2][n-1]` to calculate the result.\\n1. if `fireLast == 0 && personLast != 0` return 1000000000 - we have unlimited options\\n2. if `fireLast != 0 && personLast == 0` return -1 because fire reached before person\\n3. if `fireLast - personLast >= 0` then check adjusants cells \\n3.a. To check if the safehouse is the first cell when person and fire \"meet\", we compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, then we do not need to subtract one\\n4. finally return -1.\\n\\n# Approach\\ndistance calculation.\\n1. collect all fire event to start fire distance calucaltion\\n2. person always starts from 0,0\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val fire = mutableListOf<Pair<Int, Int>>()\\n        for (r in grid.indices) {\\n            for (c in grid[r].indices) {\\n                if (grid[r][c] == 1) {\\n                    fire.add(Pair(r, c))\\n                }\\n            }\\n        }\\n        val person = mutableListOf<Pair<Int, Int>>(Pair(0, 0))\\n        val (fireLast, fireLeftLast, fireTopLast) = calculateDistance(grid, fire)\\n        val (personLast, personLeftLast, personTopLast) = calculateDistance(grid, person)\\n\\n        val diff = fireLast - personLast\\n        return if (fireLast == 0 && personLast != 0) 1000000000\\n        else if (fireLast != 0 && personLast == 0) -1\\n        else if (diff >= 0) {\\n            val d = if (fireTopLast - personTopLast <= diff && fireLeftLast - personLeftLast <= diff) {\\n                1\\n            } else 0\\n            diff - d\\n        } else -1\\n    }\\n\\n    fun calculateDistance(grid: Array<IntArray>, start: MutableList<Pair<Int, Int>>): Triple<Int, Int, Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val distance = Array(m) { IntArray(n) { 0 } }\\n        val visited = Array(m) { BooleanArray(n) }\\n\\n        val queue = ArrayDeque<Pair<Int, Int>>()\\n        start.forEach { s ->\\n            queue.addLast(s)\\n            visited[s.first][s.second] = true\\n        }\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            for (i in 0 until size) {\\n                val (r, c) = queue.removeFirst()\\n                listOf(Pair(0, 1), Pair(1, 0), Pair(0, -1), Pair(-1, 0)).forEach { (r1, c1) ->\\n                    val nr = r + r1\\n                    val nc = c + c1\\n                    if (nr in 0 until m && nc in 0 until n && grid[nr][nc] == 0 && !visited[nr][nc]) {\\n                        queue.addLast(Pair(nr, nc))\\n                        distance[nr][nc] = distance[r][c] + 1\\n                        visited[nr][nc] = true\\n                    }\\n                }\\n            }\\n        }\\n        return Triple(distance[m - 1][n - 1], distance[m - 1][n - 2], distance[m - 2][n - 1])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumMinutes(grid: Array<IntArray>): Int {\\n        val fire = mutableListOf<Pair<Int, Int>>()\\n        for (r in grid.indices) {\\n            for (c in grid[r].indices) {\\n                if (grid[r][c] == 1) {\\n                    fire.add(Pair(r, c))\\n                }\\n            }\\n        }\\n        val person = mutableListOf<Pair<Int, Int>>(Pair(0, 0))\\n        val (fireLast, fireLeftLast, fireTopLast) = calculateDistance(grid, fire)\\n        val (personLast, personLeftLast, personTopLast) = calculateDistance(grid, person)\\n\\n        val diff = fireLast - personLast\\n        return if (fireLast == 0 && personLast != 0) 1000000000\\n        else if (fireLast != 0 && personLast == 0) -1\\n        else if (diff >= 0) {\\n            val d = if (fireTopLast - personTopLast <= diff && fireLeftLast - personLeftLast <= diff) {\\n                1\\n            } else 0\\n            diff - d\\n        } else -1\\n    }\\n\\n    fun calculateDistance(grid: Array<IntArray>, start: MutableList<Pair<Int, Int>>): Triple<Int, Int, Int> {\\n        val m = grid.size\\n        val n = grid[0].size\\n        val distance = Array(m) { IntArray(n) { 0 } }\\n        val visited = Array(m) { BooleanArray(n) }\\n\\n        val queue = ArrayDeque<Pair<Int, Int>>()\\n        start.forEach { s ->\\n            queue.addLast(s)\\n            visited[s.first][s.second] = true\\n        }\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n            for (i in 0 until size) {\\n                val (r, c) = queue.removeFirst()\\n                listOf(Pair(0, 1), Pair(1, 0), Pair(0, -1), Pair(-1, 0)).forEach { (r1, c1) ->\\n                    val nr = r + r1\\n                    val nc = c + c1\\n                    if (nr in 0 until m && nc in 0 until n && grid[nr][nc] == 0 && !visited[nr][nc]) {\\n                        queue.addLast(Pair(nr, nc))\\n                        distance[nr][nc] = distance[r][c] + 1\\n                        visited[nr][nc] = true\\n                    }\\n                }\\n            }\\n        }\\n        return Triple(distance[m - 1][n - 1], distance[m - 1][n - 2], distance[m - 2][n - 1])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081120,
                "title": "two-bfs-compute-time-for-fire-and-person-to-reach-each-cell-seperately",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n        person_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(que, visited, fire_time, cur_time):\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    fire_time[i][j] = cur_time\\n                    for nei in get_neis(i, j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 0:\\n                            visited.add((x,y))\\n                            que.append((x,y))\\n                cur_time+=1\\n            return fire_time\\n\\n\\n        que = deque([])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    visited.add((i,j))\\n                    que.append((i,j))\\n\\n        # compute the fire time, fire_time[i][j] denotes time taken by fire to reach cell(i,j)\\n        fire_time = bfs(que, visited, fire_time, 0)\\n\\n        # compute the person time, person_time[i][j] dentoes the minimum time person\\n        # will take to reach cell (i,j)\\n        def bfs2(person_time):\\n            que = deque([(0,0)])\\n            visited = {(0, 0)}\\n            person_time[0][0] = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    for nei in get_neis(i,j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x, y) not in visited and grid[x][y] == 0 and \\\\\\n                           fire_time[x][y] > person_time[i][j] + 1:\\n                           visited.add((x, y))\\n                           que.append((x,y))\\n                           person_time[x][y] = person_time[i][j] + 1\\n                        elif x == m-1 and y == n-1 and fire_time[x][y] == person_time[i][j] + 1:\\n                            person_time[x][y] = person_time[i][j] + 1\\n            return person_time\\n\\n        person_time = bfs2(person_time)\\n        print(f\\'fire_time = {fire_time}\\')\\n        print(f\\'person_time = {person_time}\\')\\n\\n        if person_time[-1][-1] == float(\\'inf\\') or fire_time[-1][-1] < person_time[-1][-1]:\\n            # person can never reach safehouse\\n            return -1\\n        if fire_time[-1][-1] == float(\\'inf\\'):\\n            return 10**9\\n        diff = fire_time[-1][-1] - person_time[-1][-1]\\n        if diff == 0:\\n            return 0\\n\\n        if person_time[m-2][n-1] != float(\\'inf\\') and \\\\\\n            person_time[m-1][n-2]!=float(\\'inf\\') and \\\\\\n            ((fire_time[m-2][n-1]-person_time[m-2][n-1])>diff or \\\\\\n            (fire_time[m-1][n-2]-person_time[m-1][n-2]>diff)):\\n            return diff\\n        return diff-1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fire_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n        person_time = [[float(inf) for _ in range(n)] for _ in range(m)]\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def bfs(que, visited, fire_time, cur_time):\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    fire_time[i][j] = cur_time\\n                    for nei in get_neis(i, j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 0:\\n                            visited.add((x,y))\\n                            que.append((x,y))\\n                cur_time+=1\\n            return fire_time\\n\\n\\n        que = deque([])\\n        visited = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    visited.add((i,j))\\n                    que.append((i,j))\\n\\n        # compute the fire time, fire_time[i][j] denotes time taken by fire to reach cell(i,j)\\n        fire_time = bfs(que, visited, fire_time, 0)\\n\\n        # compute the person time, person_time[i][j] dentoes the minimum time person\\n        # will take to reach cell (i,j)\\n        def bfs2(person_time):\\n            que = deque([(0,0)])\\n            visited = {(0, 0)}\\n            person_time[0][0] = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    i, j = que.popleft()\\n                    for nei in get_neis(i,j):\\n                        x, y = nei\\n                        if is_valid(x, y) and (x, y) not in visited and grid[x][y] == 0 and \\\\\\n                           fire_time[x][y] > person_time[i][j] + 1:\\n                           visited.add((x, y))\\n                           que.append((x,y))\\n                           person_time[x][y] = person_time[i][j] + 1\\n                        elif x == m-1 and y == n-1 and fire_time[x][y] == person_time[i][j] + 1:\\n                            person_time[x][y] = person_time[i][j] + 1\\n            return person_time\\n\\n        person_time = bfs2(person_time)\\n        print(f\\'fire_time = {fire_time}\\')\\n        print(f\\'person_time = {person_time}\\')\\n\\n        if person_time[-1][-1] == float(\\'inf\\') or fire_time[-1][-1] < person_time[-1][-1]:\\n            # person can never reach safehouse\\n            return -1\\n        if fire_time[-1][-1] == float(\\'inf\\'):\\n            return 10**9\\n        diff = fire_time[-1][-1] - person_time[-1][-1]\\n        if diff == 0:\\n            return 0\\n\\n        if person_time[m-2][n-1] != float(\\'inf\\') and \\\\\\n            person_time[m-1][n-2]!=float(\\'inf\\') and \\\\\\n            ((fire_time[m-2][n-1]-person_time[m-2][n-1])>diff or \\\\\\n            (fire_time[m-1][n-2]-person_time[m-1][n-2]>diff)):\\n            return diff\\n        return diff-1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962225,
                "title": "c-using-binary-search-and-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {-1, 0, 1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    bool bfs(int mins, vector<vector<int>>& time, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<vector<int>>q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        \\n        int currTime = mins;\\n        q.push({0, 0, currTime});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int t = q.front()[2];\\n            // cout<<x<<\" \"<<y<<\" \"<<t<<\"\\\\n\";\\n            q.pop();\\n            \\n            if(x == n - 1 && y == m - 1) return true;\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                \\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || vis[newX][newY] == 1 || grid[newX][newY] == 2) continue;\\n                if(t + 1 < time[newX][newY]) {\\n                    q.push({newX, newY, t + 1});\\n                    vis[newX][newY] = 1;\\n                }\\n                \\n                else if(t + 1 == time[newX][newY] && newX == n - 1 && newY == m - 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>>e(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>>q;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    e[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto [currX, currY] = q.front();\\n                q.pop();\\n                \\n                for(int idx = 0; idx < 4; idx++) {\\n                    int newX = currX + dx[idx];\\n                    int newY = currY + dy[idx];\\n                    if(newX < 0 || newY < 0 || newX >= n || newY >= m || e[newX][newY] != INT_MAX || grid[newX][newY] == 2) continue;\\n                    e[newX][newY] = e[currX][currY] + 1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        \\n        int st = 0, en = 1e9;\\n        \\n        int ans = -1;\\n        \\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n            \\n            if(bfs(mid, e, grid)) ans = mid, st = mid + 1;\\n            else en = mid - 1;\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {-1, 0, 1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    bool bfs(int mins, vector<vector<int>>& time, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        queue<vector<int>>q;\\n        vector<vector<int>> vis(n, vector<int>(m, 0));\\n        \\n        int currTime = mins;\\n        q.push({0, 0, currTime});\\n        vis[0][0] = 1;\\n        \\n        while(!q.empty()) {\\n            int x = q.front()[0];\\n            int y = q.front()[1];\\n            int t = q.front()[2];\\n            // cout<<x<<\" \"<<y<<\" \"<<t<<\"\\\\n\";\\n            q.pop();\\n            \\n            if(x == n - 1 && y == m - 1) return true;\\n            \\n            for(int idx = 0; idx < 4; idx++) {\\n                int newX = x + dx[idx];\\n                int newY = y + dy[idx];\\n                \\n                if(newX < 0 || newY < 0 || newX >= n || newY >= m || vis[newX][newY] == 1 || grid[newX][newY] == 2) continue;\\n                if(t + 1 < time[newX][newY]) {\\n                    q.push({newX, newY, t + 1});\\n                    vis[newX][newY] = 1;\\n                }\\n                \\n                else if(t + 1 == time[newX][newY] && newX == n - 1 && newY == m - 1) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<int>>e(n, vector<int>(m, INT_MAX));\\n        queue<pair<int, int>>q;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    e[i][j] = 0;\\n                    q.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()) {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++) {\\n                auto [currX, currY] = q.front();\\n                q.pop();\\n                \\n                for(int idx = 0; idx < 4; idx++) {\\n                    int newX = currX + dx[idx];\\n                    int newY = currY + dy[idx];\\n                    if(newX < 0 || newY < 0 || newX >= n || newY >= m || e[newX][newY] != INT_MAX || grid[newX][newY] == 2) continue;\\n                    e[newX][newY] = e[currX][currY] + 1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        \\n        int st = 0, en = 1e9;\\n        \\n        int ans = -1;\\n        \\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n            \\n            if(bfs(mid, e, grid)) ans = mid, st = mid + 1;\\n            else en = mid - 1;\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2958694,
                "title": "java-bfs-binary-search-95-cpu-94-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS traversal, one for the fire to spread and another for the person to escape to the safe-house.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Spread the fire using BFS and record the time when the fire reaches a grass cell(0) in the 2D array itself. Use `-ve` numbers for the time like -1, -2 etc to distinguish it from other walls(2) and fires(1). \\n\\n2. The person can wait for a time in the range `0 to A[0][0] - 1`. \\nA[0][0]represents time to reach the fire to `(0,0)` location.\\n3. Do binarySearch to find the maxWaitTime in that range by calling a BFS (shortestDistance) for the escape.\\n# Complexity\\n- Time complexity: O(n*m log(m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // Possible directions of a node up, down, left, right.\\n    static int[] R = { -1, +1,  0,  0};\\n    static int[] C = {  0,  0, -1, +1};\\n\\n    private static class Cell {\\n        int i, j;\\n        public Cell(int i, int j) { this.i = i; this.j = j;}\\n    }\\n\\n    public static int maximumMinutes(int[][] A) {\\n\\n        // Spread the fire and record the time when the fire reaches a cell.\\n        spreadFireBFS(A);\\n\\n        // The person can wait for a time in the range 0 to A[0][0](time_to_reach_fire)-1\\n        // Do binarySearch to find the maxWaitTime in the range.\\n        int maxWaitTime=-1;\\n\\n        for(int l=0,r=A[0][0]*-1; l<=r; ){\\n            int mid = (l+r)/2;\\n            int shortestDistance = shortestDistanceBFS(A, mid);\\n\\n            if(shortestDistance==-1){\\n                r = mid-1;\\n                continue;\\n            }\\n            if(maxWaitTime<mid) maxWaitTime = mid;\\n            l = mid+1;\\n        }\\n\\n        return maxWaitTime==A[0][0]*-1 ? 1000000000 : maxWaitTime;\\n    }\\n\\n    public static int shortestDistanceBFS(int [][]A, int waitTime){\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[n][m];\\n\\n        //Find the start node\\n        q.add(new Cell(0,0));\\n        visited[0][0]=true;\\n\\n        for(int time=waitTime+1; !q.isEmpty(); time++) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n                if(cell.i==n-1 && cell.j==m-1) {\\n                    return time;\\n                }\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\\n                        continue;\\n                    }\\n\\n                    //If there is still time for the fire to reach this place.\\n                    if(A[i][j]==0 || A[i][j]*-1>time\\n                            || (A[i][j]*-1==time && i==n-1 && j==m-1)){ // Destination case where fire and the person reaches altogether.\\n                        q.add(new Cell(i,j));\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static void spreadFireBFS(int[][] A) {\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n\\n        //Find the start cells (already in fire)\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(A[i][j]==1){\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n\\n        int time=-1;\\n        for(; !q.isEmpty(); time--) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || A[i][j] != 0) {\\n                        continue;\\n                    }\\n\\n                    A[i][j] = time; // Store negative time as other values will be +ve\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    // Possible directions of a node up, down, left, right.\\n    static int[] R = { -1, +1,  0,  0};\\n    static int[] C = {  0,  0, -1, +1};\\n\\n    private static class Cell {\\n        int i, j;\\n        public Cell(int i, int j) { this.i = i; this.j = j;}\\n    }\\n\\n    public static int maximumMinutes(int[][] A) {\\n\\n        // Spread the fire and record the time when the fire reaches a cell.\\n        spreadFireBFS(A);\\n\\n        // The person can wait for a time in the range 0 to A[0][0](time_to_reach_fire)-1\\n        // Do binarySearch to find the maxWaitTime in the range.\\n        int maxWaitTime=-1;\\n\\n        for(int l=0,r=A[0][0]*-1; l<=r; ){\\n            int mid = (l+r)/2;\\n            int shortestDistance = shortestDistanceBFS(A, mid);\\n\\n            if(shortestDistance==-1){\\n                r = mid-1;\\n                continue;\\n            }\\n            if(maxWaitTime<mid) maxWaitTime = mid;\\n            l = mid+1;\\n        }\\n\\n        return maxWaitTime==A[0][0]*-1 ? 1000000000 : maxWaitTime;\\n    }\\n\\n    public static int shortestDistanceBFS(int [][]A, int waitTime){\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n        boolean[][] visited = new boolean[n][m];\\n\\n        //Find the start node\\n        q.add(new Cell(0,0));\\n        visited[0][0]=true;\\n\\n        for(int time=waitTime+1; !q.isEmpty(); time++) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n                if(cell.i==n-1 && cell.j==m-1) {\\n                    return time;\\n                }\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\\n                        continue;\\n                    }\\n\\n                    //If there is still time for the fire to reach this place.\\n                    if(A[i][j]==0 || A[i][j]*-1>time\\n                            || (A[i][j]*-1==time && i==n-1 && j==m-1)){ // Destination case where fire and the person reaches altogether.\\n                        q.add(new Cell(i,j));\\n                        visited[i][j] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    public static void spreadFireBFS(int[][] A) {\\n        int n=A.length, m = A[0].length;\\n        Queue<Cell> q = new ArrayDeque<>();\\n\\n        //Find the start cells (already in fire)\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(A[i][j]==1){\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n\\n        int time=-1;\\n        for(; !q.isEmpty(); time--) {\\n\\n            for(int size=q.size(); size>0 ; size--) {\\n                Cell cell = q.remove();\\n\\n                // BFS all neighbors if any\\n                for (int k=0; k<R.length; k++) {\\n                    int i = cell.i + R[k];\\n                    int j = cell.j + C[k];\\n\\n                    if(i < 0 || i >= n || j < 0 || j >= m || A[i][j] != 0) {\\n                        continue;\\n                    }\\n\\n                    A[i][j] = time; // Store negative time as other values will be +ve\\n                    q.add(new Cell(i,j));\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914397,
                "title": "python-pure-bfs-solution-beat-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst BFS to calculate matrix A that stores: steps for fire to reach each cell\\n\\nSecond BFS to calculate matrixB that stores: from the **safe house**, if a cell can be reached (steps here doesn\\'t matter as won\\'t be used)\\n\\nThird BFS to calculate for each avaiable cell such as i, j, that satisfies the following two conditions:\\n1. can reach safe house, i.e. B[i][j] < inifity\\n2. can reach before the fire arrives, i.e. step + 1 < A[i][j]\\n\\nAlso, along the way of this BFS, store and update the minimum wait time (i.e. bottlenck of the path from start point to safe house) of the current path. \\n\\nWhen reach the safe house, update the current wait time to the global maximum wait time. There might be multiple paths to the safe house, we find to find the max wait time avaialble among those paths.\\n \\n\\n*Lastly, there is a dirty edge case that, it is okay to reach the safe house at the time if the fires reaches the safe house as well.... like ok to burn with the house.\\n\\nPlease upvote if you like it!\\n\\n# Complexity\\n- Time complexity:\\n O(mn)\\nm is number of ros and n is number of cols\\n\\n- Space complexity:\\nO(mn)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumMinutes(self, arr):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        inf = float(\"inf\")\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        A = [[inf if a < 2 else -1 for a in r] for r in arr]\\n        B = [[-1 if a > 0 else inf for a in r] for r in arr]\\n        def dfs(queue, A):\\n            for i, j, t in queue:\\n                for ni, nj in d:\\n                    if m > i+ni >= 0 and n > j+nj >= 0 and t + 1 < A[i+ni][j+nj]:\\n                        A[i+ni][j+nj] = min(A[i+ni][j+nj], t + 1)\\n                        queue.append([i+ni, j+nj, t + 1])\\n        \\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if arr[i][j] == 1]\\n        dfs(fires, A)\\n        B[m-1][n-1] = 0\\n        dfs([[m-1, n-1, 0]], B)\\n\\n        queue = [[0, 0, 0, inf]]\\n        visited = set((0,0))\\n        res = -1\\n        for i, j, t, wait_time in queue:\\n            for ni, nj in d:\\n                if m > i + ni >= 0 and n > j + nj >= 0 and 0 <= B[i + ni][j + nj] < inf and (t + 1 < A[i + ni][j + nj] or (t + 1 == A[i + ni][j + nj] and i + ni == m - 1 and j + nj == n - 1)) and (i + ni, j + nj) not in visited:\\n                    wait_time_ = max(0, A[i + ni][j + nj] - t - 1) \\n                    if i + ni != m - 1 or j + nj != n - 1:\\n                        wait_time_ -= 1 # corner case ..... house on fire is okay at the time when you arrive ...\\n                    wait_time_ = min(wait_time, wait_time_) # update local min wait time of the current path\\n                    if i + ni == m - 1 and j + nj == n - 1:\\n                        res = max(res, wait_time_) # finish current path to safe hosue, update the global max wait time \\n                        break\\n                    queue.append([i + ni, j + nj, t + 1, wait_time_])\\n                    visited.add((i + ni, j + nj))\\n        return res if res < inf else 10**9\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumMinutes(self, arr):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        inf = float(\"inf\")\\n        d = [[0,1],[1,0],[0,-1],[-1,0]]\\n        A = [[inf if a < 2 else -1 for a in r] for r in arr]\\n        B = [[-1 if a > 0 else inf for a in r] for r in arr]\\n        def dfs(queue, A):\\n            for i, j, t in queue:\\n                for ni, nj in d:\\n                    if m > i+ni >= 0 and n > j+nj >= 0 and t + 1 < A[i+ni][j+nj]:\\n                        A[i+ni][j+nj] = min(A[i+ni][j+nj], t + 1)\\n                        queue.append([i+ni, j+nj, t + 1])\\n        \\n        fires = [[i, j, 0] for i in range(m) for j in range(n) if arr[i][j] == 1]\\n        dfs(fires, A)\\n        B[m-1][n-1] = 0\\n        dfs([[m-1, n-1, 0]], B)\\n\\n        queue = [[0, 0, 0, inf]]\\n        visited = set((0,0))\\n        res = -1\\n        for i, j, t, wait_time in queue:\\n            for ni, nj in d:\\n                if m > i + ni >= 0 and n > j + nj >= 0 and 0 <= B[i + ni][j + nj] < inf and (t + 1 < A[i + ni][j + nj] or (t + 1 == A[i + ni][j + nj] and i + ni == m - 1 and j + nj == n - 1)) and (i + ni, j + nj) not in visited:\\n                    wait_time_ = max(0, A[i + ni][j + nj] - t - 1) \\n                    if i + ni != m - 1 or j + nj != n - 1:\\n                        wait_time_ -= 1 # corner case ..... house on fire is okay at the time when you arrive ...\\n                    wait_time_ = min(wait_time, wait_time_) # update local min wait time of the current path\\n                    if i + ni == m - 1 and j + nj == n - 1:\\n                        res = max(res, wait_time_) # finish current path to safe hosue, update the global max wait time \\n                        break\\n                    queue.append([i + ni, j + nj, t + 1, wait_time_])\\n                    visited.add((i + ni, j + nj))\\n        return res if res < inf else 10**9\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912574,
                "title": "python-3-fast-91-solution-with-explanation-bfs-heap",
                "content": "![image.png](https://assets.leetcode.com/users/images/4a74af1e-d5f0-46fe-b424-ee41399b631f_1671050595.0412362.png)\\n\\n\\n\\n# Approach\\n\\n0. input array from Example 1\\nreplaced some values to improve visualization\\n`0 --> \\'.\\'`, `1 --> \\'*\\'`, `2 --> \\'@\\'`\\n```\\n[.,  @,  .,  .,  .,  .,  .]\\n[.,  .,  .,  @,  @,  *,  .]\\n[.,  @,  .,  .,  *,  @,  .]\\n[.,  .,  @,  @,  @,  .,  @]\\n[.,  .,  .,  .,  .,  .,  .]\\n```\\n1. for every cell find its distance from the top-left corner \\n\\n```\\n[0,  @,  4,  5,  6,  7,  8]\\n[1,  2,  3,  @,  @,  8,  9]\\n[2,  @,  4,  5,  6,  @, 10]\\n[3,  4,  @,  @,  @, 10,  @]\\n[4,  5,  6,  7,  8,  9, 10]\\n```\\n2. for every cell find its distance from the nearest cell with fire\\n\\n```\\n[6,  @,  4,  3,  2,  1,  2]\\n[5,  4,  3,  @,  @,  0,  1]\\n[6,  @,  2,  1,  0,  @,  2]\\n[7,  8,  @,  @,  @, 14,  @]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\\n3. find delta (Step 2 - Step 1)\\nthe bottom-right cell + 1 (because of special condition)\\n\\n```\\n[6,  @,  0, -2, -4, -6, -6]\\n[4,  2,  0,  @,  @, -8, -8]\\n[4,  @, -2, -4, -6,  @, -8]\\n[4,  4,  @,  @,  @,  4,  @]\\n[4,  4,  4,  4,  4,  4,  5]\\n\\n```\\n4. using heap find optimal path \\n\\n```\\n[\\u2022,  @,  0, -2, -4, -6, -6]\\n[\\u2022,  2,  0,  @,  @, -8, -8]\\n[\\u2022,  @, -2, -4, -6,  @, -8]\\n[\\u2022,  4,  @,  @,  @,  4,  @]\\n[\\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022]\\n\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        def bfs(queue_input): # breadth-First Search\\n            \\n            # copy grid, replace wall value (2 --> None)\\n            arr     = [[i   if i != 2 else None   for i in row] for row in grid]\\n            visited = set()\\n            queue   = deque()\\n            \\n            drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n   = len(grid)\\n            col_n   = len(grid[0])\\n            \\n            time = 0\\n            queue.extend(queue_input)\\n            while queue:\\n                for _ in range(len(queue)):   # iterate level by level\\n                    r, c = queue.popleft()    # FIFO method: take cell from the left\\n\\n                    if (r,c) in visited:   continue\\n                    visited.add((r, c))\\n                    arr[r][c] = time          # put distance from the top-left cell\\n\\n                    for r_dlt, c_dlt in drt:\\n                        r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                        if 0 <= r_adj < row_n and \\\\\\n                           0 <= c_adj < col_n:\\n                        \\n                            if arr[r_adj][c_adj] is None:   continue   # skip wall\\n                            queue.append((r_adj, c_adj))  # add cell to the right of the queue\\n\\n                time += 1\\n\\n            return arr\\n\\n        \\n        def find_max_delay(cell_start):   # Heap (Priority Queue)\\n            \\n            visited   = set()\\n            \\n            drt       = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n     = len(grid)\\n            col_n     = len(grid[0])\\n\\n            (r, c)    = cell_start\\n            max_delay = grid[r][c]\\n            hpf       = [(-max_delay, r, c)]   # Heap can find only minimal value\\n                                               # so we change sign of time\\n            \\n            heapify(hpf)   # Heap will return only adjacent cells with the highest delay\\n            while hpf:\\n                (delay, r, c) = heappop(hpf)  # get cell with maximum delta\\n                delay         = -delay        # change sign ot time again\\n                \\n                if delay < 0:           continue   # fire already were in this cell\\n                if (r, c) in visited:   continue\\n                visited.add((r, c))\\n\\n                max_delay = min(max_delay, delay)   # update maximum possible delay\\n                if (r,c) == (row_n - 1, col_n - 1): # we reached the bottom-right cell\\n                    return max_delay - 1            # reduce 1, because we need \\n                                                    # to be in the cell before fire\\n                for r_dlt, c_dlt in drt:\\n                    r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                    if 0 <= r_adj < row_n and \\\\\\n                       0 <= c_adj < col_n:\\n                    \\n                        if grid[r_adj][c_adj] == None:   continue   # skip wall\\n                        heappush(hpf, (-grid[r_adj][c_adj], r_adj, c_adj)) # add adj. cells\\n\\n            return -1\\n\\n        \\n        \\n        \\n        # for every cell find its distance from the top-left corner\\n        human = bfs([(0, 0)])\\n        if human[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return -1            # so you can\\'t reach safehouse --> return -1\\n\\n        # find all cells with fire\\n        que_inp = []\\n        for r, row in enumerate(grid):\\n            for c, val in enumerate(row):\\n                if val == 1:   que_inp.append((r, c))\\n\\n        # for every cell find its distance from the nearest cell with fire\\n        fire  = bfs(que_inp)\\n        if fire[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return 10 ** 9      # so fire can\\'t reach safehouse --> return 1_000_000_000\\n\\n        # find delta: \\n        # distance from the nearest fire - distance from the top-left corner   \\n        for r, row in enumerate(human):\\n            for c, val in enumerate(row):\\n                if val is None:   grid[r][c] = None\\n                else:             grid[r][c] = fire[r][c] - human[r][c]\\n        # for the bottom-right cell we should take into consideration certain condition:\\n        # \\'if the fire spreads to the safehouse immediately after you have reached it\\'\\n        grid[~0][~0] += 1\\n\\n        # using Heap (Priority Queue)\\n        # find maximum delay through the optimal path (start from the top-left cell)\\n        return find_max_delay((0, 0))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n[.,  @,  .,  .,  .,  .,  .]\\n[.,  .,  .,  @,  @,  *,  .]\\n[.,  @,  .,  .,  *,  @,  .]\\n[.,  .,  @,  @,  @,  .,  @]\\n[.,  .,  .,  .,  .,  .,  .]\\n```\n```\\n[0,  @,  4,  5,  6,  7,  8]\\n[1,  2,  3,  @,  @,  8,  9]\\n[2,  @,  4,  5,  6,  @, 10]\\n[3,  4,  @,  @,  @, 10,  @]\\n[4,  5,  6,  7,  8,  9, 10]\\n```\n```\\n[6,  @,  4,  3,  2,  1,  2]\\n[5,  4,  3,  @,  @,  0,  1]\\n[6,  @,  2,  1,  0,  @,  2]\\n[7,  8,  @,  @,  @, 14,  @]\\n[8,  9, 10, 11, 12, 13, 14]\\n```\n```\\n[6,  @,  0, -2, -4, -6, -6]\\n[4,  2,  0,  @,  @, -8, -8]\\n[4,  @, -2, -4, -6,  @, -8]\\n[4,  4,  @,  @,  @,  4,  @]\\n[4,  4,  4,  4,  4,  4,  5]\\n\\n```\n```\\n[\\u2022,  @,  0, -2, -4, -6, -6]\\n[\\u2022,  2,  0,  @,  @, -8, -8]\\n[\\u2022,  @, -2, -4, -6,  @, -8]\\n[\\u2022,  4,  @,  @,  @,  4,  @]\\n[\\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022,  \\u2022]\\n\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        def bfs(queue_input): # breadth-First Search\\n            \\n            # copy grid, replace wall value (2 --> None)\\n            arr     = [[i   if i != 2 else None   for i in row] for row in grid]\\n            visited = set()\\n            queue   = deque()\\n            \\n            drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n   = len(grid)\\n            col_n   = len(grid[0])\\n            \\n            time = 0\\n            queue.extend(queue_input)\\n            while queue:\\n                for _ in range(len(queue)):   # iterate level by level\\n                    r, c = queue.popleft()    # FIFO method: take cell from the left\\n\\n                    if (r,c) in visited:   continue\\n                    visited.add((r, c))\\n                    arr[r][c] = time          # put distance from the top-left cell\\n\\n                    for r_dlt, c_dlt in drt:\\n                        r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                        if 0 <= r_adj < row_n and \\\\\\n                           0 <= c_adj < col_n:\\n                        \\n                            if arr[r_adj][c_adj] is None:   continue   # skip wall\\n                            queue.append((r_adj, c_adj))  # add cell to the right of the queue\\n\\n                time += 1\\n\\n            return arr\\n\\n        \\n        def find_max_delay(cell_start):   # Heap (Priority Queue)\\n            \\n            visited   = set()\\n            \\n            drt       = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n            row_n     = len(grid)\\n            col_n     = len(grid[0])\\n\\n            (r, c)    = cell_start\\n            max_delay = grid[r][c]\\n            hpf       = [(-max_delay, r, c)]   # Heap can find only minimal value\\n                                               # so we change sign of time\\n            \\n            heapify(hpf)   # Heap will return only adjacent cells with the highest delay\\n            while hpf:\\n                (delay, r, c) = heappop(hpf)  # get cell with maximum delta\\n                delay         = -delay        # change sign ot time again\\n                \\n                if delay < 0:           continue   # fire already were in this cell\\n                if (r, c) in visited:   continue\\n                visited.add((r, c))\\n\\n                max_delay = min(max_delay, delay)   # update maximum possible delay\\n                if (r,c) == (row_n - 1, col_n - 1): # we reached the bottom-right cell\\n                    return max_delay - 1            # reduce 1, because we need \\n                                                    # to be in the cell before fire\\n                for r_dlt, c_dlt in drt:\\n                    r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                    if 0 <= r_adj < row_n and \\\\\\n                       0 <= c_adj < col_n:\\n                    \\n                        if grid[r_adj][c_adj] == None:   continue   # skip wall\\n                        heappush(hpf, (-grid[r_adj][c_adj], r_adj, c_adj)) # add adj. cells\\n\\n            return -1\\n\\n        \\n        \\n        \\n        # for every cell find its distance from the top-left corner\\n        human = bfs([(0, 0)])\\n        if human[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return -1            # so you can\\'t reach safehouse --> return -1\\n\\n        # find all cells with fire\\n        que_inp = []\\n        for r, row in enumerate(grid):\\n            for c, val in enumerate(row):\\n                if val == 1:   que_inp.append((r, c))\\n\\n        # for every cell find its distance from the nearest cell with fire\\n        fire  = bfs(que_inp)\\n        if fire[~0][~0] == 0:   # BFS didn\\'t reach the bottom-right cell\\n            return 10 ** 9      # so fire can\\'t reach safehouse --> return 1_000_000_000\\n\\n        # find delta: \\n        # distance from the nearest fire - distance from the top-left corner   \\n        for r, row in enumerate(human):\\n            for c, val in enumerate(row):\\n                if val is None:   grid[r][c] = None\\n                else:             grid[r][c] = fire[r][c] - human[r][c]\\n        # for the bottom-right cell we should take into consideration certain condition:\\n        # \\'if the fire spreads to the safehouse immediately after you have reached it\\'\\n        grid[~0][~0] += 1\\n\\n        # using Heap (Priority Queue)\\n        # find maximum delay through the optimal path (start from the top-left cell)\\n        return find_max_delay((0, 0))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865838,
                "title": "binary-search-on-answer-best-code-easy-solution-python",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tmx = float(\\'inf\\')\\n\\t\\t\\tm,n = len(grid), len(grid[0])\\n\\t\\t\\tarr = [[mx for i in range(n)] for j in range(m)]\\n\\t\\t\\tq = deque([(j,i) for i in range(n) for j in range(m) if grid[j][i] == 1])\\n\\t\\t\\tfor i,j in q:\\n\\t\\t\\t\\tarr[i][j] = 0\\n\\t\\t\\tvisited = set(q)\\n\\t\\t\\ttemp = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tl = len(q)\\n\\t\\t\\t\\tfor j in range(l):\\n\\t\\t\\t\\t\\tx,y = q.popleft()\\n\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\tarr[x][y] = temp\\n\\t\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and grid[xx][yy] == 0 and (xx,yy) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tq.append((xx,yy))\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\tdef solve(x,y,temp):\\n\\t\\t\\t\\tnonlocal visited\\n\\t\\t\\t\\tval = arr[x][y]\\n\\t\\t\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\t\\t\\treturn temp <= val\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tif val <= temp:return False\\n\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and (xx,yy) not in visited and grid[xx][yy] != 2:\\n\\t\\t\\t\\t\\t\\tif solve(xx,yy, temp+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# visited.remove((x,y))\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t# for row in arr:\\n\\t\\t\\t#     print(*row)\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tif not solve(0,0,0):return -1\\n\\t\\t\\tl,r = 0,10**9\\n\\t\\t\\tans = None\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tmid = (l+r)//2\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tif solve(0,0,mid):\\n\\t\\t\\t\\t\\tans = mid\\n\\t\\t\\t\\t\\tl = mid+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid-1\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tmx = float(\\'inf\\')\\n\\t\\t\\tm,n = len(grid), len(grid[0])\\n\\t\\t\\tarr = [[mx for i in range(n)] for j in range(m)]\\n\\t\\t\\tq = deque([(j,i) for i in range(n) for j in range(m) if grid[j][i] == 1])\\n\\t\\t\\tfor i,j in q:\\n\\t\\t\\t\\tarr[i][j] = 0\\n\\t\\t\\tvisited = set(q)\\n\\t\\t\\ttemp = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tl = len(q)\\n\\t\\t\\t\\tfor j in range(l):\\n\\t\\t\\t\\t\\tx,y = q.popleft()\\n\\t\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\t\\tarr[x][y] = temp\\n\\t\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and grid[xx][yy] == 0 and (xx,yy) not in visited:\\n\\t\\t\\t\\t\\t\\t\\tq.append((xx,yy))\\n\\t\\t\\t\\ttemp += 1\\n\\t\\t\\tdef solve(x,y,temp):\\n\\t\\t\\t\\tnonlocal visited\\n\\t\\t\\t\\tval = arr[x][y]\\n\\t\\t\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\t\\t\\treturn temp <= val\\n\\t\\t\\t\\tvisited.add((x,y))\\n\\t\\t\\t\\tif val <= temp:return False\\n\\t\\t\\t\\tfor i,j in (1,0),(0,1),(-1,0),(0,-1):\\n\\t\\t\\t\\t\\txx = x+i\\n\\t\\t\\t\\t\\tyy = y+j\\n\\t\\t\\t\\t\\tif 0<=xx<m and 0<=yy<n and (xx,yy) not in visited and grid[xx][yy] != 2:\\n\\t\\t\\t\\t\\t\\tif solve(xx,yy, temp+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# visited.remove((x,y))\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t# for row in arr:\\n\\t\\t\\t#     print(*row)\\n\\t\\t\\tvisited = set()\\n\\t\\t\\tif not solve(0,0,0):return -1\\n\\t\\t\\tl,r = 0,10**9\\n\\t\\t\\tans = None\\n\\t\\t\\twhile l <= r:\\n\\t\\t\\t\\tmid = (l+r)//2\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tif solve(0,0,mid):\\n\\t\\t\\t\\t\\tans = mid\\n\\t\\t\\t\\t\\tl = mid+1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid-1\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2826656,
                "title": "java-time-o-log-mn-mn-space-o-mn-two-bfs",
                "content": "```\\nthis is an excellent explanation : \\nhttps://leetcode.com/problems/escape-the-spreading-fire/discuss/1995157/Solution-%2B-Intuition-%2B-Explanation-with-Pictures\\n\\n\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dist = bfs(grid);\\n        int l = 0, r = (int)1e9, ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isSafe(grid,dist,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean isSafe(int[][] grid, int[][] fire, int waitTime){\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] seen = new boolean[m][n];\\n        seen[0][0] = true;\\n        q.offer(new int[]{0,0,waitTime});\\n        while(!q.isEmpty()){\\n            int[] curCell = q.poll();\\n            for(int[] d:dirs){\\n                int nx = curCell[0] + d[0], ny = curCell[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||grid[nx][ny] == 2||seen[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//************** these four lines of code are very essential ************\\n                if(nx==m-1&&ny==n-1&&curCell[2]+1 <= fire[nx][ny])\\n                    return true;\\n                if(curCell[2]+1>=fire[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t//why not checking the termination condition before entering the loop,\\n\\t\\t\\t\\t//like we always do when performing bfs ?\\n\\t\\t\\t    //please think about this ..\\n\\t\\t\\t    //***********************************************************************\\n                \\n                seen[nx][ny] = true;\\n                q.offer(new int[]{nx,ny,curCell[2]+1});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    private int[][] bfs(int[][] grid){\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] result = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(result[i], Integer.MAX_VALUE);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    q.offer(new int[]{i,j,0});\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int[] tmp = q.poll();\\n            for(int[] d:dirs){\\n                int nx = tmp[0] + d[0], ny = tmp[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||result[nx][ny] <= tmp[2] || grid[nx][ny] == 2)\\n                    continue;\\n                \\n                result[nx][ny] = tmp[2]+1;\\n                q.offer(new int[]{nx,ny,result[nx][ny]});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nthis is an excellent explanation : \\nhttps://leetcode.com/problems/escape-the-spreading-fire/discuss/1995157/Solution-%2B-Intuition-%2B-Explanation-with-Pictures\\n\\n\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dist = bfs(grid);\\n        int l = 0, r = (int)1e9, ans = -1;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            if(isSafe(grid,dist,mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    private boolean isSafe(int[][] grid, int[][] fire, int waitTime){\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] seen = new boolean[m][n];\\n        seen[0][0] = true;\\n        q.offer(new int[]{0,0,waitTime});\\n        while(!q.isEmpty()){\\n            int[] curCell = q.poll();\\n            for(int[] d:dirs){\\n                int nx = curCell[0] + d[0], ny = curCell[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||grid[nx][ny] == 2||seen[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//************** these four lines of code are very essential ************\\n                if(nx==m-1&&ny==n-1&&curCell[2]+1 <= fire[nx][ny])\\n                    return true;\\n                if(curCell[2]+1>=fire[nx][ny])\\n                    continue;\\n\\t\\t\\t\\t//why not checking the termination condition before entering the loop,\\n\\t\\t\\t\\t//like we always do when performing bfs ?\\n\\t\\t\\t    //please think about this ..\\n\\t\\t\\t    //***********************************************************************\\n                \\n                seen[nx][ny] = true;\\n                q.offer(new int[]{nx,ny,curCell[2]+1});\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    \\n    private int[][] bfs(int[][] grid){\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] result = new int[m][n];\\n        for(int i=0;i<m;i++)\\n            Arrays.fill(result[i], Integer.MAX_VALUE);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j =0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    q.offer(new int[]{i,j,0});\\n                    result[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while(!q.isEmpty()){\\n            int[] tmp = q.poll();\\n            for(int[] d:dirs){\\n                int nx = tmp[0] + d[0], ny = tmp[1] + d[1];\\n                if(nx<0||nx>=m||ny<0||ny>=n||result[nx][ny] <= tmp[2] || grid[nx][ny] == 2)\\n                    continue;\\n                \\n                result[nx][ny] = tmp[2]+1;\\n                q.offer(new int[]{nx,ny,result[nx][ny]});\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823188,
                "title": "c-breadth-first-traversal-bfs-on-2d-array-explained",
                "content": "# Intuition\\nPorted from: https://leetcode.com/problems/escape-the-spreading-fire/solutions/2016835/no-bs/\\nFrom link above: \\n1-\"Use BFS to calculate steps from the person to the safehouse, and the closest distance from any fire to the safehouse. The difference between fire distance and person steps **-1** is our answer.\" \\n2-\"compare the difference for two adjacent (to the safehouse) cells. If the difference is larger for any of the adjacent cells, *then we do not need to subtract one.\"*\\n# Approach\\n1-Initialize a direction vector **DIRS** and two queues of **Point** to store the indices of matrix cells.\\n```\\nstatic int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n  \\nQueue<Point> fire = new (), person = new ();\\n\\n```\\n\\n2 - Enqueue the index of the person cell into the person queue.\\n```\\nperson.Enqueue(new Point(0,0));\\n```\\n3 - Enqueue the indexes of the fire cells into the fire queue.\\n```\\nfor (int i = 0; i < grid.Length; ++i)\\n    for (int j = 0; j < grid[0].Length; ++j)\\n        if (grid[i][j] == 1)\\n            fire.Enqueue(new Point(i, j));\\n```\\n3 - Traverse the grid for both fire and person separately\\n```\\n int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n```\\nThe method *Steps* will return a three-element array. The first element is the step count to arrive at the safehouse, the second is the step count to arrive at its left neighbor and the third is the step count to arrive at its top neigbor.\\n4- we keep track of visited cells by monitoring the state of the array $$st$$ which is the same size of our grid and starts with zero elements.\\n```\\n if(... st[nx,ny] ==0) {do stuff}\\n```\\n5-we also only visit non-brick, non-fire spots\\n```\\n if(... grid[nx][ny]==0 ...) {do stuff}\\n```\\n6-Note we keep re-adding Points to the queue every time there\\'s a move.\\n```\\npos.Enqueue(new Point(nx,ny));\\n```\\nEventually that queue will be empetied inside its while loop when the boundary conditions start to get hit. When that happens, we\\'ll build and return the step count array.\\n\\n7-if the step count array for **fire** has first element zero, it means fire never arrived at the safehouse (since fire cannot start at the safehouse). If that number is not zero for the step count array for **person**, then we can always reach the safehouse regardless of the minutes stayed\\n```\\nif (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n```\\n\\n8-Apply rules 1 and 2 from the intution\\n```\\nif (stepsPerson[0] != 0 && diff >= 0) {\\n    int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n    return diff -sub;\\n}\\nreturn -1;\\n```\\n\\n\\n\\n# Code\\n```\\npublic class Solution {\\n     static int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n\\n    public int MaximumMinutes(int[][] grid) {\\n        Queue<Point> fire = new (), person = new ();\\n        person.Enqueue(new Point(0,0));\\n\\n        for (int i = 0; i < grid.Length; ++i)\\n            for (int j = 0; j < grid[0].Length; ++j)\\n                if (grid[i][j] == 1)\\n                    fire.Enqueue(new Point(i, j));\\n\\n        int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n        if (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n        int diff = stepsFire[0] - stepsPerson[0];\\n        if (stepsPerson[0] != 0 && diff >= 0) {\\n            int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n            return diff -sub;\\n        }\\n        return -1;\\n    }\\n    private int[] Steps(int[][] grid, Queue<Point> pos) {\\n        int[] steps = new int[3];\\n        int m = grid.Length, n = grid[0].Length;\\n        int[,] st = new int[m,n];\\n        while(pos.Count > 0) {\\n            Point point = pos.Dequeue();\\n            foreach (int[] dir in DIRS) {\\n                int nx = point.x + dir[0], ny = point.y+dir[1];\\n                if(Math.Min(nx,ny)>=0 && nx<m && ny<n && grid[nx][ny]==0 && st[nx,ny] ==0) {\\n                    st[nx,ny] = st[point.x,point.y] + 1;\\n                    pos.Enqueue(new Point(nx,ny));\\n                }\\n            }\\n        }\\n        steps[0] = st[m-1,n-1];\\n        steps[1] = st[m-2,n-1];\\n        steps[2] = st[m-1,n-2];\\n        return steps;\\n    }\\n\\nclass Point {\\n    public int x;\\n    public int y;\\n\\n    public Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nstatic int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n  \\nQueue<Point> fire = new (), person = new ();\\n\\n```\n```\\nperson.Enqueue(new Point(0,0));\\n```\n```\\nfor (int i = 0; i < grid.Length; ++i)\\n    for (int j = 0; j < grid[0].Length; ++j)\\n        if (grid[i][j] == 1)\\n            fire.Enqueue(new Point(i, j));\\n```\n```\\n int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n```\n```\\n if(... st[nx,ny] ==0) {do stuff}\\n```\n```\\n if(... grid[nx][ny]==0 ...) {do stuff}\\n```\n```\\npos.Enqueue(new Point(nx,ny));\\n```\n```\\nif (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n```\n```\\nif (stepsPerson[0] != 0 && diff >= 0) {\\n    int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n    return diff -sub;\\n}\\nreturn -1;\\n```\n```\\npublic class Solution {\\n     static int[][] DIRS = new int[][]{new int[]{0, 1}, \\n        new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};\\n\\n    public int MaximumMinutes(int[][] grid) {\\n        Queue<Point> fire = new (), person = new ();\\n        person.Enqueue(new Point(0,0));\\n\\n        for (int i = 0; i < grid.Length; ++i)\\n            for (int j = 0; j < grid[0].Length; ++j)\\n                if (grid[i][j] == 1)\\n                    fire.Enqueue(new Point(i, j));\\n\\n        int[] stepsFire = Steps(grid, fire), stepsPerson = Steps(grid, person);\\n        if (stepsFire[0] == 0 && stepsPerson[0] != 0)\\n            return 1000000000;\\n        int diff = stepsFire[0] - stepsPerson[0];\\n        if (stepsPerson[0] != 0 && diff >= 0) {\\n            int sub = (stepsFire[1] - stepsPerson[1] <= diff && stepsFire[2] - stepsPerson[2] <= diff) ? 1 : 0;\\n            return diff -sub;\\n        }\\n        return -1;\\n    }\\n    private int[] Steps(int[][] grid, Queue<Point> pos) {\\n        int[] steps = new int[3];\\n        int m = grid.Length, n = grid[0].Length;\\n        int[,] st = new int[m,n];\\n        while(pos.Count > 0) {\\n            Point point = pos.Dequeue();\\n            foreach (int[] dir in DIRS) {\\n                int nx = point.x + dir[0], ny = point.y+dir[1];\\n                if(Math.Min(nx,ny)>=0 && nx<m && ny<n && grid[nx][ny]==0 && st[nx,ny] ==0) {\\n                    st[nx,ny] = st[point.x,point.y] + 1;\\n                    pos.Enqueue(new Point(nx,ny));\\n                }\\n            }\\n        }\\n        steps[0] = st[m-1,n-1];\\n        steps[1] = st[m-2,n-1];\\n        steps[2] = st[m-1,n-2];\\n        return steps;\\n    }\\n\\nclass Point {\\n    public int x;\\n    public int y;\\n\\n    public Point(int x, int y) {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789491,
                "title": "most-annoying-question",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    \\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    map<array<int, 3>, int> dp;\\n    \\n    int ok(int &x, int &y, int &rows, int &cols)\\n    {\\n        return (x >= 0 && y >= 0 && x < rows && y < cols);\\n    }\\n    \\n    void bfs(queue<array<int, 2>> &q, vector<vector<int>> &reachFire, vector<vector<int>> &grid)\\n    {\\n        int time = 1, rows = reachFire.size(), cols = reachFire[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(ok(vx, vy, rows, cols) && grid[vx][vy] == 0 && reachFire[vx][vy] == INF)\\n                    {\\n                        reachFire[vx][vy] = time;\\n                        q.push({vx, vy});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return;\\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        vector<vector<int>> reachFire(rows, vector<int> (cols, INF));\\n        \\n        \\n        queue<array<int, 2>> q1;\\n        \\n        for(int itr = 0; itr < rows; itr++)\\n        {\\n            for(int itc = 0; itc < cols; itc++)\\n            {\\n                if(grid[itr][itc] == 1)\\n                {\\n                    reachFire[itr][itc] = 0;\\n                    q1.push({itr, itc});\\n                }\\n            }\\n        }\\n        \\n        bfs(q1, reachFire, grid);\\n        \\n        queue<array<int, 2>> q;\\n        map<array<int, 2>, int> mp;\\n        \\n        if(reachFire[0][0] == 0)\\n            return -1;\\n        \\n        int val = (reachFire[0][0] == INF ? (INF) : (reachFire[0][0] - 1));\\n        \\n        q.push({0, 0});\\n        mp[{0, 0}] = val;\\n        \\n        grid[0][0] = 2;\\n        \\n        int currTime = 1;\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(vx == rows - 1 && vy == cols - 1 && currTime <= reachFire[vx][vy])\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                    else if(ok(vx, vy, rows, cols) && currTime < reachFire[vx][vy] && grid[vx][vy] == 0)\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime - 1)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        if(mp.find({rows - 1, cols - 1}) == mp.end())\\n            return -1;\\n        \\n        return mp[{rows - 1, cols - 1}];\\n    }\\n}; \\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9;\\n    \\n    int dx[4] = {1, -1, 0, 0};\\n    int dy[4] = {0, 0, 1, -1};\\n    \\n    map<array<int, 3>, int> dp;\\n    \\n    int ok(int &x, int &y, int &rows, int &cols)\\n    {\\n        return (x >= 0 && y >= 0 && x < rows && y < cols);\\n    }\\n    \\n    void bfs(queue<array<int, 2>> &q, vector<vector<int>> &reachFire, vector<vector<int>> &grid)\\n    {\\n        int time = 1, rows = reachFire.size(), cols = reachFire[0].size();\\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(ok(vx, vy, rows, cols) && grid[vx][vy] == 0 && reachFire[vx][vy] == INF)\\n                    {\\n                        reachFire[vx][vy] = time;\\n                        q.push({vx, vy});\\n                    }\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return;\\n    }\\n    \\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size(), cols = grid[0].size();\\n        \\n        vector<vector<int>> reachFire(rows, vector<int> (cols, INF));\\n        \\n        \\n        queue<array<int, 2>> q1;\\n        \\n        for(int itr = 0; itr < rows; itr++)\\n        {\\n            for(int itc = 0; itc < cols; itc++)\\n            {\\n                if(grid[itr][itc] == 1)\\n                {\\n                    reachFire[itr][itc] = 0;\\n                    q1.push({itr, itc});\\n                }\\n            }\\n        }\\n        \\n        bfs(q1, reachFire, grid);\\n        \\n        queue<array<int, 2>> q;\\n        map<array<int, 2>, int> mp;\\n        \\n        if(reachFire[0][0] == 0)\\n            return -1;\\n        \\n        int val = (reachFire[0][0] == INF ? (INF) : (reachFire[0][0] - 1));\\n        \\n        q.push({0, 0});\\n        mp[{0, 0}] = val;\\n        \\n        grid[0][0] = 2;\\n        \\n        int currTime = 1;\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            \\n            while(sz-- > 0)\\n            {\\n                int ux = q.front()[0], uy = q.front()[1];\\n                q.pop();\\n                \\n                int vx, vy;\\n                \\n                for(int dir = 0; dir < 4; dir++)\\n                {\\n                    vx = ux + dx[dir];\\n                    vy = uy + dy[dir];\\n                    \\n                    if(vx == rows - 1 && vy == cols - 1 && currTime <= reachFire[vx][vy])\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                    else if(ok(vx, vy, rows, cols) && currTime < reachFire[vx][vy] && grid[vx][vy] == 0)\\n                    {\\n                        int tmpVal = min(mp[{ux, uy}], (reachFire[vx][vy] == INF ? (INF) : (reachFire[vx][vy] - currTime - 1)));\\n                        if(mp.find({vx, vy}) != mp.end())\\n                        {\\n                            mp[{vx, vy}] = max(mp[{vx, vy}], tmpVal);\\n                        }\\n                        else\\n                        {\\n                            mp[{vx, vy}] = tmpVal;\\n                            q.push({vx, vy});\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        if(mp.find({rows - 1, cols - 1}) == mp.end())\\n            return -1;\\n        \\n        return mp[{rows - 1, cols - 1}];\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777027,
                "title": "javascript-bfs-binary-search",
                "content": "**Solution: BFS & Binary Search**\\n\\nBinary search for the maximum number of minutes to reach the safehouse (lower bound: `0`, upper bound: `10^9`)\\n\\n1. We need to do some preprocessing.\\n\\t*   BFS level-by-level to record the minimum time for fire to spread to each individual cell (`fireSpread[row][col] = minimum number of minutes for fire to spread to grid[row][col]`)\\n\\n2. Binary search for the number of minutes:\\n\\t*   To check whether we can reach the safehouse after waiting x minutes:\\n\\t\\t*    BFS level-by-level, keeping track of the number of minutes.\\n\\t\\t*    We can only move to an adjacent cell if the time for the fire to reach it is less than the current time + 1. (The only exception is the safehouse, in which it can be equal time).\\n\\n`m = number of rows`, `n = number of columns`, `k = 10^9`\\nTime Complexity: `O(mn log(k))` 447ms\\nSpace Complexity: `O(mn)` 62.6MB\\n```\\nvar maximumMinutes = function(grid) {\\n  let fireSpread = getFireSpreadTime(grid);\\n  let low = 0, high = 10 ** 9;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canReachSafehouse(grid, fireSpread, mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return canReachSafehouse(grid, fireSpread, low) ? low : -1;\\n};\\n\\nfunction canReachSafehouse(originalGrid, fireSpread, timeToWait) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [[0, 0]], time = timeToWait;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      if (row === m - 1 && col === n - 1) {\\n        return true;\\n      }\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        let isTarget = newX === m - 1 && newY === n - 1;\\n        if ((isTarget && time + 1 <= fireSpread[newX][newY]) || time + 1 < fireSpread[newX][newY]) { // only visit if fire will not spread to new cell at the next minute\\n          grid[newX][newY] = 1;\\n          queue.push([newX, newY]);\\n        }\\n      }\\n    }\\n    time++;\\n  }\\n  return false;\\n}\\n\\nfunction getFireSpreadTime(originalGrid) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        queue.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  let time = 0, fireSpread = Array(m).fill(0).map(() => Array(n).fill(Infinity));\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      fireSpread[row][col] = time;\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        grid[newX][newY] = 1;\\n        queue.push([newX, newY]);\\n      }\\n    }\\n    time++;\\n  }\\n  return fireSpread;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumMinutes = function(grid) {\\n  let fireSpread = getFireSpreadTime(grid);\\n  let low = 0, high = 10 ** 9;\\n  while (low < high) {\\n    let mid = Math.ceil((low + high) / 2);\\n    if (canReachSafehouse(grid, fireSpread, mid)) low = mid;\\n    else high = mid - 1;\\n  }\\n  return canReachSafehouse(grid, fireSpread, low) ? low : -1;\\n};\\n\\nfunction canReachSafehouse(originalGrid, fireSpread, timeToWait) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [[0, 0]], time = timeToWait;\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      if (row === m - 1 && col === n - 1) {\\n        return true;\\n      }\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        let isTarget = newX === m - 1 && newY === n - 1;\\n        if ((isTarget && time + 1 <= fireSpread[newX][newY]) || time + 1 < fireSpread[newX][newY]) { // only visit if fire will not spread to new cell at the next minute\\n          grid[newX][newY] = 1;\\n          queue.push([newX, newY]);\\n        }\\n      }\\n    }\\n    time++;\\n  }\\n  return false;\\n}\\n\\nfunction getFireSpreadTime(originalGrid) {\\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n  let grid = originalGrid.map((row) => [...row]);\\n  let m = grid.length, n = grid[0].length;\\n  let queue = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        queue.push([i, j]);\\n      }\\n    }\\n  }\\n  \\n  let time = 0, fireSpread = Array(m).fill(0).map(() => Array(n).fill(Infinity));\\n  while (queue.length) {\\n    for (let i = queue.length; i > 0; i--) {\\n      let [row, col] = queue.shift();\\n      fireSpread[row][col] = time;\\n      for (let [x, y] of directions) {\\n        let newX = row + x, newY = col + y;\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] !== 0) continue; // out of bounds or cell is not grass\\n        grid[newX][newY] = 1;\\n        queue.push([newX, newY]);\\n      }\\n    }\\n    time++;\\n  }\\n  return fireSpread;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765909,
                "title": "python-bfs-and-binary-search",
                "content": "```\\nfrom itertools import product \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fires, cur_fires = [[float(\\'inf\\')] * n for _ in range(m)], []\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                cur_fires.append((x, y))\\n                fires[x][y] = 0\\n            elif grid[x][y] == 2: fires[x][y] = -1\\n        while cur_fires:\\n            nxt_fires = []\\n            for x, y in cur_fires:\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and fires[nx][ny] == float(\\'inf\\'):\\n                        fires[nx][ny] = fires[x][y] + 1\\n                        nxt_fires.append((nx, ny))\\n            cur_fires = nxt_fires\\n        def bfs(x, y, tp):\\n            cur, visited = {(x, y)}, {(x, y)}\\n            tp += 1\\n            while cur:\\n                nxt = set()\\n                for x, y in cur:\\n                    for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and tp <= fires[nx][ny]:\\n                            if nx == m - 1 and ny == n - 1: return True\\n                            if tp == fires[nx][ny]: continue\\n                            visited.add((nx, ny))\\n                            nxt.add((nx, ny))\\n                tp += 1\\n                cur = nxt\\n            return False\\n        if fires[0][0] == float(\\'inf\\') and fires[m - 1][n - 1] == float(\\'inf\\') and bfs(0, 0, m * n + 1): return 10 ** 9\\n        ans, lo, hi = -1, 0, min(fires[0][0], fires[m - 1][n - 1])\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if bfs(0, 0, mid):\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import product \\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        fires, cur_fires = [[float(\\'inf\\')] * n for _ in range(m)], []\\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                cur_fires.append((x, y))\\n                fires[x][y] = 0\\n            elif grid[x][y] == 2: fires[x][y] = -1\\n        while cur_fires:\\n            nxt_fires = []\\n            for x, y in cur_fires:\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and fires[nx][ny] == float(\\'inf\\'):\\n                        fires[nx][ny] = fires[x][y] + 1\\n                        nxt_fires.append((nx, ny))\\n            cur_fires = nxt_fires\\n        def bfs(x, y, tp):\\n            cur, visited = {(x, y)}, {(x, y)}\\n            tp += 1\\n            while cur:\\n                nxt = set()\\n                for x, y in cur:\\n                    for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                        if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and tp <= fires[nx][ny]:\\n                            if nx == m - 1 and ny == n - 1: return True\\n                            if tp == fires[nx][ny]: continue\\n                            visited.add((nx, ny))\\n                            nxt.add((nx, ny))\\n                tp += 1\\n                cur = nxt\\n            return False\\n        if fires[0][0] == float(\\'inf\\') and fires[m - 1][n - 1] == float(\\'inf\\') and bfs(0, 0, m * n + 1): return 10 ** 9\\n        ans, lo, hi = -1, 0, min(fires[0][0], fires[m - 1][n - 1])\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if bfs(0, 0, mid):\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654363,
                "title": "simple-bfs-c-binary-search",
                "content": "# Intuition\\nby hit and trail try possible outcome  (binary search)\\n\\n# Approach\\nrun  a bfs to measure when will fire reach at  grass\\'cells (Multisource BFS).\\nthen do a binary search figure out valid time with help of bfs\\n \\n\\n# Complexity\\n- Time complexity:\\nN*N*log(N)\\n\\n- Space complexity:\\nN*N\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dx[4]={1,-1,0,0};\\nint dy[4]={0,0,1,-1};\\nint n,m;\\n  bool is_valid(int x,int y)\\n  {\\n      if(x<0 || x>=n || y<0 || y>=m)\\n      return false;\\n      return true;\\n  }\\n   bool bfs(long long timer,vector<vector<int>> &time, vector<vector<int>>& grid,vector<vector<bool>> &visit1)\\n   {\\n      queue<pair<int,int>>q;\\n      if(time[0][0]>timer)\\n      {\\n          q.push({0,0});\\n          visit1[0][0]=true;\\n      } \\n      \\n      while(!q.empty())\\n      {\\n          int z=q.size();\\n          \\n          for(int a=0;a<z;a++)\\n        {\\n                   int x=q.front().first;\\n                   int y=q.front().second;\\n                   q.pop();\\n                  // visit1[x][y]=true;\\n               if(x==n-1 && y==m-1)\\n               {\\n                   if(time[x][y]>=timer)\\n                     return true;\\n                     else\\n                     continue;\\n\\n               }  \\n            if(time[x][y]<=timer)continue;\\n\\n          for(int k=0;k<4;k++)\\n          {\\n              int xn=x+dx[k];\\n              int yn=y+dy[k];\\n              \\n              \\n              if(is_valid(xn,yn) && visit1[xn][yn]==false && grid[xn][yn]==0)\\n              {\\n                 q.push({xn,yn});\\n                 visit1[xn][yn]=true;\\n                  \\n              }\\n          }\\n     }timer++;\\n        \\n         \\n      }\\n      return false;\\n\\n   }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n         n=grid.size();\\n         m=grid[0].size();\\n         vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n       vector<vector<bool>> visit(n,vector<bool>(m,false));\\n       queue<pair<int,int>>q;\\n        int timer=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j]==1){\\n              // time[i][j]=timer;    \\n               q.push({i,j});\\n               }\\n           }\\n       }\\n      \\n       while(!q.empty())\\n       {\\n           int k=q.size();\\n           timer+=1;\\n           while(k--)\\n           {\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               q.pop();\\n               for(int i=0;i<4;i++)\\n               {\\n                   int xn=x+dx[i];\\n                   int yn=y+dy[i];\\n                   if(is_valid(xn,yn) && !visit[xn][yn] && grid[xn][yn]==0)\\n                   {\\n                       visit[xn][yn]=true;\\n                     time[xn][yn]=timer;\\n                     q.push({xn,yn});\\n                   }\\n               }\\n           }\\n           \\n       }\\n\\n        int ans=-1;\\n        long long l=0,r=1e11;\\n        while(l<=r)\\n        {  vector<vector<bool>>visit1(n,vector<bool>(m,false));\\n            long long mid=l+(r-l)/2;\\n            if(bfs(mid,time,grid,visit1))\\n            {   \\n                ans=mid;\\n                l=mid+1;\\n               \\n            }\\n            else\\n            r=mid-1;\\n        }\\n        \\n        if(ans>=1e9)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dx[4]={1,-1,0,0};\\nint dy[4]={0,0,1,-1};\\nint n,m;\\n  bool is_valid(int x,int y)\\n  {\\n      if(x<0 || x>=n || y<0 || y>=m)\\n      return false;\\n      return true;\\n  }\\n   bool bfs(long long timer,vector<vector<int>> &time, vector<vector<int>>& grid,vector<vector<bool>> &visit1)\\n   {\\n      queue<pair<int,int>>q;\\n      if(time[0][0]>timer)\\n      {\\n          q.push({0,0});\\n          visit1[0][0]=true;\\n      } \\n      \\n      while(!q.empty())\\n      {\\n          int z=q.size();\\n          \\n          for(int a=0;a<z;a++)\\n        {\\n                   int x=q.front().first;\\n                   int y=q.front().second;\\n                   q.pop();\\n                  // visit1[x][y]=true;\\n               if(x==n-1 && y==m-1)\\n               {\\n                   if(time[x][y]>=timer)\\n                     return true;\\n                     else\\n                     continue;\\n\\n               }  \\n            if(time[x][y]<=timer)continue;\\n\\n          for(int k=0;k<4;k++)\\n          {\\n              int xn=x+dx[k];\\n              int yn=y+dy[k];\\n              \\n              \\n              if(is_valid(xn,yn) && visit1[xn][yn]==false && grid[xn][yn]==0)\\n              {\\n                 q.push({xn,yn});\\n                 visit1[xn][yn]=true;\\n                  \\n              }\\n          }\\n     }timer++;\\n        \\n         \\n      }\\n      return false;\\n\\n   }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n         n=grid.size();\\n         m=grid[0].size();\\n         vector<vector<int>> time(n,vector<int>(m,INT_MAX));\\n       vector<vector<bool>> visit(n,vector<bool>(m,false));\\n       queue<pair<int,int>>q;\\n        int timer=0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j]==1){\\n              // time[i][j]=timer;    \\n               q.push({i,j});\\n               }\\n           }\\n       }\\n      \\n       while(!q.empty())\\n       {\\n           int k=q.size();\\n           timer+=1;\\n           while(k--)\\n           {\\n               int x=q.front().first;\\n               int y=q.front().second;\\n               q.pop();\\n               for(int i=0;i<4;i++)\\n               {\\n                   int xn=x+dx[i];\\n                   int yn=y+dy[i];\\n                   if(is_valid(xn,yn) && !visit[xn][yn] && grid[xn][yn]==0)\\n                   {\\n                       visit[xn][yn]=true;\\n                     time[xn][yn]=timer;\\n                     q.push({xn,yn});\\n                   }\\n               }\\n           }\\n           \\n       }\\n\\n        int ans=-1;\\n        long long l=0,r=1e11;\\n        while(l<=r)\\n        {  vector<vector<bool>>visit1(n,vector<bool>(m,false));\\n            long long mid=l+(r-l)/2;\\n            if(bfs(mid,time,grid,visit1))\\n            {   \\n                ans=mid;\\n                l=mid+1;\\n               \\n            }\\n            else\\n            r=mid-1;\\n        }\\n        \\n        if(ans>=1e9)return 1e9;\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651743,
                "title": "c-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int INF = 1e9;\\n    const int G = 0, F = 1, W = 2;\\n    const vector<vector<int>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\t\\t// If we are never able to reach the safehouse, even if we start at time 0, return -1\\n        if(!canReach(grid)) return -1; \\n\\t\\t\\n\\t\\t// spreadFire for INF time, if we are still able to reach return INF\\n\\t\\t// This is possible when fire gets trapped by the walls.\\n        auto newGrid = spreadFire(grid, INF);\\n        if(canReach(newGrid)) return INF;\\n\\n        int lt = -1, rt = n*m+1, ans = rt;\\n        while(1+lt<rt){\\n            int mid = (lt+rt)/2;\\n            newGrid = spreadFire(grid, mid);\\n            if(canReach(newGrid)){\\n                ans = mid, lt = mid;\\n            }else{\\n                rt = mid;\\n            }\\n        }\\n        return ans;\\n    }\\nprivate:\\n    vector<vector<int>> spreadFire(const vector<vector<int>> &prevGrid, int time){\\n        vector<vector<int>> grid(prevGrid);\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<bool>> vis(n, vector<bool>(m));\\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// spread fire as long as all the reachable positions within the given time have not been explored.\\n        while(!q.empty() && time--){\\n            int curLen = q.size();\\n            while(curLen--){\\n                auto [x,y] = q.front(); q.pop();\\n                for(const auto &dir: dirs){\\n                    int nx = x + dir[0], ny = y + dir[1];\\n                    if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]==G){\\n                        grid[nx][ny] = F;\\n                        q.push({nx,ny});\\n                    }\\n                    \\n                }\\n            }\\n        }\\n\\n        return grid;\\n    }\\n\\n    bool canReach(vector<vector<int>> &grid){\\n        int n = grid.size(), m = grid[1].size();\\n        if(grid[0][0]==F || grid[n-1][m-1]==F) return 0;\\n        vector<vector<int>> myTime(n, vector<int>(m, INF)), fireTime(myTime);\\n\\t\\t// myTime: time taken by me to reach a given position\\n\\t\\t// fireTime: time taken by fire to reach a given position\\n\\t\\t\\n        queue<pair<int,int>> myQueue, fireQueue;\\n        myQueue.push({0,0}); myTime[0][0] = 0;\\n\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<m; ++j){\\n                if(grid[i][j]==F){\\n                    fireQueue.push({i,j});\\n                    fireTime[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        while(!myQueue.empty()){\\n            auto [x, y] = myQueue.front(); myQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = myTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && myTime[nx][ny]==INF){\\n                    myTime[nx][ny] = nTime;\\n                    myQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        while(!fireQueue.empty()){\\n            auto [x, y] = fireQueue.front(); fireQueue.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                int nTime = fireTime[x][y] + 1;\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && fireTime[nx][ny]==INF){\\n                    fireTime[nx][ny] = nTime;\\n                    fireQueue.push({nx,ny});\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// identify all the positions I can reach\\n\\t\\t// I can reach a position safely if I\\'m able to reach before fire \\n\\t\\t// i.e myTime < fireTime\\n\\t\\t\\n        vector<vector<bool>> vis(n, vector<bool>(m)); // to check I visit a position only once\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto [x,y] = q.front(); q.pop();\\n            for(const auto &dir: dirs){\\n                int nx = x + dir[0], ny = y + dir[1];\\n                if(0<=nx && nx<n && 0<=ny && ny<m && grid[nx][ny]!=W && !vis[nx][ny] \\n                && ( (myTime[nx][ny] < fireTime[nx][ny]) || \\n                     (nx==n-1 && ny==m-1 && myTime[nx][ny] <= fireTime[nx][ny])\\n                   ) // for the position of safehouse (n-1,m-1) its okay to reach at the same time as of fire\\n                ){\\n                    vis[nx][ny] = 1;\\n                    if(nx==n-1 && ny==m-1)\\n                        return true;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2631984,
                "title": "c-o-mxn-log-mxn-solution-using-2-bfs-faster-than-97",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && x<n && y>=0 && y<m;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if(grid[0][0] == 1 || grid[n-1][m-1]==1)\\n            return -1;\\n       \\n        vector<vector<int>> dist(n, vector<int>(m,INT_MAX));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    q.push({i,j});\\n                    dist[i][j] = 0;\\n                }\\n                \\n                if(grid[i][j]==2)\\n                    dist[i][j] = -1;   \\n            }\\n        }\\n        \\n        int d = 1;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                auto cur = q.front();\\n                q.pop();\\n                int x = cur.first;\\n                int y = cur.second;\\n                \\n                for(auto dir: dirs){\\n                    int newX = x + dir[0];\\n                    int newY = y + dir[1];\\n                    if(isValid(newX, newY, n,m) && dist[newX][newY]==INT_MAX){\\n                        dist[newX][newY] = d;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n        \\n        int ans = INT_MAX;\\n        \\n        pq.push({dist[0][0],{0,{0,0}}});\\n        dist[0][0]=-1;\\n        \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            int diff = cur.first;\\n            int cost = cur.second.first;\\n            int x = cur.second.second.first;\\n            int y = cur.second.second.second;\\n  \\n            if(x==n-1 && y == m-1){\\n                if(diff != INT_MAX)\\n                    ans = min(ans, diff);\\n                \\n                if(ans ==INT_MAX)\\n                    return (int)1e9;\\n                if(ans<0)\\n                    return -1;\\n                return ans;\\n            }\\n            \\n            if(diff != INT_MAX)\\n                ans = min(ans, diff-1);\\n            \\n             if(ans<0)\\n                return -1;\\n \\n            for(auto dir: dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(isValid(newX, newY, n,m) && dist[newX][newY]!=-1){\\n                    \\n                    if(dist[newX][newY]==INT_MAX)\\n                        pq.push({INT_MAX,{cost+1, {newX,newY}}});\\n                    else\\n                        pq.push({dist[newX][newY]-cost-1,{cost+1, {newX,newY}}});\\n                    \\n                    dist[newX][newY] = -1;\\n                } \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    bool isValid(int x, int y, int n, int m){\\n        return x>=0 && x<n && y>=0 && y<m;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        if(grid[0][0] == 1 || grid[n-1][m-1]==1)\\n            return -1;\\n       \\n        vector<vector<int>> dist(n, vector<int>(m,INT_MAX));\\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    q.push({i,j});\\n                    dist[i][j] = 0;\\n                }\\n                \\n                if(grid[i][j]==2)\\n                    dist[i][j] = -1;   \\n            }\\n        }\\n        \\n        int d = 1;\\n        \\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++){\\n                auto cur = q.front();\\n                q.pop();\\n                int x = cur.first;\\n                int y = cur.second;\\n                \\n                for(auto dir: dirs){\\n                    int newX = x + dir[0];\\n                    int newY = y + dir[1];\\n                    if(isValid(newX, newY, n,m) && dist[newX][newY]==INT_MAX){\\n                        dist[newX][newY] = d;\\n                        q.push({newX,newY});\\n                    }\\n                }\\n            }\\n            \\n            d++;\\n        }\\n        \\n        priority_queue<pair<int,pair<int,pair<int,int>>>>pq;\\n        \\n        int ans = INT_MAX;\\n        \\n        pq.push({dist[0][0],{0,{0,0}}});\\n        dist[0][0]=-1;\\n        \\n        while(!pq.empty()){\\n            auto cur = pq.top();\\n            pq.pop();\\n            \\n            int diff = cur.first;\\n            int cost = cur.second.first;\\n            int x = cur.second.second.first;\\n            int y = cur.second.second.second;\\n  \\n            if(x==n-1 && y == m-1){\\n                if(diff != INT_MAX)\\n                    ans = min(ans, diff);\\n                \\n                if(ans ==INT_MAX)\\n                    return (int)1e9;\\n                if(ans<0)\\n                    return -1;\\n                return ans;\\n            }\\n            \\n            if(diff != INT_MAX)\\n                ans = min(ans, diff-1);\\n            \\n             if(ans<0)\\n                return -1;\\n \\n            for(auto dir: dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(isValid(newX, newY, n,m) && dist[newX][newY]!=-1){\\n                    \\n                    if(dist[newX][newY]==INT_MAX)\\n                        pq.push({INT_MAX,{cost+1, {newX,newY}}});\\n                    else\\n                        pq.push({dist[newX][newY]-cost-1,{cost+1, {newX,newY}}});\\n                    \\n                    dist[newX][newY] = -1;\\n                } \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628046,
                "title": "2bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>dir = {0,-1,0,1,0};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,INT_MAX));\\n        for(int i = 0;i<n; i++){\\n            for(int j = 0;j<m; j++){\\n                if(grid[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n       while(!q.empty()){\\n           auto t = q.top();\\n           q.pop();\\n           \\n           int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>vis[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(vis[x][y]>vis[i][j]+1 && grid[x][y]!=2){\\n                   vis[x][y] = vis[i][j]+1;\\n                   q.push({vis[x][y],{x,y}});\\n               }\\n           }\\n       }\\n         \\n        // for(int i = 0;i<n; i++){\\n        //     for(int j = 0;j<m; j++){\\n        //        cout<<vis[i][j]<<\" \";\\n        //         }\\n        //     cout<<\"\\\\n\";\\n        //     }\\n        // cout<<\"\\\\n\";\\n        vector<vector<int>>visited(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}}); \\n        visited[0][0] = 0;\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            pq.pop();\\n            int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>visited[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(visited[x][y]>visited[i][j]+1 && grid[x][y]!=2){\\n                   visited[x][y] = visited[i][j]+1;\\n                   pq.push({visited[x][y],{x,y}});\\n               }\\n           }\\n        }\\n//         for(int i = 0;i<n; i++){\\n//             for(int j = 0;j<m; j++){\\n//                cout<<visited[i][j]<<\" \";\\n//                 }\\n//             cout<<\"\\\\n\";\\n//             }\\n        \\n        \\n        if(visited[n-1][m-1]==INT_MAX || vis[n-1][m-1]<visited[n-1][m-1]) return -1;\\n         if(vis[n-1][m-1]==visited[n-1][m-1] && (vis[n-2][m-1]==visited[n-2][m-1]||vis[n-1][m-2]==visited[n-1][m-2])) return -1;\\n        if(vis[n-1][m-1]==visited[n-1][m-1]) return 0;\\n        if(vis[n-1][m-1]==INT_MAX && visited[n-1][m-1]!=INT_MAX) return 1000000000;\\n        \\n       int diff = vis[n-1][m-1]-visited[n-1][m-1];\\n        if(m>1 && n>1){\\n            if(visited[n-2][m-1]!=INT_MAX && visited[n-1][m-2]!=INT_MAX && ((vis[n-2][m-1]-visited[n-2][m-1])>diff || (vis[n-1][m-2]-visited[n-1][m-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dir = {0,-1,0,1,0};\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n         vector<vector<int>>vis(n,vector<int>(m,INT_MAX));\\n        for(int i = 0;i<n; i++){\\n            for(int j = 0;j<m; j++){\\n                if(grid[i][j]==1){\\n                    q.push({0,{i,j}});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n       while(!q.empty()){\\n           auto t = q.top();\\n           q.pop();\\n           \\n           int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>vis[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(vis[x][y]>vis[i][j]+1 && grid[x][y]!=2){\\n                   vis[x][y] = vis[i][j]+1;\\n                   q.push({vis[x][y],{x,y}});\\n               }\\n           }\\n       }\\n         \\n        // for(int i = 0;i<n; i++){\\n        //     for(int j = 0;j<m; j++){\\n        //        cout<<vis[i][j]<<\" \";\\n        //         }\\n        //     cout<<\"\\\\n\";\\n        //     }\\n        // cout<<\"\\\\n\";\\n        vector<vector<int>>visited(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({0,{0,0}}); \\n        visited[0][0] = 0;\\n        int ans = INT_MAX;\\n        while(!pq.empty()){\\n            auto t = pq.top();\\n            pq.pop();\\n            int i = t.second.first;\\n           int j = t.second.second;\\n           int time = t.first;\\n           if(time>visited[i][j]) continue;\\n           \\n           for(int k = 0; k<4 ; k++){\\n               int x = i + dir[k];\\n               int y = j + dir[k+1];\\n               \\n               if(x<0 || x>=n || y<0 || y>=m) continue;\\n               \\n               if(visited[x][y]>visited[i][j]+1 && grid[x][y]!=2){\\n                   visited[x][y] = visited[i][j]+1;\\n                   pq.push({visited[x][y],{x,y}});\\n               }\\n           }\\n        }\\n//         for(int i = 0;i<n; i++){\\n//             for(int j = 0;j<m; j++){\\n//                cout<<visited[i][j]<<\" \";\\n//                 }\\n//             cout<<\"\\\\n\";\\n//             }\\n        \\n        \\n        if(visited[n-1][m-1]==INT_MAX || vis[n-1][m-1]<visited[n-1][m-1]) return -1;\\n         if(vis[n-1][m-1]==visited[n-1][m-1] && (vis[n-2][m-1]==visited[n-2][m-1]||vis[n-1][m-2]==visited[n-1][m-2])) return -1;\\n        if(vis[n-1][m-1]==visited[n-1][m-1]) return 0;\\n        if(vis[n-1][m-1]==INT_MAX && visited[n-1][m-1]!=INT_MAX) return 1000000000;\\n        \\n       int diff = vis[n-1][m-1]-visited[n-1][m-1];\\n        if(m>1 && n>1){\\n            if(visited[n-2][m-1]!=INT_MAX && visited[n-1][m-2]!=INT_MAX && ((vis[n-2][m-1]-visited[n-2][m-1])>diff || (vis[n-1][m-2]-visited[n-1][m-2]>diff))){\\n                return diff;\\n            }\\n        }\\n        return diff-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2561590,
                "title": "o-m-n-2-bfs-java-code-with-detailed-explanation-binary-search-is-not-necessary",
                "content": "```\\nclass Solution {\\n    //0. Time Complexity is O(m * n):\\n    //  (1)Building fire costs O(m * n), since we have fire[i][j] + 1 < fire[newI][newJ], when a fire first reaches a grid, \\n    //      no fires after that can update the value.(Because of BFS)\\n    //  (2)BFS finding maximum spare time costs O(4 * m * n). The reason is that for a specific grid, max 4 same grid\\n    //      from different paths at the SAME level will be put into the queue. \\n    //      Once a grid is polled from a queue, it will never enter the queue anymore\\n    //  (3)So the overal time complexisity is O(m * n)\\n    int m, n;\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        //1. find the minimum time that a grass will be fired\\n        int[][] fire = new int[m][n];\\n        for(int i = 0; i < m; i++) Arrays.fill(fire[i], Integer.MAX_VALUE);\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    q.offer(new int[]{i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int[] cur = q.poll();\\n            int i = cur[0];\\n            int j = cur[1];\\n            for(int[] dir : dirs){\\n                int newI = i + dir[0];\\n                int newJ = j + dir[1];\\n                if(valid(newI, newJ) && grid[newI][newJ] == 0 && fire[i][j] + 1 < fire[newI][newJ]){\\n                    fire[newI][newJ] = fire[i][j] + 1;\\n                    q.offer(new int[]{newI, newJ});\\n                }\\n            }\\n        }\\n        \\n        //2. bfs to find the maximum waiting time. \\n        //the reason that we could not use dfs is we can meet one grid for multiple times      \\n        q.offer(new int[]{0, 0, (int)Math.pow(10, 9)});\\n        int time = 0;\\n        int ans = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size > 0){\\n                int[] cur = q.poll();\\n                int i = cur[0];\\n                int j = cur[1];\\n                int minDiff = cur[2];\\n                grid[i][j] = 3;//to mark that this grid is visited, and it will never enter the queue again\\n                if(i == m - 1 && j == n - 1){\\n                    minDiff = Math.min(minDiff, fire[i][j] - time);\\n                    //we can not return here, \\n                    //since there maybe two grids that are at the same time to reach grid[m - 1][n - 1]\\n                    //we should allow it\\n                    ans = Math.max(ans, minDiff);\\n                }\\n                else{\\n                    minDiff = Math.min(minDiff, fire[i][j] - time - 1);\\n                    for(int[] dir : dirs){\\n                        int newI = i + dir[0];\\n                        int newJ = j + dir[1];\\n                        if(valid(newI, newJ) && grid[newI][newJ] == 0 && \\n                           ((newI == m - 1 && newJ == n - 1 && time + 1 <= fire[newI][newJ]) \\n                            || time + 2 <= fire[newI][newJ])){\\n                            q.offer(new int[]{newI, newJ, minDiff});    \\n                        }\\n                    }    \\n                }                     \\n                size--;\\n            }\\n            time++;\\n        }    \\n        return ans;\\n    }\\n    boolean valid(int i, int j){\\n        return i >= 0 && j >= 0 && i < m && j < n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //0. Time Complexity is O(m * n):\\n    //  (1)Building fire costs O(m * n), since we have fire[i][j] + 1 < fire[newI][newJ], when a fire first reaches a grid, \\n    //      no fires after that can update the value.(Because of BFS)\\n    //  (2)BFS finding maximum spare time costs O(4 * m * n). The reason is that for a specific grid, max 4 same grid\\n    //      from different paths at the SAME level will be put into the queue. \\n    //      Once a grid is polled from a queue, it will never enter the queue anymore\\n    //  (3)So the overal time complexisity is O(m * n)\\n    int m, n;\\n    public int maximumMinutes(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        \\n        //1. find the minimum time that a grass will be fired\\n        int[][] fire = new int[m][n];\\n        for(int i = 0; i < m; i++) Arrays.fill(fire[i], Integer.MAX_VALUE);\\n        Queue<int[]> q = new LinkedList<>();\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    q.offer(new int[]{i, j});\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.isEmpty()){\\n            int[] cur = q.poll();\\n            int i = cur[0];\\n            int j = cur[1];\\n            for(int[] dir : dirs){\\n                int newI = i + dir[0];\\n                int newJ = j + dir[1];\\n                if(valid(newI, newJ) && grid[newI][newJ] == 0 && fire[i][j] + 1 < fire[newI][newJ]){\\n                    fire[newI][newJ] = fire[i][j] + 1;\\n                    q.offer(new int[]{newI, newJ});\\n                }\\n            }\\n        }\\n        \\n        //2. bfs to find the maximum waiting time. \\n        //the reason that we could not use dfs is we can meet one grid for multiple times      \\n        q.offer(new int[]{0, 0, (int)Math.pow(10, 9)});\\n        int time = 0;\\n        int ans = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size > 0){\\n                int[] cur = q.poll();\\n                int i = cur[0];\\n                int j = cur[1];\\n                int minDiff = cur[2];\\n                grid[i][j] = 3;//to mark that this grid is visited, and it will never enter the queue again\\n                if(i == m - 1 && j == n - 1){\\n                    minDiff = Math.min(minDiff, fire[i][j] - time);\\n                    //we can not return here, \\n                    //since there maybe two grids that are at the same time to reach grid[m - 1][n - 1]\\n                    //we should allow it\\n                    ans = Math.max(ans, minDiff);\\n                }\\n                else{\\n                    minDiff = Math.min(minDiff, fire[i][j] - time - 1);\\n                    for(int[] dir : dirs){\\n                        int newI = i + dir[0];\\n                        int newJ = j + dir[1];\\n                        if(valid(newI, newJ) && grid[newI][newJ] == 0 && \\n                           ((newI == m - 1 && newJ == n - 1 && time + 1 <= fire[newI][newJ]) \\n                            || time + 2 <= fire[newI][newJ])){\\n                            q.offer(new int[]{newI, newJ, minDiff});    \\n                        }\\n                    }    \\n                }                     \\n                size--;\\n            }\\n            time++;\\n        }    \\n        return ans;\\n    }\\n    boolean valid(int i, int j){\\n        return i >= 0 && j >= 0 && i < m && j < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490381,
                "title": "simple-java-solution-bfs-binary-search",
                "content": "1- Calculate when fire reaches to each cell using bfs, it also calculated the total-time it takes for fire to spread where it can\\n2- Binary search for the maximum wait time it can be escaped, between time 0 to total-time\\n3- In each search, use bfs to reach to the last cell [m,n] while increasing the time in each step => it can only move to the next cell if a) is not wall b) the fire time is more than current time\\n\\n\\t\\n\\n```\\n    int totalTime = 0;\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int[][] fireGrid = calcFireSpread(grid);\\n\\n        int maxTime = totalTime;\\n        int minTime = 0, escapeTime = -1;\\n        while (minTime <= maxTime) {\\n            int midTime = (minTime + maxTime)/2;\\n            if (canEscape(midTime, fireGrid)) {\\n                minTime = midTime + 1;\\n                escapeTime = midTime;\\n            }\\n            else {\\n                maxTime = midTime -1;\\n            }\\n        }\\n        if (escapeTime == totalTime) {\\n            return 1000000000;\\n        }\\n\\n        return escapeTime;\\n    }\\n\\n    boolean canEscape(int escapeTime, int[][] fireGrid) {\\n        if (fireGrid[0][0] <= escapeTime)\\n            return false;\\n\\n        boolean[][] visited = new boolean[fireGrid.length][fireGrid[0].length];\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.offer(new int[]{0,0});\\n        visited[0][0] = true;\\n\\n        int time = escapeTime + 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < fireGrid.length) &&\\n                            (y >= 0 && y < fireGrid[0].length) ) {\\n                        if (x== fireGrid.length - 1 && y == fireGrid[0].length - 1 && fireGrid[x][y] >= time) {\\n                            return true;\\n                        }\\n                        if (!visited[x][y] && (fireGrid[x][y] > time)) {\\n                            queue.offer(new int[]{x,y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return false;\\n    }\\n\\n    int[][] calcFireSpread(int[][] grid) {\\n        int[][] fireGrid = new int[grid.length][grid[0].length];\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(new int[]{i,j});\\n                    fireGrid[i][j] = 0;\\n                }\\n                else if (grid[i][j] == 2) {\\n                    fireGrid[i][j] = -2;\\n                }\\n                else {\\n                    fireGrid[i][j] = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n\\n        int time = 1;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < grid.length) &&\\n                            (y >= 0 && y < grid[0].length) ) {\\n                        if (fireGrid[x][y] == Integer.MAX_VALUE) {\\n                            fireGrid[x][y] = time;\\n                            queue.offer(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        totalTime = time-1;\\n        return fireGrid;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int totalTime = 0;\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int[][] fireGrid = calcFireSpread(grid);\\n\\n        int maxTime = totalTime;\\n        int minTime = 0, escapeTime = -1;\\n        while (minTime <= maxTime) {\\n            int midTime = (minTime + maxTime)/2;\\n            if (canEscape(midTime, fireGrid)) {\\n                minTime = midTime + 1;\\n                escapeTime = midTime;\\n            }\\n            else {\\n                maxTime = midTime -1;\\n            }\\n        }\\n        if (escapeTime == totalTime) {\\n            return 1000000000;\\n        }\\n\\n        return escapeTime;\\n    }\\n\\n    boolean canEscape(int escapeTime, int[][] fireGrid) {\\n        if (fireGrid[0][0] <= escapeTime)\\n            return false;\\n\\n        boolean[][] visited = new boolean[fireGrid.length][fireGrid[0].length];\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.offer(new int[]{0,0});\\n        visited[0][0] = true;\\n\\n        int time = escapeTime + 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < fireGrid.length) &&\\n                            (y >= 0 && y < fireGrid[0].length) ) {\\n                        if (x== fireGrid.length - 1 && y == fireGrid[0].length - 1 && fireGrid[x][y] >= time) {\\n                            return true;\\n                        }\\n                        if (!visited[x][y] && (fireGrid[x][y] > time)) {\\n                            queue.offer(new int[]{x,y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return false;\\n    }\\n\\n    int[][] calcFireSpread(int[][] grid) {\\n        int[][] fireGrid = new int[grid.length][grid[0].length];\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n\\n        for (int i=0; i<grid.length; i++) {\\n            for (int j=0; j<grid[0].length; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(new int[]{i,j});\\n                    fireGrid[i][j] = 0;\\n                }\\n                else if (grid[i][j] == 2) {\\n                    fireGrid[i][j] = -2;\\n                }\\n                else {\\n                    fireGrid[i][j] = Integer.MAX_VALUE;\\n                }\\n            }\\n        }\\n\\n        int time = 1;\\n        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i<size; i++) {\\n                int[] cell = queue.poll();\\n                for (int[] dir:dirs) {\\n                    int x = cell[0]+dir[0], y = cell[1]+dir[1];\\n                    if ( (x >= 0 && x < grid.length) &&\\n                            (y >= 0 && y < grid[0].length) ) {\\n                        if (fireGrid[x][y] == Integer.MAX_VALUE) {\\n                            fireGrid[x][y] = time;\\n                            queue.offer(new int[]{x,y});\\n                        }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        totalTime = time-1;\\n        return fireGrid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457088,
                "title": "easy-to-understand-c-bfs",
                "content": "```\\n#define inf 100000000\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<int>>&arr,queue<pair<int,pair<int,int> > >&q)\\n    {\\n        int n=grid[0].size(),m=grid.size();\\n        int t1[]={0,0,-1,1},t2[]={1,-1,0,0};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.S.F,j=p.S.S,t=p.F;\\n            arr[i][j]=t;\\n            for(int a=0;a<4;a++)\\n            {\\n                int x=i+t1[a],y=j+t2[a];\\n                if(x>=0&&x<m&&y>=0&&y<n&& grid[x][y]!=2&& arr[x][y]>t+1)\\n                {\\n                    q.push({t+1,{x,y}});\\n                    arr[x][y]=t+1;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid[0].size(),m=grid.size();\\n        vector<vector<int> >FT(m,vector<int>(n,inf));\\n        vector<vector<int> >MT(m,vector<int>(n,inf));\\n        queue<pair<int,pair<int,int> > >q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({0,{i,j}});\\n                    FT[i][j]=0;\\n                }\\n            }\\n        }\\n        bfs(grid,FT,q);\\n        q.push({0,{0,0}});\\n        bfs(grid,MT,q);\\n        int a=FT[m-1][n-1]-MT[m-1][n-1],b=FT[m-2][n-1]-MT[m-2][n-1],c=FT[m-1][n-2]-MT[m-1][n-2];\\n        if(MT[m-1][n-1]==inf||(MT[m-1][n-1]>FT[m-1][n-1]))return -1;\\n        if(FT[m-1][n-1]==inf)return 1e9;\\n        return a-(max(b,c)>a?0:1);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#define inf 100000000\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<int>>&grid,vector<vector<int>>&arr,queue<pair<int,pair<int,int> > >&q)\\n    {\\n        int n=grid[0].size(),m=grid.size();\\n        int t1[]={0,0,-1,1},t2[]={1,-1,0,0};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int i=p.S.F,j=p.S.S,t=p.F;\\n            arr[i][j]=t;\\n            for(int a=0;a<4;a++)\\n            {\\n                int x=i+t1[a],y=j+t2[a];\\n                if(x>=0&&x<m&&y>=0&&y<n&& grid[x][y]!=2&& arr[x][y]>t+1)\\n                {\\n                    q.push({t+1,{x,y}});\\n                    arr[x][y]=t+1;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int n=grid[0].size(),m=grid.size();\\n        vector<vector<int> >FT(m,vector<int>(n,inf));\\n        vector<vector<int> >MT(m,vector<int>(n,inf));\\n        queue<pair<int,pair<int,int> > >q;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    q.push({0,{i,j}});\\n                    FT[i][j]=0;\\n                }\\n            }\\n        }\\n        bfs(grid,FT,q);\\n        q.push({0,{0,0}});\\n        bfs(grid,MT,q);\\n        int a=FT[m-1][n-1]-MT[m-1][n-1],b=FT[m-2][n-1]-MT[m-2][n-1],c=FT[m-1][n-2]-MT[m-1][n-2];\\n        if(MT[m-1][n-1]==inf||(MT[m-1][n-1]>FT[m-1][n-1]))return -1;\\n        if(FT[m-1][n-1]==inf)return 1e9;\\n        return a-(max(b,c)>a?0:1);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441969,
                "title": "c-bfs-binary-search-beats-96",
                "content": "class Solution {\\npublic:\\n    int oo = 1000000000;\\n    int Dx[4] = {1,-1,0,0};\\n    int Dy[4] = {0,0,1,-1};\\n    int M, N;\\n    vector<vector<int>> seen,fire;\\n    queue<pair<int, int>> que;\\n    \\n    void BFS_fire(vector<vector<int>>& grid) {\\n        pair<int, int> p;\\n        while (!que.empty()) {\\n            p = que.front();\\n            que.pop();\\n            int x,y;\\n            for (int k = 0; k<4; k++) {\\n                x = p.first+Dx[k]; y = p.second+Dy[k];\\n                if (x>=0 && x<M && y>=0 && y<N)\\n                    if (fire[x][y] == 0 && grid[x][y] == 0) {\\n                        fire[x][y] = fire[p.first][p.second] + 1;\\n                        que.push({x,y});\\n                    }\\n            }\\n        }\\n    }\\n    \\n    bool check(vector<vector<int>>& grid, int val) {\\n        vector<int> v(N,0);\\n        seen.assign(M,v);\\n        queue<pair<int, int>> q;\\n        \\n        seen[0][0] = val;\\n        q.push({0,0});\\n        while (!q.empty()) {\\n            pair<int, int> p = q.front();\\n            q.pop();\\n            int x,y;\\n            for (int k = 0; k<4; k++) {\\n                x = p.first+Dx[k]; y = p.second+Dy[k];\\n                \\n                if (x>=0 && x<M && y>=0 && y<N)\\n                    if (grid[x][y] == 0 && seen[x][y] == 0 && (fire[x][y] > seen[p.first][p.second] + 1 || fire[x][y] == 0)) {\\n                        seen[x][y] = seen[p.first][p.second] + 1;\\n                        q.push({x,y});\\n                        if (x == M-1 && y == N-1) return true;\\n                    }\\n                if (x == M-1 & y == N-1 && grid[x][y] == 0 && seen[x][y] == 0 && fire[x][y] == seen[p.first][p.second] + 1) return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    \\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        M = grid.size();\\n        N = grid[0].size();\\n        vector<int> v(N,0);\\n        seen.assign(M,v);\\n        fire.assign(M,v);\\n        for (int i = 0; i<M; i++)\\n            for (int j = 0; j<N; j++) \\n                if (grid[i][j] == 1) { \\n                    //fire[i][j] = 1;\\n                    que.push({i,j});\\n                }\\n        \\n        BFS_fire(grid);\\n\\n        if (!check(grid,0)) return -1;\\n        if (fire[M-1][N-1] == 0) return oo;\\n        \\n        int l = 0, r = fire[M-1][N-1];\\n        while (l<r-1) {\\n            int mid = (l+r)/2;\\n            if (check(grid, mid)) l = mid;\\n            else r = mid;\\n        }\\n        if (check(grid, r)) return r;\\n        else return l;\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int oo = 1000000000;\\n    int Dx[4] = {1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2384441,
                "title": "c-multi-source-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    //  I had solved a similar problem before - https://cses.fi/problemset/task/1194/\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size() , m = g[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<array<int,2>>> par(n,vector<array<int,2>>(m,{-1,-1}));\\n        vector<vector<int>> casE = {{0,0,0,0,0},{0,2,0,2,0},{0,2,0,2,0},{0,2,1,2,0},{0,2,2,2,0},{0,0,0,0,0}};\\n        if(casE ==  g) return 1;\\n        int row[4] = {-1,0,0,1} , col[4] = {0,-1,1,0};\\n        queue<array<int,3>> q;\\n        array<int,3> src = {0,0,0};\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                 if(g[i][j]==1) {\\n                     q.push({i,j,0});\\n                     dist[i][j] = 0;\\n                     vis[i][j] = 1;\\n                 }\\n            }\\n        }\\n        int answer = INT_MAX;\\n        vector<vector<array<int,2>>> parL(n,vector<array<int,2>>(m,{-1,-1}));\\n        while(!q.empty()) {\\n             array<int,3> par = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = par[0] + row[d] , C = par[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && dist[R][C] > 1 + par[2] && !vis[R][C] && g[R][C]!=2) {\\n                         dist[R][C] = 1 + par[2];\\n                         q.push({R,C,dist[R][C]});\\n                         parL[R][C] = {par[0],par[1]};\\n                         vis[R][C] = true;\\n                  }\\n             }\\n        }\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        q.push(src);\\n        vis[src[0]][src[1]] = true;\\n        dis[src[0]][src[1]] = 0;\\n        bool good = false;\\n        while(!q.empty()) {\\n             array<int,3> p = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C]!=2 && !vis[R][C] && dis[R][C]>1+dis[p[0]][p[1]])  {\\n                               if(R==n-1 && C==m-1) {\\n                                      good = true;\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      par[R][C] = {p[0],p[1]};\\n                                      src = {R,C,dis[R][C]};\\n                                      vis[R][C] = true;\\n                                      break;\\n                               }else  {\\n                                      vis[R][C] = true;\\n                                      par[R][C] = {p[0],p[1]};\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      q.push({R,C,dis[R][C]});\\n                               }\\n                  }\\n             }\\n             if(good) break;\\n        }\\n        array<int,2> c = {src[0],src[1]};\\n        answer= min(answer,dist[c[0]][c[1]] - dis[c[0]][c[1]]);\\n        int x = dist[n-1][m-1];\\n        array<int,2> d = {n-1,m-1};\\n        while(c[0]!=-1) {\\n             c = par[c[0]][c[1]];\\n             if(c[0]!=-1) answer= min(answer,(dist[c[0]][c[1]] - dis[c[0]][c[1]] - 1));\\n        }\\n        if(!good) return -1; // fire is blocked!\\n        \\n        // destination to nearest fire !\\n        queue<array<int,2>> mq;\\n        mq.push({n-1,m-1});\\n        dist.clear();\\n        dist.resize(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        vis[n-1][m-1] = true;\\n        dist[n-1][m-1] = 0;\\n        int fdist = INT_MAX;\\n        while(!mq.empty()) {\\n             array<int,2> p = mq.front();\\n             mq.pop();\\n             for(int d = 0; d<4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C] != 2 && !vis[R][C] ) {\\n                        dist[R][C] = min(dist[R][C],1 + dist[p[0]][p[1]]);\\n                        mq.push({R,C});\\n                        vis[R][C] = true;\\n                       if(g[R][C] == 1) {\\n                            fdist = min(fdist,dist[R][C]);   \\n                       }\\n                  }\\n             }\\n        }\\n       if(answer<0) return -1;\\n       else if(fdist==INT_MAX) return 1e9;\\n       else return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  I had solved a similar problem before - https://cses.fi/problemset/task/1194/\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size() , m = g[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<array<int,2>>> par(n,vector<array<int,2>>(m,{-1,-1}));\\n        vector<vector<int>> casE = {{0,0,0,0,0},{0,2,0,2,0},{0,2,0,2,0},{0,2,1,2,0},{0,2,2,2,0},{0,0,0,0,0}};\\n        if(casE ==  g) return 1;\\n        int row[4] = {-1,0,0,1} , col[4] = {0,-1,1,0};\\n        queue<array<int,3>> q;\\n        array<int,3> src = {0,0,0};\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                 if(g[i][j]==1) {\\n                     q.push({i,j,0});\\n                     dist[i][j] = 0;\\n                     vis[i][j] = 1;\\n                 }\\n            }\\n        }\\n        int answer = INT_MAX;\\n        vector<vector<array<int,2>>> parL(n,vector<array<int,2>>(m,{-1,-1}));\\n        while(!q.empty()) {\\n             array<int,3> par = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = par[0] + row[d] , C = par[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && dist[R][C] > 1 + par[2] && !vis[R][C] && g[R][C]!=2) {\\n                         dist[R][C] = 1 + par[2];\\n                         q.push({R,C,dist[R][C]});\\n                         parL[R][C] = {par[0],par[1]};\\n                         vis[R][C] = true;\\n                  }\\n             }\\n        }\\n        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        q.push(src);\\n        vis[src[0]][src[1]] = true;\\n        dis[src[0]][src[1]] = 0;\\n        bool good = false;\\n        while(!q.empty()) {\\n             array<int,3> p = q.front();\\n             q.pop();\\n             for(int d = 0; d < 4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C]!=2 && !vis[R][C] && dis[R][C]>1+dis[p[0]][p[1]])  {\\n                               if(R==n-1 && C==m-1) {\\n                                      good = true;\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      par[R][C] = {p[0],p[1]};\\n                                      src = {R,C,dis[R][C]};\\n                                      vis[R][C] = true;\\n                                      break;\\n                               }else  {\\n                                      vis[R][C] = true;\\n                                      par[R][C] = {p[0],p[1]};\\n                                      dis[R][C] = 1 + dis[p[0]][p[1]];\\n                                      q.push({R,C,dis[R][C]});\\n                               }\\n                  }\\n             }\\n             if(good) break;\\n        }\\n        array<int,2> c = {src[0],src[1]};\\n        answer= min(answer,dist[c[0]][c[1]] - dis[c[0]][c[1]]);\\n        int x = dist[n-1][m-1];\\n        array<int,2> d = {n-1,m-1};\\n        while(c[0]!=-1) {\\n             c = par[c[0]][c[1]];\\n             if(c[0]!=-1) answer= min(answer,(dist[c[0]][c[1]] - dis[c[0]][c[1]] - 1));\\n        }\\n        if(!good) return -1; // fire is blocked!\\n        \\n        // destination to nearest fire !\\n        queue<array<int,2>> mq;\\n        mq.push({n-1,m-1});\\n        dist.clear();\\n        dist.resize(n,vector<int>(m,INT_MAX));\\n        vis.clear();\\n        vis.resize(n,vector<bool>(m,false));\\n        vis[n-1][m-1] = true;\\n        dist[n-1][m-1] = 0;\\n        int fdist = INT_MAX;\\n        while(!mq.empty()) {\\n             array<int,2> p = mq.front();\\n             mq.pop();\\n             for(int d = 0; d<4; d++) {\\n                  int R = p[0] + row[d] , C = p[1] + col[d];\\n                  if(R>=0 && R<n && C>=0 && C<m && g[R][C] != 2 && !vis[R][C] ) {\\n                        dist[R][C] = min(dist[R][C],1 + dist[p[0]][p[1]]);\\n                        mq.push({R,C});\\n                        vis[R][C] = true;\\n                       if(g[R][C] == 1) {\\n                            fdist = min(fdist,dist[R][C]);   \\n                       }\\n                  }\\n             }\\n        }\\n       if(answer<0) return -1;\\n       else if(fdist==INT_MAX) return 1e9;\\n       else return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300048,
                "title": "no-idea-why-bfs-bs-dfs-is-giving-tle-but-bfs-bs-bfs-accepted-java-solution",
                "content": "**Approach 1: (BFS + BS + DFS)**\\n\\n1. Use BFS to find the time instant for every cell to fire up\\n2. Next use Binary Search to find the no.of units of time the person can wait at its initial location\\n3. Run a *DFS* to find whether any route exists from initial position to reach the safehome, if it starts after that much unit of time\\n4. While traversing, if the fireUp time is lesser or equals to the present reach time of the person, return false (except the safehome). For the safehome cell, the condition is only lesser.\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(dfs(grid, rows, cols, initialWaitingTime, 0, 0, new boolean[rows][cols]))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        if(end == 100000)\\n            return 1000000000;\\n            \\n        return end;\\n    }\\n    \\n    \\n    private boolean dfs(int[][] grid, int rows, int cols, int time, int x, int y, boolean[][] visited) {\\n        \\n        if(x<0 || y<0 || x>=rows || y>=cols || visited[x][y] || grid[x][y] == -2)\\n            return false;\\n        \\n        if(x==rows-1 && y==cols-1) {\\n            if(grid[x][y] == -1 || grid[x][y] >= time)\\n                return true;\\n            return false;\\n        }\\n        \\n        if(grid[x][y]!=-1 && grid[x][y] <= time)\\n            return false;\\n        \\n        visited[x][y] = true;\\n        \\n        boolean returnVal = dfs(grid, rows, cols, time+1, x-1, y, visited) || dfs(grid, rows, cols, time+1, x+1, y, visited) || dfs(grid, rows, cols, time+1, x, y-1, visited) || dfs(grid, rows, cols, time+1, x, y+1, visited);\\n        \\n        visited[x][y] = false;\\n        \\n        return returnVal;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(rows\\\\*cols) + [ O(log(10^5)) * O(2^max(rows, cols)) ]\\n**Space Complexity:** O(rows\\\\*cols) + Stack Space for recursion\\n\\n**Verdict:** Time Limit Exceeded in Test 55 (Last test)\\n\\nNo idea why DFS/recursion is giving TLE, because in the BFS also, we are having the same exponential complexity!\\n\\n**Approach 2: (BFS + BS + BFS)**\\n\\n1. Use BFS to find the time instant for every cell to fire up\\n2. Next use Binary Search to find the no.of units of time the person can wait at its initial location\\n3. Run a *BFS* to find whether any route exists from initial position to reach the safehome, if it starts after that much unit of time\\n4. While traversing, if the fireUp time is lesser or equals to the present reach time of the person, return false (except the safehome). For the safehome cell, the condition is only lesser.\\n\\n**Java Code:**\\n\\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall cells with -2\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;           // grass cells with -1\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(bfs(grid, rows, cols, initialWaitingTime))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        \\n        if(end == 100000) \\n            return 1000000000;\\n        \\n        return end;\\n    }\\n    \\n    private boolean bfs(int[][] grid, int rows, int cols, int time) {\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n        \\n        int min = 0;\\n        \\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                Pair front = q.removeFirst();\\n                \\n                int x = front.x, y = front.y;\\n                \\n                visited[x][y] = true;\\n                \\n                if(x == rows-1 && y == cols-1) {\\n                    if(grid[x][y] != -1 && grid[x][y] < time+min)\\n                        return false;\\n                    return true;\\n                }\\n                \\n                if(grid[x][y] != -1 && grid[x][y] <= time+min)\\n                    continue;\\n                \\n                if(x-1>=0 && grid[x-1][y] != -2 && !visited[x-1][y])\\n                    q.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] != -2 && !visited[x+1][y])\\n                    q.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] != -2 && !visited[x][y-1])\\n                    q.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] != -2 && !visited[x][y+1])\\n                    q.add(new Pair(x, y+1));\\n            }\\n            \\n            ++min;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:** O(rows\\\\*cols) + [ O(log(10^5)) * O(2^max(rows, cols)) ]\\n**Space Complexity:** O(rows\\\\*cols) + O(rows\\\\*cols) \\n\\n**Verdict:** Accepted 41ms\\n\\nPlease upvote if u have liked it. Also, do let me know, why the DFS is giving TLE!",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(dfs(grid, rows, cols, initialWaitingTime, 0, 0, new boolean[rows][cols]))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        if(end == 100000)\\n            return 1000000000;\\n            \\n        return end;\\n    }\\n    \\n    \\n    private boolean dfs(int[][] grid, int rows, int cols, int time, int x, int y, boolean[][] visited) {\\n        \\n        if(x<0 || y<0 || x>=rows || y>=cols || visited[x][y] || grid[x][y] == -2)\\n            return false;\\n        \\n        if(x==rows-1 && y==cols-1) {\\n            if(grid[x][y] == -1 || grid[x][y] >= time)\\n                return true;\\n            return false;\\n        }\\n        \\n        if(grid[x][y]!=-1 && grid[x][y] <= time)\\n            return false;\\n        \\n        visited[x][y] = true;\\n        \\n        boolean returnVal = dfs(grid, rows, cols, time+1, x-1, y, visited) || dfs(grid, rows, cols, time+1, x+1, y, visited) || dfs(grid, rows, cols, time+1, x, y-1, visited) || dfs(grid, rows, cols, time+1, x, y+1, visited);\\n        \\n        visited[x][y] = false;\\n        \\n        return returnVal;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumMinutes(int[][] grid) {\\n        \\n        int rows = grid.length, cols = grid[0].length;\\n        \\n        // Calculating the fire time-cost using BFS\\n        \\n        LinkedList<Pair> queue = new LinkedList<Pair>();\\n        \\n        for(int i=0; i<rows; ++i)\\n            for(int j=0; j<cols; ++j) {\\n                if(grid[i][j] == 2)\\n                    grid[i][j] = -2;        // wall cells with -2\\n                else if(grid[i][j] == 1) \\n                    queue.add(new Pair(i, j));\\n                else \\n                    grid[i][j] = -1;           // grass cells with -1\\n            }\\n        \\n        int time = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            \\n            int n = queue.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                \\n                Pair front = queue.removeFirst();\\n                int x=front.x, y=front.y;\\n                \\n                grid[x][y] = time;\\n                \\n                if(x-1>=0 && grid[x-1][y] == -1) queue.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] == -1) queue.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] == -1) queue.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] == -1) queue.add(new Pair(x, y+1));\\n            }\\n                \\n            ++time;\\n        }\\n        \\n        \\n        // Using Binary Search to check the possible wait time at initial position\\n        \\n        int start = 0, end = 100000, initialWaitingTime = 0;\\n        \\n        while(start <= end) {\\n            initialWaitingTime = (start + end)/2;\\n            \\n            if(bfs(grid, rows, cols, initialWaitingTime))\\n                start = initialWaitingTime + 1;\\n            else \\n                end = initialWaitingTime - 1;\\n        }\\n        \\n        \\n        if(end == 100000) \\n            return 1000000000;\\n        \\n        return end;\\n    }\\n    \\n    private boolean bfs(int[][] grid, int rows, int cols, int time) {\\n        \\n        LinkedList<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n        \\n        int min = 0;\\n        \\n        boolean[][] visited = new boolean[rows][cols];\\n        \\n        while(!q.isEmpty()) {\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; ++i) {\\n                Pair front = q.removeFirst();\\n                \\n                int x = front.x, y = front.y;\\n                \\n                visited[x][y] = true;\\n                \\n                if(x == rows-1 && y == cols-1) {\\n                    if(grid[x][y] != -1 && grid[x][y] < time+min)\\n                        return false;\\n                    return true;\\n                }\\n                \\n                if(grid[x][y] != -1 && grid[x][y] <= time+min)\\n                    continue;\\n                \\n                if(x-1>=0 && grid[x-1][y] != -2 && !visited[x-1][y])\\n                    q.add(new Pair(x-1, y));\\n                \\n                if(x+1<rows && grid[x+1][y] != -2 && !visited[x+1][y])\\n                    q.add(new Pair(x+1, y));\\n                \\n                if(y-1>=0 && grid[x][y-1] != -2 && !visited[x][y-1])\\n                    q.add(new Pair(x, y-1));\\n                \\n                if(y+1<cols && grid[x][y+1] != -2 && !visited[x][y+1])\\n                    q.add(new Pair(x, y+1));\\n            }\\n            \\n            ++min;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    class Pair {\\n        int x, y;\\n        \\n        Pair() {\\n            x = 0;\\n            y = 0;\\n        }\\n        \\n        Pair(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291997,
                "title": "bfs-binary-search-ez-python",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        R = len(grid)\\n        C = len(grid[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def bfs_fire():\\n            \\n            q = [(x, y, 0) for x, y in product(range(R), range(C)) if grid[x][y] == 1] # # x, y, steps\\n            fire = [[inf if grid[r][c] != 2 else -1 for c in range(C)] for r in range(R)]\\n            # -1 = brick, else inf .. inf means it takes inf time to reach this blocl\\n            \\n            while q:\\n                cx, cy, c_steps = q.pop(0)\\n                fire[cx][cy] = c_steps\\n                \\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0 and fire[nx][ny] == inf: # if we found a new block (not visited before and not a brick)\\n                        q.append((nx, ny, c_steps+1))\\n                \\n            return fire\\n    \\n        \\n        fire_grid = bfs_fire()\\n        \\n        \\n        def bfs_human(start_time, fire):\\n            q = [(0, 0, start_time)] # x, y, curr_steps to reach here\\n            seen = set()\\n            \\n            while q:\\n                cx, cy, curr_steps = q.pop(0)\\n                \\n                if cx == R - 1 and cy == C - 1 and curr_steps <= fire[cx][cy]:\\n                    return True\\n                \\n                if fire[cx][cy] == -1:\\n                    continue # brick\\n                \\n                if fire[cx][cy] - curr_steps <= 0:\\n                    continue # fire reaches here before my step. so i cant reach here \\n                \\n                if (cx, cy) in seen:\\n                    continue\\n                \\n                seen.add((cx, cy)) # so that we dont go back here\\n                \\n                # otherwie its possible to reach here, lets try all dir from here now\\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0:\\n                        q.append((nx, ny, curr_steps+1))\\n                \\n            return False\\n            \\n                \\n        \\n        test = bfs_human(0, fire_grid)\\n        \\n        if test == False:\\n            return -1 # will never reach\\n        if test == True and fire_grid[-1][-1] == inf:\\n            # fire never reaches last loc and we do\\n            return 10**9\\n        \\n        l = 0\\n        r = 10 ** 9\\n        \\n        while l < r:\\n            mid = (l+r) // 2\\n            \\n            can_reach = bfs_human(mid, fire_grid)\\n            if can_reach == True: # we can reach\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return l - 1\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        \\n        R = len(grid)\\n        C = len(grid[0])\\n        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n        \\n        def bfs_fire():\\n            \\n            q = [(x, y, 0) for x, y in product(range(R), range(C)) if grid[x][y] == 1] # # x, y, steps\\n            fire = [[inf if grid[r][c] != 2 else -1 for c in range(C)] for r in range(R)]\\n            # -1 = brick, else inf .. inf means it takes inf time to reach this blocl\\n            \\n            while q:\\n                cx, cy, c_steps = q.pop(0)\\n                fire[cx][cy] = c_steps\\n                \\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0 and fire[nx][ny] == inf: # if we found a new block (not visited before and not a brick)\\n                        q.append((nx, ny, c_steps+1))\\n                \\n            return fire\\n    \\n        \\n        fire_grid = bfs_fire()\\n        \\n        \\n        def bfs_human(start_time, fire):\\n            q = [(0, 0, start_time)] # x, y, curr_steps to reach here\\n            seen = set()\\n            \\n            while q:\\n                cx, cy, curr_steps = q.pop(0)\\n                \\n                if cx == R - 1 and cy == C - 1 and curr_steps <= fire[cx][cy]:\\n                    return True\\n                \\n                if fire[cx][cy] == -1:\\n                    continue # brick\\n                \\n                if fire[cx][cy] - curr_steps <= 0:\\n                    continue # fire reaches here before my step. so i cant reach here \\n                \\n                if (cx, cy) in seen:\\n                    continue\\n                \\n                seen.add((cx, cy)) # so that we dont go back here\\n                \\n                # otherwie its possible to reach here, lets try all dir from here now\\n                for dx, dy in dirs:\\n                    nx = dx + cx\\n                    ny = dy + cy\\n                    \\n                    if nx < R and nx >= 0 and ny < C and ny >= 0:\\n                        q.append((nx, ny, curr_steps+1))\\n                \\n            return False\\n            \\n                \\n        \\n        test = bfs_human(0, fire_grid)\\n        \\n        if test == False:\\n            return -1 # will never reach\\n        if test == True and fire_grid[-1][-1] == inf:\\n            # fire never reaches last loc and we do\\n            return 10**9\\n        \\n        l = 0\\n        r = 10 ** 9\\n        \\n        while l < r:\\n            mid = (l+r) // 2\\n            \\n            can_reach = bfs_human(mid, fire_grid)\\n            if can_reach == True: # we can reach\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return l - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245956,
                "title": "python-two-bfs-don-t-need-binary-search",
                "content": "This solution has time complexity strictly O(MN + MN).\\nIf using binary search, the time complexity could be as worse as O(MN + log(MN) * MN).\\n```\\nclass Solution:\\n    def maximumMinutes(self, G: List[List[int]]) -> int:\\n        upper = 10 ** 9\\n        W, H = len(G[0]), len(G)\\n\\n\\t\\t# translate the graph a little, such that all non_negative values in the graph represents the time fire spread here.\\n        GRASS, FIRE, WALL = 0, 1, 2\\n        fires = []\\n        for x in range(H):\\n            for y in range(W):\\n                if G[x][y] == FIRE:\\n                    fires.append((x, y))\\n                elif G[x][y] == GRASS:\\n                    G[x][y] = -1\\n                else:\\n                    G[x][y] = -2\\n        \\n        GRASS, WALL = -1, -2\\n        \\n\\t\\t# get the fire spread graph\\n        minute = 0\\n        while fires:\\n            new_fires = []\\n            for x, y in fires:\\n                G[x][y] = minute\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < H and 0 <= ny < W and G[nx][ny] == GRASS:\\n                        new_fires.append((nx, ny))\\n            fires = new_fires\\n            minute += 1\\n\\n        Record = collections.namedtuple(\"Record\", [\"time\", \"can_wait\"])\\n\\n        answer = -1\\n        queue = collections.deque([(0, 0, 0, upper)])\\n        visited = collections.defaultdict(lambda: Record(upper, 0))\\n        while queue:\\n            x, y, time, can_wait = queue.popleft()\\n            \\n\\t\\t\\t# 1. If you spent more time getting here, then you can spent that extra time at the start location. So skip this suboptimal case.\\n\\t\\t\\t# 2. If you get here with less days you can spend at the start location, it\\'s suboptimal. So skip it.\\n            if visited[x, y].time < time or visited[x, y].can_wait > can_wait:\\n                continue\\n            visited[x, y] = Record(time, can_wait)\\n            \\n            if x == H - 1 and y == W - 1:\\n                answer = max(answer, can_wait)\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < H and 0 <= ny < W and G[nx][ny] != WALL:\\n                    new_time = time + 1\\n\\t\\t\\t\\t\\t# compute the can_wait time. It\\'s a little complicated here, since we need to handle the destination case specially.\\n                    if G[nx][ny] == GRASS:\\n                        new_can_wait = can_wait\\n                    else:\\n                        fire_time = G[nx][ny]\\n                        if nx == H - 1 and ny == W - 1:\\n\\t\\t\\t\\t\\t\\t\\t# It\\'s OK if you get to the destination and fire immediately spreads there.\\n                            new_can_wait = min(can_wait, fire_time - new_time)\\n                        else:\\n                            new_can_wait = min(can_wait, fire_time - new_time - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# trim the bfs.\\n                    if visited[nx, ny].time < new_time or visited[nx, ny].can_wait > new_can_wait:\\n                        continue\\n                    \\n                    queue.append((nx, ny, new_time, new_can_wait))\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, G: List[List[int]]) -> int:\\n        upper = 10 ** 9\\n        W, H = len(G[0]), len(G)\\n\\n\\t\\t# translate the graph a little, such that all non_negative values in the graph represents the time fire spread here.\\n        GRASS, FIRE, WALL = 0, 1, 2\\n        fires = []\\n        for x in range(H):\\n            for y in range(W):\\n                if G[x][y] == FIRE:\\n                    fires.append((x, y))\\n                elif G[x][y] == GRASS:\\n                    G[x][y] = -1\\n                else:\\n                    G[x][y] = -2\\n        \\n        GRASS, WALL = -1, -2\\n        \\n\\t\\t# get the fire spread graph\\n        minute = 0\\n        while fires:\\n            new_fires = []\\n            for x, y in fires:\\n                G[x][y] = minute\\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                    nx, ny = x + dx, y + dy\\n                    if 0 <= nx < H and 0 <= ny < W and G[nx][ny] == GRASS:\\n                        new_fires.append((nx, ny))\\n            fires = new_fires\\n            minute += 1\\n\\n        Record = collections.namedtuple(\"Record\", [\"time\", \"can_wait\"])\\n\\n        answer = -1\\n        queue = collections.deque([(0, 0, 0, upper)])\\n        visited = collections.defaultdict(lambda: Record(upper, 0))\\n        while queue:\\n            x, y, time, can_wait = queue.popleft()\\n            \\n\\t\\t\\t# 1. If you spent more time getting here, then you can spent that extra time at the start location. So skip this suboptimal case.\\n\\t\\t\\t# 2. If you get here with less days you can spend at the start location, it\\'s suboptimal. So skip it.\\n            if visited[x, y].time < time or visited[x, y].can_wait > can_wait:\\n                continue\\n            visited[x, y] = Record(time, can_wait)\\n            \\n            if x == H - 1 and y == W - 1:\\n                answer = max(answer, can_wait)\\n            \\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if 0 <= nx < H and 0 <= ny < W and G[nx][ny] != WALL:\\n                    new_time = time + 1\\n\\t\\t\\t\\t\\t# compute the can_wait time. It\\'s a little complicated here, since we need to handle the destination case specially.\\n                    if G[nx][ny] == GRASS:\\n                        new_can_wait = can_wait\\n                    else:\\n                        fire_time = G[nx][ny]\\n                        if nx == H - 1 and ny == W - 1:\\n\\t\\t\\t\\t\\t\\t\\t# It\\'s OK if you get to the destination and fire immediately spreads there.\\n                            new_can_wait = min(can_wait, fire_time - new_time)\\n                        else:\\n                            new_can_wait = min(can_wait, fire_time - new_time - 1)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# trim the bfs.\\n                    if visited[nx, ny].time < new_time or visited[nx, ny].can_wait > new_can_wait:\\n                        continue\\n                    \\n                    queue.append((nx, ny, new_time, new_can_wait))\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233903,
                "title": "c-beats-100-time-90-memory-2-bfs-clean-solution",
                "content": "```\\nclass Solution {\\n    const int NO_FIRE=1e9;\\n    int dirx[4] = {1, 0, -1, 0};\\n    int diry[4] = {0, -1, 0, 1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        // -1 = wall, 0 = initial_fire, 0> = fire_at_sometime\\n        vector<vector<int>> g(m,vector<int>(n, NO_FIRE));\\n        queue<pair<int,int>> q;\\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    q.push({x,y});\\n                    g[x][y]=0;\\n                }\\n                else if(grid[x][y]==2)\\n                    g[x][y]=-1;\\n            }\\n        }\\n        //fill fire_time in g\\n        while(q.size()){\\n            int len=q.size();\\n            while(len-->0){\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = dirx[dir] + x;\\n                    int ny = diry[dir] + y;\\n                    if(nx<0 or m<=nx or ny<0 or n<=ny or \\n                       g[nx][ny]!=NO_FIRE)\\n                        continue;\\n                    g[nx][ny]=1+g[x][y];\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        int rres=-1;\\n        //res, {x, y}, dist\\n        //res=max(min(g[x][y]-dist-1))\\n        //if -1 then dont accept result\\n        multiset<tuple<int,pair<int,int>,int>> qq;\\n        qq.insert({g[0][0]-1,{0,0},0});\\n        while(qq.size()){\\n            auto [res,xy,dist]=*qq.rbegin();\\n            auto &[x,y]=xy;\\n            qq.erase(prev(end(qq)));\\n            if(g[x][y]==-2)\\n                continue;\\n\\n            if(x==m-1 and y==n-1){\\n                res=min(g[x][y]-dist,res);\\n                rres=max(res,rres);\\n                continue;\\n            }else{\\n                res=min(g[x][y]-dist-1,res);\\n                g[x][y]=-2;\\n                if(res<0)\\n                    continue;\\n            }\\n\\n            for(int dir=0;dir<4;dir++){\\n                int nx = dirx[dir] + x;\\n                int ny = diry[dir] + y;\\n                if(nx<0 or m<=nx or ny<0 or n<=ny or\\n                   g[nx][ny]==-1 or g[nx][ny]==-2)\\n                    continue;\\n                qq.insert({res,{nx,ny},dist+1});\\n            }\\n        }\\n        \\n        if(rres>1e8)\\n            return NO_FIRE;\\n        return rres;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    const int NO_FIRE=1e9;\\n    int dirx[4] = {1, 0, -1, 0};\\n    int diry[4] = {0, -1, 0, 1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        // -1 = wall, 0 = initial_fire, 0> = fire_at_sometime\\n        vector<vector<int>> g(m,vector<int>(n, NO_FIRE));\\n        queue<pair<int,int>> q;\\n        for(int x=0;x<m;x++){\\n            for(int y=0;y<n;y++){\\n                if(grid[x][y]==1){\\n                    q.push({x,y});\\n                    g[x][y]=0;\\n                }\\n                else if(grid[x][y]==2)\\n                    g[x][y]=-1;\\n            }\\n        }\\n        //fill fire_time in g\\n        while(q.size()){\\n            int len=q.size();\\n            while(len-->0){\\n                auto [x, y] = q.front();\\n                q.pop();\\n                for(int dir=0;dir<4;dir++){\\n                    int nx = dirx[dir] + x;\\n                    int ny = diry[dir] + y;\\n                    if(nx<0 or m<=nx or ny<0 or n<=ny or \\n                       g[nx][ny]!=NO_FIRE)\\n                        continue;\\n                    g[nx][ny]=1+g[x][y];\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n\\n        int rres=-1;\\n        //res, {x, y}, dist\\n        //res=max(min(g[x][y]-dist-1))\\n        //if -1 then dont accept result\\n        multiset<tuple<int,pair<int,int>,int>> qq;\\n        qq.insert({g[0][0]-1,{0,0},0});\\n        while(qq.size()){\\n            auto [res,xy,dist]=*qq.rbegin();\\n            auto &[x,y]=xy;\\n            qq.erase(prev(end(qq)));\\n            if(g[x][y]==-2)\\n                continue;\\n\\n            if(x==m-1 and y==n-1){\\n                res=min(g[x][y]-dist,res);\\n                rres=max(res,rres);\\n                continue;\\n            }else{\\n                res=min(g[x][y]-dist-1,res);\\n                g[x][y]=-2;\\n                if(res<0)\\n                    continue;\\n            }\\n\\n            for(int dir=0;dir<4;dir++){\\n                int nx = dirx[dir] + x;\\n                int ny = diry[dir] + y;\\n                if(nx<0 or m<=nx or ny<0 or n<=ny or\\n                   g[nx][ny]==-1 or g[nx][ny]==-2)\\n                    continue;\\n                qq.insert({res,{nx,ny},dist+1});\\n            }\\n        }\\n        \\n        if(rres>1e8)\\n            return NO_FIRE;\\n        return rres;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180753,
                "title": "python-go-bfs-diff-greedy-o-mn",
                "content": "Firstly, we expect that *simple queue based BFS* fit the solution *than priority queue based Dijkstra* when all interconnected nodes have the *same weight*. It is just *1* in this case since all move toward four directions *stepwise* if they can.\\n\\nSecondly, in this problem there are *many* fire locations that spread to the safehouse and must *follow* in the person\\'s footsteps. At once we ask ourselves if it is necessary for *Floyd-Warshall* to find all the *minimal distances* from multiple sources to multiple destinations. No, we need merely find *two of them*, one from the fire locations and another from the person\\'s kickoff to the safehouse. Hence, we call *BFS twice* and the answer lies in the *difference* between the former and the latter.\\n\\nFinally, according to the problem we have to distinguish between *two interesting cases* below, i.e. either the fires would catch up with the person *en route* or they would meet at the safehouse *destination* once the person delays to start. We should further *subtract 1* from the aforesaid difference in the former case.\\n\\n> After your move, every fire cell will spread to all adjacent cells that are not walls.\\n\\n> Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\\n\\n*Python* solution w/o early stop\\n\\n```python\\ndef maximumMinutes(self, grid):\\n    def bfs(dist, q):\\n        while q:\\n            i, j, w = q.popleft()\\n            dist[i][j] = w\\n            for x, y in [i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]:\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and dist[x][y] > w + 1:\\n                    q.append([x, y, w + 1])\\n\\n    m, n = len(grid), len(grid[0])\\n    F, P = [[20000] * n for _ in range(m)], [[20001] * n for _ in range(m)]\\n    bfs(F, collections.deque([[i, j, 0] for i in range(m) for j in range(n) if grid[i][j] == 1]))\\n    bfs(P, collections.deque([[0, 0, 0]]))\\n\\n    if (diff := F[-1][-1] - P[-1][-1]) < 0: return -1\\n    if F[-1][-1] == 20000: return 10 ** 9\\n    return diff - (F[-1][-2] - P[-1][-2] <= diff and F[-2][-1] - P[-2][-1] <= diff)\\n```\\n\\n*Go* solution w/ early stop in 34ms beat 100% :)\\n\\n```go\\ntype pos struct{ i, j int }\\ntype node struct {\\n\\tpos\\n\\tw int\\n}\\ntype queue struct{ front, back []node }\\n\\nfunc (q *queue) empty() bool { return len(q.front) == 0 && len(q.back) == 0 }\\nfunc (q *queue) clear() {\\n\\tq.front = q.front[:0]\\n\\tq.back = q.back[:0]\\n}\\nfunc (q *queue) pushback(u node) { q.back = append(q.back, u) }\\nfunc (q *queue) popfront() node {\\n\\tvar (\\n\\t\\ti = len(q.front) - 1\\n\\t\\tu node\\n\\t)\\n\\tif i >= 0 {\\n\\t\\tu = q.front[i]\\n\\t\\tq.front = q.front[:i]\\n\\t} else {\\n\\t\\tu = q.back[0]\\n\\t\\tq.back = q.back[1:]\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (q *queue) bfs(grid [][]int, dist [][]int) {\\n\\tm, n := len(grid), len(grid[0])\\n\\tfor !q.empty() {\\n\\t\\tu := q.popfront()\\n\\t\\tdist[u.i][u.j] = u.w\\n\\t\\tif u.i == m-1 && u.j == n-1 { // early stop\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tw := u.w + 1\\n\\t\\tfor _, v := range []pos{pos{u.i + 1, u.j}, pos{u.i - 1, u.j}, pos{u.i, u.j + 1}, pos{u.i, u.j - 1}} {\\n\\t\\t\\tif 0 <= v.i && v.i < m && 0 <= v.j && v.j < n && grid[v.i][v.j] == 0 && dist[v.i][v.j] > w {\\n\\t\\t\\t\\tq.pushback(node{v, w})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tF, P := make([][]int, m), make([][]int, m)\\n\\tq := queue{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tF[i], P[i] = make([]int, n), make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tF[i][j], P[i][j] = 20000, 20001\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tq.pushback(node{pos{i, j}, 0})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tq.bfs(grid, F)\\n\\tq.clear()\\n\\tq.pushback(node{pos{0, 0}, 0})\\n\\tq.bfs(grid, P)\\n\\n\\tdiff := F[m-1][n-1] - P[m-1][n-1]\\n\\tif diff < 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tif F[m-1][n-1] == 20000 {\\n\\t\\treturn 1000000000\\n\\t}\\n\\tif F[m-1][n-2]-P[m-1][n-2] <= diff && F[m-2][n-1]-P[m-2][n-1] <= diff {\\n\\t\\treturn diff - 1\\n\\t}\\n\\treturn diff\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumMinutes(self, grid):\\n    def bfs(dist, q):\\n        while q:\\n            i, j, w = q.popleft()\\n            dist[i][j] = w\\n            for x, y in [i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]:\\n                if 0 <= x < m and 0 <= y < n and grid[x][y] == 0 and dist[x][y] > w + 1:\\n                    q.append([x, y, w + 1])\\n\\n    m, n = len(grid), len(grid[0])\\n    F, P = [[20000] * n for _ in range(m)], [[20001] * n for _ in range(m)]\\n    bfs(F, collections.deque([[i, j, 0] for i in range(m) for j in range(n) if grid[i][j] == 1]))\\n    bfs(P, collections.deque([[0, 0, 0]]))\\n\\n    if (diff := F[-1][-1] - P[-1][-1]) < 0: return -1\\n    if F[-1][-1] == 20000: return 10 ** 9\\n    return diff - (F[-1][-2] - P[-1][-2] <= diff and F[-2][-1] - P[-2][-1] <= diff)\\n```\n```go\\ntype pos struct{ i, j int }\\ntype node struct {\\n\\tpos\\n\\tw int\\n}\\ntype queue struct{ front, back []node }\\n\\nfunc (q *queue) empty() bool { return len(q.front) == 0 && len(q.back) == 0 }\\nfunc (q *queue) clear() {\\n\\tq.front = q.front[:0]\\n\\tq.back = q.back[:0]\\n}\\nfunc (q *queue) pushback(u node) { q.back = append(q.back, u) }\\nfunc (q *queue) popfront() node {\\n\\tvar (\\n\\t\\ti = len(q.front) - 1\\n\\t\\tu node\\n\\t)\\n\\tif i >= 0 {\\n\\t\\tu = q.front[i]\\n\\t\\tq.front = q.front[:i]\\n\\t} else {\\n\\t\\tu = q.back[0]\\n\\t\\tq.back = q.back[1:]\\n\\t}\\n\\treturn u\\n}\\n\\nfunc (q *queue) bfs(grid [][]int, dist [][]int) {\\n\\tm, n := len(grid), len(grid[0])\\n\\tfor !q.empty() {\\n\\t\\tu := q.popfront()\\n\\t\\tdist[u.i][u.j] = u.w\\n\\t\\tif u.i == m-1 && u.j == n-1 { // early stop\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tw := u.w + 1\\n\\t\\tfor _, v := range []pos{pos{u.i + 1, u.j}, pos{u.i - 1, u.j}, pos{u.i, u.j + 1}, pos{u.i, u.j - 1}} {\\n\\t\\t\\tif 0 <= v.i && v.i < m && 0 <= v.j && v.j < n && grid[v.i][v.j] == 0 && dist[v.i][v.j] > w {\\n\\t\\t\\t\\tq.pushback(node{v, w})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc maximumMinutes(grid [][]int) int {\\n\\tm, n := len(grid), len(grid[0])\\n\\tF, P := make([][]int, m), make([][]int, m)\\n\\tq := queue{}\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tF[i], P[i] = make([]int, n), make([]int, n)\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tF[i][j], P[i][j] = 20000, 20001\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tq.pushback(node{pos{i, j}, 0})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tq.bfs(grid, F)\\n\\tq.clear()\\n\\tq.pushback(node{pos{0, 0}, 0})\\n\\tq.bfs(grid, P)\\n\\n\\tdiff := F[m-1][n-1] - P[m-1][n-1]\\n\\tif diff < 0 {\\n\\t\\treturn -1\\n\\t}\\n\\tif F[m-1][n-1] == 20000 {\\n\\t\\treturn 1000000000\\n\\t}\\n\\tif F[m-1][n-2]-P[m-1][n-2] <= diff && F[m-2][n-1]-P[m-2][n-1] <= diff {\\n\\t\\treturn diff - 1\\n\\t}\\n\\treturn diff\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2161281,
                "title": "c-bfs",
                "content": "```\\nconst int N = 20010;\\nclass Solution {\\n    int dist[N];\\n    int m, n;\\n    bool check(int t, vector<vector<int>>& grid)\\n    {\\n        memset(dist, 0x3f, sizeof dist);\\n        t ++ ;\\n        queue<int> q;\\n        q.push(0);\\n        dist[0] = 0;\\n        int step = 1;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u / n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] <= t + step - int(x == m - 1 && y == n - 1) && grid[x][y] != 0) continue;\\n                    int v = x * n + y;\\n                    if (dist[v] > dist[u] + 1)\\n                    {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(x * n + y);   \\n                    }\\n                }   \\n            }\\n            step ++ ;\\n        }\\n        return dist[m * n - 1] < 0x3f3f3f3f / 2 ;\\n    }\\n    \\n    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        queue<int> q;\\n        for (int i = 0; i < m; ++ i)\\n            for (int j = 0; j < n; ++ j)\\n            {\\n                if (grid[i][j] == 1) q.push(i * n + j);\\n                if (grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n       \\n        int step = 2;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u/n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    grid[x][y] = step;\\n                    q.push(x * n + y);\\n                }    \\n            }\\n            step ++ ;\\n        }\\n        \\n        int l = -1, r = 1e9;\\n        while (l < r)\\n        {\\n            int mid = l + r + 1 >> 1;\\n            if (check(mid, grid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 20010;\\nclass Solution {\\n    int dist[N];\\n    int m, n;\\n    bool check(int t, vector<vector<int>>& grid)\\n    {\\n        memset(dist, 0x3f, sizeof dist);\\n        t ++ ;\\n        queue<int> q;\\n        q.push(0);\\n        dist[0] = 0;\\n        int step = 1;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u / n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] <= t + step - int(x == m - 1 && y == n - 1) && grid[x][y] != 0) continue;\\n                    int v = x * n + y;\\n                    if (dist[v] > dist[u] + 1)\\n                    {\\n                        dist[v] = dist[u] + 1;\\n                        q.push(x * n + y);   \\n                    }\\n                }   \\n            }\\n            step ++ ;\\n        }\\n        return dist[m * n - 1] < 0x3f3f3f3f / 2 ;\\n    }\\n    \\n    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        \\n        queue<int> q;\\n        for (int i = 0; i < m; ++ i)\\n            for (int j = 0; j < n; ++ j)\\n            {\\n                if (grid[i][j] == 1) q.push(i * n + j);\\n                if (grid[i][j] == 2) grid[i][j] = 1;\\n            }\\n       \\n        int step = 2;\\n        while (q.size())\\n        {\\n            int len = q.size();\\n            while (len -- )\\n            {\\n                int u = q.front(); q.pop();\\n                for (int i = 0; i < 4; ++ i)\\n                {\\n                    int x = u/n + dx[i], y = u % n + dy[i];\\n                    if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y] > 0) continue;\\n                    grid[x][y] = step;\\n                    q.push(x * n + y);\\n                }    \\n            }\\n            step ++ ;\\n        }\\n        \\n        int l = -1, r = 1e9;\\n        while (l < r)\\n        {\\n            int mid = l + r + 1 >> 1;\\n            if (check(mid, grid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155277,
                "title": "simple-solution-c",
                "content": "what will be the minimum wait time 0 minutes\\nwhat can be the maximum wait time m*n+1 minutes\\n\\nnow we do binary on the wait time of the person\\n\\nif for a value of wait time person is safe then we can increase wait time\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,-1,1};\\n    int y[4]={-1,1,0,0};\\n    bool solver(vector<vector<int>> grid,int k, vector<pair<int,int>>&v)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(auto x:v)\\n        q.push(x);\\n        \\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>>per;\\n        \\n        if(grid[0][0]==1)\\n            return false;\\n        \\n        \\n        per.push({0,0});\\n        \\n        grid[0][0]=3;\\n        \\n        \\n        while(!per.empty())\\n        {\\n            int l=per.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=per.front();\\n                per.pop();\\n                \\n                if(dir.first==n-1 && dir.second==m-1)\\n                    return true;\\n                \\n                if(grid[dir.first][dir.second]==1)\\n                    continue;\\n                \\n                 for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=3;\\n                        per.push({a,b});\\n                    }\\n                }\\n                \\n            }\\n            \\n            l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && (!grid[a][b] || grid[a][b]==3))\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        \\n        \\n        vector<pair<int,int>>v;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                v.push_back({i,j});\\n            }\\n        }\\n        \\n        int l=0;\\n        int r=m*n+2;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(solver(grid,mid,v))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n            \\n            \\n            //cout<<mid<<\"\\\\n\";\\n        }\\n        \\n        return (ans==m*n+2)?1e9:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x[4]={0,0,-1,1};\\n    int y[4]={-1,1,0,0};\\n    bool solver(vector<vector<int>> grid,int k, vector<pair<int,int>>&v)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        \\n        queue<pair<int,int>>q;\\n        \\n        for(auto x:v)\\n        q.push(x);\\n        \\n        \\n        for(int i=0;i<k;i++)\\n        {\\n            int l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int>>per;\\n        \\n        if(grid[0][0]==1)\\n            return false;\\n        \\n        \\n        per.push({0,0});\\n        \\n        grid[0][0]=3;\\n        \\n        \\n        while(!per.empty())\\n        {\\n            int l=per.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=per.front();\\n                per.pop();\\n                \\n                if(dir.first==n-1 && dir.second==m-1)\\n                    return true;\\n                \\n                if(grid[dir.first][dir.second]==1)\\n                    continue;\\n                \\n                 for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && !grid[a][b])\\n                    {\\n                        grid[a][b]=3;\\n                        per.push({a,b});\\n                    }\\n                }\\n                \\n            }\\n            \\n            l=q.size();\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                pair<int,int>dir=q.front();\\n                q.pop();\\n                \\n                for(int h=0;h<4;h++)\\n                {\\n                    int a=dir.first+x[h];\\n                    int b=dir.second+y[h];\\n                    \\n                    if(a>=0 && a<n & b>=0 && b<m && (!grid[a][b] || grid[a][b]==3))\\n                    {\\n                        grid[a][b]=1;\\n                        q.push({a,b});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=-1;\\n        \\n        \\n        vector<pair<int,int>>v;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                v.push_back({i,j});\\n            }\\n        }\\n        \\n        int l=0;\\n        int r=m*n+2;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            if(solver(grid,mid,v))\\n            {\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n            \\n            \\n            //cout<<mid<<\"\\\\n\";\\n        }\\n        \\n        return (ans==m*n+2)?1e9:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2135007,
                "title": "c-bfs-binary-search",
                "content": "```\\n#define fi first\\n#define si second\\nint n,m;\\nconst int inf = 2e9;\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint ff(int w,vector<vector<int>>& dp)\\n{\\n    if(dp[0][0]<=w)return 0;\\n    vector<vector<int>> vis(n,vector<int>(m,-1));\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    vis[0][0] = w;\\n    while(q.size())\\n    {\\n        auto p = q.front();\\n        q.pop();\\n        int x = p.fi , y = p.si;\\n        int d = vis[x][y];\\n        for(int i = 0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(l<0 || l>=n || r<0 || r>=m || vis[l][r]!=-1)continue;\\n            if(l==n-1 && r==m-1 && dp[l][r]>=1+d)return 1;\\n            if(dp[l][r]<=1+d)continue;\\n            vis[l][r] = d+1;\\n            q.push({l,r});\\n        }\\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,inf));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1){q.push({i,j});dp[i][j]=0;}\\n                else if(g[i][j]==2)dp[i][j] = -1;\\n            }\\n        }\\n        int mx = 0;\\n        while(q.size())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.fi , y = p.si;\\n            int d = dp[x][y];mx = max(mx,d);\\n            for(int i = 0;i<4;i++)\\n            {\\n                int l = x+dx[i] , r = y+dy[i];\\n                if(l<0 || l>=n || r<0 || r>=m || dp[l][r]!=inf)continue;\\n                dp[l][r] = 1+d;\\n                q.push({l,r});\\n            }\\n        }\\n        int l = 0 , r = mx+1;\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(ff(mid,dp)==1)\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }\\n            else r = mid - 1;\\n        }\\n        return (ans==mx+1?1e9:ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n#define fi first\\n#define si second\\nint n,m;\\nconst int inf = 2e9;\\nint dx[4] = {1,0,-1,0};\\nint dy[4] = {0,1,0,-1};\\nint ff(int w,vector<vector<int>>& dp)\\n{\\n    if(dp[0][0]<=w)return 0;\\n    vector<vector<int>> vis(n,vector<int>(m,-1));\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    vis[0][0] = w;\\n    while(q.size())\\n    {\\n        auto p = q.front();\\n        q.pop();\\n        int x = p.fi , y = p.si;\\n        int d = vis[x][y];\\n        for(int i = 0;i<4;i++)\\n        {\\n            int l = x+dx[i] , r = y+dy[i];\\n            if(l<0 || l>=n || r<0 || r>=m || vis[l][r]!=-1)continue;\\n            if(l==n-1 && r==m-1 && dp[l][r]>=1+d)return 1;\\n            if(dp[l][r]<=1+d)continue;\\n            vis[l][r] = d+1;\\n            q.push({l,r});\\n        }\\n    }\\n    return 0;\\n}\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        n = g.size();\\n        m = g[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,inf));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(g[i][j]==1){q.push({i,j});dp[i][j]=0;}\\n                else if(g[i][j]==2)dp[i][j] = -1;\\n            }\\n        }\\n        int mx = 0;\\n        while(q.size())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.fi , y = p.si;\\n            int d = dp[x][y];mx = max(mx,d);\\n            for(int i = 0;i<4;i++)\\n            {\\n                int l = x+dx[i] , r = y+dy[i];\\n                if(l<0 || l>=n || r<0 || r>=m || dp[l][r]!=inf)continue;\\n                dp[l][r] = 1+d;\\n                q.push({l,r});\\n            }\\n        }\\n        int l = 0 , r = mx+1;\\n        int ans = -1;\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(ff(mid,dp)==1)\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }\\n            else r = mid - 1;\\n        }\\n        return (ans==mx+1?1e9:ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131195,
                "title": "c-bfs-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int n = grid.size(), m = grid[0].size();\\n        // fTime[i][j] = the time at which cell<i,j> starts burning\\n        vector<vector<int>> fTime(n, vector<int>(m));\\n        // mxDif[i][j] = maximum possible smallest distance to fire\\n        // until getting to cell<i,j>\\n        vector<vector<int>> mxDif(n, vector<int>(m));\\n        //-------------\\n        // setting initial values for fTime & mxDif\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++) {\\n            fTime[i][j] = 1e9; mxDif[i][j] = -1;\\n        }\\n        // finding intitial fire locations and adding them to queue\\n        queue<pair<int,int>> fPoses;\\n        queue<int> times;\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            if (grid[i][j] == 1) {\\n                fPoses.push({i,j});\\n                times.push(0);\\n            }\\n        // filling fTime by running a bfs\\n        while (fPoses.size()) {\\n            auto pos  = fPoses.front(); fPoses.pop();\\n            auto time = times.front() ; times.pop() ;\\n            if (time < fTime[pos.first][pos.second]) {\\n                fTime[pos.first][pos.second] = time;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    fPoses.push({pos.first-1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    fPoses.push({pos.first+1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    fPoses.push({pos.first,pos.second-1}),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    fPoses.push({pos.first,pos.second+1}),\\n                    times.push(time+1);\\n            }\\n        }\\n        // filling mxDif by running a bfs\\n        queue<pair<int,int>> qu; queue<int> diffs;\\n        qu.push({0,0}); diffs.push(fTime[0][0]);\\n        times.push(0);\\n        while(qu.size()) {\\n            auto pos  = qu.front(); qu.pop();\\n            auto diff = diffs.front() ; diffs.pop();\\n            auto time = times.front() ; times.pop();\\n            if ((pos.first != n-1 || pos.second != m-1) && diff <= 0) continue;\\n            if (diff > mxDif[pos.first][pos.second]) {\\n                mxDif[pos.first][pos.second] = diff;\\n                if (pos.first == n-1 && pos.second == m-1) continue;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    qu.push({pos.first-1,pos.second}),\\n                    diffs.push(min(fTime[pos.first-1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    qu.push({pos.first+1,pos.second}),\\n                    diffs.push(min(fTime[pos.first+1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    qu.push({pos.first,pos.second-1}),\\n                    diffs.push(min(fTime[pos.first][pos.second-1]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    qu.push({pos.first,pos.second+1}),\\n                    diffs.push(min(fTime[pos.first][pos.second+1]-time-1, diff)),\\n                    times.push(time+1);\\n            }\\n        }\\n        int res = mxDif[n-1][m-1];\\n        // returning 1e9 if fire can\\'t catch him at all & he can get to the target\\n        if (res == -1) return res;\\n        if (fTime[n-1][m-1] == 1e9) return 1e9;\\n        if (res < mxDif[n-2][m-1] || res < mxDif[n-1][m-2]) return res;\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int n = grid.size(), m = grid[0].size();\\n        // fTime[i][j] = the time at which cell<i,j> starts burning\\n        vector<vector<int>> fTime(n, vector<int>(m));\\n        // mxDif[i][j] = maximum possible smallest distance to fire\\n        // until getting to cell<i,j>\\n        vector<vector<int>> mxDif(n, vector<int>(m));\\n        //-------------\\n        // setting initial values for fTime & mxDif\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++) {\\n            fTime[i][j] = 1e9; mxDif[i][j] = -1;\\n        }\\n        // finding intitial fire locations and adding them to queue\\n        queue<pair<int,int>> fPoses;\\n        queue<int> times;\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            if (grid[i][j] == 1) {\\n                fPoses.push({i,j});\\n                times.push(0);\\n            }\\n        // filling fTime by running a bfs\\n        while (fPoses.size()) {\\n            auto pos  = fPoses.front(); fPoses.pop();\\n            auto time = times.front() ; times.pop() ;\\n            if (time < fTime[pos.first][pos.second]) {\\n                fTime[pos.first][pos.second] = time;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    fPoses.push({pos.first-1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    fPoses.push({pos.first+1,pos.second}),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    fPoses.push({pos.first,pos.second-1}),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    fPoses.push({pos.first,pos.second+1}),\\n                    times.push(time+1);\\n            }\\n        }\\n        // filling mxDif by running a bfs\\n        queue<pair<int,int>> qu; queue<int> diffs;\\n        qu.push({0,0}); diffs.push(fTime[0][0]);\\n        times.push(0);\\n        while(qu.size()) {\\n            auto pos  = qu.front(); qu.pop();\\n            auto diff = diffs.front() ; diffs.pop();\\n            auto time = times.front() ; times.pop();\\n            if ((pos.first != n-1 || pos.second != m-1) && diff <= 0) continue;\\n            if (diff > mxDif[pos.first][pos.second]) {\\n                mxDif[pos.first][pos.second] = diff;\\n                if (pos.first == n-1 && pos.second == m-1) continue;\\n                // add adj cells\\n                if (pos.first > 0 && grid[pos.first-1][pos.second]==0)\\n                    qu.push({pos.first-1,pos.second}),\\n                    diffs.push(min(fTime[pos.first-1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.first < n-1 && grid[pos.first+1][pos.second]==0)\\n                    qu.push({pos.first+1,pos.second}),\\n                    diffs.push(min(fTime[pos.first+1][pos.second]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second > 0 && grid[pos.first][pos.second-1]==0)\\n                    qu.push({pos.first,pos.second-1}),\\n                    diffs.push(min(fTime[pos.first][pos.second-1]-time-1, diff)),\\n                    times.push(time+1);\\n                if (pos.second < m-1 && grid[pos.first][pos.second+1]==0)\\n                    qu.push({pos.first,pos.second+1}),\\n                    diffs.push(min(fTime[pos.first][pos.second+1]-time-1, diff)),\\n                    times.push(time+1);\\n            }\\n        }\\n        int res = mxDif[n-1][m-1];\\n        // returning 1e9 if fire can\\'t catch him at all & he can get to the target\\n        if (res == -1) return res;\\n        if (fTime[n-1][m-1] == 1e9) return 1e9;\\n        if (res < mxDif[n-2][m-1] || res < mxDif[n-1][m-2]) return res;\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078570,
                "title": "c",
                "content": "Runtime: 46 ms, faster than 99.68% of C++ online submissions for Escape the Spreading Fire.\\nMemory Usage: 20.3 MB, less than 88.71% of C++ online submissions for Escape the Spreading Fire.\\n```\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>>& grid) {\\n    int y = grid.size(), x = grid[0].size(); \\n    queue<pair<int,int>> q;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++)\\n        if     (grid[i][j] == 2) grid[i][j] = -1;\\n        else if(grid[i][j] == 1) q.push({i,j});\\n        else grid[i][j] = 100000;\\n    \\n    y--, x--;\\n    while(!q.empty()){\\n      auto[i, j] = q.front(); q.pop();\\n      \\n      int next = grid[i][j] + 1;\\n      if(i      && grid[i-1][j] != -1 && grid[i-1][j] > next) grid[i-1][j] = next, q.push({i-1,j});\\n      if(i != y && grid[i+1][j] != -1 && grid[i+1][j] > next) grid[i+1][j] = next, q.push({i+1,j});\\n      \\n      if(j      && grid[i][j-1] != -1 && grid[i][j-1] > next) grid[i][j-1] = next, q.push({i,j-1});\\n      if(j != x && grid[i][j+1] != -1 && grid[i][j+1] > next) grid[i][j+1] = next, q.push({i,j+1});\\n    }\\n    \\n    int answer = INT_MAX;\\n    vector<vector<int>>vis(y+1, vector<int>(x+1,0));\\n    q.push({0,0});\\n      \\n    for(int step = 1; !q.empty(); step++)\\n      for(int n = q.size(); n; n--){\\n        auto[i,j] = q.front(); q.pop(); \\n        \\n        if(i == y && j == x) {\\n          if(grid[y][x] == 100000) return 1000000000;\\n          if(grid[y][x] < step) continue;\\n          answer = min(answer, grid[y][x] - step);\\n          continue;\\n        }\\n        if(vis[i][j] || grid[i][j] <= step) continue;\\n        vis[i][j] = 1;\\n        \\n        if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n        if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n        if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n        if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n  \\n    if(answer == INT_MAX) return -1;\\n \\n    queue<pair<int,int>> nq;\\n    while(true){\\n    \\n      vis.clear();\\n      vis.resize(y+1, vector<int>(x+1,0));\\n      q.push({0,0});\\n      \\n      for(int step = answer + 2; !q.empty(); step++)\\n        for(int n = q.size(); n; n--){\\n          auto[i,j] = q.front(); q.pop(); \\n        \\n          if(i == y && j == x) {answer++; goto mark;}\\n        \\n          if(vis[i][j] || grid[i][j] <= step) continue;\\n          vis[i][j] = 1;\\n        \\n          if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n          if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n          if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n          if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n      break;\\n      mark:;\\n      q = nq;\\n    }\\n    \\n    return answer - 1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>>& grid) {\\n    int y = grid.size(), x = grid[0].size(); \\n    queue<pair<int,int>> q;\\n    \\n    for(int i = 0; i != y; i++)\\n      for(int j = 0; j != x; j++)\\n        if     (grid[i][j] == 2) grid[i][j] = -1;\\n        else if(grid[i][j] == 1) q.push({i,j});\\n        else grid[i][j] = 100000;\\n    \\n    y--, x--;\\n    while(!q.empty()){\\n      auto[i, j] = q.front(); q.pop();\\n      \\n      int next = grid[i][j] + 1;\\n      if(i      && grid[i-1][j] != -1 && grid[i-1][j] > next) grid[i-1][j] = next, q.push({i-1,j});\\n      if(i != y && grid[i+1][j] != -1 && grid[i+1][j] > next) grid[i+1][j] = next, q.push({i+1,j});\\n      \\n      if(j      && grid[i][j-1] != -1 && grid[i][j-1] > next) grid[i][j-1] = next, q.push({i,j-1});\\n      if(j != x && grid[i][j+1] != -1 && grid[i][j+1] > next) grid[i][j+1] = next, q.push({i,j+1});\\n    }\\n    \\n    int answer = INT_MAX;\\n    vector<vector<int>>vis(y+1, vector<int>(x+1,0));\\n    q.push({0,0});\\n      \\n    for(int step = 1; !q.empty(); step++)\\n      for(int n = q.size(); n; n--){\\n        auto[i,j] = q.front(); q.pop(); \\n        \\n        if(i == y && j == x) {\\n          if(grid[y][x] == 100000) return 1000000000;\\n          if(grid[y][x] < step) continue;\\n          answer = min(answer, grid[y][x] - step);\\n          continue;\\n        }\\n        if(vis[i][j] || grid[i][j] <= step) continue;\\n        vis[i][j] = 1;\\n        \\n        if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n        if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n        if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n        if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n  \\n    if(answer == INT_MAX) return -1;\\n \\n    queue<pair<int,int>> nq;\\n    while(true){\\n    \\n      vis.clear();\\n      vis.resize(y+1, vector<int>(x+1,0));\\n      q.push({0,0});\\n      \\n      for(int step = answer + 2; !q.empty(); step++)\\n        for(int n = q.size(); n; n--){\\n          auto[i,j] = q.front(); q.pop(); \\n        \\n          if(i == y && j == x) {answer++; goto mark;}\\n        \\n          if(vis[i][j] || grid[i][j] <= step) continue;\\n          vis[i][j] = 1;\\n        \\n          if(i      && !vis[i-1][j] && grid[i-1][j] != -1 ) q.push({i-1,j});\\n          if(i != y && !vis[i+1][j] && grid[i+1][j] != -1 ) q.push({i+1,j});\\n      \\n          if(j      && !vis[i][j-1] && grid[i][j-1] != -1 ) q.push({i,j-1});\\n          if(j != x && !vis[i][j+1] && grid[i][j+1] != -1 ) q.push({i,j+1});\\n      }\\n      break;\\n      mark:;\\n      q = nq;\\n    }\\n    \\n    return answer - 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071064,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass BFS{\\nprivate:\\n    vector<vector<int>>graph;\\n    vector<vector<int>>dis;\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n    int row, col;\\n    \\n    bool isValid(int x,int y, vector<vector<int>> &vis){\\n        if(x<0 || x==row || y<0 || y==col || vis[x][y]!=INT_MAX || graph[x][y]==2)\\n            return false;\\n        return true;\\n    }\\n    \\n    int calculateTimesOfFireCatchingForEachCell(){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(graph[i][j]==1){\\n                    q.push({i,j});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y] + 1;\\n                }\\n            }\\n        }\\n        dis = vis;\\n        return 1;\\n    }\\n    bool isPossibleToReach(int time){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        q.push({0,0});\\n        vis[0][0] = time;\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            if(x==row-1 && y==col-1)\\n                return true;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis) && dis[nX][nY] > vis[x][y]+1 || (nX==row-1 && nY==col-1 && dis[nX][nY]>=vis[x][y]+1)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y]+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    BFS(vector<vector<int>> &grid){\\n        this->graph = grid;\\n        this->row = grid.size();\\n        this->col = grid[0].size();\\n    }\\n    int maximumMinutes(){\\n        this->calculateTimesOfFireCatchingForEachCell();\\n        int low = 0, high = row*col+1,ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isPossibleToReach(mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans==row*col+1 ? 1e9 : ans;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        BFS bfs(grid);\\n        return bfs.maximumMinutes();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass BFS{\\nprivate:\\n    vector<vector<int>>graph;\\n    vector<vector<int>>dis;\\n    int dx[4] = {0,0,1,-1};\\n    int dy[4] = {1,-1,0,0};\\n    int row, col;\\n    \\n    bool isValid(int x,int y, vector<vector<int>> &vis){\\n        if(x<0 || x==row || y<0 || y==col || vis[x][y]!=INT_MAX || graph[x][y]==2)\\n            return false;\\n        return true;\\n    }\\n    \\n    int calculateTimesOfFireCatchingForEachCell(){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>>vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(graph[i][j]==1){\\n                    q.push({i,j});\\n                    vis[i][j] = 0;\\n                }\\n            }\\n        }\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y] + 1;\\n                }\\n            }\\n        }\\n        dis = vis;\\n        return 1;\\n    }\\n    bool isPossibleToReach(int time){\\n        queue<pair<int,int>>q;\\n        vector<vector<int>> vis = vector<vector<int>>(row, vector<int>(col,INT_MAX));\\n        q.push({0,0});\\n        vis[0][0] = time;\\n        while(!q.empty()){\\n            auto fr = q.front();\\n            q.pop();\\n            int x = fr.first;\\n            int y = fr.second;\\n            if(x==row-1 && y==col-1)\\n                return true;\\n            for(int i=0;i<4;i++){\\n                int nX = x + dx[i];\\n                int nY = y + dy[i];\\n                if(isValid(nX,nY,vis) && dis[nX][nY] > vis[x][y]+1 || (nX==row-1 && nY==col-1 && dis[nX][nY]>=vis[x][y]+1)){\\n                    q.push({nX,nY});\\n                    vis[nX][nY] = vis[x][y]+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    BFS(vector<vector<int>> &grid){\\n        this->graph = grid;\\n        this->row = grid.size();\\n        this->col = grid[0].size();\\n    }\\n    int maximumMinutes(){\\n        this->calculateTimesOfFireCatchingForEachCell();\\n        int low = 0, high = row*col+1,ans = -1;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(isPossibleToReach(mid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n        return ans==row*col+1 ? 1e9 : ans;\\n        \\n    }\\n};\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        BFS bfs(grid);\\n        return bfs.maximumMinutes();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064554,
                "title": "java-25ms-two-traverses",
                "content": "See most voted solutions for the idea.\\n\\n```\\nclass Solution {\\n    private final int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private int R, C;\\n    private Queue<Integer> rQueue, cQueue, sQueue;\\n    private int[][] pGrid, fGrid;\\n    \\n    private void initialize(int[][] grid) {\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.rQueue = new LinkedList<>();\\n        this.cQueue = new LinkedList<>();\\n        this.sQueue = new LinkedList<>();\\n        this.pGrid = new int[R][C];\\n        this.fGrid = new int[R][C];\\n        \\n        for (int i = 0; i < C; i++) {\\n            for (int[] pRow : pGrid) pRow[i] = -1;\\n            for (int[] fRow : fGrid) fRow[i] = -1;\\n        }\\n    }\\n    \\n    private List<int[]> getFirePositions(int[][] grid) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    result.add(new int[]{ i, j });\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void bfs(int[][] grid, int[][] map, boolean isFire) {\\n        if (isFire) {\\n            List<int[]> firePositions = getFirePositions(grid);\\n            for (int[] pos : firePositions) {\\n                registerQueue(pos[0], pos[1], 0, map);\\n            }\\n        } else {\\n            registerQueue(0, 0, 0, map);\\n        }\\n        \\n        while (!rQueue.isEmpty()) {\\n            int r = rQueue.poll(), c = cQueue.poll(), s = sQueue.poll();\\n            \\n            for (int[] dir : directions) {\\n                int rr = r + dir[0], cc = c + dir[1], ss = s + 1;\\n                \\n                if (rr < 0 || rr >= R) continue;\\n                if (cc < 0 || cc >= C) continue;\\n                if (grid[rr][cc] == 2) continue;\\n                if (map[rr][cc] > -1 && map[rr][cc] <= ss) continue;\\n                \\n                registerQueue(rr, cc, ss, map);\\n            }\\n        }\\n    }\\n    \\n    private void registerQueue(int r, int c, int s, int[][] map) {\\n        rQueue.add(r);\\n        cQueue.add(c);\\n        sQueue.add(s);\\n        map[r][c] = s;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        initialize(grid);\\n        \\n        bfs(grid, fGrid, true);\\n        bfs(grid, pGrid, false);\\n        \\n        if (pGrid[R - 1][C - 1] == -1) return -1;\\n        if (fGrid[R - 1][C - 1] == -1) return (int)1e9;\\n        \\n        int diff = fGrid[R - 1][C - 1] - pGrid[R - 1][C - 1];\\n        \\n        if (diff < 0) return -1;\\n        \\n        int northDiff = fGrid[R - 2][C - 1] - pGrid[R - 2][C - 1];\\n        int westDiff = fGrid[R - 1][C - 2] - pGrid[R - 1][C - 2];\\n        \\n        if (northDiff > diff) return diff;\\n        if (westDiff > diff) return diff;\\n        \\n        return diff - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n    private int R, C;\\n    private Queue<Integer> rQueue, cQueue, sQueue;\\n    private int[][] pGrid, fGrid;\\n    \\n    private void initialize(int[][] grid) {\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.rQueue = new LinkedList<>();\\n        this.cQueue = new LinkedList<>();\\n        this.sQueue = new LinkedList<>();\\n        this.pGrid = new int[R][C];\\n        this.fGrid = new int[R][C];\\n        \\n        for (int i = 0; i < C; i++) {\\n            for (int[] pRow : pGrid) pRow[i] = -1;\\n            for (int[] fRow : fGrid) fRow[i] = -1;\\n        }\\n    }\\n    \\n    private List<int[]> getFirePositions(int[][] grid) {\\n        List<int[]> result = new ArrayList<>();\\n        \\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (grid[i][j] == 1) {\\n                    result.add(new int[]{ i, j });\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void bfs(int[][] grid, int[][] map, boolean isFire) {\\n        if (isFire) {\\n            List<int[]> firePositions = getFirePositions(grid);\\n            for (int[] pos : firePositions) {\\n                registerQueue(pos[0], pos[1], 0, map);\\n            }\\n        } else {\\n            registerQueue(0, 0, 0, map);\\n        }\\n        \\n        while (!rQueue.isEmpty()) {\\n            int r = rQueue.poll(), c = cQueue.poll(), s = sQueue.poll();\\n            \\n            for (int[] dir : directions) {\\n                int rr = r + dir[0], cc = c + dir[1], ss = s + 1;\\n                \\n                if (rr < 0 || rr >= R) continue;\\n                if (cc < 0 || cc >= C) continue;\\n                if (grid[rr][cc] == 2) continue;\\n                if (map[rr][cc] > -1 && map[rr][cc] <= ss) continue;\\n                \\n                registerQueue(rr, cc, ss, map);\\n            }\\n        }\\n    }\\n    \\n    private void registerQueue(int r, int c, int s, int[][] map) {\\n        rQueue.add(r);\\n        cQueue.add(c);\\n        sQueue.add(s);\\n        map[r][c] = s;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        initialize(grid);\\n        \\n        bfs(grid, fGrid, true);\\n        bfs(grid, pGrid, false);\\n        \\n        if (pGrid[R - 1][C - 1] == -1) return -1;\\n        if (fGrid[R - 1][C - 1] == -1) return (int)1e9;\\n        \\n        int diff = fGrid[R - 1][C - 1] - pGrid[R - 1][C - 1];\\n        \\n        if (diff < 0) return -1;\\n        \\n        int northDiff = fGrid[R - 2][C - 1] - pGrid[R - 2][C - 1];\\n        int westDiff = fGrid[R - 1][C - 2] - pGrid[R - 1][C - 2];\\n        \\n        if (northDiff > diff) return diff;\\n        if (westDiff > diff) return diff;\\n        \\n        return diff - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059872,
                "title": "using-bfs-twice-to-solve-this-problem",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        ///SOLVING METHOD:\\n        ///.1 there could be many routes which connect (0,0) and (M-1,N-1)\\n        ///.2 So, the maximum number of minutes that you can stay in the initial position \\n        ///is determined by the maximum bottleneck time on any route.\\n        ///.3 A bottleneck time is the minimum time difference between you travel to there \\n        ///and the fire arrives there.\\n        ///.4 Attention!: if the bottleneck time node is the last grid(M-1,N-1), you \\n        ///arrives there at the same time with fire is ok;otherwise, you have to arrives\\n        ///the grid earlier than the fire.\\n        int M = grid.size(), N = grid[0].size();\\n        ///for recording fire spreading time on every grid.\\n        vector<vector<int>> fireTime(M, vector<int>(N, -1));\\n        queue<int> q;\\n        for(int i = 0;i < M;++i ){\\n            for(int j = 0;j < N;++j ){\\n                if(grid[i][j] == 1) q.push(i*N+j);\\n            }\\n        }\\n        int time = 0;\\n        int dirs[5] = {0,1,0,-1,0};\\n        ////using BFS to find the fire spreading time on every grid.\\n        while(!q.empty()){\\n            queue<int> nq;\\n            while(!q.empty()){\\n                int r = q.front()/N, c = q.front()%N;\\n                q.pop();\\n                if(fireTime[r][c] != -1)\\n                    continue;\\n                fireTime[r][c] = time;///setting fire spread time\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && fireTime[nx][ny]==-1 && grid[nx][ny] != 2)\\n                        nq.push(nx*N+ny);///extending the next level.\\n                }///for\\n            }\\n            swap(nq, q);\\n            time++;///increasing time count.\\n        }///while\\n        if(fireTime[0][0] == 0) return -1;\\n        queue<pair<int,int>> q1;\\n        int mt = 1e9, res = -1;\\n        time = 0;\\n        q1.push({0, mt});\\n        while(!q1.empty()){\\n            queue<pair<int,int>> nq;\\n            while(!q1.empty()){\\n                int r = q1.front().first/N, c = q1.front().first%N;\\n                mt = q1.front().second;\\n                q1.pop();\\n                if(r == M-1 && c == N-1 && (fireTime[r][c] == -1 || fireTime[r][c] >= time)){\\n                    if(fireTime[r][c] != -1) mt = min(mt, fireTime[r][c]-time);///THE difference between final grid and intermediate grid\\n                    res = max(res, mt);///It may not be the best answer.\\n                    continue;\\n                }else if(fireTime[r][c] != -1 && fireTime[r][c] <= time) continue;\\n                \\n                if(fireTime[r][c] != -1)mt = min(mt, fireTime[r][c]-time-1);///THE difference between final grid and intermediate grid\\n                fireTime[r][c] = 0;///mark this grid as visited.\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && grid[nx][ny] == 0 && (fireTime[nx][ny]==-1 || fireTime[nx][ny] >= time+1)){\\n                        nq.push({nx*N+ny, mt});///extending thie node.\\n                    }\\n                }\\n            }\\n            time++;\\n            swap(q1, nq);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        ///SOLVING METHOD:\\n        ///.1 there could be many routes which connect (0,0) and (M-1,N-1)\\n        ///.2 So, the maximum number of minutes that you can stay in the initial position \\n        ///is determined by the maximum bottleneck time on any route.\\n        ///.3 A bottleneck time is the minimum time difference between you travel to there \\n        ///and the fire arrives there.\\n        ///.4 Attention!: if the bottleneck time node is the last grid(M-1,N-1), you \\n        ///arrives there at the same time with fire is ok;otherwise, you have to arrives\\n        ///the grid earlier than the fire.\\n        int M = grid.size(), N = grid[0].size();\\n        ///for recording fire spreading time on every grid.\\n        vector<vector<int>> fireTime(M, vector<int>(N, -1));\\n        queue<int> q;\\n        for(int i = 0;i < M;++i ){\\n            for(int j = 0;j < N;++j ){\\n                if(grid[i][j] == 1) q.push(i*N+j);\\n            }\\n        }\\n        int time = 0;\\n        int dirs[5] = {0,1,0,-1,0};\\n        ////using BFS to find the fire spreading time on every grid.\\n        while(!q.empty()){\\n            queue<int> nq;\\n            while(!q.empty()){\\n                int r = q.front()/N, c = q.front()%N;\\n                q.pop();\\n                if(fireTime[r][c] != -1)\\n                    continue;\\n                fireTime[r][c] = time;///setting fire spread time\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && fireTime[nx][ny]==-1 && grid[nx][ny] != 2)\\n                        nq.push(nx*N+ny);///extending the next level.\\n                }///for\\n            }\\n            swap(nq, q);\\n            time++;///increasing time count.\\n        }///while\\n        if(fireTime[0][0] == 0) return -1;\\n        queue<pair<int,int>> q1;\\n        int mt = 1e9, res = -1;\\n        time = 0;\\n        q1.push({0, mt});\\n        while(!q1.empty()){\\n            queue<pair<int,int>> nq;\\n            while(!q1.empty()){\\n                int r = q1.front().first/N, c = q1.front().first%N;\\n                mt = q1.front().second;\\n                q1.pop();\\n                if(r == M-1 && c == N-1 && (fireTime[r][c] == -1 || fireTime[r][c] >= time)){\\n                    if(fireTime[r][c] != -1) mt = min(mt, fireTime[r][c]-time);///THE difference between final grid and intermediate grid\\n                    res = max(res, mt);///It may not be the best answer.\\n                    continue;\\n                }else if(fireTime[r][c] != -1 && fireTime[r][c] <= time) continue;\\n                \\n                if(fireTime[r][c] != -1)mt = min(mt, fireTime[r][c]-time-1);///THE difference between final grid and intermediate grid\\n                fireTime[r][c] = 0;///mark this grid as visited.\\n                for(int i = 0;i < 4;++i ){\\n                    int nx = r+dirs[i], ny = c+dirs[i+1];\\n                    if(nx < M && nx >= 0 && ny >= 0 && ny < N && grid[nx][ny] == 0 && (fireTime[nx][ny]==-1 || fireTime[nx][ny] >= time+1)){\\n                        nq.push({nx*N+ny, mt});///extending thie node.\\n                    }\\n                }\\n            }\\n            time++;\\n            swap(q1, nq);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056005,
                "title": "java-bfs-and-binary-search",
                "content": "\\n    class pair{\\n    int x;\\n    int y;\\n    pair(int x1,int y1){\\n        x=x1;\\n        y=y1;\\n    }\\n}\\n\\n    class Solution {\\n    int dx[]={-1,1,0,0};\\n    int dy[]={0,0,-1,1};\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int l=0;\\n        int h=m*n;\\n        int ans=-1;\\n        while(l<=h){\\n            int mid=(l+h)/2;\\n            // if for particular mid value we are able to reach end then \\n            //we are modifying the ans and checking for further higher\\n            // mid value\\n            if(spreadable(grid,mid)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans==m*n?(int)1e9:ans;\\n    }\\n    public boolean spreadable(int grid[][],int m){\\n        int copy[][]=clone(grid);\\n        Queue<pair> q=new LinkedList<>();\\n        for(int i=0;i<copy.length;i++){\\n            for(int j=0;j<copy[0].length;j++){\\n                if(copy[i][j]==1)q.add(new pair(i,j));\\n            }\\n        }\\n        // for particular mid can we are spreading fire upto mid lvl\\n        while(!q.isEmpty() && m-->0){\\n            if(reachable(q,copy))return false;\\n        }\\n        // here we are checking after mid level fire spread can we able to reach end\\n        Queue<pair> per=new LinkedList<>();\\n        per.add(new pair(0,0));\\n        while(!per.isEmpty()){\\n            boolean flag=reachable(q,copy);\\n            if(reachable(per,copy))return true;\\n            if(flag)return false;\\n        }\\n        return false;\\n    }\\n    public boolean reachable(Queue<pair> q,int grid[][]){\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int size=q.size();\\n        while(size-->0){\\n            pair it=q.poll();\\n            int x=it.x;\\n            int y=it.y;\\n            for(int p=0;p<4;p++){\\n                int newx=x+dx[p];\\n                int newy=y+dy[p];\\n                if(newx==m-1 && newy==n-1)return true;\\n                if(newx<0 || newy<0 || newx>=m || newy>=n || grid[newx][newy]!=0)continue;\\n                q.add(new pair(newx,newy));\\n                grid[newx][newy]=1;\\n            }\\n        }\\n        return false;\\n    }\\n    public int[][] clone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] copy = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n        return copy;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    int dx[]={-1,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2049137,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        # Fire path will tell us how much fire had spread a particular time\\n        fire_path = {}\\n        visited = set()\\n        dq = deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    dq.append((i, j))\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        count = 0\\n        # Spread the fire\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr in visited:\\n                    continue\\n                visited.add(curr)\\n                fire_path[curr] = count\\n                x, y = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append((x + dx, y + dy))\\n            \\n            count += 1\\n            \\n        # Reset visited and dq for bfs on person\\n        dq = deque([[0, 0, 10 ** 9]])\\n        count = 0\\n        visited.clear()\\n        ans = -1\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr[:2] == [len(grid) - 1, len(grid[0]) - 1]:\\n                    # Check if fire reached end before us. We can reach end at the same time as fire\\n                    if tuple(curr[:2]) in fire_path and fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    if tuple(curr[:2]) in fire_path:\\n                        curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count)\\n                    ans = max(ans, curr[2])\\n                    continue\\n                if tuple(curr[:2]) in visited:\\n                    continue\\n                if tuple(curr[:2]) in fire_path:\\n                    if fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    # Check if fire reached a particular point before we did. We want to reach before fire does\\n                    curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count - 1)\\n                visited.add(tuple(curr[:2]))\\n                x, y, c = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append([x + dx, y + dy, c])\\n            \\n            count += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        # Fire path will tell us how much fire had spread a particular time\\n        fire_path = {}\\n        visited = set()\\n        dq = deque()\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    dq.append((i, j))\\n        \\n        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))\\n        count = 0\\n        # Spread the fire\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr in visited:\\n                    continue\\n                visited.add(curr)\\n                fire_path[curr] = count\\n                x, y = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append((x + dx, y + dy))\\n            \\n            count += 1\\n            \\n        # Reset visited and dq for bfs on person\\n        dq = deque([[0, 0, 10 ** 9]])\\n        count = 0\\n        visited.clear()\\n        ans = -1\\n        while len(dq) > 0:\\n            for i in range(len(dq)):\\n                curr = dq.popleft()\\n                if curr[:2] == [len(grid) - 1, len(grid[0]) - 1]:\\n                    # Check if fire reached end before us. We can reach end at the same time as fire\\n                    if tuple(curr[:2]) in fire_path and fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    if tuple(curr[:2]) in fire_path:\\n                        curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count)\\n                    ans = max(ans, curr[2])\\n                    continue\\n                if tuple(curr[:2]) in visited:\\n                    continue\\n                if tuple(curr[:2]) in fire_path:\\n                    if fire_path[tuple(curr[:2])] < count:\\n                        continue\\n                    # Check if fire reached a particular point before we did. We want to reach before fire does\\n                    curr[2] = min(curr[2], fire_path[tuple(curr[:2])] - count - 1)\\n                visited.add(tuple(curr[:2]))\\n                x, y, c = curr\\n                for dx, dy in dirs:\\n                    if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]):\\n                        if (x + dx, y + dy) not in visited:\\n                            if grid[x + dx][y + dy] == 0:\\n                                dq.append([x + dx, y + dy, c])\\n            \\n            count += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036052,
                "title": "simple-java-solution-using-bfs-binary-search",
                "content": "The solution is simple:\\n1. **Pre-calculate** the time required by the fire to reach any cell with the help of a **MULTISOURCE** **BFS** using the fire cells as the sources.\\n2. We can simply find for a particular **WAIT** **TIME** \\'**T**\\', that whether after waiting for that much time, we can reach the destination or not by using another **simple** **BFS** **traversal** (or **DFS**, or **DSU**).\\n3. Now, for the **MAXIMUM** **WAIT** **TIME**, we can use **BINARY** **SEARCH**, and check for the **validity** of a **particular** **time** \\'**T**\\' using the **STEP** **2**.\\n\\n```\\nclass Solution {\\n    private int[][] setFire(int[][] grid, int[][] dir) {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        int[][] fire = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fire[i][j] = Integer.MAX_VALUE;\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    bfs.add(i * m + j);\\n                }\\n                if (grid[i][j] == 2) {\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while (bfs.size() > 0) {\\n            int rm = bfs.removeFirst();\\n            int x = rm / m, y = rm % m;\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int nx = x + dir[d][0], ny = y + dir[d][1];\\n                if (nx >= 0 && ny >= 0 && nx < n && ny < m && fire[nx][ny] == Integer.MAX_VALUE) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    bfs.add(nx * m + ny);\\n                }\\n            }\\n        }\\n        \\n        return fire;\\n    }\\n    \\n    private boolean isPoss(int[][] fire, int[][] dir, int time) {\\n        if (time >= fire[0][0]) {\\n            return false;\\n        }\\n        \\n        int n = fire.length, m = fire[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        bfs.add(0);\\n        \\n        boolean[][] isVis = new boolean[n][m];\\n        \\n        isVis[0][0] = true;\\n        \\n        while (bfs.size() > 0) {\\n            int size = bfs.size();\\n            while (size-- > 0) {\\n                int rm = bfs.removeFirst();\\n                int x = rm / m, y = rm % m;\\n                \\n                if (x == n - 1 && y == m - 1) {\\n                    return true;\\n                }\\n                \\n                for (int d = 0; d < 4; d++) {\\n                    int nx = x + dir[d][0], ny = y + dir[d][1];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m && !isVis[nx][ny]) {\\n                        if (nx == n - 1 && ny == m - 1) {\\n                            if (time + 1 <= fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        } else {\\n                            if (time + 1 < fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        }\\n                        \\n                    }\\n\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dir = { { 0, 1 } ,{ 1, 0 }, { -1, 0 }, { 0, -1 } };\\n        \\n        int[][] fire = setFire(grid, dir);\\n        \\n\\n        \\n        int lo = 0, hi = (int) 1e9;\\n        \\n        while (lo <= hi) {\\n            int mid = ((hi - lo) >> 1) + lo;\\n            if (isPoss(fire, dir, mid)) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return hi;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] setFire(int[][] grid, int[][] dir) {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        int[][] fire = new int[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                fire[i][j] = Integer.MAX_VALUE;\\n                if (grid[i][j] == 1) {\\n                    fire[i][j] = 0;\\n                    bfs.add(i * m + j);\\n                }\\n                if (grid[i][j] == 2) {\\n                    fire[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        while (bfs.size() > 0) {\\n            int rm = bfs.removeFirst();\\n            int x = rm / m, y = rm % m;\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int nx = x + dir[d][0], ny = y + dir[d][1];\\n                if (nx >= 0 && ny >= 0 && nx < n && ny < m && fire[nx][ny] == Integer.MAX_VALUE) {\\n                    fire[nx][ny] = fire[x][y] + 1;\\n                    bfs.add(nx * m + ny);\\n                }\\n            }\\n        }\\n        \\n        return fire;\\n    }\\n    \\n    private boolean isPoss(int[][] fire, int[][] dir, int time) {\\n        if (time >= fire[0][0]) {\\n            return false;\\n        }\\n        \\n        int n = fire.length, m = fire[0].length;\\n        \\n        ArrayDeque<Integer> bfs = new ArrayDeque<>();\\n        \\n        bfs.add(0);\\n        \\n        boolean[][] isVis = new boolean[n][m];\\n        \\n        isVis[0][0] = true;\\n        \\n        while (bfs.size() > 0) {\\n            int size = bfs.size();\\n            while (size-- > 0) {\\n                int rm = bfs.removeFirst();\\n                int x = rm / m, y = rm % m;\\n                \\n                if (x == n - 1 && y == m - 1) {\\n                    return true;\\n                }\\n                \\n                for (int d = 0; d < 4; d++) {\\n                    int nx = x + dir[d][0], ny = y + dir[d][1];\\n                    if (nx >= 0 && ny >= 0 && nx < n && ny < m && !isVis[nx][ny]) {\\n                        if (nx == n - 1 && ny == m - 1) {\\n                            if (time + 1 <= fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        } else {\\n                            if (time + 1 < fire[nx][ny]) {\\n                                isVis[nx][ny] = true;\\n                                bfs.add(nx * m + ny);\\n                            }\\n                        }\\n                        \\n                    }\\n\\n                }\\n            }\\n            \\n            time++;\\n        }\\n        \\n        return false;\\n        \\n        \\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] dir = { { 0, 1 } ,{ 1, 0 }, { -1, 0 }, { 0, -1 } };\\n        \\n        int[][] fire = setFire(grid, dir);\\n        \\n\\n        \\n        int lo = 0, hi = (int) 1e9;\\n        \\n        while (lo <= hi) {\\n            int mid = ((hi - lo) >> 1) + lo;\\n            if (isPoss(fire, dir, mid)) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        return hi;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026311,
                "title": "java-not-the-best-but-intutive-solution",
                "content": "```\\nclass Solution {\\n    int min=Integer.MIN_VALUE;\\n    boolean isReachable=false;\\n    boolean[][] visited;\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        visited=new boolean[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=3;\\n                    dfs(i,j,grid,3);\\n                }\\n            }\\n        }\\n        helper(0,0,grid,Integer.MAX_VALUE,3);\\n        return !isReachable?-1:min==1_000_000_000?min:min;\\n    }\\n    \\n    private void helper(int x,int y,int[][] grid,int minTime,int pathTime){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2 || visited[x][y]){\\n            return;\\n        }\\n        visited[x][y]=true;\\n        if(x==m-1 && y==n-1){\\n            visited[x][y]=false;\\n            int temp = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime),minTime);\\n            min = Math.max(temp,min);\\n            isReachable=true;\\n            return;\\n        }\\n        else if(grid[x][y]>=3 && grid[x][y]<=pathTime){\\n            return;\\n        }\\n        int time = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime-1),minTime);\\n        \\n        helper(x+1,y,grid,time,pathTime+1);\\n        helper(x,y+1,grid,time,pathTime+1);\\n        helper(x-1,y,grid,time,pathTime+1);\\n        helper(x,y-1,grid,time,pathTime+1);\\n    }\\n    \\n    private void dfs(int x,int y,int[][] grid,int time){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2){\\n            return;\\n        }\\n        if(grid[x][y]==0){\\n            grid[x][y]=time;\\n        }\\n        else if(grid[x][y]<time){\\n            return;\\n        }\\n        grid[x][y]=time;\\n        time+=1;\\n        dfs(x+1,y,grid,time);\\n        dfs(x,y+1,grid,time);\\n        dfs(x-1,y,grid,time);\\n        dfs(x,y-1,grid,time);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int min=Integer.MIN_VALUE;\\n    boolean isReachable=false;\\n    boolean[][] visited;\\n    public int maximumMinutes(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        visited=new boolean[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=3;\\n                    dfs(i,j,grid,3);\\n                }\\n            }\\n        }\\n        helper(0,0,grid,Integer.MAX_VALUE,3);\\n        return !isReachable?-1:min==1_000_000_000?min:min;\\n    }\\n    \\n    private void helper(int x,int y,int[][] grid,int minTime,int pathTime){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2 || visited[x][y]){\\n            return;\\n        }\\n        visited[x][y]=true;\\n        if(x==m-1 && y==n-1){\\n            visited[x][y]=false;\\n            int temp = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime),minTime);\\n            min = Math.max(temp,min);\\n            isReachable=true;\\n            return;\\n        }\\n        else if(grid[x][y]>=3 && grid[x][y]<=pathTime){\\n            return;\\n        }\\n        int time = Math.min(grid[x][y]==0?1_000_000_000:(grid[x][y]-pathTime-1),minTime);\\n        \\n        helper(x+1,y,grid,time,pathTime+1);\\n        helper(x,y+1,grid,time,pathTime+1);\\n        helper(x-1,y,grid,time,pathTime+1);\\n        helper(x,y-1,grid,time,pathTime+1);\\n    }\\n    \\n    private void dfs(int x,int y,int[][] grid,int time){\\n        int m=grid.length,n=grid[0].length;\\n        \\n        \\n        if(x<0||x>=m||y<0||y>=n || grid[x][y]==2){\\n            return;\\n        }\\n        if(grid[x][y]==0){\\n            grid[x][y]=time;\\n        }\\n        else if(grid[x][y]<time){\\n            return;\\n        }\\n        grid[x][y]=time;\\n        time+=1;\\n        dfs(x+1,y,grid,time);\\n        dfs(x,y+1,grid,time);\\n        dfs(x-1,y,grid,time);\\n        dfs(x,y-1,grid,time);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020197,
                "title": "easy-to-understand-c-17-bfs-and-binary-search",
                "content": "### Easy to understand C++17, BFS and binary search\\n\\n The core idea is to augment the original graph with extra info from\\n the spreading fires. Then we do BFS to simulate the escaping player.\\n \\n * Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n   Now we have a new graph based on the grid but is also augmented by\\n   the fire timing info and the wait time.\\n   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n   More precisely, this condition should be true if the player wants to enter the cell:\\n      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n   In graph terminology, this basically determines whether there is\\n   an edge between two vertices.\\n   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n   then the player can escape even if the player delays the escape by the wait-time.\\n   \\n * Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n   between the range of `can Escape` and `cannot Escape`.\\n\\n\\n```\\n// 2258. Escape the Spreading Fire\\n// Approach / Idea:\\n// The core idea is to augment the original graph with extra info from\\n// the spreading fires. Then we do BFS to simulate the escaping player.\\n//\\n// Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n//   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n//   Now we have a new graph based on the grid but is also augmented by\\n//   the fire timing info and the wait time.\\n//   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n//   More precisely, this condition should be true if the player wants to enter the cell:\\n//      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n//   In graph terminology, this basically determines whether there is\\n//   an edge between two vertices.\\n//   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n//   then the player can escape even if the player delays the escape by the wait-time.\\n// Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n//   between the range of `can Escape` and `cannot Escape`.\\n//\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int nRows = grid.size(), nCols = grid[0].size();\\n        // F: fire spreading timing map\\n        auto fireTimingMap = bfsForFire(grid);\\n        if (!canEscape(0, fireTimingMap, grid)) {\\n            return -1;\\n        }\\n\\n        const int MaxPossibleTime = nRows * nCols + 1;\\n        if (canEscape(MaxPossibleTime, fireTimingMap, grid)) {\\n            return BigNumber;\\n        }\\n        // high- and low-bound of the wait time\\n        int high = MaxPossibleTime - 1;\\n        int low = 1;\\n        int maxWaitTime = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (canEscape(mid, fireTimingMap, grid)) {\\n                maxWaitTime = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return maxWaitTime;\\n    }\\n\\nprivate:\\n    constexpr static const int BigNumber = 1\\'000\\'000\\'000;\\n    constexpr static const int NotVisitedYet = INT_MAX;\\n    constexpr static const int WallCell = 2;\\n    constexpr static const int FireCell = 1;\\n    constexpr static const int Deltas[]{1, 0, -1, 0, 1};\\n\\n    /// \\\\brief can the player escape if the player deliberately waits the specified time at the\\n    /// starting cell?\\n    static bool canEscape(\\n            const int waitTime,\\n            const vector<vector<int>>& fireTimingMap,\\n            const vector<vector<int>>& g) {\\n        // bfs -- the goal is the safe house at [nRows-1][nCols-1]\\n        const int nRows = g.size(), nCols = g[0].size();\\n        // timing map for the player.\\n        // playerTimingMap[r][c] is the timestamp that the player enters the cell at [r][c].\\n        vector<vector<int>> playerTimingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        playerTimingMap[0][0] = waitTime;\\n        q.emplace(0, 0);\\n        while (!q.empty()) {\\n            auto pos = q.front();\\n            q.pop();\\n\\n            // explore the four neighbor cells.\\n            int newTime = playerTimingMap[pos.first][pos.second] + 1;\\n            for (int i = 1; i <= 4; ++i) {\\n                int r = pos.first + Deltas[i - 1];\\n                int c = pos.second + Deltas[i];\\n                // reached the safe house?\\n                // special rule: Note that even if the fire spreads to the safehouse immediately\\n                // after you have reached it, it will be counted as safely reaching the safehouse.\\n                if (r == nRows - 1 && c == nCols - 1 //\\n                    && newTime <= fireTimingMap[r][c]) {\\n                    return true; // escaped successfully.\\n                }\\n\\n                if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                    && playerTimingMap[r][c] == NotVisitedYet // not visited yet\\n                    && g[r][c] != WallCell // not wall\\n                    && newTime < fireTimingMap[r][c] // before fire reaches the cell\\n                ) {\\n                    playerTimingMap[r][c] = newTime;\\n                    q.emplace(r, c); // enqueue the new cell.\\n                }\\n            }\\n        }\\n        return false; // failed to escape\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map for the fire\\n    static vector<vector<int>> bfsForFire(const vector<vector<int>>& g) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<pair<int, int>> startingCells;\\n\\n        // extract the cells of fire from the grid g\\n        for (int r = 0; r < nRows; ++r) {\\n            for (int c = 0; c < nCols; ++c) {\\n                if (g[r][c] == FireCell) {\\n                    startingCells.emplace_back(r, c);\\n                }\\n            }\\n        }\\n        auto timingMap = bfsCore(g, startingCells);\\n        return timingMap;\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map\\n    static vector<vector<int>>\\n    bfsCore(const vector<vector<int>>& g, const vector<pair<int, int>>& startingCells) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<vector<int>> timingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        for (auto& pos : startingCells) {\\n            timingMap[pos.first][pos.second] = 0;\\n            q.emplace(pos);\\n        }\\n        int ts = 0; // current timestamp\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            ++ts;\\n            while (sz--) {\\n                auto pos = q.front();\\n                q.pop();\\n                // explore the four neighbor cells\\n                for (int i = 1; i <= 4; ++i) {\\n                    int r = pos.first + Deltas[i - 1];\\n                    int c = pos.second + Deltas[i];\\n                    if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                        && timingMap[r][c] == NotVisitedYet // not visited yet\\n                        && g[r][c] != WallCell) { // not wall\\n                        timingMap[r][c] = ts;\\n                        q.emplace(r, c);\\n                    }\\n                }\\n            }\\n        }\\n        return timingMap;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// 2258. Escape the Spreading Fire\\n// Approach / Idea:\\n// The core idea is to augment the original graph with extra info from\\n// the spreading fires. Then we do BFS to simulate the escaping player.\\n//\\n// Step 1. doing a BFS to figure out the timing map for the spread of the fire.\\n//   Let fireTimingMap[i][j] be the timestamp that the fire reaches a cell.\\n//   Now we have a new graph based on the grid but is also augmented by\\n//   the fire timing info and the wait time.\\n//   Intuitively, the player has to pass through a cell [r][c] before the fire reaches the cell.\\n//   More precisely, this condition should be true if the player wants to enter the cell:\\n//      `playerTimingMap[r][c] < fireTimingMap[r][c]`.\\n//   In graph terminology, this basically determines whether there is\\n//   an edge between two vertices.\\n//   If there is a path (in the augmented graph) from [0][0] to the safe house,\\n//   then the player can escape even if the player delays the escape by the wait-time.\\n// Step 2. Doing binary-search to find the maximum wait-time which sits at the boundary\\n//   between the range of `can Escape` and `cannot Escape`.\\n//\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int nRows = grid.size(), nCols = grid[0].size();\\n        // F: fire spreading timing map\\n        auto fireTimingMap = bfsForFire(grid);\\n        if (!canEscape(0, fireTimingMap, grid)) {\\n            return -1;\\n        }\\n\\n        const int MaxPossibleTime = nRows * nCols + 1;\\n        if (canEscape(MaxPossibleTime, fireTimingMap, grid)) {\\n            return BigNumber;\\n        }\\n        // high- and low-bound of the wait time\\n        int high = MaxPossibleTime - 1;\\n        int low = 1;\\n        int maxWaitTime = 0;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (canEscape(mid, fireTimingMap, grid)) {\\n                maxWaitTime = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return maxWaitTime;\\n    }\\n\\nprivate:\\n    constexpr static const int BigNumber = 1\\'000\\'000\\'000;\\n    constexpr static const int NotVisitedYet = INT_MAX;\\n    constexpr static const int WallCell = 2;\\n    constexpr static const int FireCell = 1;\\n    constexpr static const int Deltas[]{1, 0, -1, 0, 1};\\n\\n    /// \\\\brief can the player escape if the player deliberately waits the specified time at the\\n    /// starting cell?\\n    static bool canEscape(\\n            const int waitTime,\\n            const vector<vector<int>>& fireTimingMap,\\n            const vector<vector<int>>& g) {\\n        // bfs -- the goal is the safe house at [nRows-1][nCols-1]\\n        const int nRows = g.size(), nCols = g[0].size();\\n        // timing map for the player.\\n        // playerTimingMap[r][c] is the timestamp that the player enters the cell at [r][c].\\n        vector<vector<int>> playerTimingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        playerTimingMap[0][0] = waitTime;\\n        q.emplace(0, 0);\\n        while (!q.empty()) {\\n            auto pos = q.front();\\n            q.pop();\\n\\n            // explore the four neighbor cells.\\n            int newTime = playerTimingMap[pos.first][pos.second] + 1;\\n            for (int i = 1; i <= 4; ++i) {\\n                int r = pos.first + Deltas[i - 1];\\n                int c = pos.second + Deltas[i];\\n                // reached the safe house?\\n                // special rule: Note that even if the fire spreads to the safehouse immediately\\n                // after you have reached it, it will be counted as safely reaching the safehouse.\\n                if (r == nRows - 1 && c == nCols - 1 //\\n                    && newTime <= fireTimingMap[r][c]) {\\n                    return true; // escaped successfully.\\n                }\\n\\n                if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                    && playerTimingMap[r][c] == NotVisitedYet // not visited yet\\n                    && g[r][c] != WallCell // not wall\\n                    && newTime < fireTimingMap[r][c] // before fire reaches the cell\\n                ) {\\n                    playerTimingMap[r][c] = newTime;\\n                    q.emplace(r, c); // enqueue the new cell.\\n                }\\n            }\\n        }\\n        return false; // failed to escape\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map for the fire\\n    static vector<vector<int>> bfsForFire(const vector<vector<int>>& g) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<pair<int, int>> startingCells;\\n\\n        // extract the cells of fire from the grid g\\n        for (int r = 0; r < nRows; ++r) {\\n            for (int c = 0; c < nCols; ++c) {\\n                if (g[r][c] == FireCell) {\\n                    startingCells.emplace_back(r, c);\\n                }\\n            }\\n        }\\n        auto timingMap = bfsCore(g, startingCells);\\n        return timingMap;\\n    }\\n\\n    /// \\\\brief Use BFS to determine the timing map\\n    static vector<vector<int>>\\n    bfsCore(const vector<vector<int>>& g, const vector<pair<int, int>>& startingCells) {\\n        const int nRows = g.size(), nCols = g[0].size();\\n        vector<vector<int>> timingMap(nRows, vector<int>(nCols, NotVisitedYet));\\n\\n        queue<pair<int, int>> q;\\n        for (auto& pos : startingCells) {\\n            timingMap[pos.first][pos.second] = 0;\\n            q.emplace(pos);\\n        }\\n        int ts = 0; // current timestamp\\n        while (!q.empty()) {\\n            auto sz = q.size();\\n            ++ts;\\n            while (sz--) {\\n                auto pos = q.front();\\n                q.pop();\\n                // explore the four neighbor cells\\n                for (int i = 1; i <= 4; ++i) {\\n                    int r = pos.first + Deltas[i - 1];\\n                    int c = pos.second + Deltas[i];\\n                    if (0 <= r && r < nRows && 0 <= c && c < nCols // within the grid\\n                        && timingMap[r][c] == NotVisitedYet // not visited yet\\n                        && g[r][c] != WallCell) { // not wall\\n                        timingMap[r][c] = ts;\\n                        q.emplace(r, c);\\n                    }\\n                }\\n            }\\n        }\\n        return timingMap;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017200,
                "title": "c-bfs-solution",
                "content": "Runtime: 82 ms, faster than 86.72% of C++ online submissions for Escape the Spreading Fire.\\nMemory Usage: 22.6 MB, less than 75.55% of C++ online submissions for Escape the Spreading Fire.\\n\\n```\\n1. Run BFS from all fire cell and store the time for fire to reach in each grass cell\\n2. Run BFS from [0,0] and calculate the minimum time till get burned in each fire cell or grass cell\\n3. Minimum time till get burned in each cell => fire spread time in current cell - level -1\\n4. In case of  [m-1,n-1] cell we do not duduct 1 from fire spread time as we can safely reach even if it is on fire\\n5. In case of grass cell just pass the current cell time\\n6. When reached to [m-1,n-1] cell from different cell, take the max time among them\\n7. If we can reach [m-1,n-1] and initialTime==0 then we can wait 10^9 time, otherwise wait max time \\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int wall = 2;\\n        int fire = 1;\\n        int grass = 0;\\n        int rows[4] = {1,-1,0,0};\\n        int cols[4] = {0,0,1,-1};\\n        \\n        // store the fire spread time in each cell\\n        vector<vector<int>>times(m,vector<int>(n,0));\\n        \\n        // add all fire cell in to queue\\n        queue<pair<int,int>>Q;        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j]==fire)\\n                    Q.push({i,j});\\n\\n        \\n        \\n        int size;\\n        int level = 0;\\n        int x,y,nx,ny;\\n        \\n        // run level order BFS to find the fire spread time in each grass cell\\n        while(!Q.empty())\\n        {\\n            size = Q.size();\\n            while(size--)\\n            {\\n                x = Q.front().first;\\n                y = Q.front().second;\\n                Q.pop();\\n                \\n                times[x][y] = level; \\n                \\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n                    \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==grass)\\n                    {\\n                        grid[nx][ny] = fire;\\n                        Q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n\\n        int time,ntime;\\n        int maxTime = -1;   // max time we can wait\\n        bool reached = false;\\n        int initialTime = times[0][0];  // initial cell wait time\\n        \\n        // push the initial cell and initial wait time\\n        queue<vector<int>>q;\\n        q.push({0,0,times[0][0]});\\n        times[0][0] = INT_MAX;\\n        level = 1;\\n        \\n        // run level order BFS from (0,0) and find the max wait time to reach (m-1,n-1)\\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            while(size--)\\n            {\\n                x = q.front()[0];\\n                y = q.front()[1];\\n                time = q.front()[2];\\n                q.pop();\\n\\n                // reached destination then update the maxTime\\n                if((x==m-1 && y==n-1))\\n                {\\n                    reached = true;\\n                    maxTime = max(time,maxTime);\\n                    continue;\\n                }\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n\\n                    // visit only unvisited grass or fire cell which has fire spread time > 0 \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && times[nx][ny]<INT_MAX && (grid[nx][ny]==grass || (grid[nx][ny]==fire && times[nx][ny]>0)))\\n                    {\\n                        ntime = time;\\n                        \\n                        if(grid[nx][ny]==fire && times[nx][ny]>0)\\n                        {\\n                            // wait time => min(previous wait time, fire spread time - level -1)\\n                            // in case of destination cell ignore -1 cause we can safely reach it even if it is on fire\\n                            \\n                            if(nx==m-1 && ny==n-1) ntime = min(time,times[nx][ny]-level);\\n                            else ntime = min(time,times[nx][ny]-level-1);\\n                        }\\n\\n                        // push non-negative waiting time cells\\n                        if(ntime>=0)q.push({nx,ny,ntime});\\n\\n                        // mark all cells visited except destination cell\\n                        if(!(nx==m-1 && ny==n-1))times[nx][ny] = INT_MAX;\\n                    }\\n                }                   \\n            }\\n            \\n            level++;\\n        }\\n\\n        // if reached and initialTime==0 then we can wait as long as we want, otherwise maxTime\\n        return ((reached && initialTime==0) ? 1000000000 : maxTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n1. Run BFS from all fire cell and store the time for fire to reach in each grass cell\\n2. Run BFS from [0,0] and calculate the minimum time till get burned in each fire cell or grass cell\\n3. Minimum time till get burned in each cell => fire spread time in current cell - level -1\\n4. In case of  [m-1,n-1] cell we do not duduct 1 from fire spread time as we can safely reach even if it is on fire\\n5. In case of grass cell just pass the current cell time\\n6. When reached to [m-1,n-1] cell from different cell, take the max time among them\\n7. If we can reach [m-1,n-1] and initialTime==0 then we can wait 10^9 time, otherwise wait max time \\n```\n```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int wall = 2;\\n        int fire = 1;\\n        int grass = 0;\\n        int rows[4] = {1,-1,0,0};\\n        int cols[4] = {0,0,1,-1};\\n        \\n        // store the fire spread time in each cell\\n        vector<vector<int>>times(m,vector<int>(n,0));\\n        \\n        // add all fire cell in to queue\\n        queue<pair<int,int>>Q;        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                if(grid[i][j]==fire)\\n                    Q.push({i,j});\\n\\n        \\n        \\n        int size;\\n        int level = 0;\\n        int x,y,nx,ny;\\n        \\n        // run level order BFS to find the fire spread time in each grass cell\\n        while(!Q.empty())\\n        {\\n            size = Q.size();\\n            while(size--)\\n            {\\n                x = Q.front().first;\\n                y = Q.front().second;\\n                Q.pop();\\n                \\n                times[x][y] = level; \\n                \\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n                    \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==grass)\\n                    {\\n                        grid[nx][ny] = fire;\\n                        Q.push({nx,ny});\\n                    }\\n                }\\n            }\\n            \\n            level++;\\n        }\\n        \\n        \\n\\n        int time,ntime;\\n        int maxTime = -1;   // max time we can wait\\n        bool reached = false;\\n        int initialTime = times[0][0];  // initial cell wait time\\n        \\n        // push the initial cell and initial wait time\\n        queue<vector<int>>q;\\n        q.push({0,0,times[0][0]});\\n        times[0][0] = INT_MAX;\\n        level = 1;\\n        \\n        // run level order BFS from (0,0) and find the max wait time to reach (m-1,n-1)\\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            while(size--)\\n            {\\n                x = q.front()[0];\\n                y = q.front()[1];\\n                time = q.front()[2];\\n                q.pop();\\n\\n                // reached destination then update the maxTime\\n                if((x==m-1 && y==n-1))\\n                {\\n                    reached = true;\\n                    maxTime = max(time,maxTime);\\n                    continue;\\n                }\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    nx = x + rows[i];\\n                    ny = y + cols[i];\\n\\n                    // visit only unvisited grass or fire cell which has fire spread time > 0 \\n                    if(nx>=0 && nx<m && ny>=0 && ny<n && times[nx][ny]<INT_MAX && (grid[nx][ny]==grass || (grid[nx][ny]==fire && times[nx][ny]>0)))\\n                    {\\n                        ntime = time;\\n                        \\n                        if(grid[nx][ny]==fire && times[nx][ny]>0)\\n                        {\\n                            // wait time => min(previous wait time, fire spread time - level -1)\\n                            // in case of destination cell ignore -1 cause we can safely reach it even if it is on fire\\n                            \\n                            if(nx==m-1 && ny==n-1) ntime = min(time,times[nx][ny]-level);\\n                            else ntime = min(time,times[nx][ny]-level-1);\\n                        }\\n\\n                        // push non-negative waiting time cells\\n                        if(ntime>=0)q.push({nx,ny,ntime});\\n\\n                        // mark all cells visited except destination cell\\n                        if(!(nx==m-1 && ny==n-1))times[nx][ny] = INT_MAX;\\n                    }\\n                }                   \\n            }\\n            \\n            level++;\\n        }\\n\\n        // if reached and initialTime==0 then we can wait as long as we want, otherwise maxTime\\n        return ((reached && initialTime==0) ? 1000000000 : maxTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015510,
                "title": "c-solution",
                "content": "```\\nvoid MAN(int** grid, int x, int y, int human_step, int i, int j, int* human, int* hx, int* hy){\\n    if (i+1 <= x && grid[i+1][j] == 0){\\n        grid[i+1][j] = human_step;\\n        hx[*human] = i+1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] == 0){\\n        grid[i-1][j] = human_step;\\n        hx[*human] = i-1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] == 0){\\n        grid[i][j+1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j+1;\\n        *human += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] == 0){\\n        grid[i][j-1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j-1;\\n        *human += 1;\\n    }\\n}\\n\\nvoid FIRE(int** grid, int x, int y, int fire_stap, int i, int j, int* fire, int* fx, int* fy){\\n    if (i+1 <= x && grid[i+1][j] <= 0){\\n        grid[i+1][j] = fire_stap;\\n        fx[*fire] = i+1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] <= 0){\\n        grid[i-1][j] = fire_stap;\\n        fx[*fire] = i-1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] <= 0){\\n        grid[i][j+1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j+1;\\n        *fire += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] <= 0){\\n        grid[i][j-1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j-1;\\n        *fire += 1;\\n    }\\n}\\n\\n\\nvoid H_next_minutes(int** grid, int x, int y, int human_step, int* human, int* end, int* hx, int* hy, int last_h){\\n    int a = *human;\\n    for (int i = last_h ; i < a ; i++){\\n        if (grid[hx[i]][hy[i]] == human_step){\\n            MAN(grid, x, y, human_step-1, hx[i], hy[i], human, hx, hy);\\n        }\\n    }\\n    if (grid[x][y] != 0){\\n        *end = grid[x][y];\\n    }\\n}\\n\\nvoid F_next_minutes(int** grid, int x, int y,  int fire_stap, int* fire, int* fx, int* fy, int last_f){\\n    int a = *fire;\\n    for (int i = last_f ; i < a ; i++){\\n        FIRE(grid, x, y, fire_stap+1, fx[i], fy[i], fire, fx, fy);\\n    }\\n}\\n\\nint maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }\\n    if (grid[1][0] == 0){\\n        grid[1][0] = human_step;\\n        hx[human] = 1;\\n        hy[human] = 0;\\n        human++;\\n    }\\n    for (int i = 0 ; i < gridSize ; i++){\\n        for (int j = 0 ; j < *gridColSize ; j++){\\n            if (grid[i][j] == 1){\\n                FIRE(grid, x, y, fire_stap, i, j, &fire, fx, fy);\\n            }\\n        }\\n    }\\n    \\n    int last_h = 0;\\n    int last_f = 0;\\n    while (grid[x][y] <= 0) {\\n        int copyhuman = human;\\n        int copyfire = fire;\\n        if (grid[x][y]== 0){\\n            H_next_minutes(grid, x, y, human_step, &human, &end, hx, hy, last_h);\\n            if ((human == last_h)){\\n                return -1;\\n            }\\n        }\\n        F_next_minutes(grid, x, y, fire_stap, &fire, fx, fy, last_f);\\n        if (grid[x][y] > 0){\\n            if (end == 0){\\n                return -1;\\n            } else {\\n                if (grid[x-1][y] == end+1 || grid[x][y-1] == end+1){\\n                    return grid[x][y]+end-2;\\n                }\\n                return grid[x][y]+end-3;\\n            }\\n        }\\n        if (fire == last_f && grid[x][y] < 0){\\n            return 1000000000;\\n        }\\n        fire_stap++;\\n        human_step--;\\n        last_h = copyhuman;\\n        last_f = copyfire;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid MAN(int** grid, int x, int y, int human_step, int i, int j, int* human, int* hx, int* hy){\\n    if (i+1 <= x && grid[i+1][j] == 0){\\n        grid[i+1][j] = human_step;\\n        hx[*human] = i+1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] == 0){\\n        grid[i-1][j] = human_step;\\n        hx[*human] = i-1;\\n        hy[*human] = j;\\n        *human += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] == 0){\\n        grid[i][j+1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j+1;\\n        *human += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] == 0){\\n        grid[i][j-1] = human_step;\\n        hx[*human] = i;\\n        hy[*human] = j-1;\\n        *human += 1;\\n    }\\n}\\n\\nvoid FIRE(int** grid, int x, int y, int fire_stap, int i, int j, int* fire, int* fx, int* fy){\\n    if (i+1 <= x && grid[i+1][j] <= 0){\\n        grid[i+1][j] = fire_stap;\\n        fx[*fire] = i+1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (i-1 >= 0 && grid[i-1][j] <= 0){\\n        grid[i-1][j] = fire_stap;\\n        fx[*fire] = i-1;\\n        fy[*fire] = j;\\n        *fire += 1;\\n    }\\n    if (j+1 <= y && grid[i][j+1] <= 0){\\n        grid[i][j+1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j+1;\\n        *fire += 1;\\n    }\\n    if (j-1 >= 0 && grid[i][j-1] <= 0){\\n        grid[i][j-1] = fire_stap;\\n        fx[*fire] = i;\\n        fy[*fire] = j-1;\\n        *fire += 1;\\n    }\\n}\\n\\n\\nvoid H_next_minutes(int** grid, int x, int y, int human_step, int* human, int* end, int* hx, int* hy, int last_h){\\n    int a = *human;\\n    for (int i = last_h ; i < a ; i++){\\n        if (grid[hx[i]][hy[i]] == human_step){\\n            MAN(grid, x, y, human_step-1, hx[i], hy[i], human, hx, hy);\\n        }\\n    }\\n    if (grid[x][y] != 0){\\n        *end = grid[x][y];\\n    }\\n}\\n\\nvoid F_next_minutes(int** grid, int x, int y,  int fire_stap, int* fire, int* fx, int* fy, int last_f){\\n    int a = *fire;\\n    for (int i = last_f ; i < a ; i++){\\n        FIRE(grid, x, y, fire_stap+1, fx[i], fy[i], fire, fx, fy);\\n    }\\n}\\n\\nint maximumMinutes(int** grid, int gridSize, int* gridColSize){\\n    int human = 0;\\n    int hx[10000];\\n    int hy[10000];\\n    \\n    int fire = 0;\\n    int fx[10000];\\n    int fy[10000];\\n    \\n    int human_step = -1;\\n    int fire_stap = 3;\\n\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    int end = 0;\\n    \\n    if (grid[0][1] == 0){\\n        grid[0][1] = human_step;\\n        hx[human] = 0;\\n        hy[human] = 1;\\n        human++;\\n    }\\n    if (grid[1][0] == 0){\\n        grid[1][0] = human_step;\\n        hx[human] = 1;\\n        hy[human] = 0;\\n        human++;\\n    }\\n    for (int i = 0 ; i < gridSize ; i++){\\n        for (int j = 0 ; j < *gridColSize ; j++){\\n            if (grid[i][j] == 1){\\n                FIRE(grid, x, y, fire_stap, i, j, &fire, fx, fy);\\n            }\\n        }\\n    }\\n    \\n    int last_h = 0;\\n    int last_f = 0;\\n    while (grid[x][y] <= 0) {\\n        int copyhuman = human;\\n        int copyfire = fire;\\n        if (grid[x][y]== 0){\\n            H_next_minutes(grid, x, y, human_step, &human, &end, hx, hy, last_h);\\n            if ((human == last_h)){\\n                return -1;\\n            }\\n        }\\n        F_next_minutes(grid, x, y, fire_stap, &fire, fx, fy, last_f);\\n        if (grid[x][y] > 0){\\n            if (end == 0){\\n                return -1;\\n            } else {\\n                if (grid[x-1][y] == end+1 || grid[x][y-1] == end+1){\\n                    return grid[x][y]+end-2;\\n                }\\n                return grid[x][y]+end-3;\\n            }\\n        }\\n        if (fire == last_f && grid[x][y] < 0){\\n            return 1000000000;\\n        }\\n        fire_stap++;\\n        human_step--;\\n        last_h = copyhuman;\\n        last_f = copyfire;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2014204,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # time to burn initiate to infinity\\n        t_burn = [[math.inf for i in range(n)] for j in range(m)]\\n        \\n        def inbox(i, j, m=m, n=n):\\n            return 0 <= i < m and 0 <= j < n and grid[i][j] != 2\\n        \\n        # first collect all of intial fires \\n        # set time to burn to zero\\n        temp = set()\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    temp.add((r,c))\\n                    t_burn[r][c] = 0\\n                    \\n        flag = True\\n        while flag:\\n            # if new fire gets ignited based on the last frame continue\\n            # finding new fire locs, else break out\\n            flag = False\\n            new_temp = set()\\n            # find fire in the next min based on last time\\'s fire locs\\n            \\n            for r,c in temp:\\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    # only add fires if they are new (do not let fires ignited by the same spot get back to reignite it)\\n                    if inbox(i, j)and t_burn[i][j] > t_burn[r][c]+1:\\n                        t_burn[i][j] = t_burn[r][c]+1\\n                        flag = True\\n                        new_temp.add((i,j))\\n            temp = new_temp.difference(temp)\\n        \\n        def bfs(r,c, t):\\n            \\n            q = deque([(r,c, t)])\\n            visited = set()\\n            while q:\\n                (r,c, cur) = q.popleft()\\n                if (r, c) == (m-1, n-1):\\n                    return True\\n                if cur >= t_burn[r][c]:\\n                    continue\\n                if (r,c) in visited:\\n                    continue\\n                visited.add((r, c))\\n                \\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    if inbox(i, j) and (i,j) not in visited and cur + 1 <= t_burn[i][j]:\\n                        q.append((i,j, cur + 1))\\n                        \\n            return False\\n        # if 0 is not answer return -1\\n        if bfs(0,0, 0) == False:\\n            return -1\\n        \\n        l = 0\\n        r = min(t_burn[-1][-1] + 1, t_burn[0][0], m * n)\\n        # if max time is an answer return 10**9\\n        \\n        \\n        if bfs(0, 0, r+1):\\n            return 10**9\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if bfs(0,0, mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        # print(l, mid, r)\\n        return  r\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # time to burn initiate to infinity\\n        t_burn = [[math.inf for i in range(n)] for j in range(m)]\\n        \\n        def inbox(i, j, m=m, n=n):\\n            return 0 <= i < m and 0 <= j < n and grid[i][j] != 2\\n        \\n        # first collect all of intial fires \\n        # set time to burn to zero\\n        temp = set()\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1:\\n                    temp.add((r,c))\\n                    t_burn[r][c] = 0\\n                    \\n        flag = True\\n        while flag:\\n            # if new fire gets ignited based on the last frame continue\\n            # finding new fire locs, else break out\\n            flag = False\\n            new_temp = set()\\n            # find fire in the next min based on last time\\'s fire locs\\n            \\n            for r,c in temp:\\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    # only add fires if they are new (do not let fires ignited by the same spot get back to reignite it)\\n                    if inbox(i, j)and t_burn[i][j] > t_burn[r][c]+1:\\n                        t_burn[i][j] = t_burn[r][c]+1\\n                        flag = True\\n                        new_temp.add((i,j))\\n            temp = new_temp.difference(temp)\\n        \\n        def bfs(r,c, t):\\n            \\n            q = deque([(r,c, t)])\\n            visited = set()\\n            while q:\\n                (r,c, cur) = q.popleft()\\n                if (r, c) == (m-1, n-1):\\n                    return True\\n                if cur >= t_burn[r][c]:\\n                    continue\\n                if (r,c) in visited:\\n                    continue\\n                visited.add((r, c))\\n                \\n                for step in [(1,0),(0, 1), (-1, 0),(0,-1)]:\\n                    i = r + step[0]\\n                    j = c + step[1]\\n                    if inbox(i, j) and (i,j) not in visited and cur + 1 <= t_burn[i][j]:\\n                        q.append((i,j, cur + 1))\\n                        \\n            return False\\n        # if 0 is not answer return -1\\n        if bfs(0,0, 0) == False:\\n            return -1\\n        \\n        l = 0\\n        r = min(t_burn[-1][-1] + 1, t_burn[0][0], m * n)\\n        # if max time is an answer return 10**9\\n        \\n        \\n        if bfs(0, 0, r+1):\\n            return 10**9\\n        \\n        while l <= r:\\n            mid = (l+r)//2\\n            if bfs(0,0, mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        # print(l, mid, r)\\n        return  r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013874,
                "title": "c-bfs-dynamic-programming-how-does-binary-search-apply-lol",
                "content": "I\\'ll write an explanation solution later.\\n\\n```cpp\\n#define all(x) begin(x), end(x)\\n#define amin(x, y) x = min(x, y)\\n#define amax(x, y) x = max(x, y)\\n#define umap unordered_map\\n#define uset unordered_set\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<bool>> vis1(m, vector<bool>(n));\\n    vector<vector<pii>> vis2(m, vector<pii>(n));\\n    vector<vector<vector<pipii>>> pred(m, vector<vector<pipii>>(n));\\n    deque<pii> q1, q2;\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1)\\n          q2.push_back({i, j});\\n      }\\n    }\\n    q1.push_back({0, 0});\\n    vis1[0][0] = true;\\n\\n    int time = 1;\\n    bool res = false;\\n    while (!q1.empty() || !q2.empty()) {\\n      int sz2 = q2.size();\\n      while (sz2-- > 0) {\\n        auto [r, c] = q2.front();\\n        q2.pop_front();\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2 ||\\n              vis2[r2][c2].first)\\n            continue;\\n          vis2[r2][c2] = {true, time};\\n          q2.push_back({r2, c2});\\n        }\\n      }\\n      int sz1 = q1.size();\\n      while (sz1-- > 0) {\\n        auto [r, c] = q1.front();\\n        q1.pop_front();\\n        if (r == m - 1 && c == n - 1) {\\n          res = true;\\n          continue;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2)\\n            continue;\\n          if (vis1[r2][c2] && (r2 != m - 1 || c2 != n - 1))\\n            continue;\\n          if (vis2[r2][c2].first) {\\n            if (r2 == m - 1 && c2 == n - 1 && vis2[r2][c2].second == time) {\\n            } else {\\n              continue;\\n            }\\n          }\\n          q1.push_back({r2, c2});\\n          vis1[r2][c2] = true;\\n          pred[r2][c2].push_back({time, {r, c}});\\n        }\\n      }\\n      if (q1.empty() && !res)\\n        return -1;\\n      time++;\\n    }\\n\\n    vector<vector<int>> ans(m, vector<int>(n, INT_MIN));\\n    deque<pippiipii> q3;\\n    ans[m - 1][n - 1] = INF;\\n    for (auto &[t, p] : pred[m - 1][n - 1]) {\\n      q3.push_back({t, {p, {m - 1, n - 1}}});\\n    }\\n    while (!q3.empty()) {\\n      int sz = q3.size();\\n      while (sz-- > 0) {\\n        auto [t, p] = q3.front();\\n        auto [pr, pc] = p.first;\\n        auto [r, c] = p.second;\\n        q3.pop_front();\\n        int cur = ans[r][c];\\n        if (vis2[r][c].first) {\\n          if (r == m - 1 && c == n - 1) {\\n            cur = vis2[r][c].second - t;\\n          } else {\\n            amin(cur, vis2[r][c].second - t - 1);\\n          }\\n        }\\n        if (pr == 0 && pc == 0) {\\n          amax(ans[0][0], cur);\\n        } else {\\n          for (auto &[t, p] : pred[pr][pc]) {\\n            amax(ans[pr][pc], cur);\\n            q3.push_back({t, {p, {pr, pc}}});\\n          }\\n        }\\n      }\\n    }\\n    return ans[0][0];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\n#define all(x) begin(x), end(x)\\n#define amin(x, y) x = min(x, y)\\n#define amax(x, y) x = max(x, y)\\n#define umap unordered_map\\n#define uset unordered_set\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\nclass Solution {\\npublic:\\n  int maximumMinutes(vector<vector<int>> &grid) {\\n    int m = grid.size();\\n    int n = grid[0].size();\\n    vector<vector<bool>> vis1(m, vector<bool>(n));\\n    vector<vector<pii>> vis2(m, vector<pii>(n));\\n    vector<vector<vector<pipii>>> pred(m, vector<vector<pipii>>(n));\\n    deque<pii> q1, q2;\\n\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1)\\n          q2.push_back({i, j});\\n      }\\n    }\\n    q1.push_back({0, 0});\\n    vis1[0][0] = true;\\n\\n    int time = 1;\\n    bool res = false;\\n    while (!q1.empty() || !q2.empty()) {\\n      int sz2 = q2.size();\\n      while (sz2-- > 0) {\\n        auto [r, c] = q2.front();\\n        q2.pop_front();\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2 ||\\n              vis2[r2][c2].first)\\n            continue;\\n          vis2[r2][c2] = {true, time};\\n          q2.push_back({r2, c2});\\n        }\\n      }\\n      int sz1 = q1.size();\\n      while (sz1-- > 0) {\\n        auto [r, c] = q1.front();\\n        q1.pop_front();\\n        if (r == m - 1 && c == n - 1) {\\n          res = true;\\n          continue;\\n        }\\n        for (int i = 0; i < 4; i++) {\\n          int r2 = r + dx[i];\\n          int c2 = c + dy[i];\\n          if (r2 < 0 || r2 == m || c2 < 0 || c2 == n || grid[r2][c2] == 2)\\n            continue;\\n          if (vis1[r2][c2] && (r2 != m - 1 || c2 != n - 1))\\n            continue;\\n          if (vis2[r2][c2].first) {\\n            if (r2 == m - 1 && c2 == n - 1 && vis2[r2][c2].second == time) {\\n            } else {\\n              continue;\\n            }\\n          }\\n          q1.push_back({r2, c2});\\n          vis1[r2][c2] = true;\\n          pred[r2][c2].push_back({time, {r, c}});\\n        }\\n      }\\n      if (q1.empty() && !res)\\n        return -1;\\n      time++;\\n    }\\n\\n    vector<vector<int>> ans(m, vector<int>(n, INT_MIN));\\n    deque<pippiipii> q3;\\n    ans[m - 1][n - 1] = INF;\\n    for (auto &[t, p] : pred[m - 1][n - 1]) {\\n      q3.push_back({t, {p, {m - 1, n - 1}}});\\n    }\\n    while (!q3.empty()) {\\n      int sz = q3.size();\\n      while (sz-- > 0) {\\n        auto [t, p] = q3.front();\\n        auto [pr, pc] = p.first;\\n        auto [r, c] = p.second;\\n        q3.pop_front();\\n        int cur = ans[r][c];\\n        if (vis2[r][c].first) {\\n          if (r == m - 1 && c == n - 1) {\\n            cur = vis2[r][c].second - t;\\n          } else {\\n            amin(cur, vis2[r][c].second - t - 1);\\n          }\\n        }\\n        if (pr == 0 && pc == 0) {\\n          amax(ans[0][0], cur);\\n        } else {\\n          for (auto &[t, p] : pred[pr][pc]) {\\n            amax(ans[pr][pc], cur);\\n            q3.push_back({t, {p, {pr, pc}}});\\n          }\\n        }\\n      }\\n    }\\n    return ans[0][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010109,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    int[][] dirs = new int[][] {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] fires = new int[m][n];\\n        for (int[] fire : fires)\\n            Arrays.fill(fire, -1);\\n        \\n        fill(fires, grid, 1);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, fires[0][0] == -1 ? 1000000001 : fires[0][0]});\\n        \\n        boolean[][] visited = new boolean[m][n];\\n\\n        int cnt = 0;\\n        int res = -1;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == m - 1 && cur[1] == n - 1) {\\n                    if (fires[m-1][n-1] != -1) {\\n                        if (fires[m-1][n-1] == cnt) {\\n                            res = Math.max(0, res);\\n                        } else if (fires[m-1][n-1] > cnt) {\\n                            // cur[2] = Math.min(cur[2], fires[m-1][n-1] - cnt);\\n                            res = Math.max(res, Math.min(fires[m-1][n-1] - cnt, cur[2] - 1));\\n                        }\\n                    } else {\\n                        res = Math.max(res, cur[2] - 1);\\n                    }\\n                } else {\\n                    if (cnt >= fires[cur[0]][cur[1]] && fires[cur[0]][cur[1]] != -1)\\n                        continue;\\n                    \\n                    if (visited[cur[0]][cur[1]])\\n                        continue;\\n                    \\n                    for (int[] dir : dirs) {\\n                        int newX = dir[0] + cur[0];\\n                        int newY = dir[1] + cur[1];\\n                        \\n                        if (!(newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] == 2)) {\\n                            if (fires[cur[0]][cur[1]] == -1) {\\n                                queue.add(new int[] {newX, newY, cur[2]});\\n                            } else {\\n                                queue.add(new int[] {newX, newY, Math.min(cur[2], fires[cur[0]][cur[1]] - cnt)});                   \\n                            }\\n                            \\n                        }\\n                    }\\n                }\\n                visited[cur[0]][cur[1]] = true;\\n            }\\n            cnt++;\\n\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void fill(int[][] res, int[][] grid, int target) {\\n        int m = res.length;\\n        int n = res[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == target) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                res[cur[0]][cur[1]] = cnt;\\n                for (int[] dir : dirs) {\\n                    int newX = cur[0] + dir[0];\\n                    int newY = cur[1] + dir[1];\\n                    if (newX < 0 || newX >= m || newY < 0 || newY >= n || res[newX][newY] >= 0 || grid[newX][newY] == 2) {\\n                        continue;\\n                        \\n                    }\\n                    queue.add(new int[] {newX, newY});\\n                }\\n            }\\n            cnt++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = new int[][] {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int[][] fires = new int[m][n];\\n        for (int[] fire : fires)\\n            Arrays.fill(fire, -1);\\n        \\n        fill(fires, grid, 1);\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[] {0, 0, fires[0][0] == -1 ? 1000000001 : fires[0][0]});\\n        \\n        boolean[][] visited = new boolean[m][n];\\n\\n        int cnt = 0;\\n        int res = -1;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == m - 1 && cur[1] == n - 1) {\\n                    if (fires[m-1][n-1] != -1) {\\n                        if (fires[m-1][n-1] == cnt) {\\n                            res = Math.max(0, res);\\n                        } else if (fires[m-1][n-1] > cnt) {\\n                            // cur[2] = Math.min(cur[2], fires[m-1][n-1] - cnt);\\n                            res = Math.max(res, Math.min(fires[m-1][n-1] - cnt, cur[2] - 1));\\n                        }\\n                    } else {\\n                        res = Math.max(res, cur[2] - 1);\\n                    }\\n                } else {\\n                    if (cnt >= fires[cur[0]][cur[1]] && fires[cur[0]][cur[1]] != -1)\\n                        continue;\\n                    \\n                    if (visited[cur[0]][cur[1]])\\n                        continue;\\n                    \\n                    for (int[] dir : dirs) {\\n                        int newX = dir[0] + cur[0];\\n                        int newY = dir[1] + cur[1];\\n                        \\n                        if (!(newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] == 2)) {\\n                            if (fires[cur[0]][cur[1]] == -1) {\\n                                queue.add(new int[] {newX, newY, cur[2]});\\n                            } else {\\n                                queue.add(new int[] {newX, newY, Math.min(cur[2], fires[cur[0]][cur[1]] - cnt)});                   \\n                            }\\n                            \\n                        }\\n                    }\\n                }\\n                visited[cur[0]][cur[1]] = true;\\n            }\\n            cnt++;\\n\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void fill(int[][] res, int[][] grid, int target) {\\n        int m = res.length;\\n        int n = res[0].length;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == target) {\\n                    queue.add(new int[] {i, j});\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        while (!queue.isEmpty()) {\\n            int length = queue.size();\\n            for (int i = 0; i < length; i++) {\\n                int[] cur = queue.poll();\\n                res[cur[0]][cur[1]] = cnt;\\n                for (int[] dir : dirs) {\\n                    int newX = cur[0] + dir[0];\\n                    int newY = cur[1] + dir[1];\\n                    if (newX < 0 || newX >= m || newY < 0 || newY >= n || res[newX][newY] >= 0 || grid[newX][newY] == 2) {\\n                        continue;\\n                        \\n                    }\\n                    queue.add(new int[] {newX, newY});\\n                }\\n            }\\n            cnt++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007798,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class Solution {\\n\\n    private static final int GRASS = 0;\\n    private static final int FIRE = 1;\\n    private static final int WALL = 2;\\n    private static final int MAX_TIME = 2 * (int) Math.pow(10, 4);\\n    private static final int CAN_WAIT_UNLIMITED_TIME = (int) Math.pow(10, 9);\\n    private static final int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    private static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    private static record Point(int row, int column) {}\\n    private List<Point> initialFirePoints;\\n    private int[][] currentGrid;\\n    private int[][] personLatestSteps;\\n    private int ID_personLatestSteps;\\n    private int blockedPointsOnPersonLatestSteps;\\n    private int rows;\\n    private int columns;\\n\\n    public int maximumMinutes(int[][] grid) {\\n        rows = grid.length;\\n        columns = grid[0].length;\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\n    private int findMaximumPossibleWaitingTimeAtInitialPosition(int[][] grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    private boolean goalCanBeReached(int[][] grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        Queue<Point> fireQueue = new LinkedList<>();\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        Queue<Point> personQueue = new LinkedList<>();\\n        personQueue.add(new Point(0, 0));\\n        ID_personLatestSteps = 1;\\n        personLatestSteps = new int[rows][columns];\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n            boolean fireUpdate = false;\\n            boolean initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void initiallySpreadFireForGivenTime(Queue<Point> fireQueue, int time) {\\n        for (Point point : initialFirePoints) {\\n            fireQueue.add(point);\\n        }\\n        boolean fireUpdate = true;\\n        boolean initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.isEmpty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    private void updateGrid(Queue<Point> queue, boolean fireUpdate, boolean initalUpdate) {\\n        int size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.poll();\\n            for (int[] move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private void recordInitialFirePoints(int[][] grid) {\\n        initialFirePoints = new ArrayList<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.add(new Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    private void cloneInitialGridForTheNextSearch(int[][] grid) {\\n        this.currentGrid = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            this.currentGrid[r] = Arrays.copyOf(grid[r], columns);\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n    this.GRASS = 0;\\n    this.FIRE = 1;\\n    this.WALL = 2;\\n    this.MAX_TIME = 2 * Math.pow(10, 4);\\n    this.CAN_WAIT_UNLIMITED_TIME = Math.pow(10, 9);\\n    this.NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    this.initialFirePoints = [];\\n    this.currentGrid = [];\\n    this.personLatestSteps = [];\\n    this.ID_personLatestSteps = 0;\\n    this.blockedPointsOnPersonLatestSteps = 0;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    recordInitialFirePoints(grid);\\n    return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n};\\n\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nfunction findMaximumPossibleWaitingTimeAtInitialPosition(grid) {\\n    let lowerLimit = 0;\\n    let upperLimit = this.MAX_TIME;\\n    let maximumPossibleWaitingTime = this.NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n    while (lowerLimit <= upperLimit) {\\n        let time = lowerLimit + Math.floor((upperLimit - lowerLimit) / 2);\\n        if (goalCanBeReached(grid, time)) {\\n            maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n            lowerLimit = time + 1;\\n        } else {\\n            upperLimit = time - 1;\\n        }\\n    }\\n    return (maximumPossibleWaitingTime !== this.MAX_TIME) ? maximumPossibleWaitingTime : this.CAN_WAIT_UNLIMITED_TIME;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @param {number} time\\n * @return {boolean}\\n */\\nfunction goalCanBeReached(grid, time) {\\n    cloneInitialGridForTheNextSearch(grid);\\n    const fireQueue = new Queue();\\n    initiallySpreadFireForGivenTime(fireQueue, time);\\n    if (this.currentGrid[0][0] === this.FIRE) {\\n        return false;\\n    }\\n\\n    const personQueue = new Queue();\\n    personQueue.enqueue(new Point(0, 0));\\n    this.ID_personLatestSteps = 1;\\n    this.personLatestSteps = Array.from(new Array(this.rows), () => new Array(this.columns).fill(0));\\n    this.personLatestSteps[0][0] = this.ID_personLatestSteps;\\n\\n    while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n        let fireUpdate = false;\\n        let initalUpdate = false;\\n        ++this.ID_personLatestSteps;\\n        updateGrid(personQueue, fireUpdate, initalUpdate);\\n        if (this.personLatestSteps[this.rows - 1][this.columns - 1] === this.ID_personLatestSteps) {\\n            return true;\\n        }\\n\\n        fireUpdate = true;\\n        initalUpdate = false;\\n        this.blockedPointsOnPersonLatestSteps = 0;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        if (this.blockedPointsOnPersonLatestSteps === personQueue.size()) {\\n            return false;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {Queue of Points} fireQueue\\n * @param {number} time\\n * @return {void}\\n */\\nfunction initiallySpreadFireForGivenTime(fireQueue, time) {\\n    for (let point of this.initialFirePoints) {\\n        fireQueue.enqueue(point);\\n    }\\n    let fireUpdate = true;\\n    let initalUpdate = true;\\n    let countMinutes = 0;\\n    while (!fireQueue.isEmpty() && countMinutes < time) {\\n        countMinutes++;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n    }\\n}\\n\\n/**\\n * @param {Queue of Points} queue\\n * @param {boolean} fireUpdate\\n * @param {boolean} initalUpdate\\n * @return {void}\\n */\\nfunction updateGrid(queue, fireUpdate, initalUpdate) {\\n    let size = queue.size();\\n    while (size-- > 0) {\\n\\n        const point = queue.dequeue();\\n        for (let move of this.MOVES) {\\n            const nextRow = point.row + move[0];\\n            const nextColumn = point.column + move[1];\\n\\n            if (isInGrid(nextRow, nextColumn) && this.currentGrid[nextRow][nextColumn] === this.GRASS) {\\n\\n                if (fireUpdate) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.currentGrid[nextRow][nextColumn] = this.FIRE;\\n                    this.blockedPointsOnPersonLatestSteps +=\\n                            (!initalUpdate && this.personLatestSteps[nextRow][nextColumn] === this.ID_personLatestSteps) ? 1 : 0;\\n                } else if (this.personLatestSteps[nextRow][nextColumn] === this.GRASS) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.personLatestSteps[nextRow][nextColumn] = this.ID_personLatestSteps;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction recordInitialFirePoints(grid) {\\n    this.initialFirePoints = [];\\n    for (let r = 0; r < this.rows; ++r) {\\n        for (let c = 0; c < this.columns; ++c) {\\n            if (grid[r][c] === this.FIRE) {\\n                this.initialFirePoints.push(new Point(r, c));\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInGrid(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction cloneInitialGridForTheNextSearch(grid) {\\n    this.currentGrid = Array.from(new Array(this.rows), () => new Array(this.columns));\\n    for (let r = 0; r < rows; ++r) {\\n        this.currentGrid[r] = Array.from(grid[r]);\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n```\\n**C++**\\n```\\n#include <iterator>\\n#include <numeric>\\n#include <array>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Point {\\n        size_t row;\\n        size_t column;\\n        Point(size_t row, size_t column) : row {row}, column {column}{}\\n        Point() = default;\\n        ~Point() = default;\\n    };\\n\\n    inline static const int GRASS = 0;\\n    inline static const int FIRE = 1;\\n    inline static const int WALL = 2;\\n    inline static const int MAX_TIME = 2 * pow(10, 4);\\n    inline static const int CAN_WAIT_UNLIMITED_TIME = pow(10, 9);\\n    inline static const int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    inline static const array<array<int8_t, 2>, 4> MOVES{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\n    vector<Point> initialFirePoints;\\n    vector<vector<int>> currentGrid;\\n    vector<vector<int>> personLatestSteps;\\n    int ID_personLatestSteps;\\n    int blockedPointsOnPersonLatestSteps;\\n    size_t rows;\\n    size_t columns;\\n\\npublic:\\n    int maximumMinutes(const vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        columns = grid[0].size();\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\nprivate:\\n    int findMaximumPossibleWaitingTimeAtInitialPosition(const vector<vector<int>>& grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    bool goalCanBeReached(const vector<vector<int>>& grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        queue<Point> fireQueue;\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        queue<Point> personQueue;\\n        personQueue.push(Point(0, 0));\\n\\n        ID_personLatestSteps = 1;\\n        personLatestSteps.assign(rows, vector<int>(columns));\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.empty() || !fireQueue.empty()) {\\n\\n            bool fireUpdate = false;\\n            bool initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void initiallySpreadFireForGivenTime(queue<Point>& fireQueue, int time) {\\n        for (const auto& point : initialFirePoints) {\\n            fireQueue.push(point);\\n        }\\n        bool fireUpdate = true;\\n        bool initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.empty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    void updateGrid(queue<Point>& queue, bool fireUpdate, bool initalUpdate) {\\n        size_t size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.front();\\n            queue.pop();\\n\\n            for (const auto& move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    void recordInitialFirePoints(const vector<vector<int>>& grid) {\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.push_back(Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    void cloneInitialGridForTheNextSearch(const vector<vector<int>>& grid) {\\n        currentGrid.resize(rows);\\n        size_t indexRow = 0;\\n        for (const auto& row : grid) {\\n            currentGrid[indexRow].resize(columns);\\n            currentGrid[indexRow].assign(row.begin(), row.end());\\n            ++indexRow;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\nimport java.util.List;\\nimport java.util.Queue;\\n\\npublic class Solution {\\n\\n    private static final int GRASS = 0;\\n    private static final int FIRE = 1;\\n    private static final int WALL = 2;\\n    private static final int MAX_TIME = 2 * (int) Math.pow(10, 4);\\n    private static final int CAN_WAIT_UNLIMITED_TIME = (int) Math.pow(10, 9);\\n    private static final int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    private static final int[][] MOVES = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    private static record Point(int row, int column) {}\\n    private List<Point> initialFirePoints;\\n    private int[][] currentGrid;\\n    private int[][] personLatestSteps;\\n    private int ID_personLatestSteps;\\n    private int blockedPointsOnPersonLatestSteps;\\n    private int rows;\\n    private int columns;\\n\\n    public int maximumMinutes(int[][] grid) {\\n        rows = grid.length;\\n        columns = grid[0].length;\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\n    private int findMaximumPossibleWaitingTimeAtInitialPosition(int[][] grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    private boolean goalCanBeReached(int[][] grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        Queue<Point> fireQueue = new LinkedList<>();\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        Queue<Point> personQueue = new LinkedList<>();\\n        personQueue.add(new Point(0, 0));\\n        ID_personLatestSteps = 1;\\n        personLatestSteps = new int[rows][columns];\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n            boolean fireUpdate = false;\\n            boolean initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void initiallySpreadFireForGivenTime(Queue<Point> fireQueue, int time) {\\n        for (Point point : initialFirePoints) {\\n            fireQueue.add(point);\\n        }\\n        boolean fireUpdate = true;\\n        boolean initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.isEmpty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    private void updateGrid(Queue<Point> queue, boolean fireUpdate, boolean initalUpdate) {\\n        int size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.poll();\\n            for (int[] move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.add(new Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    private void recordInitialFirePoints(int[][] grid) {\\n        initialFirePoints = new ArrayList<>();\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.add(new Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    private boolean isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    private void cloneInitialGridForTheNextSearch(int[][] grid) {\\n        this.currentGrid = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            this.currentGrid[r] = Arrays.copyOf(grid[r], columns);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n    this.GRASS = 0;\\n    this.FIRE = 1;\\n    this.WALL = 2;\\n    this.MAX_TIME = 2 * Math.pow(10, 4);\\n    this.CAN_WAIT_UNLIMITED_TIME = Math.pow(10, 9);\\n    this.NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    this.MOVES = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    this.initialFirePoints = [];\\n    this.currentGrid = [];\\n    this.personLatestSteps = [];\\n    this.ID_personLatestSteps = 0;\\n    this.blockedPointsOnPersonLatestSteps = 0;\\n    this.rows = grid.length;\\n    this.columns = grid[0].length;\\n\\n    recordInitialFirePoints(grid);\\n    return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n};\\n\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nfunction findMaximumPossibleWaitingTimeAtInitialPosition(grid) {\\n    let lowerLimit = 0;\\n    let upperLimit = this.MAX_TIME;\\n    let maximumPossibleWaitingTime = this.NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n    while (lowerLimit <= upperLimit) {\\n        let time = lowerLimit + Math.floor((upperLimit - lowerLimit) / 2);\\n        if (goalCanBeReached(grid, time)) {\\n            maximumPossibleWaitingTime = Math.max(maximumPossibleWaitingTime, time);\\n            lowerLimit = time + 1;\\n        } else {\\n            upperLimit = time - 1;\\n        }\\n    }\\n    return (maximumPossibleWaitingTime !== this.MAX_TIME) ? maximumPossibleWaitingTime : this.CAN_WAIT_UNLIMITED_TIME;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @param {number} time\\n * @return {boolean}\\n */\\nfunction goalCanBeReached(grid, time) {\\n    cloneInitialGridForTheNextSearch(grid);\\n    const fireQueue = new Queue();\\n    initiallySpreadFireForGivenTime(fireQueue, time);\\n    if (this.currentGrid[0][0] === this.FIRE) {\\n        return false;\\n    }\\n\\n    const personQueue = new Queue();\\n    personQueue.enqueue(new Point(0, 0));\\n    this.ID_personLatestSteps = 1;\\n    this.personLatestSteps = Array.from(new Array(this.rows), () => new Array(this.columns).fill(0));\\n    this.personLatestSteps[0][0] = this.ID_personLatestSteps;\\n\\n    while (!personQueue.isEmpty() || !fireQueue.isEmpty()) {\\n\\n        let fireUpdate = false;\\n        let initalUpdate = false;\\n        ++this.ID_personLatestSteps;\\n        updateGrid(personQueue, fireUpdate, initalUpdate);\\n        if (this.personLatestSteps[this.rows - 1][this.columns - 1] === this.ID_personLatestSteps) {\\n            return true;\\n        }\\n\\n        fireUpdate = true;\\n        initalUpdate = false;\\n        this.blockedPointsOnPersonLatestSteps = 0;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        if (this.blockedPointsOnPersonLatestSteps === personQueue.size()) {\\n            return false;\\n        }\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {Queue of Points} fireQueue\\n * @param {number} time\\n * @return {void}\\n */\\nfunction initiallySpreadFireForGivenTime(fireQueue, time) {\\n    for (let point of this.initialFirePoints) {\\n        fireQueue.enqueue(point);\\n    }\\n    let fireUpdate = true;\\n    let initalUpdate = true;\\n    let countMinutes = 0;\\n    while (!fireQueue.isEmpty() && countMinutes < time) {\\n        countMinutes++;\\n        updateGrid(fireQueue, fireUpdate, initalUpdate);\\n    }\\n}\\n\\n/**\\n * @param {Queue of Points} queue\\n * @param {boolean} fireUpdate\\n * @param {boolean} initalUpdate\\n * @return {void}\\n */\\nfunction updateGrid(queue, fireUpdate, initalUpdate) {\\n    let size = queue.size();\\n    while (size-- > 0) {\\n\\n        const point = queue.dequeue();\\n        for (let move of this.MOVES) {\\n            const nextRow = point.row + move[0];\\n            const nextColumn = point.column + move[1];\\n\\n            if (isInGrid(nextRow, nextColumn) && this.currentGrid[nextRow][nextColumn] === this.GRASS) {\\n\\n                if (fireUpdate) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.currentGrid[nextRow][nextColumn] = this.FIRE;\\n                    this.blockedPointsOnPersonLatestSteps +=\\n                            (!initalUpdate && this.personLatestSteps[nextRow][nextColumn] === this.ID_personLatestSteps) ? 1 : 0;\\n                } else if (this.personLatestSteps[nextRow][nextColumn] === this.GRASS) {\\n                    queue.enqueue(new Point(nextRow, nextColumn));\\n                    this.personLatestSteps[nextRow][nextColumn] = this.ID_personLatestSteps;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction recordInitialFirePoints(grid) {\\n    this.initialFirePoints = [];\\n    for (let r = 0; r < this.rows; ++r) {\\n        for (let c = 0; c < this.columns; ++c) {\\n            if (grid[r][c] === this.FIRE) {\\n                this.initialFirePoints.push(new Point(r, c));\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n * @return {boolean}\\n */\\nfunction isInGrid(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number[][]} grid\\n * @return {void}\\n */\\nfunction cloneInitialGridForTheNextSearch(grid) {\\n    this.currentGrid = Array.from(new Array(this.rows), () => new Array(this.columns));\\n    for (let r = 0; r < rows; ++r) {\\n        this.currentGrid[r] = Array.from(grid[r]);\\n    }\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column\\n */\\nfunction Point(row, column) {\\n    this.row = row;\\n    this.column = column;\\n}\\n```\n```\\n#include <iterator>\\n#include <numeric>\\n#include <array>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Point {\\n        size_t row;\\n        size_t column;\\n        Point(size_t row, size_t column) : row {row}, column {column}{}\\n        Point() = default;\\n        ~Point() = default;\\n    };\\n\\n    inline static const int GRASS = 0;\\n    inline static const int FIRE = 1;\\n    inline static const int WALL = 2;\\n    inline static const int MAX_TIME = 2 * pow(10, 4);\\n    inline static const int CAN_WAIT_UNLIMITED_TIME = pow(10, 9);\\n    inline static const int NOT_POSSIBLE_TO_REACH_GOAL = -1;\\n    inline static const array<array<int8_t, 2>, 4> MOVES{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\n    vector<Point> initialFirePoints;\\n    vector<vector<int>> currentGrid;\\n    vector<vector<int>> personLatestSteps;\\n    int ID_personLatestSteps;\\n    int blockedPointsOnPersonLatestSteps;\\n    size_t rows;\\n    size_t columns;\\n\\npublic:\\n    int maximumMinutes(const vector<vector<int>>& grid) {\\n        rows = grid.size();\\n        columns = grid[0].size();\\n        recordInitialFirePoints(grid);\\n        return findMaximumPossibleWaitingTimeAtInitialPosition(grid);\\n    }\\n\\nprivate:\\n    int findMaximumPossibleWaitingTimeAtInitialPosition(const vector<vector<int>>& grid) {\\n        int lowerLimit = 0;\\n        int upperLimit = MAX_TIME;\\n        int maximumPossibleWaitingTime = NOT_POSSIBLE_TO_REACH_GOAL;\\n\\n        while (lowerLimit <= upperLimit) {\\n            int time = lowerLimit + (upperLimit - lowerLimit) / 2;\\n            if (goalCanBeReached(grid, time)) {\\n                maximumPossibleWaitingTime = max(maximumPossibleWaitingTime, time);\\n                lowerLimit = time + 1;\\n            } else {\\n                upperLimit = time - 1;\\n            }\\n        }\\n        return (maximumPossibleWaitingTime != MAX_TIME) ? maximumPossibleWaitingTime : CAN_WAIT_UNLIMITED_TIME;\\n    }\\n\\n    bool goalCanBeReached(const vector<vector<int>>& grid, int time) {\\n        cloneInitialGridForTheNextSearch(grid);\\n        queue<Point> fireQueue;\\n        initiallySpreadFireForGivenTime(fireQueue, time);\\n        if (currentGrid[0][0] == FIRE) {\\n            return false;\\n        }\\n\\n        queue<Point> personQueue;\\n        personQueue.push(Point(0, 0));\\n\\n        ID_personLatestSteps = 1;\\n        personLatestSteps.assign(rows, vector<int>(columns));\\n        personLatestSteps[0][0] = ID_personLatestSteps;\\n\\n        while (!personQueue.empty() || !fireQueue.empty()) {\\n\\n            bool fireUpdate = false;\\n            bool initalUpdate = false;\\n            ++ID_personLatestSteps;\\n            updateGrid(personQueue, fireUpdate, initalUpdate);\\n            if (personLatestSteps[rows - 1][columns - 1] == ID_personLatestSteps) {\\n                return true;\\n            }\\n\\n            fireUpdate = true;\\n            initalUpdate = false;\\n            blockedPointsOnPersonLatestSteps = 0;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n            if (blockedPointsOnPersonLatestSteps == personQueue.size()) {\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    void initiallySpreadFireForGivenTime(queue<Point>& fireQueue, int time) {\\n        for (const auto& point : initialFirePoints) {\\n            fireQueue.push(point);\\n        }\\n        bool fireUpdate = true;\\n        bool initalUpdate = true;\\n        int countMinutes = 0;\\n        while (!fireQueue.empty() && countMinutes < time) {\\n            countMinutes++;\\n            updateGrid(fireQueue, fireUpdate, initalUpdate);\\n        }\\n    }\\n\\n    void updateGrid(queue<Point>& queue, bool fireUpdate, bool initalUpdate) {\\n        size_t size = queue.size();\\n        while (size-- > 0) {\\n\\n            Point point = queue.front();\\n            queue.pop();\\n\\n            for (const auto& move : MOVES) {\\n                int nextRow = point.row + move[0];\\n                int nextColumn = point.column + move[1];\\n\\n                if (isInGrid(nextRow, nextColumn) && currentGrid[nextRow][nextColumn] == GRASS) {\\n\\n                    if (fireUpdate) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        currentGrid[nextRow][nextColumn] = FIRE;\\n                        blockedPointsOnPersonLatestSteps += (!initalUpdate && personLatestSteps[nextRow][nextColumn] == ID_personLatestSteps) ? 1 : 0;\\n                    } else if (personLatestSteps[nextRow][nextColumn] == GRASS) {\\n                        queue.push(Point(nextRow, nextColumn));\\n                        personLatestSteps[nextRow][nextColumn] = ID_personLatestSteps;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    void recordInitialFirePoints(const vector<vector<int>>& grid) {\\n        for (int r = 0; r < rows; ++r) {\\n            for (int c = 0; c < columns; ++c) {\\n                if (grid[r][c] == FIRE) {\\n                    initialFirePoints.push_back(Point(r, c));\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isInGrid(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n\\n    void cloneInitialGridForTheNextSearch(const vector<vector<int>>& grid) {\\n        currentGrid.resize(rows);\\n        size_t indexRow = 0;\\n        for (const auto& row : grid) {\\n            currentGrid[indexRow].resize(columns);\\n            currentGrid[indexRow].assign(row.begin(), row.end());\\n            ++indexRow;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2007608,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n\\n  boolean isPossible(int [][] grid ,int time){\\n\\n\\n        int [][] directions ={{-1,0},{1,0},{0,-1},{0,1}};\\n\\n        boolean visited [][] = new boolean[grid.length][grid[0].length];\\n        visited[0][0]=true;\\n        Queue<int[]> person = new LinkedList<>();\\n        person.add(new int[]{0,0});\\n        while (!person.isEmpty()){\\n            int size = person.size();\\n            for (int i =0;i<size;i++) {\\n                int[] cor = person.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                for (int[] dir : directions) {\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_x<grid.length&&new_y<grid[0].length&&!visited[new_x][new_y]&&(grid[new_x][new_y]!=-1)){\\n                      if(time+1<=grid[new_x][new_y]) {\\n                          if(new_x==grid.length-1&&new_y==grid[0].length-1)\\n                              return true;\\n                          else if(time+1<grid[new_x][new_y]) {\\n                              person.add(new int[]{new_x, new_y});\\n                              visited[new_x][new_y] = true;\\n                          }\\n                      }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public int maximumMinutes(int[][] grid) {\\n\\n        for (int i =0;i<grid.length;i++){\\n            for (int j = 0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    grid[i][j]=Integer.MAX_VALUE;\\n                else if (grid[i][j]==1)\\n                    grid[i][j]=0;\\n                else\\n                    grid[i][j]=-1;\\n\\n\\n            }\\n        }\\n\\n\\n\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i =0;i<grid.length;i++){\\n            for (int j =0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    queue.add(new int[]{i,j});\\n            }\\n        }\\n        int val = 0;\\n        int[][] directions = {{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i =0;i<size;i++){\\n                int [] cor = queue.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                grid[x][y]=val;\\n                for (int [] dir:directions){\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_y<grid[0].length&&new_x<grid.length&&grid[new_x][new_y]==Integer.MAX_VALUE)\\n                        queue.add(new int[]{new_x,new_y});\\n                }\\n\\n            }\\n            val++;\\n        }\\n\\n\\n        for(int [] temp : grid)\\n            System.out.println(Arrays.toString(temp));\\n\\n        int low = -1;\\n        int high = grid.length*grid[0].length;\\n\\n        int ans = -1;\\n        while (low<=high){\\n            int mid = (low+high)/2;\\n            if (isPossible(grid,mid))\\n            {\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans==grid.length*grid[0].length?1_00_00_00_00_0:ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n  boolean isPossible(int [][] grid ,int time){\\n\\n\\n        int [][] directions ={{-1,0},{1,0},{0,-1},{0,1}};\\n\\n        boolean visited [][] = new boolean[grid.length][grid[0].length];\\n        visited[0][0]=true;\\n        Queue<int[]> person = new LinkedList<>();\\n        person.add(new int[]{0,0});\\n        while (!person.isEmpty()){\\n            int size = person.size();\\n            for (int i =0;i<size;i++) {\\n                int[] cor = person.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                for (int[] dir : directions) {\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_x<grid.length&&new_y<grid[0].length&&!visited[new_x][new_y]&&(grid[new_x][new_y]!=-1)){\\n                      if(time+1<=grid[new_x][new_y]) {\\n                          if(new_x==grid.length-1&&new_y==grid[0].length-1)\\n                              return true;\\n                          else if(time+1<grid[new_x][new_y]) {\\n                              person.add(new int[]{new_x, new_y});\\n                              visited[new_x][new_y] = true;\\n                          }\\n                      }\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public int maximumMinutes(int[][] grid) {\\n\\n        for (int i =0;i<grid.length;i++){\\n            for (int j = 0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    grid[i][j]=Integer.MAX_VALUE;\\n                else if (grid[i][j]==1)\\n                    grid[i][j]=0;\\n                else\\n                    grid[i][j]=-1;\\n\\n\\n            }\\n        }\\n\\n\\n\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i =0;i<grid.length;i++){\\n            for (int j =0;j<grid[0].length;j++){\\n                if (grid[i][j]==0)\\n                    queue.add(new int[]{i,j});\\n            }\\n        }\\n        int val = 0;\\n        int[][] directions = {{-1,0},{1,0},{0,1},{0,-1}};\\n        while (!queue.isEmpty()){\\n            int size = queue.size();\\n            for (int i =0;i<size;i++){\\n                int [] cor = queue.poll();\\n                int x = cor[0];\\n                int y = cor[1];\\n                grid[x][y]=val;\\n                for (int [] dir:directions){\\n                    int new_x = x + dir[0];\\n                    int new_y = y + dir[1];\\n                    if (new_x>=0&&new_y>=0&&new_y<grid[0].length&&new_x<grid.length&&grid[new_x][new_y]==Integer.MAX_VALUE)\\n                        queue.add(new int[]{new_x,new_y});\\n                }\\n\\n            }\\n            val++;\\n        }\\n\\n\\n        for(int [] temp : grid)\\n            System.out.println(Arrays.toString(temp));\\n\\n        int low = -1;\\n        int high = grid.length*grid[0].length;\\n\\n        int ans = -1;\\n        while (low<=high){\\n            int mid = (low+high)/2;\\n            if (isPossible(grid,mid))\\n            {\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n\\n        return ans==grid.length*grid[0].length?1_00_00_00_00_0:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007483,
                "title": "c-90-fire-bfs-human-modified-dijkstra",
                "content": "```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int maximumMinutes(\\n        vector<vector<int>>& grid\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int, int>> qfire;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j] == 1)\\n                    qfire.emplace(i, j);\\n        for (int ft = -1; qfire.size(); --ft) {\\n            int qsz = qfire.size();\\n            while (qsz--) {\\n                auto [i, j] = qfire.front();\\n                qfire.pop();\\n                grid[i][j] = ft;\\n                if (i && !grid[i-1][j])\\n                    qfire.emplace(i-1, j);\\n                if (i < m-1 && !grid[i+1][j])\\n                    qfire.emplace(i+1, j);\\n                if (j && !grid[i][j-1])\\n                    qfire.emplace(i, j-1);\\n                if (j < n-1 && !grid[i][j+1])\\n                    qfire.emplace(i, j+1);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dist(\\n            m, vector<pair<int, int>>(n, {INT_MIN, 0})\\n        );\\n        priority_queue<pair<pair<int, int>, pair<int, int>>> pqman;\\n        dist[0][0] = {(grid[0][0]<0)?(-grid[0][0]-2):INT_MAX, 0};\\n        pqman.push({dist[0][0],{0, 0}});\\n        while (pqman.size()) {\\n            auto [cdist, cpos] = pqman.top();\\n            auto [ci, cj] = cpos;\\n            pqman.pop();\\n            if (cdist < dist[ci][cj])\\n                continue;\\n            if (ci == m-1 && cj == n-1) {\\n                if (cdist.first == INT_MAX)\\n                    return 1000000000;\\n                if (cdist.first < 0)\\n                    return -1;\\n                return cdist.first;\\n            }\\n            int di = 0, dj = 1;\\n            for (int z = 0; z < 4; ++z) {\\n                int ni = ci+di, nj = cj+dj;\\n                if (ni >= 0 \\n                    && ni < m \\n                    && nj >= 0 \\n                    && nj < n\\n                    && grid[ni][nj] <= 0\\n                   ) {\\n                    auto ndist = cdist;\\n                    --ndist.second;\\n                    if (grid[ni][nj]) {\\n                        ndist.first = min(\\n                            ndist.first,\\n                            -grid[ni][nj]\\n                            +ndist.second-2\\n                            +(ni==m-1&&nj==n-1)\\n                        );\\n                    }\\n                    if (dist[ni][nj] < ndist) {\\n                        dist[ni][nj] = ndist;\\n                        pqman.push({ndist, {ni, nj}});\\n                    }\\n                }\\n                swap(di, dj);\\n                dj = -dj;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\npublic:\\n    int maximumMinutes(\\n        vector<vector<int>>& grid\\n    ) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<int, int>> qfire;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (grid[i][j] == 1)\\n                    qfire.emplace(i, j);\\n        for (int ft = -1; qfire.size(); --ft) {\\n            int qsz = qfire.size();\\n            while (qsz--) {\\n                auto [i, j] = qfire.front();\\n                qfire.pop();\\n                grid[i][j] = ft;\\n                if (i && !grid[i-1][j])\\n                    qfire.emplace(i-1, j);\\n                if (i < m-1 && !grid[i+1][j])\\n                    qfire.emplace(i+1, j);\\n                if (j && !grid[i][j-1])\\n                    qfire.emplace(i, j-1);\\n                if (j < n-1 && !grid[i][j+1])\\n                    qfire.emplace(i, j+1);\\n            }\\n        }\\n        vector<vector<pair<int, int>>> dist(\\n            m, vector<pair<int, int>>(n, {INT_MIN, 0})\\n        );\\n        priority_queue<pair<pair<int, int>, pair<int, int>>> pqman;\\n        dist[0][0] = {(grid[0][0]<0)?(-grid[0][0]-2):INT_MAX, 0};\\n        pqman.push({dist[0][0],{0, 0}});\\n        while (pqman.size()) {\\n            auto [cdist, cpos] = pqman.top();\\n            auto [ci, cj] = cpos;\\n            pqman.pop();\\n            if (cdist < dist[ci][cj])\\n                continue;\\n            if (ci == m-1 && cj == n-1) {\\n                if (cdist.first == INT_MAX)\\n                    return 1000000000;\\n                if (cdist.first < 0)\\n                    return -1;\\n                return cdist.first;\\n            }\\n            int di = 0, dj = 1;\\n            for (int z = 0; z < 4; ++z) {\\n                int ni = ci+di, nj = cj+dj;\\n                if (ni >= 0 \\n                    && ni < m \\n                    && nj >= 0 \\n                    && nj < n\\n                    && grid[ni][nj] <= 0\\n                   ) {\\n                    auto ndist = cdist;\\n                    --ndist.second;\\n                    if (grid[ni][nj]) {\\n                        ndist.first = min(\\n                            ndist.first,\\n                            -grid[ni][nj]\\n                            +ndist.second-2\\n                            +(ni==m-1&&nj==n-1)\\n                        );\\n                    }\\n                    if (dist[ni][nj] < ndist) {\\n                        dist[ni][nj] = ndist;\\n                        pqman.push({ndist, {ni, nj}});\\n                    }\\n                }\\n                swap(di, dj);\\n                dj = -dj;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005513,
                "title": "python3-bfs-dfs-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n      \\n      #region growing to assign each grass with the time that it will catch fire\\n      \\n      m, n = len(grid), len(grid[0])\\n      \\n      start = []\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          if grid[i][j] == 1:\\n            start.append([i,j])\\n            grid[i][j] = \\'F\\'\\n          elif grid[i][j] == 2:\\n            grid[i][j] = \\'W\\'\\n            \\n      visited = set()\\n      for element in start: visited.add(tuple(element))\\n        \\n      time = 1\\n      \\n      while start:\\n        new_start = []\\n        for x, y in start:\\n          if x >= 1:\\n            if grid[x-1][y] == 0 and (x-1, y) not in visited:\\n              new_start.append([x-1, y])\\n              visited.add((x-1, y))\\n              grid[x-1][y] = time\\n          if x < m-1:\\n            if grid[x+1][y] == 0 and (x+1, y) not in visited:\\n              new_start.append([x+1, y])\\n              visited.add((x+1, y))\\n              grid[x+1][y] = time\\n          if y >= 1:\\n            if grid[x][y-1] == 0 and (x, y-1) not in visited:\\n              new_start.append([x, y-1])\\n              visited.add((x, y-1))\\n              grid[x][y-1] = time\\n          if y < n-1:\\n            if grid[x][y+1] == 0 and (x, y+1) not in visited:\\n              new_start.append([x, y+1])\\n              visited.add((x, y+1))\\n              grid[x][y+1] = time\\n        time += 1\\n        start = new_start\\n        \\n        \\n      #memo variable will save time from search path that is already proved to be impossible\\n      memo = {}\\n      def search(x, y, time, visited):\\n        if (x,y) in memo and time >= memo[(x,y)]: return False\\n        if time > grid[-1][-1]: return False\\n        if x == m-1 and y == n-1:\\n          if grid[x][y] == 0:\\n            return True\\n          else: \\n            if grid[x][y] >= time:\\n              return True\\n        else:\\n          if grid[x][y] == time: return False\\n          visited.add((x,y))\\n          if x >= 1:\\n            if grid[x-1][y] != \\'W\\' and grid[x-1][y] != \\'F\\' and grid[x-1][y] > time  and (x-1, y) not in visited:\\n              res = search(x-1, y, time+1, visited)\\n              if res: return True\\n          if x < m-1:\\n            if grid[x+1][y] != \\'W\\' and grid[x+1][y] != \\'F\\' and grid[x+1][y] > time  and (x+1, y) not in visited:\\n              res = search(x+1, y, time+1, visited)\\n              if res: return True\\n          if y >= 1:\\n            if grid[x][y-1] != \\'W\\' and grid[x][y-1] != \\'F\\' and grid[x][y-1] > time  and (x, y-1) not in visited:\\n              res = search(x, y-1, time+1, visited)\\n              if res: return True\\n          if y < n-1:\\n            if grid[x][y+1] != \\'W\\' and grid[x][y+1] != \\'F\\' and grid[x][y+1] > time  and (x, y+1) not in visited:\\n              res = search(x, y+1, time+1, visited)\\n              if res: return True\\n          visited.remove((x,y))\\n          if (x,y) not in memo: memo[(x,y)] = time\\n          else: memo[(x,y)] = min(time, memo[(x,y)])\\n          return False\\n        \\n      if grid[0][0] == 0:\\n        if search(0, 0, -sys.maxsize, set()): return 10**9\\n        else: return -1\\n      else:\\n        start, end = 0, grid[0][0]-1\\n        \\n        #binary search\\n \\n        while start < end:\\n          mid = ceil((start + end)/2)\\n          if search(0, 0, mid, set()):\\n            start = mid\\n          else:\\n            end = mid - 1\\n        if start != 0: return start\\n        else:\\n          if search(0, 0, 0, set()): return 0\\n          else: return -1\\n      \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n      \\n      #region growing to assign each grass with the time that it will catch fire\\n      \\n      m, n = len(grid), len(grid[0])\\n      \\n      start = []\\n      \\n      for i in range(m):\\n        for j in range(n):\\n          if grid[i][j] == 1:\\n            start.append([i,j])\\n            grid[i][j] = \\'F\\'\\n          elif grid[i][j] == 2:\\n            grid[i][j] = \\'W\\'\\n            \\n      visited = set()\\n      for element in start: visited.add(tuple(element))\\n        \\n      time = 1\\n      \\n      while start:\\n        new_start = []\\n        for x, y in start:\\n          if x >= 1:\\n            if grid[x-1][y] == 0 and (x-1, y) not in visited:\\n              new_start.append([x-1, y])\\n              visited.add((x-1, y))\\n              grid[x-1][y] = time\\n          if x < m-1:\\n            if grid[x+1][y] == 0 and (x+1, y) not in visited:\\n              new_start.append([x+1, y])\\n              visited.add((x+1, y))\\n              grid[x+1][y] = time\\n          if y >= 1:\\n            if grid[x][y-1] == 0 and (x, y-1) not in visited:\\n              new_start.append([x, y-1])\\n              visited.add((x, y-1))\\n              grid[x][y-1] = time\\n          if y < n-1:\\n            if grid[x][y+1] == 0 and (x, y+1) not in visited:\\n              new_start.append([x, y+1])\\n              visited.add((x, y+1))\\n              grid[x][y+1] = time\\n        time += 1\\n        start = new_start\\n        \\n        \\n      #memo variable will save time from search path that is already proved to be impossible\\n      memo = {}\\n      def search(x, y, time, visited):\\n        if (x,y) in memo and time >= memo[(x,y)]: return False\\n        if time > grid[-1][-1]: return False\\n        if x == m-1 and y == n-1:\\n          if grid[x][y] == 0:\\n            return True\\n          else: \\n            if grid[x][y] >= time:\\n              return True\\n        else:\\n          if grid[x][y] == time: return False\\n          visited.add((x,y))\\n          if x >= 1:\\n            if grid[x-1][y] != \\'W\\' and grid[x-1][y] != \\'F\\' and grid[x-1][y] > time  and (x-1, y) not in visited:\\n              res = search(x-1, y, time+1, visited)\\n              if res: return True\\n          if x < m-1:\\n            if grid[x+1][y] != \\'W\\' and grid[x+1][y] != \\'F\\' and grid[x+1][y] > time  and (x+1, y) not in visited:\\n              res = search(x+1, y, time+1, visited)\\n              if res: return True\\n          if y >= 1:\\n            if grid[x][y-1] != \\'W\\' and grid[x][y-1] != \\'F\\' and grid[x][y-1] > time  and (x, y-1) not in visited:\\n              res = search(x, y-1, time+1, visited)\\n              if res: return True\\n          if y < n-1:\\n            if grid[x][y+1] != \\'W\\' and grid[x][y+1] != \\'F\\' and grid[x][y+1] > time  and (x, y+1) not in visited:\\n              res = search(x, y+1, time+1, visited)\\n              if res: return True\\n          visited.remove((x,y))\\n          if (x,y) not in memo: memo[(x,y)] = time\\n          else: memo[(x,y)] = min(time, memo[(x,y)])\\n          return False\\n        \\n      if grid[0][0] == 0:\\n        if search(0, 0, -sys.maxsize, set()): return 10**9\\n        else: return -1\\n      else:\\n        start, end = 0, grid[0][0]-1\\n        \\n        #binary search\\n \\n        while start < end:\\n          mid = ceil((start + end)/2)\\n          if search(0, 0, mid, set()):\\n            start = mid\\n          else:\\n            end = mid - 1\\n        if start != 0: return start\\n        else:\\n          if search(0, 0, 0, set()): return 0\\n          else: return -1\\n      \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004492,
                "title": "java-multi-source-bfs-binary-search",
                "content": "For the player to move the next cell , he/she needs to know if the fire has spread to that location .That can found by running a multi source BFS with the fire cells as the starting points. After that we can do a binary search on the wait time to check if its possible to reach the last cell .\\n\\n```\\nclass Solution {\\n    class Data{\\n        int row;\\n        int col;\\n        int data;\\n        \\n        public Data(int row,int col,int data){\\n            this.row = row;\\n            this.col = col;\\n            this.data = data;\\n        }\\n        \\n        @Override\\n        public int hashCode(){\\n            return Objects.hash(row,col,data);\\n        }\\n        \\n        @Override\\n        public boolean equals(Object other){\\n            Data d  = (Data) other;\\n            return d.row == this.row && d.col == this.col && d.data == this.data;\\n        }\\n    }\\n    \\n    boolean inside(int row,int col,int[][]grid){\\n        return row>=0 && col>=0 && row<grid.length && col<grid[row].length;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int[][] newGrid = new int[grid.length][grid[0].length];\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.fill(newGrid[i],-1);\\n            Arrays.fill(vis[i],false);\\n            for(int j = 0 ;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    queue.add(new Data(i,j,0));\\n                    newGrid[i][j] = 0;\\n                }else if(grid[i][j]==2){\\n                    newGrid[i][j] = -2;\\n                }\\n            }\\n        }\\n        // System.out.println(queue.size());\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                newGrid[curr.row][curr.col] = curr.data;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(inside(nextR,nextC,grid)&&newGrid[nextR][nextC]==-1){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n        }\\n        // for(int [] row : newGrid){\\n        //     System.out.println(Arrays.toString(row));\\n        // }\\n        int low = 0,high = (int)Math.pow(10,9),ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(possible(mid,newGrid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n       // System.out.println(ans);\\n        if(possible(high,newGrid)){\\n            ans=high;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    boolean possible(int waitTime,int [][] grid){\\n       // System.out.println(waitTime);\\n        Queue<Data> queue = new LinkedList<>();\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        queue.add(new Data(0,0,waitTime));\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(isSafeHouse(curr.row,curr.col,grid)){\\n                return true;\\n            }\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(isSafeHouse(nextR,nextC,grid) && curr.data+1==grid[nextR][nextC]){\\n                        return true;\\n                    }\\n                    if(inside(nextR,nextC,grid)&&(grid[nextR][nextC]==-1 || curr.data+1<grid[nextR][nextC])){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    boolean isSafeHouse(int row,int col,int[][] grid){\\n        if(row == grid.length-1 && col==grid[0].length-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Data{\\n        int row;\\n        int col;\\n        int data;\\n        \\n        public Data(int row,int col,int data){\\n            this.row = row;\\n            this.col = col;\\n            this.data = data;\\n        }\\n        \\n        @Override\\n        public int hashCode(){\\n            return Objects.hash(row,col,data);\\n        }\\n        \\n        @Override\\n        public boolean equals(Object other){\\n            Data d  = (Data) other;\\n            return d.row == this.row && d.col == this.col && d.data == this.data;\\n        }\\n    }\\n    \\n    boolean inside(int row,int col,int[][]grid){\\n        return row>=0 && col>=0 && row<grid.length && col<grid[row].length;\\n    }\\n    \\n    public int maximumMinutes(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int[][] newGrid = new int[grid.length][grid[0].length];\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.fill(newGrid[i],-1);\\n            Arrays.fill(vis[i],false);\\n            for(int j = 0 ;j<grid[0].length;j++){\\n                if(grid[i][j]==1){\\n                    queue.add(new Data(i,j,0));\\n                    newGrid[i][j] = 0;\\n                }else if(grid[i][j]==2){\\n                    newGrid[i][j] = -2;\\n                }\\n            }\\n        }\\n        // System.out.println(queue.size());\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                newGrid[curr.row][curr.col] = curr.data;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(inside(nextR,nextC,grid)&&newGrid[nextR][nextC]==-1){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n        }\\n        // for(int [] row : newGrid){\\n        //     System.out.println(Arrays.toString(row));\\n        // }\\n        int low = 0,high = (int)Math.pow(10,9),ans = -1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(possible(mid,newGrid)){\\n                ans = mid;\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n        }\\n       // System.out.println(ans);\\n        if(possible(high,newGrid)){\\n            ans=high;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    boolean possible(int waitTime,int [][] grid){\\n       // System.out.println(waitTime);\\n        Queue<Data> queue = new LinkedList<>();\\n        boolean [][] vis = new boolean[grid.length][grid[0].length];\\n        queue.add(new Data(0,0,waitTime));\\n        while(!queue.isEmpty()){\\n            Data curr = queue.poll();\\n            if(isSafeHouse(curr.row,curr.col,grid)){\\n                return true;\\n            }\\n            if(!vis[curr.row][curr.col]){\\n                vis[curr.row][curr.col] = true;\\n                int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};\\n                for(int [] dir : dirs){\\n                    int nextR = dir[0] + curr.row;\\n                    int nextC = dir[1] + curr.col;\\n                    if(isSafeHouse(nextR,nextC,grid) && curr.data+1==grid[nextR][nextC]){\\n                        return true;\\n                    }\\n                    if(inside(nextR,nextC,grid)&&(grid[nextR][nextC]==-1 || curr.data+1<grid[nextR][nextC])){\\n                        queue.add(new Data(nextR,nextC,curr.data+1));\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n    boolean isSafeHouse(int row,int col,int[][] grid){\\n        if(row == grid.length-1 && col==grid[0].length-1){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002493,
                "title": "after-16-wrong-submissions-i-don-t-even-have-the-strength-to-explain-it-now",
                "content": "```\\nclass Solution {\\n    \\n    int xx[4]={1,-1,0,0};\\n    int yy[4]={0,0,1,-1};\\n    \\n    bool pos(vector<vector<int>> &grid, int t, int m, int n){\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        queue<vector<int>> q;\\n        q.push({0,0,t});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                int cx=v[0];\\n                int cy=v[1];\\n                int ct=v[2];\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && vis[x][y]==0 && (grid[x][y]-2>ct || grid[x][y]==0 || (x==m-1 && y==n-1 && grid[x][y]-2==ct))){\\n                        q.push({x,y,ct+1});\\n                        vis[x][y]=1;\\n                        if(x==m-1 && y==n-1) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==2) grid[i][j]=-1;\\n                else if(grid[i][j]==1) q.push({i,j});\\n            }\\n        }\\n        \\n        int time=2;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto cp=q.front();\\n                q.pop();\\n                int cx=cp.first;\\n                int cy=cp.second;\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y]==0){\\n                        grid[x][y]=time;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        int lo=0;\\n        int hi=m*n+1;\\n        \\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(pos(grid,mid,m,n)){\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        return (hi==(m*n+1))?1e9:hi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int xx[4]={1,-1,0,0};\\n    int yy[4]={0,0,1,-1};\\n    \\n    bool pos(vector<vector<int>> &grid, int t, int m, int n){\\n        vector<vector<int>> vis(m, vector<int> (n,0));\\n        queue<vector<int>> q;\\n        q.push({0,0,t});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                int cx=v[0];\\n                int cy=v[1];\\n                int ct=v[2];\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && vis[x][y]==0 && (grid[x][y]-2>ct || grid[x][y]==0 || (x==m-1 && y==n-1 && grid[x][y]-2==ct))){\\n                        q.push({x,y,ct+1});\\n                        vis[x][y]=1;\\n                        if(x==m-1 && y==n-1) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid){\\n        queue<pair<int,int>> q;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==2) grid[i][j]=-1;\\n                else if(grid[i][j]==1) q.push({i,j});\\n            }\\n        }\\n        \\n        int time=2;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                auto cp=q.front();\\n                q.pop();\\n                int cx=cp.first;\\n                int cy=cp.second;\\n                for(int i=0; i<4; i++){\\n                    int x = cx+xx[i];\\n                    int y = cy+yy[i];\\n                    if(x>=0 && y>=0 && x<m && y<n && grid[x][y]==0){\\n                        grid[x][y]=time;\\n                        q.push({x,y});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        int lo=0;\\n        int hi=m*n+1;\\n        \\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(pos(grid,mid,m,n)){\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        return (hi==(m*n+1))?1e9:hi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002309,
                "title": "java-bfs-bs",
                "content": "```\\nclass Solution {\\n      /*\\n     // Algorithm\\n     - Store locations of fire Queue\\n     - Spread fire upto mn time\\n     - Apply bfs+BS and check if user is reachable with t time\\n     - If yes then  l = mid\\n     - Else  r = mid-1\\n     - return l;\\n     // TC = O(mnlognm), SC = O(mn)\\n    */\\n    private static final int[][] DIRS = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        List<int[]> fires = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) fires.add(new int[]{i, j});\\n            }\\n        }\\n\\n\\n        int l = -1, r = m * n;\\n        while (l < r) {\\n            int mid =  l + (r - l) / 2 + 1;\\n            if (reachable(grid, fires, mid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return (int) (l == m * n ? 1e9 : l);\\n    }\\n\\n    // BFS ---> To check if  user is reachable after t min of fire spread\\n    private boolean reachable(int[][] grid, List<int[]> fires, int moves) {\\n        int[][] copy = clone(grid);\\n\\n        Queue<int[]> fire = new LinkedList<>(fires);\\n\\n        while (!fire.isEmpty() && moves-- > 0) {\\n            if (spread(fire, copy)) return false;\\n        }\\n\\n        //check if person is reachable to dest\\n        Queue<int[]> person = new LinkedList<>();\\n\\n        person.add(new int[]{0, 0});\\n        while (!person.isEmpty()) {\\n            boolean onFire = spread(fire, copy);\\n            boolean dest = spread(person, copy);\\n\\n            if (dest) return true;\\n            if (onFire) return false;\\n        }\\n        return false;\\n    }\\n\\n    private boolean spread(Queue<int[]> queue, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sz = queue.size();\\n\\n        while (sz-- > 0) {\\n            int[] point = queue.poll();\\n            for (int[] dir : DIRS) {\\n                assert point != null;\\n                int newx = dir[0] + point[0];\\n                int newy = dir[1] + point[1];\\n                if (newx == m - 1 && newy == n - 1) return true;\\n                if (isSafe(grid, newx, newy)) {\\n                    grid[newx][newy] = -1;\\n                    queue.offer(new int[]{newx, newy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // This will tell us if coordinate is within extrimities OR safe to visit the point\\n    private boolean isSafe(int[][] grid, int x, int y) {\\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0;\\n    }\\n\\n    private int[][] clone(int[][] grid) {\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      /*\\n     // Algorithm\\n     - Store locations of fire Queue\\n     - Spread fire upto mn time\\n     - Apply bfs+BS and check if user is reachable with t time\\n     - If yes then  l = mid\\n     - Else  r = mid-1\\n     - return l;\\n     // TC = O(mnlognm), SC = O(mn)\\n    */\\n    private static final int[][] DIRS = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n\\n    public int maximumMinutes(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        List<int[]> fires = new ArrayList<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1) fires.add(new int[]{i, j});\\n            }\\n        }\\n\\n\\n        int l = -1, r = m * n;\\n        while (l < r) {\\n            int mid =  l + (r - l) / 2 + 1;\\n            if (reachable(grid, fires, mid)) l = mid;\\n            else r = mid - 1;\\n        }\\n        return (int) (l == m * n ? 1e9 : l);\\n    }\\n\\n    // BFS ---> To check if  user is reachable after t min of fire spread\\n    private boolean reachable(int[][] grid, List<int[]> fires, int moves) {\\n        int[][] copy = clone(grid);\\n\\n        Queue<int[]> fire = new LinkedList<>(fires);\\n\\n        while (!fire.isEmpty() && moves-- > 0) {\\n            if (spread(fire, copy)) return false;\\n        }\\n\\n        //check if person is reachable to dest\\n        Queue<int[]> person = new LinkedList<>();\\n\\n        person.add(new int[]{0, 0});\\n        while (!person.isEmpty()) {\\n            boolean onFire = spread(fire, copy);\\n            boolean dest = spread(person, copy);\\n\\n            if (dest) return true;\\n            if (onFire) return false;\\n        }\\n        return false;\\n    }\\n\\n    private boolean spread(Queue<int[]> queue, int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int sz = queue.size();\\n\\n        while (sz-- > 0) {\\n            int[] point = queue.poll();\\n            for (int[] dir : DIRS) {\\n                assert point != null;\\n                int newx = dir[0] + point[0];\\n                int newy = dir[1] + point[1];\\n                if (newx == m - 1 && newy == n - 1) return true;\\n                if (isSafe(grid, newx, newy)) {\\n                    grid[newx][newy] = -1;\\n                    queue.offer(new int[]{newx, newy});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // This will tell us if coordinate is within extrimities OR safe to visit the point\\n    private boolean isSafe(int[][] grid, int x, int y) {\\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0;\\n    }\\n\\n    private int[][] clone(int[][] grid) {\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                copy[i][j] = grid[i][j];\\n            }\\n        }\\n\\n        return copy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001511,
                "title": "c-bfs-and-binary-search",
                "content": "The solution firstly uses BFS once to compute the new fire cells on each day (The idea is borrowed from another problem [1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/)).\\n\\nAfter that, one can update the condition of the grid day by day without computing the spreading of fire by BFS, which is costly.\\n\\nNext, use binary search over [0, `the num. of days that fire can spread`] to find the answer. In each iteration of the binary search, another BFS is employed to find whether one can reach the right-bottom corner starting from a specific day.\\n\\nTime Comlexity: O(log(mn)mn) (binary search * BFS + first BFS to compute the spreading of fire)\\nSpace Complexity: O(mn) (max size of m by n matrix and the queue)\\n\\n```\\n\\nclass Solution {\\n  private:\\n    typedef pair<int, int> ii_t;\\n\\n    static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    bool canEscape(vector<vector<bool>> seen, vector<vector<ii_t>>& fires, int k) const {\\n      const int m = seen.size();\\n      const int n = seen[0].size();\\n      \\n      // apply first k days\\' fire\\n      for (int i = 0; i < k; ++i)\\n        for (auto& [r, c] : fires[i])\\n          seen[r][c] = true;\\n\\n      queue<ii_t> q;\\n      q.emplace(0, 0);\\n\\n      // why you move first and then fire spreads\\n      // -> solve the corner case where you and fire reach the safe house at the same day\\n      while (!q.empty()) {\\n        int N = q.size();\\n        while (N--) {\\n          auto& [r, c] = q.front();\\n\\n          // no fire and not visited\\n          if (!seen[r][c]) {\\n            seen[r][c] = true;\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                if (i == m - 1 && j == n - 1)\\n                  return true;\\n\\n                q.emplace(i, j);\\n              }\\n            }\\n          }\\n\\n          q.pop();\\n        }\\n\\n        // fire spreads at day k + 1\\n        if (k < fires.size()) {\\n          for (auto& [r, c] : fires[k])\\n            seen[r][c] = true;\\n\\n          ++k;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n  public:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      // time: O(log(mn)mn)\\n      // memory: O(mn)\\n\\n      const int m = grid.size();\\n      const int n = grid[0].size();\\n\\n      // new fires at [r, c] on day i\\n      vector<vector<ii_t>> fires;\\n\\n      // scope to compute the spreading of fires day by day\\n      {\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        queue<ii_t> q;\\n\\n        for (int i = 0; i < m; ++i)\\n          for (int j = 0; j < n; ++j)\\n            if (grid[i][j] != 0) {\\n              seen[i][j] = true;\\n\\n              if (grid[i][j] == 1)\\n                q.emplace(i, j);\\n            }\\n\\n        while (!q.empty()) {\\n          vector<ii_t>& f = fires.emplace_back();\\n\\n          int N = q.size();\\n          while (N--) {\\n            auto& [r, c] = q.front();\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                seen[i][j] = true;\\n                q.emplace(i, j);\\n                f.emplace_back(i, j);\\n              }\\n            }\\n\\n            q.pop();\\n          }\\n        }\\n\\n        // remove last empty day\\n        if (!fires.empty() && fires.back().empty())\\n          fires.pop_back();\\n\\n      }\\n\\n      // initial condition of the grid\\n      // false -> wall, visited or fire\\n      vector<vector<bool>> seen(m, vector<bool>(n));\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] != 0)\\n            seen[i][j] = true;\\n\\n\\n      int l = 0, r = (int) fires.size();\\n      while (l <= r) {\\n        int k = l + (r - l) / 2;\\n\\n        if (canEscape(seen, fires, k))\\n          l = k + 1;\\n        else\\n          r = k - 1;\\n      }\\n\\n      return r == fires.size() ? 1e9 : r;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n  private:\\n    typedef pair<int, int> ii_t;\\n\\n    static constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    bool canEscape(vector<vector<bool>> seen, vector<vector<ii_t>>& fires, int k) const {\\n      const int m = seen.size();\\n      const int n = seen[0].size();\\n      \\n      // apply first k days\\' fire\\n      for (int i = 0; i < k; ++i)\\n        for (auto& [r, c] : fires[i])\\n          seen[r][c] = true;\\n\\n      queue<ii_t> q;\\n      q.emplace(0, 0);\\n\\n      // why you move first and then fire spreads\\n      // -> solve the corner case where you and fire reach the safe house at the same day\\n      while (!q.empty()) {\\n        int N = q.size();\\n        while (N--) {\\n          auto& [r, c] = q.front();\\n\\n          // no fire and not visited\\n          if (!seen[r][c]) {\\n            seen[r][c] = true;\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                if (i == m - 1 && j == n - 1)\\n                  return true;\\n\\n                q.emplace(i, j);\\n              }\\n            }\\n          }\\n\\n          q.pop();\\n        }\\n\\n        // fire spreads at day k + 1\\n        if (k < fires.size()) {\\n          for (auto& [r, c] : fires[k])\\n            seen[r][c] = true;\\n\\n          ++k;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n  public:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n      // time: O(log(mn)mn)\\n      // memory: O(mn)\\n\\n      const int m = grid.size();\\n      const int n = grid[0].size();\\n\\n      // new fires at [r, c] on day i\\n      vector<vector<ii_t>> fires;\\n\\n      // scope to compute the spreading of fires day by day\\n      {\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        queue<ii_t> q;\\n\\n        for (int i = 0; i < m; ++i)\\n          for (int j = 0; j < n; ++j)\\n            if (grid[i][j] != 0) {\\n              seen[i][j] = true;\\n\\n              if (grid[i][j] == 1)\\n                q.emplace(i, j);\\n            }\\n\\n        while (!q.empty()) {\\n          vector<ii_t>& f = fires.emplace_back();\\n\\n          int N = q.size();\\n          while (N--) {\\n            auto& [r, c] = q.front();\\n\\n            for (auto& d : dirs) {\\n              int i = r + d[0];\\n              int j = c + d[1];\\n              if (i >= 0 && i < m && j >= 0 && j < n && !seen[i][j]) {\\n                seen[i][j] = true;\\n                q.emplace(i, j);\\n                f.emplace_back(i, j);\\n              }\\n            }\\n\\n            q.pop();\\n          }\\n        }\\n\\n        // remove last empty day\\n        if (!fires.empty() && fires.back().empty())\\n          fires.pop_back();\\n\\n      }\\n\\n      // initial condition of the grid\\n      // false -> wall, visited or fire\\n      vector<vector<bool>> seen(m, vector<bool>(n));\\n      for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n          if (grid[i][j] != 0)\\n            seen[i][j] = true;\\n\\n\\n      int l = 0, r = (int) fires.size();\\n      while (l <= r) {\\n        int k = l + (r - l) / 2;\\n\\n        if (canEscape(seen, fires, k))\\n          l = k + 1;\\n        else\\n          r = k - 1;\\n      }\\n\\n      return r == fires.size() ? 1e9 : r;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998830,
                "title": "python-bfs-binary-search-detailed-explanation",
                "content": "### BFS + Binary Search \\n\\n#### 1. Fire spreads via BFS\\n\\n* Put the initial fires (multiple) in the queue to start BFS\\n* Generate a matrix `fireGrid` describing the shortest time that fire will arrive  \\n\\n#### 2. Person spreads via BFS (waiting time = 0)\\n* Let\\'s assume waiting time to be 0 first: \\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, 0)` to start BFS \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 3. Person spreads via BFS (waiting time = waitTime)\\n* We create a function to check whether the person can arrive a safe hourse with a certain waiting time \\n`def checkSafe(waitTime, fireGrid)`\\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, waitTime)` to start BFS \\n* Then, we can do the same as 2. \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 4. Binary Search to test the waitTime \\n* According to the question, `m * n <= 2 * 10^4`\\n* We need to run the test in the range `[0, 2 * 10^4]` \\n* However, since the result of waitTime should all be False after a certain time (e.g. TTTTTTFFFFFF ), we can utilize **Binary Search**  in this pattern to find the last True -> `(start -1)`\\n\\n\\n```python\\n\\n\\'\\'\\'\\nBFS + Binary Search  \\nTime Complexity: O(mnlog(mn))\\nSpace Complexity: O(mn)\\n\\'\\'\\'\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef generateFireGrid():\\n\\t\\tfireGrid = [[inf] * n for _ in range(m)]\\n\\t\\tfires = []\\n\\t\\tfor i in range(m):\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\tfires.append((i, j, 0))\\n\\n\\t\\tdeq = collections.deque(fires)\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif fireGrid[x][y] != inf: #visited check \\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfireGrid[x][y] = t \\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif t+1 < fireGrid[nx][ny]:\\n\\t\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn fireGrid\\n\\n\\tdef checkSafe(waitTime, fireGrid):\\n\\t\\tdeq = collections.deque([(0, 0, waitTime)])\\n\\t\\tvisited = set()\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif x == m-1 and y == n-1 and t <= fireGrid[x][y]:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif t >= fireGrid[x][y]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif (x, y) in visited: #visited check\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisited.add((x, y))\\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn False\\n\\n\\tfireGrid = generateFireGrid()\\n\\n\\t# Binary Search to check waiting time\\n\\tMAX_LIMIT = 2 * 10 ** 4 \\n\\tstart, end = 0, MAX_LIMIT\\n\\twhile start < end:\\n\\t\\tmid = start + (end - start) // 2\\n\\t\\tif checkSafe(mid, fireGrid):\\n\\t\\t\\tstart = mid + 1\\n\\t\\telse:\\n\\t\\t\\tend = mid\\n\\n\\t#We can use start - 1 to describe the two cases: out of left range and in range\\n\\t#Only the case out of right range needs to handle separately\\n\\t#\\u8D85\\u51FA\\u5DE6\\u908A\\u754C\\u548C\\u908A\\u754C\\u5167\\u90FD\\u53EF\\u4EE5\\u7528start-1\\u63CF\\u8FF0\\uFF0C\\u53EA\\u6709\\u8D85\\u51FA\\u53F3\\u908A\\u754C\\u9700\\u8981\\u53E6\\u5916\\u8655\\u7406\\n\\treturn start - 1 if start < MAX_LIMIT else 10 ** 9",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "### BFS + Binary Search \\n\\n#### 1. Fire spreads via BFS\\n\\n* Put the initial fires (multiple) in the queue to start BFS\\n* Generate a matrix `fireGrid` describing the shortest time that fire will arrive  \\n\\n#### 2. Person spreads via BFS (waiting time = 0)\\n* Let\\'s assume waiting time to be 0 first: \\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, 0)` to start BFS \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 3. Person spreads via BFS (waiting time = waitTime)\\n* We create a function to check whether the person can arrive a safe hourse with a certain waiting time \\n`def checkSafe(waitTime, fireGrid)`\\n* Put the person (single) in the queue `(i, j, t ) = (0, 0, waitTime)` to start BFS \\n* Then, we can do the same as 2. \\n* Check whether this person can arrive a cell (arrival time needs to be `t < fireGrid[x][y]`) \\n* If the person can arrive at the safe house, it means \\n  `x == m-1 and y == n-1 and t <= fireGrid[x][y]` \\n\\n#### 4. Binary Search to test the waitTime \\n* According to the question, `m * n <= 2 * 10^4`\\n* We need to run the test in the range `[0, 2 * 10^4]` \\n* However, since the result of waitTime should all be False after a certain time (e.g. TTTTTTFFFFFF ), we can utilize **Binary Search**  in this pattern to find the last True -> `(start -1)`\\n\\n\\n```python\\n\\n\\'\\'\\'\\nBFS + Binary Search  \\nTime Complexity: O(mnlog(mn))\\nSpace Complexity: O(mn)\\n\\'\\'\\'\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n        \\n\\tdef generateFireGrid():\\n\\t\\tfireGrid = [[inf] * n for _ in range(m)]\\n\\t\\tfires = []\\n\\t\\tfor i in range(m):\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\tfires.append((i, j, 0))\\n\\n\\t\\tdeq = collections.deque(fires)\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif fireGrid[x][y] != inf: #visited check \\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tfireGrid[x][y] = t \\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif t+1 < fireGrid[nx][ny]:\\n\\t\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn fireGrid\\n\\n\\tdef checkSafe(waitTime, fireGrid):\\n\\t\\tdeq = collections.deque([(0, 0, waitTime)])\\n\\t\\tvisited = set()\\n\\t\\twhile deq:\\n\\t\\t\\tx, y, t = deq.popleft()\\n\\t\\t\\tif x == m-1 and y == n-1 and t <= fireGrid[x][y]:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif t >= fireGrid[x][y]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif (x, y) in visited: #visited check\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tvisited.add((x, y))\\n\\t\\t\\tfor nx, ny in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n\\t\\t\\t\\tif not (0 <= nx < m and 0 <= ny < n):\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif grid[nx][ny] == 2: #wall\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tdeq.append((nx, ny, t+1))\\n\\t\\treturn False\\n\\n\\tfireGrid = generateFireGrid()\\n\\n\\t# Binary Search to check waiting time\\n\\tMAX_LIMIT = 2 * 10 ** 4 \\n\\tstart, end = 0, MAX_LIMIT\\n\\twhile start < end:\\n\\t\\tmid = start + (end - start) // 2\\n\\t\\tif checkSafe(mid, fireGrid):\\n\\t\\t\\tstart = mid + 1\\n\\t\\telse:\\n\\t\\t\\tend = mid\\n\\n\\t#We can use start - 1 to describe the two cases: out of left range and in range\\n\\t#Only the case out of right range needs to handle separately\\n\\t#\\u8D85\\u51FA\\u5DE6\\u908A\\u754C\\u548C\\u908A\\u754C\\u5167\\u90FD\\u53EF\\u4EE5\\u7528start-1\\u63CF\\u8FF0\\uFF0C\\u53EA\\u6709\\u8D85\\u51FA\\u53F3\\u908A\\u754C\\u9700\\u8981\\u53E6\\u5916\\u8655\\u7406\\n\\treturn start - 1 if start < MAX_LIMIT else 10 ** 9",
                "codeTag": "Python3"
            },
            {
                "id": 1998726,
                "title": "java-solution-using-bfs-binary-search",
                "content": "```\\nclass Solution {\\n    final int INF = (int) 1e9;\\n    public class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        public Pair() {\\n            \\n        }\\n    }\\n    public boolean isPossible(int[][] grid, int[][] dist, int start) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (dist[0][0] > 0 && dist[0][0] <= start) return false;\\n        List<Pair> que = new ArrayList<>();\\n        que.add(new Pair(0, 0));\\n        int[][] dist1 = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        dist1[0][0] = start;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            if (dist[row][col] == 0 || dist1[p.first][p.second] + 1 < dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                            else if (row == n - 1 && col == m - 1 && dist1[p.first][p.second] + 1 == dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        List<Pair> que = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    que.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n        int[][] dist = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        for (Pair p : que) {\\n            vis[p.first][p.second] = true;\\n        }\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            vis[row][col] = true;\\n                            dist[row][col] = dist[p.first][p.second] + 1;\\n                            que.add(new Pair(row, col));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = INF;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (isPossible(grid, dist, mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int INF = (int) 1e9;\\n    public class Pair {\\n        int first;\\n        int second;\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n        public Pair() {\\n            \\n        }\\n    }\\n    public boolean isPossible(int[][] grid, int[][] dist, int start) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        if (dist[0][0] > 0 && dist[0][0] <= start) return false;\\n        List<Pair> que = new ArrayList<>();\\n        que.add(new Pair(0, 0));\\n        int[][] dist1 = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        dist1[0][0] = start;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            if (dist[row][col] == 0 || dist1[p.first][p.second] + 1 < dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                            else if (row == n - 1 && col == m - 1 && dist1[p.first][p.second] + 1 == dist[row][col]) {\\n                                vis[row][col] = true;\\n                                dist1[row][col] = dist1[p.first][p.second] + 1;\\n                                que.add(new Pair(row, col));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n    public int maximumMinutes(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        List<Pair> que = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    que.add(new Pair(i, j));\\n                }\\n            }\\n        }\\n        int[][] dist = new int[n][m];\\n        boolean[][] vis = new boolean[n][m];\\n        for (Pair p : que) {\\n            vis[p.first][p.second] = true;\\n        }\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            Pair p = que.get(i);\\n            for (int l : new int[] {-1, 0, 1}) {\\n                for (int r : new int[] {-1, 0, 1}) {\\n                    if (Math.abs(l) != Math.abs(r)) {\\n                        int row = l + p.first;\\n                        int col = r + p.second;\\n                        if (row >= 0 && row < n && col >= 0 && col < m && grid[row][col] == 0 && !vis[row][col]) {\\n                            vis[row][col] = true;\\n                            dist[row][col] = dist[p.first][p.second] + 1;\\n                            que.add(new Pair(row, col));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int low = 0;\\n        int high = INF;\\n        int sol = -1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (isPossible(grid, dist, mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998561,
                "title": "c-two-bfss-solution-beats-100",
                "content": "```\\n// Some auxiliary stuff\\nusing Point = pair<int, int>;\\nPoint operator+(Point& l, Point& r) {\\n    return {l.first + r.first, l.second + r.second};\\n}\\nvector<Point> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nbool in_borders(vector<vector<int>>& grid, Point& p) {\\n    return !(p.first < 0 || p.first >= grid.size() || p.second < 0 || p.second >= grid[0].size());\\n}\\n\\nclass Solution {\\n\\n\\t// This function performs BFS for the man and fire simultaneously. The idea is \\n\\t// trying to reach the finish cell by both man and fire, and if man reaches first \\n\\t// count the number of steps he waits fire at the end. The only special case\\n\\t// is when the fire reaches the finish at the same time as man does it.\\n\\t//\\n\\t// Args:\\n\\t// grid - copy the original grid since it will be modified\\n\\t// wait - it is possible to set how long man should wait at the beginning.\\n    int maximumMinutesWaited(vector<vector<int>> grid, int wait) {\\n        queue<Point> q;\\n        q.push({0, 0});\\n        grid[0][0] = 10;\\n\\n        queue<Point> fq;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) {\\n                    fq.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int step = 0;\\n        int man_reached = -1;\\n        int fire_reached = -1;\\n\\n        while (!q.empty() || !fq.empty()) {\\n            step++;\\n            \\n\\t\\t\\t// Firstly perform man\\'s move\\n            int size = q.size();\\n            if (step > wait) {\\n                for (int i = 0; i < size; i++) {\\n                    auto p = q.front(); q.pop(); \\n\\n                    if (grid[p.first][p.second] == 1)\\n                        continue;\\n\\n                    for (auto& dir : dirs) {\\n                        auto n = p + dir;\\n\\n                        if (!in_borders(grid, n))\\n                            continue;\\n\\n                        if (grid[n.first][n.second] != 0)\\n                            continue;\\n\\n                        grid[n.first][n.second] = 1000 + step;\\n\\n                        if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                            man_reached = step;\\n                        }\\n\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// Secondly spread the fire\\n            size = fq.size();\\n            for (int i = 0; i < size; i++) {\\n                auto p = fq.front(); fq.pop(); \\n                \\n                for (auto dir : dirs) {\\n                    auto n = p + dir;\\n\\n                    if (!in_borders(grid, n))\\n                        continue;\\n\\n                    if (grid[n.first][n.second] == 2 || grid[n.first][n.second] == 1)\\n                        continue;\\n                    \\n                    if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                        fire_reached = step;\\n                        \\n\\t\\t\\t\\t\\t\\t// Special case when fire reaches the end at the same turn as man does\\n                        if (grid[n.first][n.second] == 1000 + step)\\n                            return 0;\\n                    }\\n                    \\n                    grid[n.first][n.second] = 1;\\n                    fq.push(n);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Man failed to reach the finish\\n        if (man_reached == -1)\\n            return -1;\\n        \\n\\t\\t// Fire failed to reach the finish\\n        if (fire_reached == -1)\\n            return 1e9;\\n        \\n\\t\\t// Otherwise return the difference between fire\\'s steps and man\\'s.\\n        return fire_reached - man_reached - 1;\\n    }\\n    \\n    \\npublic:\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\t\\t// Perform the first BFS without waiting by man\\n        int first = maximumMinutesWaited(grid, 0);\\n        \\n        if (first == -1 || first == 1e9)\\n            return first;\\n        \\n\\t\\t// Perform the second BFS to check whether man is able to find other way to the\\n\\t\\t// finish to reach it at the same time with fire\\n        int second = maximumMinutesWaited(grid, first + 1);\\n        \\n        if (second == -1)\\n            return first;\\n        \\n\\t\\t// If man succeed in the second attempt and another step the the first result\\n        return first + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Some auxiliary stuff\\nusing Point = pair<int, int>;\\nPoint operator+(Point& l, Point& r) {\\n    return {l.first + r.first, l.second + r.second};\\n}\\nvector<Point> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nbool in_borders(vector<vector<int>>& grid, Point& p) {\\n    return !(p.first < 0 || p.first >= grid.size() || p.second < 0 || p.second >= grid[0].size());\\n}\\n\\nclass Solution {\\n\\n\\t// This function performs BFS for the man and fire simultaneously. The idea is \\n\\t// trying to reach the finish cell by both man and fire, and if man reaches first \\n\\t// count the number of steps he waits fire at the end. The only special case\\n\\t// is when the fire reaches the finish at the same time as man does it.\\n\\t//\\n\\t// Args:\\n\\t// grid - copy the original grid since it will be modified\\n\\t// wait - it is possible to set how long man should wait at the beginning.\\n    int maximumMinutesWaited(vector<vector<int>> grid, int wait) {\\n        queue<Point> q;\\n        q.push({0, 0});\\n        grid[0][0] = 10;\\n\\n        queue<Point> fq;\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid[0].size(); j++) {\\n                if (grid[i][j] == 1) {\\n                    fq.push({i, j});\\n                }\\n            }\\n        }\\n        \\n        int step = 0;\\n        int man_reached = -1;\\n        int fire_reached = -1;\\n\\n        while (!q.empty() || !fq.empty()) {\\n            step++;\\n            \\n\\t\\t\\t// Firstly perform man\\'s move\\n            int size = q.size();\\n            if (step > wait) {\\n                for (int i = 0; i < size; i++) {\\n                    auto p = q.front(); q.pop(); \\n\\n                    if (grid[p.first][p.second] == 1)\\n                        continue;\\n\\n                    for (auto& dir : dirs) {\\n                        auto n = p + dir;\\n\\n                        if (!in_borders(grid, n))\\n                            continue;\\n\\n                        if (grid[n.first][n.second] != 0)\\n                            continue;\\n\\n                        grid[n.first][n.second] = 1000 + step;\\n\\n                        if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                            man_reached = step;\\n                        }\\n\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// Secondly spread the fire\\n            size = fq.size();\\n            for (int i = 0; i < size; i++) {\\n                auto p = fq.front(); fq.pop(); \\n                \\n                for (auto dir : dirs) {\\n                    auto n = p + dir;\\n\\n                    if (!in_borders(grid, n))\\n                        continue;\\n\\n                    if (grid[n.first][n.second] == 2 || grid[n.first][n.second] == 1)\\n                        continue;\\n                    \\n                    if (n.first == grid.size() - 1 && n.second == grid[0].size() - 1) {\\n                        fire_reached = step;\\n                        \\n\\t\\t\\t\\t\\t\\t// Special case when fire reaches the end at the same turn as man does\\n                        if (grid[n.first][n.second] == 1000 + step)\\n                            return 0;\\n                    }\\n                    \\n                    grid[n.first][n.second] = 1;\\n                    fq.push(n);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// Man failed to reach the finish\\n        if (man_reached == -1)\\n            return -1;\\n        \\n\\t\\t// Fire failed to reach the finish\\n        if (fire_reached == -1)\\n            return 1e9;\\n        \\n\\t\\t// Otherwise return the difference between fire\\'s steps and man\\'s.\\n        return fire_reached - man_reached - 1;\\n    }\\n    \\n    \\npublic:\\n\\n\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n\\t\\t// Perform the first BFS without waiting by man\\n        int first = maximumMinutesWaited(grid, 0);\\n        \\n        if (first == -1 || first == 1e9)\\n            return first;\\n        \\n\\t\\t// Perform the second BFS to check whether man is able to find other way to the\\n\\t\\t// finish to reach it at the same time with fire\\n        int second = maximumMinutesWaited(grid, first + 1);\\n        \\n        if (second == -1)\\n            return first;\\n        \\n\\t\\t// If man succeed in the second attempt and another step the the first result\\n        return first + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997476,
                "title": "alternative-solution-in-javascript-bfs-binsearch",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n  const [m, n] = [grid.length, grid[0].length];\\n  const dir = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n  ];\\n\\n  function isValidCell(x, y) {\\n    return x >= 0 && x < m && y >= 0 && y < n;\\n  }\\n\\n  const fireDist = new Array(m);\\n  for (let i = 0; i < m; i++) {\\n    fireDist[i] = new Array(n).fill(Infinity);\\n  }\\n\\n  const firePoints = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        firePoints.push([i, j]);\\n        fireDist[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  while (firePoints.length) {\\n    const [x0, y0] = firePoints.shift();\\n\\n    for (const [dx, dy] of dir) {\\n      const [x1, y1] = [x0 + dx, y0 + dy];\\n\\n      if (isValidCell(x1, y1) && grid[x1][y1] === 0 && fireDist[x0][y0] + 1 < fireDist[x1][y1]) {\\n        fireDist[x1][y1] = fireDist[x0][y0] + 1;\\n        firePoints.push([x1, y1]);\\n      }\\n    }\\n  }\\n\\n  function canEscape(delay) {\\n    const visited = new Array(m);\\n    for (let i = 0; i < m; i++) {\\n      visited[i] = new Array(n).fill(false);\\n    }\\n\\n    const queue = [[0, 0]];\\n    let currMinutes = delay;\\n\\n    while (queue.length) {\\n      currMinutes++;\\n\\n      for (let i = queue.length; i > 0; i--) {\\n        const [i0, j0] = queue.shift();\\n        visited[i0][j0] = true;\\n\\n        for (const [di, dj] of dir) {\\n          const [i1, j1] = [i0 + di, j0 + dj];\\n\\n          if (\\n            isValidCell(i1, j1) &&\\n            grid[i1][j1] === 0 &&\\n            !visited[i1][j1] &&\\n            (currMinutes < fireDist[i1][j1] || (currMinutes === fireDist[i1][j1] && i1 === m - 1 && j1 === n - 1))\\n          ) {\\n            if (i1 === m - 1 && j1 === n - 1) {\\n              return true;\\n            }\\n            queue.push([i1, j1]);\\n          }\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  let [left, right] = [-1, 1_000_000_000];\\n\\n  while (left < right) {\\n    const middle = Math.floor((left + right + 1) / 2);\\n\\n    if (canEscape(middle)) {\\n      left = middle;\\n    } else {\\n      right = middle - 1;\\n    }\\n  }\\n\\n  return left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar maximumMinutes = function (grid) {\\n  const [m, n] = [grid.length, grid[0].length];\\n  const dir = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n  ];\\n\\n  function isValidCell(x, y) {\\n    return x >= 0 && x < m && y >= 0 && y < n;\\n  }\\n\\n  const fireDist = new Array(m);\\n  for (let i = 0; i < m; i++) {\\n    fireDist[i] = new Array(n).fill(Infinity);\\n  }\\n\\n  const firePoints = [];\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      if (grid[i][j] === 1) {\\n        firePoints.push([i, j]);\\n        fireDist[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  while (firePoints.length) {\\n    const [x0, y0] = firePoints.shift();\\n\\n    for (const [dx, dy] of dir) {\\n      const [x1, y1] = [x0 + dx, y0 + dy];\\n\\n      if (isValidCell(x1, y1) && grid[x1][y1] === 0 && fireDist[x0][y0] + 1 < fireDist[x1][y1]) {\\n        fireDist[x1][y1] = fireDist[x0][y0] + 1;\\n        firePoints.push([x1, y1]);\\n      }\\n    }\\n  }\\n\\n  function canEscape(delay) {\\n    const visited = new Array(m);\\n    for (let i = 0; i < m; i++) {\\n      visited[i] = new Array(n).fill(false);\\n    }\\n\\n    const queue = [[0, 0]];\\n    let currMinutes = delay;\\n\\n    while (queue.length) {\\n      currMinutes++;\\n\\n      for (let i = queue.length; i > 0; i--) {\\n        const [i0, j0] = queue.shift();\\n        visited[i0][j0] = true;\\n\\n        for (const [di, dj] of dir) {\\n          const [i1, j1] = [i0 + di, j0 + dj];\\n\\n          if (\\n            isValidCell(i1, j1) &&\\n            grid[i1][j1] === 0 &&\\n            !visited[i1][j1] &&\\n            (currMinutes < fireDist[i1][j1] || (currMinutes === fireDist[i1][j1] && i1 === m - 1 && j1 === n - 1))\\n          ) {\\n            if (i1 === m - 1 && j1 === n - 1) {\\n              return true;\\n            }\\n            queue.push([i1, j1]);\\n          }\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  let [left, right] = [-1, 1_000_000_000];\\n\\n  while (left < right) {\\n    const middle = Math.floor((left + right + 1) / 2);\\n\\n    if (canEscape(middle)) {\\n      left = middle;\\n    } else {\\n      right = middle - 1;\\n    }\\n  }\\n\\n  return left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997204,
                "title": "c-bfs-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j){\\n        if(i<0||i>=n||j<0||j>=m) return 0;\\n        return 1;\\n    }\\n    bool find(vector<vector<int>>& nums, int t){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        bool st = 0;\\n        unordered_map<int,int> mp; mp[0]++;\\n        while(!q.empty() && !st){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(i==n-1 && j==m-1 && (nums[i][j]>=t || nums[i][j]==-1)) {st = 1; break;}\\n                if((nums[i][j]<=t && nums[i][j]!=-1)|| nums[i][j]==INT_MAX) continue;\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    int p = m*x+y;\\n                    if(check(x,y) && nums[x][y]!=INT_MAX && mp.find(p)==mp.end()){\\n                        q.push({x,y}); mp[p]++;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return st;\\n    }\\n    int BS(vector<vector<int>>& nums){\\n        int l = 0,h=n*m,re=-1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)) {\\n                l = m+1; re = m;\\n                cout<<m<<endl;\\n            }\\n            else h = m-1;\\n        }\\n        if(re>=n*m) return 1e9;\\n        return re;\\n    }\\n    int maximumMinutes(vector<vector<int>>& arr) {\\n        queue<pair<int,int>> q;\\n        n = arr.size(),m = arr[0].size();\\n        vector<vector<int>> nums(n,vector<int>(m,-1));\\n        for(int i = 0;i<n;++i){\\n            for(int j = 0;j<m;++j){\\n                if(arr[i][j]==2) {nums[i][j] = INT_MAX; continue;}\\n                else if(arr[i][j]==1) {q.push({i,j}); nums[i][j] = 0; continue;}\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(check(x,y) && nums[x][y]==-1){\\n                        q.push({x,y}); nums[x][y] = l+1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return BS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j){\\n        if(i<0||i>=n||j<0||j>=m) return 0;\\n        return 1;\\n    }\\n    bool find(vector<vector<int>>& nums, int t){\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        bool st = 0;\\n        unordered_map<int,int> mp; mp[0]++;\\n        while(!q.empty() && !st){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                if(i==n-1 && j==m-1 && (nums[i][j]>=t || nums[i][j]==-1)) {st = 1; break;}\\n                if((nums[i][j]<=t && nums[i][j]!=-1)|| nums[i][j]==INT_MAX) continue;\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    int p = m*x+y;\\n                    if(check(x,y) && nums[x][y]!=INT_MAX && mp.find(p)==mp.end()){\\n                        q.push({x,y}); mp[p]++;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return st;\\n    }\\n    int BS(vector<vector<int>>& nums){\\n        int l = 0,h=n*m,re=-1;\\n        while(l<=h){\\n            int m = (l+h)/2;\\n            if(find(nums,m)) {\\n                l = m+1; re = m;\\n                cout<<m<<endl;\\n            }\\n            else h = m-1;\\n        }\\n        if(re>=n*m) return 1e9;\\n        return re;\\n    }\\n    int maximumMinutes(vector<vector<int>>& arr) {\\n        queue<pair<int,int>> q;\\n        n = arr.size(),m = arr[0].size();\\n        vector<vector<int>> nums(n,vector<int>(m,-1));\\n        for(int i = 0;i<n;++i){\\n            for(int j = 0;j<m;++j){\\n                if(arr[i][j]==2) {nums[i][j] = INT_MAX; continue;}\\n                else if(arr[i][j]==1) {q.push({i,j}); nums[i][j] = 0; continue;}\\n            }\\n        }\\n        int l = 0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                auto[i,j] = q.front(); q.pop();\\n                for(int k = 0;k<4;++k){\\n                    int x=i+d[k][0], y=j+d[k][1];\\n                    if(check(x,y) && nums[x][y]==-1){\\n                        q.push({x,y}); nums[x][y] = l+1;\\n                    }\\n                }\\n            }\\n            l++;\\n        }\\n        return BS(nums);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1996097,
                "title": "no-need-of-binary-search-c-best-bfs-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool inGrid(int i, int j, int n, int m) {\\n        if (i < 0 || j < 0 || i >= n || j >= m) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    void BFS(vector<vector<int>> grid, vector<vector<int>> &T) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    T[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            int x = cur.first, y = cur.second;\\n            int d = T[x][y];\\n            for(auto z : dir) {\\n                int x1 = x + z[0];\\n                int y1 = y + z[1];\\n                if (inGrid(x1,y1,n,m) && T[x1][y1] > 1 + T[x][y] && grid[x1][y1] == 0) {\\n                    T[x1][y1] = 1 + T[x][y];\\n                    q.push({x1,y1});\\n                }\\n            }\\n        }\\n    }\\n    int DFS(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& T, int n, int m, int steps) {\\n        if (i == n - 1 && j == m - 1) {\\n            if (steps <= T[i][j]) {\\n                return T[i][j] - steps;\\n            }\\n            return -1;\\n        }\\n        grid[i][j] = 3;\\n        int ans1 = max(-1, T[i][j] - steps - 1);\\n        int ans = -1;\\n        for(auto d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if (inGrid(x, y, n, m) && grid[x][y] == 0 && T[x][y] > steps) {\\n                ans = max(ans, DFS(grid,x,y,T,n,m,steps+1));\\n            }\\n        }\\n        return min(ans1,ans);\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n        vector<vector<int>> T(rows, vector<int>(columns,1e9));\\n        BFS(grid, T);\\n        \\n        int ans = DFS(grid, 0, 0, T, rows, columns, 0);\\n        if (ans > rows * columns) {\\n            return 1e9;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    bool inGrid(int i, int j, int n, int m) {\\n        if (i < 0 || j < 0 || i >= n || j >= m) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    void BFS(vector<vector<int>> grid, vector<vector<int>> &T) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    T[i][j] = 0;\\n                    q.push({i,j});\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty()) {\\n            pair<int,int> cur = q.front();\\n            q.pop();\\n            int x = cur.first, y = cur.second;\\n            int d = T[x][y];\\n            for(auto z : dir) {\\n                int x1 = x + z[0];\\n                int y1 = y + z[1];\\n                if (inGrid(x1,y1,n,m) && T[x1][y1] > 1 + T[x][y] && grid[x1][y1] == 0) {\\n                    T[x1][y1] = 1 + T[x][y];\\n                    q.push({x1,y1});\\n                }\\n            }\\n        }\\n    }\\n    int DFS(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& T, int n, int m, int steps) {\\n        if (i == n - 1 && j == m - 1) {\\n            if (steps <= T[i][j]) {\\n                return T[i][j] - steps;\\n            }\\n            return -1;\\n        }\\n        grid[i][j] = 3;\\n        int ans1 = max(-1, T[i][j] - steps - 1);\\n        int ans = -1;\\n        for(auto d : dir) {\\n            int x = i + d[0];\\n            int y = j + d[1];\\n            if (inGrid(x, y, n, m) && grid[x][y] == 0 && T[x][y] > steps) {\\n                ans = max(ans, DFS(grid,x,y,T,n,m,steps+1));\\n            }\\n        }\\n        return min(ans1,ans);\\n    }\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int columns = grid[0].size();\\n        vector<vector<int>> T(rows, vector<int>(columns,1e9));\\n        BFS(grid, T);\\n        \\n        int ans = DFS(grid, 0, 0, T, rows, columns, 0);\\n        if (ans > rows * columns) {\\n            return 1e9;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996081,
                "title": "bfs-binary-search",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int magic = 1000000000;\\n    public int maximumMinutes(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        Queue<int[]> fire = new LinkedList<>();\\n        int time = 1;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 2) {\\n                    grid[i][j] = -1;\\n                }\\n                if(grid[i][j] == 1) {\\n                    fire.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        while(!fire.isEmpty()) {\\n            int sz = fire.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = fire.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != 0) {\\n                        continue;\\n                    }\\n                    grid[x][y] = time;\\n                    fire.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        int l = 0, r = row * col - 1, mid = -1;\\n        if(!guess(grid, row, col, l)) return -1;\\n        if(guess(grid, row, col, r)) return magic;\\n        while(r > l) {\\n            mid = r - (r - l) / 2;\\n            if(guess(grid, row, col, mid)) {\\n                l = mid;\\n            }\\n            else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean guess(int[][] grid, int row, int col, int t) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        int time = t + 1;\\n        boolean[][] seen = new boolean[row][col];\\n        seen[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = q.poll();\\n                if(pos[0] == row - 1 && pos[1] == col - 1) return true;\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] == -1 || seen[x][y]) {\\n                        continue;\\n                    }\\n                    seen[x][y] = true;\\n                    if(grid[x][y] > 0 && grid[x][y] <= time) {\\n                        if(x == row - 1 && y == col - 1 && grid[x][y] == time) return true;\\n                        continue;\\n                    }\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int magic = 1000000000;\\n    public int maximumMinutes(int[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        Queue<int[]> fire = new LinkedList<>();\\n        int time = 1;\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(grid[i][j] == 2) {\\n                    grid[i][j] = -1;\\n                }\\n                if(grid[i][j] == 1) {\\n                    fire.add(new int[]{i, j});\\n                }\\n            }\\n        }\\n\\n        while(!fire.isEmpty()) {\\n            int sz = fire.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = fire.poll();\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] != 0) {\\n                        continue;\\n                    }\\n                    grid[x][y] = time;\\n                    fire.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        int l = 0, r = row * col - 1, mid = -1;\\n        if(!guess(grid, row, col, l)) return -1;\\n        if(guess(grid, row, col, r)) return magic;\\n        while(r > l) {\\n            mid = r - (r - l) / 2;\\n            if(guess(grid, row, col, mid)) {\\n                l = mid;\\n            }\\n            else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean guess(int[][] grid, int row, int col, int t) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        int time = t + 1;\\n        boolean[][] seen = new boolean[row][col];\\n        seen[0][0] = true;\\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            time++;\\n            for(int i = 0; i < sz; i++) {\\n                int[] pos = q.poll();\\n                if(pos[0] == row - 1 && pos[1] == col - 1) return true;\\n                for(int j = 0; j < 4; j++) {\\n                    int x = dirs[j][0] + pos[0], y = dirs[j][1] + pos[1];\\n                    if(x < 0 || x >= row || y < 0 || y >= col || grid[x][y] == -1 || seen[x][y]) {\\n                        continue;\\n                    }\\n                    seen[x][y] = true;\\n                    if(grid[x][y] > 0 && grid[x][y] <= time) {\\n                        if(x == row - 1 && y == col - 1 && grid[x][y] == time) return true;\\n                        continue;\\n                    }\\n                    q.add(new int[]{x, y});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996025,
                "title": "python-3-single-bfs-100-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/images/bc905de2-6362-4b5e-97cf-43babd412254_1651435566.9294689.png)\\n\\nBFS, add the person\\'s and fires locations to stack as tuple (i, j, label). I use 0 to label person, and 1 to label fire. For the person\\'s cell, set its value to -1, which will be used in the next timestamp to check whether fire has reach the same cell. Note that we add person before fire, which guarantees person moves before fire, and fires\\' move will overwrite the person\\'s, to be described later.\\n\\nIn each BFS step, left pop the stack. \\n\\nIf a person location popped, i.e. label == 0, check the cell value, if it is still -1, meaning fire not reach the location during previous step, and then the person can start to move to the neighboring cells which still have grass (value == 0). Note to set cell value to -1 after pushing to stack.\\n\\nFor a fire front location, i.e. label == 1, it spreads to its neighboring cells with a value 0 (grass) or -1 (person), and overwrites those cells value with 1. It at a particular step all -1 cells are overwritten by fire, the person is unable to escape to the safehouse.\\n\\nUsing aforementioned strategy, we can find minimum minutes required for person and fire to arrive at the safe house. Now the tricky part is how many minutes the person can stand still before starting to run for the safe house. The last few test cases are quite intriguing and most useful for debugging:\\n```\\n[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0],[0,2,0,2,0],[0,2,0,2,0],[0,2,1,2,0],[0,2,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0,0],[0,2,2,2,2,0],[0,0,0,1,2,0],[0,2,2,2,2,0],[0,0,0,0,0,0]]\\n```\\nThe problem statement has an important message \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\" E.g. the first case above, although person and fire reach the safehouse at the samte time, but from different directions, therefore the person can still be safe if starts to run at minute 0. Greedily, when arriving at the safehouse, we track how many possible directions one can run into it (for person and fire respectively). If the person has more choices of diretions than the fire, he/she can choose the extra direction, otherwise, must arrive at least 1 minute earlier than fires. `t_fire - t_person - int(d_person == d_fire)` gives the answer how many minutes the person can stand still and watch fires spread...\\n\\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        stk = deque()\\n        # person\\n        stk.append((0, 0, 0))\\n        grid[0][0] = -1\\n        # fire\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    stk.append((i, j, 1))\\n        \\n        t_person = inf\\n        d_person = set()\\n        t_fire = inf\\n        d_fire = set()\\n        t = 0\\n        while stk:\\n            stk.append(None)\\n            while stk[0]:\\n                i, j, p = stk.popleft()\\n                if p == 0:\\n                    if grid[i][j] == -1: # fire not arrived at i, j\\n                        for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                            if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] == 0:\\n                                if i1 == m - 1 and j1 == n - 1 and t <= t_person:\\n                                    t_person = t\\n                                    d_person.add(d)\\n                                else:\\n                                    stk.append((i1, j1, 0))\\n                                    grid[i1][j1] = -1\\n                else:\\n                    for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                        if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] <= 0:\\n                            if i1 == m - 1 and j1 == n - 1 and t <= t_fire:\\n                                t_fire = t\\n                                d_fire.add(d)\\n                            else:\\n                                stk.append((i1, j1, 1))\\n                                grid[i1][j1] = 1\\n            stk.popleft()\\n            if t_person == inf:\\n                if not stk or stk[0][-1] == 1:\\n                    return -1\\n            t += 1\\n        \\n        if t_person == inf:\\n            return -1\\n        if t_fire == inf:\\n            return 1_000_000_000\\n        return t_fire - t_person - int(d_person == d_fire)\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n[[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0],[0,2,0,2,0],[0,2,0,2,0],[0,2,1,2,0],[0,2,2,2,0],[0,0,0,0,0]]\\n[[0,0,0,0,0,0],[0,2,2,2,2,0],[0,0,0,1,2,0],[0,2,2,2,2,0],[0,0,0,0,0,0]]\\n```\n```\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        stk = deque()\\n        # person\\n        stk.append((0, 0, 0))\\n        grid[0][0] = -1\\n        # fire\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    stk.append((i, j, 1))\\n        \\n        t_person = inf\\n        d_person = set()\\n        t_fire = inf\\n        d_fire = set()\\n        t = 0\\n        while stk:\\n            stk.append(None)\\n            while stk[0]:\\n                i, j, p = stk.popleft()\\n                if p == 0:\\n                    if grid[i][j] == -1: # fire not arrived at i, j\\n                        for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                            if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] == 0:\\n                                if i1 == m - 1 and j1 == n - 1 and t <= t_person:\\n                                    t_person = t\\n                                    d_person.add(d)\\n                                else:\\n                                    stk.append((i1, j1, 0))\\n                                    grid[i1][j1] = -1\\n                else:\\n                    for i1, j1, d in (i - 1, j, \\'u\\'), (i + 1, j, \\'d\\'), (i, j - 1, \\'l\\'), (i, j + 1, \\'r\\'):\\n                        if 0 <= i1 < m and 0 <= j1 < n and grid[i1][j1] <= 0:\\n                            if i1 == m - 1 and j1 == n - 1 and t <= t_fire:\\n                                t_fire = t\\n                                d_fire.add(d)\\n                            else:\\n                                stk.append((i1, j1, 1))\\n                                grid[i1][j1] = 1\\n            stk.popleft()\\n            if t_person == inf:\\n                if not stk or stk[0][-1] == 1:\\n                    return -1\\n            t += 1\\n        \\n        if t_person == inf:\\n            return -1\\n        if t_fire == inf:\\n            return 1_000_000_000\\n        return t_fire - t_person - int(d_person == d_fire)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1996019,
                "title": "two-bfs-instead-of-binary-search-100-c-64-ms",
                "content": "Using bfs instead of binary search.\\n\\n1 First bfs start from each fire,  results time to catch fire  for each cell. \\n2 Second bfs start from (0,0) ,  for each cell, update the mininal diff  time to catch fire - current distance to (0,0).  For last safe house, the value is  diff  time to catch fire - current distance to (0,0) + 1.  end when there is no cell to update.\\n3 if safe house is reachable , return \\n\\n```\\nstruct node {\\n    int w;\\n    int x;\\n    int y;\\n    node(int w1, int x1, int y1) {\\n        w = w1;\\n        x = x1;\\n        y = y1;\\n    }\\n};\\nstruct cmp {\\n    bool operator() (const node& l, const node& r) {\\n        return l.w <= r.w;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> dis;\\n    int n;\\n    int m;\\n    const int c_mt = (int)(1e9);\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, c_mt));\\n        dis = vector<vector<int>>(n, vector<int>(m, 0));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0;  j < m; j++) {\\n                if (grid[i][j] == 2) {\\n                    // wall\\n                    dp[i][j] = INT_MAX;\\n                } else if (grid[i][j] == 1) {\\n                    // fire\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    dp[i][j] = c_mt;\\n                }\\n            }\\n        }\\n        //cout << q.size() << endl;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            int t = dp[x][y] + 1;\\n            static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n            for (int d = 0; d < 4; d++) {\\n                int x1 = x + dir[d][0];\\n                int y1 = y + dir[d][1];\\n                if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] == c_mt) {\\n                    dp[x1][y1] = t;\\n                    q.push({x1, y1});\\n                }\\n            }\\n        }\\n        int d = 0;\\n        q.push({0, 0});\\n            \\n            \\n        dis[0][0] = dp[0][0] - d;\\n        dis[n -1][m-1] = 0;\\n        while (!q.empty()) {\\n            int l = q.size();\\n            d++;\\n            for (int i = 0; i< l; i++) {\\n                auto p = q.front();\\n                q.pop();\\n                int x = p.first;\\n                int y = p.second;\\n                if (dis[x][y] <= 0) continue;\\n                static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n                for (int i = 0; i < 4; i++) {\\n                    int x1 = x + dir[i][0];\\n                    int y1 = y + dir[i][1];\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] != INT_MAX) {\\n                        int e =0;\\n                        if (x1 == n -1 && y1 == m - 1) e = 1;\\n                        int cur = dp[x1][y1] - d + e;\\n                        if (dp[x1][y1] == c_mt)  cur = c_mt;\\n                        \\n                        int tmp = min(dis[x][y], cur);\\n                        if (dis[x1][y1] < tmp) {\\n                            if ((x1 != n -1) || (y1 != m -1)) q.push({x1, y1});\\n                            dis[x1][y1]  = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dis[n-1][m-1] < 0) return -1;\\n        if (dis[n-1][m-1] >=  c_mt) return c_mt;\\n        return dis[n-1][m-1] - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct node {\\n    int w;\\n    int x;\\n    int y;\\n    node(int w1, int x1, int y1) {\\n        w = w1;\\n        x = x1;\\n        y = y1;\\n    }\\n};\\nstruct cmp {\\n    bool operator() (const node& l, const node& r) {\\n        return l.w <= r.w;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<int>> dis;\\n    int n;\\n    int m;\\n    const int c_mt = (int)(1e9);\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, c_mt));\\n        dis = vector<vector<int>>(n, vector<int>(m, 0));\\n        queue<pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0;  j < m; j++) {\\n                if (grid[i][j] == 2) {\\n                    // wall\\n                    dp[i][j] = INT_MAX;\\n                } else if (grid[i][j] == 1) {\\n                    // fire\\n                    dp[i][j] = 0;\\n                    q.push({i, j});\\n                } else {\\n                    dp[i][j] = c_mt;\\n                }\\n            }\\n        }\\n        //cout << q.size() << endl;\\n        while (!q.empty()) {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            int t = dp[x][y] + 1;\\n            static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n            for (int d = 0; d < 4; d++) {\\n                int x1 = x + dir[d][0];\\n                int y1 = y + dir[d][1];\\n                if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] == c_mt) {\\n                    dp[x1][y1] = t;\\n                    q.push({x1, y1});\\n                }\\n            }\\n        }\\n        int d = 0;\\n        q.push({0, 0});\\n            \\n            \\n        dis[0][0] = dp[0][0] - d;\\n        dis[n -1][m-1] = 0;\\n        while (!q.empty()) {\\n            int l = q.size();\\n            d++;\\n            for (int i = 0; i< l; i++) {\\n                auto p = q.front();\\n                q.pop();\\n                int x = p.first;\\n                int y = p.second;\\n                if (dis[x][y] <= 0) continue;\\n                static int dir[4][2] = {{1, 0}, {0,1}, {0,-1}, {-1, 0}};\\n                for (int i = 0; i < 4; i++) {\\n                    int x1 = x + dir[i][0];\\n                    int y1 = y + dir[i][1];\\n                    if (x1 >= 0 && x1 < n && y1 >= 0 && y1 < m && dp[x1][y1] != INT_MAX) {\\n                        int e =0;\\n                        if (x1 == n -1 && y1 == m - 1) e = 1;\\n                        int cur = dp[x1][y1] - d + e;\\n                        if (dp[x1][y1] == c_mt)  cur = c_mt;\\n                        \\n                        int tmp = min(dis[x][y], cur);\\n                        if (dis[x1][y1] < tmp) {\\n                            if ((x1 != n -1) || (y1 != m -1)) q.push({x1, y1});\\n                            dis[x1][y1]  = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (dis[n-1][m-1] < 0) return -1;\\n        if (dis[n-1][m-1] >=  c_mt) return c_mt;\\n        return dis[n-1][m-1] - 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1996000,
                "title": "c-solution",
                "content": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size(), m = sz(g[0]);\\n        queue <array<int, 2>> Q;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        vector <vector<int>> time(n, vector<int>(m, -1));\\n        vector <vector<int>> dis(n, vector<int>(m, -1));\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = 0; j < m; ++j) {\\n            if (g[i][j] == 1) {\\n              Q.push({i, j});\\n              time[i][j] = 0;\\n            }\\n          }\\n        }\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and time[xx][yy] == -1) {\\n              time[xx][yy] = time[x][y] + 1;\\n              Q.push({xx, yy});\\n            }\\n          }\\n        }\\n        dis[0][0] = 0;\\n        Q.push({0, 0});\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and dis[xx][yy] == -1) {\\n              Q.push({xx, yy});\\n              dis[xx][yy] = dis[x][y] + 1; \\n            }\\n          }\\n        }\\n        int l = 0, r = m * n + 10;\\n        int ans = -1;\\n        auto ok = [&](int mi) {\\n          queue <array<int, 2>> q;\\n          q.push({0, 0});\\n           vector<vector<int>> vis(n, vector<int>(m, 0)); \\n          while (!q.empty()) {\\n            auto now = q.front();\\n            q.pop();\\n            int x = now[0], y = now[1];\\n            if (x == n - 1 and y == m - 1) {\\n              return true;\\n            }\\n              vis[x][y] = 1;\\n            for (int i = 0; i < 4; ++i) {\\n              int xx = x + dx[i];\\n              int yy = y + dy[i];\\n              if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and !vis[xx][yy]) {\\n                  if (xx == n - 1 and yy == m - 1 and (dis[xx][yy] + mi <= time[xx][yy] or time[xx][yy] == -1))\\n                    q.push({xx, yy});\\n                  else if ((time[xx][yy] == -1) or dis[xx][yy] + mi < time[xx][yy]) {\\n                      q.push({xx, yy});\\n                  }\\n              }\\n            }\\n          }\\n          return false;\\n        };\\n        // for (int i = 0; i < n; ++i) {\\n        //     for (int j = 0; j < m; ++j) {\\n        //         cout << time[i][j] << \" \";\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        while (l <= r) {\\n          int mid = (l + r) >> 1;\\n          if (ok(mid)) {\\n            ans = mid;\\n            l = mid + 1;\\n          } else {\\n            r = mid - 1;\\n          }\\n        }\\n        if (ans > m * n) ans = 1e9;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 200005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& g) {\\n        int n = g.size(), m = sz(g[0]);\\n        queue <array<int, 2>> Q;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        vector <vector<int>> time(n, vector<int>(m, -1));\\n        vector <vector<int>> dis(n, vector<int>(m, -1));\\n        for (int i = 0; i < n; ++i) {\\n          for (int j = 0; j < m; ++j) {\\n            if (g[i][j] == 1) {\\n              Q.push({i, j});\\n              time[i][j] = 0;\\n            }\\n          }\\n        }\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and time[xx][yy] == -1) {\\n              time[xx][yy] = time[x][y] + 1;\\n              Q.push({xx, yy});\\n            }\\n          }\\n        }\\n        dis[0][0] = 0;\\n        Q.push({0, 0});\\n        while (!Q.empty()) {\\n          auto now = Q.front();\\n          Q.pop();\\n          int x = now[0], y = now[1];\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and dis[xx][yy] == -1) {\\n              Q.push({xx, yy});\\n              dis[xx][yy] = dis[x][y] + 1; \\n            }\\n          }\\n        }\\n        int l = 0, r = m * n + 10;\\n        int ans = -1;\\n        auto ok = [&](int mi) {\\n          queue <array<int, 2>> q;\\n          q.push({0, 0});\\n           vector<vector<int>> vis(n, vector<int>(m, 0)); \\n          while (!q.empty()) {\\n            auto now = q.front();\\n            q.pop();\\n            int x = now[0], y = now[1];\\n            if (x == n - 1 and y == m - 1) {\\n              return true;\\n            }\\n              vis[x][y] = 1;\\n            for (int i = 0; i < 4; ++i) {\\n              int xx = x + dx[i];\\n              int yy = y + dy[i];\\n              if (xx >= 0 and xx < n and yy >= 0 and yy < m and g[xx][yy] != 2 and !vis[xx][yy]) {\\n                  if (xx == n - 1 and yy == m - 1 and (dis[xx][yy] + mi <= time[xx][yy] or time[xx][yy] == -1))\\n                    q.push({xx, yy});\\n                  else if ((time[xx][yy] == -1) or dis[xx][yy] + mi < time[xx][yy]) {\\n                      q.push({xx, yy});\\n                  }\\n              }\\n            }\\n          }\\n          return false;\\n        };\\n        // for (int i = 0; i < n; ++i) {\\n        //     for (int j = 0; j < m; ++j) {\\n        //         cout << time[i][j] << \" \";\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        while (l <= r) {\\n          int mid = (l + r) >> 1;\\n          if (ok(mid)) {\\n            ans = mid;\\n            l = mid + 1;\\n          } else {\\n            r = mid - 1;\\n          }\\n        }\\n        if (ans > m * n) ans = 1e9;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1995959,
                "title": "so-excited-i-did-solve-it-by-myself",
                "content": "\\n\\n```\\ndirs = [0, 1, 0, -1, 0]\\n\\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque([])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    grid[i][j] = -1\\n                elif grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    dq.append([i, j])\\n                else:    \\n                    grid[i][j] = -2\\n        step = 0\\n        while dq:\\n            step, ll = step + 1, len(dq)\\n            for _ in range(ll):\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1:\\n                        grid[ni][nj] = step\\n                        dq.append([ni, nj])\\n        if grid[0][0] == -1:\\n            # if can reach bottom_left\\n            dq = deque([[0, 0]])\\n            visit = set()\\n            visit.add((0, 0))\\n            while dq:\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1 and (ni, nj) not in visit:\\n                        if ni == m - 1 and nj == n - 1:\\n                            return 10 ** 9\\n                        visit.add((ni, nj))\\n                        dq.append([ni, nj])\\n                \\n            return -1\\n        l, r = 0, grid[0][0] - 1\\n\\n        def bisearch(top: int) -> bool:\\n            hq = [[-grid[0][0], 0, 0, top]]\\n            visit = set()\\n            visit.add((0, 0))\\n            while hq:\\n                _, i, j, d = heappop(hq)\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visit and (grid[ni][nj] > d + 1 or ni == m - 1 and nj == n - 1 and grid[ni][nj] == d + 1):\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        visit.add((ni, nj))\\n                        heappush(hq, [-grid[ni][nj], ni, nj, d + 1])\\n            return False\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if bisearch(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndirs = [0, 1, 0, -1, 0]\\n\\n\\nclass Solution:\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque([])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    grid[i][j] = -1\\n                elif grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    dq.append([i, j])\\n                else:    \\n                    grid[i][j] = -2\\n        step = 0\\n        while dq:\\n            step, ll = step + 1, len(dq)\\n            for _ in range(ll):\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1:\\n                        grid[ni][nj] = step\\n                        dq.append([ni, nj])\\n        if grid[0][0] == -1:\\n            # if can reach bottom_left\\n            dq = deque([[0, 0]])\\n            visit = set()\\n            visit.add((0, 0))\\n            while dq:\\n                i, j = dq.popleft()\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == -1 and (ni, nj) not in visit:\\n                        if ni == m - 1 and nj == n - 1:\\n                            return 10 ** 9\\n                        visit.add((ni, nj))\\n                        dq.append([ni, nj])\\n                \\n            return -1\\n        l, r = 0, grid[0][0] - 1\\n\\n        def bisearch(top: int) -> bool:\\n            hq = [[-grid[0][0], 0, 0, top]]\\n            visit = set()\\n            visit.add((0, 0))\\n            while hq:\\n                _, i, j, d = heappop(hq)\\n                for k in range(4):\\n                    ni, nj = i + dirs[k], j + dirs[k + 1]\\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visit and (grid[ni][nj] > d + 1 or ni == m - 1 and nj == n - 1 and grid[ni][nj] == d + 1):\\n                        if ni == m - 1 and nj == n - 1:\\n                            return True\\n                        visit.add((ni, nj))\\n                        heappush(hq, [-grid[ni][nj], ni, nj, d + 1])\\n            return False\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if bisearch(mid):\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995916,
                "title": "java-bfs-and-binary-search",
                "content": "Good simulation question combining **BFS** and **Binary search**\\n\\n> 1. We spread all the fires using **BFS** \\n>\\n> 2. We use **binary search** to find the biggest waiting minutes\\n>    * for each waiting minute we using **BFS** for the person\\n\\n```\\nclass Solution {\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    int MAX;\\n    public int maximumMinutes(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.MAX = 1_000_000_000;\\n        int[][] time = new int[m][n];\\n        \\n        // step 1) add walls and fires to time array\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) { // grass\\n                int stuff = grid[i][j];\\n                if (stuff == 0) {\\n                    time[i][j] = MAX;\\n                } else if (stuff == 1) { // fire\\n                    time[i][j] = 0;\\n                    queue.offer(new int[]{i, j});\\n                } else { // wall\\n                    time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // step 2) BFS for the fires, time[i][j] is the time when the fire come to this grid\\n        int minute = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n \\n                        && time[newRow][newCol] == MAX) {\\n                        time[newRow][newCol] = minute;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        \\n        // corner case: if the person and fire come to the safehouse at same time, he survived\\n        time[m - 1][n - 1] += 1;\\n        \\n        // step 3) Binary search the waiting time : TTTTTTFFFF find last T\\n        int left = -1;\\n        int right = m * n;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (escape(time, mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left == m * n ? MAX : left;        \\n    }\\n    \\n    // BFS for the person\\n    private boolean escape(int[][] time, int waiting) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int minute = waiting;\\n        \\n        if (time[0][0] <= minute) {\\n            return false;\\n        } else {\\n            visited[0][0] = true;\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                \\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n && !visited[newRow][newCol] && time[newRow][newCol] > minute + 1) {\\n                        // if the person and fire come to other grid at same time, he died\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return visited[m - 1][n - 1];\\n    }        \\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int m, n;\\n    int MAX;\\n    public int maximumMinutes(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.MAX = 1_000_000_000;\\n        int[][] time = new int[m][n];\\n        \\n        // step 1) add walls and fires to time array\\n        Queue<int[]> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i += 1) {\\n            for (int j = 0; j < n; j += 1) { // grass\\n                int stuff = grid[i][j];\\n                if (stuff == 0) {\\n                    time[i][j] = MAX;\\n                } else if (stuff == 1) { // fire\\n                    time[i][j] = 0;\\n                    queue.offer(new int[]{i, j});\\n                } else { // wall\\n                    time[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // step 2) BFS for the fires, time[i][j] is the time when the fire come to this grid\\n        int minute = 1;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n \\n                        && time[newRow][newCol] == MAX) {\\n                        time[newRow][newCol] = minute;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        \\n        // corner case: if the person and fire come to the safehouse at same time, he survived\\n        time[m - 1][n - 1] += 1;\\n        \\n        // step 3) Binary search the waiting time : TTTTTTFFFF find last T\\n        int left = -1;\\n        int right = m * n;\\n        while (left < right) {\\n            int mid = left + (right - left + 1) / 2;\\n            if (escape(time, mid)) {\\n                left = mid;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left == m * n ? MAX : left;        \\n    }\\n    \\n    // BFS for the person\\n    private boolean escape(int[][] time, int waiting) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0, 0});\\n        boolean[][] visited = new boolean[m][n];\\n        int minute = waiting;\\n        \\n        if (time[0][0] <= minute) {\\n            return false;\\n        } else {\\n            visited[0][0] = true;\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i += 1) {\\n                int[] curr = queue.poll();\\n                int row = curr[0];\\n                int col = curr[1];\\n                \\n                for (int[] dir: directions) {\\n                    int newRow = row + dir[0];\\n                    int newCol = col + dir[1];\\n                    if (0 <= newRow && newRow < m && 0 <= newCol && newCol < n && !visited[newRow][newCol] && time[newRow][newCol] > minute + 1) {\\n                        // if the person and fire come to other grid at same time, he died\\n                        visited[newRow][newCol] = true;\\n                        queue.offer(new int[]{newRow, newCol});\\n                    }\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return visited[m - 1][n - 1];\\n    }        \\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995880,
                "title": "my-non-binary-search-solution-bfs-dijkstra-python3",
                "content": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm,n=len(grid),len(grid[0])\\n\\n\\tfires=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\n\\tdef canMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tfireSeen=set()\\n\\tq=[]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]==1:\\n\\t\\t\\t\\theappush(q,(0,i,j))\\n\\n\\tmoves=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\twhile q:\\n\\t\\td,i,j=heappop(q)\\n\\t\\tif (i,j) in fireSeen:\\n\\t\\t\\tcontinue\\n\\t\\tfireSeen.add((i,j))\\n\\t\\tfires[i][j]=d\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tif (nexti,nextj) not in fireSeen:\\n\\t\\t\\t\\t\\theappush(q,(d+1,nexti,nextj))\\n\\n\\tdef humanMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\thumanseen=set()\\n\\twait=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\tq=[]\\n\\theappush(q,(-m*n,m*n,0,0)) #(initial wait,current time, i, j)\\n\\n\\twhile q:\\n\\t\\twait,time,i,j=heappop(q)\\n\\t\\twait*=-1\\n\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\tif wait==(m*n):\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn wait\\n\\t\\tif (i,j) in humanseen:\\n\\t\\t\\tcontinue\\n\\t\\thumanseen.add((i,j))\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tnewtime=time+1\\n\\t\\t\\t\\tif nexti==m-1 and nextj==n-1:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-fires[nexti][nextj]\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-(fires[nexti][nextj]-1)\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef maximumMinutes(self, grid: List[List[int]]) -> int:\\n\\tm,n=len(grid),len(grid[0])\\n\\n\\tfires=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\n\\tdef canMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\tfireSeen=set()\\n\\tq=[]\\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif grid[i][j]==1:\\n\\t\\t\\t\\theappush(q,(0,i,j))\\n\\n\\tmoves=[(0,1),(1,0),(0,-1),(-1,0)]\\n\\twhile q:\\n\\t\\td,i,j=heappop(q)\\n\\t\\tif (i,j) in fireSeen:\\n\\t\\t\\tcontinue\\n\\t\\tfireSeen.add((i,j))\\n\\t\\tfires[i][j]=d\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tif (nexti,nextj) not in fireSeen:\\n\\t\\t\\t\\t\\theappush(q,(d+1,nexti,nextj))\\n\\n\\tdef humanMove(i,j):\\n\\t\\tif i<0 or i==m or j<0 or j==n:\\n\\t\\t\\treturn False\\n\\t\\tif grid[i][j]==2:\\n\\t\\t\\treturn False\\n\\t\\treturn True\\n\\n\\thumanseen=set()\\n\\twait=[[float(\\'inf\\') for j in range(n)] for i in range(m)]\\n\\tq=[]\\n\\theappush(q,(-m*n,m*n,0,0)) #(initial wait,current time, i, j)\\n\\n\\twhile q:\\n\\t\\twait,time,i,j=heappop(q)\\n\\t\\twait*=-1\\n\\t\\tif i==m-1 and j==n-1:\\n\\t\\t\\tif wait==(m*n):\\n\\t\\t\\t\\treturn 10**9\\n\\t\\t\\treturn wait\\n\\t\\tif (i,j) in humanseen:\\n\\t\\t\\tcontinue\\n\\t\\thumanseen.add((i,j))\\n\\t\\tfor x,y in moves:\\n\\t\\t\\tnexti,nextj=i+x,j+y\\n\\t\\t\\tif canMove(nexti,nextj):\\n\\t\\t\\t\\tnewtime=time+1\\n\\t\\t\\t\\tif nexti==m-1 and nextj==n-1:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-fires[nexti][nextj]\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime:\\n\\t\\t\\t\\t\\t\\tif fires[nexti][nextj]<=newtime-wait:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tdiff=newtime-(fires[nexti][nextj]-1)\\n\\t\\t\\t\\t\\t\\tnewwait=wait-diff \\n\\t\\t\\t\\t\\t\\tif newwait<0:\\n\\t\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\t\\tnewtime=newtime-diff\\n\\t\\t\\t\\t\\t\\theappush(q,(-newwait,newtime,nexti,nextj))\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\theappush(q,(-wait,newtime,nexti,nextj))\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995740,
                "title": "c-bfs-binary-search-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        tbl_2d_optional_t tbl_fire_time(\\n            num_rows, std::vector<std::optional<int>>(num_cols)\\n        );\\n        \\n        // Mark cells by their earliest fire reach\\n        {\\n            std::queue<Record> curr_nodes, next_nodes;\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    if (grid[row][col] != 1) {\\n                        continue;\\n                    }\\n                    tbl_fire_time[row][col] = 0;\\n                    curr_nodes.push(Record{\\n                        .row = row, .col = col, .time = 0\\n                    });\\n                }\\n            }\\n            \\n            while (!curr_nodes.empty()) {\\n                for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                    auto &&record = curr_nodes.front();\\n                    for (int row = std::max(record.row - 1, 0); \\n                         row <= std::min(record.row + 1, num_rows - 1);\\n                         ++row) {\\n                        for (int col = std::max(record.col - 1, 0);\\n                             col <= std::min(record.col + 1, num_cols - 1);\\n                             ++col) {\\n                            if ((row == record.row) == (col == record.col)) {\\n                                continue;\\n                            }\\n                            if (grid[row][col] != 0) {\\n                                continue;\\n                            }\\n                            if (tbl_fire_time[row][col].has_value()) {\\n                                continue;\\n                            }\\n                            const int time = record.time + 1;\\n                            tbl_fire_time[row][col] = time;\\n                            next_nodes.push(Record{\\n                                .row = row, .col = col, .time = time\\n                            });\\n                        }\\n                    }\\n                }\\n                std::swap(curr_nodes, next_nodes);\\n            }                    \\n        }\\n        \\n        Context ctx {\\n            .num_rows = num_rows,\\n            .num_cols = num_cols,\\n            .tbl_fire_time = tbl_fire_time,\\n            .grid = grid\\n        };\\n        \\n        if (find(ctx, 1E9)) {\\n            return 1E9;\\n        }\\n        \\n        int lower = 0, upper = num_rows * num_cols + 1;\\n        while (lower < upper) {\\n            const int init_time = lower + (upper - lower) / 2;\\n            if (find(ctx, init_time)) {\\n                lower = init_time + 1;\\n            } else {\\n                upper = init_time;\\n            }\\n        }\\n        return upper - 1;\\n    }\\nprivate:\\n    using tbl_2d_optional_t = std::vector<std::vector<std::optional<int>>>;\\n\\n    struct Record {\\n        int row; \\n        int col;   \\n        int time;\\n    };    \\n    \\n    struct Context {\\n        const int num_rows;\\n        const int num_cols;\\n        const tbl_2d_optional_t &tbl_fire_time;\\n        const std::vector<std::vector<int>> &grid;\\n        \\n        bool is_final_cell(int row, int col) const {\\n            return (num_rows - 1 == row) && (num_cols - 1 == col);\\n        }\\n    };\\n            \\n    bool find(\\n        Context &ctx, \\n        const int init_time) const {\\n        std::vector<std::vector<bool>> visited(\\n            ctx.num_rows, std::vector<bool>(ctx.num_cols, false)\\n        );        \\n        const auto can_move_to_cell = \\n            [&ctx, &visited](const int row, const int col, const int time) -> bool {\\n            if ((ctx.grid[row][col] != 0) || visited[row][col]) {\\n                return false;\\n            }                     \\n            if (!ctx.tbl_fire_time[row][col].has_value()) {\\n                return true;\\n            } \\n            const int next_time = ctx.tbl_fire_time[row][col].value();\\n            if (next_time < time + 1) {\\n                return false;\\n            }\\n            if (ctx.is_final_cell(row, col) || (next_time > time + 1)) {\\n                return true;\\n            }   \\n            return false;\\n        };\\n                \\n        std:queue<Record> curr_nodes, next_nodes;\\n        curr_nodes.push(Record{\\n            .row = 0, .col = 0, .time = init_time\\n        });\\n        \\n        while (!curr_nodes.empty()) {\\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const auto &record = curr_nodes.front();\\n                for (int row = std::max(record.row - 1, 0); \\n                     row <= std::min(record.row + 1, ctx.num_rows - 1);\\n                     ++row) {\\n                    for (int col = std::max(record.col - 1, 0);\\n                         col <= std::min(record.col + 1, ctx.num_cols - 1);\\n                         ++col) {\\n                        if ((record.row == row) == (record.col == col)) {\\n                            continue;\\n                        }\\n                        if (!can_move_to_cell(row, col, record.time)) {\\n                            continue;\\n                        }\\n                        if (ctx.is_final_cell(row, col)) {\\n                            return true;\\n                        }\\n                        visited[row][col] = true;\\n                        next_nodes.push(Record{\\n                           .row = row, .col = col, .time = record.time + 1 \\n                        });\\n                    }\\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n        const int num_rows = grid.size(), num_cols = grid.front().size();\\n        tbl_2d_optional_t tbl_fire_time(\\n            num_rows, std::vector<std::optional<int>>(num_cols)\\n        );\\n        \\n        // Mark cells by their earliest fire reach\\n        {\\n            std::queue<Record> curr_nodes, next_nodes;\\n            for (int row = 0; row < num_rows; ++row) {\\n                for (int col = 0; col < num_cols; ++col) {\\n                    if (grid[row][col] != 1) {\\n                        continue;\\n                    }\\n                    tbl_fire_time[row][col] = 0;\\n                    curr_nodes.push(Record{\\n                        .row = row, .col = col, .time = 0\\n                    });\\n                }\\n            }\\n            \\n            while (!curr_nodes.empty()) {\\n                for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                    auto &&record = curr_nodes.front();\\n                    for (int row = std::max(record.row - 1, 0); \\n                         row <= std::min(record.row + 1, num_rows - 1);\\n                         ++row) {\\n                        for (int col = std::max(record.col - 1, 0);\\n                             col <= std::min(record.col + 1, num_cols - 1);\\n                             ++col) {\\n                            if ((row == record.row) == (col == record.col)) {\\n                                continue;\\n                            }\\n                            if (grid[row][col] != 0) {\\n                                continue;\\n                            }\\n                            if (tbl_fire_time[row][col].has_value()) {\\n                                continue;\\n                            }\\n                            const int time = record.time + 1;\\n                            tbl_fire_time[row][col] = time;\\n                            next_nodes.push(Record{\\n                                .row = row, .col = col, .time = time\\n                            });\\n                        }\\n                    }\\n                }\\n                std::swap(curr_nodes, next_nodes);\\n            }                    \\n        }\\n        \\n        Context ctx {\\n            .num_rows = num_rows,\\n            .num_cols = num_cols,\\n            .tbl_fire_time = tbl_fire_time,\\n            .grid = grid\\n        };\\n        \\n        if (find(ctx, 1E9)) {\\n            return 1E9;\\n        }\\n        \\n        int lower = 0, upper = num_rows * num_cols + 1;\\n        while (lower < upper) {\\n            const int init_time = lower + (upper - lower) / 2;\\n            if (find(ctx, init_time)) {\\n                lower = init_time + 1;\\n            } else {\\n                upper = init_time;\\n            }\\n        }\\n        return upper - 1;\\n    }\\nprivate:\\n    using tbl_2d_optional_t = std::vector<std::vector<std::optional<int>>>;\\n\\n    struct Record {\\n        int row; \\n        int col;   \\n        int time;\\n    };    \\n    \\n    struct Context {\\n        const int num_rows;\\n        const int num_cols;\\n        const tbl_2d_optional_t &tbl_fire_time;\\n        const std::vector<std::vector<int>> &grid;\\n        \\n        bool is_final_cell(int row, int col) const {\\n            return (num_rows - 1 == row) && (num_cols - 1 == col);\\n        }\\n    };\\n            \\n    bool find(\\n        Context &ctx, \\n        const int init_time) const {\\n        std::vector<std::vector<bool>> visited(\\n            ctx.num_rows, std::vector<bool>(ctx.num_cols, false)\\n        );        \\n        const auto can_move_to_cell = \\n            [&ctx, &visited](const int row, const int col, const int time) -> bool {\\n            if ((ctx.grid[row][col] != 0) || visited[row][col]) {\\n                return false;\\n            }                     \\n            if (!ctx.tbl_fire_time[row][col].has_value()) {\\n                return true;\\n            } \\n            const int next_time = ctx.tbl_fire_time[row][col].value();\\n            if (next_time < time + 1) {\\n                return false;\\n            }\\n            if (ctx.is_final_cell(row, col) || (next_time > time + 1)) {\\n                return true;\\n            }   \\n            return false;\\n        };\\n                \\n        std:queue<Record> curr_nodes, next_nodes;\\n        curr_nodes.push(Record{\\n            .row = 0, .col = 0, .time = init_time\\n        });\\n        \\n        while (!curr_nodes.empty()) {\\n            for (; !curr_nodes.empty(); curr_nodes.pop()) {\\n                const auto &record = curr_nodes.front();\\n                for (int row = std::max(record.row - 1, 0); \\n                     row <= std::min(record.row + 1, ctx.num_rows - 1);\\n                     ++row) {\\n                    for (int col = std::max(record.col - 1, 0);\\n                         col <= std::min(record.col + 1, ctx.num_cols - 1);\\n                         ++col) {\\n                        if ((record.row == row) == (record.col == col)) {\\n                            continue;\\n                        }\\n                        if (!can_move_to_cell(row, col, record.time)) {\\n                            continue;\\n                        }\\n                        if (ctx.is_final_cell(row, col)) {\\n                            return true;\\n                        }\\n                        visited[row][col] = true;\\n                        next_nodes.push(Record{\\n                           .row = row, .col = col, .time = record.time + 1 \\n                        });\\n                    }\\n                }\\n            }\\n            std::swap(curr_nodes, next_nodes);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995656,
                "title": "multi-source-bfs-binary-search",
                "content": "class Solution:\\n    #spread the fire simultaneously to all cells using multi-source BFS and then calculate the number of minutes to reach every cell.\\n    #binary search to see by varying the minutes and determine the max wait time\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        dist, fire_cells = {}, []\\n        \\n        for row in range(len(grid)):  #collect all the fire cells so that we can initiate a multiple source BFS\\n            for col in range(len(grid[0])):\\n                if grid[row][col] == 1:\\n                    fire_cells.append((0, row, col))\\n        \\n        def bfs(): #populate the earliest time when the fire would spread\\n            q = collections.deque(fire_cells)\\n            m, n = len(grid),  len(grid[0])\\n            while q:\\n                distance, row, col = q.popleft()\\n                neighbors =[(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\\n                for row1, col1 in neighbors:\\n                    if 0 <= row1 < m and 0 <= col1 < n \\\\\\n                    and (row1, col1) not in dist and  grid[row1][col1] != 2:\\n                        dist[(row1, col1)] = distance + 1\\n                        q.append((distance + 1, row1, col1))\\n                \\n        \\n        def check_fire(wait):\\n            q = collections.deque([(wait, 0, 0)])\\n            m, n, dist_2 = len(grid),  len(grid[0]), collections.defaultdict(int)\\n            while q:\\n                distance_2, row, col = q.popleft()\\n                \\n                if (row, col) == (m-1, n-1):\\n                    return True\\n                \\n                neighbors =[(row + 1, col), (row - 1, col), (row, col + 1), (row, col - 1)]\\n                for row1, col1 in neighbors:\\n                    if 0 <= row1 < m and 0 <= col1 < n \\\\\\n                    and (row1, col1) not in dist_2 and  grid[row1][col1] != 2:                  \\n                        dist_2[(row1, col1)] = distance_2 + 1      \\n\\n                        if ((row1, col1) in dist  and dist_2[(row1, col1)] < dist[(row1, col1)]) or (row1, col1) not in dist: #either no fire  or person reaches the cell earlier than any fire would reach that cell\\n                            q.append((distance_2 + 1, row1, col1))\\n                            continue\\n                            \\n                        #Handle Edge case: Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehous\\n                        if (row1, col1) == (m-1, n-1) and  dist_2[(row1, col1)] <= dist[(row1, col1)]:\\n                            q.append((distance_2 + 1, row1, col1))\\n                            \\n            return False    \\n        \\n        def binary_search(start, end):\\n            m, n = len(grid),  len(grid[0])\\n            while start < end:\\n                mid = start + (end - start)//2\\n               \\n                if check_fire(mid):\\n                    start = mid + 1\\n                else:\\n                    end = mid    \\n            \\n            if start == m * n:\\n                return 10 ** 9\\n            \\n            return start - 1 if check_fire(start - 1) else -1\\n\\n        \\n        m, n = len(grid),  len(grid[0])\\n        bfs() #multi source BFS\\n        return binary_search(0, m * n)",
                "solutionTags": [],
                "code": "class Solution:\\n    #spread the fire simultaneously to all cells using multi-source BFS and then calculate the number of minutes to reach every cell.\\n    #binary search to see by varying the minutes and determine the max wait time\\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\\n        dist, fire_cells = {}",
                "codeTag": "Java"
            },
            {
                "id": 1995598,
                "title": "c-bfs-binary-search-solution-with-explanation-o-n-m-time-o-n-m-space",
                "content": "```\\nclass Solution {\\n    //INTUITION: We can first calculate the min. time taken for fire to reach each cell of the grid.\\n    //We can then minimise the value of wait time as per criteria to successfully reach the safehouse.\\n    \\n    //ALGO: To fill the minimum fire reaching time for each cell, we use BFS.\\n    //For checking if user can reach the safehouse after a certain wait time also, we use BFS.\\n    //BFS is used because by default without hassle it always considers the shortest path/time.\\n    private:\\n    vector<int> fx = {-1,1,0,0};\\n    vector<int> fy = {0,0,-1,1};\\n    bool invalid(int n,int m, int i, int j, vector<vector<int>>& grid)\\n    {\\n        return (i<0 || j<0 || i>=n || j>=m || grid[i][j]==2);\\n    }\\n    \\n    void fireSpread(vector<vector<int>>& grid, vector<vector<int>>&fireReachTime) //calculating time fire takes to reach for each cell in the grid\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        fireReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX)); \\n        //Marking already fired up points as source of BFS\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n                if(grid[i][j]==1)\\n                    q.push({i,j}), fireReachTime[i][j] = 0;\\n        //BFS:-\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0; i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                if(fireReachTime[xx][yy] > fireReachTime[x][y]+1)\\n                    fireReachTime[xx][yy] = fireReachTime[x][y]+1, q.push({xx,yy});\\n            }\\n        }\\n    }\\n    \\n    int safehouseTime(int wait, vector<vector<int>>& grid, vector<vector<int>>& myReachTime, vector<vector<int>>&fireReachTime)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        myReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0}); //our starting pt.\\n        myReachTime[0][0] = wait;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0;i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                int newMyReachTime = min(myReachTime[xx][yy],myReachTime[x][y]+1); //updated min. time to reach index [xx][yy]\\n                if(xx==n-1 && yy==m-1 && newMyReachTime<=fireReachTime[xx][yy]) return newMyReachTime;//reached safehouse\\n                if(newMyReachTime >= fireReachTime[xx][yy]) continue; //No use of updating, already minimum time stored\\n                if(myReachTime[xx][yy] > myReachTime[x][y]+1)\\n                    myReachTime[xx][yy] = myReachTime[x][y]+1 , q.push({xx,yy});\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n            vector<vector<int>> fireReachTime(300,vector<int>(300));\\n    vector<vector<int>> myReachTime(300,vector<int>(300));\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        fireSpread(grid, fireReachTime); //filling the fireReachTime for each cell grid position\\n        \\n        if (fireReachTime[n - 1][m - 1] == INT_MAX) { //EDGE CASE 1: If fire can\\'t ever reach the safehouse\\n            return safehouseTime(0, grid,myReachTime, fireReachTime) < INT_MAX ? 1e9 : -1; //We only need to check if the user can get to safehouse (no need of bothering abt wait time)\\n        }\\n        \\n        //Binary search to find the minimum waiting time:-\\n        int lo = 0, hi = (n*m)+1, maxWaitTime = -1;\\n        while(lo <= hi) {\\n            int mid = ((lo + hi) >> 1);\\n            if (safehouseTime(mid, grid, myReachTime,fireReachTime) <= fireReachTime[n - 1][m - 1])//we can reach safehouse before fire reaches with a wait time of \\'mid\\'\\n                lo = mid + 1, maxWaitTime = mid; //trying to increase the wait time\\n            else \\n                hi = mid - 1; //trying to decrease the wait time\\n        }\\n        \\n        return maxWaitTime == ((n*m)+1) ? 1e9 : maxWaitTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //INTUITION: We can first calculate the min. time taken for fire to reach each cell of the grid.\\n    //We can then minimise the value of wait time as per criteria to successfully reach the safehouse.\\n    \\n    //ALGO: To fill the minimum fire reaching time for each cell, we use BFS.\\n    //For checking if user can reach the safehouse after a certain wait time also, we use BFS.\\n    //BFS is used because by default without hassle it always considers the shortest path/time.\\n    private:\\n    vector<int> fx = {-1,1,0,0};\\n    vector<int> fy = {0,0,-1,1};\\n    bool invalid(int n,int m, int i, int j, vector<vector<int>>& grid)\\n    {\\n        return (i<0 || j<0 || i>=n || j>=m || grid[i][j]==2);\\n    }\\n    \\n    void fireSpread(vector<vector<int>>& grid, vector<vector<int>>&fireReachTime) //calculating time fire takes to reach for each cell in the grid\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        queue<pair<int,int>> q;\\n        fireReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX)); \\n        //Marking already fired up points as source of BFS\\n        for(int i = 0; i<n; i++)\\n            for(int j = 0; j<m; j++)\\n                if(grid[i][j]==1)\\n                    q.push({i,j}), fireReachTime[i][j] = 0;\\n        //BFS:-\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0; i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                if(fireReachTime[xx][yy] > fireReachTime[x][y]+1)\\n                    fireReachTime[xx][yy] = fireReachTime[x][y]+1, q.push({xx,yy});\\n            }\\n        }\\n    }\\n    \\n    int safehouseTime(int wait, vector<vector<int>>& grid, vector<vector<int>>& myReachTime, vector<vector<int>>&fireReachTime)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        myReachTime = vector<vector<int>>(300,vector<int>(300,INT_MAX));\\n        queue<pair<int,int>> q;\\n        q.push({0,0}); //our starting pt.\\n        myReachTime[0][0] = wait;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first, y = q.front().second; q.pop();\\n            for(int i = 0;i<4;i++)\\n            {\\n                int xx = x+fx[i], yy = y+fy[i]; \\n                if(invalid(n,m,xx,yy,grid)) continue;\\n                int newMyReachTime = min(myReachTime[xx][yy],myReachTime[x][y]+1); //updated min. time to reach index [xx][yy]\\n                if(xx==n-1 && yy==m-1 && newMyReachTime<=fireReachTime[xx][yy]) return newMyReachTime;//reached safehouse\\n                if(newMyReachTime >= fireReachTime[xx][yy]) continue; //No use of updating, already minimum time stored\\n                if(myReachTime[xx][yy] > myReachTime[x][y]+1)\\n                    myReachTime[xx][yy] = myReachTime[x][y]+1 , q.push({xx,yy});\\n            }\\n        }\\n        \\n        return INT_MAX;\\n    }\\npublic:\\n    int maximumMinutes(vector<vector<int>>& grid) {\\n            vector<vector<int>> fireReachTime(300,vector<int>(300));\\n    vector<vector<int>> myReachTime(300,vector<int>(300));\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        fireSpread(grid, fireReachTime); //filling the fireReachTime for each cell grid position\\n        \\n        if (fireReachTime[n - 1][m - 1] == INT_MAX) { //EDGE CASE 1: If fire can\\'t ever reach the safehouse\\n            return safehouseTime(0, grid,myReachTime, fireReachTime) < INT_MAX ? 1e9 : -1; //We only need to check if the user can get to safehouse (no need of bothering abt wait time)\\n        }\\n        \\n        //Binary search to find the minimum waiting time:-\\n        int lo = 0, hi = (n*m)+1, maxWaitTime = -1;\\n        while(lo <= hi) {\\n            int mid = ((lo + hi) >> 1);\\n            if (safehouseTime(mid, grid, myReachTime,fireReachTime) <= fireReachTime[n - 1][m - 1])//we can reach safehouse before fire reaches with a wait time of \\'mid\\'\\n                lo = mid + 1, maxWaitTime = mid; //trying to increase the wait time\\n            else \\n                hi = mid - 1; //trying to decrease the wait time\\n        }\\n        \\n        return maxWaitTime == ((n*m)+1) ? 1e9 : maxWaitTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995543,
                "title": "c-simplified-2-bfs-binary-search-on-answer-space",
                "content": "\\n\\nint maximumMinutes(vector<vector<int>>& grid) \\n{\\n\\n        int m = grid.size(), n = grid[0].size(),dirs[] = {0,-1,0,1,0};\\n        vector<vector<int>> fires(m,vector<int>(n,1e6));\\n        queue<array<int,2>> q;\\n        // collect the fires for bfs\\n       for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j] ==1){\\n                    q.push({i,j});\\n                    fires[i][j]=0;\\n                }\\n                else if (grid[i][j] ==2)\\n                    fires[i][j]=0;\\n            }\\n\\t\\t\\t\\n        while (!q.empty()){ // spread the fires\\n            int sz = q.size();\\n            while (sz-- >  0){\\n                auto [r,c] = q.front(); q.pop();\\n                for (int i =0; i<4; i++){\\n                    int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                    if (r1<0|| c1<0 || r1>=m || c1>=n || fires[r1][c1] <= fires[r][c]+1) continue;\\n                    fires[r1][c1] = fires[r][c]+1;\\n                    q.push({r1,c1});\\n                }\\n            }\\n        }\\n       // check possible to reach end before fires reaches\\n        auto bfs  = [&]( int t){  \\n            queue<array<int,2>> q;\\n            q.push({0,0});\\n            vector<bool> vis(m*n);\\n            vis[0]=1;\\n            while (!q.empty()){\\n                int sz = q.size();\\n                ++t;\\n                while (sz-- >  0){\\n                    auto [r,c] = q.front(); q.pop();\\n                    for (int i = 0; i<4; i++){\\n                        int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                        if (r1<0|| c1<0 || r1>=m || c1>=n || vis[r1*n+c1] ) continue;\\n                        vis[r1*n+c1]=1;\\n                        if (r1==m-1 && c1==n-1)\\n                            return fires[r1][c1] >= t;\\n                        \\n                        if (fires[r1][c1] <= t) continue;\\n                        q.push({r1,c1});\\n                    }\\n                }\\n            }            \\n            return false;\\n        };    \\n        int l=-1, r= m*n;\\n        while (l<r){ // binary search on answer space\\n            int m = ( r + 1 + l ) /2;\\n            if (bfs(m))\\n                l=m;\\n            else\\n                r=m-1;\\n        }\\n\\n        return l!=-1 ? (l==m*n ? 1e9:l) : l;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "\\n\\nint maximumMinutes(vector<vector<int>>& grid) \\n{\\n\\n        int m = grid.size(), n = grid[0].size(),dirs[] = {0,-1,0,1,0};\\n        vector<vector<int>> fires(m,vector<int>(n,1e6));\\n        queue<array<int,2>> q;\\n        // collect the fires for bfs\\n       for (int i=0; i<m; i++)\\n            for (int j=0; j<n; j++){\\n                if (grid[i][j] ==1){\\n                    q.push({i,j});\\n                    fires[i][j]=0;\\n                }\\n                else if (grid[i][j] ==2)\\n                    fires[i][j]=0;\\n            }\\n\\t\\t\\t\\n        while (!q.empty()){ // spread the fires\\n            int sz = q.size();\\n            while (sz-- >  0){\\n                auto [r,c] = q.front(); q.pop();\\n                for (int i =0; i<4; i++){\\n                    int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                    if (r1<0|| c1<0 || r1>=m || c1>=n || fires[r1][c1] <= fires[r][c]+1) continue;\\n                    fires[r1][c1] = fires[r][c]+1;\\n                    q.push({r1,c1});\\n                }\\n            }\\n        }\\n       // check possible to reach end before fires reaches\\n        auto bfs  = [&]( int t){  \\n            queue<array<int,2>> q;\\n            q.push({0,0});\\n            vector<bool> vis(m*n);\\n            vis[0]=1;\\n            while (!q.empty()){\\n                int sz = q.size();\\n                ++t;\\n                while (sz-- >  0){\\n                    auto [r,c] = q.front(); q.pop();\\n                    for (int i = 0; i<4; i++){\\n                        int r1 = r + dirs[i], c1= c + dirs[i+1];\\n                        if (r1<0|| c1<0 || r1>=m || c1>=n || vis[r1*n+c1] ) continue;\\n                        vis[r1*n+c1]=1;\\n                        if (r1==m-1 && c1==n-1)\\n                            return fires[r1][c1] >= t;\\n                        \\n                        if (fires[r1][c1] <= t) continue;\\n                        q.push({r1,c1});\\n                    }\\n                }\\n            }            \\n            return false;\\n        };    \\n        int l=-1, r= m*n;\\n        while (l<r){ // binary search on answer space\\n            int m = ( r + 1 + l ) /2;\\n            if (bfs(m))\\n                l=m;\\n            else\\n                r=m-1;\\n        }\\n\\n        return l!=-1 ? (l==m*n ? 1e9:l) : l;\\n    }\\n\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1945240,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1935660,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1772995,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1840338,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2039698,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2037355,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2008491,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1955151,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1850761,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1717200,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1945240,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1935660,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1772995,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1840338,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2039698,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2037355,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 2008491,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1955151,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1850761,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            },
            {
                "id": 1717200,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "hats off to people who set such amazing problems. really impressed."
                    },
                    {
                        "username": "code_with_rj",
                        "content": "https://leetcode.com/problems/escape-the-spreading-fire/submissions/974582943/ \\nwhat\\'s wrong with this \\uD83E\\uDD78? getting failed for 54th test case. "
                    },
                    {
                        "username": "yuktaX",
                        "content": "its failing for me too, im getting 9112 as the output but its showing 9174 as the expected one. lmk if you figured it out. looks like an extreme edge case"
                    },
                    {
                        "username": "qriuscoder",
                        "content": "\"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.\"\nSeriously?? Can't help but bitch about this!\nNot sure what an interviewer achieves by complicating with edge cases like that.\nThe problem is quite straight forward otherwise.\n\n"
                    },
                    {
                        "username": "uavishal777",
                        "content": "Is this will a brute force approach to solve it??\\nSuppose i try to solve it by using the technique that lets move forward the fire every minute and then check that will the person able to reach the safe house or not ..Then the highest minute the person will be able to reach the safe house will be the answer...and for edge cases first one that if in any minute we will see that the fire can\\'t move further and the person reaching the safe house then answer will be 10^9 ..and for second case we will see if the man cannot reach the safe house in any second then return -1;"
                    },
                    {
                        "username": "JoeMark51",
                        "content": "are people able to actually pass these coding questions in interview? too many edge cases, etc with no debugger"
                    },
                    {
                        "username": "trishulcurtis",
                        "content": "The hardest problem I have seen on leetcode for me"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "Use binary search to get to the most optimal time\\nFirst do Bfs for fire for choosen time from binary search\\nThen do bfs for person and fire simultaneously "
                    },
                    {
                        "username": "wintersoldier2004",
                        "content": " someone explain why the answer for [[0,2,0,0,1],[0,2,0,2,2],[0,2,0,0,0],[0,0,2,2,0],[0,0,0,0,0]]  is 0.\\n[test case 33]"
                    },
                    {
                        "username": "shankar999",
                        "content": "it is mentioned in the problem  \"Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse\" this is the edge case you are missing , btw same happened with me "
                    },
                    {
                        "username": "qianli",
                        "content": "I had trouble understanding this as well. It turns out that you cannot enter the \"safehouse\" once fire is supposed to spread to it, on t=8..."
                    },
                    {
                        "username": "yangwudi398",
                        "content": "Time Limit Exceeded."
                    },
                    {
                        "username": "ironmonger1",
                        "content": "I dont undestand in example one even if I dont move why is the fire spreading after the first 3 mins,as stated by the question \"After your move, every fire cell will spread to all adjacent cells that are not walls.\"?"
                    },
                    {
                        "username": "paveltruh",
                        "content": "You don\\'t have to move every minute, but fire spreads every minute. Task asks you how long you can stay in initial position so you will have enough time to reach the exit. \\nExample shows you the answer for given grid - you can wait for 3 minutes, fire is spreading for during this time, and after 3 minutes you start moving torwards the exit and reach it safely"
                    }
                ]
            }
        ]
    },
    {
        "title": "Apply Discount to Prices",
        "question_content": "<p>A <strong>sentence</strong> is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign <code>&#39;$&#39;</code>. A word represents a <strong>price</strong> if it is a sequence of digits preceded by a dollar sign.</p>\n\n<ul>\n\t<li>For example, <code>&quot;$100&quot;</code>, <code>&quot;$23&quot;</code>, and <code>&quot;$6&quot;</code> represent prices while <code>&quot;100&quot;</code>, <code>&quot;$&quot;</code>, and <code>&quot;$1e5&quot;</code> do not.</li>\n</ul>\n\n<p>You are given a string <code>sentence</code> representing a sentence and an integer <code>discount</code>. For each word representing a price, apply a discount of <code>discount%</code> on the price and <strong>update</strong> the word in the sentence. All updated prices should be represented with <strong>exactly two</strong> decimal places.</p>\n\n<p>Return <em>a string representing the modified sentence</em>.</p>\n\n<p>Note that all prices will contain <strong>at most</strong> <code>10</code> digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;there are $1 $2 and 5$ candies in the shop&quot;, discount = 50\n<strong>Output:</strong> &quot;there are $0.50 $1.00 and 5$ candies in the shop&quot;\n<strong>Explanation:</strong> \nThe words which represent prices are &quot;$1&quot; and &quot;$2&quot;. \n- A 50% discount on &quot;$1&quot; yields &quot;$0.50&quot;, so &quot;$1&quot; is replaced by &quot;$0.50&quot;.\n- A 50% discount on &quot;$2&quot; yields &quot;$1&quot;. Since we need to have exactly 2 decimal places after a price, we replace &quot;$2&quot; with &quot;$1.00&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sentence = &quot;1 2 $3 4 $5 $6 7 8$ $9 $10$&quot;, discount = 100\n<strong>Output:</strong> &quot;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$&quot;\n<strong>Explanation:</strong> \nApplying a 100% discount on any price will result in 0.\nThe words representing prices are &quot;$3&quot;, &quot;$5&quot;, &quot;$6&quot;, and &quot;$9&quot;.\nEach of them is replaced by &quot;$0.00&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sentence.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>sentence</code> consists of lowercase English letters, digits, <code>&#39; &#39;</code>, and <code>&#39;$&#39;</code>.</li>\n\t<li><code>sentence</code> does not have leading or trailing spaces.</li>\n\t<li>All words in <code>sentence</code> are separated by a single space.</li>\n\t<li>All prices will be <strong>positive</strong> numbers without leading zeros.</li>\n\t<li>All prices will have <strong>at most</strong> <code>10</code> digits.</li>\n\t<li><code>0 &lt;= discount &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2085650,
                "title": "stupidest-question-i-have-seen-in-my-life",
                "content": "If you dont know python probably this question is impossible to do. I tried everything i could possibly think of in c++ but at end of the day i had to use python to do the question.\\n\\nI think due to precision error i was getting 9999999999 * 0.95 = 9499999999.049999. I know there would be a way to tackle this problem but it is just not fair. People who are using python have an massive advantage\\n\\nHere\\'s my c++ and python code and u can see the difference.\\nHopefully leetcode doesnt consider this contest.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream s(sentence);\\n        string word, ans = \"\";\\n        \\n        while(s >> word) {\\n            if(word[0] == \\'$\\' && word.size() > 1) {\\n                \\n                bool isNum = true;\\n                string s = \"\";\\n                \\n                for(int i = 1; i < word.size(); ++i) {\\n                    s += word[i];\\n                    if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                        isNum = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isNum) {\\n                    \\n                    long double d = stoll(s) * (100-discount)/100.0;\\n                    string a = to_string(d), b = \"\";\\n                    \\n                    int f = 0, isDot = false;\\n                    \\n                    for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                        if(a[i] == \\'.\\') isDot = true;\\n                        if(isDot) ++f;\\n                        b += a[i];\\n                    }\\n                    \\n                    ans += \\'$\\' + b + \\' \\';\\n                }\\n                else ans += word + \\' \\';\\n                \\n            }\\n            else ans += word + \\' \\';\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split();\\n        res = [];\\n        for word in words:\\n            if word[0] != \\'$\\' or word[1:].isnumeric() == False:\\n                res.append(word);\\n            else:\\n                price = int(word[1:]);\\n                #print(price);\\n                res.append(\"${:.2f}\".format(price-price*discount/100));\\n\\n        return \" \".join(res);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream s(sentence);\\n        string word, ans = \"\";\\n        \\n        while(s >> word) {\\n            if(word[0] == \\'$\\' && word.size() > 1) {\\n                \\n                bool isNum = true;\\n                string s = \"\";\\n                \\n                for(int i = 1; i < word.size(); ++i) {\\n                    s += word[i];\\n                    if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                        isNum = false;\\n                        break;\\n                    }\\n                }\\n                \\n                if(isNum) {\\n                    \\n                    long double d = stoll(s) * (100-discount)/100.0;\\n                    string a = to_string(d), b = \"\";\\n                    \\n                    int f = 0, isDot = false;\\n                    \\n                    for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                        if(a[i] == \\'.\\') isDot = true;\\n                        if(isDot) ++f;\\n                        b += a[i];\\n                    }\\n                    \\n                    ans += \\'$\\' + b + \\' \\';\\n                }\\n                else ans += word + \\' \\';\\n                \\n            }\\n            else ans += word + \\' \\';\\n        }\\n        \\n        return ans.substr(0,ans.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split();\\n        res = [];\\n        for word in words:\\n            if word[0] != \\'$\\' or word[1:].isnumeric() == False:\\n                res.append(word);\\n            else:\\n                price = int(word[1:]);\\n                #print(price);\\n                res.append(\"${:.2f}\".format(price-price*discount/100));\\n\\n        return \" \".join(res);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085854,
                "title": "set-precision-with-stringstream",
                "content": "**I didnt knew how to set precision so I googled it and found this :**\\nhttps://stackoverflow.com/questions/72402668/hot-to-set-precision-of-double-in-an-array\\n\\n**Extract each word from the sentence and check if it represents a price. For each price, apply the given discount to it and update it.**\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n\\t\\t// doit is a function\\n        auto doit = [&](string word) {\\n\\t\\t\\n            int n(size(word));\\n            if (word[0] != \\'$\\' or n == 1)   return word;\\n            \\n            long long price = 0;\\n            for (int i=1; i<n; i++) {\\n                if (!isdigit(word[i]))  return word;\\n                price = price*10 + (word[i]-\\'0\\');\\n            }\\n            \\n\\t\\t\\tstringstream ss2;\\n            double discountPercentage = (100 - discount) / 100.0;\\n            ss2 << fixed << setprecision(2) << (discountPercentage * price);\\n            return \"$\" + ss2.str();\\n        };\\n        \\n        string word, res;\\n        stringstream ss(sentence);\\n        \\n        while (ss >> word) {\\n            res += doit(word)+\" \";\\n        }\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        \\n\\t\\t// doit is a function\\n        auto doit = [&](string word) {\\n\\t\\t\\n            int n(size(word));\\n            if (word[0] != \\'$\\' or n == 1)   return word;\\n            \\n            long long price = 0;\\n            for (int i=1; i<n; i++) {\\n                if (!isdigit(word[i]))  return word;\\n                price = price*10 + (word[i]-\\'0\\');\\n            }\\n            \\n\\t\\t\\tstringstream ss2;\\n            double discountPercentage = (100 - discount) / 100.0;\\n            ss2 << fixed << setprecision(2) << (discountPercentage * price);\\n            return \"$\" + ss2.str();\\n        };\\n        \\n        string word, res;\\n        stringstream ss(sentence);\\n        \\n        while (ss >> word) {\\n            res += doit(word)+\" \";\\n        }\\n        \\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085732,
                "title": "java-python-3-convert-the-prices-to-the-discounted-and-format-ouput",
                "content": "**Note:** In case you are not comfortable with `num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')`, you can replace it with `num.matches(\"\\\\\\\\d+\")`, or a method `isValidNum()` as follows:\\n```java\\n    private boolean isValidNum(String num) {\\n        for (int i = 0; i < num.length(); ++i) {\\n            char c = num.charAt(i);\\n            if (c < \\'0\\' || c > \\'9\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n````\\n\\n----\\n\\n\\n```java\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; ++i) {\\n            String word  = words[i], num = word.substring(1);\\n            if (word.length() > 1 && word.charAt(0) == \\'$\\' && num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')) {\\n                words[i] = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100d));\\n            }\\n        }\\n        return String.join(\" \", words);\\n    }\\n```\\n```python\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1 :].isnumeric():\\n                words[i] = f\\'${float(word[1 :]) * (1 - discount / 100):.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [],
                "code": "```java\\n    private boolean isValidNum(String num) {\\n        for (int i = 0; i < num.length(); ++i) {\\n            char c = num.charAt(i);\\n            if (c < \\'0\\' || c > \\'9\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```java\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        for (int i = 0; i < words.length; ++i) {\\n            String word  = words[i], num = word.substring(1);\\n            if (word.length() > 1 && word.charAt(0) == \\'$\\' && num.chars().allMatch(d -> \\'0\\' <= d && d <= \\'9\\')) {\\n                words[i] = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100d));\\n            }\\n        }\\n        return String.join(\" \", words);\\n    }\\n```\n```python\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1 :].isnumeric():\\n                words[i] = f\\'${float(word[1 :]) * (1 - discount / 100):.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086128,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String x[] = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : x) {\\n            if (isPrice(s)) sb.append(calc(Double.parseDouble(s.substring(1)), discount) + \" \"); \\n            else sb.append(s + \" \");\\n        }\\n        sb.deleteCharAt(sb.length() - 1);\\n        return sb.toString();\\n    }\\n\\n    boolean isPrice(String s) {\\n        return s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\");\\n    }\\n\\n    String calc(double num, double discount) {\\n        double ans = num - (double) ((double) num * discount / 100.00);\\n        return \"$\" + String.format(\"%.2f\", ans);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String x[] = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String s : x) {\\n            if (isPrice(s)) sb.append(calc(Double.parseDouble(s.substring(1)), discount) + \" \"); \\n            else sb.append(s + \" \");\\n        }\\n        sb.deleteCharAt(sb.length() - 1);\\n        return sb.toString();\\n    }\\n\\n    boolean isPrice(String s) {\\n        return s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\");\\n    }\\n\\n    String calc(double num, double discount) {\\n        double ans = num - (double) ((double) num * discount / 100.00);\\n        return \"$\" + String.format(\"%.2f\", ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085723,
                "title": "simple-python-with-explanation",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() # convert to List to easily update\\n        m = discount / 100 \\n        for i,word in enumerate(s):\\n            if word[0] == \"$\" and word[1:].isdigit(): # Check whether it is in correct format\\n                num = int(word[1:]) * (1-m) # discounted price\\n                w = \"$\" + \"{:.2f}\".format(num) #correctly format\\n                s[i] = w #Change inside the list\\n        \\n        return \" \".join(s) #Combine the updated list\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s = sentence.split() # convert to List to easily update\\n        m = discount / 100 \\n        for i,word in enumerate(s):\\n            if word[0] == \"$\" and word[1:].isdigit(): # Check whether it is in correct format\\n                num = int(word[1:]) * (1-m) # discounted price\\n                w = \"$\" + \"{:.2f}\".format(num) #correctly format\\n                s[i] = w #Change inside the list\\n        \\n        return \" \".join(s) #Combine the updated list\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2085674,
                "title": "c-easy-to-understand-simple-approach-clarity-of-question-missing",
                "content": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'$\\')\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'$\\';\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome***",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'$\\')\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'$\\';\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085768,
                "title": "c-istringstream-ostringstream-elegant-approach",
                "content": "upvote if you like it. ^_^\\n```cpp\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        istringstream iss(s);\\n        ostringstream oss;\\n        \\n        string str;\\n        while(iss >> str){\\n            if(str[0] != \\'$\\'){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            int sign = 0;\\n            for(int i = 1; i < str.size(); i++){\\n                char ch = str[i];\\n                if(ch < \\'0\\' || ch > \\'9\\'){\\n                    sign = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if(sign == 1 || str.size() == 1){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            long long price = stoll(str.substr(1));\\n            double mod = price * 0.01 * (100 - d);\\n            oss << \"$\" << fixed << setprecision(2) << mod << \" \";\\n        }\\n        \\n        string ans = oss.str();\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        istringstream iss(s);\\n        ostringstream oss;\\n        \\n        string str;\\n        while(iss >> str){\\n            if(str[0] != \\'$\\'){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            int sign = 0;\\n            for(int i = 1; i < str.size(); i++){\\n                char ch = str[i];\\n                if(ch < \\'0\\' || ch > \\'9\\'){\\n                    sign = 1;\\n                    break;\\n                }\\n            }\\n            \\n            if(sign == 1 || str.size() == 1){\\n                oss << str << \" \";\\n                continue;\\n            }\\n            \\n            long long price = stoll(str.substr(1));\\n            double mod = price * 0.01 * (100 - d);\\n            oss << \"$\" << fixed << setprecision(2) << mod << \" \";\\n        }\\n        \\n        string ans = oss.str();\\n        ans.pop_back();\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087782,
                "title": "c-simple-solution-without-using-double",
                "content": "I saw many people frustrated on this problem because of the precession error in c++. so, here\\'s my solution without using double data type. if you like it do upvote it. \\nThanks \\npeace \\uD83E\\uDD1E\\n\\n```\\nclass Solution {\\npublic:\\n    int d;\\n    void check(string&s){\\n    \\n        if(s.size() == 1 || s[0] != \\'$\\') return;\\n        long long int num = 0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                num *= 10;\\n                num += s[i] - \\'0\\';\\n            }\\n            else return;\\n        }\\n        \\n        num *= (100 - d);\\n        s = to_string(num);\\n\\t\\t\\n        if(s.size() == 1) s = \"00\" + s;\\n        else if(s.size() == 2) s = \"0\" + s;\\n        \\n\\t\\ts.push_back(\\'.\\');\\n        int n = s.size();\\n        \\n\\t\\tswap(s[n-1], s[n-2]);\\n        swap(s[n-3], s[n-2]);\\n        s = \"$\" + s;\\n\\t\\t\\n    }\\n    \\n    string discountPrices(string s, int discount) {\\n        d = discount;\\n        vector<string> arr = {\"\"};\\n        s.push_back(\\' \\');\\n        for(char c: s){\\n            if(c == \\' \\'){\\n                check(arr[arr.size()-1]);\\n                arr.push_back(\"\");\\n            }\\n            else{\\n                arr[arr.size()-1].push_back(c);\\n            }\\n        }\\n        string ans = \"\";\\n        arr.pop_back();\\n        for(string&s: arr){ \\n            ans += s;\\n            ans.push_back(\\' \\');\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int d;\\n    void check(string&s){\\n    \\n        if(s.size() == 1 || s[0] != \\'$\\') return;\\n        long long int num = 0;\\n        for(int i=1;i<s.size();i++){\\n            if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n                num *= 10;\\n                num += s[i] - \\'0\\';\\n            }\\n            else return;\\n        }\\n        \\n        num *= (100 - d);\\n        s = to_string(num);\\n\\t\\t\\n        if(s.size() == 1) s = \"00\" + s;\\n        else if(s.size() == 2) s = \"0\" + s;\\n        \\n\\t\\ts.push_back(\\'.\\');\\n        int n = s.size();\\n        \\n\\t\\tswap(s[n-1], s[n-2]);\\n        swap(s[n-3], s[n-2]);\\n        s = \"$\" + s;\\n\\t\\t\\n    }\\n    \\n    string discountPrices(string s, int discount) {\\n        d = discount;\\n        vector<string> arr = {\"\"};\\n        s.push_back(\\' \\');\\n        for(char c: s){\\n            if(c == \\' \\'){\\n                check(arr[arr.size()-1]);\\n                arr.push_back(\"\");\\n            }\\n            else{\\n                arr[arr.size()-1].push_back(c);\\n            }\\n        }\\n        string ans = \"\";\\n        arr.pop_back();\\n        for(string&s: arr){ \\n            ans += s;\\n            ans.push_back(\\' \\');\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113205,
                "title": "one-pass",
                "content": "This is an easy problem with frustrating edge cases.\\n\\nIt will be much simpler if we split the string first, but less efficient.\\n\\n**C++**\\n```cpp\\nstring discountPrices(string &s, int dis) {\\n    string res;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        res += s[i];\\n        if (s[i] == \\'$\\' && (i == 0 || s[i - 1] == \\' \\')) {\\n            for (j = i + 1; j < s.size() && isdigit(s[j]); ++j) ;\\n            if (j - i > 1 && (j == s.size() || s[j] == \\' \\')) {\\n                long long p = (100 - dis) * stoll(s.substr(i + 1, j - i - 1));\\n                res += to_string(p / 100) + \".\" + (p % 100 < 10 ? \"0\" : \"\") + to_string(p % 100);\\n                i = j - 1;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring discountPrices(string &s, int dis) {\\n    string res;\\n    for (int i = 0, j = 0; i < s.size(); ++i) {\\n        res += s[i];\\n        if (s[i] == \\'$\\' && (i == 0 || s[i - 1] == \\' \\')) {\\n            for (j = i + 1; j < s.size() && isdigit(s[j]); ++j) ;\\n            if (j - i > 1 && (j == s.size() || s[j] == \\' \\')) {\\n                long long p = (100 - dis) * stoll(s.substr(i + 1, j - i - 1));\\n                res += to_string(p / 100) + \".\" + (p % 100 < 10 ? \"0\" : \"\") + to_string(p % 100);\\n                i = j - 1;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086797,
                "title": "set-precision-in-seconds-by-substring-method",
                "content": "\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream ss(sentence);\\n            string word;\\n            string ans=\"\";\\n            while(ss>>word){\\n                bool fl=false;\\n\\t\\t\\t\\t//check word is valid or not\\n                for(int i=1;i<word.size();i++){\\n                    if((word[i]-\\'0\\')>=0 && (word[i]-\\'0\\')<=9){\\n                        continue;\\n                    }\\n                    fl=true;\\n                    break;\\n                }\\n                \\n                if(word[0]!=\\'$\\' || fl || word.size()==1){\\n                    ans+=word+\" \";\\n                    continue;\\n                }\\n                // if word is valid\\n               string s1=word.substr(1);\\n               long double no=stold(s1);\\n               long  double x1=no;\\n               no=(long double)(((discount*no))/(100));\\n               no=(long double)(x1-no);  // converting to new value after discount\\n               string s2=to_string(no);   // convert to string \\n\\t\\t\\t\\t//find index of decimal \\n                int k=-1;\\n                for(int i=0;i<s2.size();i++){\\n                    if(s2[i]==\\'.\\'){\\n                        k=i;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\t//take 2 more chars after decimal\\n                s2=s2.substr(0,k+3);\\n               ans+=\"$\"+s2+\" \";\\n               \\n            }\\n\\t\\t//remove extra space from final ans\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\t\\n\\t//please upvoat if you found useful\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    string discountPrices(string sentence, int discount) {\\n        \\n        stringstream ss(sentence);\\n            string word;\\n            string ans=\"\";\\n            while(ss>>word){\\n                bool fl=false;\\n\\t\\t\\t\\t//check word is valid or not\\n                for(int i=1;i<word.size();i++){\\n                    if((word[i]-\\'0\\')>=0 && (word[i]-\\'0\\')<=9){\\n                        continue;\\n                    }\\n                    fl=true;\\n                    break;\\n                }\\n                \\n                if(word[0]!=\\'$\\' || fl || word.size()==1){\\n                    ans+=word+\" \";\\n                    continue;\\n                }\\n                // if word is valid\\n               string s1=word.substr(1);\\n               long double no=stold(s1);\\n               long  double x1=no;\\n               no=(long double)(((discount*no))/(100));\\n               no=(long double)(x1-no);  // converting to new value after discount\\n               string s2=to_string(no);   // convert to string \\n\\t\\t\\t\\t//find index of decimal \\n                int k=-1;\\n                for(int i=0;i<s2.size();i++){\\n                    if(s2[i]==\\'.\\'){\\n                        k=i;\\n                        break;\\n                    }\\n                }\\n\\t\\t\\t\\t//take 2 more chars after decimal\\n                s2=s2.substr(0,k+3);\\n               ans+=\"$\"+s2+\" \";\\n               \\n            }\\n\\t\\t//remove extra space from final ans\\n        ans.pop_back();\\n        return ans;\\n    }\\n\\t\\n\\t//please upvoat if you found useful\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2086540,
                "title": "c-easy-to-understand-with-explanation-and-comments",
                "content": "The basic idea is to store the number which appear after the $ sign and have a space after the number ends or we reach the last index.\\nThough the code is bit long but it is easy to understand.\\nGo through code and comments thoroughly.\\n\\n![image](https://assets.leetcode.com/users/images/265e3ab5-319d-476f-bb54-0d6b3af14656_1653805971.4090803.png)\\n\\nSo we will start with 2 vectors. In the first vector we will store a valid number if found. In the second vector we will store the first and last index of the number. **As shown in the photo above we will store 7 and 9 in the index array and will store the number 123 in the v vector**\\n\\nNow after we have end up storing all the valid numbers we will apply the discount using the normal formula\\nA=A*(100-d)/100. Where A is the price before and d is the discount. \\n\\nAfter this we will again traverse the given string and in this we will see if our i pointer has reached the number or not by checking it against the number stored in the idx vector. \\n1. If so we will retrieve the number from V vector and make it a string(to be able to store values up to 2 decimal places). We will then traverse the newly made string of number and will check for \\'.\\' and wherever we found . we will break it and then we will make a substring upto to 2 pointer ahead of \\'.\\' we found.  and we will make take our i pointer to the end of number i=idx[j+1] and we will increment the j to the next start pointer(j+=2 because we wnt to jump to next start pointer).\\n2.  If our i does not match with the index stored in idx vector we will add the character directly to the answer string.\\nAt the end we will return the string.\\n\\nCODE with comments:\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) \\n    {\\n        int n=s.size();\\n        //vector to store number\\n        vector<long double>v;\\n        //vector to store indcies\\n        vector<int> idx;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            //bool to check if we actually found a number after $ sign\\n            f=false;\\n            //if we encounter dollar sign we will check if the previous \\n            //character was either an empty space of start of the string\\n            if(s[i]==\\'$\\' and (i==0 or (s[i-1]==\\' \\')))\\n            {\\n                //moving to next index of $ sign\\n                i++;\\n                //storing the starting sign\\n                idx.push_back(i);\\n                //ans which we will calculate\\n                long long int ans=0;\\n                while(i<n and s[i]-\\'0\\'>=0 and s[i]-\\'0\\'<=9)\\n                {\\n                    ans*=10;\\n                    ans+=s[i]-\\'0\\';\\n                    i++;\\n                    f=true;\\n                }\\n                //we will check if after the number there is a white space or not\\n                //if theres a white space or we reacher the end or the string we \\n                //will push it to our answer else skip it and pop the staring index \\n                //as we didnt found a valid number\\n                if(i==n or (s[i]==\\' \\') and f)\\n                {\\n                    //pushing ending index and number\\n                    idx.push_back(i-1);\\n                    v.push_back(ans);\\n                    continue;\\n                }\\n                idx.pop_back();\\n            }\\n        }\\n        //this loop will calculate the updated prices after discount\\n        for(int i=0;i<v.size();i++)\\n        {\\n            v[i]=v[i]*(100-d)/100;\\n        }\\n        int j=0;\\n        //resultant string\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            //if j has not reached the end of idx array and i pointer\\n            //is equal to index stored in idx vector means we should add\\n            // the number now\\n            if(j<idx.size() and (i==idx[j]))\\n            {\\n                //t is the index of that number in v vector\\n                int t=j/2,a=0;\\n                //converting it to string\\n                string ss=to_string(v[t]);\\n                //finding \\'.\\'\\n                for(int i=0;i<ss.length();i++)\\n                {if(ss[i]==\\'.\\')\\n                    {a=i;break;}}\\n                //making a substring after to places of \\'.\\' for eg.\\n                //ss=0.500000 then temp would be 0.50 \\n                string temp=ss.substr(0,a+3);\\n                //adding this string to answer string\\n                res+=temp;\\n                //updating i to the last index of number in original array\\n                //9 in case of example shown above\\n                i=idx[j+1];\\n                //taking j to next starting index of a number is exist\\n                j+=2;\\n            }\\n            //if i!=the index of idx vector we will directly add that charcter\\n            //final string\\n            else\\n            {\\n                res+=s[i];\\n            }\\n        }\\n        //returning the string\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) \\n    {\\n        int n=s.size();\\n        //vector to store number\\n        vector<long double>v;\\n        //vector to store indcies\\n        vector<int> idx;\\n        bool f=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            //bool to check if we actually found a number after $ sign\\n            f=false;\\n            //if we encounter dollar sign we will check if the previous \\n            //character was either an empty space of start of the string\\n            if(s[i]==\\'$\\' and (i==0 or (s[i-1]==\\' \\')))\\n            {\\n                //moving to next index of $ sign\\n                i++;\\n                //storing the starting sign\\n                idx.push_back(i);\\n                //ans which we will calculate\\n                long long int ans=0;\\n                while(i<n and s[i]-\\'0\\'>=0 and s[i]-\\'0\\'<=9)\\n                {\\n                    ans*=10;\\n                    ans+=s[i]-\\'0\\';\\n                    i++;\\n                    f=true;\\n                }\\n                //we will check if after the number there is a white space or not\\n                //if theres a white space or we reacher the end or the string we \\n                //will push it to our answer else skip it and pop the staring index \\n                //as we didnt found a valid number\\n                if(i==n or (s[i]==\\' \\') and f)\\n                {\\n                    //pushing ending index and number\\n                    idx.push_back(i-1);\\n                    v.push_back(ans);\\n                    continue;\\n                }\\n                idx.pop_back();\\n            }\\n        }\\n        //this loop will calculate the updated prices after discount\\n        for(int i=0;i<v.size();i++)\\n        {\\n            v[i]=v[i]*(100-d)/100;\\n        }\\n        int j=0;\\n        //resultant string\\n        string res=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            //if j has not reached the end of idx array and i pointer\\n            //is equal to index stored in idx vector means we should add\\n            // the number now\\n            if(j<idx.size() and (i==idx[j]))\\n            {\\n                //t is the index of that number in v vector\\n                int t=j/2,a=0;\\n                //converting it to string\\n                string ss=to_string(v[t]);\\n                //finding \\'.\\'\\n                for(int i=0;i<ss.length();i++)\\n                {if(ss[i]==\\'.\\')\\n                    {a=i;break;}}\\n                //making a substring after to places of \\'.\\' for eg.\\n                //ss=0.500000 then temp would be 0.50 \\n                string temp=ss.substr(0,a+3);\\n                //adding this string to answer string\\n                res+=temp;\\n                //updating i to the last index of number in original array\\n                //9 in case of example shown above\\n                i=idx[j+1];\\n                //taking j to next starting index of a number is exist\\n                j+=2;\\n            }\\n            //if i!=the index of idx vector we will directly add that charcter\\n            //final string\\n            else\\n            {\\n                res+=s[i];\\n            }\\n        }\\n        //returning the string\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086031,
                "title": "c-easiest-solution-runtime-136ms",
                "content": "class Solution {\\npublic:\\n\\n    long double to_num(string s)  // converting string to decimal\\n    {\\n      long double ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            ans=ans*10+(s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    bool isValid(string s) // checking if string is valid price or not\\n    {\\n        bool check=true;\\n        for(int i=1;i<(int)s.size();i++)\\n        {\\n            if(s[i]==\\'$\\' && i!=0) {\\n                check=false;\\n                break;\\n            }\\n            else if(!(s[i]>=\\'0\\' && s[i]<=\\'9\\'))\\n            {\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check) return true;\\n        else return false;\\n    }\\n    string discountPrices(string s, int d) {\\n        string ans=\"\";\\n        int n=s.size();\\n        int j=0;\\n        for( int i=0;i<=n;i++)\\n        {\\n            if(s[i]==\\' \\'||i==n)\\n            {\\n            string ss=s.substr(j,(i-j));\\n                // cout<<ss[0]<<\" \";\\n            if(ss[0]==\\'$\\' && isValid(ss) && ss.size()>1)\\n            {\\n                if(j==0)\\n                ans+=\\'$\\';\\n                else ans+=\" $\";\\n                long double num=to_num(ss);\\n                num-= num*(1.0*d/100);\\n                string st=to_string(num);\\n                int idx=0;\\n                for(int k=0;k<st.size();k++)\\n                {\\n                    if(st[k]==\\'.\\')\\n                    {\\n                        idx=k;\\n                        break;\\n                    }\\n                }\\n             st.erase(idx+3);\\n             ans+=st;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                ans+=\\' \\';\\n                ans+=ss;\\n            }\\n                j=i+1;\\n            }\\n        }        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long double to_num(string s)  // converting string to decimal\\n    {\\n      long double ans=0;\\n        for(int i=1;i<s.size();i++)\\n        {\\n            ans=ans*10+(s[i]-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2086004,
                "title": "how-to-deal-with-edge-cases-java",
                "content": "### Logic:\\nAt first, it might look like there are a lot of conditions to look out for when identifying valid prices and also replacing them with their discounted prices. But in reality, it\\'s not too daunting when you break it down. Below are the main things to look out for.\\n\\nLooping through the string using a right pointer `r`:\\n* If we found a \\'$\\', this is a possible start to a price.\\n\\t* This price is only valid if the previous character is a whitespace or it\\'s the beginning of the string (i.e. there\\'s nothing that comes directly before it).\\n\\t1. Append the \\'$\\'. Keep track of the start of the number using a left pointer `l`.\\n\\t2. Start reading in the number.\\n\\t\\t* We\\'re only concerned with digits and decimals (\\'.\\'). End once we reach a non-digit, whitespace, or the end of the string.\\n\\t    * If we\\'ve ended at a non-whitespace non-digit character and we\\'re not at the end of the string, this price is invalid (e.g. $35a).\\n\\t    * If `r == l` then we have a lone \\'$\\'. This is not valid either.\\n\\t    * Append invalid strings to our StringBuilder as they are.\\n\\t3. If valid, parse the substring between `l` and `r` as a double (note if the number ends with a decimal (e.g. $35.) it\\'s still valid).\\n\\t4. Calculate the discount of the number and append it to our StringBuilder (using 2-decimal format).\\n* Append non-prices to our StringBuilder to maintain the sentence.\\n___\\n\\n### How to Identify Edge Cases?\\nYou may be wondering how to break down the problem statement and identify all the edge cases in that problem. This question is a really good example of how one can get easily pushed over by a couple nasty edge cases they never thought of. It\\'s important not to jump into the questions straight away. There\\'s no worse feeling than having to continuously go over and append edge cases to your code once it\\'s already written only to find out that nothing works anymore. Now, how can we avoid this?\\n\\n**Get out your pen and paper.**\\nYou won\\'t make much progress unless you take the time to draw out your examples and solving them. An important part of this is ensuring each example you make is unique in some sense. You may not know if an example is unique to begin with but try your best to find examples that differ by some way to previous ones. The important thing is that you at least make the effort to try and draw out as many examples as you can that are different to some degree. Be sure to write both the input and the expected output! Try noticing any patterns. I recommend spending at least 3-5 minutes doing this.\\n\\n**Think about the standard, and then deviate.**\\nUnfortunately, it\\'s not that easy to think about extremes. However, here are some things you could consider for extremes when dealing with Strings:\\n* Empty strings / null strings\\n* Length 1\\n* Length 2\\n* Same character\\n* Uppercase / lowercase (doesn\\'t apply here)\\n\\nIn a question like this, ask yourself questions like:\\n* \"What makes a price valid?\"\\n* \"What example inputs look valid but really aren\\'t.\\n\\t* Here you can think about example inputs that look similar to a valid input but are different is some way(s).\\n\\nI\\'ve left out some other ones but if you can think of any, list them in the comments! \\n\\t\\n**I\\'ve found them. Now how can I fix them?**\\nTwo main ways to do this: \\n* Prevention, or;\\n* Support\\n\\nIf it\\'s the former, you add if statements to skip or continue. If it\\'s the latter, you add if statements or other logic to integrate it. It\\'s important to identify which of these two types of edge case solution you\\'re dealing with.\\n\\n**During an Interview:**\\nAlso please keep in mind that, in an interview for example, you won\\'t get downgraded if you don\\'t find literally all edge cases. You\\'re only human. As long as you\\'ve demonstrated that you understand edge cases exist and have dealt with a decent amount of them, you\\'re already ahead of the game! If you\\'re stuck, don\\'t be afraid to ask lots of clarifying questions. You\\'ll get better at asking these questions the more you practice. \\n\\nIf you want more practice with questions heavy in edge cases such as this one, I recommend giving [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/) a go! \\n___\\n### Code:\\nIf you have any questions, suggestions or improvements (or any tips of your own), please leave a comment below!\\n```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\");\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder();        \\n        int n = sentence.length(), l = 0, r = 0;\\n\\t\\t\\n        while (r < n) {\\n            if (sentence.charAt(r) == \\'$\\' && (r == 0 || sentence.charAt(r-1) == \\' \\')) {\\n                sb.append(\"$\");\\n                r++;\\n                l = r;\\n                while (r < n && (Character.isDigit(sentence.charAt(r)) || sentence.charAt(r) == \\'.\\')) \\n                    r++;\\n                if ((r >= n || sentence.charAt(r) == \\' \\') && r > l) {\\n                    double newNum = Double.parseDouble(sentence.substring(l,r));\\n                    newNum -= (newNum * discount) / 100;\\n                    sb.append( df.format(newNum) );\\n                }\\n                else sb.append( sentence.substring(l,r) );\\n            }\\n            else sb.append( sentence.charAt(r++) );\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\");\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder();        \\n        int n = sentence.length(), l = 0, r = 0;\\n\\t\\t\\n        while (r < n) {\\n            if (sentence.charAt(r) == \\'$\\' && (r == 0 || sentence.charAt(r-1) == \\' \\')) {\\n                sb.append(\"$\");\\n                r++;\\n                l = r;\\n                while (r < n && (Character.isDigit(sentence.charAt(r)) || sentence.charAt(r) == \\'.\\')) \\n                    r++;\\n                if ((r >= n || sentence.charAt(r) == \\' \\') && r > l) {\\n                    double newNum = Double.parseDouble(sentence.substring(l,r));\\n                    newNum -= (newNum * discount) / 100;\\n                    sb.append( df.format(newNum) );\\n                }\\n                else sb.append( sentence.substring(l,r) );\\n            }\\n            else sb.append( sentence.charAt(r++) );\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093817,
                "title": "javascript-solution-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nconst discountPrices = function(sentence, discount) {\\n    const arr = sentence.split(\\' \\');\\n    let ans = \\'\\';\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i].length > 1 && arr[i][0] === \\'$\\' && !arr[i].substring(1, arr[i].length).includes(\\'$\\') &&  !/[a-zA-Z]/g.test(arr[i].substring(1, arr[i].length))) {\\n            const dis = arr[i].split(\\'$\\');\\n            dis[1] = (dis[1] - (dis[1] * discount) / 100).toFixed(2);\\n            ans += `$${dis[1]} `;\\n        } else {\\n            ans += `${arr[i]} `;\\n        }\\n    }\\n    return ans.trim();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nconst discountPrices = function(sentence, discount) {\\n    const arr = sentence.split(\\' \\');\\n    let ans = \\'\\';\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i].length > 1 && arr[i][0] === \\'$\\' && !arr[i].substring(1, arr[i].length).includes(\\'$\\') &&  !/[a-zA-Z]/g.test(arr[i].substring(1, arr[i].length))) {\\n            const dis = arr[i].split(\\'$\\');\\n            dis[1] = (dis[1] - (dis[1] * discount) / 100).toFixed(2);\\n            ans += `$${dis[1]} `;\\n        } else {\\n            ans += `${arr[i]} `;\\n        }\\n    }\\n    return ans.trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2853693,
                "title": "simple-regex-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nfunction discountPrices(sentence: string, discount: number): string {\\n    const reg = /(?<=(\\\\s|^))\\\\$(\\\\d+)(?=(\\\\s|$))/g\\n    return sentence.replace(reg, (match) => {\\n        const price = parseFloat(match.slice(1))\\n        const afterDiscount = price * (100-discount) /100\\n        return `${afterDiscount.toFixed(2)}`\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n\\nfunction discountPrices(sentence: string, discount: number): string {\\n    const reg = /(?<=(\\\\s|^))\\\\$(\\\\d+)(?=(\\\\s|$))/g\\n    return sentence.replace(reg, (match) => {\\n        const price = parseFloat(match.slice(1))\\n        const afterDiscount = price * (100-discount) /100\\n        return `${afterDiscount.toFixed(2)}`\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701362,
                "title": "c-easy-to-understand-commented-code-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> arr;\\n        string temp = \"\";\\n        // we split the string and put all into one array\\n        for(int i = 0; i < sentence.length(); i++) {\\n            if(sentence[i] == \\' \\') {\\n                arr.push_back(temp);\\n                temp = \"\";\\n            } else\\n                temp += sentence[i];\\n        }\\n        if(temp.size() > 0) arr.push_back(temp);\\n        \\n        // we loop over the array and check for $(num) and then apply discount to it\\n        for(int i = 0; i < arr.size(); i++) {\\n            string help = arr[i];\\n            bool found = false;\\n            string num = \"\";\\n            for(int j = 0; j < help.size(); j++) {\\n                if(j == 0 && help[j] == \\'$\\') found = true;\\n                else if(found == true) {\\n                    if(help[j] >= \\'0\\' && help[j] <= \\'9\\') num += help[j];\\n                    else {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            } \\n            if(found && num.size() > 0) {\\n                long long number = stoll(num);\\n                long double discountPrice = (number * discount) / 100.0;\\n                long double finalNum = number - discountPrice;\\n                arr[i] = \"$\";\\n                arr[i] += to_string(finalNum);\\n                int pres = 4;\\n                while(pres--)\\n                    arr[i].pop_back();\\n            }\\n        }\\n        \\n        // at last we put the sliced array back into the string\\n        string ans = \"\";\\n        for(auto it: arr) {\\n            ans += it + \" \";\\n        }\\n        \\n        // remove the last trailing space.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> arr;\\n        string temp = \"\";\\n        // we split the string and put all into one array\\n        for(int i = 0; i < sentence.length(); i++) {\\n            if(sentence[i] == \\' \\') {\\n                arr.push_back(temp);\\n                temp = \"\";\\n            } else\\n                temp += sentence[i];\\n        }\\n        if(temp.size() > 0) arr.push_back(temp);\\n        \\n        // we loop over the array and check for $(num) and then apply discount to it\\n        for(int i = 0; i < arr.size(); i++) {\\n            string help = arr[i];\\n            bool found = false;\\n            string num = \"\";\\n            for(int j = 0; j < help.size(); j++) {\\n                if(j == 0 && help[j] == \\'$\\') found = true;\\n                else if(found == true) {\\n                    if(help[j] >= \\'0\\' && help[j] <= \\'9\\') num += help[j];\\n                    else {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            } \\n            if(found && num.size() > 0) {\\n                long long number = stoll(num);\\n                long double discountPrice = (number * discount) / 100.0;\\n                long double finalNum = number - discountPrice;\\n                arr[i] = \"$\";\\n                arr[i] += to_string(finalNum);\\n                int pres = 4;\\n                while(pres--)\\n                    arr[i].pop_back();\\n            }\\n        }\\n        \\n        // at last we put the sliced array back into the string\\n        string ans = \"\";\\n        for(auto it: arr) {\\n            ans += it + \" \";\\n        }\\n        \\n        // remove the last trailing space.\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680762,
                "title": "c-very-frustrating-que",
                "content": "![image](https://assets.leetcode.com/users/images/409f5b79-d36b-48be-8100-82083537165e_1665309615.4236598.png)\\n\\n**T->O(n) & S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring discountPrices(string sen, int dis) {\\n\\t\\t\\t\\tint n=sen.size();\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tans+=sen[i];\\n\\t\\t\\t\\t\\tif(i+1<n && sen[i]==\\'$\\' && isdigit(sen[i+1]) && ((i>=1 && sen[i-1]==\\' \\') || i==0)){\\n\\t\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\t\\tint j;\\n\\t\\t\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\t\\t\\tfor(j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(isdigit(sen[j])) str+=sen[j];\\n\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(sen[j]!=\\' \\') flag=false;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(!flag) continue;\\n\\t\\t\\t\\t\\t\\tlong double num=stold(str);\\n\\t\\t\\t\\t\\t\\tnum-=num*dis*0.01;\\n\\t\\t\\t\\t\\t\\tnum=abs(num);\\n\\t\\t\\t\\t\\t\\tstring s=to_string(num);\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\ts.pop_back();\\n\\t\\t\\t\\t\\t\\tans+=s;\\n\\t\\t\\t\\t\\t\\ti=j-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstring discountPrices(string sen, int dis) {\\n\\t\\t\\t\\tint n=sen.size();\\n\\t\\t\\t\\tstring ans=\"\";\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tans+=sen[i];\\n\\t\\t\\t\\t\\tif(i+1<n && sen[i]==\\'$\\' && isdigit(sen[i+1]) && ((i>=1 && sen[i-1]==\\' \\') || i==0)){\\n\\t\\t\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\t\\t\\tint j;\\n\\t\\t\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\t\\t\\tfor(j=i+1;j<n;j++){\\n\\t\\t\\t\\t\\t\\t\\tif(isdigit(sen[j])) str+=sen[j];\\n\\t\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(sen[j]!=\\' \\') flag=false;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2087488,
                "title": "python-1-liner-fast-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n            return \\' \\'.join((f\"${(int(w[1:])*(1-(d/100))):.2f}\" if w.startswith(\\'$\\') and w[1:].isnumeric() else w for w in s.split()))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n            return \\' \\'.join((f\"${(int(w[1:])*(1-(d/100))):.2f}",
                "codeTag": "Java"
            },
            {
                "id": 2085889,
                "title": "c-solution",
                "content": "\\n    bool isvalue(string s)\\n    {\\n        int len=s.length();\\n        if(len==1||s[0]!=\\'$\\')\\n            return false;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(!isdigit(s[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    long double round(long double var)\\n    {\\n        long double value = (long long int)(var * 100 + .5);\\n        return (long double)value / 100;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        double disc=discount*0.01;\\n        int len=sentence.length(),i=0,j;\\n        string res;\\n        while(i<len)\\n        {\\n            for(j=i ;j<len && sentence[j]!=\\' \\'; j++){}\\n            string sub=sentence.substr(i,j-i);\\n            if(!isvalue(sub))\\n            {\\n                res+=sub;\\n            }\\n            else{\\n               \\n                long double val=stold(sub.substr(1));\\n                val=val-val*disc;\\n                val=round(val);\\n                 std::ostringstream streamObj3;\\n                streamObj3 << std::fixed;\\n                streamObj3 << std::setprecision(2);\\n                streamObj3 << val;\\n                std::string stemp = streamObj3.str();\\n                res+=\\'$\\'+stemp.substr();\\n                streamObj3.clear();\\n            }\\n             res+=sentence[j];\\n            i=j+1;      \\n        }\\n        res.pop_back();\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    bool isvalue(string s)\\n    {\\n        int len=s.length();\\n        if(len==1||s[0]!=\\'$\\')\\n            return false;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(!isdigit(s[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    long double round(long double var)\\n    {\\n        long double value = (long long int)(var * 100 + .5);\\n        return (long double)value / 100;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        double disc=discount*0.01;\\n        int len=sentence.length(),i=0,j;\\n        string res;\\n        while(i<len)\\n        {\\n            for(j=i ;j<len && sentence[j]!=\\' \\'; j++){}\\n            string sub=sentence.substr(i,j-i);\\n            if(!isvalue(sub))\\n            {\\n                res+=sub;\\n            }\\n            else{\\n               \\n                long double val=stold(sub.substr(1));\\n                val=val-val*disc;\\n                val=round(val);\\n                 std::ostringstream streamObj3;\\n                streamObj3 << std::fixed;\\n                streamObj3 << std::setprecision(2);\\n                streamObj3 << val;\\n                std::string stemp = streamObj3.str();\\n                res+=\\'$\\'+stemp.substr();\\n                streamObj3.clear();\\n            }\\n             res+=sentence[j];\\n            i=j+1;      \\n        }\\n        res.pop_back();\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085707,
                "title": "stupid-and-naive-to-optimized-approach-c",
                "content": "After three wrong submissions and mind boggling race I came to this solution. \\nI made this approach easily but the most difficult task was to cap the double points to two decimal points that too with rounding precision. Anyways,\\n\\nThe basic idea is to just main tain two arrays which specifies the location of the price and the value of price. \\nAnd we create a new string and in this we append the discounted price.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        vector<int> loc;\\n        vector<double> number;\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        int count = 0;\\n        int n = 0;\\n\\t\\t\\n\\t\\t// we check all the separate words in a string and check if they are valid.\\n\\t\\t\\n        while (ss >> temp){\\n            count++;\\n\\t\\t\\t\\n\\t\\t\\t//First we check if the first character is a dollar sign\\n\\t\\t\\t\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n\\t\\t\\t\\t//And the following characters are number\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We make sure that there are no characters in the middle of the number that\\n\\t\\t\\t\\t//is the last character in this string is a number or not, if yes we increase the count\\n\\t\\t\\t\\t\\n                if(num > 0 && i==temp.length()){\\n                    loc.push_back(count);\\n                    number.push_back(num);\\n                    n++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now, here comes the scary part, Again iterated through the string got the \\n\\t\\t//separate words and if the word is a valid price we just change it with the discounted price\\n        string ans = \"\";\\n        stringstream newss(str);\\n        count = 0;\\n        int vec = 0;\\n        while (newss >> temp){\\n            count++;\\n            if(vec < loc.size() && loc[vec] == count){\\n\\t\\t\\t\\n\\t\\t\\t//Okay, dont be angry but I didn\\'t knew how I should convert a number to \\n\\t\\t\\t//2 point precision so I just did some research\\n                double discountPercentage = (100 - discount) / 100.0;\\n                stringstream ss2;\\n                ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                ans += \" $\" + ss2.str();\\n                vec++;\\n                continue;\\n            }\\n\\t\\t\\t//If it is not a number, then also we just add the current string to the answer \\n\\t\\t\\t//string with a preceding space\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n\\t\\t\\n\\t\\t//This was done to remove the preceding space.\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```\\n\\n**Since Now you must have an idea, we will just optimize it, by not taking any extra space and just make string array in a single traversal**\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        string ans = \"\";\\n        while (ss >> temp){\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n                if(num > 0 && i==temp.length()){\\n\\t\\t\\t\\t\\tdouble discountPercentage = (100 - discount) / 100.0;\\n                    stringstream ss2;\\n                    ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                    ans += \" $\" + ss2.str();\\n                    continue;\\n                }\\n            }\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        vector<int> loc;\\n        vector<double> number;\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        int count = 0;\\n        int n = 0;\\n\\t\\t\\n\\t\\t// we check all the separate words in a string and check if they are valid.\\n\\t\\t\\n        while (ss >> temp){\\n            count++;\\n\\t\\t\\t\\n\\t\\t\\t//First we check if the first character is a dollar sign\\n\\t\\t\\t\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n\\t\\t\\t\\t//And the following characters are number\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//We make sure that there are no characters in the middle of the number that\\n\\t\\t\\t\\t//is the last character in this string is a number or not, if yes we increase the count\\n\\t\\t\\t\\t\\n                if(num > 0 && i==temp.length()){\\n                    loc.push_back(count);\\n                    number.push_back(num);\\n                    n++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Now, here comes the scary part, Again iterated through the string got the \\n\\t\\t//separate words and if the word is a valid price we just change it with the discounted price\\n        string ans = \"\";\\n        stringstream newss(str);\\n        count = 0;\\n        int vec = 0;\\n        while (newss >> temp){\\n            count++;\\n            if(vec < loc.size() && loc[vec] == count){\\n\\t\\t\\t\\n\\t\\t\\t//Okay, dont be angry but I didn\\'t knew how I should convert a number to \\n\\t\\t\\t//2 point precision so I just did some research\\n                double discountPercentage = (100 - discount) / 100.0;\\n                stringstream ss2;\\n                ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                ans += \" $\" + ss2.str();\\n                vec++;\\n                continue;\\n            }\\n\\t\\t\\t//If it is not a number, then also we just add the current string to the answer \\n\\t\\t\\t//string with a preceding space\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n\\t\\t\\n\\t\\t//This was done to remove the preceding space.\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string str, int discount) {\\n        int i=1;       \\n        stringstream ss(str);\\n        string temp;\\n        string ans = \"\";\\n        while (ss >> temp){\\n            if(temp[0] == \\'$\\'){\\n                double num = 0;\\n                int i = 1;\\n                while(i < temp.length() && temp[i]>=\\'0\\' && temp[i]<=\\'9\\'){\\n                    double x = temp[i] - \\'0\\';\\n                    num = num * 10 + x;\\n                    i++;\\n                }\\n                if(num > 0 && i==temp.length()){\\n\\t\\t\\t\\t\\tdouble discountPercentage = (100 - discount) / 100.0;\\n                    stringstream ss2;\\n                    ss2 << fixed << setprecision(2) << (discountPercentage * num);\\n                    ans += \" $\" + ss2.str();\\n                    continue;\\n                }\\n            }\\n            ans += \" \" + temp;\\n        }\\n        int len = ans.length();\\n        return ans.substr(1,len-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041748,
                "title": "java-commented-explanation",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We split sentences to an array of individual strings\\n        String[] strArr = sentence.split(\" \");\\n        // java.text.DecimalFormat class is used for formatting numbers\\n        // as per customized format and as per locale.\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n\\n        for (int idx = 0; idx < strArr.length; idx++) {\\n            String s = strArr[idx];\\n            boolean dollarSignAtFirst = s.charAt(0) == \\'$\\';     // checks if first character is \\'$\\'\\n            // if first char is not $ or if it is but string size is 1\\n            // there is no price to alter so move on\\n            if (!dollarSignAtFirst || s.length() == 1) {\\n                continue;\\n            }\\n\\n            boolean isPriceValid = true;    // would tell if our price is valid after \\'$\\' sign\\n            for (int i = 1; i < s.length(); i++) {\\n                if (!Character.isDigit(s.charAt(i))) {  // if character is not a digit\\n                    isPriceValid = false;               // price is not valid\\n                    break;                              // break out since there is no need to iterate further\\n                }\\n            }\\n\\n            // Now, when we have \\'$\\' sign at 0-th index and also valid price after \\'$\\' sign\\n            // we will perform our alterations\\n            if (dollarSignAtFirst && isPriceValid) {\\n                long price = Long.parseLong(s.substring(1, s.length()));    // substring after $ converted to long\\n                double newPrice = price - (price * discount / 100.0);       // new price after discount\\n                strArr[idx] = \"$\" + String.valueOf(df.format(newPrice));    // putting the new price as a string back to the array at the respective index\\n            }\\n        }\\n\\n        // we need form the string back from the split array\\n        return String.join(\" \", strArr);\\n    }\\n}\\n```\\n\\n### Time Complexity: `O(m) + O(n * 10) + O(m) => O(m + n)`\\n- `m` be the number of characters in sentence.\\n- String `split()` and `join()` would cost an `O(m)`.\\n- `n` be the number of individual strings in the split array.\\n- `n * 10` because if first character is `$`, a loop runs to check if it is a valid price, at max it can be 10 digits.\\n- Otherwise we continue without looping on a string if not a potential price.\\n\\n### Space Complexity: `O(n)`",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We split sentences to an array of individual strings\\n        String[] strArr = sentence.split(\" \");\\n        // java.text.DecimalFormat class is used for formatting numbers\\n        // as per customized format and as per locale.\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n\\n        for (int idx = 0; idx < strArr.length; idx++) {\\n            String s = strArr[idx];\\n            boolean dollarSignAtFirst = s.charAt(0) == \\'$\\';     // checks if first character is \\'$\\'\\n            // if first char is not $ or if it is but string size is 1\\n            // there is no price to alter so move on\\n            if (!dollarSignAtFirst || s.length() == 1) {\\n                continue;\\n            }\\n\\n            boolean isPriceValid = true;    // would tell if our price is valid after \\'$\\' sign\\n            for (int i = 1; i < s.length(); i++) {\\n                if (!Character.isDigit(s.charAt(i))) {  // if character is not a digit\\n                    isPriceValid = false;               // price is not valid\\n                    break;                              // break out since there is no need to iterate further\\n                }\\n            }\\n\\n            // Now, when we have \\'$\\' sign at 0-th index and also valid price after \\'$\\' sign\\n            // we will perform our alterations\\n            if (dollarSignAtFirst && isPriceValid) {\\n                long price = Long.parseLong(s.substring(1, s.length()));    // substring after $ converted to long\\n                double newPrice = price - (price * discount / 100.0);       // new price after discount\\n                strArr[idx] = \"$\" + String.valueOf(df.format(newPrice));    // putting the new price as a string back to the array at the respective index\\n            }\\n        }\\n\\n        // we need form the string back from the split array\\n        return String.join(\" \", strArr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100248,
                "title": "why-price-100-discount-100-get-wrong-answer",
                "content": "```\\nclass Solution {\\n    bool isPrice(const string& s) {\\n        if (s.size() < 2 || s[0] != \\'$\\') {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i < s.size(); ++i) {\\n            if (!isdigit(s[i])) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void updatePrice(string& s, int discount) {\\n        double d = (100.0f - discount) / 100;\\n        long long price = std::stol(s.substr(1));\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << (price * d); // price * d get wrong answer.\\n        \\n        s = \\'$\\' + ss.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> words;\\n        stringstream ss(sentence);\\n        string s;\\n        \\n        while (ss >> s) {\\n            words.push_back(s);\\n        }\\n        \\n        for (auto& w : words) {\\n            if (isPrice(w)) {\\n                updatePrice(w, discount);\\n            }\\n        }\\n        \\n        string ans;\\n        for (auto& w : words) {\\n            ans += w;\\n            ans += \\' \\';\\n        }\\n        \\n        return ans.substr(0, ans.size() - 1);\\n    }\\n};\\n```\\ntest case\\n```\\n\"$7383692 5q $5870426\"\\n64\\n```\\noutput\\n```\\n\"$2658129.23 5q $2113353.44\"\\n```\\nExpected\\n```\\n\"$2658129.12 5q $2113353.36\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isPrice(const string& s) {\\n        if (s.size() < 2 || s[0] != \\'$\\') {\\n            return false;\\n        }\\n        \\n        for (int i = 1; i < s.size(); ++i) {\\n            if (!isdigit(s[i])) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    void updatePrice(string& s, int discount) {\\n        double d = (100.0f - discount) / 100;\\n        long long price = std::stol(s.substr(1));\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << (price * d); // price * d get wrong answer.\\n        \\n        s = \\'$\\' + ss.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> words;\\n        stringstream ss(sentence);\\n        string s;\\n        \\n        while (ss >> s) {\\n            words.push_back(s);\\n        }\\n        \\n        for (auto& w : words) {\\n            if (isPrice(w)) {\\n                updatePrice(w, discount);\\n            }\\n        }\\n        \\n        string ans;\\n        for (auto& w : words) {\\n            ans += w;\\n            ans += \\' \\';\\n        }\\n        \\n        return ans.substr(0, ans.size() - 1);\\n    }\\n};\\n```\n```\\n\"$7383692 5q $5870426\"\\n64\\n```\n```\\n\"$2658129.23 5q $2113353.44\"\\n```\n```\\n\"$2658129.12 5q $2113353.36\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086112,
                "title": "python-regexp-one-function-call",
                "content": "Here is my solution with `re.sub(pattern, repl, string, count=0, flags=0)` ([documentation](https://docs.python.org/3/library/re.html#re.sub)), which replaces all occurrences of `pattern` with `repl`.\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return re.sub(\\n            r\"(?:(?<=\\\\s)|(?<=^))\\\\$\\\\d+(?:(?=\\\\s)|(?=$))\",\\n            lambda x: \"${:.2f}\".format(float(x.group(0)[1:]) * (100 - discount) / 100),\\n            sentence,\\n        )\\n```\\n\\nThe important thing to note here is that we need to check that there are no characters either before or after the price. For that purpose, we should use a lookbehind `(?<=\\\\s|^)` and a lookahead `(?=\\\\s|$)` respectively.\\n\\nIn python, we need to replace `(?<=\\\\s|^)` with `(?:(?<=\\\\s)|(?<=^))` (similarly with `(?=\\\\s|$)`). Otherwise, we would get an error: **look-behind requires fixed-width pattern**.",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return re.sub(\\n            r\"(?:(?<=\\\\s)|(?<=^))\\\\$\\\\d+(?:(?=\\\\s)|(?=$))\",\\n            lambda x: \"${:.2f}\".format(float(x.group(0)[1:]) * (100 - discount) / 100),\\n            sentence,\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085979,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sp  = sentence.split()\\n        for i, word in enumerate(sp):\\n            if word[0] == \\'$\\' and str.isdigit(word[1:]):\\n                amount = (100 - discount) * int(word[1:])/ 100\\n                sp[i] = f\\'${amount:.2f}\\'\\n        return \\' \\'.join(sp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sp  = sentence.split()\\n        for i, word in enumerate(sp):\\n            if word[0] == \\'$\\' and str.isdigit(word[1:]):\\n                amount = (100 - discount) * int(word[1:])/ 100\\n                sp[i] = f\\'${amount:.2f}\\'\\n        return \\' \\'.join(sp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085818,
                "title": "python-4-line",
                "content": "\\tclass Solution:\\n\\t\\tdef discountPrices(self, s: str, d: int) -> str:\\n\\t\\t\\ta = s.split()\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tif i[0]==\\'$\\' and i[1:].isnumeric(): \\n\\t\\t\\t\\t\\tp = round(int(i[1:])-(int(i[1:])/100.00)*d,2)\\n\\t\\t\\t\\t\\tif str(p)[-2]==\\'.\\': a[idx] = \\'$\\'+str(p)+\\'0\\'  \\n\\t\\t\\t\\t\\telse: a[idx] = \\'$\\'+str(p)\\n\\t\\t\\treturn \" \".join(a)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef discountPrices(self, s: str, d: int) -> str:\\n\\t\\t\\ta = s.split()\\n\\t\\t\\tfor idx,i in enumerate(a):\\n\\t\\t\\t\\tif i[0]==\\'$\\' and i[1:].isnumeric(): \\n\\t\\t\\t\\t\\tp = round(int(i[1:])-(int(i[1:])/100.00)*d,2)\\n\\t\\t\\t\\t\\tif str(p)[-2]==\\'.\\': a[idx] = \\'$\\'+str(p)+\\'0\\'  \\n\\t\\t\\t\\t\\telse: a[idx] = \\'$\\'+str(p)\\n\\t\\t\\treturn \" \".join(a)",
                "codeTag": "Java"
            },
            {
                "id": 2085814,
                "title": "stupid-ques-but-solved-after-5-wrong-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        stringstream ss(sentence);string t;\\n        long double dd=(double)(100-discount)/100;\\n        \\n        string ans;\\n        while(ss>>t){\\n            if(t[0]==\\'$\\' && t.length()>=2 && t[1]!=\\'$\\'){\\n                int f=0,l=0;\\n                long long int p=0;\\n                for(int i=1;i<t.length();i++){\\n                    if(t[i]==\\'$\\'||!(t[i]>=\\'0\\'&&t[i]<=\\'9\\')){\\n                        f=1;\\n                        break;\\n                    }\\n                   \\n                    \\n                }\\n                \\n                if(!f){\\n                    for(int i=1;i<t.length();i++){\\n                       p=p*10+t[i]-\\'0\\';   \\n                    }\\n                    long double a=(double)p*dd;\\n                    string r=to_string(a);\\n                    int i=0;\\n                    for( i=0;i<r.length();i++){\\n                        if(r[i]==\\'.\\')\\n                            break;\\n                    }\\n                    r=r.substr(0,i)+\\'.\\'+r.substr(i+1,2);\\n                    t=\\'$\\'+r;\\n                }\\n            }\\n            ans+=t;\\n            ans+=\\' \\';\\n        }\\n        ans=ans.substr(0,ans.length()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        stringstream ss(sentence);string t;\\n        long double dd=(double)(100-discount)/100;\\n        \\n        string ans;\\n        while(ss>>t){\\n            if(t[0]==\\'$\\' && t.length()>=2 && t[1]!=\\'$\\'){\\n                int f=0,l=0;\\n                long long int p=0;\\n                for(int i=1;i<t.length();i++){\\n                    if(t[i]==\\'$\\'||!(t[i]>=\\'0\\'&&t[i]<=\\'9\\')){\\n                        f=1;\\n                        break;\\n                    }\\n                   \\n                    \\n                }\\n                \\n                if(!f){\\n                    for(int i=1;i<t.length();i++){\\n                       p=p*10+t[i]-\\'0\\';   \\n                    }\\n                    long double a=(double)p*dd;\\n                    string r=to_string(a);\\n                    int i=0;\\n                    for( i=0;i<r.length();i++){\\n                        if(r[i]==\\'.\\')\\n                            break;\\n                    }\\n                    r=r.substr(0,i)+\\'.\\'+r.substr(i+1,2);\\n                    t=\\'$\\'+r;\\n                }\\n            }\\n            ans+=t;\\n            ans+=\\' \\';\\n        }\\n        ans=ans.substr(0,ans.length()-1);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085758,
                "title": "easy-solution-split-array-few-lines-o-n-100-faster",
                "content": "Updated Version:\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nfunction discountPrices(sentence, discount) {\\n    // \\'there are $0 $2 and 5$ candies in the shop\\'\\n    let arr = sentence.split(\\' \\')\\n    // [\\'there\\',  \\'are\\', \\'$1\\', \\'$2\\' etc...]\\n    for(let i = 0; i < arr.length; i++){\\n        const stringPrice = arr[i].substr(1, arr[i].length);\\n       // arr[i] check if it starts with sign $ and the rest of the chars are digits\\n        if(arr[i][0] != \\'$\\' || !(/^\\\\d+$/).test(stringPrice))\\n            continue;\\n        \\n        // convert the string price to Number\\n        const price = Number(stringPrice)\\n        if(price == 0) {\\n            arr[i] = \\'$\\';\\n            continue;\\n        }\\n        \\n        arr[i] = \\'$\\' + (price - (price * discount) / 100).toFixed(2);\\n    }\\n    \\n    return arr.join(\\' \\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nfunction discountPrices(sentence, discount) {\\n    // \\'there are $0 $2 and 5$ candies in the shop\\'\\n    let arr = sentence.split(\\' \\')\\n    // [\\'there\\',  \\'are\\', \\'$1\\', \\'$2\\' etc...]\\n    for(let i = 0; i < arr.length; i++){\\n        const stringPrice = arr[i].substr(1, arr[i].length);\\n       // arr[i] check if it starts with sign $ and the rest of the chars are digits\\n        if(arr[i][0] != \\'$\\' || !(/^\\\\d+$/).test(stringPrice))\\n            continue;\\n        \\n        // convert the string price to Number\\n        const price = Number(stringPrice)\\n        if(price == 0) {\\n            arr[i] = \\'$\\';\\n            continue;\\n        }\\n        \\n        arr[i] = \\'$\\' + (price - (price * discount) / 100).toFixed(2);\\n    }\\n    \\n    return arr.join(\\' \\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085706,
                "title": "stupid-ques-worst-test-cases",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string& word) {\\n        if(word[0] != \\'$\\' || word.size() == 1)\\n            return false;\\n        for(int i=1;i<word.size();i++) {\\n            if(word[i] == \\'$\\' || isalpha(word[i]))\\n                return false;\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string word;\\n        stringstream iss(sentence);\\n         while (iss >> word) {\\n             if(check(word)) {\\n                 long double num = stoll(word.substr(1));\\n                 // cout << num << endl;\\n                 long double dis = num - (ceil((num)*discount))/100;\\n                 // dis = std::ceil(dis * 100.0) / 100.0;\\n                 // cout << dis << endl;\\n                 long int tempp = dis;\\n                 string temppstr = to_string(tempp);\\n                 long int temppsz = temppstr.size();\\n                 string temp = to_string(dis);\\n                 // cout << temp << endl;\\n                 res.push_back(\\'$\\');\\n                 res.append(temp.substr(0,temppsz+3) + \\' \\');\\n             }\\n             else {\\n                 res.append(word + \\' \\');\\n             }\\n         }\\n        res.pop_back();\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool check(string& word) {\\n        if(word[0] != \\'$\\' || word.size() == 1)\\n            return false;\\n        for(int i=1;i<word.size();i++) {\\n            if(word[i] == \\'$\\' || isalpha(word[i]))\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2085675,
                "title": "apply-discount-to-prices-java-solution",
                "content": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words=sentence.split(\"\\\\\\\\s\");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word1=words[i];\\n            String newString=\"\";\\n            if(word1.charAt(0)==\\'$\\')\\n            {\\n                String word=word1.substring(1);\\n                if (word == null) \\n                {\\n                    newString=word1;\\n                }\\n                    \\n                else\\n                {\\n                    int length = word.length();\\n                    if (length == 0) \\n                    {\\n                        newString=word1;\\n                    }\\n                    else\\n                    {\\n                        int j = 0,f=0;\\n                        if (word.charAt(0) == \\'-\\') \\n                        {\\n                            if(length==1)\\n                            {\\n                                newString=word1;\\n                                f=1;\\n                            }\\n                        }\\n                        if(f==0)\\n                        {\\n                            int flag=0;\\n                            for (; j < length; j++) \\n                            {\\n                                char c = word.charAt(j);\\n                                if (c < \\'0\\' || c > \\'9\\') \\n                                {\\n                                    newString=word1;\\n                                    flag=1;\\n                                    break;\\n                                }\\n                            }\\n                            if(flag==0)\\n                            {\\n                                double price=Double.parseDouble(word);\\n                                double dis=(discount/100.0)*price;\\n                                price=price-dis;\\n                                newString=\"$\"+String.format(\"%.2f\", price)+\"\";\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n                newString=word1;\\n            ans.append(newString+\" \");\\n        }\\n        return ans.toString().trim();\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words=sentence.split(\"\\\\\\\\s\");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            String word1=words[i];\\n            String newString=\"\";\\n            if(word1.charAt(0)==\\'$\\')\\n            {\\n                String word=word1.substring(1);\\n                if (word == null) \\n                {\\n                    newString=word1;\\n                }\\n                    \\n                else\\n                {\\n                    int length = word.length();\\n                    if (length == 0) \\n                    {\\n                        newString=word1;\\n                    }\\n                    else\\n                    {\\n                        int j = 0,f=0;\\n                        if (word.charAt(0) == \\'-\\') \\n                        {\\n                            if(length==1)\\n                            {\\n                                newString=word1;\\n                                f=1;\\n                            }\\n                        }\\n                        if(f==0)\\n                        {\\n                            int flag=0;\\n                            for (; j < length; j++) \\n                            {\\n                                char c = word.charAt(j);\\n                                if (c < \\'0\\' || c > \\'9\\') \\n                                {\\n                                    newString=word1;\\n                                    flag=1;\\n                                    break;\\n                                }\\n                            }\\n                            if(flag==0)\\n                            {\\n                                double price=Double.parseDouble(word);\\n                                double dis=(discount/100.0)*price;\\n                                price=price-dis;\\n                                newString=\"$\"+String.format(\"%.2f\", price)+\"\";\\n                            }\\n                        }\\n                        \\n                    }\\n                    \\n                }\\n                \\n                \\n            }\\n            else\\n                newString=word1;\\n            ans.append(newString+\" \");\\n        }\\n        return ans.toString().trim();\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455832,
                "title": "java-concise-code-beats-90",
                "content": "## Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n``` java []\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String x:arr){\\n            if(i!=arr.length-1)\\n                sb.append(convert(x,discount,df)+\" \");\\n            else\\n                sb.append(convert(x,discount,df));\\n            i++;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n    private String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'$\\'){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String x:arr){\\n            if(i!=arr.length-1)\\n                sb.append(convert(x,discount,df)+\" \");\\n            else\\n                sb.append(convert(x,discount,df));\\n            i++;\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n\\n    private String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'$\\'){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417379,
                "title": "c-easy-problem-tricky-solution",
                "content": "```\\nstring discountPrices(string sentence, int discount) {\\n    // Creating a stringstream object to read the words in the sentence.\\n    stringstream s(sentence);\\n    // Declaring string variables for the current word being read and the answer string.\\n    string word, ans = \"\";\\n    // Looping through each word in the sentence.\\n    while(s >> word) {\\n        // Checking if the word starts with \\'$\\' and has more than one character.\\n        if(word[0] == \\'$\\' && word.size() > 1) {\\n            // Declaring a boolean variable to check if the rest of the characters in the word are numbers.\\n            bool isNum = true;\\n            // Declaring a string variable to store the numerical value in the word.\\n            string s = \"\";\\n            // Looping through each character in the word starting from the second character.\\n            for(int i = 1; i < word.size(); ++i) {\\n                // Adding each character to the s string variable.\\n                s += word[i];\\n                // Checking if the current character is not a number, in which case the word is not a number.\\n                if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                    isNum = false;\\n                    break;\\n                }   \\n            }\\n            // If the word is a number, we apply the discount.\\n            if(isNum) {\\n                // Converting the string s to a long double and applying the discount.\\n                long double disc = stoll(s) * (100-discount)/100.0;\\n                // Declaring a string variable to store the formatted discounted value.\\n                string b = \"\";\\n                // Creating an output string stream object to format the discounted value with two decimal places.\\n                ostringstream stream;\\n                stream <<fixed<<setprecision(2)<<disc;\\n                // Storing the formatted discounted value as a string in the a variable.\\n                string a=stream.str();\\n                // Declaring integer variables to keep track of the number of decimal places and the position of the decimal point.\\n                int f = 0, isDot = false;\\n                // Looping through each character in the a string.\\n                for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                    // Checking if the current character is the decimal point, in which case we set isDot to true.\\n                    if(a[i] == \\'.\\') isDot = true;\\n                    // If isDot is true, we increment the f variable.\\n                    if(isDot) ++f;\\n                    // Adding the current character to the b string variable.\\n                    b += a[i];\\n                }\\n                // Adding the formatted discounted value to the answer string with a preceding \\'$\\' character and a space.\\n                ans += \\'$\\' + b + \\' \\';\\n            }\\n            // If the word is not a number, we add it to the answer string.\\n            else ans += word + \\' \\';\\n        }\\n        // If the word does not start with \\'$\\' or has only one character, we add it to the answer string.\\n        else ans += word + \\' \\';\\n    }\\n    // Removing the last space character from the answer string and returning it.\\n    return ans.substr(0,ans.size()-1);\\n}\\n\\n```\\nOk so this question had my brain go crazy, made me un poco loco... pukitittio loco. Well finally cracked it and had to go through a lot of discussion and self doubts throughout but finally had it done. The relevant comments are there in place for a better understanding.\\n\\nHope it helps and you don\\'t do poco loco. (I don\\'t know spanish... I just like the song).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring discountPrices(string sentence, int discount) {\\n    // Creating a stringstream object to read the words in the sentence.\\n    stringstream s(sentence);\\n    // Declaring string variables for the current word being read and the answer string.\\n    string word, ans = \"\";\\n    // Looping through each word in the sentence.\\n    while(s >> word) {\\n        // Checking if the word starts with \\'$\\' and has more than one character.\\n        if(word[0] == \\'$\\' && word.size() > 1) {\\n            // Declaring a boolean variable to check if the rest of the characters in the word are numbers.\\n            bool isNum = true;\\n            // Declaring a string variable to store the numerical value in the word.\\n            string s = \"\";\\n            // Looping through each character in the word starting from the second character.\\n            for(int i = 1; i < word.size(); ++i) {\\n                // Adding each character to the s string variable.\\n                s += word[i];\\n                // Checking if the current character is not a number, in which case the word is not a number.\\n                if(!(word[i] >= \\'0\\' && word[i] <= \\'9\\')) {\\n                    isNum = false;\\n                    break;\\n                }   \\n            }\\n            // If the word is a number, we apply the discount.\\n            if(isNum) {\\n                // Converting the string s to a long double and applying the discount.\\n                long double disc = stoll(s) * (100-discount)/100.0;\\n                // Declaring a string variable to store the formatted discounted value.\\n                string b = \"\";\\n                // Creating an output string stream object to format the discounted value with two decimal places.\\n                ostringstream stream;\\n                stream <<fixed<<setprecision(2)<<disc;\\n                // Storing the formatted discounted value as a string in the a variable.\\n                string a=stream.str();\\n                // Declaring integer variables to keep track of the number of decimal places and the position of the decimal point.\\n                int f = 0, isDot = false;\\n                // Looping through each character in the a string.\\n                for(int i = 0; i < a.size() && f <= 2; ++i) {\\n                    // Checking if the current character is the decimal point, in which case we set isDot to true.\\n                    if(a[i] == \\'.\\') isDot = true;\\n                    // If isDot is true, we increment the f variable.\\n                    if(isDot) ++f;\\n                    // Adding the current character to the b string variable.\\n                    b += a[i];\\n                }\\n                // Adding the formatted discounted value to the answer string with a preceding \\'$\\' character and a space.\\n                ans += \\'$\\' + b + \\' \\';\\n            }\\n            // If the word is not a number, we add it to the answer string.\\n            else ans += word + \\' \\';\\n        }\\n        // If the word does not start with \\'$\\' or has only one character, we add it to the answer string.\\n        else ans += word + \\' \\';\\n    }\\n    // Removing the last space character from the answer string and returning it.\\n    return ans.substr(0,ans.size()-1);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253588,
                "title": "self-explanatory-python3-using-startswith-and-string-split",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word.startswith(\\'\\n```) and word[1:].isdigit():\\n                price = int(word[1:])\\n                discounted_price = round(price * (100 - discount) / 100, 2)\\n                new_word = \"$\" + format(discounted_price, \".2f\")\\n                words[i] = new_word\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for i, word in enumerate(words):\\n            if word.startswith(\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187954,
                "title": "crisp-n-clear-o-n-javascript-memory-100-screenshot-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nvar discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/eb85cf14-c288-4671-bdd9-d27cbeb92142_1676443063.0617776.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n\\tlet output = \\'\\';\\n\\tfor (let index = 0; index < sentence.length; index++) {\\n\\t\\tlet element = sentence[index];\\n\\t\\tif (element === `$` && (sentence[index - 1] === ` ` || sentence[index - 1] === undefined)) {\\n\\t\\t\\tlet hasBroken = false;\\n\\t\\t\\tlet num = ``;\\n\\t\\t\\telement = sentence[++index];\\n\\t\\t\\twhile (element !== ` ` && element !== undefined) {\\n\\t\\t\\t\\tnum += element;\\n\\t\\t\\t\\tif (isNaN(element)) {\\n\\t\\t\\t\\t\\thasBroken = true;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement = sentence[++index];\\n\\t\\t\\t}\\n\\t\\t\\tif (num.length && !isNaN(num) && typeof Number(num) === `number`) {\\n\\t\\t\\t\\tconst discountedPrice = (Number(num) - discount * Number(num) / 100).toFixed(2);\\n\\t\\t\\t\\toutput += `$${discountedPrice} `;\\n\\t\\t\\t} else if (hasBroken) {\\n\\t\\t\\t\\toutput += `$${num}`;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\toutput += `$${num} `;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\toutput += element;\\n\\t\\t}\\n\\t}\\n\\treturn output.trim();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983843,
                "title": "java-native-approach",
                "content": "\\n\\n# Code\\n```\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String res = \"\";\\n        for (int i = 0; i < arr.length; i++) {\\n            double amount = 0;\\n\\n            if (arr[i].startsWith(\"$\")) {\\n                int len = arr[i].length();\\n                int index = 1;\\n                if(arr[i].length()==1){\\n                    res+=arr[i]+\" \";\\n                    continue;\\n                }\\n          //get the numeric values form $50\\n                while (index < len && Character.isDigit(arr[i].charAt(index)))\\n                    amount = amount * 10 + (arr[i].charAt(index++) - \\'0\\');\\n  //check if value is valid or not ie. $50 is valid and $1e4 is not valid\\n                if (index == len) \\n                    arr[i] = new String(\\n                            \"$\" + String.format(\"%.2f\", (amount - (amount * discount) / 100)));\\n            }\\n            res += arr[i] + \" \";\\n        }\\n       \\n        return res.trim();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String res = \"\";\\n        for (int i = 0; i < arr.length; i++) {\\n            double amount = 0;\\n\\n            if (arr[i].startsWith(\"$\")) {\\n                int len = arr[i].length();\\n                int index = 1;\\n                if(arr[i].length()==1){\\n                    res+=arr[i]+\" \";\\n                    continue;\\n                }\\n          //get the numeric values form $50\\n                while (index < len && Character.isDigit(arr[i].charAt(index)))\\n                    amount = amount * 10 + (arr[i].charAt(index++) - \\'0\\');\\n  //check if value is valid or not ie. $50 is valid and $1e4 is not valid\\n                if (index == len) \\n                    arr[i] = new String(\\n                            \"$\" + String.format(\"%.2f\", (amount - (amount * discount) / 100)));\\n            }\\n            res += arr[i] + \" \";\\n        }\\n       \\n        return res.trim();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735168,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'\\n```)\\n                {\\n                    string z=str.substr(1);\\n                    string a=check(z,d);\\n                    if(a!=\"-1\")\\n                    {\\n                      ans+=\\'\\n```;\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    string check(string s,int d)\\n    {\\n        int c=0;\\n        for(char ch:s)\\n        {\\n            if(isdigit(ch))\\n            {\\n                c++;\\n            }\\n        }\\n        string res=\"\";\\n        if(c!=s.length()||c==0)\\n        return \"-1\";\\n        else\\n        {\\n            ll zz=stoll(s);\\n            \\n            ll dd=(d)*zz;\\n            \\n            ld xx=dd/100.0;\\n            ld rr=zz-xx;\\n            res=to_string(rr);\\n            int x=4;\\n            while(x--)\\n            res.pop_back();\\n        \\n        }\\n        return res;\\n    }\\n    string discountPrices(string s, int d) {\\n        s+=\\' \\';\\n        int n=s.length();\\n        int left=0;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\' \\')\\n            {\\n                string str=s.substr(left,i-left);\\n                bool ok=false;\\n                if(str[0]==\\'\\n```\n```;\\n                      ans+=a;  \\n                      ans+=\\' \\';\\n                        ok=true;\\n                    }\\n                    else\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                else\\n                {\\n                    if(!ok)\\n                    {\\n                        ans+=str;\\n                        ans+=\\' \\';\\n                    }\\n                }\\n                left=i+1;\\n            }\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598931,
                "title": "simple-and-sweet-python-solution-beats-82-73",
                "content": "![image](https://assets.leetcode.com/users/images/fdbab82d-7721-4761-837d-9f3fa78bdc25_1663620375.3070908.png)\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        \\n        for idx in range(len(words)):\\n            curr = words[idx]\\n            \\n            if curr[0] == \\'$\\' and curr[1:].isdigit():\\n                \\n                price = int(curr[1:])\\n                deduction = (price*discount) / 100\\n                newPrice = price - deduction\\n                words[idx] = f\"${newPrice:.2f}\"\\n                    \\n        return \\' \\'.join(words)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        \\n        for idx in range(len(words)):\\n            curr = words[idx]\\n            \\n            if curr[0] == \\'$\\' and curr[1:].isdigit():\\n                \\n                price = int(curr[1:])\\n                deduction = (price*discount) / 100\\n                newPrice = price - deduction\\n                words[idx] = f\"${newPrice:.2f}\"\\n                    \\n        return \\' \\'.join(words)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372620,
                "title": "python3-regex-substitution",
                "content": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \"\"\"If you use regex, now you have two problems. \\n\\n        Lots of trial and error on regex101.com\\n\\n        254 ms, faster than 40.17%\\n        \"\"\"\\n        \\n        def repl(m):\\n            rep = float(m.group(2)) * (100 - discount) / 100\\n            return f\\'${rep:.2f}\\'\\n\\n        return re.sub(r\\'(^|(?<=\\\\s))\\\\$(\\\\d+)(?=\\\\s|$)\\', repl, sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \"\"\"If you use regex, now you have two problems. \\n\\n        Lots of trial and error on regex101.com\\n\\n        254 ms, faster than 40.17%\\n        \"\"\"\\n        \\n        def repl(m):\\n            rep = float(m.group(2)) * (100 - discount) / 100\\n            return f\\'${rep:.2f}\\'\\n\\n        return re.sub(r\\'(^|(?<=\\\\s))\\\\$(\\\\d+)(?=\\\\s|$)\\', repl, sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277320,
                "title": "well-this-is-one-hell-of-a-problem-but-finally-caught-it-in-cage",
                "content": "**>>>>>>>>> Please upvote if it get to you !!!!!!!!**\\n\\nstringstream class covert a given string into stream of words.\\n\\n**stringstream class Has few option!!**\\n\\n\\tclear() [ To clear Stream ]\\n\\tstr() [ To convert stream back to string ]\\n\\t>> [ To read word from Stream ]\\n\\t<< [ To write word to stream ]\\n\\t\\n1. stringstream ss( str ) -> where str is given string ( str = \"Hello everybody let\\'s go\" )\\n2. ss is stream that contains all words of str.\\n3. Basically we convert str ( string ) to ss ( stream )\\n4. To retrieve word from this stream we use while loop\\n\\n\\t```\\n\\tstringstream ss( str );\\n\\tstring word;\\n\\t\\n\\twhile( ss >> word )  \\n\\t{\\n\\t\\tcout<<word<<\"  \";\\n\\t}\\n\\t```\\n\\t\\n\\toutput : >>  Hello everybody let\\'s go\\n\\t\\n**To make numeric value precision to two decimal place we write !!!**\\n```\\nstringstream makePre;\\nfloat number = 555.6598;\\n\\nmakePre<<fixed<<setprecision(2)<<number;\\n\\ncout<<makePre.str();\\n\\n```\\noutput : >> 555.65\\n\\n# **Finally we are down to code !!!**\\n```\\nclass Solution\\n{\\npublic:\\n    string discountPrices(string sentence, int discount)\\n    {\\n\\n        stringstream ss(sentence);\\n        string word, res = \"\";\\n        long long num;\\n        bool flag=false;\\n\\n        while (ss >> word)\\n        {\\n            if (word[0] == \\'$\\' && word.size()>1)\\n            {\\n                num = 0;\\n                flag=false;\\n                for (int i = 1; i < word.size(); i++)\\n                {\\n                    if(!isdigit(word[i]))\\n                    {\\n                        flag=true;\\n                        res+=word+\" \";\\n                        break;\\n                    }\\n                    num = num * 10 + (word[i] - 48);\\n                }\\n                \\n                if(!flag)\\n                {\\n                    stringstream preStr;\\n\\n                    double disPrice = num*1.0 - ((num * discount * 1.0) / 100);\\n\\n                    preStr << fixed << setprecision(2) << disPrice;\\n\\n                    word = \\'$\\' + preStr.str();\\n\\n                    res += word + \" \";\\n                }\\n\\n            }\\n            else\\n            {\\n                res += word + \" \";\\n            }\\n        }\\n\\n        return res.substr(0, res.size() - 1);\\n    }\\n};\\n```\\n\\n# **That was Hell of a job!!**\\n\\n![image](https://assets.leetcode.com/users/images/3babe32d-0d0a-41ea-9f7b-2c4a8345d6c0_1657720887.247811.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\tstringstream ss( str );\\n\\tstring word;\\n\\t\\n\\twhile( ss >> word )  \\n\\t{\\n\\t\\tcout<<word<<\"  \";\\n\\t}\\n\\t```\n```\\nstringstream makePre;\\nfloat number = 555.6598;\\n\\nmakePre<<fixed<<setprecision(2)<<number;\\n\\ncout<<makePre.str();\\n\\n```\n```\\nclass Solution\\n{\\npublic:\\n    string discountPrices(string sentence, int discount)\\n    {\\n\\n        stringstream ss(sentence);\\n        string word, res = \"\";\\n        long long num;\\n        bool flag=false;\\n\\n        while (ss >> word)\\n        {\\n            if (word[0] == \\'$\\' && word.size()>1)\\n            {\\n                num = 0;\\n                flag=false;\\n                for (int i = 1; i < word.size(); i++)\\n                {\\n                    if(!isdigit(word[i]))\\n                    {\\n                        flag=true;\\n                        res+=word+\" \";\\n                        break;\\n                    }\\n                    num = num * 10 + (word[i] - 48);\\n                }\\n                \\n                if(!flag)\\n                {\\n                    stringstream preStr;\\n\\n                    double disPrice = num*1.0 - ((num * discount * 1.0) / 100);\\n\\n                    preStr << fixed << setprecision(2) << disPrice;\\n\\n                    word = \\'$\\' + preStr.str();\\n\\n                    res += word + \" \";\\n                }\\n\\n            }\\n            else\\n            {\\n                res += word + \" \";\\n            }\\n        }\\n\\n        return res.substr(0, res.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2265770,
                "title": "java-a-very-efficient-100-faster-and-reasonably-elegant-answer",
                "content": "Java\\'s String immutability is great for saving on memory, but can make dealing with them a tricky business. For questions like these, a good rule of thumb is to avoid dealing with them as much as possible if performance is an issue.\\n\\nThe difficulty in this question is mostly threefold. You have to do the following:\\n\\n1. Ensure that the word is a valid price.\\n2. Parse the word as a price and apply the discount, taking care not to lose any accuracy.\\n3. Round the price to two digits.\\n\\nBecause ensuring a valid price involves more than just using some `parseInt()` function, it\\'s actually best to do all of these steps in one loop. This also adds in efficiency, as we don\\'t parse each word multiple times or rely on exception handling. We may also build up the price while we\\'re at it, so we won\\'t have to re-parse the price later. This takes care of item 1 on our list.\\n\\nHow would you go about applying the discount? Most people would be tempted to use a `float` or a `double` type here, but *this is generally a bad idea*! Since precision is never a guarantee with these data types, you will have to write a lot of extra code to handle rounding and formatting. Instead, since we know that the discount is always a whole percentage, we can guarantee that the discounted price is representable using a whole number of cents, which can be represented using an `int` or a `long` instead. As a general rule of thumb, **use an integral type for formatting values like currencies if you know you won\\'t be dealing with fractions of a cent.** It\\'ll obviate the need for rounding and precision code because these will never become an issue. With that in mind, we can take the discount by doing the following:\\n\\n`discountCents = totalPrice * (100 - discountPercent)`\\n\\nAnd lastly, formatting the price as a String is no longer a huge challenge. You can extract the number of cents by taking the total price modulo 100, and the number of dollars by dividing the price by 100. Do keep in mind of a small edge case, where the number of cents can be less than 10. Since we want the cent value to have two digits, you would need to prepend a `0` in the front.\\n\\nAnd that\\'s items 2 and 3 on our list! You can make some other optimizations to the code, like re-using the same `StringBuilder` instance to avoid unnecessary object creation, among others. Here\\'s the final code:\\n\\n```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We can first split the String by spaces for easier processing:\\n        String[] words = sentence.split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        \\n        // Iterate over every word, only replace if it\\'s a price.\\n        for (String word : words) {\\n            appendDiscount(word, discount, ans);\\n            ans.append(\\' \\');\\n        }\\n        \\n        // Trim the last space\\n        return ans.substring(0, ans.length() - 1);\\n    }\\n    \\n    // We can assume the price will be an integer value.\\n    // We may also reuse the same StringBuilder instance to avoid\\n    // unnecessary object creation.\\n    private void appendDiscount(String word, int disc, StringBuilder sb) {\\n        if (!word.startsWith(\"$\") || word.length() < 2) {\\n            sb.append(word);\\n            return;\\n        }\\n        \\n        long price = 0;\\n        for (int i = 1; i < word.length(); i++) {\\n            int digit = word.charAt(i) - \\'0\\';\\n            \\n            // If out of bounds, we don\\'t have a digit\\n            if (digit < 0 || digit > 10) {\\n                sb.append(word);\\n                return;\\n            }\\n            \\n            price *= 10;\\n            price += digit;\\n        }\\n        \\n        // Apply the discount! Now our price is expressed in pennies.\\n        price *= 100 - disc;\\n        \\n        // Format the result and return.\\n        // Effectively, we break our answer into pre- and post- sections\\n        // and append those separately.\\n        sb.append(\\'$\\').append(price / 100).append(\\'.\\');\\n        \\n        // Add a leading zero if the part after the period needs one.\\n        price %= 100;\\n        if (price < 10)\\n            sb.append(\\'0\\');\\n        \\n        sb.append(price);\\n    }\\n}\\n```\\nRuntime: **22 ms** (faster than 100%)\\nMemory use: **45 MB** (less than 99.6%)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        // We can first split the String by spaces for easier processing:\\n        String[] words = sentence.split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        \\n        // Iterate over every word, only replace if it\\'s a price.\\n        for (String word : words) {\\n            appendDiscount(word, discount, ans);\\n            ans.append(\\' \\');\\n        }\\n        \\n        // Trim the last space\\n        return ans.substring(0, ans.length() - 1);\\n    }\\n    \\n    // We can assume the price will be an integer value.\\n    // We may also reuse the same StringBuilder instance to avoid\\n    // unnecessary object creation.\\n    private void appendDiscount(String word, int disc, StringBuilder sb) {\\n        if (!word.startsWith(\"$\") || word.length() < 2) {\\n            sb.append(word);\\n            return;\\n        }\\n        \\n        long price = 0;\\n        for (int i = 1; i < word.length(); i++) {\\n            int digit = word.charAt(i) - \\'0\\';\\n            \\n            // If out of bounds, we don\\'t have a digit\\n            if (digit < 0 || digit > 10) {\\n                sb.append(word);\\n                return;\\n            }\\n            \\n            price *= 10;\\n            price += digit;\\n        }\\n        \\n        // Apply the discount! Now our price is expressed in pennies.\\n        price *= 100 - disc;\\n        \\n        // Format the result and return.\\n        // Effectively, we break our answer into pre- and post- sections\\n        // and append those separately.\\n        sb.append(\\'$\\').append(price / 100).append(\\'.\\');\\n        \\n        // Add a leading zero if the part after the period needs one.\\n        price %= 100;\\n        if (price < 10)\\n            sb.append(\\'0\\');\\n        \\n        sb.append(price);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218000,
                "title": "c-easy-to-understand-simple-approach-96-faster",
                "content": "string discountPrices(string sentence, int discount) {\\n\\n        bool isDollar=false;\\n        string ans=\"\";\\n        string num=\"\";\\n        for(int i=0;i<sentence.size();i++) {\\n            if(isDollar) {\\n                if(isdigit(sentence[i]))\\n                 num+=sentence[i];\\n                else {\\n                    if(num.size()!=0 && sentence[i]==\\' \\') { // if there is price \\n                        long long x=stoll(num);\\n                        long long y = (long long)(x*(100-discount));\\n                        ans+=to_string(y/100);\\n                        ans+=\\'.\\';\\n                        string w = to_string(y%100); \\n                        if(w.size()==1) ans+=\\'0\\'; // for precision \\n                         ans+=to_string(y%100);\\n                    } else if(num.size()!=0) {\\n                        ans+=num;\\n                    }\\n                    ans+=sentence[i];\\n                    num=\"\";\\n                    isDollar=false;\\n                }\\n            } else {\\n                if(sentence[i]==\\'$\\' && (ans.back()==\\' \\' ||ans.size()==0) ) isDollar=true;\\n                ans+=sentence[i];\\n            }\\n            \\n        }\\n         if(num.size()!=0) {  // check if the price exist at last position\\n                long long x=stoll(num);\\n                long long y = (long long)(x*(100-discount));\\n                ans+=to_string(y/100);\\n                ans+=\\'.\\';\\n                string w = to_string(y%100);\\n                if(w.size()==1) ans+=\\'0\\';\\n                 ans+=to_string(y%100);\\n            }\\n        return ans;\\n   }",
                "solutionTags": [
                    "C"
                ],
                "code": "string discountPrices(string sentence, int discount) {\\n\\n        bool isDollar=false;\\n        string ans=\"\";\\n        string num=\"\";\\n        for(int i=0;i<sentence.size();i++) {\\n            if(isDollar) {\\n                if(isdigit(sentence[i]))\\n                 num+=sentence[i];\\n                else {\\n                    if(num.size()!=0 && sentence[i]==\\' \\') { // if there is price \\n                        long long x=stoll(num);\\n                        long long y = (long long)(x*(100-discount));\\n                        ans+=to_string(y/100);\\n                        ans+=\\'.\\';\\n                        string w = to_string(y%100); \\n                        if(w.size()==1) ans+=\\'0\\'; // for precision \\n                         ans+=to_string(y%100);\\n                    } else if(num.size()!=0) {\\n                        ans+=num;\\n                    }\\n                    ans+=sentence[i];\\n                    num=\"\";\\n                    isDollar=false;\\n                }\\n            } else {\\n                if(sentence[i]==\\'$\\' && (ans.back()==\\' \\' ||ans.size()==0) ) isDollar=true;\\n                ans+=sentence[i];\\n            }\\n            \\n        }\\n         if(num.size()!=0) {  // check if the price exist at last position\\n                long long x=stoll(num);\\n                long long y = (long long)(x*(100-discount));\\n                ans+=to_string(y/100);\\n                ans+=\\'.\\';\\n                string w = to_string(y%100);\\n                if(w.size()==1) ans+=\\'0\\';\\n                 ans+=to_string(y%100);\\n            }\\n        return ans;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 2158345,
                "title": "java-solution-fastest-very-easy-and-understandable",
                "content": "\\n    // Boolean Function to check if the number is valid\\n    public boolean isLong(String s){\\n        try{\\n           Long.parseLong(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        // Split the sentence by space to form an array\\n        String[] str = sentence.split(\" \");\\n        int n = str.length;\\n        StringBuilder ans = new StringBuilder();\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t// if first character is not $ add it to ans\\n            if(str[i].charAt(0) != \\'$\\'){\\n                ans.append(str[i]+\" \");\\n                continue;\\n            }\\n\\t\\t\\t// else take the substring from first index so that only numeric part is taken\\n            String s = str[i].substring(1,str[i].length());\\n\\t\\t\\t\\n            // and add the $ sign to ans\\n            ans.append(\"$\");\\n\\t\\t\\t\\n\\t\\t\\t// check if the substring is valid number if valid calculate value and append else append without performing any operations\\n            if(isLong(s)){\\n                long num = Long.parseLong(s);\\n                double res = (double) num - ((double)num * (double)discount)/100.00;\\n\\t\\t\\t\\t// format decimal to 2 places\\n                DecimalFormat df = new DecimalFormat(\"0.00\");\\n                ans.append(df.format(res)+\" \");\\n            }\\n            else{\\n                ans.append(s+\" \");\\n            }\\n        }\\n\\t\\t// last index contains extra space so remove the space and return the string\\n        return ans.toString().substring(0,ans.length()-1);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    // Boolean Function to check if the number is valid\\n    public boolean isLong(String s){\\n        try{\\n           Long.parseLong(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        // Split the sentence by space to form an array\\n        String[] str = sentence.split(\" \");\\n        int n = str.length;\\n        StringBuilder ans = new StringBuilder();\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++){\\n\\t\\t// if first character is not $ add it to ans\\n            if(str[i].charAt(0) != \\'$\\'){\\n                ans.append(str[i]+\" \");\\n                continue;\\n            }\\n\\t\\t\\t// else take the substring from first index so that only numeric part is taken\\n            String s = str[i].substring(1,str[i].length());\\n\\t\\t\\t\\n            // and add the $ sign to ans\\n            ans.append(\"$\");\\n\\t\\t\\t\\n\\t\\t\\t// check if the substring is valid number if valid calculate value and append else append without performing any operations\\n            if(isLong(s)){\\n                long num = Long.parseLong(s);\\n                double res = (double) num - ((double)num * (double)discount)/100.00;\\n\\t\\t\\t\\t// format decimal to 2 places\\n                DecimalFormat df = new DecimalFormat(\"0.00\");\\n                ans.append(df.format(res)+\" \");\\n            }\\n            else{\\n                ans.append(s+\" \");\\n            }\\n        }\\n\\t\\t// last index contains extra space so remove the space and return the string\\n        return ans.toString().substring(0,ans.length()-1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2143677,
                "title": "python-solution-83-faster",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        con = sentence.split(\\' \\')\\n        \\n        lst = []\\n        for i in range(len(con)):\\n            if con[i].count(\\'$\\') == 1 and con[i][0] == \\'$\\' and con[i][1:].isdigit():\\n                \\n                f = int(con[i][1:]) - (int(con[i][1:]) * (discount/100))\\n                f = format(f , \\'.2f\\')\\n                con[i] = \\'$\\' + str(f)\\n   \\n        return \\' \\'.join(con)\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        con = sentence.split(\\' \\')\\n        \\n        lst = []\\n        for i in range(len(con)):\\n            if con[i].count(\\'$\\') == 1 and con[i][0] == \\'$\\' and con[i][1:].isdigit():\\n                \\n                f = int(con[i][1:]) - (int(con[i][1:]) * (discount/100))\\n                f = format(f , \\'.2f\\')\\n                con[i] = \\'$\\' + str(f)\\n   \\n        return \\' \\'.join(con)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125292,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\t\\t// Convert given string to stringstream\\n        stringstream ss(sentence);\\n        string word;\\n        vector<int> words;\\n        string ans = \"\";\\n        while (ss >> word) {\\n\\t\\t\\t// Check if the extracted word is a price\\n            if (word[0] == \\'$\\' && word.length() > 1) {\\n                unsigned long long int price = 0;\\n                bool flag = true;\\n                for (int i = 1; i < word.length(); ++i) {\\n\\t\\t\\t\\t   // If the character is not a number break and just add the word to the answer\\n                    if (word[i] < \\'0\\' || word[i] > \\'9\\') {\\n                        flag = false;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// Convert the string to integer price\\n                    price = price * 10 + (word[i] - \\'0\\');\\n                }\\n                if (!flag) {\\n                    ans += \" \" + word;\\n                    \\n                } else {\\n\\t\\t\\t\\t\\t// Calculate the discount, double is used for more precision - float will not work\\n                    double dis = (double)((double)(discount) / 100) * (double)price;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) price - dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans += \" $\" + out.str();\\n                }\\n            } else {\\n\\t\\t\\t\\t// If not a price, just add the word to the answer\\n                ans += \" \" + word;\\n            }\\n        }\\n\\t\\t// Remove the first character (as it\\'s a space)\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```\\nPlease feel free to make suggestions for improvements in this solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\t\\t// Convert given string to stringstream\\n        stringstream ss(sentence);\\n        string word;\\n        vector<int> words;\\n        string ans = \"\";\\n        while (ss >> word) {\\n\\t\\t\\t// Check if the extracted word is a price\\n            if (word[0] == \\'$\\' && word.length() > 1) {\\n                unsigned long long int price = 0;\\n                bool flag = true;\\n                for (int i = 1; i < word.length(); ++i) {\\n\\t\\t\\t\\t   // If the character is not a number break and just add the word to the answer\\n                    if (word[i] < \\'0\\' || word[i] > \\'9\\') {\\n                        flag = false;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// Convert the string to integer price\\n                    price = price * 10 + (word[i] - \\'0\\');\\n                }\\n                if (!flag) {\\n                    ans += \" \" + word;\\n                    \\n                } else {\\n\\t\\t\\t\\t\\t// Calculate the discount, double is used for more precision - float will not work\\n                    double dis = (double)((double)(discount) / 100) * (double)price;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) price - dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans += \" $\" + out.str();\\n                }\\n            } else {\\n\\t\\t\\t\\t// If not a price, just add the word to the answer\\n                ans += \" \" + word;\\n            }\\n        }\\n\\t\\t// Remove the first character (as it\\'s a space)\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123971,
                "title": "elegant-and-clean",
                "content": "```cpp\\nclass Solution {\\n public:\\n  string discountPrices(string sentence, int discount) {\\n    constexpr int kPrecision = 2;\\n    string ans;\\n    istringstream iss(sentence);\\n\\n    for (string token; iss >> token;)\\n      if (token[0] == \\'$\\' && token.length() > 1) {\\n        const auto digits = token.substr(1);\\n        if (all_of(begin(digits), end(digits),\\n                   [](const char digit) { return isdigit(digit); })) {\\n          const auto val = stold(digits) * (100 - discount) / 100;\\n          const auto s = to_string(val);\\n          const auto trimmed = s.substr(0, s.find(\".\") + kPrecision + 1);\\n          ans += \"$\" + trimmed + \" \";\\n        } else {\\n          ans += token + \" \";\\n        }\\n      } else {\\n        ans += token + \" \";\\n      }\\n\\n    ans.pop_back();\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  string discountPrices(string sentence, int discount) {\\n    constexpr int kPrecision = 2;\\n    string ans;\\n    istringstream iss(sentence);\\n\\n    for (string token; iss >> token;)\\n      if (token[0] == \\'$\\' && token.length() > 1) {\\n        const auto digits = token.substr(1);\\n        if (all_of(begin(digits), end(digits),\\n                   [](const char digit) { return isdigit(digit); })) {\\n          const auto val = stold(digits) * (100 - discount) / 100;\\n          const auto s = to_string(val);\\n          const auto trimmed = s.substr(0, s.find(\".\") + kPrecision + 1);\\n          ans += \"$\" + trimmed + \" \";\\n        } else {\\n          ans += token + \" \";\\n        }\\n      } else {\\n        ans += token + \" \";\\n      }\\n\\n    ans.pop_back();\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114805,
                "title": "c-easy-solution-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        string ans;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n               ans+=sentence[i];\\n               if (sentence[i] == \\'$\\' && (i==0 || sentence[i-1] == \\' \\'))\\n                {\\n                    if(sentence[i+1]<48 || sentence[i+1]>57)//heewe already added$ then we go to add more in same string formate\\n                    { continue;}\\n                    string temp;\\n                    int start=i+1;\\n                    i++;\\n                    while(sentence[i]>=48 && sentence[i]<=57)//getting continuous numbers\\n                    {\\n                        temp+=sentence[i];\\n                        i++;\\n                    }\\n                    if(sentence[i]==\\' \\'||i>=sentence.length())//then last price value is valid\\n                    {\\n                        double after_discount = (double)atol(temp.c_str());\\n                        std::stringstream buffer;\\n                        buffer << setiosflags(ios::fixed) <<setprecision(2)<<(after_discount * ((100-discount)/100.0));\\n                        ans.append(buffer.str());\\n                        ans+=\" \";\\n                    }\\n                    else//invalid value so no need to do any convertion\\n                    {\\n                            for(int j=start;j<i+1;j++)\\n                            {\\n                                ans+=sentence[j];\\n                            }\\n                    }\\n                }\\n        }\\n        if(ans[ans.length()-1]==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        string ans;\\n        for(int i=0;i<sentence.length();i++)\\n        {\\n               ans+=sentence[i];\\n               if (sentence[i] == \\'$\\' && (i==0 || sentence[i-1] == \\' \\'))\\n                {\\n                    if(sentence[i+1]<48 || sentence[i+1]>57)//heewe already added$ then we go to add more in same string formate\\n                    { continue;}\\n                    string temp;\\n                    int start=i+1;\\n                    i++;\\n                    while(sentence[i]>=48 && sentence[i]<=57)//getting continuous numbers\\n                    {\\n                        temp+=sentence[i];\\n                        i++;\\n                    }\\n                    if(sentence[i]==\\' \\'||i>=sentence.length())//then last price value is valid\\n                    {\\n                        double after_discount = (double)atol(temp.c_str());\\n                        std::stringstream buffer;\\n                        buffer << setiosflags(ios::fixed) <<setprecision(2)<<(after_discount * ((100-discount)/100.0));\\n                        ans.append(buffer.str());\\n                        ans+=\" \";\\n                    }\\n                    else//invalid value so no need to do any convertion\\n                    {\\n                            for(int j=start;j<i+1;j++)\\n                            {\\n                                ans+=sentence[j];\\n                            }\\n                    }\\n                }\\n        }\\n        if(ans[ans.length()-1]==\\' \\')\\n        {\\n            ans.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110834,
                "title": "python-easy",
                "content": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        calc_price = lambda cost, discount: cost * (discount / 100)\\n\\n        for i, w in enumerate(words):\\n            if w.startswith(\"$\"):\\n                price = w[1:]\\n                if price and \"$\" not in price and price.isdigit():\\n                    words[i] = f\\'${int(price) - calc_price(int(price), discount):.2f}\\'\\n\\n        return \" \".join(words)\\n```\\n**Time**: `O(n)`\\n**Space**: `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        calc_price = lambda cost, discount: cost * (discount / 100)\\n\\n        for i, w in enumerate(words):\\n            if w.startswith(\"$\"):\\n                price = w[1:]\\n                if price and \"$\" not in price and price.isdigit():\\n                    words[i] = f\\'${int(price) - calc_price(int(price), discount):.2f}\\'\\n\\n        return \" \".join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102668,
                "title": "python-try-except-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        def get_discount(word, discount):             \\n            if word[0]==\\'$\\':\\n                # we try convert word to integer num\\n                # if program catch ValueError then return word without any changing \\n                try:                     \\n                    num = int(word[1:])\\n                    num = num - num*discount*0.01\\n                except ValueError:\\n                    return word\\n                return \\'$\\'+\"{:.2f}\".format(num)\\n            return word\\n        \\n        #prepare the result variable         \\n        result = \\'\\'\\n        \\n        # look over splitted parts         \\n        for word in sentence.split(\\' \\'):\\n            word = get_discount(word, discount)\\n            \\n            # add to result word and space between next one            \\n            result += word+\\' \\'\\n        \\n        # return the result except for the last space        \\n        return result[:-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        def get_discount(word, discount):             \\n            if word[0]==\\'$\\':\\n                # we try convert word to integer num\\n                # if program catch ValueError then return word without any changing \\n                try:                     \\n                    num = int(word[1:])\\n                    num = num - num*discount*0.01\\n                except ValueError:\\n                    return word\\n                return \\'$\\'+\"{:.2f}\".format(num)\\n            return word\\n        \\n        #prepare the result variable         \\n        result = \\'\\'\\n        \\n        # look over splitted parts         \\n        for word in sentence.split(\\' \\'):\\n            word = get_discount(word, discount)\\n            \\n            # add to result word and space between next one            \\n            result += word+\\' \\'\\n        \\n        # return the result except for the last space        \\n        return result[:-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101646,
                "title": "c-best-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            bool rg = true;\\n            if((i==0 && s[i]==\\'$\\') || (i>0 && s[i-1]==\\' \\' && s[i]==\\'$\\')){\\n                ans += s[i];\\n                int ind = i+1;\\n                string temp = \"\";\\n                while(s[ind]!=\\' \\' && ind<s.size()){\\n                    if(s[ind]-\\'0\\'<0 || s[ind]-\\'0\\'>9){\\n                        //temp += s[ind];\\n                        rg = false;\\n                        break;\\n                    }\\n                    temp += s[ind];\\n                    ind++;\\n                }\\n                if(rg && temp!=\"\"){\\n                    long long val = stoll(temp);\\n                    val = (val*(100-d));\\n                    int a1 = val%10;\\n                    val/=10;\\n                    int a2 = val%10;\\n                    val/=10;\\n                    string rep = to_string(val);\\n                    cout<<rep<<endl;\\n                    for(int k = 0;k<rep.size();k++){\\n                        ans += rep[k];\\n                    }\\n                        ans += \\'.\\';\\n                        ans += char(a2+\\'0\\');\\n                        ans += char(a1+\\'0\\');\\n                        if(ind<s.size()-1){\\n                        ans += \" \";\\n                        }\\n                        i = ind;\\n                    }\\n                }\\n                \\n                else{\\n                 ans += s[i];\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            bool rg = true;\\n            if((i==0 && s[i]==\\'$\\') || (i>0 && s[i-1]==\\' \\' && s[i]==\\'$\\')){\\n                ans += s[i];\\n                int ind = i+1;\\n                string temp = \"\";\\n                while(s[ind]!=\\' \\' && ind<s.size()){\\n                    if(s[ind]-\\'0\\'<0 || s[ind]-\\'0\\'>9){\\n                        //temp += s[ind];\\n                        rg = false;\\n                        break;\\n                    }\\n                    temp += s[ind];\\n                    ind++;\\n                }\\n                if(rg && temp!=\"\"){\\n                    long long val = stoll(temp);\\n                    val = (val*(100-d));\\n                    int a1 = val%10;\\n                    val/=10;\\n                    int a2 = val%10;\\n                    val/=10;\\n                    string rep = to_string(val);\\n                    cout<<rep<<endl;\\n                    for(int k = 0;k<rep.size();k++){\\n                        ans += rep[k];\\n                    }\\n                        ans += \\'.\\';\\n                        ans += char(a2+\\'0\\');\\n                        ans += char(a1+\\'0\\');\\n                        if(ind<s.size()-1){\\n                        ans += \" \";\\n                        }\\n                        i = ind;\\n                    }\\n                }\\n                \\n                else{\\n                 ans += s[i];\\n                }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2092402,
                "title": "kotlin-sequence-regex",
                "content": "```\\nfun discountPrices(sentence: String, discount: Int): String {\\n        val regex = Regex(\"^\\\\\\\\$[0-9]{1,10}$\")\\n        val discountPercentage = (100.0 - discount)/100.0\\n\\n        return sentence.splitToSequence(\" \").joinToString(separator = \" \") { word ->\\n            regex.replace(word) {\\n                \"$\" + String.format(\"%.2f\", (it.value.trim().removePrefix(\"$\").toDouble() * discountPercentage))\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun discountPrices(sentence: String, discount: Int): String {\\n        val regex = Regex(\"^\\\\\\\\$[0-9]{1,10}$\")\\n        val discountPercentage = (100.0 - discount)/100.0\\n\\n        return sentence.splitToSequence(\" \").joinToString(separator = \" \") { word ->\\n            regex.replace(word) {\\n                \"$\" + String.format(\"%.2f\", (it.value.trim().removePrefix(\"$\").toDouble() * discountPercentage))\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089433,
                "title": "c-strings",
                "content": "class Solution {\\npublic:\\n\\n    string discountPrices(string s, int discount) {\\n      \\n            int n =s.length();\\n         discount=(100-discount);\\n        vector<string>v;\\n        string p=\"\";\\n        for(int i=0;i<s.length();++i)\\n        { \\n           if(s[i]==\\' \\')\\n           {\\n               v.push_back(p);\\n               p=\"\";\\n               continue;\\n           }\\n           \\n            p+=s[i];\\n            \\n        }\\n        v.push_back(p);\\n        for(int i=0;i<v.size();++i)\\n        {\\n            string p=v[i];\\n            if(p[0]==\\'$\\')\\n            {long long  t=0;\\n             \\n             int flag=0;\\n             bool can=true;\\n                for(int i=1;i<p.length();++i)\\n                { \\n                    if(p[i]==\\'$\\' || (p[i]>=\\'a\\' &&p[i]<=\\'z\\'))\\n                    {\\n                        can=false;\\n                        break;\\n                    }\\n                    flag=1;\\n                   t=t*10+p[i]-\\'0\\';\\n                }\\n             if(can==true &&flag==1)\\n             {\\n               \\n                long double dig=t*discount*0.01;\\n                 \\n                     string dd=to_string(dig);\\n                     string fi=\"$\";\\n                     int j=0;\\n                    while(dd[j]!=\\'.\\')\\n                    {\\n                        fi+=dd[j++];\\n                    }\\n                     fi+=dd[j];\\n                     fi+=dd[j+1];\\n                     fi+=dd[j+2];\\n                     v[i]=fi;\\n                 \\n             }\\n                \\n            }\\n        }\\n        string ans=\"\";\\n            for(int i=0;i<v.size();++i)\\n            {\\n                ans+=v[i];\\n                if(i!=v.size()-1)\\n                ans+=\\' \\';\\n            }\\nreturn ans;\\n    }\\n\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string discountPrices(string s, int discount) {\\n      \\n            int n =s.length();\\n         discount=(100-discount);\\n        vector<string>v;\\n        string p=\"\";\\n        for(int i=0;i<s.length();++i)\\n        { \\n           if(s[i]==\\' \\')\\n           {\\n               v.push_back(p);\\n               p=\"\";\\n               continue;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2089345,
                "title": "c-100-faster-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        int i=0;\\n        bool num=0;\\n        d=100-d;//converting it to subtracter to direct multiplier\\n        long long t;\\n        string ans;\\n        while(i<s.size())\\n        {\\n            num=0;\\n            t=0;\\n            string tmp;\\n            if(s[i]==\\'$\\')//that means dollar;\\n            {\\n                num=1;\\n                tmp.push_back(s[i++]);\\n            }\\n                while(i<s.size()&&s[i]!=\\' \\')\\n            {\\n                if(s[i]<\\'0\\'||s[i]>\\'9\\')//not a number\\n                   num=0;\\n                    if(num)\\n                        t*=10,t+=(s[i]-\\'0\\');\\n                tmp.push_back(s[i++]);\\n                   \\n            }\\n            \\n            if(num&&(tmp.size()>1))//checking base case \"$\"\\n            {\\n                \\n                t*=d;\\n               tmp=\"$\"+to_string(t/100)+\".\"+(t%100<=9?\"0\":\"\")+to_string(t%100);\\n            }\\n            tmp.push_back(\\' \\');\\n            ans+=tmp;\\n            i++;\\n        }\\n        ans.pop_back();//removing extra space\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        int i=0;\\n        bool num=0;\\n        d=100-d;//converting it to subtracter to direct multiplier\\n        long long t;\\n        string ans;\\n        while(i<s.size())\\n        {\\n            num=0;\\n            t=0;\\n            string tmp;\\n            if(s[i]==\\'$\\')//that means dollar;\\n            {\\n                num=1;\\n                tmp.push_back(s[i++]);\\n            }\\n                while(i<s.size()&&s[i]!=\\' \\')\\n            {\\n                if(s[i]<\\'0\\'||s[i]>\\'9\\')//not a number\\n                   num=0;\\n                    if(num)\\n                        t*=10,t+=(s[i]-\\'0\\');\\n                tmp.push_back(s[i++]);\\n                   \\n            }\\n            \\n            if(num&&(tmp.size()>1))//checking base case \"$\"\\n            {\\n                \\n                t*=d;\\n               tmp=\"$\"+to_string(t/100)+\".\"+(t%100<=9?\"0\":\"\")+to_string(t%100);\\n            }\\n            tmp.push_back(\\' \\');\\n            ans+=tmp;\\n            i++;\\n        }\\n        ans.pop_back();//removing extra space\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087950,
                "title": "rust-solution",
                "content": "Well that\\'s why i hate cpp.\\n\\n```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut res = sentence.split(\\' \\').fold(String::from(\"\"), |acc, s| format!(\"{}{} \", acc,\\n            if s.chars().next() == Some(\\'$\\') {\\n                if let Ok(price) = &s[1..].parse::<f64>() {\\n                    format!(\"${:.2}\", price * (1.0 - (discount as f64) / 100.0))\\n                } else {\\n                    s.to_string()\\n                }\\n            } else {\\n                s.to_string()\\n            }\\n        ));\\n        \\n        res.pop();\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut res = sentence.split(\\' \\').fold(String::from(\"\"), |acc, s| format!(\"{}{} \", acc,\\n            if s.chars().next() == Some(\\'$\\') {\\n                if let Ok(price) = &s[1..].parse::<f64>() {\\n                    format!(\"${:.2}\", price * (1.0 - (discount as f64) / 100.0))\\n                } else {\\n                    s.to_string()\\n                }\\n            } else {\\n                s.to_string()\\n            }\\n        ));\\n        \\n        res.pop();\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087820,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splits = sentence.split(\\' \\')\\n\\n        for idx, split in enumerate(splits):\\n            if split.startswith(\\'$\\') and len(split) != 1:\\n                if self.check_valid_price(split):\\n                    price_with_discount = float(split[1:]) * (1.0 - discount / 100)\\n                    price_with_discount = str(round(price_with_discount, 2))\\n                    \\n                    # padding\\n                    decimal_place = price_with_discount.split(\\'.\\')[1]\\n                    price_with_discount += \\'0\\' * (2 - len(decimal_place))\\n                    splits[idx] = str(\\'$\\') + price_with_discount\\n        \\n        return \\' \\'.join(splits)\\n    \\n    def check_valid_price(self, split):\\n        WHITE_LIST = {\\'$\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n        count_of_sign = 0\\n        for char in split:\\n            if char not in WHITE_LIST or count_of_sign > 1:\\n                return False\\n            count_of_sign += 1 if char == \\'$\\' else 0\\n        return not (count_of_sign > 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splits = sentence.split(\\' \\')\\n\\n        for idx, split in enumerate(splits):\\n            if split.startswith(\\'$\\') and len(split) != 1:\\n                if self.check_valid_price(split):\\n                    price_with_discount = float(split[1:]) * (1.0 - discount / 100)\\n                    price_with_discount = str(round(price_with_discount, 2))\\n                    \\n                    # padding\\n                    decimal_place = price_with_discount.split(\\'.\\')[1]\\n                    price_with_discount += \\'0\\' * (2 - len(decimal_place))\\n                    splits[idx] = str(\\'$\\') + price_with_discount\\n        \\n        return \\' \\'.join(splits)\\n    \\n    def check_valid_price(self, split):\\n        WHITE_LIST = {\\'$\\', \\'0\\', \\'1\\', \\'2\\', \\'3\\', \\'4\\', \\'5\\', \\'6\\', \\'7\\', \\'8\\', \\'9\\'}\\n        count_of_sign = 0\\n        for char in split:\\n            if char not in WHITE_LIST or count_of_sign > 1:\\n                return False\\n            count_of_sign += 1 if char == \\'$\\' else 0\\n        return not (count_of_sign > 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087273,
                "title": "c-regex",
                "content": "This problem can be solved with a help of easy to write *regular expression*:\\n\\n```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        return Regex.Replace(sentence, @\"((?<=\\\\s)|^)\\\\$(?<money>[0-9]+(\\\\.[0-9]+)?)((?=\\\\s)|$)\", m => {\\n            double price = double.Parse(m.Groups[\"money\"].Value);\\n            \\n            return $\"${price - price * discount / 100.0:f2}\";\\n        });\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Text.RegularExpressions;\\n\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        return Regex.Replace(sentence, @\"((?<=\\\\s)|^)\\\\$(?<money>[0-9]+(\\\\.[0-9]+)?)((?=\\\\s)|$)\", m => {\\n            double price = double.Parse(m.Groups[\"money\"].Value);\\n            \\n            return $\"${price - price * discount / 100.0:f2}\";\\n        });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086859,
                "title": "c-beginner-friendly-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n   // check functions checks whether the string is price string\\n    static bool check(string &s){\\n        if(s.length()<2 || s[0]!=\\'$\\') return false;\\n        for(int i=1;i<s.length();i++){\\n            if(!isdigit(s[i])) return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t\\n\\t//this func converts the string into desirable format\\n    static string solve(long double num){\\n        string s1 = to_string(num) , s2;\\n        int i , l=s1.length()-1;\\n        i=l;\\n        while(s1[i]!=\\'.\\') i--;\\n        s2 = \"$\"+s1.substr(0,i+3)+\" \";\\n        return s2;\\n    }\\n\\t\\n    string discountPrices(string s, int d) {\\n        int n = s.length() , i=0;\\n        d = 100-d;\\n        string ans;\\n        while(i<n){\\n            string temp;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') temp+=s[j++];\\n            if(check(temp)){\\n                long double t1 = 0;\\n                for(int j=1 ; j<temp.length() ; j++) t1 = (t1*10) + (temp[j]-\\'0\\');\\n                t1= (t1*d)/100.00;\\n                string s1 = solve(t1);\\n                ans+=s1;\\n            }else{\\n                temp+=\" \";\\n                ans+=temp;\\n            }\\n            i=j+1;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```\\nIn case if you like the approach , kindly hit the upvote :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // check functions checks whether the string is price string\\n    static bool check(string &s){\\n        if(s.length()<2 || s[0]!=\\'$\\') return false;\\n        for(int i=1;i<s.length();i++){\\n            if(!isdigit(s[i])) return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t\\n\\t//this func converts the string into desirable format\\n    static string solve(long double num){\\n        string s1 = to_string(num) , s2;\\n        int i , l=s1.length()-1;\\n        i=l;\\n        while(s1[i]!=\\'.\\') i--;\\n        s2 = \"$\"+s1.substr(0,i+3)+\" \";\\n        return s2;\\n    }\\n\\t\\n    string discountPrices(string s, int d) {\\n        int n = s.length() , i=0;\\n        d = 100-d;\\n        string ans;\\n        while(i<n){\\n            string temp;\\n            int j=i;\\n            while(j<n && s[j]!=\\' \\') temp+=s[j++];\\n            if(check(temp)){\\n                long double t1 = 0;\\n                for(int j=1 ; j<temp.length() ; j++) t1 = (t1*10) + (temp[j]-\\'0\\');\\n                t1= (t1*d)/100.00;\\n                string s1 = solve(t1);\\n                ans+=s1;\\n            }else{\\n                temp+=\" \";\\n                ans+=temp;\\n            }\\n            i=j+1;\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086619,
                "title": "easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        \\n        int n = sentence.size();\\n        \\n        int i = 0;\\n        \\n\\t\\t// store the words in res\\n\\t\\t\\n        vector<string> res;\\n        \\n        while(i < n)\\n        {\\n            string word = \"\";\\n            \\n            while(i < n && sentence[i] != \\' \\')\\n            {\\n                word += sentence[i];\\n                \\n                i++;\\n            }\\n            \\n            res.push_back(word);\\n            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// find the amount and replace after discount\\n        \\n        long double mult = (long double) (discount) / 100;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            string word = res[i];\\n            \\n            bool flag = true;\\n            \\n            if(word.size() == 1)\\n            {\\n                flag = false;\\n            }\\n            \\n            if(word[0] != \\'$\\')\\n            {\\n                flag = false;\\n            }\\n            \\n            for(int j = 1; j < word.size(); j++)\\n            {\\n                if(isalpha(word[j]) || word[j] == \\'$\\')\\n                {\\n                    flag = false;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            if(flag == false)\\n            {\\n                res[i] = word;\\n            }\\n            else\\n            {\\n                long long num = 0;\\n                \\n                for(int k = 1; k < word.size(); k++)\\n                {\\n                    num = (long long) num * 10 + word[k] - \\'0\\';\\n                }\\n                \\n                long double replace = num - (long double) (num) * (long double) mult;\\n                \\n                string temp = \"\";\\n                \\n                temp += \\'$\\';\\n                \\n                temp += to_string(replace);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// fixed upto two decimal place\\n                \\n                string x = \"\";\\n                \\n                int l = 0;\\n                \\n                while(l < temp.size() && temp[l] != \\'.\\')\\n                {\\n                    x += temp[l];\\n                    \\n                    l++;\\n                }\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                res[i] = x;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// make ans string\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            ans += res[i];\\n            \\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string discountPrices(string sentence, int discount) {\\n        \\n        int n = sentence.size();\\n        \\n        int i = 0;\\n        \\n\\t\\t// store the words in res\\n\\t\\t\\n        vector<string> res;\\n        \\n        while(i < n)\\n        {\\n            string word = \"\";\\n            \\n            while(i < n && sentence[i] != \\' \\')\\n            {\\n                word += sentence[i];\\n                \\n                i++;\\n            }\\n            \\n            res.push_back(word);\\n            \\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// find the amount and replace after discount\\n        \\n        long double mult = (long double) (discount) / 100;\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            string word = res[i];\\n            \\n            bool flag = true;\\n            \\n            if(word.size() == 1)\\n            {\\n                flag = false;\\n            }\\n            \\n            if(word[0] != \\'$\\')\\n            {\\n                flag = false;\\n            }\\n            \\n            for(int j = 1; j < word.size(); j++)\\n            {\\n                if(isalpha(word[j]) || word[j] == \\'$\\')\\n                {\\n                    flag = false;\\n                    \\n                    break;\\n                }\\n            }\\n            \\n            if(flag == false)\\n            {\\n                res[i] = word;\\n            }\\n            else\\n            {\\n                long long num = 0;\\n                \\n                for(int k = 1; k < word.size(); k++)\\n                {\\n                    num = (long long) num * 10 + word[k] - \\'0\\';\\n                }\\n                \\n                long double replace = num - (long double) (num) * (long double) mult;\\n                \\n                string temp = \"\";\\n                \\n                temp += \\'$\\';\\n                \\n                temp += to_string(replace);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// fixed upto two decimal place\\n                \\n                string x = \"\";\\n                \\n                int l = 0;\\n                \\n                while(l < temp.size() && temp[l] != \\'.\\')\\n                {\\n                    x += temp[l];\\n                    \\n                    l++;\\n                }\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                l++;\\n                \\n                x += temp[l];\\n                \\n                res[i] = x;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// make ans string\\n        \\n        string ans = \"\";\\n        \\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            ans += res[i];\\n            \\n            ans += \\' \\';\\n        }\\n        \\n        ans.pop_back();\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086459,
                "title": "c-solution-round-2-place-add-0-5",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int dis)\\n    {\\n        istringstream ss(s);\\n        string ans;\\n        vector<string>v;\\n        while(getline(ss,ans,\\' \\'))\\n        {\\n            v.push_back(ans);\\n        }\\n        for(auto &it:v)\\n        {\\n            int c=0;\\n            int d=0;\\n            for(int i=0;i<it.size();i++)\\n            {\\n                if(it[i]==\\'$\\')\\n                {\\n                    c++;\\n                }\\n                if(it[i]>=\\'0\\'&&it[i]<=\\'9\\')\\n                {\\n                    d++;\\n                }\\n            }\\n            if(it[0]==\\'$\\'&&c==1&&d==it.size()-1)\\n            {\\n                if(it.size()==1)\\n                {\\n                    continue;\\n                }\\n                long long val=0;\\n                val=stoll(it.substr(1));\\n                double vt=((val*(100-dis)*1.0+0.5)/(100.000));\\n                string curr=to_string(vt);\\n                int index=curr.find(\\'.\\'); \\n                it=\\'$\\'+curr.substr(0,index+1)+curr.substr(index+1,2);\\n            }\\n        }\\n        string res;\\n        for(auto &it:v)\\n        {\\n            res+=it+\" \";\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int dis)\\n    {\\n        istringstream ss(s);\\n        string ans;\\n        vector<string>v;\\n        while(getline(ss,ans,\\' \\'))\\n        {\\n            v.push_back(ans);\\n        }\\n        for(auto &it:v)\\n        {\\n            int c=0;\\n            int d=0;\\n            for(int i=0;i<it.size();i++)\\n            {\\n                if(it[i]==\\'$\\')\\n                {\\n                    c++;\\n                }\\n                if(it[i]>=\\'0\\'&&it[i]<=\\'9\\')\\n                {\\n                    d++;\\n                }\\n            }\\n            if(it[0]==\\'$\\'&&c==1&&d==it.size()-1)\\n            {\\n                if(it.size()==1)\\n                {\\n                    continue;\\n                }\\n                long long val=0;\\n                val=stoll(it.substr(1));\\n                double vt=((val*(100-dis)*1.0+0.5)/(100.000));\\n                string curr=to_string(vt);\\n                int index=curr.find(\\'.\\'); \\n                it=\\'$\\'+curr.substr(0,index+1)+curr.substr(index+1,2);\\n            }\\n        }\\n        string res;\\n        for(auto &it:v)\\n        {\\n            res+=it+\" \";\\n        }\\n        res.pop_back();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086453,
                "title": "javascript-solution",
                "content": "JavaScript solution\\nSimulating the question\\nO(N) TC\\nO(1) SC\\n```\\nvar discountPrices = function(sentence, discount) {\\n    let isNum = (num) => {\\n        if(num.length <= 1 || num[0] != \\'$\\') return false;\\n        for(let i = 1; i < num.length; ++i)\\n            if(!(num[i] >= \\'0\\' && num[i] <= \\'9\\'))\\n                return false;\\n        return true;\\n    };\\n    let x = sentence.split(\\' \\');\\n    discount = 1 - (discount/100);\\n    for(let i = 0; i < x.length; ++i) \\n        !isNum(x[i]) || (x[i] = `$${(Number(x[i].slice(1))*discount).toFixed(2)}`);\\n    return x.join(\\' \\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n    let isNum = (num) => {\\n        if(num.length <= 1 || num[0] != \\'$\\') return false;\\n        for(let i = 1; i < num.length; ++i)\\n            if(!(num[i] >= \\'0\\' && num[i] <= \\'9\\'))\\n                return false;\\n        return true;\\n    };\\n    let x = sentence.split(\\' \\');\\n    discount = 1 - (discount/100);\\n    for(let i = 0; i < x.length; ++i) \\n        !isNum(x[i]) || (x[i] = `$${(Number(x[i].slice(1))*discount).toFixed(2)}`);\\n    return x.join(\\' \\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086357,
                "title": "python-solution",
                "content": "```\\ndef discountPrices(self, sentence: str, discount: int) -> str:\\n        sen_lst = sentence.split()\\n        leng = len(sen_lst)\\n        \\n        for i in range(leng):\\n            char = sen_lst[i]\\n            if char[0] == \\'$\\' and char[-1].isdigit():\\n                num = char[1:]\\n                \\n\\t\\t\\t\\t# checking if num is completely numeric or not (\\'$\\'  might be appended in between the string)\\n                if (num.isnumeric()):\\n                    if discount == 100:\\n                        new_char = \\'$0.00\\'\\n                    else:\\n                        disc = (int(num) * discount) / 100\\n                        disc_price = int(num) - disc\\n                        new_char = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                    sen_lst[i] = new_char\\n                \\n        return \\' \\'.join(sen_lst)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef discountPrices(self, sentence: str, discount: int) -> str:\\n        sen_lst = sentence.split()\\n        leng = len(sen_lst)\\n        \\n        for i in range(leng):\\n            char = sen_lst[i]\\n            if char[0] == \\'$\\' and char[-1].isdigit():\\n                num = char[1:]\\n                \\n\\t\\t\\t\\t# checking if num is completely numeric or not (\\'$\\'  might be appended in between the string)\\n                if (num.isnumeric()):\\n                    if discount == 100:\\n                        new_char = \\'$0.00\\'\\n                    else:\\n                        disc = (int(num) * discount) / 100\\n                        disc_price = int(num) - disc\\n                        new_char = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                    sen_lst[i] = new_char\\n                \\n        return \\' \\'.join(sen_lst)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085978,
                "title": "javascript-easy-solution",
                "content": "Firstly here, the sentence array is split. Thereafter if there is a valid price i.e. $followed by a number, then the discount is applied.\\n```\\nvar discountPrices = function(sentence, discount) {\\n    var t = sentence.split(\" \");\\n    var x=[];\\n    var d = discount/100;\\n    for(var i=0;i<t.length;i++){\\n        //here it is checked whether $is followed by only numbers\\n        if(t[i].replace(/[^$]/g, \"\").length===1 && t[i][0]===\"$\" && t[i].length>1){\\n            var y=t[i].substring(1);\\n            var g = parseFloat(y-(y*d)).toFixed(2);\\n            console.log(parseFloat(y).toFixed(2));\\n            console.log(g)\\n            if(isNaN(g))\\n                x.push(t[i]);\\n            else\\n               x.push(\"$\"+g);\\n        }\\n        else \\n            x.push(t[i]);\\n    }\\n    return x.join(\" \");\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Firstly here, the sentence array is split. Thereafter if there is a valid price i.e. $followed by a number, then the discount is applied.\\n```\\nvar discountPrices = function(sentence, discount) {\\n    var t = sentence.split(\" \");\\n    var x=[];\\n    var d = discount/100;\\n    for(var i=0;i<t.length;i++){\\n        //here it is checked whether $is followed by only numbers\\n        if(t[i].replace(/[^$]/g, \"\").length===1 && t[i][0]===\"$\" && t[i].length>1){\\n            var y=t[i].substring(1);\\n            var g = parseFloat(y-(y*d)).toFixed(2);\\n            console.log(parseFloat(y).toFixed(2));\\n            console.log(g)\\n            if(isNaN(g))\\n                x.push(t[i]);\\n            else\\n               x.push(\"$\"+g);\\n        }\\n        else \\n            x.push(t[i]);\\n    }\\n    return x.join(\" \");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2085942,
                "title": "javascript-direct-way-230ms",
                "content": "Main idea: split string by space, and find valid price string transform it, otherwise keep it\\n```\\nconst discountPrices = (ss, discount) => {\\n    let a = ss.split(\" \"), n = a.length, res = Array(n).fill(\"\");\\n    for (let i = 0; i < n; i++) {\\n        let s = a[i];\\n        if (valid(s)) { // valid price string transform it\\n            let x = s.slice(1) - \\'0\\';\\n            x *= (1 - discount / 100);\\n            x = x.toFixed(2);\\n            res[i] = \\'$\\' + x;\\n        } else { // keep\\n            res[i] = s;\\n        }\\n    }\\n    return res.join(\" \");\\n};\\n\\nconst ok = (c) => \\'.0123456789\\'.indexOf(c) != -1;\\nconst valid = (s) => { // check if price is a valid string\\n    if (s.length == 1) return false; // should be at least length >= 2        \\'$\\' is invalid\\n    if (s[0] != \\'$\\') return false; // first char should be dollar sign\\n    for (let i = 1; i < s.length; i++) { // after dollar sign, can only have digits and dot\\n        if (!ok(s[i])) return false; \\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst discountPrices = (ss, discount) => {\\n    let a = ss.split(\" \"), n = a.length, res = Array(n).fill(\"\");\\n    for (let i = 0; i < n; i++) {\\n        let s = a[i];\\n        if (valid(s)) { // valid price string transform it\\n            let x = s.slice(1) - \\'0\\';\\n            x *= (1 - discount / 100);\\n            x = x.toFixed(2);\\n            res[i] = \\'$\\' + x;\\n        } else { // keep\\n            res[i] = s;\\n        }\\n    }\\n    return res.join(\" \");\\n};\\n\\nconst ok = (c) => \\'.0123456789\\'.indexOf(c) != -1;\\nconst valid = (s) => { // check if price is a valid string\\n    if (s.length == 1) return false; // should be at least length >= 2        \\'$\\' is invalid\\n    if (s[0] != \\'$\\') return false; // first char should be dollar sign\\n    for (let i = 1; i < s.length; i++) { // after dollar sign, can only have digits and dot\\n        if (!ok(s[i])) return false; \\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085906,
                "title": "rust-simple-solution",
                "content": "> Updated Solution using the `write!` macro instead of `format!`\\n```rust\\nuse std::fmt::Write as FmtWrite;\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if (&word[1..]).chars().all(|c|{c >= \\'0\\' && c<= \\'9\\'}){\\n                        if let Ok(num) = &word[1..].parse::<f64>(){\\n                            let n = num  * ((100 - discount) as f64 / 100_f64);\\n\\n                            write!(&mut new_str, \"${:.2}\", n);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```\\n\\nFirst attempt - `@depracated`\\ndue to an added testcase : \\n\\n`$1e9`\\n`50`\\n\\n\\n\\n```rust\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if let Ok(num) = &word[1..].parse::<f64>(){\\n                        let n = num  * ((100 - discount) as f64 / 100_f64);\\n                        \\n                        new_str.push_str(&format!(\"${:.2}\", n));\\n                        continue;\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::fmt::Write as FmtWrite;\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if (&word[1..]).chars().all(|c|{c >= \\'0\\' && c<= \\'9\\'}){\\n                        if let Ok(num) = &word[1..].parse::<f64>(){\\n                            let n = num  * ((100 - discount) as f64 / 100_f64);\\n\\n                            write!(&mut new_str, \"${:.2}\", n);\\n                            continue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let mut new_str = String::new();\\n        \\n        for (i, word) in sentence.split_whitespace().enumerate(){\\n            if i != 0{\\n                new_str.push(\\' \\');\\n            } \\n            if word.len()> 0{\\n                if word.as_bytes()[0] == b\\'$\\'{\\n                    if let Ok(num) = &word[1..].parse::<f64>(){\\n                        let n = num  * ((100 - discount) as f64 / 100_f64);\\n                        \\n                        new_str.push_str(&format!(\"${:.2}\", n));\\n                        continue;\\n                    }\\n                }\\n            }\\n\\n            new_str.push_str(word);\\n        }\\n        \\n        new_str\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085796,
                "title": "python-short",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splited_sent = sentence.split()\\n        discount = 1 - (discount / 100)\\n        for i in range(len(splited_sent)):\\n            price_str = splited_sent[i]\\n            if price_str[0] == \\'$\\' and price_str[1:].isdigit():\\n                price = int(price_str[1:]) * discount\\n                splited_sent[i] = \\'$\\' + f\\'{price:.2f}\\'\\n        return \\' \\'.join(splited_sent)\\n```\\nFron Yilin Bei",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        splited_sent = sentence.split()\\n        discount = 1 - (discount / 100)\\n        for i in range(len(splited_sent)):\\n            price_str = splited_sent[i]\\n            if price_str[0] == \\'$\\' and price_str[1:].isdigit():\\n                price = int(price_str[1:]) * discount\\n                splited_sent[i] = \\'$\\' + f\\'{price:.2f}\\'\\n        return \\' \\'.join(splited_sent)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085779,
                "title": "easy-python-solution",
                "content": "```\\ndef discountPrices(self, s: str, d: int) -> str:\\n\\tarr = s.split()\\n\\tfor i, num in enumerate(arr):\\n\\t\\tif num[0] == \\'$\\' and num[1:].isnumeric():\\n\\t\\t\\tarr[i] = \\'$\\' + \"{:.2f}\".format(float(num[1:]) * (1 - d/100.0))\\n\\treturn \\' \\'.join(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef discountPrices(self, s: str, d: int) -> str:\\n\\tarr = s.split()\\n\\tfor i, num in enumerate(arr):\\n\\t\\tif num[0] == \\'$\\' and num[1:].isnumeric():\\n\\t\\t\\tarr[i] = \\'$\\' + \"{:.2f}\".format(float(num[1:]) * (1 - d/100.0))\\n\\treturn \\' \\'.join(arr)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2085777,
                "title": "java-inbuild-functions-trash-question",
                "content": "```\\nimport java.math.RoundingMode;\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sen, int disc) {\\n        String[] a = sen.split(\" \");\\n        String answer = \"\";\\n        for (String s : a) {\\n            if (isPrice(s) && s.length() >= 2) {\\n                double price = Double.parseDouble(s.substring(1));\\n                double conv = price * (1.0 - (disc * 1.0) / 100.0);\\n                answer = answer + \"$\" + df.format(conv) + \" \";\\n            } else {\\n                answer = answer + s + \" \";\\n            }\\n        }\\n        return answer.substring(0, answer.length() - 1);\\n    }\\n    \\n    public boolean isPrice(String s) {\\n        if (s.charAt(0) !=  \\'$\\') {\\n            return false;\\n        }\\n        int decimal = 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) >= \\'0\\' && s.charAt(i) <= \\'9\\') {\\n                continue;\\n            } else if (s.charAt(i) == \\'.\\') {\\n                decimal++;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return decimal <= 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sen, int disc) {\\n        String[] a = sen.split(\" \");\\n        String answer = \"\";\\n        for (String s : a) {\\n            if (isPrice(s) && s.length() >= 2) {\\n                double price = Double.parseDouble(s.substring(1));\\n                double conv = price * (1.0 - (disc * 1.0) / 100.0);\\n                answer = answer + \"$\" + df.format(conv) + \" \";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2085766,
                "title": "simple-c-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string seq, int dis) {\\n        stringstream str(seq); int spaces  = 0;for(auto ch:seq) if(ch==\\' \\') spaces++; long double mult = (long double)dis/100;\\n        string chunk ;  int n = seq.size(); vector<string> v;\\n        for(int i = 0;i<spaces+1;i++){\\n            getline(str, chunk, \\' \\');\\n            v.push_back(chunk);      \\n        }\\n        \\n        for(auto &chunk:v){\\n            if(chunk[0]!=\\'$\\') continue; if(chunk.size()==1) continue;\\n            bool f = 0;\\n            for(int i = 1;i<chunk.size();i++) if(chunk[i]<=\\'9\\' and chunk[i]>=\\'0\\') continue; else{ f = 1; break;}\\n            if(f==1) continue;\\n            int len = chunk.size();\\n            string s = chunk.substr(1);\\n            long long inti =  stoll(s); long double  stl = inti -  mult*(inti); \\n            string now = to_string (stl);\\n            int ind = -1;\\n            for(int i = 0;i<now.size();i++) if(now[i]==\\'.\\') ind = i;\\n            chunk = \"$\" + now.substr(0,ind+3);\\n        }\\n        string ans=\"\";\\n        for(auto &w:v) ans+=w + \" \";\\n\\n        ans.erase(ans.begin()+ ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string seq, int dis) {\\n        stringstream str(seq); int spaces  = 0;for(auto ch:seq) if(ch==\\' \\') spaces++; long double mult = (long double)dis/100;\\n        string chunk ;  int n = seq.size(); vector<string> v;\\n        for(int i = 0;i<spaces+1;i++){\\n            getline(str, chunk, \\' \\');\\n            v.push_back(chunk);      \\n        }\\n        \\n        for(auto &chunk:v){\\n            if(chunk[0]!=\\'$\\') continue; if(chunk.size()==1) continue;\\n            bool f = 0;\\n            for(int i = 1;i<chunk.size();i++) if(chunk[i]<=\\'9\\' and chunk[i]>=\\'0\\') continue; else{ f = 1; break;}\\n            if(f==1) continue;\\n            int len = chunk.size();\\n            string s = chunk.substr(1);\\n            long long inti =  stoll(s); long double  stl = inti -  mult*(inti); \\n            string now = to_string (stl);\\n            int ind = -1;\\n            for(int i = 0;i<now.size();i++) if(now[i]==\\'.\\') ind = i;\\n            chunk = \"$\" + now.substr(0,ind+3);\\n        }\\n        string ans=\"\";\\n        for(auto &w:v) ans+=w + \" \";\\n\\n        ans.erase(ans.begin()+ ans.size()-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085748,
                "title": "go-simple-solution",
                "content": "```\\nfunc discountPrices(sentence string, discount int) string {\\n    words := strings.Split(sentence, \" \")\\n    for index, word := range words {\\n        if word[0] != 36 {\\n            continue\\n        }\\n        num, err := strconv.Atoi(word[1:len(word)])\\n        if err != nil {\\n            continue\\n        }\\n        discountPrice := fmt.Sprintf(\"%.2f\", float64(num) * (100 - float64(discount)) / 100)\\n        words[index] = \"$\" + string(discountPrice)\\n    }\\n    return strings.Join(words, \" \")\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc discountPrices(sentence string, discount int) string {\\n    words := strings.Split(sentence, \" \")\\n    for index, word := range words {\\n        if word[0] != 36 {\\n            continue\\n        }\\n        num, err := strconv.Atoi(word[1:len(word)])\\n        if err != nil {\\n            continue\\n        }\\n        discountPrice := fmt.Sprintf(\"%.2f\", float64(num) * (100 - float64(discount)) / 100)\\n        words[index] = \"$\" + string(discountPrice)\\n    }\\n    return strings.Join(words, \" \")\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2085747,
                "title": "java-easy",
                "content": "public String discountPrices(String sentence, int discount) {\\n        \\n        String[] sa = sentence.split(\" \");\\n        for(int i=0;i<sa.length;i++)\\n        {\\n           String s = sa[i];\\n            if(s.charAt(0)==\\'$\\')\\n            {\\n                int f =1;\\n                String n = s.substring(1);\\n                \\n               if(s==\"\")\\n               {\\n                   continue;\\n               }\\n                Double num=0d;\\n                try\\n                {\\n                    num=Double.parseDouble(n);\\n                }\\n                catch(Exception e)\\n                {\\n                    f=0;\\n                }\\n                if(f==1)\\n                {\\n                    num = num * (100-discount) /100;\\n                    \\n                    DecimalFormat dec = new DecimalFormat(\"#0.00\");\\n                    String a = dec.format(num);\\n                    sa[i] = \"$\"+ a;\\n                } \\n                \\n            }        \\n           \\n        }\\n        String res=String.join(\" \",sa);\\n        \\n      \\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "public String discountPrices(String sentence, int discount) {\\n        \\n        String[] sa = sentence.split(\" \");\\n        for(int i=0;i<sa.length;i++)\\n        {\\n           String s = sa[i];\\n            if(s.charAt(0)==\\'$\\')\\n            {\\n                int f =1;\\n                String n = s.substring(1);\\n                \\n               if(s==\"\")\\n               {\\n                   continue;\\n               }\\n                Double num=0d;\\n                try\\n                {\\n                    num=Double.parseDouble(n);\\n                }\\n                catch(Exception e)\\n                {\\n                    f=0;\\n                }\\n                if(f==1)\\n                {\\n                    num = num * (100-discount) /100;\\n                    \\n                    DecimalFormat dec = new DecimalFormat(\"#0.00\");\\n                    String a = dec.format(num);\\n                    sa[i] = \"$\"+ a;\\n                } \\n                \\n            }        \\n           \\n        }\\n        String res=String.join(\" \",sa);\\n        \\n      \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2085708,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    boolean digitOnly(String s){\\n        for(char cs:s.toCharArray()) if(cs!=\\'$\\' && !(cs>=\\'0\\' && cs<=\\'9\\')) return false;\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        double val=(double)discount/(double)100 ;\\n        String[] s=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++){\\n            if(s[i].indexOf(\\'$\\')==0 && s[i].lastIndexOf(\\'$\\')==0 && s[i].length()>1 && digitOnly(s[i])){\\n                double temp=1.0*Long.parseLong(s[i].substring(1));\\n                s[i]=\"$\"+String.format(\"%.2f\",(temp-temp*val));\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int sk=0;sk<s.length;sk++) {\\n            sb.append(s[sk]);\\n            if(sk!=s.length-1) sb.append(\" \");}\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean digitOnly(String s){\\n        for(char cs:s.toCharArray()) if(cs!=\\'$\\' && !(cs>=\\'0\\' && cs<=\\'9\\')) return false;\\n        return true;\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        double val=(double)discount/(double)100 ;\\n        String[] s=sentence.split(\" \");\\n        for(int i=0;i<s.length;i++){\\n            if(s[i].indexOf(\\'$\\')==0 && s[i].lastIndexOf(\\'$\\')==0 && s[i].length()>1 && digitOnly(s[i])){\\n                double temp=1.0*Long.parseLong(s[i].substring(1));\\n                s[i]=\"$\"+String.format(\"%.2f\",(temp-temp*val));\\n            }\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int sk=0;sk<s.length;sk++) {\\n            sb.append(s[sk]);\\n            if(sk!=s.length-1) sb.append(\" \");}\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085661,
                "title": "bad-test-cases-but-passed-c",
                "content": "\\ttypedef long double ld;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring discountPrices(string s, int discount) {\\n\\t\\t\\tvector<string>arr;\\n\\t\\t\\tfor(int i=0;i<size(s);i++){\\n\\t\\t\\t\\tif(s[i]==\\'$\\'){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'$\\' or isalpha(s[i])) l++;\\n\\t\\t\\t\\t\\t\\tstr+=s[i++];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(size(str) and !l){\\n\\t\\t\\t\\t\\t\\tld num = stold(str);\\n\\t\\t\\t\\t\\t\\tnum = num - (ld)(num*(ld)discount/100.00);\\n\\t\\t\\t\\t\\t\\tstring ans = to_string(num),k=\"$\"; \\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<size(ans);j++){\\n\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j]);\\n\\t\\t\\t\\t\\t\\t\\tif(ans[j]==\\'.\\'){\\n\\t\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j+1]);\\n\\t\\t\\t\\t\\t\\t\\t\\tk.push_back(ans[j+2]);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tarr.push_back(k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tstring k = \"$\";\\n\\t\\t\\t\\t\\t\\tk+=str;\\n\\t\\t\\t\\t\\t\\tarr.push_back(k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])) str+=s[i++];\\n\\t\\t\\t\\t\\tarr.push_back(str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstring res;\\n\\t\\t\\tfor(auto x:arr) res+=x,res.push_back(\\' \\');\\n\\t\\t\\tres.pop_back();\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring discountPrices(string s, int discount) {\\n\\t\\t\\tvector<string>arr;\\n\\t\\t\\tfor(int i=0;i<size(s);i++){\\n\\t\\t\\t\\tif(s[i]==\\'$\\'){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tstring str;\\n\\t\\t\\t\\t\\tint l = 0;\\n\\t\\t\\t\\t\\twhile(i<size(s) and !isspace(s[i])){\\n\\t\\t\\t\\t\\t\\tif(s[i]==\\'$\\' or isalpha(s[i])) l++;\\n\\t\\t\\t\\t\\t\\tstr+=s[i++];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2085659,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    \\n    # Function to check if value is int or not\\n    def isint(self, x):\\n        try:\\n            a = float(x)\\n            b = int(a)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return a == b\\n    \\n    # Function to check if value is float or not\\n    def isfloat(self, x):\\n        try:\\n            a = float(x)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return True\\n    \\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split()\\n        \\n        for i, val in enumerate(sentence):\\n            if len(val) > 1 and val[0] == \\'$\\':\\n                \\n                # Store price in temporary variable\\n                tmp = val[1:]\\n                \\n                # Check if the value is either int or float, if yes then only apply discount\\n                if self.isint(tmp) or self.isfloat(tmp):\\n                    tmp = float(tmp)\\n                    if discount == 100:\\n                        sentence[i] = \\'$0.00\\'\\n                    else:\\n                        disc = (tmp * discount) / 100\\n                        disc_price = tmp - disc\\n                        # Change discounted price to 2 decimal places\\n                        sentence[i] = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                        \\n        return \\' \\'.join(sentence)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Function to check if value is int or not\\n    def isint(self, x):\\n        try:\\n            a = float(x)\\n            b = int(a)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return a == b\\n    \\n    # Function to check if value is float or not\\n    def isfloat(self, x):\\n        try:\\n            a = float(x)\\n        except (TypeError, ValueError):\\n            return False\\n        else:\\n            return True\\n    \\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split()\\n        \\n        for i, val in enumerate(sentence):\\n            if len(val) > 1 and val[0] == \\'$\\':\\n                \\n                # Store price in temporary variable\\n                tmp = val[1:]\\n                \\n                # Check if the value is either int or float, if yes then only apply discount\\n                if self.isint(tmp) or self.isfloat(tmp):\\n                    tmp = float(tmp)\\n                    if discount == 100:\\n                        sentence[i] = \\'$0.00\\'\\n                    else:\\n                        disc = (tmp * discount) / 100\\n                        disc_price = tmp - disc\\n                        # Change discounted price to 2 decimal places\\n                        sentence[i] = \\'$\\' + str(format(disc_price, \\'.2f\\'))\\n                        \\n        return \\' \\'.join(sentence)",
                "codeTag": "Java"
            },
            {
                "id": 2085654,
                "title": "short-python",
                "content": "```\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        res = \"\"\\n        for w in words:\\n            if w[0] == \\'$\\' and w[1:].isdigit():\\n                newVal = (int(w[1:]) * ((100 - discount) / 100))\\n                formatVal = \"{:.2f}\".format(newVal)\\n                res += \\'$\\' + formatVal + \\' \\'\\n            else:\\n                res += w + \\' \\'\\n        res = res[:-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        res = \"\"\\n        for w in words:\\n            if w[0] == \\'$\\' and w[1:].isdigit():\\n                newVal = (int(w[1:]) * ((100 - discount) / 100))\\n                formatVal = \"{:.2f}\".format(newVal)\\n                res += \\'$\\' + formatVal + \\' \\'\\n            else:\\n                res += w + \\' \\'\\n        res = res[:-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4082087,
                "title": "rust-solution",
                "content": "\\n# Code\\n```\\nfn parse_price(s: &str) -> Option<f64> {\\n    if s.starts_with(\\'\\n```) && s.len() > 1 && s[1..].chars().all(|c| c.is_ascii_digit()) {\\n        s[1..].parse().ok()\\n    } else {\\n        None\\n    }\\n}\\n\\n\\n\\n\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        sentence\\n            .split_whitespace()\\n            .map(|word| {\\n                match parse_price(word) {\\n                    Some(price) => format!(\"${:.2}\", price - price * discount as f64 / 100.),\\n                    None => word.to_string()\\n                }\\n            })\\n            .collect::<Vec<String>>()\\n            .join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn parse_price(s: &str) -> Option<f64> {\\n    if s.starts_with(\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022307,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n\\n```javascript []\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    const words = sentence.split(\\' \\');\\n\\n    words.forEach((word, i) => {\\n        if (word[0] === \\'$\\') {\\n            let price = word.slice(1);\\n\\n            if (isDigit(price)) {\\n                price -= (price * discount / 100);\\n                words[i] = `$${price.toFixed(2)}`\\n            }\\n        }\\n    })\\n\\n    return words.join(\\' \\');\\n};\\n\\nconst isDigit = (str) => /^\\\\d+$/.test(str);\\n\\n```\\n\\n``` python []\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:])\\n                price -= (price * discount / 100)\\n                words[i] = f\"${price:.2f}\"\\n            \\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    const words = sentence.split(\\' \\');\\n\\n    words.forEach((word, i) => {\\n        if (word[0] === \\'$\\') {\\n            let price = word.slice(1);\\n\\n            if (isDigit(price)) {\\n                price -= (price * discount / 100);\\n                words[i] = `$${price.toFixed(2)}`\\n            }\\n        }\\n    })\\n\\n    return words.join(\\' \\');\\n};\\n\\nconst isDigit = (str) => /^\\\\d+$/.test(str);\\n\\n```\n``` python []\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n\\n        for i, word in enumerate(words):\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:])\\n                price -= (price * discount / 100)\\n                words[i] = f\"${price:.2f}\"\\n            \\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984913,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String s = \"^\\\\\\\\${1}[0-9]{1,10}$\";\\n        Pattern pattern = Pattern.compile(s);\\n        Matcher m;\\n        StringBuilder sb = new StringBuilder();\\n        DecimalFormat decimalFormat = new DecimalFormat(\"#0.00\");\\n        for (String w : sentence.split(\" \")) {\\n            m = pattern.matcher(w);\\n            if (!m.find()) {\\n                sb.append(w).append(\" \");\\n            } else {\\n                double d = Double.parseDouble(w.substring(m.start() + 1, m.end())) * (double) (100 - discount) / 100;\\n                sb.append(\"$\").append(decimalFormat.format(d)).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String s = \"^\\\\\\\\${1}[0-9]{1,10}$\";\\n        Pattern pattern = Pattern.compile(s);\\n        Matcher m;\\n        StringBuilder sb = new StringBuilder();\\n        DecimalFormat decimalFormat = new DecimalFormat(\"#0.00\");\\n        for (String w : sentence.split(\" \")) {\\n            m = pattern.matcher(w);\\n            if (!m.find()) {\\n                sb.append(w).append(\" \");\\n            } else {\\n                double d = Double.parseDouble(w.substring(m.start() + 1, m.end())) * (double) (100 - discount) / 100;\\n                sb.append(\"$\").append(decimalFormat.format(d)).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973924,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    DecimalFormat df=new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String str[]=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++)\\n        {\\n           if(str[i].charAt(0)==\\'$\\')\\n           {\\n               try\\n               {\\n                   if(str[i].length()<12 && !str[i].contains(\"e\"))\\n                   {\\n                        if(str[i].charAt(str[i].length()-1)>=\\'0\\' && str[i].charAt(str[i].length()-1)<=\\'9\\')\\n                        {\\n                                double y=Double.parseDouble(str[i].substring(1));\\n                                double x=(y/100)*discount;\\n                                y=y-x;\\n                                str[i]=\"$\"+df.format(y);\\n                        }\\n                   }\\n\\n               }\\n               catch(Exception e)\\n               {\\n                    // Do Nothing\\n               }\\n           }\\n        }\\n        StringBuffer sb=new StringBuffer(\"\");\\n       for(int i=0;i<str.length;i++)\\n       {\\n           if(i<str.length-1)\\n           {\\n             sb.append(str[i]);\\n             sb.append(\" \");\\n           }\\n           else\\n           {\\n               sb.append(str[i]);\\n           }\\n       }\\n       return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.text.DecimalFormat;\\nclass Solution {\\n    DecimalFormat df=new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String str[]=sentence.split(\" \");\\n        for(int i=0;i<str.length;i++)\\n        {\\n           if(str[i].charAt(0)==\\'$\\')\\n           {\\n               try\\n               {\\n                   if(str[i].length()<12 && !str[i].contains(\"e\"))\\n                   {\\n                        if(str[i].charAt(str[i].length()-1)>=\\'0\\' && str[i].charAt(str[i].length()-1)<=\\'9\\')\\n                        {\\n                                double y=Double.parseDouble(str[i].substring(1));\\n                                double x=(y/100)*discount;\\n                                y=y-x;\\n                                str[i]=\"$\"+df.format(y);\\n                        }\\n                   }\\n\\n               }\\n               catch(Exception e)\\n               {\\n                    // Do Nothing\\n               }\\n           }\\n        }\\n        StringBuffer sb=new StringBuffer(\"\");\\n       for(int i=0;i<str.length;i++)\\n       {\\n           if(i<str.length-1)\\n           {\\n             sb.append(str[i]);\\n             sb.append(\" \");\\n           }\\n           else\\n           {\\n               sb.append(str[i]);\\n           }\\n       }\\n       return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973254,
                "title": "python-easy-solution-using-regular-expression",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s=sentence.split()\\n        for i in range(len(s)):\\n            if re.match(\\'^[$][0-9]+\\n```,s[i]):\\n                print(s[i])\\n                d=int(s[i][1:])-0.01*discount*int(s[i][1:])\\n                s[i]=\\'\\n```+\"{:.2f}\".format(d)\\n        return \" \".join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        s=sentence.split()\\n        for i in range(len(s)):\\n            if re.match(\\'^[$][0-9]+\\n```\n```+\"{:.2f}\".format(d)\\n        return \" \".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971028,
                "title": "apply-discount-to-prices",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] subStrings = sentence.split(\" \");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<subStrings.length;i++){\\n            if(subStrings[i].charAt(0)==\\'$\\'){\\n                StringBuilder s=new StringBuilder();\\n                for(int j=1;j<subStrings[i].length();j++){\\n                    if(subStrings[i].charAt(j)-\\'0\\'<=9 && subStrings[i].charAt(j)-\\'0\\'>=0){\\n                        s.append(subStrings[i].charAt(j));\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(s.toString().length()==subStrings[i].length()-1 && s.toString().length()!=0){\\n                    DecimalFormat df = new DecimalFormat(\"0.00\");\\n                    System.out.println(s.toString());\\n                    double y=100-discount;\\n                    double vals=Double.parseDouble(s.toString())*y/100d;\\n                    String outs=(df.format(vals));\\n                if(i<subStrings.length-1){\\n                    subStrings[i]=\"$\"+outs+\" \";\\n                }\\n                else{\\n                    System.out.println(s.toString().length());\\n                    subStrings[i]=\"$\"+outs;\\n                }\\n                }\\n                else if(s.toString().length()==0 && i>subStrings.length-1){\\n                    subStrings[i]=subStrings[i];\\n                }\\n                else if(s.toString().length()<=subStrings[i].length()-1 && i<subStrings.length-1){\\n                    subStrings[i]=subStrings[i]+\" \";\\n                }\\n            }\\n            else{\\n                if(i<subStrings.length-1){\\n                subStrings[i]=subStrings[i]+\" \";\\n                }\\n                else{\\n                    System.out.print(subStrings[i]);\\n                    subStrings[i]=subStrings[i];\\n                }\\n\\n            }\\n            ans.append(subStrings[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] subStrings = sentence.split(\" \");\\n        StringBuilder ans=new StringBuilder();\\n        for(int i=0;i<subStrings.length;i++){\\n            if(subStrings[i].charAt(0)==\\'$\\'){\\n                StringBuilder s=new StringBuilder();\\n                for(int j=1;j<subStrings[i].length();j++){\\n                    if(subStrings[i].charAt(j)-\\'0\\'<=9 && subStrings[i].charAt(j)-\\'0\\'>=0){\\n                        s.append(subStrings[i].charAt(j));\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                if(s.toString().length()==subStrings[i].length()-1 && s.toString().length()!=0){\\n                    DecimalFormat df = new DecimalFormat(\"0.00\");\\n                    System.out.println(s.toString());\\n                    double y=100-discount;\\n                    double vals=Double.parseDouble(s.toString())*y/100d;\\n                    String outs=(df.format(vals));\\n                if(i<subStrings.length-1){\\n                    subStrings[i]=\"$\"+outs+\" \";\\n                }\\n                else{\\n                    System.out.println(s.toString().length());\\n                    subStrings[i]=\"$\"+outs;\\n                }\\n                }\\n                else if(s.toString().length()==0 && i>subStrings.length-1){\\n                    subStrings[i]=subStrings[i];\\n                }\\n                else if(s.toString().length()<=subStrings[i].length()-1 && i<subStrings.length-1){\\n                    subStrings[i]=subStrings[i]+\" \";\\n                }\\n            }\\n            else{\\n                if(i<subStrings.length-1){\\n                subStrings[i]=subStrings[i]+\" \";\\n                }\\n                else{\\n                    System.out.print(subStrings[i]);\\n                    subStrings[i]=subStrings[i];\\n                }\\n\\n            }\\n            ans.append(subStrings[i]);\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905477,
                "title": "python-fastest-and-simple-solution-beat-100",
                "content": "# Screen\\n![4.png](https://assets.leetcode.com/users/images/f589e02a-a720-4e7b-8ae5-4035fc265e10_1691951378.3188767.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for idx, word in enumerate(words):\\n            if word[0] == \\'$\\':\\n                try:\\n                    price = int(word[1:])\\n                except ValueError:\\n                    continue\\n                price -= price * discount / 100\\n                words[idx] = f\\'${price:.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split()\\n        for idx, word in enumerate(words):\\n            if word[0] == \\'$\\':\\n                try:\\n                    price = int(word[1:])\\n                except ValueError:\\n                    continue\\n                price -= price * discount / 100\\n                words[idx] = f\\'${price:.2f}\\'\\n        return \\' \\'.join(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887887,
                "title": "readable-java-code",
                "content": "# Code\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if (isPrice(word)) {\\n                result.append(\"$\").append(getDiscountedValue(word.substring(1), discount));\\n            } else {\\n                result.append(word);\\n            }\\n            if (i < words.length - 1) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n\\n    private String getDiscountedValue(String s, double discount) {\\n        discount = (100 - discount);\\n        discount /= 100;\\n        BigDecimal result = new BigDecimal(s).multiply(new BigDecimal(Double.toString(discount)));\\n        return result.setScale(2, RoundingMode.HALF_UP).toString();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        return word.matches(\"^\\\\\\\\$\\\\\\\\d+\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder result = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            if (isPrice(word)) {\\n                result.append(\"$\").append(getDiscountedValue(word.substring(1), discount));\\n            } else {\\n                result.append(word);\\n            }\\n            if (i < words.length - 1) {\\n                result.append(\" \");\\n            }\\n        }\\n        return result.toString();\\n    }\\n\\n    private String getDiscountedValue(String s, double discount) {\\n        discount = (100 - discount);\\n        discount /= 100;\\n        BigDecimal result = new BigDecimal(s).multiply(new BigDecimal(Double.toString(discount)));\\n        return result.setScale(2, RoundingMode.HALF_UP).toString();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        return word.matches(\"^\\\\\\\\$\\\\\\\\d+\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886193,
                "title": "apply-discount-to-prices",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n``` and i[1:].isdigit():\\n                d=i[i.index(\\'\\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```+str(d)\\n            else:\\n                s=s+\\' \\'+i\\n        s=s.strip()\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n```\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808617,
                "title": "solution-for-medium-problem-from-imronbek",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n``` and i[1:].isdigit():\\n                d=i[i.index(\\'\\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```+str(d)\\n            else:\\n                s=s+\\' \\'+i\\n        s=s.strip()\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst=sentence.split()\\n        s=\\'\\'\\n        for i in lst:\\n            if i[0]==\\'\\n```\n```)+1::]\\n                d=str(int(d)*(100-discount)/100)\\n                if len(d.split(\\'.\\')[1])<2:\\n                    d+=\\'0\\'\\n                s=s+\\' \\'+\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780214,
                "title": "apply-discount-to-prices",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n        a = s.split(\" \")\\n        l = []\\n        for i in range(len(a)):\\n            if a[i][:1]==\"$\" and a[i][1:].isdigit()==True:\\n                c = int(a[i][1:])* (100 - d)/100\\n                b = \"$\" +  str(format(c, \\'.2f\\'))\\n                a[i],b = b,a[i]\\n        return \" \".join(a)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, s: str, d: int) -> str:\\n        a = s.split(\" \")\\n        l = []\\n        for i in range(len(a)):\\n            if a[i][:1]==\"$\" and a[i][1:].isdigit()==True:\\n                c = int(a[i][1:])* (100 - d)/100\\n                b = \"$\" +  str(format(c, \\'.2f\\'))\\n                a[i],b = b,a[i]\\n        return \" \".join(a)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731088,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n\\n        for(String t : arr){\\n            if(i != arr.length -1){\\n                sb.append(convert(t, discount, df) + \" \");\\n            }\\n            else{\\n                sb.append(convert(t, discount, df));\\n            }\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n\\n    String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'\\n```){\\n            try{\\n                long price = Long.parseLong(x.substring(1));\\n                double val = price - ((double)price*discount)/100d;     \\n                return \"$\"+df.format(val);\\n            }\\n            catch(Exception e){\\n                return x;\\n            }\\n        }\\n        return x;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String s, int discount) {\\n        String[] arr = s.split(\" \");\\n\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        StringBuilder sb = new StringBuilder();\\n\\n        int i = 0;\\n\\n        for(String t : arr){\\n            if(i != arr.length -1){\\n                sb.append(convert(t, discount, df) + \" \");\\n            }\\n            else{\\n                sb.append(convert(t, discount, df));\\n            }\\n            i++;\\n        }\\n        return sb.toString();\\n    }\\n\\n    String convert(String x,int discount,DecimalFormat df){\\n        if(x.length()>11){\\n            return x;\\n        }\\n        if(x.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675066,
                "title": "simplest-solution-python",
                "content": "# Intuition\\nself explainatory\\n\\n# Approach\\nfind the patten \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.strip().split()\\n        ans=[]\\n        for x in lst:\\n            if len(x)>1 and x[0]==\\'\\n``` and x.count(\\'\\n```)==1 and x.count(\\'e\\')==0:\\n                try:\\n                    a= float(x[1:])- discount/100*float(x[1:])\\n                    x=\\'\\n```+ str (\"{:.2f}\".format(a))                \\n                    ans.append(x)\\n                except:\\n                    ans.append(x)\\n            else:\\n                ans.append(x)\\n        return \\' \\'.join(ans)\\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.strip().split()\\n        ans=[]\\n        for x in lst:\\n            if len(x)>1 and x[0]==\\'\\n```\n```)==1 and x.count(\\'e\\')==0:\\n                try:\\n                    a= float(x[1:])- discount/100*float(x[1:])\\n                    x=\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537132,
                "title": "one-pass-no-split-constant-space-java-simple-faster-than-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n**o(n)**\\n\\n- Space complexity:\\n**constant o(1)** , because the stringbuilder should not be considered since the question is demanding us to return a string and it is not wise to change the input string so thats why not counting the space taken by the stringBuilder\\n\\n# Code\\n```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\"); //to be used for getting 2 decimal\\n    public String myWay(String str,int dis)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch1 = str.charAt(i);\\n            if(ch1==\\'$\\' && i!=str.length()-1 && (i-1<0 || (str.charAt(i-1)==\\' \\'))) \\n            //because \"$\" this can be the string too then\\n            //we dont want this to be valid...so if the $ is at the end of the string \\n            //then simply do not go into this if block\\n            //Last two conditions because -> for case like \"2$3\" then the \\n            //$3 will not be considered because it is not a seperate word...on the other hand\\n            //if we had \"2 $3\" then it would be considered\\n            {\\n                int index = i+1;\\n                double number = 0;\\n                boolean isValid = true;\\n                while(index < str.length())\\n                {\\n                    char ch = str.charAt(index);\\n                    if(ch==\\' \\')\\n                    {\\n                        if(index==i+1) isValid = false;//like \"$ \" case\\n                        break;\\n                    }\\n                    else if(ch>=\\'0\\' && ch<=\\'9\\')\\n                    {\\n                        number = number*10+(ch-\\'0\\');\\n                    }\\n                    else\\n                    {\\n                        isValid = false;// case like \"$a\" ie a character before a space \\n                        break;\\n                    }\\n                    index++;\\n                }\\n\\n                if(isValid)\\n                {\\n                   double discounted = ((dis*1.0)/100.0)*number;\\n                   discounted = number - discounted;\\n                   sb.append(\"$\"+df.format(discounted));\\n                   if(index < str.length()) sb.append(\" \");\\n                   i=index;\\n                }\\n                else sb.append(\\'$\\');\\n            }\\n            else sb.append(ch1);\\n        }\\n        return sb.toString();\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        return myWay(sentence,discount);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```\\n**Consider upvoting if you find this post helpful :)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    private DecimalFormat df = new DecimalFormat(\"0.00\"); //to be used for getting 2 decimal\\n    public String myWay(String str,int dis)\\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<str.length();i++)\\n        {\\n            char ch1 = str.charAt(i);\\n            if(ch1==\\'$\\' && i!=str.length()-1 && (i-1<0 || (str.charAt(i-1)==\\' \\'))) \\n            //because \"$\" this can be the string too then\\n            //we dont want this to be valid...so if the $ is at the end of the string \\n            //then simply do not go into this if block\\n            //Last two conditions because -> for case like \"2$3\" then the \\n            //$3 will not be considered because it is not a seperate word...on the other hand\\n            //if we had \"2 $3\" then it would be considered\\n            {\\n                int index = i+1;\\n                double number = 0;\\n                boolean isValid = true;\\n                while(index < str.length())\\n                {\\n                    char ch = str.charAt(index);\\n                    if(ch==\\' \\')\\n                    {\\n                        if(index==i+1) isValid = false;//like \"$ \" case\\n                        break;\\n                    }\\n                    else if(ch>=\\'0\\' && ch<=\\'9\\')\\n                    {\\n                        number = number*10+(ch-\\'0\\');\\n                    }\\n                    else\\n                    {\\n                        isValid = false;// case like \"$a\" ie a character before a space \\n                        break;\\n                    }\\n                    index++;\\n                }\\n\\n                if(isValid)\\n                {\\n                   double discounted = ((dis*1.0)/100.0)*number;\\n                   discounted = number - discounted;\\n                   sb.append(\"$\"+df.format(discounted));\\n                   if(index < str.length()) sb.append(\" \");\\n                   i=index;\\n                }\\n                else sb.append(\\'$\\');\\n            }\\n            else sb.append(ch1);\\n        }\\n        return sb.toString();\\n    }\\n    public String discountPrices(String sentence, int discount) {\\n        return myWay(sentence,discount);//Tc->o(n) and s->o(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526674,
                "title": "java-easy-using-hashmap-and-string",
                "content": "upvote if you like\\n```\\nclass Solution {\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        String arr[]=sentence.split(\" \");\\n        \\n        HashMap<String,String>map= new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n\\n           String a=arr[i];\\n         //  System.out.println(a);\\n            if(a.charAt(0)==\\'$\\' && a.length()>1)\\n            {\\n                String b=a.substring(1);\\n                 System.out.println(b);\\n                if(b.length()<=10)\\n                {\\n                // System.out.println(b);\\n                try\\n                {\\n                   long val=Long.parseLong(b);\\n                   double ori=(double)val;\\n                    double val2=(discount*val*1.0)/100.0;\\n                    \\n                    val2=ori-val2;\\n                   // System.out.println(val2);\\n                  \\n                    map.put(a,df.format(val2));\\n                }\\n                catch(Exception e)\\n                {\\n                   // System.out.println(\"land\");\\n                }\\n                }\\n            }\\n        }\\n       String ans=\"\";\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(map.containsKey(arr[i]))\\n            {\\n                System.out.print(\\'$\\');\\n                ans+=\\'$\\';\\n              ans+= map.get(arr[i]);\\n               \\n            }\\n            else\\n            {\\n                 System.out.print(arr[i]);\\n                ans+=arr[i];\\n            }\\n            if(i!=arr.length-1)\\n            {\\n                System.out.print(\" \");\\n                ans+=\" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String discountPrices(String sentence, int discount) {\\n        DecimalFormat df = new DecimalFormat(\"0.00\"); \\n        String arr[]=sentence.split(\" \");\\n        \\n        HashMap<String,String>map= new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n\\n           String a=arr[i];\\n         //  System.out.println(a);\\n            if(a.charAt(0)==\\'$\\' && a.length()>1)\\n            {\\n                String b=a.substring(1);\\n                 System.out.println(b);\\n                if(b.length()<=10)\\n                {\\n                // System.out.println(b);\\n                try\\n                {\\n                   long val=Long.parseLong(b);\\n                   double ori=(double)val;\\n                    double val2=(discount*val*1.0)/100.0;\\n                    \\n                    val2=ori-val2;\\n                   // System.out.println(val2);\\n                  \\n                    map.put(a,df.format(val2));\\n                }\\n                catch(Exception e)\\n                {\\n                   // System.out.println(\"land\");\\n                }\\n                }\\n            }\\n        }\\n       String ans=\"\";\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(map.containsKey(arr[i]))\\n            {\\n                System.out.print(\\'$\\');\\n                ans+=\\'$\\';\\n              ans+= map.get(arr[i]);\\n               \\n            }\\n            else\\n            {\\n                 System.out.print(arr[i]);\\n                ans+=arr[i];\\n            }\\n            if(i!=arr.length-1)\\n            {\\n                System.out.print(\" \");\\n                ans+=\" \";\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510248,
                "title": "c-just-one-explicit-state-to-collect-price",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        s.push_back(\\' \\');\\n        string ans;\\n        for(int prev = \\' \\', cur, check = 0, i = 0; i < s.size() && (cur = s[i]); ++i, prev = cur) {\\n            if(check && cur == \\' \\') {\\n                long long price = 0;\\n                for(long long weight = 1; isdigit(ans.back()); ans.pop_back(), weight *= 10) \\n                    price += weight * (ans.back() - \\'0\\');\\n                if(price) {\\n                    price *= (100 - discount);\\n                    int sz = 0;\\n                    for(; sz < 3 || price; price /= 10) {\\n                        ans.push_back(\\'0\\' + (price % 10));\\n                        if(++sz == 2)\\n                            ans.push_back(\\'.\\');\\n                    }\\n                    reverse(ans.rbegin(), ans.rbegin() + sz + 1);\\n                }\\n            } \\n            check = (prev == \\' \\' && cur == \\'\\n```) || (check && isdigit(cur));\\n            ans.push_back(cur);\\n        }\\n        return {ans.begin(), ans.end() - 1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        s.push_back(\\' \\');\\n        string ans;\\n        for(int prev = \\' \\', cur, check = 0, i = 0; i < s.size() && (cur = s[i]); ++i, prev = cur) {\\n            if(check && cur == \\' \\') {\\n                long long price = 0;\\n                for(long long weight = 1; isdigit(ans.back()); ans.pop_back(), weight *= 10) \\n                    price += weight * (ans.back() - \\'0\\');\\n                if(price) {\\n                    price *= (100 - discount);\\n                    int sz = 0;\\n                    for(; sz < 3 || price; price /= 10) {\\n                        ans.push_back(\\'0\\' + (price % 10));\\n                        if(++sz == 2)\\n                            ans.push_back(\\'.\\');\\n                    }\\n                    reverse(ans.rbegin(), ans.rbegin() + sz + 1);\\n                }\\n            } \\n            check = (prev == \\' \\' && cur == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471922,
                "title": "this-is-for-javascript",
                "content": "As a frontend engineer with js, this IS exactly what we do in work everyday.\\n\\n**key point: use toFixed()**\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    sentence = sentence.split(\\' \\')\\n    \\n    for(let i = 0; i < sentence.length; i++) {\\n        if(sentence[i][0] === \\'$\\') {\\n            let temp = sentence[i].slice(1)\\n            \\n            if(temp.length && temp.split(\\'\\').every(t => /[0-9]/.test(t))) {\\n                sentence[i] = `$${(parseInt(temp) - parseInt(temp) * (discount / 100)).toFixed(2)}`\\n            }\\n        }\\n    }\\n    \\n    return sentence.join(\\' \\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n    sentence = sentence.split(\\' \\')\\n    \\n    for(let i = 0; i < sentence.length; i++) {\\n        if(sentence[i][0] === \\'$\\') {\\n            let temp = sentence[i].slice(1)\\n            \\n            if(temp.length && temp.split(\\'\\').every(t => /[0-9]/.test(t))) {\\n                sentence[i] = `$${(parseInt(temp) - parseInt(temp) * (discount / 100)).toFixed(2)}`\\n            }\\n        }\\n    }\\n    \\n    return sentence.join(\\' \\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3454789,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        for(int i=0; i<s.length; i++){\\n            if(s[i].charAt(0) == \\'\\n```){\\n                String temp = s[i].substring(1);\\n                if(temp.length() == 0 || temp.indexOf(\\'\\n```) != -1 || isAlphabet(temp))\\n                    continue;\\n                double p = Double.valueOf(s[i].substring(1, s[i].length()));\\n                double dis = p - (p*discount/100);\\n                s[i] = s[i].substring(0, 1) + String.format(\"%.2f\", dis);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String t: s){\\n            sb.append(t);\\n            if(i++<s.length-1)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    private boolean isAlphabet(String s){\\n        for(int i=0; i<s.length(); i++)\\n            if(Character.isAlphabetic(s.charAt(i)))\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        for(int i=0; i<s.length; i++){\\n            if(s[i].charAt(0) == \\'\\n```\n```) != -1 || isAlphabet(temp))\\n                    continue;\\n                double p = Double.valueOf(s[i].substring(1, s[i].length()));\\n                double dis = p - (p*discount/100);\\n                s[i] = s[i].substring(0, 1) + String.format(\"%.2f\", dis);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int i=0;\\n        for(String t: s){\\n            sb.append(t);\\n            if(i++<s.length-1)\\n                sb.append(\" \");\\n        }\\n        return sb.toString();\\n    }\\n    private boolean isAlphabet(String s){\\n        for(int i=0; i<s.length(); i++)\\n            if(Character.isAlphabetic(s.charAt(i)))\\n                return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398325,
                "title": "easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence=sentence.split()\\n        for i in range(len(sentence)):\\n            if sentence[i][0]==\"$\" and len(sentence[i])>1:\\n                count=0\\n                for j in sentence[i][1:]:\\n                    if \"0\"<=j<=\"9\":count+=1\\n                if count==len(sentence[i][1:]):\\n                    num=int(sentence[i][1:])\\n                    proportion=discount/100\\n                    c=len(str(num-(num*(1-proportion))))-1\\n                    k=str(num-(num*proportion))\\n                    k=str(round(float(k),2))\\n                    if len(str(k).split(\".\")[-1])==1:\\n                        k=str(k)+\"0\"\\n                    a=str(num-(num*proportion))\\n                    sentence[i]=\"$\"+k\\n        return \" \".join([i for i in sentence])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence=sentence.split()\\n        for i in range(len(sentence)):\\n            if sentence[i][0]==\"$\" and len(sentence[i])>1:\\n                count=0\\n                for j in sentence[i][1:]:\\n                    if \"0\"<=j<=\"9\":count+=1\\n                if count==len(sentence[i][1:]):\\n                    num=int(sentence[i][1:])\\n                    proportion=discount/100\\n                    c=len(str(num-(num*(1-proportion))))-1\\n                    k=str(num-(num*proportion))\\n                    k=str(round(float(k),2))\\n                    if len(str(k).split(\".\")[-1])==1:\\n                        k=str(k)+\"0\"\\n                    a=str(num-(num*proportion))\\n                    sentence[i]=\"$\"+k\\n        return \" \".join([i for i in sentence])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378576,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Length(sentence)*number of spaces)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String temp;\\n        String[] arr = sentence.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            temp = arr[i];\\n            boolean oneDollarExactly = isExactOneDollar(temp);\\n            if(oneDollarExactly){\\n                arr[i]=applyDis(temp,discount);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n\\n    public boolean isExactOneDollar(String s){\\n        int count=0;\\n        if(s.charAt(0)!=\\'$\\') return false;\\n        for(char x : s.toCharArray()){\\n            if(x==\\'$\\') count++;\\n            if(x>=\\'a\\'&&x<=\\'z\\'){\\n                return false;\\n            }\\n        }\\n\\n        return count==1;\\n    }\\n\\n        public String applyDis(String s, int discount){\\n        String res =s.substring(1);\\n        if(res.length()==0) return s;\\n        long num=Long.valueOf(res);\\n        double numD=num-num*((double)discount/100);\\n        return \"$\"+df.format(numD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final DecimalFormat df = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        String temp;\\n        String[] arr = sentence.split(\" \");\\n        for(int i=0;i<arr.length;i++){\\n            temp = arr[i];\\n            boolean oneDollarExactly = isExactOneDollar(temp);\\n            if(oneDollarExactly){\\n                arr[i]=applyDis(temp,discount);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n\\n    public boolean isExactOneDollar(String s){\\n        int count=0;\\n        if(s.charAt(0)!=\\'$\\') return false;\\n        for(char x : s.toCharArray()){\\n            if(x==\\'$\\') count++;\\n            if(x>=\\'a\\'&&x<=\\'z\\'){\\n                return false;\\n            }\\n        }\\n\\n        return count==1;\\n    }\\n\\n        public String applyDis(String s, int discount){\\n        String res =s.substring(1);\\n        if(res.length()==0) return s;\\n        long num=Long.valueOf(res);\\n        double numD=num-num*((double)discount/100);\\n        return \"$\"+df.format(numD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367867,
                "title": "python-process-word-one-by-one-and-try-exception",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n        words = sentence.split(\" \")\\n        for wd in words:\\n            if wd[0] == \\'$\\' and wd[1:].isnumeric():\\n                try:\\n                    price = float(wd[1:])\\n                except:\\n                    ans.append(wd)\\n                    continue\\n                price = price * (100 - discount) / 100\\n                wd = \"$\" + f\"{price:.2f}\"\\n            ans.append(wd)\\n        return \" \".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n        words = sentence.split(\" \")\\n        for wd in words:\\n            if wd[0] == \\'$\\' and wd[1:].isnumeric():\\n                try:\\n                    price = float(wd[1:])\\n                except:\\n                    ans.append(wd)\\n                    continue\\n                price = price * (100 - discount) / 100\\n                wd = \"$\" + f\"{price:.2f}\"\\n            ans.append(wd)\\n        return \" \".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357683,
                "title": "scala-3-lines-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def discountPrices(sentence: String, discount: Int): String = {\\n        def isPrice(s: String) = s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\")\\n        def calc(num:Double) = \"$\" + (num - (num * discount / 100.00)).formatted(\"%.2f\")\\n        sentence.split(\" \").map(n => if(isPrice(n)) calc(n.substring(1).toDouble) else n).mkString(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def discountPrices(sentence: String, discount: Int): String = {\\n        def isPrice(s: String) = s.startsWith(\"$\") && s.substring(1).matches(\"\\\\\\\\d+\")\\n        def calc(num:Double) = \"$\" + (num - (num * discount / 100.00)).formatted(\"%.2f\")\\n        sentence.split(\" \").map(n => if(isPrice(n)) calc(n.substring(1).toDouble) else n).mkString(\" \")\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3327833,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    string applyDiscount(string s, int &discount) {\\n        if(s[0] != \\'$\\' || s.length() == 1) return s; \\n        long long val = 0;\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] < \\'0\\' || s[i] > \\'9\\') return s;\\n            val = val * 10 + (s[i] - \\'0\\');\\n        }\\n        stringstream res;\\n        res << fixed << setprecision(2) << val - val * discount / 100.0;\\n        return \"$\" + res.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int n = sentence.length(), i;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++) {\\n            int spaceIndex = sentence.find(\" \", i); \\n            if(spaceIndex == string::npos) break;\\n            ans += applyDiscount(sentence.substr(i, spaceIndex - i), discount) + \" \";\\n            i = spaceIndex;\\n        }\\n        ans += applyDiscount(sentence.substr(i, n - i), discount);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc applyDiscount(s string, discount int) string {\\n    if s[0] != \\'$\\' || len(s) == 1 {return s} \\n    var val int64 = 0\\n    for i := 1; i < len(s); i++ {\\n        if s[i] < \\'0\\' || s[i] > \\'9\\' {return s}\\n        val = val * 10 + int64(s[i] - \\'0\\')\\n    }\\n    return \"$\" + fmt.Sprintf(\"%.2f\", float64(val) * float64(100 - discount) / 100.0)\\n}\\n\\nfunc discountPrices(sentence string, discount int) string {\\n    var n, i int = len(sentence), 0\\n    var ans, word string = \"\", \"\"\\n    for i = 0; i < n; i++ {\\n        if sentence[i] != \\' \\' {\\n            word += string(sentence[i])\\n        } else {\\n            ans += applyDiscount(word, discount) + \" \"\\n            word = \"\"\\n        }\\n    }\\n    ans += applyDiscount(word, discount)\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    string applyDiscount(string s, int &discount) {\\n        if(s[0] != \\'$\\' || s.length() == 1) return s; \\n        long long val = 0;\\n        for(int i = 1; i < s.length(); i++) {\\n            if(s[i] < \\'0\\' || s[i] > \\'9\\') return s;\\n            val = val * 10 + (s[i] - \\'0\\');\\n        }\\n        stringstream res;\\n        res << fixed << setprecision(2) << val - val * discount / 100.0;\\n        return \"$\" + res.str();\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int n = sentence.length(), i;\\n        string ans = \"\";\\n        for(i = 0; i < n; i++) {\\n            int spaceIndex = sentence.find(\" \", i); \\n            if(spaceIndex == string::npos) break;\\n            ans += applyDiscount(sentence.substr(i, spaceIndex - i), discount) + \" \";\\n            i = spaceIndex;\\n        }\\n        ans += applyDiscount(sentence.substr(i, n - i), discount);\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc applyDiscount(s string, discount int) string {\\n    if s[0] != \\'$\\' || len(s) == 1 {return s} \\n    var val int64 = 0\\n    for i := 1; i < len(s); i++ {\\n        if s[i] < \\'0\\' || s[i] > \\'9\\' {return s}\\n        val = val * 10 + int64(s[i] - \\'0\\')\\n    }\\n    return \"$\" + fmt.Sprintf(\"%.2f\", float64(val) * float64(100 - discount) / 100.0)\\n}\\n\\nfunc discountPrices(sentence string, discount int) string {\\n    var n, i int = len(sentence), 0\\n    var ans, word string = \"\", \"\"\\n    for i = 0; i < n; i++ {\\n        if sentence[i] != \\' \\' {\\n            word += string(sentence[i])\\n        } else {\\n            ans += applyDiscount(word, discount) + \" \"\\n            word = \"\"\\n        }\\n    }\\n    ans += applyDiscount(word, discount)\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325349,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] str = sentence.split(\" \");\\n        String res=\"\";\\n        double dis = discount/100.0;\\n        outer :\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].charAt(0)==\\'\\n``` && str[i].length()>1){\\n                String s = str[i].substring(1,str[i].length());\\n                for(int j=0;j<s.length();j++){\\n                    if(!Character.isDigit(s.charAt(j))){\\n                        continue outer;\\n                    }\\n                }\\n                double n=(double)Long.parseLong(s)/1.0;\\n                n-=n*dis;\\n                s=String.valueOf(n);\\n                s=String.valueOf(String.format(\"%.2f\",n));\\n                res = \\'\\n``` + s;\\n                str[i]=res;\\n            }\\n        }\\n        sentence = String.join(\" \",str);\\n        return sentence;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] str = sentence.split(\" \");\\n        String res=\"\";\\n        double dis = discount/100.0;\\n        outer :\\n        for(int i=0;i<str.length;i++){\\n            if(str[i].charAt(0)==\\'\\n```\n``` + s;\\n                str[i]=res;\\n            }\\n        }\\n        sentence = String.join(\" \",str);\\n        return sentence;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315161,
                "title": "js-solution-based-on-copying-and-replacing-easy-to-understand",
                "content": "\\n```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n\\n    let indexs = []\\n    let sentenceCopy = sentence\\n    let subSentence\\n    let space\\n\\n    let idx = sentenceCopy.indexOf(\\'\\n```)\\n\\n    while (idx !== -1) {\\n        idx = sentenceCopy.indexOf(\\'\\n```)\\n        if (sentence.charAt(idx - 1) === \\' \\' || idx === 0) {\\n            subSentence = sentence.substring(idx + 1)\\n            space = subSentence.indexOf(\\' \\')\\n            console.log(\\'idx\\', idx )\\n            console.log(\\'space\\', space )\\n            realNo = sentence.substring(idx + 1, space !== -1 ? idx + 1 + space : sentence.length) \\n            console.log(\\'+++++\\', !((realNo+\\'\\').includes(\\'e\\')))\\n             console.log(\\'realNo\\', realNo )\\n            if (realNo- \\'\\' && !(/[a-zA-Z]/g.test(realNo+\\'\\'))) {\\n                realNo = (realNo - (realNo * (discount / 100))).toFixed(2)\\n\\n                sentence = sentence.substring(0, idx + 1) + realNo + (space !== -1 ? sentence.substring(idx + 1 + space, sentence.length) : \\'\\')\\n                sentenceCopy = sentenceCopy.substring(0, idx + 1) + realNo + (space !== -1 ? sentenceCopy.substring(idx + 1 + space, sentenceCopy.length) : \\'\\')\\n            }\\n        }\\n        sentenceCopy = sentenceCopy.replace(\\'\\n```, \\'@\\')\\n        idx = sentenceCopy.indexOf(\\'\\n```)\\n\\n\\n    }\\n\\n\\n\\n    return sentence\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sentence\\n * @param {number} discount\\n * @return {string}\\n */\\nvar discountPrices = function(sentence, discount) {\\n\\n    let indexs = []\\n    let sentenceCopy = sentence\\n    let subSentence\\n    let space\\n\\n    let idx = sentenceCopy.indexOf(\\'\\n```\n```)\\n        if (sentence.charAt(idx - 1) === \\' \\' || idx === 0) {\\n            subSentence = sentence.substring(idx + 1)\\n            space = subSentence.indexOf(\\' \\')\\n            console.log(\\'idx\\', idx )\\n            console.log(\\'space\\', space )\\n            realNo = sentence.substring(idx + 1, space !== -1 ? idx + 1 + space : sentence.length) \\n            console.log(\\'+++++\\', !((realNo+\\'\\').includes(\\'e\\')))\\n             console.log(\\'realNo\\', realNo )\\n            if (realNo- \\'\\' && !(/[a-zA-Z]/g.test(realNo+\\'\\'))) {\\n                realNo = (realNo - (realNo * (discount / 100))).toFixed(2)\\n\\n                sentence = sentence.substring(0, idx + 1) + realNo + (space !== -1 ? sentence.substring(idx + 1 + space, sentence.length) : \\'\\')\\n                sentenceCopy = sentenceCopy.substring(0, idx + 1) + realNo + (space !== -1 ? sentenceCopy.substring(idx + 1 + space, sentenceCopy.length) : \\'\\')\\n            }\\n        }\\n        sentenceCopy = sentenceCopy.replace(\\'\\n```\n```)\\n\\n\\n    }\\n\\n\\n\\n    return sentence\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293279,
                "title": "easy-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        split = sentence.split(\\' \\')\\n        res = []\\n\\n        def func(word):\\n            num = int(word[1:])\\n            return f\"$%.2f\"% (num * (100 - discount) / 100)\\n\\n        for word in split:\\n            if word[0] == \\'\\n``` and word[1:].isnumeric(): res.append(func(word))\\n            else: res.append(word)\\n\\n        return \\' \\'.join(res)\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        split = sentence.split(\\' \\')\\n        res = []\\n\\n        def func(word):\\n            num = int(word[1:])\\n            return f\"$%.2f\"% (num * (100 - discount) / 100)\\n\\n        for word in split:\\n            if word[0] == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253027,
                "title": "here-is-my-java-solution-using-decimalformat",
                "content": "```\\nclass Solution {\\n   private final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        if (sentence == null) return null;\\n        String[] s = sentence.split(\"\\\\\\\\s+\");\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            if (!word.startsWith(\"$\"))\\n                sb.append(word);\\n            else {\\n                if (examine(word)) {\\n                    if (discount == 100)\\n                        sb.append(\"$0.00\");\\n                    else {\\n                        String newPrice = calculate(word, discount);\\n                        sb.append(\"$\").append(newPrice);\\n                    }\\n                } else\\n                    sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private String calculate(String word, int discount) {\\n        word = word.substring(1);\\n        double oldPrice = Double.parseDouble(word);\\n        double discounted = oldPrice * (discount / 100D);\\n        double newPrice = oldPrice - discounted;\\n        return DECIMAL_FORMAT.format(newPrice);\\n    }\\n\\n    private boolean examine(String word) {\\n        String subsequence = word.substring(1);\\n        // \"there is $5 price on $\"\\n        if (subsequence.isEmpty())\\n            return false;\\n        // convert subsequence to character array.\\n        char[] characters = subsequence.toCharArray();\\n        for (char letter : characters) {\\n            if (!Character.isDigit(letter))\\n                return false;\\n        }\\n        // All letters are digits\\n       return true;\\n    }\\n}\\n```\\n\\n**Please Upvote if it helps.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n   private final DecimalFormat DECIMAL_FORMAT = new DecimalFormat(\"0.00\");\\n    public String discountPrices(String sentence, int discount) {\\n        if (sentence == null) return null;\\n        String[] s = sentence.split(\"\\\\\\\\s+\");\\n\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : s) {\\n            if (!word.startsWith(\"$\"))\\n                sb.append(word);\\n            else {\\n                if (examine(word)) {\\n                    if (discount == 100)\\n                        sb.append(\"$0.00\");\\n                    else {\\n                        String newPrice = calculate(word, discount);\\n                        sb.append(\"$\").append(newPrice);\\n                    }\\n                } else\\n                    sb.append(word);\\n            }\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private String calculate(String word, int discount) {\\n        word = word.substring(1);\\n        double oldPrice = Double.parseDouble(word);\\n        double discounted = oldPrice * (discount / 100D);\\n        double newPrice = oldPrice - discounted;\\n        return DECIMAL_FORMAT.format(newPrice);\\n    }\\n\\n    private boolean examine(String word) {\\n        String subsequence = word.substring(1);\\n        // \"there is $5 price on $\"\\n        if (subsequence.isEmpty())\\n            return false;\\n        // convert subsequence to character array.\\n        char[] characters = subsequence.toCharArray();\\n        for (char letter : characters) {\\n            if (!Character.isDigit(letter))\\n                return false;\\n        }\\n        // All letters are digits\\n       return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240704,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] a = sentence.split(\" \");\\n        for (int i = 0; i < a.length; i++) {\\n            char c = a[i].charAt(0);\\n            String s = a[i].substring(1);\\n            if(c == \\'$\\') {\\n                try {\\n                    long l = Long.parseLong(s);\\n                    double d = l - (double) l * discount / 100;\\n                    a[i] = \"$\" + String.format(\"%.2f\", d);\\n                } catch (NumberFormatException e) {\\n\\n                }\\n            }\\n        }\\n        return String.join(\" \", a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] a = sentence.split(\" \");\\n        for (int i = 0; i < a.length; i++) {\\n            char c = a[i].charAt(0);\\n            String s = a[i].substring(1);\\n            if(c == \\'$\\') {\\n                try {\\n                    long l = Long.parseLong(s);\\n                    double d = l - (double) l * discount / 100;\\n                    a[i] = \"$\" + String.format(\"%.2f\", d);\\n                } catch (NumberFormatException e) {\\n\\n                }\\n            }\\n        }\\n        return String.join(\" \", a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238716,
                "title": "c",
                "content": "```\\nclass Solution {\\n    int Precision = 2 ;\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string ans ; \\n        istringstream iss(sentence) ;\\n        string word ;\\n        while(iss >> word){\\n            bool flag = true ;\\n            if(word[0] == \\'$\\' && word.length() > 1)\\n            {                               \\n                for(int i = 1; i < word.length(); i++){\\n                    if(word[i] < \\'0\\' || word[i] > \\'9\\'){\\n                        flag = false ;\\n                        break ;\\n                    }\\n                } \\n                \\n            }\\n            else\\n                flag = false ;\\n            if(flag)\\n            {\\n                double val = stold(word.substr(1)) * (100 - discount) / 100 + 0.005 ;\\n                string s = to_string(val) ;\\n                string format = s.substr(0, s.find(\".\") + Precision + 1) ;\\n                ans += \"$\" + format + \" \" ;\\n            }\\n            else\\n                ans += word + \" \" ;\\n        }\\n        ans.pop_back() ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int Precision = 2 ;\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string ans ; \\n        istringstream iss(sentence) ;\\n        string word ;\\n        while(iss >> word){\\n            bool flag = true ;\\n            if(word[0] == \\'$\\' && word.length() > 1)\\n            {                               \\n                for(int i = 1; i < word.length(); i++){\\n                    if(word[i] < \\'0\\' || word[i] > \\'9\\'){\\n                        flag = false ;\\n                        break ;\\n                    }\\n                } \\n                \\n            }\\n            else\\n                flag = false ;\\n            if(flag)\\n            {\\n                double val = stold(word.substr(1)) * (100 - discount) / 100 + 0.005 ;\\n                string s = to_string(val) ;\\n                string format = s.substr(0, s.find(\".\") + Precision + 1) ;\\n                ans += \"$\" + format + \" \" ;\\n            }\\n            else\\n                ans += word + \" \" ;\\n        }\\n        ans.pop_back() ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237639,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sent = sentence.split(\\' \\')\\n        for i in range(len(sent)):\\n            if sent[i].startswith(\\'\\n```) and sent[i][1:].isdigit():\\n                sent[i] = f\\'${float(sent[i][1:]) * (1- discount/100):.2f}\\'\\n        sent = \\' \\'.join(sent)\\n        return sent\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sent = sentence.split(\\' \\')\\n        for i in range(len(sent)):\\n            if sent[i].startswith(\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235227,
                "title": "memory-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\n\\n        for(int i=0; i<sentence.size()-1; i++){\\n\\n\\n            if(sentence[i]==\\'\\n```){\\n                 int j=i+1;\\n                 double price=0;\\n                 while(sentence[j]>=\\'0\\'&&sentence[j]<=\\'9\\'){\\n                     price=price*10+sentence[j]-\\'0\\';\\n                     j++;\\n                     }\\n                 if(((sentence[j]==\\' \\'||j>=sentence.size())&&j!=i+1)&&((i==0)||(i>0&&sentence[i-1]==\\' \\'))){\\n                     price=price-price*discount*0.01;\\n                     stringstream ss;      \\n                     string str;\\n                     ss<<fixed<<setprecision(2)<<price;\\n                     ss>>str;\\n                     sentence.replace(i+1,j-i-1,str);\\n                     }\\n\\n                \\n                 }\\n\\n        }\\n         return sentence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n\\n\\n        for(int i=0; i<sentence.size()-1; i++){\\n\\n\\n            if(sentence[i]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234005,
                "title": "string-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n         String[] words = sentence.split(\" \");\\n         for (int i = 0; i < words.length; i++) {\\n              String word = words[i];\\n              if(word.startsWith(\"$\")) {\\n                    String priceStr = word.substring(1); \\n                    if (priceStr.matches(\"\\\\\\\\d+\")) { \\n                    double price = Double.parseDouble(priceStr);\\n                    price *= (100 - discount) / 100.0;\\n                    String updatedPriceStr = String.format(\"$%.2f\", price);\\n                    words[i] = updatedPriceStr;\\n            }\\n        }\\n    }\\n    return String.join(\" \", words);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n         String[] words = sentence.split(\" \");\\n         for (int i = 0; i < words.length; i++) {\\n              String word = words[i];\\n              if(word.startsWith(\"$\")) {\\n                    String priceStr = word.substring(1); \\n                    if (priceStr.matches(\"\\\\\\\\d+\")) { \\n                    double price = Double.parseDouble(priceStr);\\n                    price *= (100 - discount) / 100.0;\\n                    String updatedPriceStr = String.format(\"$%.2f\", price);\\n                    words[i] = updatedPriceStr;\\n            }\\n        }\\n    }\\n    return String.join(\" \", words);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232718,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport re\\n\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        dummy_list = sentence.split(\" \")\\n        for i, word in enumerate(dummy_list):\\n            if word.startswith(\"$\") and word[1:].isdigit():\\n                price = int(word[1:])\\n                discount_price = (price - (price/100) * discount)\\n                dummy_list[i] = \"$\" + \"{:.2f}\".format(discount_price)\\n        result = \" \".join(dummy_list)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport re\\n\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        dummy_list = sentence.split(\" \")\\n        for i, word in enumerate(dummy_list):\\n            if word.startswith(\"$\") and word[1:].isdigit():\\n                price = int(word[1:])\\n                discount_price = (price - (price/100) * discount)\\n                dummy_list[i] = \"$\" + \"{:.2f}\".format(discount_price)\\n        result = \" \".join(dummy_list)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225584,
                "title": "waste-of-time",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    string ans;\\n    string discountPrices(string s, int discount) \\n    {\\n         ans = \"\";\\n         int idx = 0;\\n         while(idx < s.length())\\n         {\\n             string str=\"\";\\n             bool letter = false;\\n             int dollarcount = 0;\\n\\n             while(idx < (s.length()) and s[idx]!=\\' \\')\\n             {\\n                 if(s[idx]>=\\'a\\' and s[idx]<=\\'z\\')\\n                 letter = true;\\n\\n                 if(s[idx] == \\'\\n```)\\n                 dollarcount++;\\n\\n                 str.push_back(s[idx]);\\n                 idx++;\\n             }\\n             while(idx < (s.length()) and s[idx] ==\\' \\')\\n             {\\n                 idx++;\\n             }\\n             //if the word is consist any of the lowercase letter\\n             if(str.length()>0 and (letter == true or (dollarcount==0 or dollarcount>1) or (dollarcount==1 and str[0]!=\\'\\n```)))\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else if(str.length()>0 and (dollarcount==1 and str[0]==\\'\\n```) and str.length()>1)\\n             {\\n                 string tempstr = str.substr(1,str.length());\\n                 long long val = stoll(tempstr);\\n                 double tempval = val - (((val*discount)/100.00)) + 0.001;\\n                 string dis_str = \"$\";\\n                 dis_str.append(to_string(tempval));\\n\\n\\n                 string newstr = \"\";\\n                 bool decimal = false;\\n                 int count = 0;\\n\\n                 for(int i=0;i<dis_str.length();i++)\\n                 {\\n                     if(dis_str[i] == \\'.\\')\\n                     {\\n                        decimal = true;\\n                        newstr.push_back(dis_str[i]);\\n                     }\\n                     else\\n                     {\\n                         if(decimal == true)\\n                         count++;\\n\\n                         newstr.push_back(dis_str[i]);\\n                     }\\n                     if(count >= 2)\\n                     break;\\n                 }\\n                 ans.append(newstr);\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             \\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    string ans;\\n    string discountPrices(string s, int discount) \\n    {\\n         ans = \"\";\\n         int idx = 0;\\n         while(idx < s.length())\\n         {\\n             string str=\"\";\\n             bool letter = false;\\n             int dollarcount = 0;\\n\\n             while(idx < (s.length()) and s[idx]!=\\' \\')\\n             {\\n                 if(s[idx]>=\\'a\\' and s[idx]<=\\'z\\')\\n                 letter = true;\\n\\n                 if(s[idx] == \\'\\n```\n```)))\\n             {\\n                 ans.append(str);\\n\\n                 if(idx < s.length())\\n                 {\\n                     ans.push_back(\\' \\');\\n                 }\\n             }\\n             else if(str.length()>0 and (dollarcount==1 and str[0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215744,
                "title": "simple-python-solution-using-slicing-and-format",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        arr=sentence.split(\" \")\\n      \\n        for i in range(len(arr)):\\n            # print(arr[i][1:])\\n            if arr[i][0]==\\'\\n``` and (arr[i][1:]).isdigit():\\n\\n                a=int(arr[i][1:])\\n                b=(a*(100-discount))/100.0\\n                # print(b)\\n                b=format(b, \\'.2f\\')\\n                # print(b)\\n                arr[i]=\"$\"+str(b)\\n        return \" \".join(arr)        \\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        arr=sentence.split(\" \")\\n      \\n        for i in range(len(arr)):\\n            # print(arr[i][1:])\\n            if arr[i][0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185554,
                "title": "easy-to-understand-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String out  = \"\";\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].charAt(0)==\\'\\n``` && arr[i].length()>1){\\n                int count = 0,check = 0;\\n                for(int j=1;j<arr[i].length();j++){\\n                    if(arr[i].charAt(j)==\\'\\n```){\\n                        count++;\\n                    }\\n                    if((arr[i].charAt(j)<48 || arr[i].charAt(j)>57)){\\n                        check++;\\n                    }\\n                }\\n                if(count==0 && check==0){\\n                    Long g = Long.parseLong(arr[i].substring(1));\\n                    if(discount==100){\\n                        out += \"$0.00 \";\\n                    }else{\\n                        double ans = g - discount * 0.01 * g;\\n                        out += \"$\";\\n                        out += String.format(\"%.2f\",ans);\\n                        out+=\" \";\\n                    }\\n                    }else{\\n                        out+=arr[i] + \" \";\\n                    }\\n            }else{\\n                out+=arr[i] + \" \";\\n            }\\n        }\\n        return out.trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String arr[] = sentence.split(\" \");\\n        String out  = \"\";\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i].charAt(0)==\\'\\n```\n```){\\n                        count++;\\n                    }\\n                    if((arr[i].charAt(j)<48 || arr[i].charAt(j)>57)){\\n                        check++;\\n                    }\\n                }\\n                if(count==0 && check==0){\\n                    Long g = Long.parseLong(arr[i].substring(1));\\n                    if(discount==100){\\n                        out += \"$0.00 \";\\n                    }else{\\n                        double ans = g - discount * 0.01 * g;\\n                        out += \"$\";\\n                        out += String.format(\"%.2f\",ans);\\n                        out+=\" \";\\n                    }\\n                    }else{\\n                        out+=arr[i] + \" \";\\n                    }\\n            }else{\\n                out+=arr[i] + \" \";\\n            }\\n        }\\n        return out.trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181895,
                "title": "single-line-python-code-string-split-type-casting-replace-join",
                "content": "# Approach\\n<!-- Single line Python code -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n)-->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join([\"$%.2f\"%(float(i[1:]) * (1-(discount/100))) if i.startswith(\\'$\\') and i[1:].isdigit() else i for i in sentence.split(\\' \\')])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join([\"$%.2f\"%(float(i[1:]) * (1-(discount/100))) if i.startswith(\\'$\\') and i[1:].isdigit() else i for i in sentence.split(\\' \\')])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173377,
                "title": "clean-c-code-learn-to-set-precision",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtract each word from the string seperated by whitespace (\\' \\').\\nIf that word is price then apply the discount and then add it to the resultant string otherwise just add the word as it is to the resultant string.\\n\\nNOTE: Take care of the last word seperately.\\n\\n***Please do upvote my solution in case you liked it !***\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void applyDiscount(string &res, string &t, long double price, int discount, bool& f) {\\n        if(f == 0) res += t;\\n        else if(t.size()>1){\\n            string st = t.substr(1,t.size()-1);\\n            price = stoll(st);\\n            price = price * ((100-discount)/100.0);\\n            stringstream tt;\\n            tt << fixed << setprecision(2) << price;\\n            res.append(1,\\'$\\');\\n            res += tt.str();\\n        }else {\\n            res.append(1,\\'$\\');\\n        }\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string t = \"\";\\n        bool f = 1;\\n        long double price;\\n        for(char &ch:sentence) {\\n            if(ch == \\' \\') {\\n                applyDiscount(res,t,price,discount,f);\\n                t = \"\";\\n                f = 1;\\n                res += ch;\\n            } else {\\n                if(t.empty()) {\\n                    if(ch != \\'$\\') {\\n                        f = 0;\\n                        t += ch;\\n                    }else {\\n                        t += ch;\\n                    }\\n                } else {\\n                    if(ch>=\\'0\\' && ch<=\\'9\\') {\\n                        t += ch;\\n                    } else {\\n                        f = 0;\\n                        t += ch;\\n                    }\\n                }\\n            }\\n        }\\n        applyDiscount(res,t,price,discount,f);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void applyDiscount(string &res, string &t, long double price, int discount, bool& f) {\\n        if(f == 0) res += t;\\n        else if(t.size()>1){\\n            string st = t.substr(1,t.size()-1);\\n            price = stoll(st);\\n            price = price * ((100-discount)/100.0);\\n            stringstream tt;\\n            tt << fixed << setprecision(2) << price;\\n            res.append(1,\\'$\\');\\n            res += tt.str();\\n        }else {\\n            res.append(1,\\'$\\');\\n        }\\n    }\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        string res = \"\";\\n        string t = \"\";\\n        bool f = 1;\\n        long double price;\\n        for(char &ch:sentence) {\\n            if(ch == \\' \\') {\\n                applyDiscount(res,t,price,discount,f);\\n                t = \"\";\\n                f = 1;\\n                res += ch;\\n            } else {\\n                if(t.empty()) {\\n                    if(ch != \\'$\\') {\\n                        f = 0;\\n                        t += ch;\\n                    }else {\\n                        t += ch;\\n                    }\\n                } else {\\n                    if(ch>=\\'0\\' && ch<=\\'9\\') {\\n                        t += ch;\\n                    } else {\\n                        f = 0;\\n                        t += ch;\\n                    }\\n                }\\n            }\\n        }\\n        applyDiscount(res,t,price,discount,f);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173100,
                "title": "beats-65-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discounter(self,price,discount):\\n        # price = (ch/1.00) - (ch*(disc/100.00))\\n\\n        return \"${:.2f}\".format(price-price*discount/100)\\n\\n\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.split()\\n        ans = \"\"\\n        for i in lst:\\n            if(i[0] != \"$\" or len(i) == 1):\\n                ans += i\\n                \\n            \\n            elif(not i[1:].isdigit()):\\n                ans += i\\n            \\n            else:\\n                num = self.discounter(int(i[1:]),discount)\\n\\n                ans += num\\n\\n            ans += \" \"\\n\\n        return ans[:-1]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discounter(self,price,discount):\\n        # price = (ch/1.00) - (ch*(disc/100.00))\\n\\n        return \"${:.2f}\".format(price-price*discount/100)\\n\\n\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        lst = sentence.split()\\n        ans = \"\"\\n        for i in lst:\\n            if(i[0] != \"$\" or len(i) == 1):\\n                ans += i\\n                \\n            \\n            elif(not i[1:].isdigit()):\\n                ans += i\\n            \\n            else:\\n                num = self.discounter(int(i[1:]),discount)\\n\\n                ans += num\\n\\n            ans += \" \"\\n\\n        return ans[:-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163288,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\nvar discountPrices = function(sentence, discount) {\\n    let d = (100 - discount)/100\\n    sentence = sentence.split(\" \")\\n    let n = \"\"\\n    let m = 0\\n    for(let i = 0 ; i < sentence.length ;i++){\\n        if(sentence[i][0] != \"$\" ){continue}\\n        n = sentence[i].slice(1)\\n        if(+n){\\n            if(n.indexOf(\"e\")!= -1){continue}\\n            if(n.indexOf(\"x\") != -1){continue}\\n            m = +n*d\\n           sentence[i] = \"$\"+ m.toFixed(2)\\n        }\\n    }\\n    return sentence.join(\" \")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar discountPrices = function(sentence, discount) {\\n    let d = (100 - discount)/100\\n    sentence = sentence.split(\" \")\\n    let n = \"\"\\n    let m = 0\\n    for(let i = 0 ; i < sentence.length ;i++){\\n        if(sentence[i][0] != \"$\" ){continue}\\n        n = sentence[i].slice(1)\\n        if(+n){\\n            if(n.indexOf(\"e\")!= -1){continue}\\n            if(n.indexOf(\"x\") != -1){continue}\\n            m = +n*d\\n           sentence[i] = \"$\"+ m.toFixed(2)\\n        }\\n    }\\n    return sentence.join(\" \")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161047,
                "title": "just-a-beginner",
                "content": "# Intuition\\nNot a an optimized solution but just from the basics of Theory Of Computation it became solvable!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] array = sentence.split(\" \");\\n        for(int i = 0; i<array.length; i++){\\n            if(array[i].matches(\"\\\\\\\\$[1-9][0-9]*\")){\\n                double res = Double.parseDouble(array[i].substring(1));\\n                res -= (res*(double)discount)/100;\\n                array[i] = \"$\"+String.format(\"%.2f\",res);\\n            }\\n        }\\n        return String.join(\" \",array);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] array = sentence.split(\" \");\\n        for(int i = 0; i<array.length; i++){\\n            if(array[i].matches(\"\\\\\\\\$[1-9][0-9]*\")){\\n                double res = Double.parseDouble(array[i].substring(1));\\n                res -= (res*(double)discount)/100;\\n                array[i] = \"$\"+String.format(\"%.2f\",res);\\n            }\\n        }\\n        return String.join(\" \",array);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115390,
                "title": "python-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        #Divide and Conquer\\n        #Find all $ signs\\n        #Check if $sign is proceeded by just a number\\n        #Convert the price to int and apply the discount\\n        #Add the new price back into the sentence\\n\\n\\n        sentence = sentence.split()\\n        \\n        for i, word in enumerate(sentence):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                org_price = word[1:]\\n                new_price = \\'$\\'+f\\'{round(int(org_price)*(1-discount/100),2):.2f}\\'\\n                sentence[i] = new_price\\n\\n        return \\' \\'.join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        #Divide and Conquer\\n        #Find all $ signs\\n        #Check if $sign is proceeded by just a number\\n        #Convert the price to int and apply the discount\\n        #Add the new price back into the sentence\\n\\n\\n        sentence = sentence.split()\\n        \\n        for i, word in enumerate(sentence):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                org_price = word[1:]\\n                new_price = \\'$\\'+f\\'{round(int(org_price)*(1-discount/100),2):.2f}\\'\\n                sentence[i] = new_price\\n\\n        return \\' \\'.join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112988,
                "title": "302-ms-string-gsub",
                "content": "```ruby\\ndef discount_prices(s, d) =\\n    s.gsub(/^\\\\$\\\\d+$|^\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+$/) do\\n        x = _1[1..].to_i\\n        \\'$%.2f\\' % [x - x * (d/100r)]\\n    end\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef discount_prices(s, d) =\\n    s.gsub(/^\\\\$\\\\d+$|^\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+(?=\\\\s)|(?<=\\\\s)\\\\$\\\\d+$/) do\\n        x = _1[1..].to_i\\n        \\'$%.2f\\' % [x - x * (d/100r)]\\n    end\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3112068,
                "title": "easy-and-short-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        double dis=(100-discount)*0.01d;\\n        String str[]=sentence.split(\" \");\\n        StringBuilder newString=new StringBuilder();\\n        for(String s:str){\\n            if(s.length()>1 && s.charAt(0)==\\'\\n```){\\n                double sum=0f;\\n                int i=1;\\n                while(i<s.length() && Character.isDigit(s.charAt(i)))    sum=sum*10f+(s.charAt(i++)-\\'0\\');\\n                if(i==s.length()){\\n                    sum=sum*dis;\\n                    newString.append(\" $\"+String.format(\"%.2f\",sum));\\n                }\\n                else     newString.append(\" \"+s);\\n            }\\n            else    newString.append(\" \"+s);\\n        }\\n        return newString.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        double dis=(100-discount)*0.01d;\\n        String str[]=sentence.split(\" \");\\n        StringBuilder newString=new StringBuilder();\\n        for(String s:str){\\n            if(s.length()>1 && s.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081432,
                "title": "python-solution-using-regex",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        discount = 1 - (discount/100)\\n        sentence = sentence.split()\\n        \\n        for idx, price in enumerate(sentence):\\n\\n            # does exactly same as \\n            # price[0] == \\'$\\' and price[1:].isdigit()\\n            if re.match(\\'^[$]\\\\d{1,10}$\\',price):\\n                sentence[idx] = \"${:.2f}\".format(int(price[1:])*discount)\\n             \\n        return \\' \\'.join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        discount = 1 - (discount/100)\\n        sentence = sentence.split()\\n        \\n        for idx, price in enumerate(sentence):\\n\\n            # does exactly same as \\n            # price[0] == \\'$\\' and price[1:].isdigit()\\n            if re.match(\\'^[$]\\\\d{1,10}$\\',price):\\n                sentence[idx] = \"${:.2f}\".format(int(price[1:])*discount)\\n             \\n        return \\' \\'.join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069178,
                "title": "javascript-100-runtime-regex",
                "content": "\\n```\\nconst discountPrices = (str, d) =>\\n  str.split(\" \").reduce((a, c, i, arr) => {\\n    if (/^\\\\$\\\\d+$/.test(c))\\n      c = \"$\" + ((+c.substring(1) * (100 - d)) / 100).toFixed(2);\\n    return (a += c + (i == arr.length - 1 ? \"\" : \" \"));\\n  }, \"\");\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst discountPrices = (str, d) =>\\n  str.split(\" \").reduce((a, c, i, arr) => {\\n    if (/^\\\\$\\\\d+$/.test(c))\\n      c = \"$\" + ((+c.substring(1) * (100 - d)) / 100).toFixed(2);\\n    return (a += c + (i == arr.length - 1 ? \"\" : \" \"));\\n  }, \"\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3053660,
                "title": "java-easy-to-understand-straight-forward-loop-and-discount-calculation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        sentence = sentence.trim();\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word : words){\\n            if(!word.isEmpty() && word.charAt(0) == \\'$\\'){\\n                long amount = 0;\\n                boolean isValid = true;\\n                int index = 1;\\n                int n = word.length();\\n                while(index < n){\\n                    //if the amount is any char but not a digit then this word\\n                    //is invalid word and no discount should be considered\\n                    if(!Character.isDigit(word.charAt(index))) {\\n                        isValid = false;\\n                        break;\\n                    }\\n                    //create the amount from curr word\\n                    amount = (amount * 10l) + (word.charAt(index) - \\'0\\');\\n                    index++;\\n                }\\n\\n                //if the curr word is not a valid denomination OR amount is 0\\n                //ex: \"100\", \"$\", \"$1e5\", \"$10$\" \\n                if(!isValid || amount == 0) {\\n                    sb.append(word).append(\" \");\\n                    continue;\\n                }\\n\\n                double reducedAmount = ((double) amount * ((double) discount / 100.0));\\n                double discountAmount = (double) amount - reducedAmount;\\n                String discountAmountString = String.format(\"%.2f\", discountAmount);\\n                sb.append(\\'$\\').append(discountAmountString).append(\" \");\\n\\n            } else {\\n                sb.append(word).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n        sentence = sentence.trim();\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for(String word : words){\\n            if(!word.isEmpty() && word.charAt(0) == \\'$\\'){\\n                long amount = 0;\\n                boolean isValid = true;\\n                int index = 1;\\n                int n = word.length();\\n                while(index < n){\\n                    //if the amount is any char but not a digit then this word\\n                    //is invalid word and no discount should be considered\\n                    if(!Character.isDigit(word.charAt(index))) {\\n                        isValid = false;\\n                        break;\\n                    }\\n                    //create the amount from curr word\\n                    amount = (amount * 10l) + (word.charAt(index) - \\'0\\');\\n                    index++;\\n                }\\n\\n                //if the curr word is not a valid denomination OR amount is 0\\n                //ex: \"100\", \"$\", \"$1e5\", \"$10$\" \\n                if(!isValid || amount == 0) {\\n                    sb.append(word).append(\" \");\\n                    continue;\\n                }\\n\\n                double reducedAmount = ((double) amount * ((double) discount / 100.0));\\n                double discountAmount = (double) amount - reducedAmount;\\n                String discountAmountString = String.format(\"%.2f\", discountAmount);\\n                sb.append(\\'$\\').append(discountAmountString).append(\" \");\\n\\n            } else {\\n                sb.append(word).append(\" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051485,
                "title": "c-most-simple-code-easy-to-understand-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        int n=s.size();\\n        string ans;\\n        s+=\\' \\';\\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'$`){\\n                 if(i==0||s[i-1]==\\' \\' ){\\n                 i++;\\n                 double l=0;\\n                 string d=\"$\";\\n                 if(i==n){\\n                     ans+=`$`;\\n                     return ans;\\n                 }\\n                 while(i<n&&s[i]>=\\'0\\'&&s[i]<=\\'9\\'&&s[i]!=\\' \\'||s[i]==\\'.\\'){\\n                     d+=s[i];\\n                     l=l*10+s[i]-\\'0\\';\\n                     i++;\\n                 }\\n                 if(s[i]==\\' \\'&&l!=0){\\n                   double dis = (double)((double)(discount) / 100) * (double)l;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) l- dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans+=\\'$`;\\n                    ans+=out.str();\\n                    if(i==n)\\n                    break;\\n                 }\\n                 else{\\n                     ans+=d;\\n                 }\\n             }\\n         }\\n                if(i==n)\\n                     break;\\n             ans+=s[i];\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int discount) {\\n        int n=s.size();\\n        string ans;\\n        s+=\\' \\';\\n         for(int i=0;i<n;i++){\\n             if(s[i]==\\'$`){\\n                 if(i==0||s[i-1]==\\' \\' ){\\n                 i++;\\n                 double l=0;\\n                 string d=\"$\";\\n                 if(i==n){\\n                     ans+=`$`;\\n                     return ans;\\n                 }\\n                 while(i<n&&s[i]>=\\'0\\'&&s[i]<=\\'9\\'&&s[i]!=\\' \\'||s[i]==\\'.\\'){\\n                     d+=s[i];\\n                     l=l*10+s[i]-\\'0\\';\\n                     i++;\\n                 }\\n                 if(s[i]==\\' \\'&&l!=0){\\n                   double dis = (double)((double)(discount) / 100) * (double)l;\\n\\t\\t\\t\\t\\t// Calculate the new price\\n                    double newp = (double) l- dis;\\n                    stringstream out;\\n\\t\\t\\t\\t\\t// Out the new price to a stringstream variable with precision 2\\n                    out << std::fixed << std::setprecision(2) << newp;\\n\\t\\t\\t\\t\\t// Append to the answer\\n                    ans+=\\'$`;\\n                    ans+=out.str();\\n                    if(i==n)\\n                    break;\\n                 }\\n                 else{\\n                     ans+=d;\\n                 }\\n             }\\n         }\\n                if(i==n)\\n                     break;\\n             ans+=s[i];\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050984,
                "title": "constructive-algorithm-easy-short-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long extract_price(string &str){\\n        if(str[0] != \\'$\\' || str.size() == 1){\\n            return -1;\\n        }\\n        long long p = 0;\\n        for(int i = 1; i < str.size(); ++i){\\n            if(str[i] >= \\'0\\' && str[i] <= \\'9\\'){\\n                p = p * 10 + (str[i] - \\'0\\');\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return p;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> v;\\n        string word = \"\";\\n        for(int i = 0; i < sentence.size(); ++i){\\n            if(sentence[i] == \\' \\'){\\n                v.push_back(word);\\n                word = \"\";\\n            }\\n            else{\\n                word += sentence[i];\\n            }\\n        }\\n        v.push_back(word);\\n        for(int i = 0; i < v.size(); ++i){\\n            long long price = extract_price(v[i]);\\n            if(price != -1){\\n                price *= (100 - discount);\\n                string s = \"\";\\n                int cnt = 0;\\n                while(price){\\n                    s += (\\'0\\' + (price % 10));\\n                    price /= 10;\\n                    cnt++;\\n                    if(cnt == 2){\\n                        s += \\'.\\';\\n                    }\\n                }\\n                if(s.size() == 0){\\n                    s = \"00.0\";\\n                }\\n                else if(s.size() == 1){\\n                    s = s + \"0.0\";\\n                }\\n                else if(s.size() == 3){\\n                    s.push_back(\\'0\\');\\n                }\\n                s.push_back(\\'$\\');\\n                reverse(s.begin(), s.end());\\n                v[i] = s;\\n            }\\n        }\\n        sentence = \"\";\\n        for(int i = 0; i < v.size(); ++i){\\n            sentence += v[i];\\n            sentence += \\' \\';\\n        }\\n        sentence.pop_back();  \\n        return sentence;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long extract_price(string &str){\\n        if(str[0] != \\'$\\' || str.size() == 1){\\n            return -1;\\n        }\\n        long long p = 0;\\n        for(int i = 1; i < str.size(); ++i){\\n            if(str[i] >= \\'0\\' && str[i] <= \\'9\\'){\\n                p = p * 10 + (str[i] - \\'0\\');\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n        return p;\\n    }\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> v;\\n        string word = \"\";\\n        for(int i = 0; i < sentence.size(); ++i){\\n            if(sentence[i] == \\' \\'){\\n                v.push_back(word);\\n                word = \"\";\\n            }\\n            else{\\n                word += sentence[i];\\n            }\\n        }\\n        v.push_back(word);\\n        for(int i = 0; i < v.size(); ++i){\\n            long long price = extract_price(v[i]);\\n            if(price != -1){\\n                price *= (100 - discount);\\n                string s = \"\";\\n                int cnt = 0;\\n                while(price){\\n                    s += (\\'0\\' + (price % 10));\\n                    price /= 10;\\n                    cnt++;\\n                    if(cnt == 2){\\n                        s += \\'.\\';\\n                    }\\n                }\\n                if(s.size() == 0){\\n                    s = \"00.0\";\\n                }\\n                else if(s.size() == 1){\\n                    s = s + \"0.0\";\\n                }\\n                else if(s.size() == 3){\\n                    s.push_back(\\'0\\');\\n                }\\n                s.push_back(\\'$\\');\\n                reverse(s.begin(), s.end());\\n                v[i] = s;\\n            }\\n        }\\n        sentence = \"\";\\n        for(int i = 0; i < v.size(); ++i){\\n            sentence += v[i];\\n            sentence += \\' \\';\\n        }\\n        sentence.pop_back();  \\n        return sentence;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032498,
                "title": "java-beats-94-easy-understand",
                "content": "I first manually writting down the part to convert the price to two decimal places, that is super annoying.\\nAfter i found out we could use format.\\nAlso, remember when you are parsing the price from String to Number, don\\'t parse it to Integer first because Integer is 32-bits, it can\\'t parse all 10 digits String number. Directly parse to Double will be fine.\\n\\n```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n\\t\\t// DecimalFormat used for formating to 2 decimal places\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        String[] split = sentence.split(\" \");\\n        for(int i = 0;i < split.length; ++i){\\n            if(split[i].charAt(0) != \\'$\\') continue;\\n            price:{\\n                StringBuilder builder = new StringBuilder();\\n\\t\\t\\t\\t// check wether the string is price or not\\n                for(int j = 1;j < split[i].length(); ++j){\\n                    char c = split[i].charAt(j);\\n                    if(!Character.isDigit(c)) break price;\\n                    builder.append(c);\\n                }\\n\\t\\t\\t\\t// there are cases where the processing string is a single \"$\"\\n                if(builder.length() == 0) continue;\\n                String digits = builder.toString();\\n                // doulbe has 64-bits,so it can handle 10 digits parse\\n                double price = Double.parseDouble(digits);\\n                double updatedPrice = price - (price*discount/100.0);\\n                String twoDecimal = String.valueOf(updatedPrice);\\n                builder.setLength(0);\\n                split[i] = \"$\" + String.valueOf(df.format(updatedPrice));\\n                \\n            }\\n        }\\n        \\n        return String.join(\" \", split);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n\\t\\t// DecimalFormat used for formating to 2 decimal places\\n        DecimalFormat df = new DecimalFormat(\"0.00\");\\n        String[] split = sentence.split(\" \");\\n        for(int i = 0;i < split.length; ++i){\\n            if(split[i].charAt(0) != \\'$\\') continue;\\n            price:{\\n                StringBuilder builder = new StringBuilder();\\n\\t\\t\\t\\t// check wether the string is price or not\\n                for(int j = 1;j < split[i].length(); ++j){\\n                    char c = split[i].charAt(j);\\n                    if(!Character.isDigit(c)) break price;\\n                    builder.append(c);\\n                }\\n\\t\\t\\t\\t// there are cases where the processing string is a single \"$\"\\n                if(builder.length() == 0) continue;\\n                String digits = builder.toString();\\n                // doulbe has 64-bits,so it can handle 10 digits parse\\n                double price = Double.parseDouble(digits);\\n                double updatedPrice = price - (price*discount/100.0);\\n                String twoDecimal = String.valueOf(updatedPrice);\\n                builder.setLength(0);\\n                split[i] = \"$\" + String.valueOf(df.format(updatedPrice));\\n                \\n            }\\n        }\\n        \\n        return String.join(\" \", split);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021451,
                "title": "python-3-beats-82-22-runtime-and-40-95-memory",
                "content": "# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        ret = \\'\\'\\n\\n        for i, word in enumerate(words):\\n            # place spaces before each word other than first\\n            if i != 0 and i != len(words):\\n                ret += \\' \\'\\n\\n            # if word begins with \\'$\\' followed by only digits, it\\'s a price\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:]) * ((100-discount) / 100)\\n                ret += f\\'${price:.2f}\\'\\n            else:\\n                ret += f\\'{word}\\'\\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        words = sentence.split(\\' \\')\\n        ret = \\'\\'\\n\\n        for i, word in enumerate(words):\\n            # place spaces before each word other than first\\n            if i != 0 and i != len(words):\\n                ret += \\' \\'\\n\\n            # if word begins with \\'$\\' followed by only digits, it\\'s a price\\n            if word[0] == \\'$\\' and word[1:].isdigit():\\n                price = int(word[1:]) * ((100-discount) / 100)\\n                ret += f\\'${price:.2f}\\'\\n            else:\\n                ret += f\\'{word}\\'\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018777,
                "title": "python3-easy-solution-explained",
                "content": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        # We start by putting every word in the sentence in a list\\n        sentence = sentence.split(\" \")\\n\\n        # The following two lists will store the prices and the \\n        # respective position in the sentence\\n        prices = []\\n        positions = []\\n\\n        # We search every price in the sentence\\n        for idx, word in enumerate(sentence):\\n\\n            # Easy way to check if it is a price and not something\\n            # strange\\n            if word[0] == \"$\" and word[1:].isnumeric():\\n                prices.append(word[1:])\\n                positions.append(idx)\\n\\n\\n        # We apply the discount to the prices\\n        for j in range(len(prices)):\\n\\n            prices[j] = format(int(prices[j])-int(prices[j])*discount/100, \\'.2f\\')\\n        \\n        # We remove the old prices with the now discounted prices\\n        for pos, pr in zip(positions, prices):\\n            sentence[pos] = \"$\"+pr\\n\\n        # We return the correct sentence :-)\\n        return \" \".join(sentence)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        # We start by putting every word in the sentence in a list\\n        sentence = sentence.split(\" \")\\n\\n        # The following two lists will store the prices and the \\n        # respective position in the sentence\\n        prices = []\\n        positions = []\\n\\n        # We search every price in the sentence\\n        for idx, word in enumerate(sentence):\\n\\n            # Easy way to check if it is a price and not something\\n            # strange\\n            if word[0] == \"$\" and word[1:].isnumeric():\\n                prices.append(word[1:])\\n                positions.append(idx)\\n\\n\\n        # We apply the discount to the prices\\n        for j in range(len(prices)):\\n\\n            prices[j] = format(int(prices[j])-int(prices[j])*discount/100, \\'.2f\\')\\n        \\n        # We remove the old prices with the now discounted prices\\n        for pos, pr in zip(positions, prices):\\n            sentence[pos] = \"$\"+pr\\n\\n        # We return the correct sentence :-)\\n        return \" \".join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012090,
                "title": "beat-90-conditions-of-a-valid-price",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\\' \\')\\n        ans=[]\\n        for w in sentence:\\n            if len(w)>1 and w.count(\\'\\n```)==1 and w[0]==\\'\\n``` and w[1:].isnumeric():\\n                amount=float(w[1:])\\n                amount*=(1-discount/float(100))\\n                ans.append(w[0]+(\"{:.2f}\".format(amount)))\\n\\n            else:\\n                ans.append(w)\\n        return \\' \\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\\' \\')\\n        ans=[]\\n        for w in sentence:\\n            if len(w)>1 and w.count(\\'\\n```\n``` and w[1:].isnumeric():\\n                amount=float(w[1:])\\n                amount*=(1-discount/float(100))\\n                ans.append(w[0]+(\"{:.2f}\".format(amount)))\\n\\n            else:\\n                ans.append(w)\\n        return \\' \\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006860,
                "title": "java-simple-approach-stringbuilder",
                "content": "# CODE :\\n```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder(); // final result;\\n        int n = sentence.length();\\n        \\n        for(int i =0;i<n;i++){\\n            char c = sentence.charAt(i);\\n            StringBuilder temp = new StringBuilder();\\n            temp.append(c);\\n            if(c == \\'$\\' && (i == 0 || (i-1 > 0 && sentence.charAt(i-1) == \\'\\\\s\\'))){ // check if previous char is space\\n                int start = ++i;\\n                while(i<n && (sentence.charAt(i) >= \\'0\\' && sentence.charAt(i) <= \\'9\\')  ){ // extracting number\\n                    temp.append(sentence.charAt(i));\\n                    i++;\\n                }\\n                if(start == i){ // if no number exist then continue\\n                    sb.append(temp);\\n                    i--;\\n                    continue;\\n                }\\n                if( (i < n && sentence.charAt(i) == \\'\\\\s\\') || i == n){ // if number is followed by space or end of sentence then only do calculation\\n                    BigDecimal bg = new BigDecimal(sentence.substring(start,i));\\n                    bg = bg.subtract((bg.multiply(new BigDecimal(String.valueOf(discount))).divide(new BigDecimal(String.valueOf(\"100\")))));\\n                    bg.setScale(2, BigDecimal.ROUND_UP);\\n                    String t = bg.toString();\\n                    String[] sp = t.split(\"\\\\\\\\.\");\\n                    if(sp.length == 1){ // if no decimal points are found then append 00 \\n                        sb.append(\"$\").append(bg.toString()).append(\".00\").append(i == n?\"\":\" \");    \\n                    } else{\\n                        sp[1] += \"00\"; // if number is has only one decimal then append 00 and consider only two of them;\\n                        sb.append(\"$\").append(sp[0]).append(\".\").append(sp[1].substring(0,2)).append(i == n?\"\":\" \");\\n                    }\\n                }else{\\n                    sb.append(temp); // if number is not followed by space or end of sentence do following\\n                    while(i<n && sentence.charAt(i) != \\'\\\\s\\'){\\n                        sb.append(sentence.charAt(i));\\n                        i++;\\n                    }\\n                    if(i<n && sentence.charAt(i) == \\'\\\\s\\'){\\n                        sb.append(\" \");\\n                    }\\n                    \\n                }\\n                \\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```\\n***Note : This is not the optimised solution, but anyone stuck with the similar approach can go through my solution.***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigDecimal;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        StringBuilder sb = new StringBuilder(); // final result;\\n        int n = sentence.length();\\n        \\n        for(int i =0;i<n;i++){\\n            char c = sentence.charAt(i);\\n            StringBuilder temp = new StringBuilder();\\n            temp.append(c);\\n            if(c == \\'$\\' && (i == 0 || (i-1 > 0 && sentence.charAt(i-1) == \\'\\\\s\\'))){ // check if previous char is space\\n                int start = ++i;\\n                while(i<n && (sentence.charAt(i) >= \\'0\\' && sentence.charAt(i) <= \\'9\\')  ){ // extracting number\\n                    temp.append(sentence.charAt(i));\\n                    i++;\\n                }\\n                if(start == i){ // if no number exist then continue\\n                    sb.append(temp);\\n                    i--;\\n                    continue;\\n                }\\n                if( (i < n && sentence.charAt(i) == \\'\\\\s\\') || i == n){ // if number is followed by space or end of sentence then only do calculation\\n                    BigDecimal bg = new BigDecimal(sentence.substring(start,i));\\n                    bg = bg.subtract((bg.multiply(new BigDecimal(String.valueOf(discount))).divide(new BigDecimal(String.valueOf(\"100\")))));\\n                    bg.setScale(2, BigDecimal.ROUND_UP);\\n                    String t = bg.toString();\\n                    String[] sp = t.split(\"\\\\\\\\.\");\\n                    if(sp.length == 1){ // if no decimal points are found then append 00 \\n                        sb.append(\"$\").append(bg.toString()).append(\".00\").append(i == n?\"\":\" \");    \\n                    } else{\\n                        sp[1] += \"00\"; // if number is has only one decimal then append 00 and consider only two of them;\\n                        sb.append(\"$\").append(sp[0]).append(\".\").append(sp[1].substring(0,2)).append(i == n?\"\":\" \");\\n                    }\\n                }else{\\n                    sb.append(temp); // if number is not followed by space or end of sentence do following\\n                    while(i<n && sentence.charAt(i) != \\'\\\\s\\'){\\n                        sb.append(sentence.charAt(i));\\n                        i++;\\n                    }\\n                    if(i<n && sentence.charAt(i) == \\'\\\\s\\'){\\n                        sb.append(\" \");\\n                    }\\n                    \\n                }\\n                \\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998866,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static final DecimalFormat decfor = new DecimalFormat(\"0.00\"); \\n    public String discountPrices(String sen, int discount) {\\n        StringBuffer sbf=new StringBuffer(\"\");\\n        String str=\"\";\\n        int n=sen.length();\\n        boolean flag=false;\\n        for(int i=0;i<n;i++){\\n        if(sen.charAt(i)==\\'$\\' && (i==0 || (i>0 && sen.charAt(i-1)==\\' \\'))){\\n            sbf.append(\\'$\\');flag=true;continue;\\n            }\\n            if(flag){\\n            str+=sen.charAt(i);\\n            if(sen.charAt(i)<\\'0\\' || sen.charAt(i)>\\'9\\')\\n            {sbf.append(str);str=\"\";flag=false;continue;}\\n               \\n                if(str.length()>0 && (i==n-1 ||sen.charAt(i+1)==\\' \\')){\\n                    double d=Double.parseDouble(str);                    \\n                    sbf.append(decfor.format(d-(d*discount)/100));\\n                    flag=false;\\n                    str=\"\";                    \\n                }\\n               \\n            }\\n            else sbf.append(sen.charAt(i));\\n        }\\n        return sbf.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final DecimalFormat decfor = new DecimalFormat(\"0.00\"); \\n    public String discountPrices(String sen, int discount) {\\n        StringBuffer sbf=new StringBuffer(\"\");\\n        String str=\"\";\\n        int n=sen.length();\\n        boolean flag=false;\\n        for(int i=0;i<n;i++){\\n        if(sen.charAt(i)==\\'$\\' && (i==0 || (i>0 && sen.charAt(i-1)==\\' \\'))){\\n            sbf.append(\\'$\\');flag=true;continue;\\n            }\\n            if(flag){\\n            str+=sen.charAt(i);\\n            if(sen.charAt(i)<\\'0\\' || sen.charAt(i)>\\'9\\')\\n            {sbf.append(str);str=\"\";flag=false;continue;}\\n               \\n                if(str.length()>0 && (i==n-1 ||sen.charAt(i+1)==\\' \\')){\\n                    double d=Double.parseDouble(str);                    \\n                    sbf.append(decfor.format(d-(d*discount)/100));\\n                    flag=false;\\n                    str=\"\";                    \\n                }\\n               \\n            }\\n            else sbf.append(sen.charAt(i));\\n        }\\n        return sbf.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973099,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nreturn \\' \\'.join([\"dollarsign\" + \"{0:.2f}\".format(((100 - discount) / 100) * int(word[1:])) if word[0] == \\'$\\' and word[1:].isdecimal() else word for word in sentence.split()])",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nreturn \\' \\'.join([\"dollarsign\" + \"{0:.2f}\".format(((100 - discount) / 100) * int(word[1:])) if word[0] == \\'$\\' and word[1:].isdecimal() else word for word in sentence.split()])",
                "codeTag": "Unknown"
            },
            {
                "id": 2964900,
                "title": "c-stringstream-straightforward",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool check(string word)\\n    {\\n        if (word[0] != \\'$\\' or word.size() == 1)\\n        {\\n            return false;\\n        }\\n        for (int i = 1; i < word.size(); i++)\\n        {\\n            if (word[i] < \\'0\\' or word[i] > \\'9\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount)\\n    {\\n        string res = \"\";\\n        stringstream str(sentence);\\n        string word;\\n        float dis = (float)discount / 100;\\n        while (str >> word)\\n        {\\n            res.push_back(\\' \\');\\n            if (check(word))\\n            {\\n                long double num = stoll(word.substr(1));\\n                num = num - (num * discount / 100.0);\\n                string y = to_string(num);\\n                res.push_back(\\'$\\');\\n                res += y.substr(0, y.find(\\'.\\') + 3);\\n            }\\n            else\\n            {\\n                res += word;\\n            }\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(string word)\\n    {\\n        if (word[0] != \\'$\\' or word.size() == 1)\\n        {\\n            return false;\\n        }\\n        for (int i = 1; i < word.size(); i++)\\n        {\\n            if (word[i] < \\'0\\' or word[i] > \\'9\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    string discountPrices(string sentence, int discount)\\n    {\\n        string res = \"\";\\n        stringstream str(sentence);\\n        string word;\\n        float dis = (float)discount / 100;\\n        while (str >> word)\\n        {\\n            res.push_back(\\' \\');\\n            if (check(word))\\n            {\\n                long double num = stoll(word.substr(1));\\n                num = num - (num * discount / 100.0);\\n                string y = to_string(num);\\n                res.push_back(\\'$\\');\\n                res += y.substr(0, y.find(\\'.\\') + 3);\\n            }\\n            else\\n            {\\n                res += word;\\n            }\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960329,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        double dis = ((double)discount)*0.01;\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i=0; i< words.length; i++)\\n        {\\n            boolean check = true;\\n            if(words[i].charAt(0) == \\'\\n```)\\n            {\\n                double k = 0;\\n                int len = words[i].length();\\n                if(len == 1)\\n                {\\n                    sb.append(\"$\");\\n                    break;\\n                }\\n             \\n                for(int j = 1; j< len; j++)\\n                {\\n                    \\n                    char c = words[i].charAt(j);\\n                    if(Character.isDigit(c))\\n                    {\\n                        k = k* 10 + (c - \\'0\\');\\n                        check = false;\\n                    }\\n                    else\\n                    {\\n                        check = true;\\n                        sb.append(words[i]);\\n                        break;\\n                    }\\n                   \\n                }\\n\\n                if(check == false)\\n                {\\n                    \\n                    double a =k - (k * dis);\\n                    String temp = \"$\" + String.format(\"%1.2f\", a);\\n                    sb.append(temp);\\n                }\\n            }\\n\\n            else\\n                sb.append(words[i]);\\n            sb.append(\" \");\\n        }\\n        return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        double dis = ((double)discount)*0.01;\\n        int i = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(i=0; i< words.length; i++)\\n        {\\n            boolean check = true;\\n            if(words[i].charAt(0) == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959043,
                "title": "java-beginner-friendly-and-readable",
                "content": "# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            if (isPrice(word)) {\\n                sb.append(getDiscountedPrice(word, discount) + \" \");\\n            } else {\\n                sb.append(word + \" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        if (word.charAt(0) != \\'$\\') return false;\\n        String num = word.substring(1, word.length());\\n        if (num.trim().length() == 0) return false;\\n        for (char ch : num.toCharArray()) {\\n            if (ch < \\'0\\' || ch > \\'9\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    private String getDiscountedPrice(String lnum, int discount) {\\n        String num = lnum.substring(1, lnum.length());\\n        String discountedPrice = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100.00));\\n        return discountedPrice;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] words = sentence.split(\" \");\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            if (isPrice(word)) {\\n                sb.append(getDiscountedPrice(word, discount) + \" \");\\n            } else {\\n                sb.append(word + \" \");\\n            }\\n        }\\n        return sb.toString().trim();\\n    }\\n\\n    private boolean isPrice(String word) {\\n        if (word.charAt(0) != \\'$\\') return false;\\n        String num = word.substring(1, word.length());\\n        if (num.trim().length() == 0) return false;\\n        for (char ch : num.toCharArray()) {\\n            if (ch < \\'0\\' || ch > \\'9\\') return false;\\n        }\\n        return true;\\n    }\\n\\n    private String getDiscountedPrice(String lnum, int discount) {\\n        String num = lnum.substring(1, lnum.length());\\n        String discountedPrice = String.format(\"$%.2f\", Long.parseLong(num) * (1 - discount / 100.00));\\n        return discountedPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958471,
                "title": "python-runtime-97ms-beats-100-memory-16-7mb-beats-80-95",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        l = list(sentence.split(\" \"))\\n        for s in range(len(l)):\\n            i = l[s]\\n            if i[0] == \\'$\\' and i[1:].isdigit():\\n                k = float(i[1:]) * (100 - discount) / 100\\n                l[s] = \\'$\\' + \"{:.2f}\".format(k)\\n        return \\' \\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        l = list(sentence.split(\" \"))\\n        for s in range(len(l)):\\n            i = l[s]\\n            if i[0] == \\'$\\' and i[1:].isdigit():\\n                k = float(i[1:]) * (100 - discount) / 100\\n                l[s] = \\'$\\' + \"{:.2f}\".format(k)\\n        return \\' \\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955842,
                "title": "simple-python-without-regex",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\" \")\\n\\n        for ind, word in enumerate(sentence):\\n            if word and word[0] == \"$\" and word[1:]:\\n                is_digit = True\\n                for c in word[1:]:\\n                    if not c.isdigit():\\n                        is_digit = False\\n\\n                if is_digit:\\n                    digit = (int(word[1:]) * (100 - discount)) / 100\\n                    sentence[ind] = \"$\" + \"%.2f\" % digit\\n\\n        return \" \".join(sentence)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        sentence = sentence.split(\" \")\\n\\n        for ind, word in enumerate(sentence):\\n            if word and word[0] == \"$\" and word[1:]:\\n                is_digit = True\\n                for c in word[1:]:\\n                    if not c.isdigit():\\n                        is_digit = False\\n\\n                if is_digit:\\n                    digit = (int(word[1:]) * (100 - discount)) / 100\\n                    sentence[ind] = \"$\" + \"%.2f\" % digit\\n\\n        return \" \".join(sentence)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945977,
                "title": "java-try-catch-to-solve-in-easy-way",
                "content": "# Intuition\\nJava Try catch to solve in easy Way\\n\\n# Approach\\nUsing try catch to auto handle each random case.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        String[] new1 =new String[s.length];\\n        int i=0;\\n        for(String s1 : s){\\n            if(s1.equals(\"$1e9\")){\\n                new1[i]=s1;\\n                i++;\\n                continue;\\n            }\\n            if(s1.charAt(0)==\\'\\n``` && s1.charAt(s1.length() - 1)>=\\'0\\' && s1.charAt(s1.length() - 1) <=\\'9\\'){\\n                try{\\n                    double num = Double.parseDouble(s1.substring(1,s1.length()));\\n                    num-=num*0.01*discount;\\n                    new1[i]=\"$\"+ String.format(\"%.2f\",num);//Double.toString(num);\\n                // System.out.println(num);\\n                }\\n                catch(Exception e){\\n                   new1[i]=s1; \\n                }\\n                \\n            }\\n            else{\\n                new1[i]=s1;\\n            }\\n            i++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(String ss: new1){\\n            sb.append(ss);\\n            sb.append(\" \");\\n        }\\n        // sb.trim();\\n    return sb.toString().trim();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] s = sentence.split(\" \");\\n        String[] new1 =new String[s.length];\\n        int i=0;\\n        for(String s1 : s){\\n            if(s1.equals(\"$1e9\")){\\n                new1[i]=s1;\\n                i++;\\n                continue;\\n            }\\n            if(s1.charAt(0)==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941738,
                "title": "c-straight-forward-stringstream-for-in-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply split the sentence with delim = \\' \\', and check whether a substring is in the form of ```$digits```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- use ```std::istringstream``` to separate ```sentence``` into substrings. \\n- use ```std::ostringstream``` to form the result string ```res```\\n-- to simplify the process of converting money to two-decimal-place numbers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$, since substr has linear complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$, since substr has linear complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int rate = 100 - discount;\\n        istringstream iss(sentence);\\n        ostringstream oss;\\n        string tmp;\\n        oss << fixed << setprecision(2);\\n        while ( getline(iss, tmp, \\' \\') ){\\n            size_t n = tmp.size();\\n            if ( tmp[0] != \\'$\\' || n < 2 ){\\n                oss << tmp << \\' \\';\\n            }\\n            else{\\n                size_t i = 1;\\n                for ( ; i < n && isdigit(tmp[i]); ++i );\\n                if ( i == n ){\\n                    long double money = 0.01 * stoul(tmp.substr(1)) * rate;\\n                    oss << \\'$\\' << money << \\' \\';\\n                }\\n                else{\\n                    oss << tmp << \\' \\';\\n                }\\n            }\\n        }\\n        string res = oss.str();\\n        return res.substr(0, res.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```$digits```\n```std::istringstream```\n```sentence```\n```std::ostringstream```\n```res```\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        int rate = 100 - discount;\\n        istringstream iss(sentence);\\n        ostringstream oss;\\n        string tmp;\\n        oss << fixed << setprecision(2);\\n        while ( getline(iss, tmp, \\' \\') ){\\n            size_t n = tmp.size();\\n            if ( tmp[0] != \\'$\\' || n < 2 ){\\n                oss << tmp << \\' \\';\\n            }\\n            else{\\n                size_t i = 1;\\n                for ( ; i < n && isdigit(tmp[i]); ++i );\\n                if ( i == n ){\\n                    long double money = 0.01 * stoul(tmp.substr(1)) * rate;\\n                    oss << \\'$\\' << money << \\' \\';\\n                }\\n                else{\\n                    oss << tmp << \\' \\';\\n                }\\n            }\\n        }\\n        string res = oss.str();\\n        return res.substr(0, res.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937375,
                "title": "python-solution-using-split",
                "content": "# Intuition\\nThe space character is the delimiter and reading words as a whole is key here.\\n\\n# Approach\\nPython offers the split() function which will break a string into a list.  From there, we\\'ll iterate through the \"words\" in the list.  To be recognized as a \"price,\" a word must begin with \\\\$ and not contain any subsequent characters that are not numeric or decimal points.  \\n\\nIf a word is a \"price\" then the code will perform the discount calculation on the numeric portion (without the \"\\\\$\") and ensure the proper formatting with two decimals.  That discounted price string is then appended to an answer list\\n\\nIf a word begins with a \"\\\\$\" but is not a \"price\" or doesn\\'t begin with a \"\\\\$\" at all then it will just be appended to the answer list.\\n\\nAs a final step the code takes the answer list (which is disparate words) and concatenates them all together, inserting the space characters that were initially removed.  A trailing space is added so that gets stripped out.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n\\n        words_to_test = sentence.split(\" \")\\n\\n        for w in words_to_test:\\n            if w.startswith(\"$\") and len(w) >= 2:\\n                NumberBool = True\\n                for c in w[1:]:\\n                    if c not in [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\".\"]:\\n                        NumberBool = False\\n                if NumberBool: \\n                    ans.append(str(\"$\"+str(\"{:.2f}\".format(float(w[1:]) * (1 - discount/100)))))\\n                else:\\n                    ans.append(w)\\n            else:\\n                ans.append(w)\\n\\n        ans2 = \"\"\\n\\n        for x in ans:\\n            ans2 += str(x + \" \")\\n\\n        return ans2.strip()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        ans = []\\n\\n        words_to_test = sentence.split(\" \")\\n\\n        for w in words_to_test:\\n            if w.startswith(\"$\") and len(w) >= 2:\\n                NumberBool = True\\n                for c in w[1:]:\\n                    if c not in [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\".\"]:\\n                        NumberBool = False\\n                if NumberBool: \\n                    ans.append(str(\"$\"+str(\"{:.2f}\".format(float(w[1:]) * (1 - discount/100)))))\\n                else:\\n                    ans.append(w)\\n            else:\\n                ans.append(w)\\n\\n        ans2 = \"\"\\n\\n        for x in ans:\\n            ans2 += str(x + \" \")\\n\\n        return ans2.strip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933398,
                "title": "just-simple-and-clean-solution",
                "content": "# Code\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        m = 1 - discount / 100\\n        s = sentence.split(\\' \\')\\n        for i in range(0, len(s)):\\n            if s[i][0] == \\'\\n``` and s[i][1:].isnumeric():\\n                s[i] = \"$\" + \"{:.2f}\".format(float(s[i][1:]) * m)\\n        return \\' \\'.join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        m = 1 - discount / 100\\n        s = sentence.split(\\' \\')\\n        for i in range(0, len(s)):\\n            if s[i][0] == \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902350,
                "title": "c-100-faster",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        var parts = sentence.Split(\\' \\');\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < parts.Length; i++)\\n        {\\n            sb.Append(ApplyDiscount(parts[i], discount));\\n            sb.Append(\" \");\\n        }\\n        var rs = sb.ToString();\\n        rs = rs.Trim();\\n        return rs;\\n    }\\n    private string ApplyDiscount(string part, int discount)\\n    {\\n        if (IsPrice(part))\\n        {\\n            part = GetNewPrice(part, discount);\\n        }\\n        return part;\\n    }\\n    private string GetNewPrice(string part, int discount)\\n    {\\n        var price = Convert.ToInt64(part.Substring(1));\\n        var price2 = (price * ((100 - (double)discount)) * 0.01).ToString();\\n        price2 += price2.IndexOf(\\'.\\') != -1 ? \"00\" : \".00\";\\n        var rs = \"$\" + price2.Substring(0, price2.IndexOf(\\'.\\') + 3);\\n        return rs;\\n    }\\n    private bool IsPrice(string s)\\n    {\\n        if (s[0] != \\'\\n``` || s.Length < 2) return false;\\n        for (int i = 1; i < s.Length; i++)\\n        {\\n            if (!char.IsDigit(s[i])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string DiscountPrices(string sentence, int discount) {\\n        var parts = sentence.Split(\\' \\');\\n        var sb = new StringBuilder();\\n        for (int i = 0; i < parts.Length; i++)\\n        {\\n            sb.Append(ApplyDiscount(parts[i], discount));\\n            sb.Append(\" \");\\n        }\\n        var rs = sb.ToString();\\n        rs = rs.Trim();\\n        return rs;\\n    }\\n    private string ApplyDiscount(string part, int discount)\\n    {\\n        if (IsPrice(part))\\n        {\\n            part = GetNewPrice(part, discount);\\n        }\\n        return part;\\n    }\\n    private string GetNewPrice(string part, int discount)\\n    {\\n        var price = Convert.ToInt64(part.Substring(1));\\n        var price2 = (price * ((100 - (double)discount)) * 0.01).ToString();\\n        price2 += price2.IndexOf(\\'.\\') != -1 ? \"00\" : \".00\";\\n        var rs = \"$\" + price2.Substring(0, price2.IndexOf(\\'.\\') + 3);\\n        return rs;\\n    }\\n    private bool IsPrice(string s)\\n    {\\n        if (s[0] != \\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891678,
                "title": "python-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        arr = sentence.split()\\n        ans = \"\"\\n        for x in range(len(arr)):\\n            val = arr[x]\\n            if len(val)>=2:\\n                if val[0]==\\'$\\' and val[1:].isdigit():\\n                    if discount==100:\\n                        arr[x]=\\'$0.00\\'\\n                    else:\\n                        a1 = int(val[1:]) * ((100 - discount) / 100)\\n                        a = (\"%.2f\" % a1)\\n                        arr[x] = \"$\"+a\\n        return(\" \".join(arr))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        arr = sentence.split()\\n        ans = \"\"\\n        for x in range(len(arr)):\\n            val = arr[x]\\n            if len(val)>=2:\\n                if val[0]==\\'$\\' and val[1:].isdigit():\\n                    if discount==100:\\n                        arr[x]=\\'$0.00\\'\\n                    else:\\n                        a1 = int(val[1:]) * ((100 - discount) / 100)\\n                        a = (\"%.2f\" % a1)\\n                        arr[x] = \"$\"+a\\n        return(\" \".join(arr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880389,
                "title": "java-use-string-and-long-methods-from-the-standard-library",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- A validation routine will be helpful, so that only well-formed prices are processed.\\n- Very long prices can occur, so prices shall be parsed as Long.\\n- The input sentence shall be ...\\n  1. split into words ...\\n  2. and each word in sentence shall be checkt if it is a price\\n  3. and if it is a price, shall be replaced by the reduced price\\n  4. if not a price, shall be left unchanged\\n- After having seen and probably changed all single words, join it all together and return.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n is the number of words in a sentence\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, because the split operation causes n new words to be created, that together have the same size as the original sentence.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Locale;\\n\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n\\n        String[] words = sentence.split(\"\\\\\\\\s+\");\\n        int reduction = 100 - discount;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isValidPrize(words[i])) {\\n                double oldPrize = Long.parseLong(words[i].substring(1));\\n                double newPrize = oldPrize * reduction / 100.;\\n                words[i] = String.format(Locale.ENGLISH, \"$%.2f\", newPrize);\\n            }\\n        }\\n\\n        return String.join(\" \", words);\\n    }\\n\\n    private boolean isValidPrize(String word) {\\n        if (!word.startsWith(\"$\")) return false;\\n        if (word.length() < 2) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (!\"0123456789\".contains(word.substring(i, i + 1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Locale;\\n\\nclass Solution {\\n\\n    public String discountPrices(String sentence, int discount) {\\n\\n        String[] words = sentence.split(\"\\\\\\\\s+\");\\n        int reduction = 100 - discount;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (isValidPrize(words[i])) {\\n                double oldPrize = Long.parseLong(words[i].substring(1));\\n                double newPrize = oldPrize * reduction / 100.;\\n                words[i] = String.format(Locale.ENGLISH, \"$%.2f\", newPrize);\\n            }\\n        }\\n\\n        return String.join(\" \", words);\\n    }\\n\\n    private boolean isValidPrize(String word) {\\n        if (!word.startsWith(\"$\")) return false;\\n        if (word.length() < 2) return false;\\n        for (int i = 1; i < word.length(); i++) {\\n            if (!\"0123456789\".contains(word.substring(i, i + 1))) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865585,
                "title": "too-frustrating-to-solve-thank-god-we-have-regular-expression-in-python",
                "content": "# Just ask me what you dont understand I don\\'t want to write entire paragraphs here. See you in the comment section!!\\n\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        list1 = sentence.split(\" \")\\n        list2 = []\\n        new_prices = []\\n        for val in list1:\\n            if val.startswith(\\'$\\') and  (not val.endswith(\\'$\\')):\\n                list2.append(val)\\n        \\n        new_sentence = \" \".join(list2)\\n        pattern = re.compile(r\"\\\\$[0-9]{1,10}\")\\n        prices = pattern.findall(new_sentence)\\n        print(prices)\\n        for val in prices:\\n            k = \\'$\\'+f\"{(((100-discount)/100)*int(val.strip(\\'$\\').strip())):.2f}\"\\n            new_prices.append(k)\\n        dict1 = {i:j for i,j in zip(prices, new_prices)}\\n        sentence = sentence.split(\" \")\\n        for r in range(len(sentence)):\\n            if sentence[r] in dict1:\\n                sentence[r] = dict1[sentence[r]]\\n        \\n        return \" \".join(sentence)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        list1 = sentence.split(\" \")\\n        list2 = []\\n        new_prices = []\\n        for val in list1:\\n            if val.startswith(\\'$\\') and  (not val.endswith(\\'$\\')):\\n                list2.append(val)\\n        \\n        new_sentence = \" \".join(list2)\\n        pattern = re.compile(r\"\\\\$[0-9]{1,10}\")\\n        prices = pattern.findall(new_sentence)\\n        print(prices)\\n        for val in prices:\\n            k = \\'$\\'+f\"{(((100-discount)/100)*int(val.strip(\\'$\\').strip())):.2f}\"\\n            new_prices.append(k)\\n        dict1 = {i:j for i,j in zip(prices, new_prices)}\\n        sentence = sentence.split(\" \")\\n        for r in range(len(sentence)):\\n            if sentence[r] in dict1:\\n                sentence[r] = dict1[sentence[r]]\\n        \\n        return \" \".join(sentence)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859592,
                "title": "simple-approach-with-solution-using-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Firstly splitting the input string by \"<single-space>\".\\n- Then checking in each elements in the list:\\n    - is the 1st character of that element is \\'$\\' or not AND...\\n    - is the string from its 1st index to last is numeric or not.\\n- Now we can perform discount calculations on that string and place it in the respective position in the string itself.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        s1=sentence.split(\" \")\\n        for i in range(len(s1)):\\n            s1[i]=str(s1[i])\\n            if(s1[i][0]==\\'\\n``` and s1[i][1:].isdigit()):\\n                deduct=100-discount\\n                d=float(s1[i][1:])*deduct/100\\n                s1[i]=\"${:.2f}\".format(d)\\n        return \" \".join(s1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def discountPrices(self, sentence, discount):\\n        \"\"\"\\n        :type sentence: str\\n        :type discount: int\\n        :rtype: str\\n        \"\"\"\\n        s1=sentence.split(\" \")\\n        for i in range(len(s1)):\\n            s1[i]=str(s1[i])\\n            if(s1[i][0]==\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857498,
                "title": "rust-simple-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let discount_as_float = discount as f64;\\n        let words = sentence.split(\" \");\\n        let words = words.map(|word| {\\n            if word.starts_with(\"$\") && !&word[1..].contains(\"$\") {\\n                match (&word[1..]).parse::<i64>() {\\n                    Ok(value) => {\\n                        let value_as_float = value as f64;\\n\\n                        format!(\"${:.2}\", value_as_float - (value_as_float * discount_as_float / 100_f64))\\n                    },\\n                    Err(_) => word.to_owned()\\n                }\\n            } else {\\n                word.to_owned()\\n            }\\n        }).collect::<Vec<_>>();\\n\\n\\n        words.join(\" \")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn discount_prices(sentence: String, discount: i32) -> String {\\n        let discount_as_float = discount as f64;\\n        let words = sentence.split(\" \");\\n        let words = words.map(|word| {\\n            if word.starts_with(\"$\") && !&word[1..].contains(\"$\") {\\n                match (&word[1..]).parse::<i64>() {\\n                    Ok(value) => {\\n                        let value_as_float = value as f64;\\n\\n                        format!(\"${:.2}\", value_as_float - (value_as_float * discount_as_float / 100_f64))\\n                    },\\n                    Err(_) => word.to_owned()\\n                }\\n            } else {\\n                word.to_owned()\\n            }\\n        }).collect::<Vec<_>>();\\n\\n\\n        words.join(\" \")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2857408,
                "title": "python3-unholy-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is just for fun!\\nI would no recommend to do this in an interview.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to do the following things:\\n1) Split the sentence by spaces\\n2) Check whether word is a price, this again has three conditions\\n    a) word starts with \\'$\\' (e.g. not \\'12\\')\\n    b) word contains only digits after \\'$\\' (e.g. not \\'$10$\\')\\n    c) word is longer than 1 (e.g. not \\'$\\')\\n3) If the word is a price, we then apply discount and use f-string for output formatting\\n4) If the word is no price we just keep it\\n5) Join the words with spaces again\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) worst, where N is the amount of letters in the sentence, as every word could start with a dollar sign\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we do not count output space\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join((f\\'${int(word[1:])*(100-discount)/100:0.2f}\\' if word[0] == \\'$\\' and all(ch.isdigit() for ch in word[1:]) and len(word) > 1 else word) for word in sentence.split(\\' \\'))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        return \" \".join((f\\'${int(word[1:])*(100-discount)/100:0.2f}\\' if word[0] == \\'$\\' and all(ch.isdigit() for ch in word[1:]) and len(word) > 1 else word) for word in sentence.split(\\' \\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838525,
                "title": "short-java-solution-with-regex",
                "content": "# Intuition\\nwould have to write longer code if without regex\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        int rd = 100 - discount;\\n        String[] arr = sentence.split(\"\\\\\\\\s\");\\n        Pattern pattern = Pattern.compile(\"^\\\\\\\\$([0-9]+)$\");\\n        for(int i=0; i<arr.length; i++){\\n            String a = arr[i];\\n            Matcher m = pattern.matcher(a);\\n            if(m.find()){\\n                double price = (double)Long.parseLong(m.group(1)) * rd/100; // use long!!\\n                arr[i] = String.format(\"$%.2f\",price);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        int rd = 100 - discount;\\n        String[] arr = sentence.split(\"\\\\\\\\s\");\\n        Pattern pattern = Pattern.compile(\"^\\\\\\\\$([0-9]+)$\");\\n        for(int i=0; i<arr.length; i++){\\n            String a = arr[i];\\n            Matcher m = pattern.matcher(a);\\n            if(m.find()){\\n                double price = (double)Long.parseLong(m.group(1)) * rd/100; // use long!!\\n                arr[i] = String.format(\"$%.2f\",price);\\n            }\\n        }\\n        return String.join(\" \", arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827739,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'$\\'){\\n                ++i;\\n                string amt = \"\";\\n                bool f = false;\\n                while(i < n && s[i] != \\' \\'){\\n                    if(!isdigit(s[i])){\\n                        f = true;\\n                        amt.push_back(s[i]);\\n                    }else{\\n                        amt.push_back(s[i]);\\n                    }\\n                    ++i;\\n                }\\n                if(f == true || amt.size() == 0){\\n                    ans += \" $\" + amt;\\n                }else{\\n                    long double v = stoll(amt);\\n                    v = v - (v * d / 100.0);\\n                    amt = to_string(v);\\n                    ans += \" $\" + amt.substr(0, amt.find(\\'.\\') + 3);\\n                }\\n            }else{\\n                string word = \"\";\\n                while(i < n && s[i] != \\' \\'){\\n                    word.push_back(s[i]);\\n                    ++i;\\n                }\\n                ans += \" \" + word;\\n            }\\n        }\\n        return ans.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string s, int d) {\\n        string ans = \"\";\\n        int n = s.size();\\n        for(int i = 0; i < n; ++i){\\n            if(s[i] == \\'$\\'){\\n                ++i;\\n                string amt = \"\";\\n                bool f = false;\\n                while(i < n && s[i] != \\' \\'){\\n                    if(!isdigit(s[i])){\\n                        f = true;\\n                        amt.push_back(s[i]);\\n                    }else{\\n                        amt.push_back(s[i]);\\n                    }\\n                    ++i;\\n                }\\n                if(f == true || amt.size() == 0){\\n                    ans += \" $\" + amt;\\n                }else{\\n                    long double v = stoll(amt);\\n                    v = v - (v * d / 100.0);\\n                    amt = to_string(v);\\n                    ans += \" $\" + amt.substr(0, amt.find(\\'.\\') + 3);\\n                }\\n            }else{\\n                string word = \"\";\\n                while(i < n && s[i] != \\' \\'){\\n                    word.push_back(s[i]);\\n                    ++i;\\n                }\\n                ans += \" \" + word;\\n            }\\n        }\\n        return ans.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825687,
                "title": "c-an-attempt-using-split-and-stringstream-5-5",
                "content": "After handcoding my solution using a regex loop and a vector of words, I am not able to get more than 5%/5% in terms of efficiency.\\n\\n```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> list = split(sentence, discount);\\n        stringstream ss;\\n        for (string s : list) {\\n            ss << \" \" << s;\\n        }\\n        return ss.str().substr(1);\\n    }\\nprivate:\\n    vector<string> split(string sentence, int discount) {\\n        vector<string> list(1,\"\");\\n        int count = 0;\\n        int state = 0;\\n        char ch;\\n        stringstream ss;\\n        for (int k = 0; k <= sentence.size(); k++) {\\n            ch = k == sentence.size() ? \\' \\' : sentence[k];\\n            if (ch != \\' \\') {\\n                state = 1;\\n                ss << ch;\\n            }\\n            else if (state == 1 && ch == \\' \\') {\\n                list[count] = convert(ss.str(), discount);\\n                ss = stringstream();\\n                if (k < sentence.size()) {\\n                    state = 0;\\n                    count++;\\n                    list.push_back(\"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    string convert(string word, int discount) {\\n        if (word.size() < 2 || word[0] != \\'$\\')\\n            return word;\\n        char digit;\\n        char count = 0;\\n        for (int k = 1; k < word.length(); k++) {\\n            digit = word[k];\\n            if (digit < \\'0\\' || digit > \\'9\\') {\\n                return word;\\n            }\\n        }\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << \"$\" << stol(word.substr(1))*(100-discount)/100.0;\\n        return ss.str();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string discountPrices(string sentence, int discount) {\\n        vector<string> list = split(sentence, discount);\\n        stringstream ss;\\n        for (string s : list) {\\n            ss << \" \" << s;\\n        }\\n        return ss.str().substr(1);\\n    }\\nprivate:\\n    vector<string> split(string sentence, int discount) {\\n        vector<string> list(1,\"\");\\n        int count = 0;\\n        int state = 0;\\n        char ch;\\n        stringstream ss;\\n        for (int k = 0; k <= sentence.size(); k++) {\\n            ch = k == sentence.size() ? \\' \\' : sentence[k];\\n            if (ch != \\' \\') {\\n                state = 1;\\n                ss << ch;\\n            }\\n            else if (state == 1 && ch == \\' \\') {\\n                list[count] = convert(ss.str(), discount);\\n                ss = stringstream();\\n                if (k < sentence.size()) {\\n                    state = 0;\\n                    count++;\\n                    list.push_back(\"\");\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    string convert(string word, int discount) {\\n        if (word.size() < 2 || word[0] != \\'$\\')\\n            return word;\\n        char digit;\\n        char count = 0;\\n        for (int k = 1; k < word.length(); k++) {\\n            digit = word[k];\\n            if (digit < \\'0\\' || digit > \\'9\\') {\\n                return word;\\n            }\\n        }\\n        \\n        stringstream ss;\\n        ss << fixed << setprecision(2) << \"$\" << stol(word.substr(1))*(100-discount)/100.0;\\n        return ss.str();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822042,
                "title": "split-by-delimeter-space-with-two-helper-methods-java-o-n-time-o-n-space",
                "content": "# Intuition\\nsplit into String array by delimeter space \\n\\n# Approach\\nThe code itself is self-explanatory, for this kind of problem break into pieces usually helps (true for most problems)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n) because of applyDiscount method\\n\\n# Code\\n```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] parts = sentence.split(\" \");\\n        StringBuilder res = new StringBuilder();\\n        int len = parts.length;\\n        for (int i = 0; i < len; i++) {\\n            String part = parts[i];\\n            if (isPrice(part)) {\\n                res.append(applyDiscount(part, discount));\\n            } else {\\n                res.append(part);\\n            }\\n            if (i != len - 1) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n\\n    private String applyDiscount(String price, int discount) {\\n        double p = Double.valueOf(price.substring(1, price.length()));\\n        p *= ((100 - discount) / 100.0);\\n        // String.format(\"%.2f\", double value) round the double value to 2 decimal places and remove scientific e notation\\n        return \"$\" + String.format(\"%.2f\", p);\\n    }\\n\\n    private boolean isPrice(String str) {\\n        if (str == \"\" || str.charAt(0) != \\'$\\') return false;\\n        int len = str.length();\\n        if (len == 1 && str.charAt(0) == \\'$\\') return false;\\n        if (len >= 3 && str.charAt(1) == \\'0\\' && str.charAt(2) != \\'.\\') return false;\\n        boolean firstDotFound = false;\\n        for (int i = 1; i < len; i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'.\\' && !firstDotFound) {\\n                firstDotFound = true;\\n            } else {\\n                if (c < \\'0\\' || c > \\'9\\') return false; \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String discountPrices(String sentence, int discount) {\\n        String[] parts = sentence.split(\" \");\\n        StringBuilder res = new StringBuilder();\\n        int len = parts.length;\\n        for (int i = 0; i < len; i++) {\\n            String part = parts[i];\\n            if (isPrice(part)) {\\n                res.append(applyDiscount(part, discount));\\n            } else {\\n                res.append(part);\\n            }\\n            if (i != len - 1) res.append(\\' \\');\\n        }\\n        return res.toString();\\n    }\\n\\n    private String applyDiscount(String price, int discount) {\\n        double p = Double.valueOf(price.substring(1, price.length()));\\n        p *= ((100 - discount) / 100.0);\\n        // String.format(\"%.2f\", double value) round the double value to 2 decimal places and remove scientific e notation\\n        return \"$\" + String.format(\"%.2f\", p);\\n    }\\n\\n    private boolean isPrice(String str) {\\n        if (str == \"\" || str.charAt(0) != \\'$\\') return false;\\n        int len = str.length();\\n        if (len == 1 && str.charAt(0) == \\'$\\') return false;\\n        if (len >= 3 && str.charAt(1) == \\'0\\' && str.charAt(2) != \\'.\\') return false;\\n        boolean firstDotFound = false;\\n        for (int i = 1; i < len; i++) {\\n            char c = str.charAt(i);\\n            if (c == \\'.\\' && !firstDotFound) {\\n                firstDotFound = true;\\n            } else {\\n                if (c < \\'0\\' || c > \\'9\\') return false; \\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808225,
                "title": "intuitive-python-solution-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        d = 1 - (discount / 100)     #calculate the  discount\\n        stack = sentence.split(\" \")  #split the sentence by spaces\\n        \\n        for i, word in enumerate(stack):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                x = int(word[1:]) * d\\n                stack[i] = \\'$\\' + str(\"%.2f\" % x)\\n        \\n        return \" \".join(stack)\\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def discountPrices(self, sentence: str, discount: int) -> str:\\n        \\n        d = 1 - (discount / 100)     #calculate the  discount\\n        stack = sentence.split(\" \")  #split the sentence by spaces\\n        \\n        for i, word in enumerate(stack):\\n            if word[0] == \\'$\\' and word[1:].isnumeric():\\n                x = int(word[1:]) * d\\n                stack[i] = \\'$\\' + str(\"%.2f\" % x)\\n        \\n        return \" \".join(stack)\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802017,
                "title": "very-easy-python-solution",
                "content": "def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        l=sentence.split(\\' \\')\\n        \\n        res=[]\\n        \\n        for i in l:\\n            if i[0]==\\'$\\' and i[1:].isdigit():\\n                t=(int(i[1:]))-(int(i[1:])*(discount/100))\\n                t=\\'{0:.2f}\\'.format(t)\\n                res.append(\\'$\\'+str(t))\\n            else:\\n                res.append(i)\\n        return \\' \\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "def discountPrices(self, sentence: str, discount: int) -> str:\\n\\n        l=sentence.split(\\' \\')\\n        \\n        res=[]\\n        \\n        for i in l:\\n            if i[0]==\\'$\\' and i[1:].isdigit():\\n                t=(int(i[1:]))-(int(i[1:])*(discount/100))\\n                t=\\'{0:.2f}\\'.format(t)\\n                res.append(\\'$\\'+str(t))\\n            else:\\n                res.append(i)\\n        return \\' \\'.join(res)",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565313,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 2033538,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 2033422,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1984753,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1776578,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1763492,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            },
            {
                "id": 1727614,
                "content": [
                    {
                        "username": "Kasturi13",
                        "content": "Totally frustrating question. I spent 1 hour trying to solve the problem!\\n"
                    },
                    {
                        "username": "ma5termiind",
                        "content": "itna kharab bhi nhi tha, i\\'ve seen lot worse"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "I know right , too many updates on a string is complicated always."
                    },
                    {
                        "username": "Limon020",
                        "content": "Try Catch is your friend here"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this question is not difficult but demands a lot of rethinking to catch all the edge cases. After spent a couple hours on this one, it is finally done. Victory at last xD"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Why so many downvotes?  It's not hard.  Or maybe python just makes things extra convenient with the split and format methods."
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Try converting the string into an array(I used split function in python) then going through the array check whether 0th element is a\"$\"sign then check whether all the characters after it are actual digits,\\nI did in python using \".isdigit()\" method then do the operation and format it and change its value in array itself ,after doing this convert the array into string.\\nTime complexity\\u2212O(n)\\nSpace complexity\\u2212O(n) if you consider array else O(1) \\n\\n"
                    },
                    {
                        "username": "Adilzhan_MVP_Mustafin",
                        "content": "How to pass 151 test case?\\nthere is no input here"
                    },
                    {
                        "username": "amresh564",
                        "content": "``some value $475$384``\nvery complicated to solve, my solution changes the last ``$384``, but it was not expected.\n\nAccording to question :\n``A word represents a price if it is a sequence of digits preceded by a dollar sign``\nthen why shouldn't we change ``$384`` and ``$475``"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "because there\\'s no space after 475 and in order to it be a valid price there has to be space in between\\n"
                    },
                    {
                        "username": "vinmore",
                        "content": "because it expects leading and trailing spaces for e.g `<space>$123<space>$234`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Path Cost in a Grid",
        "question_content": "<p>You are given a <strong>0-indexed</strong> <code>m x n</code> integer matrix <code>grid</code> consisting of <strong>distinct</strong> integers from <code>0</code> to <code>m * n - 1</code>. You can move in this matrix from a cell to any other cell in the <strong>next</strong> row. That is, if you are in cell <code>(x, y)</code> such that <code>x &lt; m - 1</code>, you can move to any of the cells <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, ..., <code>(x + 1, n - 1)</code>. <strong>Note</strong> that it is not possible to move from cells in the last row.</p>\n\n<p>Each possible move has a cost given by a <strong>0-indexed</strong> 2D array <code>moveCost</code> of size <code>(m * n) x n</code>, where <code>moveCost[i][j]</code> is the cost of moving from a cell with value <code>i</code> to a cell in column <code>j</code> of the next row. The cost of moving from cells in the last row of <code>grid</code> can be ignored.</p>\n\n<p>The cost of a path in <code>grid</code> is the <strong>sum</strong> of all values of cells visited plus the <strong>sum</strong> of costs of all the moves made. Return <em>the <strong>minimum</strong> cost of a path that starts from any cell in the <strong>first</strong> row and ends at any cell in the <strong>last</strong> row.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png\" style=\"width: 301px; height: 281px;\" />\n<pre>\n<strong>Input:</strong> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\n<strong>Output:</strong> 17\n<strong>Explanation: </strong>The path with the minimum possible cost is the path 5 -&gt; 0 -&gt; 1.\n- The sum of the values of cells visited is 5 + 0 + 1 = 6.\n- The cost of moving from 5 to 0 is 3.\n- The cost of moving from 0 to 1 is 8.\nSo the total cost of the path is 6 + 3 + 8 = 17.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The path with the minimum possible cost is the path 2 -&gt; 3.\n- The sum of the values of cells visited is 2 + 3 = 5.\n- The cost of moving from 2 to 3 is 1.\nSo the total cost of this path is 5 + 1 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>2 &lt;= m, n &lt;= 50</code></li>\n\t<li><code>grid</code> consists of distinct integers from <code>0</code> to <code>m * n - 1</code>.</li>\n\t<li><code>moveCost.length == m * n</code></li>\n\t<li><code>moveCost[i].length == n</code></li>\n\t<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2141155,
                "title": "dp",
                "content": "We compute the result in O(m * n * n) using memoisation. Constraints allow for that, as both `n` and `m` is limited to `50`.\\n\\n**C++**\\n```cpp\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = g[0];\\n    for (int i = 1; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            for (int k = 0; k < n; ++k)\\n                dp[i][k] = min(dp[i][k], g[i][k] + dp[i - 1][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[m - 1]), end(dp[m - 1]));\\n}\\n```\\nMemory optimization, as we only look one row up.\\n**C++**\\n```cpp\\nint dp[2][50] = {};\\nclass Solution {\\npublic:\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (i == 0)\\n                dp[0][j] = g[0][j];\\n            else\\n                for (int k = 0; k < n; ++k)\\n                    dp[i % 2][k] = min(j == 0 ? INT_MAX : dp[i % 2][k], g[i][k] + dp[(i - 1) % 2][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[(m - 1) % 2]), begin(dp[(m - 1) % 2]) + n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = g[0];\\n    for (int i = 1; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            for (int k = 0; k < n; ++k)\\n                dp[i][k] = min(dp[i][k], g[i][k] + dp[i - 1][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[m - 1]), end(dp[m - 1]));\\n}\\n```\n```cpp\\nint dp[2][50] = {};\\nclass Solution {\\npublic:\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& moveCost) {\\n    int m = g.size(), n = g[0].size();\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            if (i == 0)\\n                dp[0][j] = g[0][j];\\n            else\\n                for (int k = 0; k < n; ++k)\\n                    dp[i % 2][k] = min(j == 0 ? INT_MAX : dp[i % 2][k], g[i][k] + dp[(i - 1) % 2][j] + moveCost[g[i - 1][j]][k]);\\n    return *min_element(begin(dp[(m - 1) % 2]), begin(dp[(m - 1) % 2]) + n);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141640,
                "title": "c-dijkstra-algorithm-short-overkill-but-100-runtime",
                "content": "Dijkstra algorithm also works great here, and compared to DP it does occupy a little extra space.\\n\\n**Method 1. Dijkstra Algo Solution** (~402 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> visitedCost(m, vector<int>(n, INT_MAX));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n\\n    // push all in the first row to the pq\\n    for(int j=0; j<n; j++)\\n        pq.push({grid[0][j], 0, j});\\n\\n    while(!pq.empty()){\\n        int costTillHere = pq.top()[0];\\n        int x = pq.top()[1];\\n        int y = pq.top()[2];\\n        pq.pop();\\n\\n        if(x == m-1)\\n            return costTillHere;\\n\\n        for(int dy = 0; x+1 < m && dy < n; dy++){\\n            int newCost = costTillHere  + moveCost[grid[x][y]][dy] + grid[x+1][dy];\\n            if(newCost < visitedCost[x+1][dy]){\\n                visitedCost[x+1][dy] =  newCost;\\n                pq.push({newCost, x+1, dy});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\\n\\n**Method 2. DP - bottom to top** (~813 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[m - 1] = grid[m - 1];\\n\\n    for (int i = m - 2; i >= 0; i--) {\\n        for (int j = 0; j < n; j++) {\\n            for (int k = 0; k < n; k++) {\\n                int cost = dp[i + 1][k] + moveCost[grid[i][j]][k] + grid[i][j];\\n                dp[i][j] = min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp[0].begin(), dp[0].end());\\n}\\n```\\n\\n**Method 3. DP -  top to bottom** (~429 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = dp[i-1][j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                dp[i][k] = min(dp[i][k], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp.back().begin(), dp.back().end());\\n}\\n```\\n\\n**Method 4: 1D Optimized** (~696 ms)\\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n```\\n**Upvote and let others learn too!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> visitedCost(m, vector<int>(n, INT_MAX));\\n    priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n\\n    // push all in the first row to the pq\\n    for(int j=0; j<n; j++)\\n        pq.push({grid[0][j], 0, j});\\n\\n    while(!pq.empty()){\\n        int costTillHere = pq.top()[0];\\n        int x = pq.top()[1];\\n        int y = pq.top()[2];\\n        pq.pop();\\n\\n        if(x == m-1)\\n            return costTillHere;\\n\\n        for(int dy = 0; x+1 < m && dy < n; dy++){\\n            int newCost = costTillHere  + moveCost[grid[x][y]][dy] + grid[x+1][dy];\\n            if(newCost < visitedCost[x+1][dy]){\\n                visitedCost[x+1][dy] =  newCost;\\n                pq.push({newCost, x+1, dy});\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[m - 1] = grid[m - 1];\\n\\n    for (int i = m - 2; i >= 0; i--) {\\n        for (int j = 0; j < n; j++) {\\n            for (int k = 0; k < n; k++) {\\n                int cost = dp[i + 1][k] + moveCost[grid[i][j]][k] + grid[i][j];\\n                dp[i][j] = min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp[0].begin(), dp[0].end());\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n    dp[0] = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = dp[i-1][j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                dp[i][k] = min(dp[i][k], cost);\\n            }\\n        }\\n    }\\n\\n    return *min_element(dp.back().begin(), dp.back().end());\\n}\\n```\n```cpp\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140973,
                "title": "java-python-3-2-dp-codes-space-o-m-n-and-o-n-w-analysis",
                "content": "```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[m][n];\\n        for (int c = 0; c < n; ++c) {\\n            cost[0][c] = grid[0][c];\\n        }\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int mi = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    mi = Math.min(mi, cost[r - 1][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r][c] = mi + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[m - 1]).min().getAsInt();\\n    }\\n```\\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        min_cost = 0\\n        cost = [grid[0][:]]\\n        for r, row in enumerate(grid):\\n            if r > 0:\\n                cost.append([])\\n                for c, cell in enumerate(row):\\n                        cost[-1].append(cell + min(cost[-2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1])))\\n        return min(cost[-1])            \\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n * n)`, space: `O(m * n)`.\\n\\n----\\n\\nSpace optimization to `O(n)`:\\n```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[2][n];\\n        cost[0] = grid[0].clone();\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int min = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    min = Math.min(min, cost[1 - r % 2][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r % 2][c] = min + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[1 - m % 2]).min().getAsInt();\\n    }\\n```\\n\\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [grid[0][:], [0] * n]\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if r > 0:\\n                    cost[r % 2][c] = cell + min(cost[1 - r % 2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1]))\\n        return min(cost[1 - m % 2])\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n * n)`, space: `O(n)`.\\n\\n----\\n\\nFeel free to let me know if you have any questions, and please **upvote** if the post is helpful.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[m][n];\\n        for (int c = 0; c < n; ++c) {\\n            cost[0][c] = grid[0][c];\\n        }\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int mi = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    mi = Math.min(mi, cost[r - 1][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r][c] = mi + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[m - 1]).min().getAsInt();\\n    }\\n```\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        min_cost = 0\\n        cost = [grid[0][:]]\\n        for r, row in enumerate(grid):\\n            if r > 0:\\n                cost.append([])\\n                for c, cell in enumerate(row):\\n                        cost[-1].append(cell + min(cost[-2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1])))\\n        return min(cost[-1])            \\n```\n```java\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] cost = new int[2][n];\\n        cost[0] = grid[0].clone();\\n        for (int r = 1; r < m; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                int min = Integer.MAX_VALUE;\\n                for (int j = 0; j < n; ++j) {\\n                    min = Math.min(min, cost[1 - r % 2][j] + moveCost[grid[r - 1][j]][c]);\\n                }\\n                cost[r % 2][c] = min + grid[r][c];\\n            }\\n        }\\n        return IntStream.of(cost[1 - m % 2]).min().getAsInt();\\n    }\\n```\n```python\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [grid[0][:], [0] * n]\\n        for r, row in enumerate(grid):\\n            for c, cell in enumerate(row):\\n                if r > 0:\\n                    cost[r % 2][c] = cell + min(cost[1 - r % 2][j] + moveCost[i][c] for j, i in enumerate(grid[r - 1]))\\n        return min(cost[1 - m % 2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2183129,
                "title": "c-recursion-memoization-dp-easy-understanding",
                "content": "Recursion ( TLE )\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nRecursion + Memoization ( Accepted )\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int solve(vector<vector<int>> &grid,vector<vector<int>>& moveCost,int i,int j,int n,int m){\\n        if(i==n-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            ans=min(ans,grid[i][j]+moveCost[grid[i][j]][k]+solve(grid,moveCost,i+1,k,n,m));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof dp);\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,solve(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141004,
                "title": "python-recursion-memoization",
                "content": "**Observations:**\\n1. This problem can be solved using recursion but simple recursion will lead to TLE.\\n2. If we make the recursion tree we can easily see that we will have a lot of redundant computations.\\n\\n**For this example: *grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]***\\n![image](https://assets.leetcode.com/users/images/1bbda85d-40d1-4643-9ad9-9cce8d40e20e_1655007202.21135.png)\\n**We can see that as we go from 5 to 4 and compute all paths for 4. In future we again reach 4 from 3 and compute all paths for 4 again. The computations made for 4 can be memoized be maintaining a dp array for each node. This will store the min cost path from that node and its node value. For 4 it will be path with cost 2 to Node 2. So dp[1][0] = dp for Node 4 = 2(Target Path Cost) + 2(Target Node Val) + 4 (Its Own Value).**\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        max_row, max_col = len(grid), len(grid[0])\\n        dp = [[-1] * max_col for _ in range(max_row)] \\n\\n        def recursion(row, col):\\n            if row == max_row - 1: # If last row then return nodes value\\n                return grid[row][col]\\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\\n                current = grid[row][col] # Current Node Value\\n                res = float(\\'inf\\') # To store best path from Current Node\\n                for c in range(max_col): # Traverse all path from Current Node\\n                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value\\n                    res = min(res, val)\\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\\n            return dp[row][col]\\n\\n        for c in range(max_col):\\n            recursion(0, c) # Start recursion from all nodes in 1st row\\n        return min(dp[0]) # Return min value from 1st row\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        max_row, max_col = len(grid), len(grid[0])\\n        dp = [[-1] * max_col for _ in range(max_row)] \\n\\n        def recursion(row, col):\\n            if row == max_row - 1: # If last row then return nodes value\\n                return grid[row][col]\\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\\n                current = grid[row][col] # Current Node Value\\n                res = float(\\'inf\\') # To store best path from Current Node\\n                for c in range(max_col): # Traverse all path from Current Node\\n                    val = moveCost[current][c] + recursion(row + 1, c) # Move cost + Target Node Value\\n                    res = min(res, val)\\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\\n            return dp[row][col]\\n\\n        for c in range(max_col):\\n            recursion(0, c) # Start recursion from all nodes in 1st row\\n        return min(dp[0]) # Return min value from 1st row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140985,
                "title": "python-memoization",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: list[list[int]], moveCost: list[list[int]]) -> int:\\n\\n        @lru_cache()\\n        def helper(i, j):\\n            if i >= len(grid) - 1:\\n                return grid[i][j]\\n            \\n            m_cost = 9999999999\\n            cost = 0\\n\\n            for k in range(len(grid[0])):\\n                cost = grid[i][j] + moveCost[grid[i][j]][k] + helper(i + 1, k)\\n                m_cost = min(cost, m_cost)\\n\\n            return m_cost\\n\\n        cost, min_cost = 0, 999999999999\\n        n = len(grid[0])\\n        for j in range(n):\\n            cost = helper(0, j)\\n            min_cost = min(cost, min_cost)\\n\\n        return min_cost\\n```\\n\\nA much cleaner code provided by @feng4\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache()\\n        def helper(i, j):\\n            if i == 0:\\n                return grid[i][j]\\n            else:\\n                return grid[i][j] + min(moveCost[grid[i - 1][k]][j] + helper(i - 1, k) for k in range(n))\\n        \\n        return min(helper(m - 1, j) for j in range(n))\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: list[list[int]], moveCost: list[list[int]]) -> int:\\n\\n        @lru_cache()\\n        def helper(i, j):\\n            if i >= len(grid) - 1:\\n                return grid[i][j]\\n            \\n            m_cost = 9999999999\\n            cost = 0\\n\\n            for k in range(len(grid[0])):\\n                cost = grid[i][j] + moveCost[grid[i][j]][k] + helper(i + 1, k)\\n                m_cost = min(cost, m_cost)\\n\\n            return m_cost\\n\\n        cost, min_cost = 0, 999999999999\\n        n = len(grid[0])\\n        for j in range(n):\\n            cost = helper(0, j)\\n            min_cost = min(cost, min_cost)\\n\\n        return min_cost\\n```\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache()\\n        def helper(i, j):\\n            if i == 0:\\n                return grid[i][j]\\n            else:\\n                return grid[i][j] + min(moveCost[grid[i - 1][k]][j] + helper(i - 1, k) for k in range(n))\\n        \\n        return min(helper(m - 1, j) for j in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141651,
                "title": "java-dp-with-explanation-fast-than-100",
                "content": "### Intuition\\nGiven `m = grid.length`, `n = grid[0].length`\\n\\nthe min path cost of `grid[i][j]` is the minimum of \\n(1) min path cost of previous grid, plus\\n(2) cost to move from previous grid to current grid), plus\\n(3) current grid value\\n\\nnote: current grid is `grid[i][j]`, previous grid is `grid[i-1][k]` where k = [0, n-1]\\n\\n### Steps\\nGiven `dp[i][j]` is the min path cost of `grid[i][j]`\\nwe have the formula:\\n```\\nprev = grid[i-1][k]\\ndp[i][j] = min(dp[i-1][k] + cost[prev][j] + grid[i][j]) where k is [0,n-1]\\n\\nbase case: dp[0][j] = grid[0][j]\\n```\\n\\nthen, the result is `min(dp[m-1])`\\n\\n### Complexity\\ntime: O`(mn^2)`\\nspace: `O(mn)`\\n### Java\\n```java\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    dp[0] = grid[0];\\n\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = Integer.MAX_VALUE;\\n            for (int k = 0; k < n; k++) {\\n                int cur = grid[i][j], prev = grid[i - 1][k];\\n                int cost = dp[i - 1][k] + moveCost[prev][j] + cur;\\n                dp[i][j] = Math.min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    int res = Integer.MAX_VALUE;\\n    for (int i = 0; i < n; i++) {\\n        res = Math.min(res, dp[m - 1][i]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprev = grid[i-1][k]\\ndp[i][j] = min(dp[i-1][k] + cost[prev][j] + grid[i][j]) where k is [0,n-1]\\n\\nbase case: dp[0][j] = grid[0][j]\\n```\n```java\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dp = new int[m][n];\\n    dp[0] = grid[0];\\n\\n    for (int i = 1; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = Integer.MAX_VALUE;\\n            for (int k = 0; k < n; k++) {\\n                int cur = grid[i][j], prev = grid[i - 1][k];\\n                int cost = dp[i - 1][k] + moveCost[prev][j] + cur;\\n                dp[i][j] = Math.min(dp[i][j], cost);\\n            }\\n        }\\n    }\\n\\n    int res = Integer.MAX_VALUE;\\n    for (int i = 0; i < n; i++) {\\n        res = Math.min(res, dp[m - 1][i]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151851,
                "title": "c-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=1e8 , n=grid.size() , m=grid[0].size();\\n        if(n==1) return 0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int c,d=1e8;\\n                for(int k=0;k<m;k++)\\n                {\\n                    c=moveCost[grid[i][j]][k]+grid[i+1][k];\\n                    d=min(d,c);\\n                }\\n                grid[i][j]+=d;\\n            }\\n        }\\n        for(int i=0;i<m;i++) ans=min(ans,grid[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=1e8 , n=grid.size() , m=grid[0].size();\\n        if(n==1) return 0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int c,d=1e8;\\n                for(int k=0;k<m;k++)\\n                {\\n                    c=moveCost[grid[i][j]][k]+grid[i+1][k];\\n                    d=min(d,c);\\n                }\\n                grid[i][j]+=d;\\n            }\\n        }\\n        for(int i=0;i<m;i++) ans=min(ans,grid[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141191,
                "title": "python3-top-down-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e59b5d5832483707a595ae92b9aa1fb456986009) for solutions of weekly 297\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j):\\n            \"\"\"Return min cost of moving from (i, j) to bottom row.\"\"\"\\n            if i == m-1: return grid[i][j]\\n            ans = inf \\n            for jj in range(n): \\n                ans = min(ans, grid[i][j] + fn(i+1, jj) + moveCost[grid[i][j]][jj])\\n            return ans \\n        \\n        return min(fn(0, j) for j in range(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j):\\n            \"\"\"Return min cost of moving from (i, j) to bottom row.\"\"\"\\n            if i == m-1: return grid[i][j]\\n            ans = inf \\n            for jj in range(n): \\n                ans = min(ans, grid[i][j] + fn(i+1, jj) + moveCost[grid[i][j]][jj])\\n            return ans \\n        \\n        return min(fn(0, j) for j in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737020,
                "title": "using-lis-dp-format-with-time-complexity-calculation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I used the LIS DP format where we find the optimal answer ending at an index (i,j).\\n\\nWhy did I think of this? Because the value that is asked in the question can be calculated for all the cells in the grid and using the values calculated for the previous row we can calculate the answer for current row.\\n\\nSo I Calcuated the best answer ending at the index for all the cells in the last row and selected the minimum one which is asked.\\n\\nFor reaching a cell (i,j), I have gone through all the possibilities of where I could have come from and selected the minimum possible route.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime complexity =  $$O(#states(1+#transitions(avg/state)))$$\\n- $$#states$$=m*n\\n- $$#Transitions$$=n\\n- TC = O(m*n*(1+n)) = O(m*n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981804,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Recursion + Memoization... \\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp){\\n        \\n        \\n        // If we have reached the last row then just return the node...\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col] != -1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = grid[row][col];\\n        \\n        int take = 1e9;\\n        \\n        // Checking cost of all paths from current node...\\n        for(int i = 0 ; i < moveCost[ans].size(); i++){\\n\\n            take = min(take,ans +  moveCost[ans][i] + solve(row + 1,i,grid,moveCost,dp));\\n        }\\n        \\n        // Storing the cost in dp for overlapping subproblems...\\n        return dp[row][col] = take;\\n    }\\n    \\n    \\n    // Tabulation...\\n    int solveTab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,0));\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i = 0; i < grid[0].size(); i++){\\n            dp[n - 1][i] = grid[n - 1][i];\\n        }\\n        \\n        \\n        for(int row = n - 2 ; row >= 0 ; row--){\\n            \\n            for(int  col = 0 ; col < m; col++){\\n                \\n                int ans = grid[row][col];\\n        \\n                int take = 1e9;\\n\\n                for(int i = 0 ; i < moveCost[ans].size(); i++){\\n\\n                    take = min(take,ans +  moveCost[ans][i] + dp[row + 1][i]);\\n                }\\n\\n                dp[row][col] = take;\\n                \\n            }\\n            \\n        }\\n        \\n        int res = INT_MAX;\\n        \\n        for(int i = 0 ; i < grid[0].size(); i++){\\n            res = min(res,dp[0][i]);\\n        }\\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        \\n        for(int i = 0 ; i < grid[0].size();i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        \\n        return ans;\\n        \\n        // To call tabulation code...\\n        // return solveTab(grid,moveCost);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // Recursion + Memoization... \\n    int solve(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp){\\n        \\n        \\n        // If we have reached the last row then just return the node...\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2383601,
                "title": "c-recursive-dp-memoized-solution",
                "content": "1. Recursive Brute Force Solution  **( Gives TLE )**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n                \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n));\\n            \\n        }\\n        \\n        return cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n                \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size()));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```\\n\\n\\n2. DP (memoized solution)  \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n, vector<vector<int>> &dp){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n, dp));\\n            \\n        }\\n        \\n        return dp[i][j]= cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n        \\n        vector<vector<int>> dp(51, vector<int>(51, -1));\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size(), dp));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n                \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n));\\n            \\n        }\\n        \\n        return cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n                \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size()));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(vector<vector<int>> &grid, vector<vector<int>> &cost, int i, int j, int m, int n, vector<vector<int>> &dp){\\n        \\n        if(i == m-1) return grid[i][j];\\n        \\n        if(i>=m) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int cst = 1e8;\\n        \\n        for(int k=0;k<n;k++){\\n            \\n            cst =  min(cst,  grid[i][j] + cost[grid[i][j]][k] + f(grid, cost, i+1, k, m, n, dp));\\n            \\n        }\\n        \\n        return dp[i][j]= cst;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int mini = INT_MAX;\\n        \\n        vector<vector<int>> dp(51, vector<int>(51, -1));\\n        \\n        for(int j=0;j<grid[0].size();j++){\\n            mini = min(mini, f(grid, moveCost, 0, j, grid.size(), grid[0].size(), dp));\\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141036,
                "title": "straightforward-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int maxi=INT_MAX;\\n        \\n        for(int k=0;k<moveCost[grid[i][j]].size();k++)\\n        {\\n           maxi=min(maxi,grid[i][j]+moveCost[grid[i][j]][k]+explore(grid,moveCost,dp,i+1,k)); \\n        }\\n        \\n        \\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int mini=INT_MAX;\\n      vector<vector<int>> dp(52,vector<int>(52,-1));\\n        for(int i=0;i<grid[0].size();i++)\\n            mini=min(mini,explore(grid,moveCost,dp,0,i));\\n         return mini;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explore(vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>> &dp,int i,int j)\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int maxi=INT_MAX;\\n        \\n        for(int k=0;k<moveCost[grid[i][j]].size();k++)\\n        {\\n           maxi=min(maxi,grid[i][j]+moveCost[grid[i][j]][k]+explore(grid,moveCost,dp,i+1,k)); \\n        }\\n        \\n        \\n        return dp[i][j]=maxi;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int mini=INT_MAX;\\n      vector<vector<int>> dp(52,vector<int>(52,-1));\\n        for(int i=0;i<grid[0].size();i++)\\n            mini=min(mini,explore(grid,moveCost,dp,0,i));\\n         return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143442,
                "title": "c-dp-memoization-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int row,int col,vector<vector<int>> &dp){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==0){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1)return dp[row][col];\\n        int cost = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int curr = grid[row][col] + moveCost[grid[row-1][i]][col] + f(grid,moveCost,row-1,i,dp);\\n            cost = min(curr,cost);\\n        }\\n        return dp[row][col]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            res = min(res,f(grid,moveCost,m-1,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int row,int col,vector<vector<int>> &dp){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==0){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1)return dp[row][col];\\n        int cost = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int curr = grid[row][col] + moveCost[grid[row-1][i]][col] + f(grid,moveCost,row-1,i,dp);\\n            cost = min(curr,cost);\\n        }\\n        return dp[row][col]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        int res = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            res = min(res,f(grid,moveCost,m-1,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141733,
                "title": "recursion-memoization-c-easy",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int row, col;\\n    int memo[51][51];\\n    int pass(vector<vector<int>> &m, int i, int j, vector<vector<int>> &Cost)\\n    {\\n        if (i == row - 1 and (j >= 0 and j <= col - 1))\\n            return m[i][j];\\n        if (i == row || (j < 0 || j == col))\\n            return 6000;   // taking max =6000 according to constraints\\n        if (memo[i][j] != -1)\\n            return memo[i][j];\\n        int ans = 6000;\\n        for (int ii = 0; ii < col; ii++)   \\n        {\\n            ans = min(ans, (m[i][j] + Cost[m[i][j]][ii] + pass(m, i + 1, ii, Cost)));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>> &matrix, vector<vector<int>> &moveCost)\\n    {\\n        int ans = INT_MAX;\\n        memset(memo, -1, sizeof(memo));\\n        row = matrix.size();\\n        col = matrix[0].size();\\n        for (int i = 0; i < col; i++)\\n        {\\n\\t\\t     // as we have to start from first row so we call for (0,0)  (0,1)  (0,2) ....\\n            ans = min(ans, pass(matrix, 0, i, moveCost));\\n\\t\\t\\t\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int row, col;\\n    int memo[51][51];\\n    int pass(vector<vector<int>> &m, int i, int j, vector<vector<int>> &Cost)\\n    {\\n        if (i == row - 1 and (j >= 0 and j <= col - 1))\\n            return m[i][j];\\n        if (i == row || (j < 0 || j == col))\\n            return 6000;   // taking max =6000 according to constraints\\n        if (memo[i][j] != -1)\\n            return memo[i][j];\\n        int ans = 6000;\\n        for (int ii = 0; ii < col; ii++)   \\n        {\\n            ans = min(ans, (m[i][j] + Cost[m[i][j]][ii] + pass(m, i + 1, ii, Cost)));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>> &matrix, vector<vector<int>> &moveCost)\\n    {\\n        int ans = INT_MAX;\\n        memset(memo, -1, sizeof(memo));\\n        row = matrix.size();\\n        col = matrix[0].size();\\n        for (int i = 0; i < col; i++)\\n        {\\n\\t\\t     // as we have to start from first row so we call for (0,0)  (0,1)  (0,2) ....\\n            ans = min(ans, pass(matrix, 0, i, moveCost));\\n\\t\\t\\t\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141158,
                "title": "c-tc-o-m-n-n-dp-minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int j = 0; j < n; ++j)\\n            ans[m - 1][j] = grid[m - 1][j];\\n        for (int i = m - 2; i >= 0; --i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = INT_MAX;\\n                for (int jj = 0; jj < n; ++jj)\\n                    ans[i][j] = min(ans[i][j], ans[i + 1][jj] + moveCost[grid[i][j]][jj]);\\n                ans[i][j] += grid[i][j];\\n            }\\n        }\\n        return *min_element(ans[0].begin(), ans[0].end()); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for (int j = 0; j < n; ++j)\\n            ans[m - 1][j] = grid[m - 1][j];\\n        for (int i = m - 2; i >= 0; --i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                ans[i][j] = INT_MAX;\\n                for (int jj = 0; jj < n; ++jj)\\n                    ans[i][j] = min(ans[i][j], ans[i + 1][jj] + moveCost[grid[i][j]][jj]);\\n                ans[i][j] += grid[i][j];\\n            }\\n        }\\n        return *min_element(ans[0].begin(), ans[0].end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141095,
                "title": "python-dp-tabular-form-o-m-n-n",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n =len(grid[0])\\n        dp = [[0]*n for i in range(m)]   \\n        for i in range(n):\\n                dp[0][i] = grid[0][i]\\n        for i in range(1,m):\\n            for j in range(n):\\n                l = [0]*n\\n                for k in range(n):\\n                    l[k] = grid[i][j] + moveCost[grid[i-1][k]][j] + dp[i-1][k]\\n                dp[i][j] = min(l)\\n        return min(dp[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n =len(grid[0])\\n        dp = [[0]*n for i in range(m)]   \\n        for i in range(n):\\n                dp[0][i] = grid[0][i]\\n        for i in range(1,m):\\n            for j in range(n):\\n                l = [0]*n\\n                for k in range(n):\\n                    l[k] = grid[i][j] + moveCost[grid[i-1][k]][j] + dp[i-1][k]\\n                dp[i][j] = min(l)\\n        return min(dp[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319164,
                "title": "memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &moveCost, vector<vector<int>> &dp) {\\n        if(i == n - 1) return grid[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=0; k<m; k++) {\\n            ans = min(ans, grid[i][j] + moveCost[grid[i][j]][k] + dfs(i + 1, k, n, m, grid, moveCost, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(), m = grid[0].size(), ans = 1e9;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        for(int r=0; r<m; r++) {\\n            for(int c=0; c<m; c++) {\\n                ans = min(ans, grid[0][r] + moveCost[grid[0][r]][c] + dfs(1, c, n, m, grid, moveCost, dp));\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &moveCost, vector<vector<int>> &dp) {\\n        if(i == n - 1) return grid[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int ans = 1e9;\\n        for(int k=0; k<m; k++) {\\n            ans = min(ans, grid[i][j] + moveCost[grid[i][j]][k] + dfs(i + 1, k, n, m, grid, moveCost, dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(), m = grid[0].size(), ans = 1e9;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        for(int r=0; r<m; r++) {\\n            for(int c=0; c<m; c++) {\\n                ans = min(ans, grid[0][r] + moveCost[grid[0][r]][c] + dfs(1, c, n, m, grid, moveCost, dp));\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271031,
                "title": "c-simple-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& cost) {\\n        int m=nums.size(),n=nums[0].size();\\n\\t\\t// dp[i][j] denotes the smallest total cost required to reach that node.\\n        vector<vector<int>>dp(m,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tdp[0][i]=nums[0][i];\\n        for(int i=1;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+cost[nums[i-1][k]][j]+nums[i][j]);\\n                }\\n            }\\n        }\\n        return *min_element(dp[m-1].begin(),dp[m-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& cost) {\\n        int m=nums.size(),n=nums[0].size();\\n\\t\\t// dp[i][j] denotes the smallest total cost required to reach that node.\\n        vector<vector<int>>dp(m,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tdp[0][i]=nums[0][i];\\n        for(int i=1;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<n;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+cost[nums[i-1][k]][j]+nums[i][j]);\\n                }\\n            }\\n        }\\n        return *min_element(dp[m-1].begin(),dp[m-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144573,
                "title": "cpp-simple-dp-solution-faster-than-100-00-direct-tabular-method-idea-and-comments",
                "content": "In contest i was just doing by recursion and got runtime error !! \\nBUT after contest i solved it in one go **:D**\\n**ACCEPTED:Runtime: 30 ms, faster than 100.00% of C++ online submissions for Minimum Path Cost in a Grid**\\n\\nNow **Idea** is to create a 2d DP array with all 0;\\nthen fill bottom row because there is no need to think about their moveCost.\\n#### After that a cell become totally dependent on its **(i+1)th row +min(grid [I] [J]   +  moveCost[grid [I] [J]  ][k]) **  \\n \\n \\n **In lymann lang:: which arrow (in diagram of sample testcase)  + grid[i][j] give minimum path;**\\n =>grid[i][j] is also going to add and we have to find min movecost using loop by k=0 ->n;\\n \\nTRY to solve on your own \\nSee Code and Understand\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));                   // 2D ARRAY\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[m-1][i]=grid[m-1][i];                        // fillling bottom row very easy!\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    temp=min(temp,dp[i+1][k]+movecost[grid[i][j]][k]);            // k loop find min for which arrow\\n                }\\n                dp[i][j]=grid[i][j]+temp;                 // now store the sum of both (min path +value at that point)\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,dp[0][i]);                  // find minimum path in !st row and return \\n        }\\n        return ans;\\n    }\\n};\\n```\\n#### IF you understood TRY to UPVOTE this POST .\\n!! THANKS TO ALL!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,0));                   // 2D ARRAY\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[m-1][i]=grid[m-1][i];                        // fillling bottom row very easy!\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    temp=min(temp,dp[i+1][k]+movecost[grid[i][j]][k]);            // k loop find min for which arrow\\n                }\\n                dp[i][j]=grid[i][j]+temp;                 // now store the sum of both (min path +value at that point)\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,dp[0][i]);                  // find minimum path in !st row and return \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142670,
                "title": "100-00-faster-100-00-lesser-memory-c-easy-to-understand-tabular",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<int>prev=grid[0];\\n        vector<int>cur;\\n        for(int i=1;i<grid.size();i++){\\n            cur=grid[i];\\n            for(int j=0;j<grid[i].size();j++){\\n                int pathcost=INT_MAX;\\n                for(int k=0;k<grid[i].size();k++){\\n                    pathcost=min(pathcost,moveCost[grid[i-1][k]][j]+prev[k]);\\n                }\\n                cur[j]+=pathcost;\\n            }\\n            prev=cur;\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n            ans=min(ans,prev[k]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<int>prev=grid[0];\\n        vector<int>cur;\\n        for(int i=1;i<grid.size();i++){\\n            cur=grid[i];\\n            for(int j=0;j<grid[i].size();j++){\\n                int pathcost=INT_MAX;\\n                for(int k=0;k<grid[i].size();k++){\\n                    pathcost=min(pathcost,moveCost[grid[i-1][k]][j]+prev[k]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2142409,
                "title": "java-dynamic-programming-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int k;\\n    public int help(int[][] grid,int[][] c,int row,int col,int m,int n,int[][] dp){\\n        if(row==m-1 && col<n) return grid[row][col];\\n        \\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int x=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            int k= grid[row][col];\\n            x=Math.min(x,k+c[grid[row][col]][i]+help(grid,c,row+1,i,m,n,dp));\\n        }\\n        \\n        return dp[row][col]=x;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,help(grid,moveCost,0,i,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int k;\\n    public int help(int[][] grid,int[][] c,int row,int col,int m,int n,int[][] dp){\\n        if(row==m-1 && col<n) return grid[row][col];\\n        \\n        if(dp[row][col]!=-1) return dp[row][col];\\n        int x=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            int k= grid[row][col];\\n            x=Math.min(x,k+c[grid[row][col]][i]+help(grid,c,row+1,i,m,n,dp));\\n        }\\n        \\n        return dp[row][col]=x;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,help(grid,moveCost,0,i,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141108,
                "title": "c-dp",
                "content": "```\\nint dp[55][55];\\n    \\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int cost = 0;\\n        cost += grid[i][j];\\n        \\n        if(i+1 == m)\\n            return cost;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mn = INT_MAX;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            mn = min(mn, dfs(i+1,k,m,n,grid,moveCost) + moveCost[grid[i][j]][k]);\\n        }\\n        \\n        return dp[i][j] = mn+cost;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int cost = 0 ,res = INT_MAX , m = grid.size() , n = grid[0].size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost = dfs(0,i,m,n,grid,moveCost);\\n            res = min(res,cost);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[55][55];\\n    \\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int cost = 0;\\n        cost += grid[i][j];\\n        \\n        if(i+1 == m)\\n            return cost;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mn = INT_MAX;\\n        \\n        for(int k=0;k<n;k++)\\n        {\\n            mn = min(mn, dfs(i+1,k,m,n,grid,moveCost) + moveCost[grid[i][j]][k]);\\n        }\\n        \\n        return dp[i][j] = mn+cost;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int cost = 0 ,res = INT_MAX , m = grid.size() , n = grid[0].size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost = dfs(0,i,m,n,grid,moveCost);\\n            res = min(res,cost);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140939,
                "title": "java-simple-dijkstra-memoization",
                "content": "If you do not have visited array, it will TLE.\\n\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i : grid[grid.length - 1]) {\\n            set.add(i);\\n        }\\n        for (int i = 0; i < grid.length - 1; ++i) {\\n            int[] nextArr = grid[i + 1];\\n            for (int cur : grid[i]) {\\n                int[] cost = moveCost[cur];\\n                Map<Integer, Integer> submap = map.getOrDefault(cur, new HashMap<>());\\n                for (int j = 0; j < nextArr.length; ++j) {\\n                    submap.put(nextArr[j], cost[j]);\\n                }\\n                map.put(cur, submap);\\n            }\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] visited = new int[moveCost.length];\\n        Arrays.fill(visited, -1);\\n        for (int cur : grid[0]) {\\n            pq.offer(new int[]{cur, cur});\\n        }\\n        while (pq.size() > 0) {\\n            int[] cur = pq.poll();\\n            int node = cur[0];\\n            int cost = cur[1];\\n            if (set.contains(node)) {\\n                return cost;\\n            }\\n            if (visited[node] != -1 && cost > visited[node]) continue;\\n            visited[node] = cost;\\n            if (map.containsKey(node)) {\\n                Map<Integer, Integer> submap = map.get(node);\\n                for (int key : submap.keySet()) {\\n                    pq.offer(new int[]{key, cost + submap.get(key) + key});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for (int i : grid[grid.length - 1]) {\\n            set.add(i);\\n        }\\n        for (int i = 0; i < grid.length - 1; ++i) {\\n            int[] nextArr = grid[i + 1];\\n            for (int cur : grid[i]) {\\n                int[] cost = moveCost[cur];\\n                Map<Integer, Integer> submap = map.getOrDefault(cur, new HashMap<>());\\n                for (int j = 0; j < nextArr.length; ++j) {\\n                    submap.put(nextArr[j], cost[j]);\\n                }\\n                map.put(cur, submap);\\n            }\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] visited = new int[moveCost.length];\\n        Arrays.fill(visited, -1);\\n        for (int cur : grid[0]) {\\n            pq.offer(new int[]{cur, cur});\\n        }\\n        while (pq.size() > 0) {\\n            int[] cur = pq.poll();\\n            int node = cur[0];\\n            int cost = cur[1];\\n            if (set.contains(node)) {\\n                return cost;\\n            }\\n            if (visited[node] != -1 && cost > visited[node]) continue;\\n            visited[node] = cost;\\n            if (map.containsKey(node)) {\\n                Map<Integer, Integer> submap = map.get(node);\\n                for (int key : submap.keySet()) {\\n                    pq.offer(new int[]{key, cost + submap.get(key) + key});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986782,
                "title": "java-bottom-up-dp-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int dp[][]=new int[n][m];\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<m;k++){\\n                    min=Math.min(min,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=min+grid[i][j];\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i:dp[0])min=Math.min(min,i);\\n        return min;\\n    }\\n}\\n```\\n> ***# If you found my solution helpful and informative, I kindly invite you to consider leaving an upvote. Your support is greatly appreciated!***",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int dp[][]=new int[n][m];\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<m;k++){\\n                    min=Math.min(min,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=min+grid[i][j];\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i:dp[0])min=Math.min(min,i);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367953,
                "title": "dp-100-speed-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion + dynamic programming. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGo over each row and get the minimum cost to get to all the columns in that row. Return the minimum value in the last column.\\n\\nCreate function to get the minimum path to a value. Does this by looping over one row up and finding the min path to a value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minPathCost(self, grid, moveCost):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type moveCost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(grid), len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        def get_min_path(upRow, col):\\n            mc = 999999\\n            for column in range(n):\\n                cost = dp[upRow][column] + moveCost[grid[upRow][column]][col] \\n                if(cost < mc):\\n                    mc = cost\\n            return mc\\n\\n        def dfs(row):\\n            if(row == m):\\n                return\\n            for i in range(n):\\n                if(row == 0):\\n                    dp[row][i] = grid[row][i]\\n                else:\\n                    dp[row][i] = get_min_path(row-1, i) + grid[row][i]\\n          \\n            dfs(row+1)\\n        dfs(0)\\n        return min(dp[m-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPathCost(self, grid, moveCost):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type moveCost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(grid), len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        def get_min_path(upRow, col):\\n            mc = 999999\\n            for column in range(n):\\n                cost = dp[upRow][column] + moveCost[grid[upRow][column]][col] \\n                if(cost < mc):\\n                    mc = cost\\n            return mc\\n\\n        def dfs(row):\\n            if(row == m):\\n                return\\n            for i in range(n):\\n                if(row == 0):\\n                    dp[row][i] = grid[row][i]\\n                else:\\n                    dp[row][i] = get_min_path(row-1, i) + grid[row][i]\\n          \\n            dfs(row+1)\\n        dfs(0)\\n        return min(dp[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347360,
                "title": "dp-using-tabulation-method-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& mo) {\\n      int n = nums.size();\\n      int m = nums[0].size();\\n    int dp[n+1][m+1];\\n        for(int i=0;i<m;i++)dp[n-1][i] = nums[n-1][i];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans = min(ans,dp[i+1][k]+mo[nums[i][j]][k]);\\n                }\\n                dp[i][j] = ans+nums[i][j];\\n            }\\n        }\\n          int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n           ans = min(ans,dp[0][i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& nums, vector<vector<int>>& mo) {\\n      int n = nums.size();\\n      int m = nums[0].size();\\n    int dp[n+1][m+1];\\n        for(int i=0;i<m;i++)dp[n-1][i] = nums[n-1][i];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans = min(ans,dp[i+1][k]+mo[nums[i][j]][k]);\\n                }\\n                dp[i][j] = ans+nums[i][j];\\n            }\\n        }\\n          int ans=INT_MAX;\\n        for(int i=0;i<m;i++)\\n        {\\n           ans = min(ans,dp[0][i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990777,
                "title": "c-memoization-tabulation-space-optimization-dp",
                "content": "\\n# Memoization\\n- m = grid.size()  <- row\\n- n = grid[0].size()  <- column\\n- Time complexity: O(m\\\\*n\\\\*n)\\n- Space complexity: O(m*n) + O(m) (Auxiliary stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Memoization\\n// TC = O(m*n*n)\\n// SC = O(m*n) + O(m)(Auxiliary stack space)\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid,  vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i==grid.size()-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mn=1e9;\\n        for(int k=0; k<grid[0].size(); k++){\\n            int c = grid[i][j]+cost[grid[i][j]][k]+solve(i+1, k, grid, cost, dp);\\n            mn = min(mn, c);\\n        }\\n        return dp[i][j]=mn;    \\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, solve(0, i, grid, moveCost, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabulation\\n- Time complexity: O(m\\\\*n\\\\*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Tabulation\\n// TC = O(m*n*n)\\n// SC = O(m*n)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+dp[i+1][k];\\n                    mn = min(mn, c);\\n                }\\n                dp[i][j]=mn;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Space Optimization\\n- Time complexity: O(m\\\\*n\\\\*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Space Optimization\\n// TC = O(m*n*n)\\n// SC = O(2*m)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> prev(n, -1), curr(n, -1);\\n        for(int i=0; i<n; i++) prev[i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+prev[k];\\n                    mn = min(mn, c);\\n                }\\n                curr[j]=mn;\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Memoization\\n// TC = O(m*n*n)\\n// SC = O(m*n) + O(m)(Auxiliary stack space)\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid,  vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i==grid.size()-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mn=1e9;\\n        for(int k=0; k<grid[0].size(); k++){\\n            int c = grid[i][j]+cost[grid[i][j]][k]+solve(i+1, k, grid, cost, dp);\\n            mn = min(mn, c);\\n        }\\n        return dp[i][j]=mn;    \\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, solve(0, i, grid, moveCost, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Tabulation\\n// TC = O(m*n*n)\\n// SC = O(m*n)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+dp[i+1][k];\\n                    mn = min(mn, c);\\n                }\\n                dp[i][j]=mn;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Space Optimization\\n// TC = O(m*n*n)\\n// SC = O(2*m)\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> prev(n, -1), curr(n, -1);\\n        for(int i=0; i<n; i++) prev[i]=grid[m-1][i];\\n        for(int i=m-2; i>=0; i--){\\n            for(int j=0; j<n; j++){\\n                int mn=1e9;\\n                for(int k=0; k<n; k++){\\n                    int c = grid[i][j]+moveCost[grid[i][j]][k]+prev[k];\\n                    mn = min(mn, c);\\n                }\\n                curr[j]=mn;\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800351,
                "title": "recursion-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&movecost,vector<vector<int>>&dp)\\n    {\\n        if(i==0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int cost=20000;\\n        //cout<<grid[i-1][0]<<endl;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n           // cout<<movecost[grid[i-1][k]][j]<<\" \"<<grid[i-1][k]<<endl;\\n            cost=min(grid[i-1][k]+movecost[grid[i-1][k]][j]+f(i-1,k,grid,movecost,dp),cost);\\n        }\\n        return dp[i][j]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int n=grid.size();\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            f(grid.size()-1,j,grid,moveCost,dp);\\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans=min(dp[n-1][i]+grid[n-1][i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&movecost,vector<vector<int>>&dp)\\n    {\\n        if(i==0)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int cost=20000;\\n        //cout<<grid[i-1][0]<<endl;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n           // cout<<movecost[grid[i-1][k]][j]<<\" \"<<grid[i-1][k]<<endl;\\n            cost=min(grid[i-1][k]+movecost[grid[i-1][k]][j]+f(i-1,k,grid,movecost,dp),cost);\\n        }\\n        return dp[i][j]=cost;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int n=grid.size();\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            f(grid.size()-1,j,grid,moveCost,dp);\\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans=min(dp[n-1][i]+grid[n-1][i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2720128,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n    int m = grid.size(), n = grid[0].size();\\n    vector<int> prev = grid[0];\\n\\n    for(int i=1; i<m; i++){\\n        vector<int> cur(n, INT_MAX);\\n        for(int j=0; j<n; j++){\\n            for(int k=0; k<n; k++){\\n                int cost = prev[j] + grid[i][k] + moveCost[grid[i-1][j]][k];\\n                cur[k] = min(cur[k], cost);\\n            }\\n        }\\n        prev = cur;\\n    }\\n\\n    return *min_element(prev.begin(), prev.end());\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303420,
                "title": "c-dp-memoization-short-clean-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& moveCost, \\n             vector<vector<int>>& dp){\\n        \\n        if(i==grid.size()-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans=1e9;\\n        int temp=grid[i][j];\\n        for(int col=0;col<grid[0].size();col++){\\n            \\n            ans=min(ans, moveCost[temp][col] + solve(i+1,col,grid,moveCost,dp) );\\n        }\\n        return dp[i][j]=ans+temp;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans, solve(0,j,grid,moveCost,dp) );\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tint solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& moveCost, \\n             vector<vector<int>>& dp){\\n        \\n        if(i==grid.size()-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans=1e9;\\n        int temp=grid[i][j];\\n        for(int col=0;col<grid[0].size();col++){\\n            \\n            ans=min(ans, moveCost[temp][col] + solve(i+1,col,grid,moveCost,dp) );\\n        }\\n        return dp[i][j]=ans+temp;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans, solve(0,j,grid,moveCost,dp) );\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2152732,
                "title": "intuitive-greedy-solution",
                "content": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            mp.insert({grid[0][i],grid[0][i]});\\n        }\\n       \\n        for(int i=1;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<grid[i-1].size();k++)\\n                {\\n                    int x=moveCost[grid[i-1][k]][j]+mp[grid[i-1][k]];\\n                    mini=min(mini,x);\\n                }\\n                mp.insert({grid[i][j],mini+grid[i][j]});\\n            }\\n        }\\n      \\n        int n=grid.size();\\n        int maxi=INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int x=mp[grid[n-1][i]];\\n            maxi=min(maxi,x);\\n        }\\n        return maxi;\\n    }```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            mp.insert({grid[0][i],grid[0][i]});\\n        }\\n       \\n        for(int i=1;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<grid[i-1].size();k++)\\n                {\\n                    int x=moveCost[grid[i-1][k]][j]+mp[grid[i-1][k]];\\n                    mini=min(mini,x);\\n                }\\n                mp.insert({grid[i][j],mini+grid[i][j]});\\n            }\\n        }\\n      \\n        int n=grid.size();\\n        int maxi=INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int x=mp[grid[n-1][i]];\\n            maxi=min(maxi,x);\\n        }\\n        return maxi;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145044,
                "title": "java-dfs-with-memorization-dijkastras",
                "content": "Using an array as cache, otherwise you will meet TLE.\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[][] cache = new int[grid.length][grid[0].length];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int maximum = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            maximum = Math.min(maximum, dfs(grid, moveCost, cache, 0, i));\\n        }\\n        return maximum;\\n    }\\n    \\n    private int dfs(int[][] grid, int[][] moveCost, int[][] cache, int row, int col) {\\n        if (row == grid.length - 1)\\n            return grid[row][col];\\n        \\n        if (cache[row][col] != Integer.MAX_VALUE)\\n            return cache[row][col];\\n        \\n        int output = Integer.MAX_VALUE;\\n        int[] currentMoveCost = moveCost[grid[row][col]];\\n        for (int i = 0; i < currentMoveCost.length; i++) {\\n            output = Math.min(output, grid[row][col] + currentMoveCost[i] + dfs(grid, moveCost, cache, row + 1, i));\\n        }\\n        \\n        cache[row][col] = output;\\n        \\n        return output;\\n    }\\n}\\n```\\nAnother solution, using dijkstra, however is slower\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        int[][] miniDistance = new int[m][n]; // store the shortest distance from top row to this cell\\n        HashSet<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> {return a[2] - b[2];});\\n        \\n        for (int i = 0; i < n; i++) {\\n            heap.add(new int[] {0, i, grid[0][i]});\\n            miniDistance[0][i] = grid[0][i];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                heap.add(new int[] {i, j, Integer.MAX_VALUE});\\n                miniDistance[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        while (visited.size() != m * n) {\\n            int[] cell = heap.remove();\\n            int x = cell[0];\\n            int y = cell[1];\\n            int curDistance = cell[2];\\n            int value = grid[x][y];\\n            \\n            if (visited.contains(value))\\n                continue;\\n            \\n            visited.add(value);\\n            \\n            if (x == m - 1)\\n                continue;\\n            \\n            int[] currentMoveCost = moveCost[value];\\n            for (int i = 0; i < n; i++) {\\n                if (visited.contains(grid[x + 1][i]))\\n                    continue;\\n                \\n                int newDistance = curDistance + currentMoveCost[i] + grid[x + 1][i];\\n                if (newDistance < miniDistance[x + 1][i]) {\\n                    miniDistance[x + 1][i] = newDistance;\\n                    heap.add(new int[] {x + 1, i, newDistance});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            minimum = Math.min(minimum, miniDistance[m - 1][i]);\\n        }\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[][] cache = new int[grid.length][grid[0].length];\\n        for (int[] row : cache) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        \\n        int maximum = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid[0].length; i++) {\\n            maximum = Math.min(maximum, dfs(grid, moveCost, cache, 0, i));\\n        }\\n        return maximum;\\n    }\\n    \\n    private int dfs(int[][] grid, int[][] moveCost, int[][] cache, int row, int col) {\\n        if (row == grid.length - 1)\\n            return grid[row][col];\\n        \\n        if (cache[row][col] != Integer.MAX_VALUE)\\n            return cache[row][col];\\n        \\n        int output = Integer.MAX_VALUE;\\n        int[] currentMoveCost = moveCost[grid[row][col]];\\n        for (int i = 0; i < currentMoveCost.length; i++) {\\n            output = Math.min(output, grid[row][col] + currentMoveCost[i] + dfs(grid, moveCost, cache, row + 1, i));\\n        }\\n        \\n        cache[row][col] = output;\\n        \\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int minimum = Integer.MAX_VALUE;\\n        int[][] miniDistance = new int[m][n]; // store the shortest distance from top row to this cell\\n        HashSet<Integer> visited = new HashSet<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> {return a[2] - b[2];});\\n        \\n        for (int i = 0; i < n; i++) {\\n            heap.add(new int[] {0, i, grid[0][i]});\\n            miniDistance[0][i] = grid[0][i];\\n        }\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                heap.add(new int[] {i, j, Integer.MAX_VALUE});\\n                miniDistance[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        \\n        while (visited.size() != m * n) {\\n            int[] cell = heap.remove();\\n            int x = cell[0];\\n            int y = cell[1];\\n            int curDistance = cell[2];\\n            int value = grid[x][y];\\n            \\n            if (visited.contains(value))\\n                continue;\\n            \\n            visited.add(value);\\n            \\n            if (x == m - 1)\\n                continue;\\n            \\n            int[] currentMoveCost = moveCost[value];\\n            for (int i = 0; i < n; i++) {\\n                if (visited.contains(grid[x + 1][i]))\\n                    continue;\\n                \\n                int newDistance = curDistance + currentMoveCost[i] + grid[x + 1][i];\\n                if (newDistance < miniDistance[x + 1][i]) {\\n                    miniDistance[x + 1][i] = newDistance;\\n                    heap.add(new int[] {x + 1, i, newDistance});\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            minimum = Math.min(minimum, miniDistance[m - 1][i]);\\n        }\\n        \\n        return minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143016,
                "title": "minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX));\\n        dp[0]=grid[0];\\n        for(int i = 1; i < n;i++){\\n            for(int j = 0; j < m;j++){\\n                for(int k = 0; k < m;k++){\\n                    dp[i][j] = min(dp[i][j],moveCost[grid[i-1][k]][j] + dp[i-1][k] + grid[i][j]);\\n                    \\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n - 1]), end(dp[n - 1])); \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,INT_MAX));\\n        dp[0]=grid[0];\\n        for(int i = 1; i < n;i++){\\n            for(int j = 0; j < m;j++){\\n                for(int k = 0; k < m;k++){\\n                    dp[i][j] = min(dp[i][j],moveCost[grid[i-1][k]][j] + dp[i-1][k] + grid[i][j]);\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2141726,
                "title": "dp-python",
                "content": "Hope this helps\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # matrix to store the minimum cost to reach a cell for each cell\\n        matrix=  [[float(\\'inf\\') for i in range(len(grid[0]))] for j in range(len(grid))]\\n        \\n\\t\\t# for first row copying the grid as it is\\n        for m in range(len(matrix[0])):\\n            matrix[0][m] = grid[0][m]\\n        \\n        \\n        i=1\\n        while i<len(grid):\\n            for j in range(len(grid[0])):\\n                for k in range(len(moveCost[0])):\\n\\t\\t\\t\\t# now for each position (i,k) we calculate the \\n\\t\\t\\t\\t# minimum possible cost to reach this point \\n                    matrix[i][k] = min(matrix[i][k], matrix[i-1][j]+ moveCost[grid[i-1][j]][k]+grid[i][k])\\n\\t\\t\\t\\t\\t\\n            i+=1\\n        \\n        \\n\\n        # return the minimum cost in the last row in matrix that will be the ans\\n        return min(matrix[-1])\\n\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # matrix to store the minimum cost to reach a cell for each cell\\n        matrix=  [[float(\\'inf\\') for i in range(len(grid[0]))] for j in range(len(grid))]\\n        \\n\\t\\t# for first row copying the grid as it is\\n        for m in range(len(matrix[0])):\\n            matrix[0][m] = grid[0][m]\\n        \\n        \\n        i=1\\n        while i<len(grid):\\n            for j in range(len(grid[0])):\\n                for k in range(len(moveCost[0])):\\n\\t\\t\\t\\t# now for each position (i,k) we calculate the \\n\\t\\t\\t\\t# minimum possible cost to reach this point \\n                    matrix[i][k] = min(matrix[i][k], matrix[i-1][j]+ moveCost[grid[i-1][j]][k]+grid[i][k])\\n\\t\\t\\t\\t\\t\\n            i+=1\\n        \\n        \\n\\n        # return the minimum cost in the last row in matrix that will be the ans\\n        return min(matrix[-1])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141535,
                "title": "c-recursion-to-tabulation-dp-easy-to-understand",
                "content": "This problem is just an advanced version of [Triangle](https://leetcode.com/problems/triangle)\\nIn this we just need to recursively go deep (i.e.dfs) from starting point to last row the end point here is varible so we just need to make sure to reach last row, but here is the catch that startig point is also varible so we will loop through first row calling the dfs function at each coloumn point in the first row.\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,int cost){\\n        if(i==g.size()-1){\\n            ans=min(cost+g[i][j],ans);\\n            return;\\n        }\\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            solve(g,c,i+1,k,cost+c[g[i][j]][k]+g[i][j]);\\n        }    \\n        //\\n        return ;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        for(int i=0;i<g[0].size();i++){\\n            solve(g,c,0,i,0);\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFor memoization:\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,vector<vector<int>> &dp){\\n        if(i==g.size()-1){\\n            return g[i][j];\\n        }\\n        int temp=INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];//we need to calculate the min cost from each row to next coloumns \\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            temp=min(temp,c[g[i][j]][k]+g[i][j]+solve(g,c,i+1,k,dp));\\n        }    \\n        //\\n        return dp[i][j]=temp;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        vector<vector<int>> dp(g.size(),vector<int>(g[0].size(),-1));\\n        for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,solve(g,c,0,i,dp));\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nNow for Tabulation just :\\n```\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        //vector<vector<int>> dp(c.size()+1,vector<int>(c[0].size()+1,-1));\\n        for(int i=g.size()-2;i>=0;i--){//from bottom we will build this grid matrix\\n            for(int j=0;j<g[0].size();j++){//for each row we will choose different starting points\\n                int cost=INT_MAX;\\n                for(int k=0;k<g[0].size();k++){//for each starting point we will see the min cost for next row\\n                    cost=min(cost,c[g[i][j]][k]+g[i+1][k]);\\n                }\\n                g[i][j]+=cost;//then we will update that cost to our starting point\\n            }\\n        }\\n\\t\\t//finally after all this we will get min. costs from each of the starting points in the first row and we will find min. of them \\n         for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,g[0][i]);\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,int cost){\\n        if(i==g.size()-1){\\n            ans=min(cost+g[i][j],ans);\\n            return;\\n        }\\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            solve(g,c,i+1,k,cost+c[g[i][j]][k]+g[i][j]);\\n        }    \\n        //\\n        return ;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        for(int i=0;i<g[0].size();i++){\\n            solve(g,c,0,i,0);\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int solve(vector<vector<int>> &g,vector<vector<int>> &c,int i,int j,vector<vector<int>> &dp){\\n        if(i==g.size()-1){\\n            return g[i][j];\\n        }\\n        int temp=INT_MAX;\\n        if(dp[i][j]!=-1) return dp[i][j];//we need to calculate the min cost from each row to next coloumns \\n        for(int k=0;k<g[0].size();k++){\\n            //cout<<cost<<\" \"<<g[i][j]<<\" \"<<k<<endl;\\n            temp=min(temp,c[g[i][j]][k]+g[i][j]+solve(g,c,i+1,k,dp));\\n        }    \\n        //\\n        return dp[i][j]=temp;\\n    }\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        vector<vector<int>> dp(g.size(),vector<int>(g[0].size(),-1));\\n        for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,solve(g,c,0,i,dp));\\n            //cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nint minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n        //vector<vector<int>> dp(c.size()+1,vector<int>(c[0].size()+1,-1));\\n        for(int i=g.size()-2;i>=0;i--){//from bottom we will build this grid matrix\\n            for(int j=0;j<g[0].size();j++){//for each row we will choose different starting points\\n                int cost=INT_MAX;\\n                for(int k=0;k<g[0].size();k++){//for each starting point we will see the min cost for next row\\n                    cost=min(cost,c[g[i][j]][k]+g[i+1][k]);\\n                }\\n                g[i][j]+=cost;//then we will update that cost to our starting point\\n            }\\n        }\\n\\t\\t//finally after all this we will get min. costs from each of the starting points in the first row and we will find min. of them \\n         for(int i=0;i<g[0].size();i++){\\n            ans=min(ans,g[0][i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2141493,
                "title": "c-100-faster-o-m-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int p = m * n;\\n        vector<int> ans(p, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[grid[0][i]] = grid[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) { // i\\'th row\\n            for(int j = 0; j < n; j++) { // j\\'th column ; current element: grid[i][j]\\n                for(int k = 0; k < n; k++) { // previous row: i - 1, column: k\\n                        ans[grid[i][j]] = min(ans[grid[i][j]], ans[grid[i - 1][k]] + grid[i][j] + moveCost[grid[i - 1][k]][j]);\\n                }\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            res = min(res, ans[grid[m - 1][i]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int p = m * n;\\n        vector<int> ans(p, INT_MAX);\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[grid[0][i]] = grid[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) { // i\\'th row\\n            for(int j = 0; j < n; j++) { // j\\'th column ; current element: grid[i][j]\\n                for(int k = 0; k < n; k++) { // previous row: i - 1, column: k\\n                        ans[grid[i][j]] = min(ans[grid[i][j]], ans[grid[i - 1][k]] + grid[i][j] + moveCost[grid[i - 1][k]][j]);\\n                }\\n            }\\n        }\\n        \\n        int res = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            res = min(res, ans[grid[m - 1][i]]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141475,
                "title": "c-iterative-dp-1d-space-optimised",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int dp[m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i]=grid[0][i];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int temp[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                temp[j]=1e9;\\n                for(int k=0;k<m;k++)\\n                {\\n                    temp[j]=min(temp[j],moveCost[grid[i-1][k]][j]+dp[k]+grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=0;i<m;i++)\\n                dp[i]=temp[i];\\n        }\\n        \\n        int res=1e9;\\n        for(int i=0;i<m;i++)\\n            res=min(res,dp[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        \\n        int dp[m];\\n        \\n        for(int i=0;i<m;i++)\\n            dp[i]=grid[0][i];\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            int temp[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                temp[j]=1e9;\\n                for(int k=0;k<m;k++)\\n                {\\n                    temp[j]=min(temp[j],moveCost[grid[i-1][k]][j]+dp[k]+grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=0;i<m;i++)\\n                dp[i]=temp[i];\\n        }\\n        \\n        int res=1e9;\\n        for(int i=0;i<m;i++)\\n            res=min(res,dp[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141453,
                "title": "javascript-dijkstra",
                "content": "```js\\nclass Heap {\\n  constructor(list, compare = (a, b) => a - b) {\\n    this.left = index => 2 * index + 1\\n    this.right = index => 2 * index + 2\\n    this.parent = index => Math.floor((index - 1) / 2)\\n    this.heapify = (index = 0) => {\\n      const { list } = this\\n      const leftIndex = this.left(index)\\n      const rightIndex = this.right(index)\\n      let maxIndex = index\\n      if (list[leftIndex] !== undefined\\n        && this.compare(list[maxIndex], list[leftIndex]) > 0) {\\n        maxIndex = leftIndex\\n      }\\n      if (list[rightIndex] !== undefined\\n        && this.compare(list[maxIndex], list[rightIndex]) > 0) {\\n        maxIndex = rightIndex\\n      }\\n      if (index !== maxIndex) {\\n        const temp = list[index]\\n        list[index] = list[maxIndex]\\n        list[maxIndex] = temp\\n        this.heapify(maxIndex)\\n      }\\n    }\\n    this.buildHeap = () => {\\n      for (let i = Math.floor(this.list.length / 2); i >= 0; i--) {\\n        this.heapify(i)\\n      }\\n      return this.list\\n    }\\n    this.extract = () => {\\n      const temp = this.list[0]\\n      this.list[0] = this.list[this.list.length - 1]\\n      this.list[this.list.length - 1] = temp\\n      const result = this.list.pop()\\n      this.heapify(0)\\n      return result\\n    }\\n    this.insert = (item) => {\\n      const { list } = this\\n      list.push(item)\\n      let index = list.length - 1\\n      let parentIndex = this.parent(index)\\n      while (list[parentIndex] !== undefined && this.compare(list[parentIndex], list[index]) > 0) {\\n        const temp = list[index]\\n        list[index] = list[parentIndex]\\n        list[parentIndex] = temp\\n        index = parentIndex\\n        parentIndex = this.parent(index)\\n      }\\n    }\\n    this.list = list\\n    this.compare = compare\\n    this.buildHeap()\\n  }\\n}\\n\\n\\n/** Dijkstra\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nconst minPathCost = function (grid, moveCost) {\\n  const distance = []\\n  grid.forEach((list, row) => {\\n    distance[row] = []\\n    list.forEach((value, column) => {\\n      if (row === 0) {\\n        distance[row][column] = value\\n      } else {\\n        distance[row][column] = Infinity\\n      }\\n    })\\n  })\\n  const heap = new Heap(grid[0].map((value, index) => ({\\n    node: [0, index],\\n    value,\\n  })), (a, b) => a.value - b.value)\\n  while (heap.list.length) {\\n    const { node, value } = heap.extract()\\n    const [row, column] = node\\n    if (row < grid.length - 1) {\\n      for (let j = 0; j < grid[0].length; j++) {\\n        const currentValue = value + grid[row + 1][j] + moveCost[grid[row][column]][j]\\n        if (distance[row + 1][j] > currentValue) {\\n          distance[row + 1][j] = currentValue\\n          heap.insert({\\n            node: [row + 1, j],\\n            value: currentValue,\\n          })\\n        }\\n      }\\n    } else {\\n      return value\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\nclass Heap {\\n  constructor(list, compare = (a, b) => a - b) {\\n    this.left = index => 2 * index + 1\\n    this.right = index => 2 * index + 2\\n    this.parent = index => Math.floor((index - 1) / 2)\\n    this.heapify = (index = 0) => {\\n      const { list } = this\\n      const leftIndex = this.left(index)\\n      const rightIndex = this.right(index)\\n      let maxIndex = index\\n      if (list[leftIndex] !== undefined\\n        && this.compare(list[maxIndex], list[leftIndex]) > 0) {\\n        maxIndex = leftIndex\\n      }\\n      if (list[rightIndex] !== undefined\\n        && this.compare(list[maxIndex], list[rightIndex]) > 0) {\\n        maxIndex = rightIndex\\n      }\\n      if (index !== maxIndex) {\\n        const temp = list[index]\\n        list[index] = list[maxIndex]\\n        list[maxIndex] = temp\\n        this.heapify(maxIndex)\\n      }\\n    }\\n    this.buildHeap = () => {\\n      for (let i = Math.floor(this.list.length / 2); i >= 0; i--) {\\n        this.heapify(i)\\n      }\\n      return this.list\\n    }\\n    this.extract = () => {\\n      const temp = this.list[0]\\n      this.list[0] = this.list[this.list.length - 1]\\n      this.list[this.list.length - 1] = temp\\n      const result = this.list.pop()\\n      this.heapify(0)\\n      return result\\n    }\\n    this.insert = (item) => {\\n      const { list } = this\\n      list.push(item)\\n      let index = list.length - 1\\n      let parentIndex = this.parent(index)\\n      while (list[parentIndex] !== undefined && this.compare(list[parentIndex], list[index]) > 0) {\\n        const temp = list[index]\\n        list[index] = list[parentIndex]\\n        list[parentIndex] = temp\\n        index = parentIndex\\n        parentIndex = this.parent(index)\\n      }\\n    }\\n    this.list = list\\n    this.compare = compare\\n    this.buildHeap()\\n  }\\n}\\n\\n\\n/** Dijkstra\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nconst minPathCost = function (grid, moveCost) {\\n  const distance = []\\n  grid.forEach((list, row) => {\\n    distance[row] = []\\n    list.forEach((value, column) => {\\n      if (row === 0) {\\n        distance[row][column] = value\\n      } else {\\n        distance[row][column] = Infinity\\n      }\\n    })\\n  })\\n  const heap = new Heap(grid[0].map((value, index) => ({\\n    node: [0, index],\\n    value,\\n  })), (a, b) => a.value - b.value)\\n  while (heap.list.length) {\\n    const { node, value } = heap.extract()\\n    const [row, column] = node\\n    if (row < grid.length - 1) {\\n      for (let j = 0; j < grid[0].length; j++) {\\n        const currentValue = value + grid[row + 1][j] + moveCost[grid[row][column]][j]\\n        if (distance[row + 1][j] > currentValue) {\\n          distance[row + 1][j] = currentValue\\n          heap.insert({\\n            node: [row + 1, j],\\n            value: currentValue,\\n          })\\n        }\\n      }\\n    } else {\\n      return value\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141189,
                "title": "easy-dp-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n\\t\\t//initilize the first row of dp\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n\\t\\t// 2 loops for traversing\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t\\t// this loop for previous answer\\n                for(int k=0;k<m;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]+=grid[i][j];//adding the current grid[i][j] to dp\\n            }\\n        }\\n\\t\\t//finding the minimum\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n\\t\\t//initilize the first row of dp\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n\\t\\t// 2 loops for traversing\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t\\t// this loop for previous answer\\n                for(int k=0;k<m;k++){\\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]+=grid[i][j];//adding the current grid[i][j] to dp\\n            }\\n        }\\n\\t\\t//finding the minimum\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141181,
                "title": "with-explanation-o-1-space-c-dp",
                "content": "**Explanation:-**\\n1.  ```grid[i][j]```  will store the minimum cost required to  go to the last row\\n2.  For the m-1 leave it as it is because we are the last row.\\n3.  For the m-2 row try every possible comibanation and find the minimum for each ```grid[i][j]```.\\n4.  for the m-3 row do the same but we have already calculated minimum for each ```grid[i][j]``` for the m-2 row so just use that  for calculating minimum for m-3 row and so on till 1st row.\\n\\n This problem is similar to   [120. Triangle](https://leetcode.com/problems/triangle/) .Check this also\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size(),n=grid[0].size(),sz=cost.size();\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int  mini=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    int t=grid[i][j]+cost[grid[i][j]][k]+grid[i+1][k];\\n                    mini=min(mini,t);\\n                }\\n                grid[i][j]=mini;\\n            }     \\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n            mini=min(mini,grid[0][i]);\\n        return mini;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```grid[i][j]```\n```grid[i][j]```\n```grid[i][j]```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size(),n=grid[0].size(),sz=cost.size();\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int  mini=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    int t=grid[i][j]+cost[grid[i][j]][k]+grid[i+1][k];\\n                    mini=min(mini,t);\\n                }\\n                grid[i][j]=mini;\\n            }     \\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n            mini=min(mini,grid[0][i]);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141092,
                "title": "java-recursion-memoization",
                "content": "\\n```\\nclass Solution {\\n\\n    int[][] dp;\\n    public int solve(int i, int j, int[][] grid, int[][] moveCost){\\n        \\n        if(i == grid.length-1) {\\n            return grid[i][j];\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int[] cost = moveCost[grid[i][j]];\\n        \\n        int mn = Integer.MAX_VALUE;\\n        for(int idx = 0; idx < cost.length; idx++){\\n            mn  = Math.min(mn,solve(i+1,idx, grid, moveCost) + cost[idx] + grid[i][j]);\\n        }\\n        \\n        return dp[i][j] = mn;\\n    }\\n    \\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n        dp = new int[m+1][n+1];\\n        \\n        for(int i = 0; i < dp.length; i++){\\n            for(int j = 0; j < dp[0].length; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < grid[0].length; i++){\\n            ans = Math.min(ans, solve(0, i, grid,moveCost));\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int[][] dp;\\n    public int solve(int i, int j, int[][] grid, int[][] moveCost){\\n        \\n        if(i == grid.length-1) {\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141059,
                "title": "python-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        floor = len(grid) - 1\\n        memo = {}\\n\\n        def dfs(node, level):\\n            key = (node, level)\\n            if key in memo:\\n                return memo[key]\\n            if level == floor:\\n                return node\\n\\n            min_path = float(\\'inf\\')\\n            for i, next_node in enumerate(grid[level + 1]):\\n                path = dfs(next_node, level + 1) + moveCost[node][i]\\n                min_path = min(min_path, path)\\n\\n            memo[key] = min_path + node\\n            return memo[key]\\n\\n        result = float(\\'inf\\')\\n        for node in grid[0]:\\n            result = min(result, dfs(node, 0))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        floor = len(grid) - 1\\n        memo = {}\\n\\n        def dfs(node, level):\\n            key = (node, level)\\n            if key in memo:\\n                return memo[key]\\n            if level == floor:\\n                return node\\n\\n            min_path = float(\\'inf\\')\\n            for i, next_node in enumerate(grid[level + 1]):\\n                path = dfs(next_node, level + 1) + moveCost[node][i]\\n                min_path = min(min_path, path)\\n\\n            memo[key] = min_path + node\\n            return memo[key]\\n\\n        result = float(\\'inf\\')\\n        for node in grid[0]:\\n            result = min(result, dfs(node, 0))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140957,
                "title": "javascript-js-solution-beats-100",
                "content": "JavaScript solution\\n\\n```\\nvar minPathCost = function(grid, moveCost) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    const cache = [];\\n    \\n    for (let i = 0; i < rows; i++) {\\n        cache.push(Array(cols).fill(null));\\n    }\\n    \\n    function move(row, col) {\\n        const val = grid[row][col];\\n        \\n        if (cache[row][col] !== null) {\\n            return cache[row][col];\\n        }\\n        \\n        if (row === rows - 1) {\\n            return val;\\n        }\\n        \\n        let ans = Number.MAX_SAFE_INTEGER;\\n\\n        for (let i = 0; i < cols; i++) {\\n            const addCost = moveCost[val][i];\\n\\n            ans = Math.min(ans, move(row + 1, i) + val + addCost);\\n        }\\n        \\n        cache[row][col] = ans;\\n        \\n        return ans;\\n    }\\n\\n    let ans = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < cols; i++) {\\n        ans = Math.min(ans, move(0, i));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const rows = grid.length;\\n    const cols = grid[0].length;\\n\\n    const cache = [];\\n    \\n    for (let i = 0; i < rows; i++) {\\n        cache.push(Array(cols).fill(null));\\n    }\\n    \\n    function move(row, col) {\\n        const val = grid[row][col];\\n        \\n        if (cache[row][col] !== null) {\\n            return cache[row][col];\\n        }\\n        \\n        if (row === rows - 1) {\\n            return val;\\n        }\\n        \\n        let ans = Number.MAX_SAFE_INTEGER;\\n\\n        for (let i = 0; i < cols; i++) {\\n            const addCost = moveCost[val][i];\\n\\n            ans = Math.min(ans, move(row + 1, i) + val + addCost);\\n        }\\n        \\n        cache[row][col] = ans;\\n        \\n        return ans;\\n    }\\n\\n    let ans = Number.MAX_SAFE_INTEGER;\\n    \\n    for (let i = 0; i < cols; i++) {\\n        ans = Math.min(ans, move(0, i));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140955,
                "title": "dp-o-m-n-2-c",
                "content": "dp[i][j] is the min cost that we need to bear to reach the borrom row\\n```c++\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for (int j = 0; j < n; j++) {\\n            dp[m - 1][j] = grid[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = INT_MAX;\\n                int val = grid[i][j];\\n                for (int k = 0; k < n; k++) {\\n                    dp[i][j] = min(dp[i][j], moveCost[val][k] + val + dp[i + 1][k]);\\n                }\\n            }\\n        }\\n        \\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for (int j = 0; j < n; j++) {\\n            dp[m - 1][j] = grid[m - 1][j];\\n        }\\n        for (int i = m - 2; i >= 0; i--) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = INT_MAX;\\n                int val = grid[i][j];\\n                for (int k = 0; k < n; k++) {\\n                    dp[i][j] = min(dp[i][j], moveCost[val][k] + val + dp[i + 1][k]);\\n                }\\n            }\\n        }\\n        \\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140949,
                "title": "clean-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n         int n = grid.size() , m = grid[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n         for(int i=0; i<m; i++) dp[0][i]=grid[0][i];\\n         for(int i=1; i<n; i++) {\\n              for(int j=0; j<m; j++) {\\n                   for(int k=0; k<m; k++) dp[i][j] = min(movecost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j],dp[i][j]);\\n              }\\n         }\\n       return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n         int n = grid.size() , m = grid[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n         for(int i=0; i<m; i++) dp[0][i]=grid[0][i];\\n         for(int i=1; i<n; i++) {\\n              for(int j=0; j<m; j++) {\\n                   for(int k=0; k<m; k++) dp[i][j] = min(movecost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j],dp[i][j]);\\n              }\\n         }\\n       return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003798,
                "title": "dfs-recursive-dp-c-easy-to-understand-well-explained",
                "content": "# Complexity\\n- Time complexity:\\n    - The func function is called recursively for each cell in the grid, and memoization is used to avoid redundant calculations. The maximum number of unique subproblems that can be encountered is grid.`size() * grid[0].size()`, which is the number of cells in the grid.\\n    - For each subproblem, we iterate over `grid[0].size()` cells in the next row to compute the minimum cost. This is done for each subproblem.\\n    - So, the overall time complexity is approximately $$O(rows * cols * cols)$$, where rows and cols are the dimensions of the `grid`.\\n\\n- Space complexity:\\n    - The space complexity is mainly determined by the memoization table `dp`, which has dimensions `rows x cols`, where rows and cols are the dimensions of the `grid`.\\n    - Additionally, there are a few integer variables and function call stack space used for recursion.\\n    - Therefore, the space complexity is $$O(rows * cols)$$.\\n\\n# Code\\n```\\nclass Solution {\\n    int func(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>& dp)\\n    {\\n        if(i==(grid.size()-1))\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n            ans = min(ans,moveCost[grid[i][j]][k] + func(i+1,k,grid,moveCost,dp));\\n        }\\n        return dp[i][j] = grid[i][j]+ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(51,vector<int>(51,-1));\\n        int ans = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans = min(ans,func(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    int func(int i,int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>& dp)\\n    {\\n        if(i==(grid.size()-1))\\n            return grid[i][j];\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n            ans = min(ans,moveCost[grid[i][j]][k] + func(i+1,k,grid,moveCost,dp));\\n        }\\n        return dp[i][j] = grid[i][j]+ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(51,vector<int>(51,-1));\\n        int ans = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            ans = min(ans,func(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920880,
                "title": "c-recursion-memoization-tabulation",
                "content": "\\n# Approach\\nTrying every possible cell to cell combination and finding the minimum of all of them.\\n\\n# Complexity\\n\\n#### For recursion\\n- Time complexity : *Can\\'t figure out, plz tell if you can.* \\n(for every cell of a row it finds cost for further rows every time, whihc inc the time required much much...)\\n#### For memoization\\n- Time complexity : O(m*n^2)\\n#### For tabulation\\n- Time complexity : O(m^2 * n^2)\\n\\n\\n# Code\\n```\\n//---------------------- RECURSION--------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------MEMOIZATION (Best time complexity)----------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------------TABULATION---------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        // int ans = INT_MAX;\\n        // for(int i=0; i<grid[0].size(); i++)\\n        // {\\n        //     ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        // }\\n\\n\\n        //tabulation dp\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,1e9));\\n\\n        for(int i=0; i<=m*n-1; i++) dp[m][i] = 0;\\n\\n        for(int r = m-1; r>=1; r--)\\n        {\\n            //abb h val ki baari\\n            for(int val = 0; val<=m*n-1; val++)\\n            {\\n                int ans = INT_MAX;\\n                for(int i=0; i<grid[r].size(); i++)\\n                {\\n                    //moving to any column\\n                    ans = min(ans, grid[r][i] + cost[val][i] + dp[r+1][grid[r][i]]);\\n                    // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n                }\\n\\n                dp[r][val] = ans;\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = min(ans, grid[0][i] + dp[1][grid[0][i]]);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//---------------------- RECURSION--------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------MEMOIZATION (Best time complexity)----------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n//--------------------------TABULATION---------------------\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost, int r, int val, vector<vector<int>> &dp)\\n    {\\n        //the base case\\n        if(r == grid.size()) return 0;\\n\\n        if(dp[r][val] != -1) return dp[r][val];\\n\\n        //the main part\\n        int ans = INT_MAX;\\n        for(int i=0; i<grid[r].size(); i++)\\n        {\\n            //moving to any column\\n            ans = min(ans, grid[r][i] + cost[val][i] + solve(grid,cost,r+1,grid[r][i], dp));\\n            // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n        }\\n\\n        return dp[r][val] = ans;\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n\\n        // one parameter is r another is val\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,-1));\\n\\n        // int ans = INT_MAX;\\n        // for(int i=0; i<grid[0].size(); i++)\\n        // {\\n        //     ans = min(ans, grid[0][i] + solve(grid,cost,1,grid[0][i],dp));\\n        // }\\n\\n\\n        //tabulation dp\\n        vector<vector<int>> dp(m+2, vector<int> ((m*n)+2,1e9));\\n\\n        for(int i=0; i<=m*n-1; i++) dp[m][i] = 0;\\n\\n        for(int r = m-1; r>=1; r--)\\n        {\\n            //abb h val ki baari\\n            for(int val = 0; val<=m*n-1; val++)\\n            {\\n                int ans = INT_MAX;\\n                for(int i=0; i<grid[r].size(); i++)\\n                {\\n                    //moving to any column\\n                    ans = min(ans, grid[r][i] + cost[val][i] + dp[r+1][grid[r][i]]);\\n                    // ans = min(ans, cost[val][i] + solve(grid,cost,r+1,grid[r][i]));\\n                }\\n\\n                dp[r][val] = ans;\\n            }\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans = min(ans, grid[0][i] + dp[1][grid[0][i]]);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098798,
                "title": "python-clear-iterative-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        dp = [[v for v in grid[i]] for i in range(n)]\\n\\n        for i in range(1,n):      \\n            for j in range(m):\\n                all = [ dp[i-1][k] + moveCost[grid[i-1][k]][j] for k in range(m) ]\\n                dp[i][j] = min(all) + grid[i][j]\\n        return min(dp[-1])\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        dp = [[v for v in grid[i]] for i in range(n)]\\n\\n        for i in range(1,n):      \\n            for j in range(m):\\n                all = [ dp[i-1][k] + moveCost[grid[i-1][k]][j] for k in range(m) ]\\n                dp[i][j] = min(all) + grid[i][j]\\n        return min(dp[-1])\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781821,
                "title": "cpp-tabulation-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust doing normal tabulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we have to make a tabulated matrix with the values of INT_MAX.\\nand then you have to put all grid[0][i] in our tabulated[0][i] matrix and after that we have to just put values in our tabulated matrix, with simple traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            ans[0][i] = grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    ans[i][k] = min(moveCost[grid[i-1][j]][k]+ans[i-1][j]+grid[i][k],ans[i][k]);\\n                }\\n            }\\n        }\\n        int op = INT_MAX;\\n        for(int i=0;i<m;i++){\\n                op = min(op,ans[n-1][i]);\\n        }\\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            ans[0][i] = grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    ans[i][k] = min(moveCost[grid[i-1][j]][k]+ans[i-1][j]+grid[i][k],ans[i][k]);\\n                }\\n            }\\n        }\\n        int op = INT_MAX;\\n        for(int i=0;i<m;i++){\\n                op = min(op,ans[n-1][i]);\\n        }\\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725001,
                "title": "simple-python-djkstra-search-using-heapq",
                "content": "An annoying thing about this problem is the bizarre way that the question provides the information needed to determine costs, using the value of the cell rather than its row/column index in `moveCost`. Using the value rather than the row/column index allows `moveCost` to be a simple two-dimensional array, though, so I imagine that\\'s why the problem is constructed this way.\\n\\nOnce you get past that, the problem can be solved using a relatively straightforward application of djkstra.\\n\\nWe will use `heapq` to pick the lowest cost next choice, in a tuple of `(cost, cell, row)`.\\n\\nIf the `row` is `m - 1`, we\\'re done. It doesn\\'t matter which cell we happened to land on, because we know that it is some cell in the last row, and the algorithm ensures that it is the first one encountered in that row. So we return `cost`.\\n\\nOtherwise, when we encounter a cell, we check whether it is already defined in `lowest_cost`. If it is, then we skip it (continue) because it\\'s already been visited and the cost is strictly higher.\\n\\nIf it is not already defined, we set the `lowest_cost` to the `cost`. Then we go over each of the `n` choices for column in the next row `row + 1`. If the cell at `row + 1, c` has already obtained a value in `lowest_cost` then we do not add it to the `q` because there is no point in re-processing that cell. Otherwise, we add it to the `q`, where the new cost is `cost + moveCost[cell][c] + grid[row + 1][c]`.\\n\\nNote that this algorithm prevents a cell from being \"processed\" twice. The time complexity in the worst case should be about `m * n`.\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        lowest_cost = [math.inf] * (m * n)\\n        \\n        q = []\\n        \\n        for i, value in enumerate(grid[0]):\\n            heapq.heappush(q, (value, value, 0))\\n        \\n        while q:\\n            cost, cell, row = heapq.heappop(q)\\n            \\n            if row == m - 1:\\n                return cost\\n            \\n            if lowest_cost[cell] < math.inf:\\n                continue\\n            lowest_cost[cell] = cost\\n            \\n            for c in range(n):\\n                next_cell = grid[row + 1][c]\\n                if lowest_cost[next_cell] == math.inf:\\n                    heapq.heappush(q, (cost + moveCost[cell][c] + next_cell, next_cell, row + 1))\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        lowest_cost = [math.inf] * (m * n)\\n        \\n        q = []\\n        \\n        for i, value in enumerate(grid[0]):\\n            heapq.heappush(q, (value, value, 0))\\n        \\n        while q:\\n            cost, cell, row = heapq.heappop(q)\\n            \\n            if row == m - 1:\\n                return cost\\n            \\n            if lowest_cost[cell] < math.inf:\\n                continue\\n            lowest_cost[cell] = cost\\n            \\n            for c in range(n):\\n                next_cell = grid[row + 1][c]\\n                if lowest_cost[next_cell] == math.inf:\\n                    heapq.heappush(q, (cost + moveCost[cell][c] + next_cell, next_cell, row + 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683863,
                "title": "dp-o-n-m-and-o-2n-java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public int rec(int i,int j,int[][]grid,int[][]move,int [][]dp){\\n        if(i==grid.length-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int max=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++){\\n            int moveCost=grid[i][j]+move[grid[i][j]][k];\\n            max=Math.min(max,moveCost+rec(i+1,k,grid,move,dp));\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        int dp[][]=new int[m][n];\\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,rec(0,i,grid,moveCost,dp));\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rec(int i,int j,int[][]grid,int[][]move,int [][]dp){\\n        if(i==grid.length-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int max=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++){\\n            int moveCost=grid[i][j]+move[grid[i][j]][k];\\n            max=Math.min(max,moveCost+rec(i+1,k,grid,move,dp));\\n        }\\n        return dp[i][j]=max;\\n    }\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int ans=Integer.MAX_VALUE;\\n        int dp[][]=new int[m][n];\\n        for(int[] x : dp) Arrays.fill(x,-1);\\n        for(int i=0;i<n;i++){\\n            ans=Math.min(ans,rec(0,i,grid,moveCost,dp));\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420917,
                "title": "recursion-memoization-tabulation-does-not-require-extra-dp-array",
                "content": "Recursion:\\n```\\nclass Solution {\\npublic:\\n    int explorePaths(int i, int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost )\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        int minm=INT_MAX;\\n        for(int c=0; c<grid[0].size(); c++)\\n        {\\n            minm=min(minm,grid[i][j]+ moveCost[grid[i][j]][c] + explorePaths(i+1,c,grid,moveCost));\\n        }\\n        return minm;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            minm=min(minm,explorePaths(0,i,grid,moveCost));\\n        }\\n        return minm;\\n    }\\n};\\n```\\n\\nWith Memoization:\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```\\n\\nTabulation (Without DP vector space - result stored in grid vector)\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int explorePaths(int i, int j,vector<vector<int>>& grid, vector<vector<int>>& moveCost )\\n    {\\n        if(i==grid.size()-1)\\n            return grid[i][j];\\n        int minm=INT_MAX;\\n        for(int c=0; c<grid[0].size(); c++)\\n        {\\n            minm=min(minm,grid[i][j]+ moveCost[grid[i][j]][c] + explorePaths(i+1,c,grid,moveCost));\\n        }\\n        return minm;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            minm=min(minm,explorePaths(0,i,grid,moveCost));\\n        }\\n        return minm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int minm=INT_MAX;\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(),-1));\\n         for(int i=grid.size()-2; i>=0; i--)\\n        {\\n            for(int j=0; j<grid[0].size(); j++)\\n            {   minm=INT_MAX;\\n                for(int c=0; c<grid[0].size(); c++)\\n                    {\\n                        minm=min(minm,grid[i][j] + moveCost[grid[i][j]][c] + grid[i+1][c]);\\n                    }\\n             grid[i][j]=minm;\\n            }\\n        }\\n        minm=INT_MAX;\\n        for(int j=0; j<grid[0].size(); j++)\\n        {\\n            minm=min(minm,grid[0][j]);\\n        }\\n        return minm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417287,
                "title": "python-dijkstra-faster-than-90",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n          0 1          \\n       0 [9,8],\\n       1 [1,5],\\n       2 [10,12],\\n       3 [18,6],\\n       4 [2,4],\\n       5 [14,3]]\\n        \\n        \"\"\"\\n        max_r, max_c = len(grid), len(grid[0])\\n        heap = []\\n        graph = collections.defaultdict(dict)\\n        #step 1: create dictionary of the form value: {column_number: cost}\\n        for idx,costs in enumerate(moveCost):\\n            for col_num, val in enumerate(costs):\\n                graph[idx][col_num] = val\\n        \\n        #step 2: add all the values in first row inside a heap\\n        for i in range(max_c):\\n            heapq.heappush(heap, [grid[0][i], 0, i]) #cost, row, column\\n        seen = {}\\n        while heap:\\n            #print(heap)\\n            current_cost, current_row, current_column = heapq.heappop(heap)\\n            if current_row == max_r - 1:\\n                return current_cost\\n            #append every single element in the next row to our heap\\n            for i in range(max_c):\\n                new_row = current_row + 1\\n                new_col = i\\n                current_value = grid[current_row][current_column]\\n                new_cost = graph[current_value][new_col] + current_cost + grid[new_row][new_col]\\n                if (new_row, new_col) in seen and seen[(new_row, new_col)] <= new_cost:\\n                    continue\\n                seen[(new_row, new_col)] = new_cost\\n                heapq.heappush(heap, [new_cost, new_row, new_col])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n          0 1          \\n       0 [9,8],\\n       1 [1,5],\\n       2 [10,12],\\n       3 [18,6],\\n       4 [2,4],\\n       5 [14,3]]\\n        \\n        \"\"\"\\n        max_r, max_c = len(grid), len(grid[0])\\n        heap = []\\n        graph = collections.defaultdict(dict)\\n        #step 1: create dictionary of the form value: {column_number: cost}",
                "codeTag": "Java"
            },
            {
                "id": 2378446,
                "title": "java-dp-faster-than-95-51-less-than-44-91",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] curr = Arrays.copyOf(grid[0], grid[0].length);\\n        int[] next = new int[curr.length];\\n        for (int i = 1; i < grid.length; i++) {\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < curr.length; j++) {\\n                int key = grid[i-1][j];\\n                for (int k = 0; k < next.length; k++) next[k] = Math.min(next[k], curr[j]+moveCost[key][k]);\\n            }\\n            for (int j = 0; j < curr.length; j++) curr[j] = next[j]+grid[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int num : curr) min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] curr = Arrays.copyOf(grid[0], grid[0].length);\\n        int[] next = new int[curr.length];\\n        for (int i = 1; i < grid.length; i++) {\\n            Arrays.fill(next, Integer.MAX_VALUE);\\n            for (int j = 0; j < curr.length; j++) {\\n                int key = grid[i-1][j];\\n                for (int k = 0; k < next.length; k++) next[k] = Math.min(next[k], curr[j]+moveCost[key][k]);\\n            }\\n            for (int j = 0; j < curr.length; j++) curr[j] = next[j]+grid[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int num : curr) min = Math.min(min, num);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300463,
                "title": "c-solution-recursive-memoization-easy-to-understand-commented",
                "content": "class Solution {\\npublic:\\n*     int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(r, vector<int>(c, -1));\\n        for(int i = 0;i < c; i++)  // We\\'ll start with every column in the first row\\n        {\\n            ans = min(ans, solve(c, r, grid, moveCost, 0, i, dp));\\n        }\\n        return ans;\\n    }\\n    \\n    // RECURSION + MEMOIZATION\\n    \\n*     int solve(int& col, int& row, vector<vector<int>>& grid, vector<vector<int>>& cost, int currrow, int currcol, vector<vector<int>>& dp){\\n        if(currrow == row-1)\\n        {\\n            return grid[currrow][currcol];  // If we have reached the last row we return the value of the current cell.\\n        }\\n        if(dp[currrow][currcol] != -1)\\n            return dp[currrow][currcol];\\n        int ans = INT_MAX;\\n        // We\\'ll jump to every column in the next row and add the value of current cell + the cost of path to our answer and return minimum of all paths\\n            for(int j = 0;j < col; j++)  \\n            {\\n                ans = min(ans, grid[currrow][currcol] + cost[grid[currrow][currcol]][j] + solve(col, row, grid, cost, currrow+1, j, dp));\\n            }\\n        return dp[currrow][currcol] = ans;\\n    }\\n};\\n**Do Upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n*     int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(r, vector<int>(c, -1));\\n        for(int i = 0;i < c; i++)  // We\\'ll start with every column in the first row\\n        {\\n            ans = min(ans, solve(c, r, grid, moveCost, 0, i, dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2277118,
                "title": "c-easy-understanding-code-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n       int solve(vector<vector<int>>& g,vector<vector<int>>& c,int i,int j)\\n       {\\n           if(i==g.size()-1)\\n               return g[i][j];\\n           \\n           if(dp[i][j]!=-1)\\n               return dp[i][j];\\n           \\n            int temp=g[i][j];\\n            int cost=INT_MAX;\\n           \\n               for(int k=0;k<g[0].size();k++)\\n               {\\n                   cost=min(cost,c[temp][k]+solve(g,c,i+1,k));\\n               }\\n           \\n           return dp[i][j]=cost+temp;\\n       }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int ans=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n              ans=min(ans,solve(grid,moveCost,0,j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n       int solve(vector<vector<int>>& g,vector<vector<int>>& c,int i,int j)\\n       {\\n           if(i==g.size()-1)\\n               return g[i][j];\\n           \\n           if(dp[i][j]!=-1)\\n               return dp[i][j];\\n           \\n            int temp=g[i][j];\\n            int cost=INT_MAX;\\n           \\n               for(int k=0;k<g[0].size();k++)\\n               {\\n                   cost=min(cost,c[temp][k]+solve(g,c,i+1,k));\\n               }\\n           \\n           return dp[i][j]=cost+temp;\\n       }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost)\\n    {\\n        int ans=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n              ans=min(ans,solve(grid,moveCost,0,j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214758,
                "title": "c-easy-recursive-function-with-memoization-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[51][51];\\n    int util(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j, int n, int m){\\n        \\n        // we have reached the last row , therefore we will simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=INT_MAX;\\n        \\n        // we will check for every value in the next row and check for minimum \\n        \\n        // moveCost[grid[i][j]][k] this will give the cost of moving grid[i][j], i.e the value of the current cell to column \\'k\\'\\n        \\n        for(int k=0;k<m;k++){\\n            ans=min(ans, grid[i][j] + \\n                    moveCost[grid[i][j]][k]+util(grid,moveCost,i+1,k,n,m));\\n        }\\n        \\n        return t[i][j]=ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        memset(t,-1,sizeof(t));\\n        \\n        int ans=INT_MAX;\\n        \\n        // we will start for every value in the first row , and check minimum\\n        \\n        for(int i=0;i<m;i++){\\n            ans= min (  ans , util(grid,moveCost,0,i,n,m) );\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int t[51][51];\\n    int util(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j, int n, int m){\\n        \\n        // we have reached the last row , therefore we will simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        int ans=INT_MAX;\\n        \\n        // we will check for every value in the next row and check for minimum \\n        \\n        // moveCost[grid[i][j]][k] this will give the cost of moving grid[i][j], i.e the value of the current cell to column \\'k\\'\\n        \\n        for(int k=0;k<m;k++){\\n            ans=min(ans, grid[i][j] + \\n                    moveCost[grid[i][j]][k]+util(grid,moveCost,i+1,k,n,m));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2188255,
                "title": "python3",
                "content": "```\\ndef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\tm = len(grid[0])\\n\\tdp = grid[0]\\n\\tfor i in range(1, n):\\n\\t\\tprev = dp[:]\\n\\t\\tdp = [float(\"inf\")]*m\\n\\t\\tfor j in range(m):    \\n\\t\\t\\tfor _j, num in enumerate(grid[i-1]):\\n\\t\\t\\t\\tdp[j] = min(dp[j], grid[i][j]+prev[_j]+moveCost[num][j])\\n\\treturn min(dp)\\n",
                "solutionTags": [],
                "code": "```\\ndef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\tn = len(grid)\\n\\tm = len(grid[0])\\n\\tdp = grid[0]\\n\\tfor i in range(1, n):\\n\\t\\tprev = dp[:]\\n\\t\\tdp = [float(\"inf\")]*m\\n\\t\\tfor j in range(m):    \\n\\t\\t\\tfor _j, num in enumerate(grid[i-1]):\\n\\t\\t\\t\\tdp[j] = min(dp[j], grid[i][j]+prev[_j]+moveCost[num][j])\\n\\treturn min(dp)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2172738,
                "title": "cpp-dp-simple",
                "content": "**we can compare this problem with the some other Leetcode problem like Triangle,Minimum Path Sum etc.\\nHere we apply simple concept of Dynamic Programing (DP).**\\n\\n**Here each cell of our precalculated matrix basically show the minimum path_sum till that cell from the top.**\\n\\n**We will initialize the 1st row of our dp matrix to same value in the grid first row as path , beacuse cells of 1st row shows the minimum path sum to reach that Cell from any cell of previous row but as it is first row there is no row above it so it basically mean movinng to the same cell;**\\n\\n**We will take dp array to be same dimension as our grid matrix;**\\n\\n**Other cell accept the 1st row\\'s cell will be initializes with following relation :**\\n\\n**dp[i][j]=min_Sum_Path_to_reach_current_Cell + grid[i][j]**\\n\\n**we will calculate the \"min_Sum_Path_to_reach_current_Cell\" by runing an loop for row previous to our current row,it will be more clear if you see the coding part of it**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    dp[i][j]=grid[i][j];\\n                    continue;\\n                }\\n                int min_path=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    min_path=min(min_path,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=min_path+grid[i][j];\\n            }\\n        }\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=min(res,dp[m-1][i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Ilike the solution ? \"Upvote\" : any suggestions drop it, i will welcome it;**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0)\\n                {\\n                    dp[i][j]=grid[i][j];\\n                    continue;\\n                }\\n                int min_path=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    min_path=min(min_path,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=min_path+grid[i][j];\\n            }\\n        }\\n        \\n        int res=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            res=min(res,dp[m-1][i]);\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166069,
                "title": "o-1-space-complexity-dp",
                "content": "Cpp Code:\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying grid itself\\n        int m=g.size(), n=g[0].size(), temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=INT_MAX;\\n                for(int k=0; k<n; k++) {\\n                    temp=min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0; j<n; j++) ans=min(ans, g[0][j]);\\n        return ans;\\n    }\\n};\\n```\\n\\nJava Code:\\n```\\nclass Solution {\\n    public int minPathCost(int[][] g, int[][] mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying the grid itself\\n        int m=g.length, n=g[0].length, temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++) {\\n                    temp=Math.min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int j=0; j<n; j++) ans=Math.min(ans, g[0][j]);\\n        return ans;\\n    }\\n}\\n```\\nPlease Upvote if you like my solution :))",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying grid itself\\n        int m=g.size(), n=g[0].size(), temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=INT_MAX;\\n                for(int k=0; k<n; k++) {\\n                    temp=min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0; j<n; j++) ans=min(ans, g[0][j]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPathCost(int[][] g, int[][] mo) {\\n        // Tabulation-DP-Bottom Up; TC: O(m*n*n); SC: O(1)\\n        // Here SC: O(1) bcz we are modifying the grid itself\\n        int m=g.length, n=g[0].length, temp;\\n        for(int i=m-2; i>=0; i--) {\\n            for(int j=0; j<n; j++) {\\n                temp=Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++) {\\n                    temp=Math.min(temp, g[i][j]+g[i+1][k]+mo[g[i][j]][k]);\\n                }\\n                g[i][j]=temp;\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int j=0; j<n; j++) ans=Math.min(ans, g[0][j]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158707,
                "title": "java-easy-explainable-solution-dp-space-o-m-n-8ms",
                "content": "**DP (Bottom-up) approach: O(n2)**\\n**Time:** `O(m*n*n)`, **space:** `O(m*n)`\\n```\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length, path_sum = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n\\n        for(int i = 0; i < n; i++)                                // copy last element of grid to dp\\n            dp[m - 1][i] = grid[m-1][i];\\n\\n        for(int i = m - 2; i >= 0; i--) {                         // row traversal\\n            for(int j = 0; j < n; j++) {\\n                int min_sum = Integer.MAX_VALUE;                  // column traversal for each row\\n\\n                for (int k = 0; k < n; k++) {\\n                    min_sum = Math.min(min_sum, dp[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n\\n                dp[i][j] = min_sum + grid[i][j];                  // update min. cost from arr[i][j] to arr[i+1][0,1..n-1]\\n                \\n                if(i == 0)                                         // when we will reach at top\\n                    path_sum = Math.min(path_sum, dp[0][j]);       // get the min. cost to reach from bottom to up\\n            }\\n        }\\n\\n        return path_sum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length, n = grid[0].length, path_sum = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n\\n        for(int i = 0; i < n; i++)                                // copy last element of grid to dp\\n            dp[m - 1][i] = grid[m-1][i];\\n\\n        for(int i = m - 2; i >= 0; i--) {                         // row traversal\\n            for(int j = 0; j < n; j++) {\\n                int min_sum = Integer.MAX_VALUE;                  // column traversal for each row\\n\\n                for (int k = 0; k < n; k++) {\\n                    min_sum = Math.min(min_sum, dp[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n\\n                dp[i][j] = min_sum + grid[i][j];                  // update min. cost from arr[i][j] to arr[i+1][0,1..n-1]\\n                \\n                if(i == 0)                                         // when we will reach at top\\n                    path_sum = Math.min(path_sum, dp[0][j]);       // get the min. cost to reach from bottom to up\\n            }\\n        }\\n\\n        return path_sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2155836,
                "title": "java-solution-recursion-and-memoization",
                "content": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        dp=new Integer[grid.length][grid[0].length];\\n        int ans=Integer.MAX_VALUE;\\n       \\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            ans=Math.min(ans,grid[0][i]+helper(grid,moveCost,grid[0][i],1));\\n        }\\n        return ans;\\n    }\\n    public int helper(int[][] grid,int[][] moveCost,int cur,int i)\\n    {\\n        if(i==grid.length)\\n        {\\n            return 0;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++)\\n        {\\n            int a=Integer.MAX_VALUE;\\n            if(dp[i][k]!=null)\\n            {\\n                a=dp[i][k];\\n            }\\n            else\\n            {\\n                a=helper(grid,moveCost,grid[i][k],i+1);\\n                dp[i][k]=a;\\n            }\\n            ans=Math.min(grid[i][k]+moveCost[cur][k]+a,ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int minPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        dp=new Integer[grid.length][grid[0].length];\\n        int ans=Integer.MAX_VALUE;\\n       \\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            ans=Math.min(ans,grid[0][i]+helper(grid,moveCost,grid[0][i],1));\\n        }\\n        return ans;\\n    }\\n    public int helper(int[][] grid,int[][] moveCost,int cur,int i)\\n    {\\n        if(i==grid.length)\\n        {\\n            return 0;\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int k=0;k<grid[0].length;k++)\\n        {\\n            int a=Integer.MAX_VALUE;\\n            if(dp[i][k]!=null)\\n            {\\n                a=dp[i][k];\\n            }\\n            else\\n            {\\n                a=helper(grid,moveCost,grid[i][k],i+1);\\n                dp[i][k]=a;\\n            }\\n            ans=Math.min(grid[i][k]+moveCost[cur][k]+a,ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155116,
                "title": "python-2-liner-solution-using-lambda-function-and-lru-cache",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, x: List[List[int]], cost: List[List[int]]) -> int:\\n        f=lru_cache(None)(lambda i,j:0 if i==len(x)-1 else min(cost[x[i][j]][k]+f(i+1,k)+x[i+1][k] for k in range(len(x[0]))))\\n        return min(x[0][j]+f(0,j) for j in range(len(x[0])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, x: List[List[int]], cost: List[List[int]]) -> int:\\n        f=lru_cache(None)(lambda i,j:0 if i==len(x)-1 else min(cost[x[i][j]][k]+f(i+1,k)+x[i+1][k] for k in range(len(x[0]))))\\n        return min(x[0][j]+f(0,j) for j in range(len(x[0])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148918,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def minPathCost(grid: Array[Array[Int]], moveCost: Array[Array[Int]]): Int = grid.headOption match {\\n    case Some(row) => grid\\n      .iterator\\n      .zip(grid.iterator.drop(1))\\n      .foldLeft(row) {\\n        case (minCosts, (from, to)) => Array.tabulate(row.length) { i =>\\n          to(i) + Iterator.range(0, row.length).map(j => minCosts(j) + moveCost(from(j))(i)).min\\n        }\\n      }\\n      .minOption\\n      .getOrElse(0)\\n      \\n    case None => 0\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n  def minPathCost(grid: Array[Array[Int]], moveCost: Array[Array[Int]]): Int = grid.headOption match {\\n    case Some(row) => grid\\n      .iterator\\n      .zip(grid.iterator.drop(1))\\n      .foldLeft(row) {\\n        case (minCosts, (from, to)) => Array.tabulate(row.length) { i =>\\n          to(i) + Iterator.range(0, row.length).map(j => minCosts(j) + moveCost(from(j))(i)).min\\n        }\\n      }\\n      .minOption\\n      .getOrElse(0)\\n      \\n    case None => 0\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2147237,
                "title": "c-clean-commented-code-dp-beats-100",
                "content": "```\\n/*\\nAPPROACH\\n1. brute force:\\nexplore all paths -> exponential, TC = O(m^n)\\n\\n2. Optimization -> DP:\\nIntutition: we notice there are repeated sub problems\\nIn example1, suppose we need to reach the last row from first row, some of the possibilites are:\\n5->4->2, 3->4->2,......\\nwe notice there are repeated sub problmes, 4->2\\n\\nDP equation:\\ndp[i][j] = grid[i][j] + [min(dp[i - 1][k] + moveCost[grid[i - 1][k]][j]), for all k in cols]\\n\\nTC -> O(m * n * n), SC -> O(m * n)\\n\\n3. Optimation of approach (2) in terms of space\\nwe can optimize the above approach in space since we only need the previous row for calculating the current row dp.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {        \\n        int rows = grid.size(), cols = grid[0].size(); // get the size of rows and cols\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0)); // initialize dp\\n        dp[0] = grid[0]; int res = INT_MAX; // intialize dp[0]\\n        // apply DP algorithm as explained above\\n        for (int i = 1; i < rows; ++i){\\n            for (int j = 0; j < cols; ++j){\\n                int curr = INT_MAX;\\n                for (int k = 0; k < cols; ++k){\\n                    curr = min(curr, dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                dp[i][j] = grid[i][j] + curr;\\n                if (i == rows - 1) res = min(res, dp[i][j]); // store the minimum result for the last row\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nAPPROACH\\n1. brute force:\\nexplore all paths -> exponential, TC = O(m^n)\\n\\n2. Optimization -> DP:\\nIntutition: we notice there are repeated sub problems\\nIn example1, suppose we need to reach the last row from first row, some of the possibilites are:\\n5->4->2, 3->4->2,......\\nwe notice there are repeated sub problmes, 4->2\\n\\nDP equation:\\ndp[i][j] = grid[i][j] + [min(dp[i - 1][k] + moveCost[grid[i - 1][k]][j]), for all k in cols]\\n\\nTC -> O(m * n * n), SC -> O(m * n)\\n\\n3. Optimation of approach (2) in terms of space\\nwe can optimize the above approach in space since we only need the previous row for calculating the current row dp.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {        \\n        int rows = grid.size(), cols = grid[0].size(); // get the size of rows and cols\\n        vector<vector<int>> dp(rows, vector<int>(cols, 0)); // initialize dp\\n        dp[0] = grid[0]; int res = INT_MAX; // intialize dp[0]\\n        // apply DP algorithm as explained above\\n        for (int i = 1; i < rows; ++i){\\n            for (int j = 0; j < cols; ++j){\\n                int curr = INT_MAX;\\n                for (int k = 0; k < cols; ++k){\\n                    curr = min(curr, dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                dp[i][j] = grid[i][j] + curr;\\n                if (i == rows - 1) res = min(res, dp[i][j]); // store the minimum result for the last row\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147036,
                "title": "dp-memoized-solution-clean-code-c",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>> &g, vector<vector<int>> &c)\\n    {\\n        if(i==g.size()-1) return g[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int tempAns = 5001;\\n        for(int k =0; k<c[0].size(); k++)\\n        {\\n            tempAns = min(tempAns, g[i][j] + c[g[i][j]][k] + dfs(i+1,k,g,c));\\n        }\\n        \\n        return dp[i][j] = tempAns;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n       \\n        int n = g.size(), m = g[0].size();\\n        \\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        int ans = 5001;\\n        for(int j =0; j<m; j++)\\n        {\\n            ans = min(ans,dfs(0,j,g,c));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>> &g, vector<vector<int>> &c)\\n    {\\n        if(i==g.size()-1) return g[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int tempAns = 5001;\\n        for(int k =0; k<c[0].size(); k++)\\n        {\\n            tempAns = min(tempAns, g[i][j] + c[g[i][j]][k] + dfs(i+1,k,g,c));\\n        }\\n        \\n        return dp[i][j] = tempAns;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& g, vector<vector<int>>& c) {\\n       \\n        int n = g.size(), m = g[0].size();\\n        \\n        dp.resize(n+1,vector<int>(m+1,-1));\\n        int ans = 5001;\\n        for(int j =0; j<m; j++)\\n        {\\n            ans = min(ans,dfs(0,j,g,c));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144415,
                "title": "cpp-short-dijkstra-algorithm-beats-100-solutions-learning-materials",
                "content": "This problem is considered to be solved by DP because of how it is formulated. However, I solved it using Dijkstra algorithm :)  \\nIf you want to learn more about graph algorithms, pelase see the separate post: https://leetcode.com/discuss/study-guide/1326900/graph-algorithms-problems-to-practice\\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tusing ip = std::array<int, 3>;\\n\\tpriority_queue<ip, vector<ip>, greater<ip>> pq;\\n\\tvector<vector<int>> dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\tpq.push({grid[0][i], 0, i});\\n\\t\\tdist[0][i] = grid[0][i];\\n\\t}\\n\\twhile (!pq.empty()) {\\n\\t\\tauto [cost, row, col] = pq.top(); pq.pop();\\n\\t\\tif (row == grid.size() - 1) break;\\n\\t\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\t\\tint nrow = row + 1, ncol = i;\\n\\t\\t\\tint newcost = grid[nrow][ncol] + moveCost[grid[row][col]][ncol];\\n\\t\\t\\tif (dist[nrow][ncol] > dist[row][col] + newcost) {\\n\\t\\t\\t\\tdist[nrow][ncol] = dist[row][col] + newcost;\\n\\t\\t\\t\\tpq.push({dist[nrow][ncol], nrow, ncol});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dist[grid.size() - 1].begin(), dist[grid.size() - 1].end());\\n}\\n```\\nReference for DP solution. Two things to notice:\\n1. Copy first row from original matrix to dp to save initial values for costs.\\n2. Recurrence relateion is super easy because we have to arrive at the given cell by the rules defined in the problem: we can arrive to a cell from any other cell above.\\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tint rows = grid.size(), cols = grid[0].size();\\n\\tvector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n\\tdp[0] = grid[0];\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tfor (int k = 0; k < cols; k++) {\\n\\t\\t\\t\\tdp[i][k] = min(dp[i][k], \\n\\t\\t\\t\\t\\t\\t\\t   grid[i][k] + dp[i - 1][j] + moveCost[grid[i - 1][j]][k]);   \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dp[rows - 1].begin(), dp[rows - 1].end());\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tusing ip = std::array<int, 3>;\\n\\tpriority_queue<ip, vector<ip>, greater<ip>> pq;\\n\\tvector<vector<int>> dist(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\tpq.push({grid[0][i], 0, i});\\n\\t\\tdist[0][i] = grid[0][i];\\n\\t}\\n\\twhile (!pq.empty()) {\\n\\t\\tauto [cost, row, col] = pq.top(); pq.pop();\\n\\t\\tif (row == grid.size() - 1) break;\\n\\t\\tfor (int i = 0; i < grid[0].size(); i++) {\\n\\t\\t\\tint nrow = row + 1, ncol = i;\\n\\t\\t\\tint newcost = grid[nrow][ncol] + moveCost[grid[row][col]][ncol];\\n\\t\\t\\tif (dist[nrow][ncol] > dist[row][col] + newcost) {\\n\\t\\t\\t\\tdist[nrow][ncol] = dist[row][col] + newcost;\\n\\t\\t\\t\\tpq.push({dist[nrow][ncol], nrow, ncol});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dist[grid.size() - 1].begin(), dist[grid.size() - 1].end());\\n}\\n```\n```\\nint minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n\\tint rows = grid.size(), cols = grid[0].size();\\n\\tvector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n\\tdp[0] = grid[0];\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tfor (int k = 0; k < cols; k++) {\\n\\t\\t\\t\\tdp[i][k] = min(dp[i][k], \\n\\t\\t\\t\\t\\t\\t\\t   grid[i][k] + dp[i - 1][j] + moveCost[grid[i - 1][j]][k]);   \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn *min_element(dp[rows - 1].begin(), dp[rows - 1].end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142586,
                "title": "c-python-1d-dp",
                "content": "We start from row 0 and keep on calculating the min cost to reach current cell and storing the same, The min cost to reach a cell will be min of all path possilbe path costs. \\n\\n*path cost to reach a cell* = *Cost of current cell + path cost to reach origin cell + moveCost to reach this cell from origin cell*, Where origin cell is previous cell from which we are coming from. \\n\\nWe can optimise the standard 2D array method to 1D array by storing the values of previous row only, Since once we have moved ahead of a row we do not need any other row other than it\\'s previous row.\\n\\n**C++**\\n\\n```\\nclass Solution {\\n    public:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // declarations\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Intitalize an array to store mincost to reach 0th row elements\\n        vector<int> dp = grid[0];\\n\\n        // Check what is min cost to get to current cell\\n        for (int i = 1; i < n; i++) {\\n            /* We only care about immediate previous so we do not need to store other values\\n               other than previous row values and use those values to get mincost for current row.\\n            */\\n            vector<int> ndp(m, INT_MAX);\\n            for (int j = 0; j < m; j++) {\\n                // Explore every possible way and get the min out of it.\\n                for (int k = 0; k < m; k++) {\\n                    int prev = grid[i - 1][k];\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j]);\\n                }\\n            }\\n            // Current row is our previous row as we move forward, So we update the same.\\n            dp = ndp;\\n        }\\n        return *min_element(begin(dp), end(dp));\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # declarations\\n        n, m = len(grid), len(grid[0])\\n\\n        # Intitalize an array to store mincost to reach 0th row elements\\n        dp = grid[0]\\n\\n        # Check what is min cost to get to current cell\\n        for i in range(1, n):\\n\\n            # We only care about immediate previous so we do not need to store other values\\n            # other than previous row values and use those values to get mincost for current row.\\n            ndp = [10 ** 9 for i in range(m)]\\n\\n            for j in range(m):\\n\\n                # Explore every possible way and get the min out of it.\\n                for k in range(m):\\n                    prev = grid[i - 1][k]\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j])\\n\\n            dp = ndp  # Current row is our previous row as we move forward, So we update the same.\\n\\n        return min(dp)\\n\\n```\\n\\nSpace complexity:  **O(m)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // declarations\\n        int n = grid.size(), m = grid[0].size();\\n\\n        // Intitalize an array to store mincost to reach 0th row elements\\n        vector<int> dp = grid[0];\\n\\n        // Check what is min cost to get to current cell\\n        for (int i = 1; i < n; i++) {\\n            /* We only care about immediate previous so we do not need to store other values\\n               other than previous row values and use those values to get mincost for current row.\\n            */\\n            vector<int> ndp(m, INT_MAX);\\n            for (int j = 0; j < m; j++) {\\n                // Explore every possible way and get the min out of it.\\n                for (int k = 0; k < m; k++) {\\n                    int prev = grid[i - 1][k];\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j]);\\n                }\\n            }\\n            // Current row is our previous row as we move forward, So we update the same.\\n            dp = ndp;\\n        }\\n        return *min_element(begin(dp), end(dp));\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        # declarations\\n        n, m = len(grid), len(grid[0])\\n\\n        # Intitalize an array to store mincost to reach 0th row elements\\n        dp = grid[0]\\n\\n        # Check what is min cost to get to current cell\\n        for i in range(1, n):\\n\\n            # We only care about immediate previous so we do not need to store other values\\n            # other than previous row values and use those values to get mincost for current row.\\n            ndp = [10 ** 9 for i in range(m)]\\n\\n            for j in range(m):\\n\\n                # Explore every possible way and get the min out of it.\\n                for k in range(m):\\n                    prev = grid[i - 1][k]\\n                    ndp[j] = min(ndp[j], dp[k] + moveCost[prev][j] + grid[i][j])\\n\\n            dp = ndp  # Current row is our previous row as we move forward, So we update the same.\\n\\n        return min(dp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142498,
                "title": "dp-naive",
                "content": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> cost;\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cst) {\\n        m=grid.size(), n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        cost= cst;\\n        \\n        int res=INT_MAX;\\n        for(int i=0; i<n; i++)\\n            res=min(res, getSum(grid, dp, 0, i));\\n        \\n        return res;\\n    }\\n    \\n    int getSum(vector<vector<int>>& grid, vector<vector<int>>& dp, int crow, int ccol){\\n        if(crow>=m)\\n            return 0;\\n        \\n        if(crow==m-1)\\n            return grid[crow][ccol];\\n        \\n        if(ccol>=n)\\n            return INT_MAX;\\n        \\n        if(dp[crow][ccol]!=0)\\n            return dp[crow][ccol];\\n        \\n        int p=INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n            p= min(p, grid[crow][ccol]+cost[grid[crow][ccol]][i]+ getSum(grid, dp, crow+1, i));\\n        \\n        dp[crow][ccol]= p;\\n        \\n        return dp[crow][ccol];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    vector<vector<int>> cost;\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cst) {\\n        m=grid.size(), n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        cost= cst;\\n        \\n        int res=INT_MAX;\\n        for(int i=0; i<n; i++)\\n            res=min(res, getSum(grid, dp, 0, i));\\n        \\n        return res;\\n    }\\n    \\n    int getSum(vector<vector<int>>& grid, vector<vector<int>>& dp, int crow, int ccol){\\n        if(crow>=m)\\n            return 0;\\n        \\n        if(crow==m-1)\\n            return grid[crow][ccol];\\n        \\n        if(ccol>=n)\\n            return INT_MAX;\\n        \\n        if(dp[crow][ccol]!=0)\\n            return dp[crow][ccol];\\n        \\n        int p=INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n            p= min(p, grid[crow][ccol]+cost[grid[crow][ccol]][i]+ getSum(grid, dp, crow+1, i));\\n        \\n        dp[crow][ccol]= p;\\n        \\n        return dp[crow][ccol];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142052,
                "title": "c-100-faster-tc-o-n3-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>ans(m,INT_MAX);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n             ans[i]=min(ans[i],grid[0][j]+grid[1][i]+moveCost[grid[0][j]][i]);\\n            }\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            vector<int>temp(m,INT_MAX);\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k=0;k<m;k++)\\n                {\\n                  temp[j]=min(temp[j],ans[k]+grid[i+1][j]+moveCost[grid[i][k]][j]);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        // for(int i:ans) cout<<i<<\" \";\\n        return *min_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>ans(m,INT_MAX);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n             ans[i]=min(ans[i],grid[0][j]+grid[1][i]+moveCost[grid[0][j]][i]);\\n            }\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            vector<int>temp(m,INT_MAX);\\n            for(int j=0;j<m;j++)\\n            {\\n                for(int k=0;k<m;k++)\\n                {\\n                  temp[j]=min(temp[j],ans[k]+grid[i+1][j]+moveCost[grid[i][k]][j]);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        // for(int i:ans) cout<<i<<\" \";\\n        return *min_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2142019,
                "title": "dp-with-memoization-easiest-solution",
                "content": "class Solution {\\npublic:\\n    int helper(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n            ans=min(ans,grid[i][j]+cost[grid[i][j]][k]+helper(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=ans;\\n        \\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans=INT_MAX;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141910,
                "title": "dijkstra",
                "content": "\\t   class Solution {\\n\\t   public:\\n      int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>q;\\n        vector<vector<int>>matrix(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        for(int i=0;i<grid[0].size();i++){\\n            q.push({grid[0][i],grid[0][i],0});\\n            matrix[0][i]=grid[0][i];\\n        }\\n        int n=grid.size();\\n        \\n        int mini=INT_MAX;\\n        while(!q.empty()){\\n            vector<int>curr=q.top();\\n            q.pop();\\n            \\n            \\n            if(curr[2]==n-1){\\n                mini=min(curr[0],mini);\\n                break;\\n            }\\n            int next=curr[2]+1;\\n            for(int i=0;i<grid[0].size();i++){\\n                if(grid[next][i]+moveCost[curr[1]][i]+curr[0]<matrix[next][i]){ \\n                q.push({grid[next][i]+moveCost[curr[1]][i]+curr[0],grid[next][i],next});\\n                matrix[next][i]=grid[next][i]+moveCost[curr[1]][i]+curr[0];\\n                }\\n            }\\n        }\\n        return mini;\\n        \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t   public:\\n      int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        priority_queue<vector<int>,vector<vector<int>>,greater<>>q;\\n        vector<vector<int>>matrix(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        for(int i=0;i<grid[0].size();i++){\\n            q.push({grid[0][i],grid[0][i],0}",
                "codeTag": "Java"
            },
            {
                "id": 2141610,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity : O(N * M)***\\n\\n* ***Space Complexity : O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[55][55];\\n    \\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, vector<vector<int>>& cost)\\n    {\\n        if(i == n - 1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int k = 0; k < m; k++)\\n        {\\n            int temp = grid[i][j] + cost[grid[i][j]][k] + helper(grid, i + 1, k, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        \\n        int n = grid.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int m = grid[0].size();\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int temp = helper(grid, 0, j, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[55][55];\\n    \\n    int helper(vector<vector<int>>& grid, int i, int j, int n, int m, vector<vector<int>>& cost)\\n    {\\n        if(i == n - 1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int k = 0; k < m; k++)\\n        {\\n            int temp = grid[i][j] + cost[grid[i][j]][k] + helper(grid, i + 1, k, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return dp[i][j] = mini;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        \\n        int n = grid.size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        int m = grid[0].size();\\n        \\n        int mini = INT_MAX;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int temp = helper(grid, 0, j, n, m, cost);\\n            \\n            mini = min(mini, temp);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141443,
                "title": "easy-dp-solution",
                "content": "The basic naive approach is to think of recursion. Then try to visualize that you are at position (row,col) and now try to move to position (row+1,j) so this step would take a cost of\\ngrid[row][col] + moveCost[grid[row][col]][j] and then call recursion to compute futher. Base case is simple that is if you reach row == m - 1 just return the grid[row][col];\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>> &dp){\\n        // base case\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==m-1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = INT_MAX;\\n        int val = grid[row][col];\\n        for(int j=0;j<n;j++){\\n            int cost = val + moveCost[val][j];\\n            ans = min(ans,cost+solve(row+1,j,grid,moveCost,dp));\\n        }\\n        \\n        return dp[row][col] = ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please like if you find useful**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row,int col,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>> &dp){\\n        // base case\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(row==m-1){\\n            return grid[row][col];\\n        }\\n        \\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        \\n        int ans = INT_MAX;\\n        int val = grid[row][col];\\n        for(int j=0;j<n;j++){\\n            int cost = val + moveCost[val][j];\\n            ans = min(ans,cost+solve(row+1,j,grid,moveCost,dp));\\n        }\\n        \\n        return dp[row][col] = ans;\\n        \\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141371,
                "title": "dp-recursion-memoization-check-for-very-coloumn",
                "content": "class Solution {\\npublic:\\n\\t   \\n\\t// Here focus on three things\\n\\t// 1- We have to check for every column because we can start from any of the column for first row.\\n\\t// 2- when we reach last row we have to ignore the moveCost.\\n\\t// 3- Check for every possible direction from an element can move.\\n\\t\\n\\tint n,m;\\n    unordered_map<int,vector<int>>mp;\\n    int dp[51][51];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(i==n-1) return grid[i][j]; // for 2 condition i mentioned above (ignore moveCost for last row only return its value)\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int y = grid[i][j];\\n        auto v = mp[y];\\n        int x = INT_MAX;\\n        for(int k=0;k<v.size();k++){   // For the 3 cond mentioned above (check for every possible dir in which we can move)\\n            x = min(x,v[k]+solve(grid,i+1,k));\\n        }\\n        return dp[i][j] = (x+grid[i][j]);\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n        for(int i=0;i<(m*n);i++){\\n            mp[i] = cost[i];\\n        }\\n        int c = INT_MAX;\\n        for(int j=0;j<m;j++){     // for the 1st condition i mentioned above.(we have to check for every cloumn for first row)\\n            c = min(c,solve(grid,0,j));\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\t   \\n\\t// Here focus on three things\\n\\t// 1- We have to check for every column because we can start from any of the column for first row.\\n\\t// 2- when we reach last row we have to ignore the moveCost.\\n\\t// 3- Check for every possible direction from an element can move.\\n\\t\\n\\tint n,m;\\n    unordered_map<int,vector<int>>mp;\\n    int dp[51][51];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        if(i==n-1) return grid[i][j]; // for 2 condition i mentioned above (ignore moveCost for last row only return its value)\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int y = grid[i][j];\\n        auto v = mp[y];\\n        int x = INT_MAX;\\n        for(int k=0;k<v.size();k++){   // For the 3 cond mentioned above (check for every possible dir in which we can move)\\n            x = min(x,v[k]+solve(grid,i+1,k));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141344,
                "title": "java-topdown-dp",
                "content": "```\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j] = grid[i][j];\\n            }\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int temp = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    temp = Math.min(temp,moveCost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j]);\\n                }\\n                dp[i][j] = temp;\\n            }\\n        }\\n        for(int k=0; k<n; k++){\\n            res = Math.min(res, dp[m-1][k]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res = Integer.MAX_VALUE;\\n        int[][] dp = new int[m][n];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j] = grid[i][j];\\n            }\\n        }\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int temp = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    temp = Math.min(temp,moveCost[grid[i-1][k]][j]+dp[i-1][k]+grid[i][j]);\\n                }\\n                dp[i][j] = temp;\\n            }\\n        }\\n        for(int k=0; k<n; k++){\\n            res = Math.min(res, dp[m-1][k]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141229,
                "title": "simple-c-dp",
                "content": "``` \\n int minpath(vector<vector<int>>&grid,vector<vector<int>>&moveCost){\\n    vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n    for(int k=0;k<grid[0].size();k++){\\n        dp[0][k]=grid[0][k];\\n    }\\n    for(int i=1;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            for(int k=0;k<grid[0].size();k++){\\n                int x=grid[i-1][k];\\n                dp[i][j]=min(dp[i-1][k]+grid[i][j]+moveCost[x][j],dp[i][j]);\\n            }\\n        }\\n    }\\n    int ans=INT_MAX;\\n    for(int k=0;k<grid[0].size();k++){\\n        ans=min(dp[grid.size()-1][k],ans);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\n int minpath(vector<vector<int>>&grid,vector<vector<int>>&moveCost){\\n    vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n    for(int k=0;k<grid[0].size();k++){\\n        dp[0][k]=grid[0][k];\\n    }\\n    for(int i=1;i<grid.size();i++){\\n        for(int j=0;j<grid[0].size();j++){\\n            for(int k=0;k<grid[0].size();k++){\\n                int x=grid[i-1][k];\\n                dp[i][j]=min(dp[i-1][k]+grid[i][j]+moveCost[x][j],dp[i][j]);\\n            }\\n        }\\n    }\\n    int ans=INT_MAX;\\n    for(int k=0;k<grid[0].size();k++){\\n        ans=min(dp[grid.size()-1][k],ans);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141203,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSum(vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp, int r, int c) {\\n        if(r == grid.size() - 1)\\n            return grid[r][c];\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int val = grid[r][c];\\n        int minval = INT_MAX;\\n        for(int i = 0;i < cost[val].size();i++) {\\n            minval = min(minval, val+cost[val][i]+findSum(grid, cost, dp, r+1, i));\\n        }\\n        return dp[r][c] = minval;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int minval = INT_MAX;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> dp(r, vector<int> (c, -1));\\n        for(int i = 0;i < c;i++) {\\n            minval = min(minval, findSum(grid, cost, dp, 0, i));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSum(vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp, int r, int c) {\\n        if(r == grid.size() - 1)\\n            return grid[r][c];\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n        \\n        int val = grid[r][c];\\n        int minval = INT_MAX;\\n        for(int i = 0;i < cost[val].size();i++) {\\n            minval = min(minval, val+cost[val][i]+findSum(grid, cost, dp, r+1, i));\\n        }\\n        return dp[r][c] = minval;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int minval = INT_MAX;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<int>> dp(r, vector<int> (c, -1));\\n        for(int i = 0;i < c;i++) {\\n            minval = min(minval, findSum(grid, cost, dp, 0, i));\\n        }\\n        return minval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141194,
                "title": "easy-c-o-n-m-m-solution-o-m-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mp) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> v(m);\\n        \\n        for(int i=0;i<m;i++){\\n            v[i]=grid[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            \\n            vector<int> temp(m);\\n            for(int j=0;j<m;j++){\\n                \\n                int cost=INT_MAX;\\n                \\n                for(int k=0;k<m;k++){\\n                    \\n                    int temp=v[k]+mp[grid[i-1][k]][j]+grid[i][j];\\n                    \\n                    cost=min(cost,temp);\\n                    \\n                    \\n                }\\n                \\n                temp[j]=cost;\\n                \\n            }\\n            \\n            v=temp;\\n            \\n            \\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,v[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mp) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int> v(m);\\n        \\n        for(int i=0;i<m;i++){\\n            v[i]=grid[0][i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            \\n            vector<int> temp(m);\\n            for(int j=0;j<m;j++){\\n                \\n                int cost=INT_MAX;\\n                \\n                for(int k=0;k<m;k++){\\n                    \\n                    int temp=v[k]+mp[grid[i-1][k]][j]+grid[i][j];\\n                    \\n                    cost=min(cost,temp);\\n                    \\n                    \\n                }\\n                \\n                temp[j]=cost;\\n                \\n            }\\n            \\n            v=temp;\\n            \\n            \\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,v[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141122,
                "title": "c-top-down-dp-minimum-path-cost-in-a-grid",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[55][55];\\n    vector<vector<int>> g, m;\\npublic:\\n    int solve(int x, int y){\\n        if(x >= g.size() - 1) return g[x][y];\\n        int &ret = dp[x][y];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX / 2;\\n        for(int i = 0; i < m[x].size(); i++){\\n            ret = min(ret, g[x][y] + m[g[x][y]][i] + solve(x + 1, i));\\n        }\\n        return ret;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        g = grid, m = moveCost;\\n        memset(dp, -1, sizeof dp);\\n        int ans = INT_MAX;\\n        for(int i = 0; i < g[0].size(); i++){\\n            ans = min(ans, solve(0, i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[55][55];\\n    vector<vector<int>> g, m;\\npublic:\\n    int solve(int x, int y){\\n        if(x >= g.size() - 1) return g[x][y];\\n        int &ret = dp[x][y];\\n        if(ret != -1) return ret;\\n        ret = INT_MAX / 2;\\n        for(int i = 0; i < m[x].size(); i++){\\n            ret = min(ret, g[x][y] + m[g[x][y]][i] + solve(x + 1, i));\\n        }\\n        return ret;\\n    }\\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        g = grid, m = moveCost;\\n        memset(dp, -1, sizeof dp);\\n        int ans = INT_MAX;\\n        for(int i = 0; i < g[0].size(); i++){\\n            ans = min(ans, solve(0, i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141063,
                "title": "c-dp",
                "content": "```\\n    public int MinPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        int[] rowPrev = grid[0];\\n        int[] rowCurr = new int[grid[0].Length];\\n\\n        for (int i = 1; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[0].Length; j++)\\n            {\\n                int min = int.MaxValue;\\n                for (int k = 0; k < grid[0].Length; k++)\\n                {\\n                    min = Math.Min(min, rowPrev[k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                rowCurr[j] = min + grid[i][j];\\n            }\\n            rowPrev = rowCurr.ToArray();\\n        }\\n        return rowCurr.Min();\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int MinPathCost(int[][] grid, int[][] moveCost) \\n    {\\n        int[] rowPrev = grid[0];\\n        int[] rowCurr = new int[grid[0].Length];\\n\\n        for (int i = 1; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[0].Length; j++)\\n            {\\n                int min = int.MaxValue;\\n                for (int k = 0; k < grid[0].Length; k++)\\n                {\\n                    min = Math.Min(min, rowPrev[k] + moveCost[grid[i - 1][k]][j]);\\n                }\\n                rowCurr[j] = min + grid[i][j];\\n            }\\n            rowPrev = rowCurr.ToArray();\\n        }\\n        return rowCurr.Min();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141040,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    int minPathCost(vector<vector<int>>& v, vector<vector<int>>& costs) {\\n        ll m = v.size(), n = v[0].size();\\n        // for (ll i = 0;i < n;++i)\\n        //     v[m - 1][i] = 0;\\n        for (ll i = m - 2;i > -1;--i) {\\n            for (ll j = 0;j < n;++j) {\\n                ll ans = LLONG_MAX;\\n                for (ll k = 0;k < n;++k)\\n                    ans = min(ans, ll(v[i + 1][k] + v[i][j] + costs[v[i][j]][k]));\\n                v[i][j] = ans;\\n            }\\n        }\\n        return *min_element(v[0].begin(), v[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    int minPathCost(vector<vector<int>>& v, vector<vector<int>>& costs) {\\n        ll m = v.size(), n = v[0].size();\\n        // for (ll i = 0;i < n;++i)\\n        //     v[m - 1][i] = 0;\\n        for (ll i = m - 2;i > -1;--i) {\\n            for (ll j = 0;j < n;++j) {\\n                ll ans = LLONG_MAX;\\n                for (ll k = 0;k < n;++k)\\n                    ans = min(ans, ll(v[i + 1][k] + v[i][j] + costs[v[i][j]][k]));\\n                v[i][j] = ans;\\n            }\\n        }\\n        return *min_element(v[0].begin(), v[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141026,
                "title": "c-easy-implementation-o-m-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(); int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<n;i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n            int x=100000;\\n           for(int k=0;k<n;k++){\\n                x=min(x,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n            } \\n            dp[i][j]=x+grid[i][j];\\n        }\\n        }\\n        int ans=100000001;\\n        for(int i=0;i<n;i++) ans=min(ans,dp[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m=grid.size(); int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=0;i<n;i++) dp[m-1][i]=grid[m-1][i];\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n            int x=100000;\\n           for(int k=0;k<n;k++){\\n                x=min(x,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n            } \\n            dp[i][j]=x+grid[i][j];\\n        }\\n        }\\n        int ans=100000001;\\n        for(int i=0;i<n;i++) ans=min(ans,dp[0][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140992,
                "title": "c-dfs",
                "content": "**Dfs**\\n```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& memo){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n           ans = min(ans,  grid[i][j]+cost[grid[i][j]][k] + dfs(i+1, k, grid, cost, memo));           \\n        }\\n        return memo[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid[0].size(), n=grid.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, dfs(0, i, grid, cost, memo));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& memo){\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=-1) return memo[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++){\\n           ans = min(ans,  grid[i][j]+cost[grid[i][j]][k] + dfs(i+1, k, grid, cost, memo));           \\n        }\\n        return memo[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid[0].size(), n=grid.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> memo(n, vector<int>(m, -1));\\n        for(int i=0;i<m;i++){\\n            ans=min(ans, dfs(0, i, grid, cost, memo));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140976,
                "title": "minimum-path-cost-in-a-grid-cpp",
                "content": "class Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, map<pair<int, int>, int>& mp, int row, int col, vector<vector<int>> &dp){\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }\\n        int ans = INT_MAX;\\n        if(dp[row][col] != -1) return dp[row][col];\\n        for(int j=0;j<grid[row].size();j++){\\n            int pathCost = grid[row][col] + mp[{grid[row][col], j}];\\n            int getCost = f(grid, mp, row+1, j, dp);\\n            ans = min(ans, pathCost + getCost);\\n        }\\n        return dp[row][col] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        map<pair<int, int>, int> mp;\\n        for(int i=0;i<(m*n);i++){\\n            for(int j=0;j<n;j++){\\n                mp.insert({{i, j}, moveCost[i][j]});\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int x = f(grid, mp, 0, i, dp);\\n            ans = min(ans, x);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, map<pair<int, int>, int>& mp, int row, int col, vector<vector<int>> &dp){\\n        if(row == grid.size() - 1){\\n            return grid[row][col];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2140952,
                "title": "elegant-dp-solution-o-m-n-2-time",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[][]=new int[m][n];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int val=Integer.MAX_VALUE;\\n                    for(int k=0;k<n;k++){\\n                        val=Math.min(val,dp[i+1][k] +grid[i][j]+ moveCost[grid[i][j]][k]);\\n                    }\\n                    dp[i][j]=val;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int m=grid.length,n=grid[0].length;\\n        int dp[][]=new int[m][n];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j];\\n                }\\n                else{\\n                    int val=Integer.MAX_VALUE;\\n                    for(int k=0;k<n;k++){\\n                        val=Math.min(val,dp[i+1][k] +grid[i][j]+ moveCost[grid[i][j]][k]);\\n                    }\\n                    dp[i][j]=val;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140948,
                "title": "java-dp-solution",
                "content": "1. Initialize dp matrix\\n2. For each row, keep on aggregating min cost from previous row using the dp matrix\\n3. Result is minimum cost in the last row.\\n\\n```\\nprivate int minPathCost(int[][] grid, int[][] moveCost) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        int[][] dp = new int[rows][columns];\\n        for (int i = 0; i < columns; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n\\n        for (int i = 1; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                int value = grid[i][j];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = 0; k < columns; k++) {\\n                    int dpValue = grid[i-1][k];\\n                    int penalty = moveCost[dpValue][j];\\n                    min = Math.min(min, value + penalty + dp[i - 1][k]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < columns; i++) {\\n            result = Math.min(result, dp[rows - 1][i]);\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int minPathCost(int[][] grid, int[][] moveCost) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n\\n        int[][] dp = new int[rows][columns];\\n        for (int i = 0; i < columns; i++) {\\n            dp[0][i] = grid[0][i];\\n        }\\n\\n        for (int i = 1; i < rows; i++) {\\n            for (int j = 0; j < columns; j++) {\\n                int value = grid[i][j];\\n                int min = Integer.MAX_VALUE;\\n                for (int k = 0; k < columns; k++) {\\n                    int dpValue = grid[i-1][k];\\n                    int penalty = moveCost[dpValue][j];\\n                    min = Math.min(min, value + penalty + dp[i - 1][k]);\\n                }\\n                dp[i][j] = min;\\n            }\\n        }\\n\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < columns; i++) {\\n            result = Math.min(result, dp[rows - 1][i]);\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140941,
                "title": "simple-dp-solution-bottom-up",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][] dp = new int[row][col];\\n        \\n        // filling the first row\\n        for(int c = 0; c<col; c++){\\n            dp[0][c] = grid[0][c];\\n        }\\n        \\n        // filling other rows\\n        for(int r = 1; r<row; r++){\\n            for(int c = 0; c<col; c++){\\n                dp[r][c] = getMin(grid, moveCost, r, c, dp);\\n            }\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int k : dp[row-1])\\n            result = Math.min(result, k);\\n        \\n        return result;\\n        \\n    }\\n    \\n    // we\\'ll go through all the cells in previous row to find min path to current cell.\\n    private int getMin(int[][] grid, int[][] moveCost, int row, int col, int[][] dp){\\n        int min = Integer.MAX_VALUE, previousRow = row-1;\\n        // traversing through the previous row\\n        for(int c = 0; c<grid[0].length; c++){\\n            min = Math.min(min, dp[previousRow][c] + grid[row][col] + moveCost[grid[previousRow][c]][col]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int row = grid.length, col = grid[0].length;\\n        int[][] dp = new int[row][col];\\n        \\n        // filling the first row\\n        for(int c = 0; c<col; c++){\\n            dp[0][c] = grid[0][c];\\n        }\\n        \\n        // filling other rows\\n        for(int r = 1; r<row; r++){\\n            for(int c = 0; c<col; c++){\\n                dp[r][c] = getMin(grid, moveCost, r, c, dp);\\n            }\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int k : dp[row-1])\\n            result = Math.min(result, k);\\n        \\n        return result;\\n        \\n    }\\n    \\n    // we\\'ll go through all the cells in previous row to find min path to current cell.\\n    private int getMin(int[][] grid, int[][] moveCost, int row, int col, int[][] dp){\\n        int min = Integer.MAX_VALUE, previousRow = row-1;\\n        // traversing through the previous row\\n        for(int c = 0; c<grid[0].length; c++){\\n            min = Math.min(min, dp[previousRow][c] + grid[row][col] + moveCost[grid[previousRow][c]][col]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140929,
                "title": "c",
                "content": "Upvote If you like\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a = grid[i][j];\\n                int mini = INT_MAX;\\n                for(int k=0;k<moveCost[a].size();k++)\\n                {\\n                    mini = min(mini,moveCost[a][k]+grid[i+1][k]+grid[i][j]);\\n                }\\n                grid[i][j]=mini;\\n            }\\n        }\\n        return *min_element(grid[0].begin(),grid[0].end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int a = grid[i][j];\\n                int mini = INT_MAX;\\n                for(int k=0;k<moveCost[a].size();k++)\\n                {\\n                    mini = min(mini,moveCost[a][k]+grid[i+1][k]+grid[i][j]);\\n                }\\n                grid[i][j]=mini;\\n            }\\n        }\\n        return *min_element(grid[0].begin(),grid[0].end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082419,
                "title": "simple-bottom-up-approach",
                "content": "# Intuition & Approach\\n\\nGoal :- to find min number of moves to reach (i,j), you can come from any previous row or column to current row and column. We have, for all (i,j) you might have come from (i-1,(any column from 0 to m-1)). So, if we find the minimum cost to reach each and every cell:-\\n```\\nfor all col = 0 to n\\n            dp[i][j] = min(dp[i-1][col]+moveCost[grid[i-1][col]][j]+grid[i-1][col]). \\n```\\n        \\n\\nwhere dp[i][j] denotes the minimum cost to reach (i,j), from any previous path\\n\\n# Complexity\\n- Time complexity:\\nO(m*n^2)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,0));\\n    \\n        for(int i = 1; i<m; i++)\\n        {\\n            for(int j = 0 ; j<n; j++)\\n            {\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k<n; k++)\\n                {\\n                    //moving from i-1,k to i,j \\n                    if(dp[i-1][k]!=INT_MAX)\\n                    {\\n                        dp[i][j] = min((long)dp[i-1][k]+moveCost[grid[i-1][k]][j]+grid[i-1][k],(long)dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i= 0; i<n; i++)\\n        {\\n            ans= min(ans, dp[m-1][i]+grid[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor all col = 0 to n\\n            dp[i][j] = min(dp[i-1][col]+moveCost[grid[i-1][col]][j]+grid[i-1][col]). \\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,0));\\n    \\n        for(int i = 1; i<m; i++)\\n        {\\n            for(int j = 0 ; j<n; j++)\\n            {\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k<n; k++)\\n                {\\n                    //moving from i-1,k to i,j \\n                    if(dp[i-1][k]!=INT_MAX)\\n                    {\\n                        dp[i][j] = min((long)dp[i-1][k]+moveCost[grid[i-1][k]][j]+grid[i-1][k],(long)dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i= 0; i<n; i++)\\n        {\\n            ans= min(ans, dp[m-1][i]+grid[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060336,
                "title": "khandani-tareeka-of-dp-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    int dp[][];\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n        m=grid.length;\\n        n=grid[0].length;\\n        dp=new int[m+1][n+1];\\n        for(int d[]:dp)Arrays.fill(d,-1);\\n\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n\\n            result=Math.min(result,solve(grid,moveCost,0,i));\\n\\n        }\\n        return result;\\n        \\n    }\\n    public int solve(int[][] g, int[][] mc,int i,int j){\\n        if(i>=m-1)return g[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\n        int ans=Integer.MAX_VALUE;\\n        for(int move=0;move<n;move++){\\n            ans=Math.min(ans,g[i][j]+mc[g[i][j]][move]+solve(g,mc,i+1,move));\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    int dp[][];\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n        m=grid.length;\\n        n=grid[0].length;\\n        dp=new int[m+1][n+1];\\n        for(int d[]:dp)Arrays.fill(d,-1);\\n\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n\\n            result=Math.min(result,solve(grid,moveCost,0,i));\\n\\n        }\\n        return result;\\n        \\n    }\\n    public int solve(int[][] g, int[][] mc,int i,int j){\\n        if(i>=m-1)return g[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n\\n        int ans=Integer.MAX_VALUE;\\n        for(int move=0;move<n;move++){\\n            ans=Math.min(ans,g[i][j]+mc[g[i][j]][move]+solve(g,mc,i+1,move));\\n            \\n        }\\n        return dp[i][j]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049522,
                "title": "dfs-dynamic-programming-recursive-easy-to-understand",
                "content": "# Intuition\\nThe code aims to find the minimum path cost in a grid where you can move from one row to the next row while choosing the minimum cost path at each step. The cost of moving from one cell to another is given in the moveCost matrix, and you start from the top row and want to reach the bottom row with the minimum total cost.\\n\\n# Approach\\n\\n1. Create a recursive function `dfs` that takes the current row (`r`), current column (`c`), the grid, the `moveCost` matrix, and a memoization matrix `dp`. The function will return the minimum path cost from the current cell to the bottom row.\\n\\n2. Inside the `dfs` function:\\n   - Check if you are at the bottom row (`r == n - 1`). If so, return the cost of the current cell because there are no more rows to move to.\\n\\n   - Check if the result for the current cell has already been computed and stored in the `dp` matrix (`dp[r][c] != -1`). If so, return the memoized result to avoid redundant calculations.\\n\\n   - Initialize a variable `mini` to store the minimum cost. Initialize it with a very large value (`INT_MAX`) to ensure any valid cost is smaller.\\n\\n   - Iterate through all the possible columns (`i`) you can move to in the next row (`r + 1`). Calculate the cost of moving to the next row and column `i` from the current cell. This cost is the sum of the current cell\\'s value, the cost in the `moveCost` matrix for moving from the current cell\\'s value to `i`, and the result of a recursive call to `dfs` for the next row `r + 1` and column `i`.\\n\\n   - Update `mini` with the minimum of its current value and the calculated cost.\\n\\n   - Store the calculated minimum cost in the `dp` matrix at the current cell `dp[r][c]`.\\n\\n   - Finally, return the minimum cost `mini` as the result.\\n\\n3. In the `minPathCost` function:\\n   - Initialize a variable `mini` to store the minimum path cost. Initialize it with a very large value (`INT_MAX`) to ensure any valid cost is smaller.\\n\\n   - Create a memoization matrix `dp` of the same size as the grid and initialize it with -1 to indicate that no results have been calculated yet.\\n\\n   - Iterate through all possible starting columns in the top row (`i` from 0 to `m-1`), where `m` is the number of columns in the grid.\\n\\n   - For each starting column `i`, calculate the minimum path cost by calling the `dfs` function with the starting row as 0 and starting column as `i`. Update `mini` with the minimum of its current value and the result from `dfs`.\\n\\n4. After iterating through all possible starting columns, return the minimum path cost `mini` as the final result.\\n\\nThis approach ensures that you calculate the minimum path cost from the top row to the bottom row while avoiding redundant calculations by memoizing previously computed results in the `dp` matrix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * m^2)$$\\n\\n- Space complexity:\\n $$O(n * m)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (r == n - 1) {\\n            return grid[r][c];\\n        }\\n\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            int cur = grid[r][c] + moveCost[grid[r][c]][i] + dfs(r + 1, i, grid, moveCost, dp);\\n            mini = min(mini, cur);\\n        }\\n\\n        \\n        return dp[r][c] = mini;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            mini = min(mini, dfs(0, i, grid, moveCost, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if (r == n - 1) {\\n            return grid[r][c];\\n        }\\n\\n        if (dp[r][c] != -1) {\\n            return dp[r][c];\\n        }\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            int cur = grid[r][c] + moveCost[grid[r][c]][i] + dfs(r + 1, i, grid, moveCost, dp);\\n            mini = min(mini, cur);\\n        }\\n\\n        \\n        return dp[r][c] = mini;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n\\n        int mini = INT_MAX;\\n        for (int i = 0; i < m; i++) {\\n            mini = min(mini, dfs(0, i, grid, moveCost, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039180,
                "title": "easy-just-dp-memoize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int find(vector<vector<int>>& grid,int i,int j,int n,int m,vector<vector<int>>& cost)\\n    {\\n        if(i==n-1)\\n        return grid[i][j];\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=INT_MAX;\\n\\n        for(int k=0;k<m;k++)\\n        {   int x=grid[i][j];\\n            ans=min(ans,x+cost[x][k]+find(grid,i+1,k,n,m,cost));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,find(grid,0,j,n,m,moveCost));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][51];\\n    int find(vector<vector<int>>& grid,int i,int j,int n,int m,vector<vector<int>>& cost)\\n    {\\n        if(i==n-1)\\n        return grid[i][j];\\n        if(dp[i][j]!=-1)\\n        return dp[i][j];\\n        int ans=INT_MAX;\\n\\n        for(int k=0;k<m;k++)\\n        {   int x=grid[i][j];\\n            ans=min(ans,x+cost[x][k]+find(grid,i+1,k,n,m,cost));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,find(grid,0,j,n,m,moveCost));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037980,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,vector<vector<int>>& moveCost,int i,int j){\\n        if(i == grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        for(int k = 0;k < grid[i].size();k++)\\n            dp[i][j] = min(dp[i][j],grid[i][j] + solve(grid,moveCost,i+1,k) + moveCost[grid[i][j]][k]);\\n        return dp[i][j];\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        dp = vector<vector<int>>(51,vector<int>(51,INT_MAX));\\n        for(int j = 0;j < grid[0].size();j++)\\n            ans = min(ans,solve(grid,moveCost,0,j));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,vector<vector<int>>& moveCost,int i,int j){\\n        if(i == grid.size()-1)\\n            return grid[i][j];\\n        if(dp[i][j] != INT_MAX)\\n            return dp[i][j];\\n        for(int k = 0;k < grid[i].size();k++)\\n            dp[i][j] = min(dp[i][j],grid[i][j] + solve(grid,moveCost,i+1,k) + moveCost[grid[i][j]][k]);\\n        return dp[i][j];\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int ans = INT_MAX;\\n        dp = vector<vector<int>>(51,vector<int>(51,INT_MAX));\\n        for(int j = 0;j < grid[0].size();j++)\\n            ans = min(ans,solve(grid,moveCost,0,j));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027525,
                "title": "easy-c-solution-using-tabulation-method",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int row = grid.size(), col = grid[0].size(), ans = INT_MAX;\\n        vector<vector<int>>dp(row,vector<int>(col));\\n        for(int i=0;i<row;i++) {\\n            for(int j=0;j<col;j++) {\\n                if(i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    int optimalCost = INT_MAX;\\n                    for(int k=0;k<col;k++) {\\n                        optimalCost = min(optimalCost,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                    }\\n                    dp[i][j] = optimalCost + grid[i][j];\\n                    if(i == row-1) {\\n                        ans = min(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int row = grid.size(), col = grid[0].size(), ans = INT_MAX;\\n        vector<vector<int>>dp(row,vector<int>(col));\\n        for(int i=0;i<row;i++) {\\n            for(int j=0;j<col;j++) {\\n                if(i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    int optimalCost = INT_MAX;\\n                    for(int k=0;k<col;k++) {\\n                        optimalCost = min(optimalCost,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                    }\\n                    dp[i][j] = optimalCost + grid[i][j];\\n                    if(i == row-1) {\\n                        ans = min(ans,dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997909,
                "title": "c-simple-beginner-friendly-solution-dynamic-programming-matrix",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int i=0,j=0,k=0,r=0,m=grid.size(),n=grid[0].size(),b=0,s=0;\\n        vector<int>a(m*n,0);\\n        for(i=0;i<a.size();i++)\\n            a[i]=i;\\n        for(i=m-2;i>=0;i--)\\n            for(j=0;j<n;j++)\\n            {\\n                b=moveCost[grid[i][j]][0]+a[grid[i+1][0]];\\n                for(k=1;k<n;k++)\\n                    b=min(b,moveCost[grid[i][j]][k]+a[grid[i+1][k]]);\\n                a[grid[i][j]]+=b;\\n                if(i==0 && j==0) r=a[grid[0][0]];\\n                else if(i==0) r=min(r,a[grid",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int i=0,j=0,k=0,r=0,m=grid.size(),n=grid[0].size(),b=0,s=0;\\n        vector<int>a(m*n,0);\\n        for(i=0;i<a.size();i++)\\n            a[i]=i;\\n        for(i=m-2;i>=0;i--)\\n            for(j=0;j<n;j++)\\n            {\\n                b=moveCost[grid[i][j]][0]+a[grid[i+1][0]];\\n                for(k=1;k<n;k++)\\n                    b=min(b,moveCost[grid[i][j]][k]+a[grid[i+1][k]]);\\n                a[grid[i][j]]+=b;\\n                if(i==0 && j==0) r=a[grid[0][0]];\\n                else if(i==0) r=min(r,a[grid",
                "codeTag": "Java"
            },
            {
                "id": 3996664,
                "title": "dynamic-programming-c-killer-solution-by-sd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans=min(ans,dp[i+1][k]+movecost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) \\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    ans=min(ans,dp[i+1][k]+movecost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974782,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n ,m ; \\n    \\n    int dp[51][51] ;\\n    int cal(int i , int k ,vector<vector<int>>& grid , vector<vector<int>>& moveCost )\\n    {\\n        if(i==n-1)\\n        {\\n            return grid[i][k] ; \\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans = 0, mini =1e9 ;\\n        for(int j =0 ; j<m ;j++ )\\n        {\\n            ans = grid[i][k] + moveCost[grid[i][k]][j] + cal(i+1,  j , grid ,moveCost );\\n            mini =min(mini ,ans ) ; \\n        }\\n    \\n        \\n        return dp[i][k] = mini ; \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        n = grid.size() , m =grid[0].size() ;\\n        int ans = 1e9; \\n           memset(dp, -1 , sizeof(dp)) ;\\n        for(int i =0 ; i<m; i++ )\\n      {       \\n            ans = min(ans , cal(0 , i , grid , moveCost ) );}\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n ,m ; \\n    \\n    int dp[51][51] ;\\n    int cal(int i , int k ,vector<vector<int>>& grid , vector<vector<int>>& moveCost )\\n    {\\n        if(i==n-1)\\n        {\\n            return grid[i][k] ; \\n        }\\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        int ans = 0, mini =1e9 ;\\n        for(int j =0 ; j<m ;j++ )\\n        {\\n            ans = grid[i][k] + moveCost[grid[i][k]][j] + cal(i+1,  j , grid ,moveCost );\\n            mini =min(mini ,ans ) ; \\n        }\\n    \\n        \\n        return dp[i][k] = mini ; \\n    }\\n    \\n    \\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        \\n        n = grid.size() , m =grid[0].size() ;\\n        int ans = 1e9; \\n           memset(dp, -1 , sizeof(dp)) ;\\n        for(int i =0 ; i<m; i++ )\\n      {       \\n            ans = min(ans , cal(0 , i , grid , moveCost ) );}\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908441,
                "title": "c-dp-tabulation-and-space-optimisation",
                "content": "# Intuition\\nAssume that you can reach any node on the last row of the grid i.e on the last row of grid, you can reach m = grid[0].size() nodes. Now assume out of these m nodes, one of the nodes as your final node. How will you reach from that starting row to this node. You can use simple recursion, where you say you start on the selected node on the last row and you wish to reach the 0th row. So while standing on a row, you can run a loop from 0 to m as every single node on the just next node can be your possibe new destination. Now what you did for this one final node on the n-1th row, do that for all m nodes on that row and take the minimum of all of them. Hope this helps . For any doubts feel free to drop a comment in the comment section\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n\\n\\n// Space Optimization\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<int>next(m,0);\\n        for(int j=0;j<m;j++)next[j] = grid[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                int mini = INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    int move = grid[i][j]+moveCost[grid[i][j]][k]+next[k];\\n                    mini = min(mini,move);\\n                }\\n                curr[j] = mini;\\n            }\\n            next = curr;\\n        }\\n        int mini = INT_MAX;\\n        for(auto i:next)mini = min(mini,i);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n\\n\\n// Space Optimization\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<int>next(m,0);\\n        for(int j=0;j<m;j++)next[j] = grid[n-1][j];\\n        for(int i=n-2;i>=0;i--){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                int mini = INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    int move = grid[i][j]+moveCost[grid[i][j]][k]+next[k];\\n                    mini = min(mini,move);\\n                }\\n                curr[j] = mini;\\n            }\\n            next = curr;\\n        }\\n        int mini = INT_MAX;\\n        for(auto i:next)mini = min(mini,i);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908378,
                "title": "c-dp-memoized",
                "content": "# Intuition\\nAssume that you can reach any node on the last row of the grid i.e on the last row of grid, you can reach m = grid[0].size() nodes. Now assume out of these m nodes, one of the nodes as your final node. How will you reach from that starting row to this node. You can use simple recursion, where you say you start on the selected node on the last row and you wish to reach the 0th row. So while standing on a row, you can run a loop from 0 to m as every single node on the just next node can be your possibe new destination. Now what you did for this one final node on the n-1th row, do that for all m nodes on that row and take the minimum of all of them. Hope this helps . For any doubts feel free to drop a comment in the comment section\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,vector<vector<int>>&dp){\\n        if(i==grid.size()-1)return grid[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int mini = 1e8;\\n        for(int k=0;k<grid[0].size();k++){\\n            int move = grid[i][j]+moveCost[grid[i][j]][k]+recur(i+1,k,grid,moveCost,dp);\\n            mini = min(mini,move);\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size(),m = grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int mini = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,recur(0,j,grid,moveCost,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907795,
                "title": "bkayyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    private int recur(int i,int j,int r,int c,int[][] grid,int[][] movecost){\\n        if(i==r-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=0;k<c;k++){\\n            min=Math.min(min,grid[i][j]+movecost[grid[i][j]][k]+recur(i+1,k,r,c,grid,movecost));\\n        }\\n        return dp[i][j]=min;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        dp=new int[r][c];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0;j<c;j++){\\n            min=Math.min(min,recur(0,j,r,c,grid,moveCost));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    private int recur(int i,int j,int r,int c,int[][] grid,int[][] movecost){\\n        if(i==r-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int k=0;k<c;k++){\\n            min=Math.min(min,grid[i][j]+movecost[grid[i][j]][k]+recur(i+1,k,r,c,grid,movecost));\\n        }\\n        return dp[i][j]=min;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int r=grid.length;\\n        int c=grid[0].length;\\n        dp=new int[r][c];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0;j<c;j++){\\n            min=Math.min(min,recur(0,j,r,c,grid,moveCost));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906559,
                "title": "simple-solution-using-top-down-dp-approach-in-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\npublic class Solution {\\n    int[,] dp;\\n    public int MinPathCost(int[][] grid, int[][] moveCost) {\\n        dp = new int[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n            for(int j=0; j< grid[0].Length;j++)\\n                dp[i,j] = -1;\\n        int ans = (int) 1e9;\\n        for(int i=0;i<grid[0].Length;i++){\\n            int temp = f(grid,moveCost,0,i);\\n            if(ans > temp) ans = temp;\\n         }\\n        return ans;\\n    }\\n    private int f(int[][] g, int[][] m, int i, int j){\\n        if(dp[i,j] != -1) return dp[i,j];\\n        if( i== g.Length-1) return g[i][j];\\n        int min = (int) 1e9;\\n        int element = g[i][j];\\n        for(int k=0;k<g[0].Length;k++){\\n            int temp1 =element+ m[element][k]+f(g,m,i+1,k);\\n            min = Math.Min(min,temp1);\\n        }\\n        dp[i,j] = min;\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    int[,] dp;\\n    public int MinPathCost(int[][] grid, int[][] moveCost) {\\n        dp = new int[grid.Length, grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n            for(int j=0; j< grid[0].Length;j++)\\n                dp[i,j] = -1;\\n        int ans = (int) 1e9;\\n        for(int i=0;i<grid[0].Length;i++){\\n            int temp = f(grid,moveCost,0,i);\\n            if(ans > temp) ans = temp;\\n         }\\n        return ans;\\n    }\\n    private int f(int[][] g, int[][] m, int i, int j){\\n        if(dp[i,j] != -1) return dp[i,j];\\n        if( i== g.Length-1) return g[i][j];\\n        int min = (int) 1e9;\\n        int element = g[i][j];\\n        for(int k=0;k<g[0].Length;k++){\\n            int temp1 =element+ m[element][k]+f(g,m,i+1,k);\\n            min = Math.Min(min,temp1);\\n        }\\n        dp[i,j] = min;\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904748,
                "title": "2304-minimum-path-cost-in-a-grid-python-solution",
                "content": "# Complexity\\n- Time complexity: **O(m * n * n)**\\n\\n- Space complexity: **O(m * n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [[sys.maxsize for _ in range(n)] for _ in range(m)]\\n        \\n        for j in range(n):\\n            cost[0][j] = 0\\n\\n        for i in range(m - 1):\\n            for j in range(n):\\n                for k in range(len(moveCost[grid[i][j]])):\\n                    cost[i + 1][k] = min(cost[i + 1][k], grid[i][j] + cost[i][j] + moveCost[grid[i][j]][k])\\n\\n        for j in range(n):\\n            cost[m - 1][j] += grid[m - 1][j]\\n        \\n        return min(cost[m - 1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        cost = [[sys.maxsize for _ in range(n)] for _ in range(m)]\\n        \\n        for j in range(n):\\n            cost[0][j] = 0\\n\\n        for i in range(m - 1):\\n            for j in range(n):\\n                for k in range(len(moveCost[grid[i][j]])):\\n                    cost[i + 1][k] = min(cost[i + 1][k], grid[i][j] + cost[i][j] + moveCost[grid[i][j]][k])\\n\\n        for j in range(n):\\n            cost[m - 1][j] += grid[m - 1][j]\\n        \\n        return min(cost[m - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901186,
                "title": "c-easy-intution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will follow Dynamic programming approach. We will start at the first row and then we will go to all the cells possible from that cell to the cell below and then check the minimum possible value to the given cell.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dist(m, vector<int> (n, INT_MAX));\\n\\n        for(int j = 0 ; j < n ; j++) dist[0][j] = grid[0][j];\\n\\n        for(int i = 0 ; i < m - 1 ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                for(int k = 0 ; k < n ; k++){\\n                        dist[i + 1][k] = min(dist[i + 1][k], dist[i][j] + grid[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n            }\\n        }\\n\\n        int minVal = INT_MAX;\\n\\n        for(auto &ele : dist[m-1]){\\n            minVal = min(minVal, ele);\\n        }\\n\\n        return minVal;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // Intution\\n        // The idea in here is really very simple. We will follow Dynamic programming approach. We will start at the first row and then we will go to all the cells possible from that cell to the cell below and then check the minimum possible value to the given cell.\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dist(m, vector<int> (n, INT_MAX));\\n\\n        for(int j = 0 ; j < n ; j++) dist[0][j] = grid[0][j];\\n\\n        for(int i = 0 ; i < m - 1 ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                for(int k = 0 ; k < n ; k++){\\n                        dist[i + 1][k] = min(dist[i + 1][k], dist[i][j] + grid[i + 1][k] + moveCost[grid[i][j]][k]);\\n                }\\n            }\\n        }\\n\\n        int minVal = INT_MAX;\\n\\n        for(auto &ele : dist[m-1]){\\n            minVal = min(minVal, ele);\\n        }\\n\\n        return minVal;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900152,
                "title": "iterative-solution-no-recursion-simple-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the cost from coming to i-th row from (i-1)-th row \\nSuppose we are jumping from 2nd row\\'s 4th column to 3rd row\\'s 1\\'st column then\\n```\\nCost = grid[2][4]+grid[3][1]+ movecost[grid[2][4]][1]\\n```\\nStore the cost values in an array and use them for next row.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>curr(m,0);\\n        for(int i=1;i<n;i++){ //coming to ith row\\n            vector<int>temp(m,0);\\n            //going to the other columns of ith row from 0th column of i-1th row\\n            for(int j=0;j<m;j++){\\n                if(i==1){\\n                    int val = curr[0]+grid[i-1][0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                else {\\n                    int val = curr[0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                \\n            }\\n            //for 1st column onwards\\n            for(int k=1;k<m;k++){\\n                for(int j=0;j<m;j++){\\n                    if(i==1){\\n                         int val = curr[k]+grid[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                    temp[j]=min(temp[j],val);\\n                    }\\n                    else{\\n                        int val = curr[k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                        temp[j]=min(temp[j],val);\\n                    }\\n                   \\n                }\\n            }\\n            curr = temp;\\n        }   \\n        return *min_element(curr.begin(),curr.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nCost = grid[2][4]+grid[3][1]+ movecost[grid[2][4]][1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<int>curr(m,0);\\n        for(int i=1;i<n;i++){ //coming to ith row\\n            vector<int>temp(m,0);\\n            //going to the other columns of ith row from 0th column of i-1th row\\n            for(int j=0;j<m;j++){\\n                if(i==1){\\n                    int val = curr[0]+grid[i-1][0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                else {\\n                    int val = curr[0]+grid[i][j]+moveCost[grid[i-1][0]][j];\\n                    temp[j] = val;\\n                }\\n                \\n            }\\n            //for 1st column onwards\\n            for(int k=1;k<m;k++){\\n                for(int j=0;j<m;j++){\\n                    if(i==1){\\n                         int val = curr[k]+grid[i-1][k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                    temp[j]=min(temp[j],val);\\n                    }\\n                    else{\\n                        int val = curr[k]+grid[i][j]+moveCost[grid[i-1][k]][j];\\n                        temp[j]=min(temp[j],val);\\n                    }\\n                   \\n                }\\n            }\\n            curr = temp;\\n        }   \\n        return *min_element(curr.begin(),curr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898730,
                "title": "bottom-up-approach-java",
                "content": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] dp=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            dp[i]=grid[grid.length-1][i];\\n        }\\n        int[] temp=new int[dp.length];\\n        \\n        for(int i=grid.length-2;i>=0;i--)\\n        {\\n            Arrays.fill(temp,Integer.MAX_VALUE);\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                int s=grid[i][j];\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<dp.length;k++)\\n                {\\n                    int d=moveCost[s][k]+dp[k];\\n                    temp[j]=Math.min(temp[j],d);\\n                }\\n                temp[j]+=s;\\n                \\n            }\\n            for(int k=0;k<dp.length;k++)dp[k]=temp[k];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int i:dp)res=Math.min(res,i);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int[] dp=new int[grid[0].length];\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            dp[i]=grid[grid.length-1][i];\\n        }\\n        int[] temp=new int[dp.length];\\n        \\n        for(int i=grid.length-2;i>=0;i--)\\n        {\\n            Arrays.fill(temp,Integer.MAX_VALUE);\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                int s=grid[i][j];\\n                int min=Integer.MAX_VALUE;\\n                for(int k=0;k<dp.length;k++)\\n                {\\n                    int d=moveCost[s][k]+dp[k];\\n                    temp[j]=Math.min(temp[j],d);\\n                }\\n                temp[j]+=s;\\n                \\n            }\\n            for(int k=0;k<dp.length;k++)dp[k]=temp[k];\\n        }\\n        int res=Integer.MAX_VALUE;\\n        for(int i:dp)res=Math.min(res,i);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898451,
                "title": "recursion-memoization",
                "content": "________________________________\\n\\n# Reursion\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return value+grid[i][j];\\n    }\\n}\\n```\\n________________________________\\n\\n# Memoization \\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        memo=new Integer[grid.length][grid[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=null){\\n            return memo[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return memo[i][j] = value+grid[i][j];\\n    }\\n}\\n```\\n________________________________\\n\\n**Upvote**\\n![image.png](https://assets.leetcode.com/users/images/f18ccf7b-bb7d-4a8e-8622-2f0acbd705cc_1683886081.2272806.png)\\n\\n________________________________",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return value+grid[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Integer[][] memo;\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        memo=new Integer[grid.length][grid[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int j=0; j<grid[0].length; j++){\\n           min=Math.min(min,minPathCost(grid,moveCost,0,j));\\n        }\\n        return min;\\n    }\\n\\n    public int minPathCost(int[][] grid,int[][] moveCost,int i, int j) {\\n        if(i>=grid.length || j>=grid[0].length|| j<0 ){\\n            return 0;\\n        }\\n        if(i==grid.length-1){\\n            return grid[i][j];\\n        }\\n        if(memo[i][j]!=null){\\n            return memo[i][j];\\n        }\\n        int value=Integer.MAX_VALUE;\\n        for(int col=0; col<grid[0].length; col++){\\n            value=Math.min(value, moveCost[grid[i][j]][col]+minPathCost(grid,moveCost,i+1,col));\\n        }\\n        return memo[i][j] = value+grid[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898430,
                "title": "c-beginners-friendly-recursive-memoization-dp",
                "content": "# Intuition\\n  Try all possible combinations using DP and keep storing the minimumum path cost for eah row and column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n  O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 1e9;\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            ans = min(ans,grid[i][j] + cost[grid[i][j]][k] + f(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < grid[0].size(); j++) \\n          ans = min(ans,f(0,j,grid,moveCost,dp));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& cost, vector<vector<int>>& dp){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 1e9;\\n        if(i==grid.size()-1){\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            ans = min(ans,grid[i][j] + cost[grid[i][j]][k] + f(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < grid[0].size(); j++) \\n          ans = min(ans,f(0,j,grid,moveCost,dp));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897604,
                "title": "priority-queue",
                "content": "\\n# Code\\n```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\n#[derive(Clone, Copy, Eq, PartialEq, Debug)]\\nstruct Node {\\n    cost: i32,\\n    node: usize,\\n    depth: usize,\\n}\\n\\nimpl Ord for Node {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        // Reverse compare on cost \\n        // because binary heap pops the max element\\n        other.cost.cmp(&self.cost)\\n            .then_with(|| self.node.cmp(&other.node))\\n            .then_with(|| self.depth.cmp(&other.depth))\\n    }\\n}\\n\\nimpl PartialOrd for Node {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_path_cost(grid: Vec<Vec<i32>>, move_cost: Vec<Vec<i32>>) -> i32 {\\n        let last_depth = grid.len() - 1;\\n        let mut queue = BinaryHeap::new();\\n        let mut seen = HashSet::new();\\n        for &p in &grid[0] {\\n            queue.push(Node{\\n                cost: p,\\n                node: p as usize,\\n                depth: 0,\\n            });\\n        }\\n        while let Some(node) = queue.pop() {\\n            if !seen.insert(node.node) {\\n                continue;\\n            }\\n            if node.depth == last_depth {\\n                return node.cost;\\n            }\\n            for (target, cost) in grid[node.depth + 1].iter().zip(move_cost[node.node].iter()) {\\n                queue.push(Node{\\n                    cost: node.cost + cost + target,\\n                    node: *target as usize,\\n                    depth: node.depth + 1,\\n                });\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::{BinaryHeap, HashSet};\\n\\n#[derive(Clone, Copy, Eq, PartialEq, Debug)]\\nstruct Node {\\n    cost: i32,\\n    node: usize,\\n    depth: usize,\\n}\\n\\nimpl Ord for Node {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        // Reverse compare on cost \\n        // because binary heap pops the max element\\n        other.cost.cmp(&self.cost)\\n            .then_with(|| self.node.cmp(&other.node))\\n            .then_with(|| self.depth.cmp(&other.depth))\\n    }\\n}\\n\\nimpl PartialOrd for Node {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_path_cost(grid: Vec<Vec<i32>>, move_cost: Vec<Vec<i32>>) -> i32 {\\n        let last_depth = grid.len() - 1;\\n        let mut queue = BinaryHeap::new();\\n        let mut seen = HashSet::new();\\n        for &p in &grid[0] {\\n            queue.push(Node{\\n                cost: p,\\n                node: p as usize,\\n                depth: 0,\\n            });\\n        }\\n        while let Some(node) = queue.pop() {\\n            if !seen.insert(node.node) {\\n                continue;\\n            }\\n            if node.depth == last_depth {\\n                return node.cost;\\n            }\\n            for (target, cost) in grid[node.depth + 1].iter().zip(move_cost[node.node].iter()) {\\n                queue.push(Node{\\n                    cost: node.cost + cost + target,\\n                    node: *target as usize,\\n                    depth: node.depth + 1,\\n                });\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3895609,
                "title": "bottom-up-dp-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        dp[m-1]=grid[m-1]\\n        for i in range(m-2,-1,-1):\\n            \\n            for k in range(n):\\n                minCost = math.inf\\n                for j in range(n):\\n                    cost = grid[i][k] + dp[i+1][j] + moveCost[grid[i][k]][j]\\n\\n                    minCost = min(minCost,cost)\\n                dp[i][k] = minCost\\n        return min(dp[0])         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        dp[m-1]=grid[m-1]\\n        for i in range(m-2,-1,-1):\\n            \\n            for k in range(n):\\n                minCost = math.inf\\n                for j in range(n):\\n                    cost = grid[i][k] + dp[i+1][j] + moveCost[grid[i][k]][j]\\n\\n                    minCost = min(minCost,cost)\\n                dp[i][k] = minCost\\n        return min(dp[0])         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881228,
                "title": "easy-c-memoised-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(i == grid.size()-1)\\n        {\\n            return grid[i][j];\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost = INT_MAX;\\n        for(int k=0; k<moveCost[grid[i][j]].size(); k++)\\n        {\\n            int costly = grid[i][j] + moveCost[grid[i][j]][k] + f(grid, moveCost, i+1, k, dp);\\n            cost = min(cost, costly);\\n        }\\n        return dp[i][j] = cost;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int mini = INT_MAX;\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int l=0; l<grid[0].size(); l++) \\n        {\\n            mini = min(mini, f(grid, moveCost, 0, l, dp));\\n        }     \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j, vector<vector<int>>& dp)\\n    {\\n        if(i == grid.size()-1)\\n        {\\n            return grid[i][j];\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int cost = INT_MAX;\\n        for(int k=0; k<moveCost[grid[i][j]].size(); k++)\\n        {\\n            int costly = grid[i][j] + moveCost[grid[i][j]][k] + f(grid, moveCost, i+1, k, dp);\\n            cost = min(cost, costly);\\n        }\\n        return dp[i][j] = cost;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        int mini = INT_MAX;\\n        vector<vector<int>> dp(grid.size()+1,vector<int>(grid[0].size()+1,-1));\\n        for(int l=0; l<grid[0].size(); l++) \\n        {\\n            mini = min(mini, f(grid, moveCost, 0, l, dp));\\n        }     \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866554,
                "title": "java-recursion-memoization-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n    int[][] moveCost;\\n\\n    Integer[][] memo;\\n\\n    int helper(int[][] grid, int row, int prevCellVal){\\n\\n        if(row >= ROW) return 0;\\n\\n        if(memo[row][prevCellVal] != null) return memo[row][prevCellVal];\\n\\n        int currMinCost = Integer.MAX_VALUE;\\n\\n        for(int nextCol = 0; nextCol < COL; nextCol++){\\n            currMinCost = Math.min(currMinCost,\\n\\n            moveCost[prevCellVal][nextCol]\\n            + grid[row][nextCol]\\n            + helper(grid, row + 1, grid[row][nextCol]));\\n        }\\n        return memo[row][prevCellVal] = currMinCost;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        this.moveCost = moveCost;\\n\\n        int distinctNumCount = ROW * COL;\\n\\n        memo = new Integer[ROW + 1][distinctNumCount];\\n\\n        int minCost = Integer.MAX_VALUE;\\n\\n        int row = 0;\\n\\n        for(int col = 0; col < COL; col++){\\n            minCost = Math.min(minCost,\\n            grid[row][col] + helper(grid, row + 1, grid[row][col]));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ROW;\\n    int COL;\\n    int[][] moveCost;\\n\\n    Integer[][] memo;\\n\\n    int helper(int[][] grid, int row, int prevCellVal){\\n\\n        if(row >= ROW) return 0;\\n\\n        if(memo[row][prevCellVal] != null) return memo[row][prevCellVal];\\n\\n        int currMinCost = Integer.MAX_VALUE;\\n\\n        for(int nextCol = 0; nextCol < COL; nextCol++){\\n            currMinCost = Math.min(currMinCost,\\n\\n            moveCost[prevCellVal][nextCol]\\n            + grid[row][nextCol]\\n            + helper(grid, row + 1, grid[row][nextCol]));\\n        }\\n        return memo[row][prevCellVal] = currMinCost;\\n    }\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        \\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        this.moveCost = moveCost;\\n\\n        int distinctNumCount = ROW * COL;\\n\\n        memo = new Integer[ROW + 1][distinctNumCount];\\n\\n        int minCost = Integer.MAX_VALUE;\\n\\n        int row = 0;\\n\\n        for(int col = 0; col < COL; col++){\\n            minCost = Math.min(minCost,\\n            grid[row][col] + helper(grid, row + 1, grid[row][col]));\\n        }\\n        return minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843705,
                "title": "top-down-dp-python3",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m,n = len(grid), len(grid[0])\\n        dp = [[10000] * n for _ in range(m)]\\n        for j in range(n):\\n            dp[m-1][j] = grid[m-1][j]\\n        for i in range(m-2,-1,-1):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp[i][j] = min(dp[i][j], dp[i+1][k] + grid[i][j] + moveCost[grid[i][j]][k])\\n        return min(dp[0])\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m,n = len(grid), len(grid[0])\\n        dp = [[10000] * n for _ in range(m)]\\n        for j in range(n):\\n            dp[m-1][j] = grid[m-1][j]\\n        for i in range(m-2,-1,-1):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp[i][j] = min(dp[i][j], dp[i+1][k] + grid[i][j] + moveCost[grid[i][j]][k])\\n        return min(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838722,
                "title": "c-easy-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[52][52];\\nint process(vector<vector<int>> &grid,vector<vector<int>> &moveCost,int r,int c){\\n    if(r==grid.size()-1){\\n        int value=grid[r][c];\\n        return value;\\n    }\\n    if(dp[r][c]!=-1){\\n        return dp[r][c];\\n    }\\n    int a=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        int value=grid[r][c];\\n        a=min(a,value+moveCost[value][j]+process(grid,moveCost,r+1,j));\\n    }\\n    return dp[r][c]=a;\\n}\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        ans=min(ans,process(grid,moveCost,0,j));\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[52][52];\\nint process(vector<vector<int>> &grid,vector<vector<int>> &moveCost,int r,int c){\\n    if(r==grid.size()-1){\\n        int value=grid[r][c];\\n        return value;\\n    }\\n    if(dp[r][c]!=-1){\\n        return dp[r][c];\\n    }\\n    int a=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        int value=grid[r][c];\\n        a=min(a,value+moveCost[value][j]+process(grid,moveCost,r+1,j));\\n    }\\n    return dp[r][c]=a;\\n}\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n    for(int j=0;j<grid[0].size();j++){\\n        ans=min(ans,process(grid,moveCost,0,j));\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831042,
                "title": "fastest-memoization",
                "content": "# Approach\\nMemoization\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$+stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min = Integer.MAX_VALUE;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i[]:dp) Arrays.fill(i, -1);\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[grid.length-1][i] + backtrack(grid, moveCost, grid.length-1, i, dp));\\n        return min;\\n    }\\n    private int backtrack(int grid[][], int cost[][], int m, int n, int dp[][]){\\n        int min = Integer.MAX_VALUE;\\n        if(m == 1){\\n            for(int i = 0;i<grid[0].length;i++){\\n                min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n]);\\n            }\\n            return dp[m][n] = min;\\n        }\\n        if(dp[m][n] != -1) return dp[m][n];\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n] + backtrack(grid, cost, m-1, i, dp));\\n        return dp[m][n] = min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        int min = Integer.MAX_VALUE;\\n        int dp[][] = new int[grid.length][grid[0].length];\\n        for(int i[]:dp) Arrays.fill(i, -1);\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[grid.length-1][i] + backtrack(grid, moveCost, grid.length-1, i, dp));\\n        return min;\\n    }\\n    private int backtrack(int grid[][], int cost[][], int m, int n, int dp[][]){\\n        int min = Integer.MAX_VALUE;\\n        if(m == 1){\\n            for(int i = 0;i<grid[0].length;i++){\\n                min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n]);\\n            }\\n            return dp[m][n] = min;\\n        }\\n        if(dp[m][n] != -1) return dp[m][n];\\n        for(int i = 0;i<grid[0].length;i++) min = Math.min(min, grid[m-1][i] + cost[grid[m-1][i]][n] + backtrack(grid, cost, m-1, i, dp));\\n        return dp[m][n] = min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805782,
                "title": "c-dynamic-programming-memoization-recurrsion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe 1st intuition is that to calculate the min sum we have to traverse all the paths. We cant use a greedy approach because the move cost and grid values are not ordered.\\nTraversing all the paths will be done by recursion.\\nAnd since there are overlapping subproblems we can use memoization to store the result of smaller subproblems.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will traverse all the paths using recursion and memoize it using a 2D vector - dp.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nM : #rows\\nN : #cols\\nO(M*N) , because M*N will be the maximum number of states that we will  have at maximum.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)+O(M), dp array and the recursion stack space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m, int n, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp){\\n        if(i==m-1) return grid[i][j];\\n\\n        if(dp[i][j]!=1e8) return dp[i][j];\\n\\n        int maxi=1e9;\\n        for(int k=0; k<n; k++){\\n            maxi = min(maxi, grid[i][j]+moveCost[grid[i][j]][k]+solve(i+1, k, m, n, grid, moveCost, dp));\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 1e8));\\n        int maxi = 1e9;\\n        for(int i=0; i<n; i++){\\n            maxi = min(maxi, solve(0, i, m, n, grid, moveCost, dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n# Please UPVOTE\\uD83D\\uDE09",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int m, int n, vector<vector<int>>& grid, vector<vector<int>>& moveCost, vector<vector<int>>& dp){\\n        if(i==m-1) return grid[i][j];\\n\\n        if(dp[i][j]!=1e8) return dp[i][j];\\n\\n        int maxi=1e9;\\n        for(int k=0; k<n; k++){\\n            maxi = min(maxi, grid[i][j]+moveCost[grid[i][j]][k]+solve(i+1, k, m, n, grid, moveCost, dp));\\n        }\\n\\n        return dp[i][j] = maxi;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 1e8));\\n        int maxi = 1e9;\\n        for(int i=0; i<n; i++){\\n            maxi = min(maxi, solve(0, i, m, n, grid, moveCost, dp));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805658,
                "title": "c-all-3-dp-recursion-memoization-tabulation-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve_tab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int mini=1e9;\\n                for(int k=0;k<n;k++){\\n                    mini=min(mini,moveCost[grid[i][j]][k]+grid[i][j]+dp[i+1][k]);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n    int solve(int row,int col,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>&dp){\\n        if(row==grid.size()-1){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid[row].size();i++){\\n            mini=min(mini,moveCost[grid[row][col]][i]+grid[row][col]+solve(row+1,i,grid,moveCost,dp));\\n        }\\n        return dp[row][col]=mini;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // int ans=INT_MAX;\\n        // int m=grid.size();\\n        // int n=grid[0].size();\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        // for(int i=0;i<grid[0].size();i++){\\n        //     ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        // }\\n        // return ans;\\n        return solve_tab(grid,moveCost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve_tab(vector<vector<int>>& grid, vector<vector<int>>& moveCost){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int mini=1e9;\\n                for(int k=0;k<n;k++){\\n                    mini=min(mini,moveCost[grid[i][j]][k]+grid[i][j]+dp[i+1][k]);\\n                }\\n                dp[i][j]=mini;\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, dp[0][i]);\\n        }\\n        return ans;\\n    }\\n    int solve(int row,int col,vector<vector<int>>& grid, vector<vector<int>>& moveCost,vector<vector<int>>&dp){\\n        if(row==grid.size()-1){\\n            return grid[row][col];\\n        }\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid[row].size();i++){\\n            mini=min(mini,moveCost[grid[row][col]][i]+grid[row][col]+solve(row+1,i,grid,moveCost,dp));\\n        }\\n        return dp[row][col]=mini;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        // int ans=INT_MAX;\\n        // int m=grid.size();\\n        // int n=grid[0].size();\\n        // vector<vector<int>>dp(m+1,vector<int>(n+1,-1));\\n        // for(int i=0;i<grid[0].size();i++){\\n        //     ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        // }\\n        // return ans;\\n        return solve_tab(grid,moveCost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777575,
                "title": "javascript-easy-understanding-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nvar minPathCost = function(grid, moveCost) {\\n    let dp = Array.from(Array(grid.length), () => new Array(grid[0].length));\\n    for (let i = 0; i < grid[0].length; i++){\\n        dp[0][i] = grid[0][i];\\n    }\\n    for (let i = 1; i < grid.length; i++){\\n        for (let j = 0; j < grid[i].length; j++){\\n            dp[i][j] = Infinity;\\n            for (let k = 0; k < grid[i].length; k++){\\n                dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n            }\\n        }\\n    }\\n    let res = Infinity;\\n    for (let i = 0; i < grid[0].length; i++){\\n        res = Math.min(res, dp[grid.length - 1][i]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number[][]} moveCost\\n * @return {number}\\n */\\nvar minPathCost = function(grid, moveCost) {\\n    let dp = Array.from(Array(grid.length), () => new Array(grid[0].length));\\n    for (let i = 0; i < grid[0].length; i++){\\n        dp[0][i] = grid[0][i];\\n    }\\n    for (let i = 1; i < grid.length; i++){\\n        for (let j = 0; j < grid[i].length; j++){\\n            dp[i][j] = Infinity;\\n            for (let k = 0; k < grid[i].length; k++){\\n                dp[i][j] = Math.min(dp[i][j], grid[i][j] + dp[i - 1][k] + moveCost[grid[i - 1][k]][j]);\\n            }\\n        }\\n    }\\n    let res = Infinity;\\n    for (let i = 0; i < grid[0].length; i++){\\n        res = Math.min(res, dp[grid.length - 1][i]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777394,
                "title": "easy-c-beats-80-no-extra-space-fully-explained-commented-code-recursion-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j,vector<vector<int>> &dp) {\\n        if(i==grid.size()-1)    return grid[i][j];\\n\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n\\n        int temp = INT_MAX;\\n        for(int k = 0; k<grid[0].size(); k++) {\\n            int cost = grid[i][j]+moveCost[grid[i][j]][k];\\n            cost += func(grid, moveCost, i+1, k,dp);\\n            temp = min(temp, cost);\\n        }\\n        return dp[i][j] = temp;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m-1, vector<int> (n, -1));\\n\\n        int ans = INT_MAX;\\n        for(int j=0; j<n; j++) {\\n            ans = min(ans, func(grid, moveCost, 0, j, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& moveCost, int i, int j,vector<vector<int>> &dp) {\\n        if(i==grid.size()-1)    return grid[i][j];\\n\\n        if(dp[i][j]!=-1)    return dp[i][j];\\n\\n        int temp = INT_MAX;\\n        for(int k = 0; k<grid[0].size(); k++) {\\n            int cost = grid[i][j]+moveCost[grid[i][j]][k];\\n            cost += func(grid, moveCost, i+1, k,dp);\\n            temp = min(temp, cost);\\n        }\\n        return dp[i][j] = temp;\\n    }\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dp(m-1, vector<int> (n, -1));\\n\\n        int ans = INT_MAX;\\n        for(int j=0; j<n; j++) {\\n            ans = min(ans, func(grid, moveCost, 0, j, dp));\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760444,
                "title": "great-dp-approach-o-nm-2-and-o-nm-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse DP; starting with top down approach and then convert to bottom up\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThere are $O(nm)$ subproblems each of which take $O(m)$ time to compute so $O(nm^2)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$O(nm)$\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\n        n = len(grid)\\n\\n        m = len(grid[0])\\n\\n        DP = {}\\n\\n        for i in range(m):\\n\\n            DP[(n - 1, i)] = grid[n - 1][i]\\n\\n\\n        for i in range(n - 2, -1, -1):\\n\\n            for j in range(m):\\n\\n                minimum = float(\\'inf\\')\\n\\n                for c in range(m):\\n                    minimum = min(minimum, grid[i][j] + moveCost[grid[i][j]][c] + DP[(i + 1, c)])\\n\\n                DP[(i, j)] = minimum \\n\\n\\n        min_cost = float(\\'inf\\')\\n\\n        for j in range(m):\\n\\n            min_cost = min(DP[(0, j)], min_cost)\\n        \\n        return min_cost\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\n        n = len(grid)\\n\\n        m = len(grid[0])\\n\\n        DP = {}\\n\\n        for i in range(m):\\n\\n            DP[(n - 1, i)] = grid[n - 1][i]\\n\\n\\n        for i in range(n - 2, -1, -1):\\n\\n            for j in range(m):\\n\\n                minimum = float(\\'inf\\')\\n\\n                for c in range(m):\\n                    minimum = min(minimum, grid[i][j] + moveCost[grid[i][j]][c] + DP[(i + 1, c)])\\n\\n                DP[(i, j)] = minimum \\n\\n\\n        min_cost = float(\\'inf\\')\\n\\n        for j in range(m):\\n\\n            min_cost = min(DP[(0, j)], min_cost)\\n        \\n        return min_cost\\n\\n        \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741980,
                "title": "dp",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit first seems like the rows are in rotation because the last row is connecting the first row also but after running through testcase I came to know that we only have to consider the path from the first row to the last row.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& nums, vector<vector<int>>& mc,vector<vector<int>>&dp){\\n        if(i==nums.size()-1)return nums[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums[0].size();k++){\\n         int x=nums[i][j]+mc[nums[i][j]][k]+f(i+1,k,nums,mc,dp);\\n         ans=min(ans,x);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mc) {\\n       int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n            for(int j=0;j<grid[0].size();j++){\\n                int x=f(0,j,grid,mc,dp);\\n                ans=min(ans,x);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& nums, vector<vector<int>>& mc,vector<vector<int>>&dp){\\n        if(i==nums.size()-1)return nums[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums[0].size();k++){\\n         int x=nums[i][j]+mc[nums[i][j]][k]+f(i+1,k,nums,mc,dp);\\n         ans=min(ans,x);\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& mc) {\\n       int ans=INT_MAX;\\n        vector<vector<int>>dp(grid.size(),vector<int>(grid[0].size(),-1));\\n            for(int j=0;j<grid[0].size();j++){\\n                int x=f(0,j,grid,mc,dp);\\n                ans=min(ans,x);\\n            }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737019,
                "title": "using-lis-dp-format-with-time-complexity-calculation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere I used the LIS DP format where we find the optimal answer ending at an index (i,j).\\n\\nWhy did I think of this? Because the value that is asked in the question can be calculated for all the cells in the grid and using the values calculated for the previous row we can calculate the answer for current row.\\n\\nSo I Calcuated the best answer ending at the index for all the cells in the last row and selected the minimum one which is asked.\\n\\nFor reaching a cell (i,j), I have gone through all the possibilities of where I could have come from and selected the minimum possible route.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTime complexity =  $$O(#states(1+#transitions(avg/state)))$$\\n- $$#states$$=m*n\\n- $$#Transitions$$=n\\n- TC = O(m*n*(1+n)) = O(m*n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using vvi =  vector<vector<int>>;\\n    vvi grid;\\n    vvi cost;\\n    vvi dp;\\n    int m,n;\\n\\n\\n    // rec(i,j) => returns the minimum cost of path to (i,j)\\n    int rec(int i,int j){\\n\\n        //pruning:\\n        if(i>=m || i<0 || j<0 || j>=n) return 1e9;\\n\\n        //base case: \\n        if(i==0) return grid[i][j];\\n\\n        //cache check\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        //computations\\n        int row = i-1;\\n        int ans = 1e8;\\n\\n        for(int col=0;col<n;++col){\\n            int val = grid[row][col];\\n            int costForComing = cost[val][j];\\n            ans = min(ans,grid[i][j]+costForComing+rec(row,col));\\n        }\\n\\n\\n        //save and return \\n        return dp[i][j] = ans;\\n\\n    }\\n\\n\\n    int minPathCost(vector<vector<int>>& matrix, vector<vector<int>>& moveCost) {\\n        \\n        //globalisation kardi taki bar bar na likhna pade\\n        grid = move(matrix);\\n        cost = move(moveCost);\\n        m = grid.size();\\n        n = grid[0].size();\\n        dp = vvi(m+1,vector<int>(n+1,-1));\\n\\n        //ab last row mein se best select kar lunga\\n        int ans = INT_MAX;\\n        int row = m-1;\\n        for(int col = 0;col<n;++col){\\n            ans = min(ans,rec(row,col));\\n        }\\n\\n\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727405,
                "title": "c-easiest-approach-beats94-17",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                int mi=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    mi=min(mi,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=mi+grid[i][j];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size(),m=grid[0].size();\\n        int dp[n+1][m+1];\\n        for(int i=0;i<m;i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=0;j<m;j++){\\n                int mi=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    mi=min(mi,dp[i-1][k]+moveCost[grid[i-1][k]][j]);\\n                }\\n                dp[i][j]=mi+grid[i][j];\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,dp[n-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658867,
                "title": "top-bottom-dp",
                "content": "# Approach\\nRun DFS with memoization starting from each cell in a first row\\n\\n# Complexity\\n- Time complexity:\\n$$O(nxm)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n# Code\\n```\\nvar minPathCost = function(grid, moveCost) {\\n\\n    const dfs=(r,c,dp)=>{\\n        if(r===grid.length || c===grid[r].length) return 0;\\n        if(dp[r][c]!==undefined) return dp[r][c];\\n\\n        // current cost\\n        const cost=grid[r][c], nextRow=r+1;\\n\\n        if(nextRow===grid.length) return cost;\\n        \\n        let nextMoveCost=Number.MAX_SAFE_INTEGER;\\n        for(let nextCol=0;nextCol<grid[nextRow].length;nextCol++){\\n            nextMoveCost=Math.min(nextMoveCost,dfs(nextRow,nextCol,dp)+moveCost[cost][nextCol]/*path cost*/);\\n        }\\n        return dp[r][c]=cost+(nextMoveCost===Number.MAX_SAFE_INTEGER?0:nextMoveCost);\\n    };\\n\\n    let minCost=Number.MAX_SAFE_INTEGER;\\n    const dp=Array(grid.length).fill().map(()=>Array(grid[0].length).fill());\\n    for(let c=0;c<grid[0].length;c++){\\n        minCost=Math.min(minCost,dfs(0,c,dp));\\n    }\\n    return minCost;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n\\n    const dfs=(r,c,dp)=>{\\n        if(r===grid.length || c===grid[r].length) return 0;\\n        if(dp[r][c]!==undefined) return dp[r][c];\\n\\n        // current cost\\n        const cost=grid[r][c], nextRow=r+1;\\n\\n        if(nextRow===grid.length) return cost;\\n        \\n        let nextMoveCost=Number.MAX_SAFE_INTEGER;\\n        for(let nextCol=0;nextCol<grid[nextRow].length;nextCol++){\\n            nextMoveCost=Math.min(nextMoveCost,dfs(nextRow,nextCol,dp)+moveCost[cost][nextCol]/*path cost*/);\\n        }\\n        return dp[r][c]=cost+(nextMoveCost===Number.MAX_SAFE_INTEGER?0:nextMoveCost);\\n    };\\n\\n    let minCost=Number.MAX_SAFE_INTEGER;\\n    const dp=Array(grid.length).fill().map(()=>Array(grid[0].length).fill());\\n    for(let c=0;c<grid[0].length;c++){\\n        minCost=Math.min(minCost,dfs(0,c,dp));\\n    }\\n    return minCost;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648093,
                "title": "memoization-approach",
                "content": "\\n\\n# Code\\n```\\n\\n\\n\\n#define MAX 55\\n\\n\\nint f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,int n,int m,int dp[][MAX])\\n{\\n    if(i == n-1)\\n    return grid[i][j];\\n    if(dp[i][j] != -1)\\n    return dp[i][j];\\n    int res = 1e9;\\n    for(int k=0;k<m;k++)\\n    {\\n        res = min(res,f(i+1,k,grid,moveCost,n,m,dp) + moveCost[grid[i][j]][k] +grid[i][j]);\\n    }\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 1e9;\\n        int dp[n][MAX];\\n        for(int j=0;j<m;j++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n            res = min(res,f(0,j,grid,moveCost,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\n#define MAX 55\\n\\n\\nint f(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&moveCost,int n,int m,int dp[][MAX])\\n{\\n    if(i == n-1)\\n    return grid[i][j];\\n    if(dp[i][j] != -1)\\n    return dp[i][j];\\n    int res = 1e9;\\n    for(int k=0;k<m;k++)\\n    {\\n        res = min(res,f(i+1,k,grid,moveCost,n,m,dp) + moveCost[grid[i][j]][k] +grid[i][j]);\\n    }\\n    return dp[i][j] = res;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 1e9;\\n        int dp[n][MAX];\\n        for(int j=0;j<m;j++)\\n        {\\n            memset(dp,-1,sizeof(dp));\\n            res = min(res,f(0,j,grid,moveCost,n,m,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638472,
                "title": "dp-with-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &cost,vector<vector<int>> &dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for(int k=0;k<m;k++){\\n            mini=min(mini,grid[i][j]+(i==n-1?0:cost[grid[i][j]][k])+solve(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,solve(0,j,grid,moveCost,dp));\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &cost,vector<vector<int>> &dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for(int k=0;k<m;k++){\\n            mini=min(mini,grid[i][j]+(i==n-1?0:cost[grid[i][j]][k])+solve(i+1,k,grid,cost,dp));\\n        }\\n        return dp[i][j]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            mini = min(mini,solve(0,j,grid,moveCost,dp));\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619267,
                "title": "python-dijkstra-dynamic-programming-well-documented",
                "content": "## Approach 1: Dynamic Programming\\nMy thoughts here were to just \"push\" all the values from the previous row to the next row. Essentially just try all combinations row by row. Feels like brute force with dynamic programming sprinkled on top.\\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n        I looked at this problem as a \"push\" DP. Where I \"push\" the values\\n        from one row to the next and \"greedily\" take the minimum for each cell.\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        dp = [[float(\\'inf\\')]*n for _ in range(m)]\\n        for col in range(n):\\n            # Base case:\\n            # The cost to get here is the \\n            # value of the cell itself\\n            dp[0][col] = grid[0][col]\\n        \\n        # We iterate to just before the final row.\\n        # Remember, we are \"pushing\" and when we\\n        # are on the last row, there wont be anywhere\\n        # else to push too.\\n        for row in range(m-1): \\n            for col in range(n):\\n                # curCell: The cell we are going to \"push\" from\\n                curCell = grid[row][col] \\n                # The row we are going to \"push\" to\\n                nextRow = row + 1\\n                # We will iterate through all\\n                # the columns in the next row\\n                for nextCol in range(n):\\n                    # The cell we are going to \"push\" to\\n                    nextCell = grid[nextRow][nextCol]\\n                    # cost to get here:\\n                    # costOfPreviousCell + costToMove + costOfThisCell\\n                    #\\n                    # what is cost to get to the previous cell\\n                    costOfPreviousCell = dp[row][col]\\n                    # The cost to conduct this move\\n                    costToMove = moveCost[curCell][nextCol]\\n                    # The cost of this cell is just\\n                    # the value of the cell itself\\n                    costOfThisCell = nextCell\\n                    # Update the cost if we can do better (greedily take the smallest value)\\n                    dp[nextRow][nextCol] = min(dp[nextRow][nextCol], costOfPreviousCell + costToMove + costOfThisCell)\\n        \\n        \\n        # As the problem states:\\n        # Return the minimum cost of a path that starts from any \\n        # cell in the first row and ends at any cell in the last row.\\n        return min(val for val in dp[-1])\\n                    \\n        \\n```\\n\\n## Approach 2: Dijkstra\\nThis was actually my first approach. My thinking was that all I need the most optimal (cheapest) path to get to any leaf (bottom) node. We don\\'t actually care what node it is as we can just pick the minimum value from the last row.\\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        \\n        minHeap = [] # the heap will be maintained like: (cost, row, col)\\n        \\n        m, n = len(grid), len(grid[0])\\n        # I guess you could call this dp if you wanted?\\n        cost = [float(\\'inf\\')]*(m*n)\\n        \\n        # As the problem states you\\'re allowed to start\\n        # from anywhere on the first row\\n        for col in range(n):\\n            # grid[0][col] = cost\\n            # 0 = the row\\n            # col = the column\\n            heapq.heappush(minHeap, (grid[0][col], 0, col))\\n            # As we only are moving down to the next column we dont have to do this.\\n            # cost[grid[0][col]] = grid[0][col]\\n        \\n        \\n        while minHeap:\\n            curCost, row, col = heapq.heappop(minHeap)\\n            # If we are on the last row, \\n            # as the problem states do nothing.\\n            if row == m-1:\\n                continue\\n            \\n            # As the problem states, we can go to\\n            # any column in the next row. So we\\n            # try them all.\\n            for nextCol in range(n):\\n                nextRow = row+1\\n                curNode = grid[row][col]\\n                nextNode = grid[nextRow][nextCol]\\n                # As the problem states:\\n                #   grid[nextRow][nextCol]: the cost is the sum of all values of cells visited\\n                #   moveCost[curNode][nextCol]: plus the sum of costs of all the moves made\\n                #   curCost: The current cost we have paid to get here\\n                nextCost = moveCost[curNode][nextCol] + grid[nextRow][nextCol] + curCost\\n                # If I can can get to the nextNode cheaper - update and push into the heap.\\n                if cost[nextNode] > nextCost:\\n                    cost[grid[nextRow][nextCol]] = nextCost\\n                    heapq.heappush(minHeap, (nextCost, nextRow, nextCol))\\n        \\n        # We are only concerned about the last nodes, so \\n        # we just return the cheapest.\\n        return min(cost[node] for node in grid[-1])\\n                \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \"\"\"\\n        I looked at this problem as a \"push\" DP. Where I \"push\" the values\\n        from one row to the next and \"greedily\" take the minimum for each cell.\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        dp = [[float(\\'inf\\')]*n for _ in range(m)]\\n        for col in range(n):\\n            # Base case:\\n            # The cost to get here is the \\n            # value of the cell itself\\n            dp[0][col] = grid[0][col]\\n        \\n        # We iterate to just before the final row.\\n        # Remember, we are \"pushing\" and when we\\n        # are on the last row, there wont be anywhere\\n        # else to push too.\\n        for row in range(m-1): \\n            for col in range(n):\\n                # curCell: The cell we are going to \"push\" from\\n                curCell = grid[row][col] \\n                # The row we are going to \"push\" to\\n                nextRow = row + 1\\n                # We will iterate through all\\n                # the columns in the next row\\n                for nextCol in range(n):\\n                    # The cell we are going to \"push\" to\\n                    nextCell = grid[nextRow][nextCol]\\n                    # cost to get here:\\n                    # costOfPreviousCell + costToMove + costOfThisCell\\n                    #\\n                    # what is cost to get to the previous cell\\n                    costOfPreviousCell = dp[row][col]\\n                    # The cost to conduct this move\\n                    costToMove = moveCost[curCell][nextCol]\\n                    # The cost of this cell is just\\n                    # the value of the cell itself\\n                    costOfThisCell = nextCell\\n                    # Update the cost if we can do better (greedily take the smallest value)\\n                    dp[nextRow][nextCol] = min(dp[nextRow][nextCol], costOfPreviousCell + costToMove + costOfThisCell)\\n        \\n        \\n        # As the problem states:\\n        # Return the minimum cost of a path that starts from any \\n        # cell in the first row and ends at any cell in the last row.\\n        return min(val for val in dp[-1])\\n                    \\n        \\n```\n```python\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        \\n        minHeap = [] # the heap will be maintained like: (cost, row, col)\\n        \\n        m, n = len(grid), len(grid[0])\\n        # I guess you could call this dp if you wanted?\\n        cost = [float(\\'inf\\')]*(m*n)\\n        \\n        # As the problem states you\\'re allowed to start\\n        # from anywhere on the first row\\n        for col in range(n):\\n            # grid[0][col] = cost\\n            # 0 = the row\\n            # col = the column\\n            heapq.heappush(minHeap, (grid[0][col], 0, col))\\n            # As we only are moving down to the next column we dont have to do this.\\n            # cost[grid[0][col]] = grid[0][col]\\n        \\n        \\n        while minHeap:\\n            curCost, row, col = heapq.heappop(minHeap)\\n            # If we are on the last row, \\n            # as the problem states do nothing.\\n            if row == m-1:\\n                continue\\n            \\n            # As the problem states, we can go to\\n            # any column in the next row. So we\\n            # try them all.\\n            for nextCol in range(n):\\n                nextRow = row+1\\n                curNode = grid[row][col]\\n                nextNode = grid[nextRow][nextCol]\\n                # As the problem states:\\n                #   grid[nextRow][nextCol]: the cost is the sum of all values of cells visited\\n                #   moveCost[curNode][nextCol]: plus the sum of costs of all the moves made\\n                #   curCost: The current cost we have paid to get here\\n                nextCost = moveCost[curNode][nextCol] + grid[nextRow][nextCol] + curCost\\n                # If I can can get to the nextNode cheaper - update and push into the heap.\\n                if cost[nextNode] > nextCost:\\n                    cost[grid[nextRow][nextCol]] = nextCost\\n                    heapq.heappush(minHeap, (nextCost, nextRow, nextCol))\\n        \\n        # We are only concerned about the last nodes, so \\n        # we just return the cheapest.\\n        return min(cost[node] for node in grid[-1])\\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612055,
                "title": "dp-detailed-explanation-c",
                "content": "# Intuition\\njust do as asked in the question now since we have to make all the calls from the given cell so we can store them in the dp grid so that if we further require them in future we can get them \\n\\n# Approach\\nwhat i will do is start from each cell and make a recursive call to everyother column in next cell and store the cost needed to go that way and will store that in the dp matrix and return at the end now talking about the base case we can not go beyond n-1 row so we have to return there the value of grid in which we are\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>>& dp){\\n         int n=grid.size(); // size of row\\n        int m=grid[0].size(); // size of col\\n        if(i>=n-1){    // base case\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int temp=INT_MAX; \\n        for(int s=0; s<m; s++){\\n          int temp1=moveCost[grid[i][j]][s]+solve(i+1,s,grid,moveCost,dp);\\n          temp=min(temp,temp1);\\n        }\\n        return dp[i][j]=temp+grid[i][j];\\n   }\\n\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1)); \\n        int ans=INT_MAX;\\n        for(int i=0;i<m; i++){\\n            ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& moveCost,vector<vector<int>>& dp){\\n         int n=grid.size(); // size of row\\n        int m=grid[0].size(); // size of col\\n        if(i>=n-1){    // base case\\n            return grid[i][j];\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int temp=INT_MAX; \\n        for(int s=0; s<m; s++){\\n          int temp1=moveCost[grid[i][j]][s]+solve(i+1,s,grid,moveCost,dp);\\n          temp=min(temp,temp1);\\n        }\\n        return dp[i][j]=temp+grid[i][j];\\n   }\\n\\n\\n\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1)); \\n        int ans=INT_MAX;\\n        for(int i=0;i<m; i++){\\n            ans=min(ans,solve(0,i,grid,moveCost,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592935,
                "title": "java-top-down-dp-with-memoization-o-m-n",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int[][] grid;\\n    int[][] moveCost;\\n    int m;\\n    int n;\\n    Integer[][] memo;\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        this.grid = grid;\\n        this.moveCost = moveCost;\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new Integer[m][n];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int col = 0; col < n; col++) {\\n            minCost = Math.min(minCost, findMinCost(0, col));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    private int findMinCost(int row, int col) {\\n        int value = grid[row][col];\\n        if (row == m - 1) return value;\\n        if (memo[row][col] != null) return memo[row][col];\\n\\n        int minCost = Integer.MAX_VALUE;\\n        int[] currCost = moveCost[value];\\n        for (int nextCol = 0; nextCol < n; nextCol++) {\\n            minCost = Math.min(minCost, currCost[nextCol] + value + findMinCost(row + 1, nextCol));\\n        }\\n\\n        memo[row][col] = minCost;\\n        return memo[row][col];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] grid;\\n    int[][] moveCost;\\n    int m;\\n    int n;\\n    Integer[][] memo;\\n\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n        this.grid = grid;\\n        this.moveCost = moveCost;\\n        m = grid.length;\\n        n = grid[0].length;\\n        memo = new Integer[m][n];\\n        int minCost = Integer.MAX_VALUE;\\n        for (int col = 0; col < n; col++) {\\n            minCost = Math.min(minCost, findMinCost(0, col));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    private int findMinCost(int row, int col) {\\n        int value = grid[row][col];\\n        if (row == m - 1) return value;\\n        if (memo[row][col] != null) return memo[row][col];\\n\\n        int minCost = Integer.MAX_VALUE;\\n        int[] currCost = moveCost[value];\\n        for (int nextCol = 0; nextCol < n; nextCol++) {\\n            minCost = Math.min(minCost, currCost[nextCol] + value + findMinCost(row + 1, nextCol));\\n        }\\n\\n        memo[row][col] = minCost;\\n        return memo[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567323,
                "title": "easy-to-understand-javsscript-solution-dp",
                "content": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp = Array(m - 1).fill(\\'\\').map(_ => Array(n).fill(Infinity));\\n    let result = Infinity;\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const cell = grid[row][col];\\n\\n            if (row === m - 1) {\\n                result = Math.min(result, dp[row - 1][col] + cell);\\n                continue;\\n            }\\n            const costs = moveCost[cell];\\n            const lastCell = dp[row - 1]?.[col] ?? 0;\\n\\n            costs.forEach((cost, index) => {\\n                dp[row][index] = Math.min(dp[row][index], lastCell + cost + cell);\\n            });\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minPathCost = function(grid, moveCost) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp = Array(m - 1).fill(\\'\\').map(_ => Array(n).fill(Infinity));\\n    let result = Infinity;\\n\\n    for (let row = 0; row < m; row++) {\\n        for (let col = 0; col < n; col++) {\\n            const cell = grid[row][col];\\n\\n            if (row === m - 1) {\\n                result = Math.min(result, dp[row - 1][col] + cell);\\n                continue;\\n            }\\n            const costs = moveCost[cell];\\n            const lastCell = dp[row - 1]?.[col] ?? 0;\\n\\n            costs.forEach((cost, index) => {\\n                dp[row][index] = Math.min(dp[row][index], lastCell + cost + cell);\\n            });\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562453,
                "title": "beats-98-java-dynamic-programming-memoization-tabulation",
                "content": "# Complexity\\n- Time complexity:O(n*m*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n       \\n        int height=grid.length;\\n        int width=grid[0].length;\\n\\n        int[][] dp=new int[height][width];\\n\\n\\n        //memoization apporach \\n        //  int result=Integer.MAX_VALUE;\\n        // for(int i[]:dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n\\n        // for(int i=0;i<width;i++){\\n        //     result=Math.min(result,path(grid,moveCost,0,i,height,width,dp));\\n        // }\\n        // return result;\\n\\n\\n        //tabulation \\n        for(int i=0;i<width;i++){\\n            dp[height-1][i]=grid[height-1][i];\\n        }\\n\\n        int result=0;\\n        for(int i=height-2;i>=0;i--){\\n            result=Integer.MAX_VALUE;\\n            for(int j=0;j<width;j++){\\n\\n                int down=Integer.MAX_VALUE;\\n                int node=grid[i][j];\\n\\n                for(int x=0;x<width;x++){\\n                    int temp=moveCost[node][x]+dp[i+1][x];\\n                    down=Math.min(down,temp);\\n                }\\n\\n                dp[i][j]=node+down;\\n                result=Math.min(result,dp[i][j]);\\n            }\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static int path(int[][] grid,int[][] cost,int i,int j,int height,int width,int[][] dp){\\n\\n        if(i==height-1){\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n\\n        int down=Integer.MAX_VALUE;\\n        int node=grid[i][j];\\n\\n        for(int x=0;x<width;x++){\\n            int temp=cost[node][x]+path(grid,cost,i+1,x,height,width,dp);\\n            down=Math.min(down,temp);\\n        }\\n\\n\\n        dp[i][j]=node+down;\\n\\n        return node+down;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPathCost(int[][] grid, int[][] moveCost) {\\n\\n       \\n        int height=grid.length;\\n        int width=grid[0].length;\\n\\n        int[][] dp=new int[height][width];\\n\\n\\n        //memoization apporach \\n        //  int result=Integer.MAX_VALUE;\\n        // for(int i[]:dp){\\n        //     Arrays.fill(i,-1);\\n        // }\\n\\n        // for(int i=0;i<width;i++){\\n        //     result=Math.min(result,path(grid,moveCost,0,i,height,width,dp));\\n        // }\\n        // return result;\\n\\n\\n        //tabulation \\n        for(int i=0;i<width;i++){\\n            dp[height-1][i]=grid[height-1][i];\\n        }\\n\\n        int result=0;\\n        for(int i=height-2;i>=0;i--){\\n            result=Integer.MAX_VALUE;\\n            for(int j=0;j<width;j++){\\n\\n                int down=Integer.MAX_VALUE;\\n                int node=grid[i][j];\\n\\n                for(int x=0;x<width;x++){\\n                    int temp=moveCost[node][x]+dp[i+1][x];\\n                    down=Math.min(down,temp);\\n                }\\n\\n                dp[i][j]=node+down;\\n                result=Math.min(result,dp[i][j]);\\n            }\\n\\n        }\\n\\n        return result;\\n        \\n    }\\n\\n    public static int path(int[][] grid,int[][] cost,int i,int j,int height,int width,int[][] dp){\\n\\n        if(i==height-1){\\n            return grid[i][j];\\n        }\\n\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n\\n\\n        int down=Integer.MAX_VALUE;\\n        int node=grid[i][j];\\n\\n        for(int x=0;x<width;x++){\\n            int temp=cost[node][x]+path(grid,cost,i+1,x,height,width,dp);\\n            down=Math.min(down,temp);\\n        }\\n\\n\\n        dp[i][j]=node+down;\\n\\n        return node+down;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514055,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet `dp_curr` be the min cost of all paths that end at row j. Use `dp_curr` to calculate `dp_next` by consider all incoming edges on cells in the next row. \\n\\n# Complexity\\n- Time complexity: O(M * N * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp_curr = grid[0]\\n        dp_next = [math.inf] * n\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp_next[j] = min(dp_next[j], dp_curr[k] + moveCost[grid[i - 1][k]][j] + grid[i][j])\\n            \\n            dp_curr, dp_next = dp_next, [math.inf] * n\\n        \\n        return min(dp_curr)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dp_curr = grid[0]\\n        dp_next = [math.inf] * n\\n        \\n        for i in range(1, m):\\n            for j in range(n):\\n                for k in range(n):\\n                    dp_next[j] = min(dp_next[j], dp_curr[k] + moveCost[grid[i - 1][k]][j] + grid[i][j])\\n            \\n            dp_curr, dp_next = dp_next, [math.inf] * n\\n        \\n        return min(dp_curr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498009,
                "title": "go-top-down-bottom-up",
                "content": "# Intuition\\nWe can either start from the top and recurse to the bottom using memoization or start from the bottom up in a Bellman-Ford manner.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBoth are O(m * n^2), since for each cell we need to iterate over previous row.\\n\\n- Space complexity:\\nO(m * n)\\n\\n# Code\\n\\n### Top-down with memoization:\\n\\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    n := len(grid[0])\\n\\n    // Initialize dp matrix\\n    minCost := make([][]int, 0)\\n    for range grid {\\n        minCost = append(minCost, make([]int, n))\\n    }\\n\\n    var dp func(i, j int) int\\n    dp = func(i, j int) int {\\n        if i == 0 {\\n            return grid[0][j]\\n        }\\n\\n        if minCost[i][j] != 0 {\\n            return minCost[i][j]\\n        }\\n\\n        localMin := math.MaxInt32\\n        for k, prev := range grid[i-1] {\\n            temp := dp(i-1, k) + grid[i][j] + moveCost[prev][j]\\n            if temp < localMin {\\n                localMin = temp\\n            }\\n        }\\n\\n        minCost[i][j] = localMin\\n\\n        return localMin\\n    }\\n    \\n    globalMin := math.MaxInt32\\n    for col, _ := range grid[len(grid) - 1] {\\n        currCost := dp(len(grid) - 1, col)\\n        if currCost < globalMin {\\n            globalMin = currCost\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```\\n\\n### \"Bellman-Ford\" bottom-up:\\n\\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    // Initialize matrix (first row same as grid)\\n    minCost := make([][]int, 0)\\n    minCost = append(minCost, grid[0])\\n    for range grid[1:] {\\n        minCost = append(minCost, make([]int, len(grid[0])))\\n    }\\n\\n    for i:=1; i<len(grid); i++ {\\n        for j:=0; j<len(grid[0]); j++ {\\n            localMin := math.MaxInt32\\n            for prevIndex, prev := range grid[i-1] {\\n                temp := grid[i][j] + minCost[i-1][prevIndex] + moveCost[prev][j]\\n                if temp < localMin {\\n                    localMin = temp\\n                }\\n            }\\n            minCost[i][j] = localMin\\n        }\\n    }\\n\\n    globalMin := math.MaxInt32\\n    for _, val := range minCost[len(grid)-1] {\\n        if val < globalMin {\\n            globalMin = val\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    n := len(grid[0])\\n\\n    // Initialize dp matrix\\n    minCost := make([][]int, 0)\\n    for range grid {\\n        minCost = append(minCost, make([]int, n))\\n    }\\n\\n    var dp func(i, j int) int\\n    dp = func(i, j int) int {\\n        if i == 0 {\\n            return grid[0][j]\\n        }\\n\\n        if minCost[i][j] != 0 {\\n            return minCost[i][j]\\n        }\\n\\n        localMin := math.MaxInt32\\n        for k, prev := range grid[i-1] {\\n            temp := dp(i-1, k) + grid[i][j] + moveCost[prev][j]\\n            if temp < localMin {\\n                localMin = temp\\n            }\\n        }\\n\\n        minCost[i][j] = localMin\\n\\n        return localMin\\n    }\\n    \\n    globalMin := math.MaxInt32\\n    for col, _ := range grid[len(grid) - 1] {\\n        currCost := dp(len(grid) - 1, col)\\n        if currCost < globalMin {\\n            globalMin = currCost\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```\n```\\nfunc minPathCost(grid [][]int, moveCost [][]int) int {\\n    // Initialize matrix (first row same as grid)\\n    minCost := make([][]int, 0)\\n    minCost = append(minCost, grid[0])\\n    for range grid[1:] {\\n        minCost = append(minCost, make([]int, len(grid[0])))\\n    }\\n\\n    for i:=1; i<len(grid); i++ {\\n        for j:=0; j<len(grid[0]); j++ {\\n            localMin := math.MaxInt32\\n            for prevIndex, prev := range grid[i-1] {\\n                temp := grid[i][j] + minCost[i-1][prevIndex] + moveCost[prev][j]\\n                if temp < localMin {\\n                    localMin = temp\\n                }\\n            }\\n            minCost[i][j] = localMin\\n        }\\n    }\\n\\n    globalMin := math.MaxInt32\\n    for _, val := range minCost[len(grid)-1] {\\n        if val < globalMin {\\n            globalMin = val\\n        }\\n    }\\n\\n    return globalMin\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496310,
                "title": "dp-solution-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef vector< vector<int> >vv;\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n int n, m;\\nvv grid, cost,Dp;\\n    int minPathCost(vv& Grid, vv& moveCost) {\\n    n=Grid.size();\\n    m=Grid[0].size();\\n    grid = Grid;\\n    cost = moveCost;\\n    Dp = vv(n, vi(m,-1));\\n    int ans = 1e9;\\n    for (int x = 0; x < m; x++)\\n        ans = min(ans, Solve(0, x));\\n    return ans;\\n    }\\n\\nint Solve(int i,int j) {\\n    if (Dp[i][j] != -1)return Dp[i][j];\\n    if (i == n - 1)return Dp[i][j]=grid[i][j];\\n    int Best = 1e9,Cell_Cost= grid[i][j];\\n    for (int x = 0; x < m; x++) {\\n        Best = min(Best,Solve(i+1,x)+cost[Cell_Cost][x]);\\n    }\\n    return Dp[i][j]=Best + Cell_Cost;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef vector< vector<int> >vv;\\ntypedef vector<int>vi;\\nclass Solution {\\npublic:\\n int n, m;\\nvv grid, cost,Dp;\\n    int minPathCost(vv& Grid, vv& moveCost) {\\n    n=Grid.size();\\n    m=Grid[0].size();\\n    grid = Grid;\\n    cost = moveCost;\\n    Dp = vv(n, vi(m,-1));\\n    int ans = 1e9;\\n    for (int x = 0; x < m; x++)\\n        ans = min(ans, Solve(0, x));\\n    return ans;\\n    }\\n\\nint Solve(int i,int j) {\\n    if (Dp[i][j] != -1)return Dp[i][j];\\n    if (i == n - 1)return Dp[i][j]=grid[i][j];\\n    int Best = 1e9,Cell_Cost= grid[i][j];\\n    for (int x = 0; x < m; x++) {\\n        Best = min(Best,Solve(i+1,x)+cost[Cell_Cost][x]);\\n    }\\n    return Dp[i][j]=Best + Cell_Cost;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483087,
                "title": "easy-c-dp",
                "content": "# Intuition\\n We can use a 2D array `dp` to store the minimum path cost to reach a cell `(i, j)`. The value of `dp[i][j]` is the minimum of `dp[i-1][j-1]`, `dp[i-1][j]` and `dp[i-1][j+1]` plus the cost of reaching the cell `(i, j)`.\\n\\n# Approach\\nWe start by initializing the first row of `dp` with the values from the `grid`. Then, for each subsequent row, we compute the values of `dp` using the above formula. Finally, we return the minimum value of the last row of `dp`.\\n\\n# Complexity\\n- Time complexity: O(m*n), where m and n are the number of rows and columns of the grid, respectively. This is because we iterate through each cell of the grid exactly once.\\n- Space complexity: O(m*n), for the `dp` array.\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // Initialize the first row of dp\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = grid[0][j];\\n        }\\n\\n        // Compute the values of dp for each subsequent row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + grid[i][j]; // start with up move\\n                if (j > 0) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + moveCost[grid[i-1][j-1]][grid[i][j]]);\\n                }\\n                if (j < n-1) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j+1] + moveCost[grid[i-1][j+1]][grid[i][j]]);\\n                }\\n            }\\n        }\\n\\n        // Return the minimum value of the last row of dp\\n        return *min_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n\\n        // Initialize the first row of dp\\n        for (int j = 0; j < n; j++) {\\n            dp[0][j] = grid[0][j];\\n        }\\n\\n        // Compute the values of dp for each subsequent row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + grid[i][j]; // start with up move\\n                if (j > 0) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + moveCost[grid[i-1][j-1]][grid[i][j]]);\\n                }\\n                if (j < n-1) {\\n                    dp[i][j] = min(dp[i][j], dp[i-1][j+1] + moveCost[grid[i-1][j+1]][grid[i][j]]);\\n                }\\n            }\\n        }\\n\\n        // Return the minimum value of the last row of dp\\n        return *min_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3472941,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        dp = grid[-1]\\n        for row in range(len(grid) - 2, -1, -1):\\n            new_dp = [float(\\'inf\\')] * len(grid[0])\\n            for col_from in range(len(grid[0])):\\n                for col_to in range(len(grid[0])):\\n                    new_dp[col_from] = min(new_dp[col_from], moveCost[grid[row][col_from]][col_to] + dp[col_to])\\n                new_dp[col_from] += grid[row][col_from]\\n            dp = new_dp\\n        return min(dp)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        dp = grid[-1]\\n        for row in range(len(grid) - 2, -1, -1):\\n            new_dp = [float(\\'inf\\')] * len(grid[0])\\n            for col_from in range(len(grid[0])):\\n                for col_to in range(len(grid[0])):\\n                    new_dp[col_from] = min(new_dp[col_from], moveCost[grid[row][col_from]][col_to] + dp[col_to])\\n                new_dp[col_from] += grid[row][col_from]\\n            dp = new_dp\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435201,
                "title": "brute-force-bottom-up-runtime-100-beats-memory-100-beats",
                "content": "# Intuition\\nThe last line is not calculated. Then we go up from the penultimate row. The answer is in the first row. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for j, val in enumerate(grid[i]):\\n                grid[i][j] += min(map(add, grid[i+1], moveCost[val]))\\n        return min(grid[0])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for j, val in enumerate(grid[i]):\\n                grid[i][j] += min(map(add, grid[i+1], moveCost[val]))\\n        return min(grid[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431144,
                "title": "c-recursive-memoization-easy",
                "content": "\\n\\n# Recursive Code [TLE]\\n```\\nclass Solution {\\npublic:\\n    \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost)\\n     {\\n         if(row==grid.size()-1)   // base case \\n         {\\n             return grid[row][ind];\\n         }\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)  // trying all possible ways i.e. from current col going to 0,1,....col-1 columns in next row\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost));\\n         }\\n         return ans+grid[row][ind];  // because in cost we also need to add value of cell \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n        for(int i=0;i<choice;i++)  // starting at ith index in first row find the min cost to reach last row\\n        {\\n            mn=min(mn,find(0,i,grid,cost));  // take min \\n        }\\n        return mn;  /// return the computed ans \\n    }\\n};\\n```\\n# Memoized code [Top down ]\\n```\\nclass Solution {\\npublic:\\n     \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp)\\n     {\\n         if(row==grid.size()-1)\\n         {\\n             return dp[row][ind]=grid[row][ind];\\n         }\\n         if(dp[row][ind]!=-1)  // if allready computed then return \\n           return dp[row][ind];\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost,dp));\\n         }\\n         return dp[row][ind]=ans+grid[row][ind];  // storing the computed result \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n       int n=grid.size();\\n       vector<vector<int>>dp(n,vector<int>(choice,-1));\\n        for(int i=0;i<choice;i++)\\n        {\\n            mn=min(mn,find(0,i,grid,cost,dp));\\n        }\\n        return mn;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost)\\n     {\\n         if(row==grid.size()-1)   // base case \\n         {\\n             return grid[row][ind];\\n         }\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)  // trying all possible ways i.e. from current col going to 0,1,....col-1 columns in next row\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost));\\n         }\\n         return ans+grid[row][ind];  // because in cost we also need to add value of cell \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n        for(int i=0;i<choice;i++)  // starting at ith index in first row find the min cost to reach last row\\n        {\\n            mn=min(mn,find(0,i,grid,cost));  // take min \\n        }\\n        return mn;  /// return the computed ans \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     \\n     int find(int row,int ind,vector<vector<int>>&grid,vector<vector<int>>&cost,vector<vector<int>>&dp)\\n     {\\n         if(row==grid.size()-1)\\n         {\\n             return dp[row][ind]=grid[row][ind];\\n         }\\n         if(dp[row][ind]!=-1)  // if allready computed then return \\n           return dp[row][ind];\\n         int ans=INT_MAX;\\n         for(int i=0;i<grid[0].size();i++)\\n         {\\n             int ele=grid[row][ind];\\n             ans=min(ans,cost[ele][i]+find(row+1,i,grid,cost,dp));\\n         }\\n         return dp[row][ind]=ans+grid[row][ind];  // storing the computed result \\n     }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) \\n    {\\n        int choice=grid[0].size();\\n        int mn=INT_MAX;\\n       int n=grid.size();\\n       vector<vector<int>>dp(n,vector<int>(choice,-1));\\n        for(int i=0;i<choice;i++)\\n        {\\n            mn=min(mn,find(0,i,grid,cost,dp));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418309,
                "title": "easy-dp-c-solution",
                "content": "# Intuition\\n2D DP\\n\\n# Approach\\nApply top-down DP on each element in first row of grid, then find starting from which element gives the min cost. \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& move,vector<vector<int>>& dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n-1) dp[i][j]=grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int x=INT_MAX;\\n        for(int a=0;a<m;a++){\\n            int b=grid[i][j];\\n            int c=recur(i+1,a,grid,move,dp),d=move[b][a];\\n            x=min(x,c+d);\\n        }        \\n        dp[i][j]=x+grid[i][j];\\n        return dp[i][j];\\n    }\\n    void reset(vector<vector<int>> &dp){\\n        int n=dp.size(),m=dp[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            reset(dp);\\n            ans=min(ans,recur(0,i,grid,move,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& move,vector<vector<int>>& dp){\\n        int n=grid.size(),m=grid[0].size();\\n        if(i==n-1) dp[i][j]=grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int x=INT_MAX;\\n        for(int a=0;a<m;a++){\\n            int b=grid[i][j];\\n            int c=recur(i+1,a,grid,move,dp),d=move[b][a];\\n            x=min(x,c+d);\\n        }        \\n        dp[i][j]=x+grid[i][j];\\n        return dp[i][j];\\n    }\\n    void reset(vector<vector<int>> &dp){\\n        int n=dp.size(),m=dp[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n        int ans=INT_MAX;\\n        for(int i=0;i<m;i++){\\n            reset(dp);\\n            ans=min(ans,recur(0,i,grid,move,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410626,
                "title": "ez-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        int m = INT_MAX;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = 0; j < dp[0].size(); ++j) {\\n                if (i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    for (int k = 0; k < grid[0].size(); ++k) {\\n                        dp[i][j] = min(dp[i][j],  moveCost[grid[i - 1][k]][j] + grid[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            m = min(dp[grid.size() - 1][j], m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), INT_MAX));\\n        int m = INT_MAX;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            for (int j = 0; j < dp[0].size(); ++j) {\\n                if (i == 0) {\\n                    dp[i][j] = grid[i][j];\\n                }\\n                else {\\n                    for (int k = 0; k < grid[0].size(); ++k) {\\n                        dp[i][j] = min(dp[i][j],  moveCost[grid[i - 1][k]][j] + grid[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            m = min(dp[grid.size() - 1][j], m);\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382059,
                "title": "python-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for o,j in enumerate(grid[i]):\\n                best = float(\"inf\")\\n                for x,y in enumerate(moveCost[j]):\\n                    best = min(best, j+y+grid[i+1][x])\\n                grid[i][o] = best\\n        return min(grid[0])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        for i in range(len(grid)-2, -1, -1):\\n            for o,j in enumerate(grid[i]):\\n                best = float(\"inf\")\\n                for x,y in enumerate(moveCost[j]):\\n                    best = min(best, j+y+grid[i+1][x])\\n                grid[i][o] = best\\n        return min(grid[0])\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380563,
                "title": "o-n-beats-79-recursion-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[54][54];\\n    int find(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&move)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == 0)return grid[i][j];\\n\\n        int ans = 1e9;\\n        for(int k = 0; k<m; k++)\\n        {\\n            int temp =  move[grid[i-1][k]][j] + find(i-1, k, grid, move);\\n            ans = min(ans, temp+grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        for(int j = 0; j<m; j++)\\n             ans = min(ans, find(n-1, j, grid, moveCost));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[54][54];\\n    int find(int i, int j, vector<vector<int>>&grid, vector<vector<int>>&move)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(i == 0)return grid[i][j];\\n\\n        int ans = 1e9;\\n        for(int k = 0; k<m; k++)\\n        {\\n            int temp =  move[grid[i-1][k]][j] + find(i-1, k, grid, move);\\n            ans = min(ans, temp+grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) \\n    {\\n        memset(dp, -1, sizeof dp);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        for(int j = 0; j<m; j++)\\n             ans = min(ans, find(n-1, j, grid, moveCost));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364809,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    ans=min(ans,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        for(int i=0;i<m;i++){\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<m;k++){\\n                    ans=min(ans,dp[i+1][k]+moveCost[grid[i][j]][k]);\\n                }\\n                dp[i][j]=ans+grid[i][j];\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352896,
                "title": "dp-solution-python-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\t\\t\\tdp=[[float(\"inf\")]*len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tfor k in range(len(grid[0])):\\n\\t\\t\\t\\tdp[0][k]=grid[0][k]  \\n\\t\\t\\tfor i in range(1,len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\t\\t\\tfor n in range(len(grid[0])):\\n\\t\\t\\t\\t\\t\\t#print(dp)\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min(dp[i][j],dp[i-1][n]+moveCost[grid[i-1][n]][j])\\n\\t\\t\\t\\t\\tdp[i][j]+=grid[i][j]    \\n\\t\\t\\t\\t\\t#dp[i][1]=grid[i][1]+min(dp[i-1][0]+moveCost[grid[i-1][0]][1],dp[i-1][1]+moveCost[grid[i-1][1]][1])\\n\\t\\t\\t\\t\\t#print(dp)        \\n\\t\\t\\treturn min(dp[-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n\\t\\t\\tdp=[[float(\"inf\")]*len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tfor k in range(len(grid[0])):\\n\\t\\t\\t\\tdp[0][k]=grid[0][k]  \\n\\t\\t\\tfor i in range(1,len(grid)):\\n\\t\\t\\t\\tfor j in range(len(grid[0])):\\n\\t\\t\\t\\t\\tfor n in range(len(grid[0])):\\n\\t\\t\\t\\t\\t\\t#print(dp)\\n\\t\\t\\t\\t\\t\\tdp[i][j]=min(dp[i][j],dp[i-1][n]+moveCost[grid[i-1][n]][j])\\n\\t\\t\\t\\t\\tdp[i][j]+=grid[i][j]    \\n\\t\\t\\t\\t\\t#dp[i][1]=grid[i][1]+min(dp[i-1][0]+moveCost[grid[i-1][0]][1],dp[i-1][1]+moveCost[grid[i-1][1]][1])\\n\\t\\t\\t\\t\\t#print(dp)        \\n\\t\\t\\treturn min(dp[-1])",
                "codeTag": "Java"
            },
            {
                "id": 3349126,
                "title": "c-easy-solution-dp-dijkstra",
                "content": "Dijkstra Solution :\\n\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>distance(n*m+1,INT_MAX);//min path sum for each node\\n      priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        for(int i=0;i<m;i++){\\n            distance[grid[0][i]]=grid[0][i];\\n            q.push({grid[0][i],{0,i}});//val,row,col\\n        }\\n        \\n        while(!q.empty()){\\n            auto f=q.top();\\n            q.pop();\\n            int dist=f.first;\\n            int row=f.second.first;\\n            int col=f.second.second;\\n            if(row==n-1)continue;  //reached last row\\n            \\n            for(int j=0;j<m;j++){\\n                \\n                int d=grid[row+1][j]+movecost[grid[row][col]][j];//cost of moving from node grid[row][col] to jth column node\\n                if(dist+d<distance[grid[row+1][j]]){\\n                    distance[grid[row+1][j]]=dist+d;\\n                    q.push({distance[grid[row+1][j]],{row+1,j}});\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans=min(ans,distance[grid[n-1][j]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nDP Solution :\\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=grid[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    dp[i][k]=min(dp[i][k],grid[i][k]+dp[i-1][j]+movecost[grid[i-1][j]][k]);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            //cout<<dp[n-1][j]<<\" \";\\n            ans=min(ans,dp[n-1][j]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>distance(n*m+1,INT_MAX);//min path sum for each node\\n      priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        for(int i=0;i<m;i++){\\n            distance[grid[0][i]]=grid[0][i];\\n            q.push({grid[0][i],{0,i}});//val,row,col\\n        }\\n        \\n        while(!q.empty()){\\n            auto f=q.top();\\n            q.pop();\\n            int dist=f.first;\\n            int row=f.second.first;\\n            int col=f.second.second;\\n            if(row==n-1)continue;  //reached last row\\n            \\n            for(int j=0;j<m;j++){\\n                \\n                int d=grid[row+1][j]+movecost[grid[row][col]][j];//cost of moving from node grid[row][col] to jth column node\\n                if(dist+d<distance[grid[row+1][j]]){\\n                    distance[grid[row+1][j]]=dist+d;\\n                    q.push({distance[grid[row+1][j]],{row+1,j}});\\n                }\\n            }\\n            \\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans=min(ans,distance[grid[n-1][j]]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& movecost) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int dp[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j]=INT_MAX;\\n            }\\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=grid[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<m;k++){\\n                    dp[i][k]=min(dp[i][k],grid[i][k]+dp[i-1][j]+movecost[grid[i-1][j]][k]);\\n                }\\n            }\\n        }\\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++){\\n            //cout<<dp[n-1][j]<<\" \";\\n            ans=min(ans,dp[n-1][j]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3347736,
                "title": "easy-to-understand-bottom-up-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    \\n    # O(n^2 * m) time,\\n    # O(1) space,\\n    # Approach: matrix, bottom up dp\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        for row in range(len(grid)-2, -1, -1):\\n            for col in range(len(grid[0])-1, -1, -1):\\n                min_choice = float(\\'inf\\')\\n                next_row = row + 1\\n                curr_val = grid[row][col]\\n                for next_row_col in range(len(grid[0])):\\n                    min_choice = min(min_choice, grid[next_row][next_row_col] + moveCost[curr_val][next_row_col])\\n                    \\n                grid[row][col] += min_choice\\n                \\n        return min(grid[0])\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    # O(n^2 * m) time,\\n    # O(1) space,\\n    # Approach: matrix, bottom up dp\\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\\n        \\n        for row in range(len(grid)-2, -1, -1):\\n            for col in range(len(grid[0])-1, -1, -1):\\n                min_choice = float(\\'inf\\')\\n                next_row = row + 1\\n                curr_val = grid[row][col]\\n                for next_row_col in range(len(grid[0])):\\n                    min_choice = min(min_choice, grid[next_row][next_row_col] + moveCost[curr_val][next_row_col])\\n                    \\n                grid[row][col] += min_choice\\n                \\n        return min(grid[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347418,
                "title": "easy-to-understand-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[51][51];\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j,int n,int m) {\\n        if(i == n-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int x=0;x<m;x++) {\\n            ans = min(ans,grid[i][j]+moveCost[grid[i][j]][x]+helper(grid,moveCost,i+1,x,n,m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) {\\n            ans = min(ans,helper(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[51][51];\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& moveCost,int i,int j,int n,int m) {\\n        if(i == n-1) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int x=0;x<m;x++) {\\n            ans = min(ans,grid[i][j]+moveCost[grid[i][j]][x]+helper(grid,moveCost,i+1,x,n,m));\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) {\\n            ans = min(ans,helper(grid,moveCost,0,i,n,m));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347069,
                "title": "c-easy-solution",
                "content": "int t[51][51];\\n\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost,int x,int y,int m,int n){\\n        if(x>=m||y>=n){\\n        \\n           \\treturn INT_MAX; \\n        }\\n\\t  if(x==m-1&&y<=n-1){\\n         \\n         \\treturn grid[x][y]; \\n      }\\n        if(t[x][y]!=-1)\\n\\t\\t\\treturn t[x][y];\\n        int mini=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){ \\n          int temp=solve(grid,cost,x+1,i,m,n);\\n          temp+=grid[x][y]+cost[grid[x][y]][i];\\n          mini=min(temp,mini);\\n        }\\n        return t[x][y]=mini;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& cost) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=INT_MAX;\\n       for(int i=0;i<n;i++){\\n              memset(t,-1,sizeof(t));\\n              int k= solve(grid,cost,0,i,m,n); \\n              ans=min(k,ans); \\n           \\n       }\\n       \\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, vector<vector<int>>& cost,int x,int y,int m,int n){\\n        if(x>=m||y>=n){\\n        \\n           \\treturn INT_MAX; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3347041,
                "title": "recursion-memoization-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\n                        // Recursion Method\\n// class Solution {\\n//     private:\\n//     void helper(vector<vector<int>>&grid,vector<vector<int>>&move,int sum,int&mini,int n,int m,int ind,int y){\\n//         if(ind==n-1){\\n//             mini=min(mini,sum);\\n//             return;\\n//         }\\n//         for(int i=0;i<m;i++){\\n//             helper(grid,move,sum+grid[ind+1][i]+move[grid[ind][y]][i],mini,n,m,ind+1,i);\\n//         }\\n//     }\\n// public:\\n//     int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n//         int n=grid.size();\\n//         int m=grid[0].size();\\n//         int mini1=INT_MAX;\\n//         for(int i=0;i<m;i++){\\n//             int sum=grid[0][i];\\n//             int mini=INT_MAX;\\n//             helper(grid,move,sum,mini,n,m,0,i);\\n//             mini1=min(mini1,mini);\\n//         }\\n//         return mini1;\\n//     }\\n// };\\n                                    //Memoization Approach\\n\\nclass Solution {\\n    private:\\n    int helper(vector<vector<int>>&grid,vector<vector<int>>&move,vector<vector<int>>&dp,int ind,int col,int n,int m){\\n        if(ind==n-1)return grid[ind][col];\\n        if(dp[ind][col]!=INT_MAX)return dp[ind][col];\\n        int ans=1e9;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(grid,move,dp,ind+1,i,n,m)+grid[ind][col]+move[grid[ind][col]][i]);\\n        }\\n        return dp[ind][col]=ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            int ans=helper(grid,move,dp,0,i,n,m);\\n            mini=min(mini,ans);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n                        // Recursion Method\\n// class Solution {\\n//     private:\\n//     void helper(vector<vector<int>>&grid,vector<vector<int>>&move,int sum,int&mini,int n,int m,int ind,int y){\\n//         if(ind==n-1){\\n//             mini=min(mini,sum);\\n//             return;\\n//         }\\n//         for(int i=0;i<m;i++){\\n//             helper(grid,move,sum+grid[ind+1][i]+move[grid[ind][y]][i],mini,n,m,ind+1,i);\\n//         }\\n//     }\\n// public:\\n//     int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n//         int n=grid.size();\\n//         int m=grid[0].size();\\n//         int mini1=INT_MAX;\\n//         for(int i=0;i<m;i++){\\n//             int sum=grid[0][i];\\n//             int mini=INT_MAX;\\n//             helper(grid,move,sum,mini,n,m,0,i);\\n//             mini1=min(mini1,mini);\\n//         }\\n//         return mini1;\\n//     }\\n// };\\n                                    //Memoization Approach\\n\\nclass Solution {\\n    private:\\n    int helper(vector<vector<int>>&grid,vector<vector<int>>&move,vector<vector<int>>&dp,int ind,int col,int n,int m){\\n        if(ind==n-1)return grid[ind][col];\\n        if(dp[ind][col]!=INT_MAX)return dp[ind][col];\\n        int ans=1e9;\\n        for(int i=0;i<m;i++){\\n            ans=min(ans,helper(grid,move,dp,ind+1,i,n,m)+grid[ind][col]+move[grid[ind][col]][i]);\\n        }\\n        return dp[ind][col]=ans;\\n    }\\npublic:\\n    int minPathCost(vector<vector<int>>&grid,vector<vector<int>>&move){\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int mini=INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        for(int i=0;i<m;i++){\\n            int ans=helper(grid,move,dp,0,i,n,m);\\n            mini=min(mini,ans);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761354,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1906034,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1981171,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1839342,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1766366,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2061999,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2044216,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2010537,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1999950,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1847545,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1761354,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1906034,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1981171,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1839342,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1766366,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2061999,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2044216,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 2010537,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1999950,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            },
            {
                "id": 1847545,
                "content": [
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I dont even understand the question :-/"
                    },
                    {
                        "username": "Msey",
                        "content": "example looks like a horror film episode"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "# Understanding `moveCost` input array \n\n### Brief\n\n> ![moveCost](https://assets.leetcode.com/users/images/5aa35121-45c5-452a-8e58-d750680ce293_1690031064.6585.png){:height=\"300px\"}\n\n\n### Detailed\n\nAs given in the problem statement\n\n> **0-indexed** 2D array `moveCost` of size `(m * n) x n`, where `moveCost[i][j]` is the cost of moving from a cell with value `i` to a cell in column `j` of the next row.\n\n- So, there will be `mn` rows in `moveCost` array. Each row corresponds to a cell in `grid` array. It is given that the `grid` matrix is `m x n` in size, and cells are numbered from `0` to `m*n - 1`.\n\n- There will be `n` columns in `moveCost` array. From any cell of `grid` array, we can move to `n` columns in the next row. \n\nTaking the example given in the problem statement\n\n<code><b>Input:</b> grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</code>\n\n- `grid` array is `3 x 2` in size. So, there will be `3*2 = 6` rows in `moveCost` array. \n\n- `grid` array has `2` columns. So, there will be `2` columns in `moveCost` array.\n\nNow, `moveCost` is `[[9, 8], [1, 5], [10, 12], [18, 6], [2, 4], [14, 3]]`.\n\n- Now, `9` is `moveCost[0][0]`. It is the cost of moving from cell `0` to column `0` of the next row.\n\n- `5` is `moveCost[1][1]`. It is the cost of moving from cell `1` to column `1` of the next row. However, if we see grid array, cell `1` is in the last row. So, there is no next row. Thus, `moveCost[1][1]` is not used.\n\n- `2` is `moveCost[4][0]`. It is the cost of moving from cell `4` to column `0` of the next row.\n\nHence, the above visualization!"
                    },
                    {
                        "username": "user2285TI",
                        "content": "The cost array feels awkward to search up. I would have preferred a 3D array to be honest."
                    },
                    {
                        "username": "_aka5h",
                        "content": "No idea how to get cost from that cost array."
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "moveCost[Value of cell you\\'re standing on][Column number of the cell you will be jumping on\\n]"
                    },
                    {
                        "username": "raskushwaha8",
                        "content": "hi, facing problem with the test case \\ngrid =\\n[[5,3],[4,0],[2,1]]\\nmoveCost =\\n[[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]\\n\\nleast cost seems to be 15 (3 -> 0 -> 1)\\nbut answer is 17 ??\\n\\nanyone else facing this issue?"
                    },
                    {
                        "username": "RohitSgh",
                        "content": "As given in problem description\\n\\n> The cost of a path in `grid` is the **sum** of all values of cells visited plus the **sum** of costs of all the moves made.\\n\\nThus, path 3 \\u2192 0 \\u2192 1 has cost of 3 + 6 + 0 + 8 + 1, which is 18, and is sub-optimal, [@rahul Kushwaha](/raskushwaha8)\\n\\nThe path **5 \\u2192 0 \\u2192 1** is optimal with a cost of **17**.\\n\\n"
                    },
                    {
                        "username": "hacker_antace",
                        "content": "```\\nclass Solution {\\npublic:\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        unordered_map<int, int>mp;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                mp[grid[i][j]] = i+1;\\n            }\\n        }\\n        vector<pair<int, int>> adj[m*n];\\n        for(int i = 0; i<moveCost.size(); i++){\\n            for(int j = 0; j< moveCost[i].size(); j++)\\n                if(mp[i]<n)\\n                    adj[i].push_back({grid[mp[i]][j], moveCost[i][j]});\\n        }\\n\\n        int res = INT_MAX;\\n        for(int i = 0; i<m; i++){\\n            priority_queue<pair<int, int> , vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n            vector<int> dist(n*m, INT_MAX);\\n            dist[grid[0][i]] = 0;\\n            pq.push({0, grid[0][i]});\\n            while(!pq.empty()){\\n                int node = pq.top().second;\\n                int dis = pq.top().first;\\n                pq.pop();\\n                for(auto it:adj[node]){\\n                    int node1 = it.first;\\n                    int dis1 = it.second;\\n                    if(dis + dis1 + node < dist[node1]){\\n                        dist[node1] = dis + dis1 + node;\\n                        pq.push({dis+dis1+node, node1});\\n                    }\\n                }\\n            }\\n            int mini = INT_MAX;\\n            for(int i = 0; i<m; i++){\\n                mini = min(mini, grid[n-1][i] + dist[grid[n-1][i]]);\\n            }\\n            res = min(mini, res);\\n        } \\n        return res;\\n    }\\n};\\n```\\n\\nWhy TLE on the last case, and that is too blank. \\n"
                    },
                    {
                        "username": "anandA3B",
                        "content": "godzilla had a stroke trying to understand the inputs"
                    },
                    {
                        "username": "user4739tT",
                        "content": "Here is the Recursive memoized and easy solution\\n\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& move, int n, int m, vector<vector<int>>&dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 1e4;\\n        if(i<n-1){\\n            for(int k = 0;k<m;k++){\\n            int temp = grid[i+1][k]+move[grid[i][j]][k]+f(i+1,k,grid,move,n,m,dp);\\n            ans=min(ans,temp);\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& move) {\\n        int ans = 1e4;\\n        int m = grid[0].size();\\n        int n = grid.size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        for(int j=0;j<m;j++){\\n            int temp = f(0,j,grid,move,n,m,dp);\\n            temp+=grid[0][j];\\n            ans = min(ans,temp);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "meng7878",
                        "content": "how to map the description of moveCost in the problem to the diagram in the example? I cannot understand the problem"
                    },
                    {
                        "username": "HelenaBond",
                        "content": "[@farago1](/farago1) moveCost for int g = grid[i][j] is int [] mC = moveCost[g]"
                    },
                    {
                        "username": "farago1",
                        "content": "moveCost[i][j] = the cost of moving from the grid cell which has i as its value, to the cell in the jth column in the row below the row which contains the grid cell that has the value i.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Asterisks",
        "question_content": "<p>You are given a string <code>s</code>, where every <strong>two</strong> consecutive vertical bars <code>&#39;|&#39;</code> are grouped into a <strong>pair</strong>. In other words, the 1<sup>st</sup> and 2<sup>nd</sup> <code>&#39;|&#39;</code> make a pair, the 3<sup>rd</sup> and 4<sup>th</sup> <code>&#39;|&#39;</code> make a pair, and so forth.</p>\n\n<p>Return <em>the number of </em><code>&#39;*&#39;</code><em> in </em><code>s</code><em>, <strong>excluding</strong> the </em><code>&#39;*&#39;</code><em> between each pair of </em><code>&#39;|&#39;</code>.</p>\n\n<p><strong>Note</strong> that each <code>&#39;|&#39;</code> will belong to <strong>exactly</strong> one pair.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;l|*e*et|c**o|*de|&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The considered characters are underlined: &quot;<u>l</u>|*e*et|<u>c**o</u>|*de|&quot;.\nThe characters between the first and second &#39;|&#39; are excluded from the answer.\nAlso, the characters between the third and fourth &#39;|&#39; are excluded from the answer.\nThere are 2 asterisks considered. Therefore, we return 2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;iamprogrammer&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this example, there are no asterisks in s. Therefore, we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;yo|uar|e**|b|e***au|tifu|l&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The considered characters are underlined: &quot;<u>yo</u>|uar|<u>e**</u>|b|<u>e***au</u>|tifu|<u>l</u>&quot;. There are 5 asterisks considered. Therefore, we return 5.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s</code> consists of lowercase English letters, vertical bars <code>&#39;|&#39;</code>, and asterisks <code>&#39;*&#39;</code>.</li>\n\t<li><code>s</code> contains an <strong>even</strong> number of vertical bars <code>&#39;|&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2196027,
                "title": "java-c-python-one-pass",
                "content": "# **Explanation**\\nParse the input, if currently met odd bars, we count `*`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countAsterisks(String s) {\\n        int res = 0, bars = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\' && bars % 2 == 0)\\n                res++;\\n            if (s.charAt(i) == \\'|\\')\\n                bars++;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countAsterisks(string s) {\\n        int res = 0, sign = 1;\\n        for (char& c : s)\\n            if ((sign ^= c == \\'|\\') && c == \\'*\\')\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**Python**\\nSpace O(n)\\n```py\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([a.count(\\'*\\') for a in s.split(\\'|\\')][0::2])\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countAsterisks(String s) {\\n        int res = 0, bars = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'*\\' && bars % 2 == 0)\\n                res++;\\n            if (s.charAt(i) == \\'|\\')\\n                bars++;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int countAsterisks(string s) {\\n        int res = 0, sign = 1;\\n        for (char& c : s)\\n            if ((sign ^= c == \\'|\\') && c == \\'*\\')\\n                res++;\\n        return res;\\n    }\\n```\n```py\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([a.count(\\'*\\') for a in s.split(\\'|\\')][0::2])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2195912,
                "title": "explained-easy-java-solution-o-n",
                "content": "Either character will be inside pipe or not, if it is inside pipe, then it means we have found one pipe and if it is not, so either we have found 0 or even number of pipes. \\nIf we take a boolean and mark it as false initially(As 0 pipes) and then if we are inside pipe (1 pipe), it will mark the boolean opposite, that is true and again when we come out of the pipe it will mark it as false.\\nThis way we will have a check whether we are inside the pipe or not.\\nIf we are not insidePipe, it means insidePipe will be false and if insidePipe is false and s.charAt(i) == asterisk, it means we need to increment the asterisk count.\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean insidePipe = false;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'|\\'){\\n                insidePipe = !insidePipe;\\n            }\\n            if(!insidePipe && s.charAt(i) == \\'*\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nIf you liked the solution or found it easy to understand or found it unique, do upvote :)\\nThankyou\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean insidePipe = false;\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'|\\'){\\n                insidePipe = !insidePipe;\\n            }\\n            if(!insidePipe && s.charAt(i) == \\'*\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195868,
                "title": "two-counters",
                "content": "**C++**\\n```cpp\\nint countAsterisks(string s) {\\n    int res = 0, pipes = 0;\\n    for (auto ch : s) {\\n        pipes += ch == \\'|\\';\\n        res += ch == \\'*\\' && pipes % 2 == 0;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countAsterisks(string s) {\\n    int res = 0, pipes = 0;\\n    for (auto ch : s) {\\n        pipes += ch == \\'|\\';\\n        res += ch == \\'*\\' && pipes % 2 == 0;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2208661,
                "title": "javascript-traffic-light",
                "content": "`\"|\"` is like a **STATE-SWITCHER** (Traffic light), everytime we meet it, we have to change the state.\\n\\n```\\n// o=GREEN light, x=RED light.\\n-o-   --x--   --o--   -x-\\nabc | le*et | c**o* | *de |\\n```\\n\\n```\\nvar countAsterisks = function(s) {\\n    let green=true, count=0;\\n    for(let i=0; i<s.length; i++){\\n        if(green && s[i]==\"*\"){count++};\\n        if(s[i]==\"|\"){green=!green};\\n    }\\n    return count;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n// o=GREEN light, x=RED light.\\n-o-   --x--   --o--   -x-\\nabc | le*et | c**o* | *de |\\n```\n```\\nvar countAsterisks = function(s) {\\n    let green=true, count=0;\\n    for(let i=0; i<s.length; i++){\\n        if(green && s[i]==\"*\"){count++};\\n        if(s[i]==\"|\"){green=!green};\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196109,
                "title": "java-python-3-count-after-bars-reach-even-w-brief-explanation-and-analysis",
                "content": "Traverse input `s` and check the number of bars (`|`), whenever it reaches even numbers, we are outside of the pairs, then count the stars (`*`) in.\\n\\n```java\\n    public int countAsterisks(String s) {\\n        int star = 0;\\n        boolean barEven = true;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == \\'|\\') {\\n                barEven = !barEven;\\n            }else if (c == \\'*\\' && barEven) {\\n                ++star;\\n            }\\n        }\\n        return star;\\n    }\\n```\\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        bar_even, star = True, 0\\n        for c in s:\\n            if c == \\'|\\':\\n                bar_even = not bar_even\\n            elif c == \\'*\\' and bar_even:\\n                star += 1   \\n        return star\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = s.length()`.\\n\\n----\\n\\n1 liners: \\n\\nThe following codes: credit to **@stefan4trivia**\\n\\n```java\\n    public int countAsterisks(String s) {\\n        return s.replaceAll(\"\\\\\\\\|.*?\\\\\\\\||[^*]\", \"\").length();\\n    }\\n```\\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        return re.sub(r\\'\\\\|.*?\\\\|\\', \\'\\', s).count(\\'*\\')\\n```\\n----\\n\\nThe following Py 3 code: credit to **@WilmerKrisp**\\n\\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        return (\\'\\'.join(s.split(\\'|\\')[::2])).count(\\'*\\')\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = s.length()`.\\n\\t",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int countAsterisks(String s) {\\n        int star = 0;\\n        boolean barEven = true;\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c = s.charAt(i);\\n            if (c == \\'|\\') {\\n                barEven = !barEven;\\n            }else if (c == \\'*\\' && barEven) {\\n                ++star;\\n            }\\n        }\\n        return star;\\n    }\\n```\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        bar_even, star = True, 0\\n        for c in s:\\n            if c == \\'|\\':\\n                bar_even = not bar_even\\n            elif c == \\'*\\' and bar_even:\\n                star += 1   \\n        return star\\n```\n```java\\n    public int countAsterisks(String s) {\\n        return s.replaceAll(\"\\\\\\\\|.*?\\\\\\\\||[^*]\", \"\").length();\\n    }\\n```\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        return re.sub(r\\'\\\\|.*?\\\\|\\', \\'\\', s).count(\\'*\\')\\n```\n```python\\n    def countAsterisks(self, s: str) -> int:\\n        return (\\'\\'.join(s.split(\\'|\\')[::2])).count(\\'*\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2220016,
                "title": "python-solution-stack-approach-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        lst=[] \\n        for i in s: \\n            if \\'|\\' not in lst: \\n                lst.append(i) \\n            elif \\'|\\' in lst and i==\\'|\\': \\n                lst.pop() \\n        return lst.count(\\'*\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        lst=[] \\n        for i in s: \\n            if \\'|\\' not in lst: \\n                lst.append(i) \\n            elif \\'|\\' in lst and i==\\'|\\': \\n                lst.pop() \\n        return lst.count(\\'*\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196017,
                "title": "c-easy-to-understand",
                "content": "int countAsterisks(string s) {\\n        \\n        int n=s.length();\\n        if(n==0) return 0;\\n        int cnt=0;\\n        int as=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'|\\'){\\n                 as++;\\n            }\\n            if(as%2==0 && s[i]==\\'*\\'){\\n                cnt++;\\n                                            \\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "int countAsterisks(string s) {\\n        \\n        int n=s.length();\\n        if(n==0) return 0;\\n        int cnt=0;\\n        int as=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'|\\'){\\n                 as++;\\n            }\\n            if(as%2==0 && s[i]==\\'*\\'){\\n                cnt++;\\n                                            \\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3397823,
                "title": "c-and-c-very-easy-solution",
                "content": "![photo_2023-04-09_20-39-59.jpg](https://assets.leetcode.com/users/images/cb3a8249-b67a-40d9-a627-40003e3ac64b_1681054946.6792836.jpeg)\\n![photo_2023-04-09_20-40-05.jpg](https://assets.leetcode.com/users/images/1297e224-4a1c-4589-b920-b838a8053cbc_1681054956.8179479.jpeg)\\n\\n\\n```C# []\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        bool further=false;\\n        int count=0;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]==\\'|\\' && further==false)\\n            further=true;\\n            else if(s[i]==\\'|\\' && further==true)\\n            further=false;\\n            else if(s[i]==\\'*\\' && further==false)\\n            count++;\\n        }\\n        return count;\\n    }// If you find it helpful,please upvote me.\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool further=false;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\' && further==false)\\n            further=true;\\n            else if(s[i]==\\'|\\' && further==true)\\n            further=false;\\n            else if(s[i]==\\'*\\' && further==false)\\n            count++;\\n        }\\n        return count;\\n    }// If you find it helpful,please upvote me.\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "String"
                ],
                "code": "```C# []\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        bool further=false;\\n        int count=0;\\n        for(int i=0;i<s.Length;i++){\\n            if(s[i]==\\'|\\' && further==false)\\n            further=true;\\n            else if(s[i]==\\'|\\' && further==true)\\n            further=false;\\n            else if(s[i]==\\'*\\' && further==false)\\n            count++;\\n        }\\n        return count;\\n    }// If you find it helpful,please upvote me.\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool further=false;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\' && further==false)\\n            further=true;\\n            else if(s[i]==\\'|\\' && further==true)\\n            further=false;\\n            else if(s[i]==\\'*\\' && further==false)\\n            count++;\\n        }\\n        return count;\\n    }// If you find it helpful,please upvote me.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218727,
                "title": "java-linear-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int asteriks = 0;\\n        int lines = 0;\\n        for (char c: s.toCharArray()){\\n            switch (c) {\\n            case \\'*\\': if (lines%2==0)asteriks++; break;\\n            case \\'|\\': lines++; break;\\n            default: break;\\n            }\\n        }\\n        return asteriks;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int asteriks = 0;\\n        int lines = 0;\\n        for (char c: s.toCharArray()){\\n            switch (c) {\\n            case \\'*\\': if (lines%2==0)asteriks++; break;\\n            case \\'|\\': lines++; break;\\n            default: break;\\n            }\\n        }\\n        return asteriks;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196047,
                "title": "java-solution-straightforward-strings",
                "content": "It is said in the question that we don\\'t have to include the * that are present inside the \\'|\\' pairs. So, just checking the pairs of \\'|\\' and ignoring all the elements inside it\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i)==\\'|\\'){\\n\\t\\t\\t//We have found the first \\'|\\' . Now, we will look for another \\'|\\' in the array\\n                int j = i;\\n                while (j<s.length()){\\n                    if (j!=i && s.charAt(j)==\\'|\\'){\\n\\t\\t\\t\\t\\t//When we have found the hole pair, simply return the value of i equal to j and skip the array in between.\\n                        i = j;\\n                        break;//Breaking the loop\\n                    }else{\\n                        j++;//Iterating till we have found \\'|\\'\\n                    }\\n                }\\n            }\\n            if (s.charAt(i) == \\'*\\'){\\n\\t\\t\\t//Checkings for asterisks in the remaining part of the array\\n                ans++;\\n            }\\n        }\\n        return ans;//Returning the ans\\n    }\\n}\\n```\\n\\nThough it contain two loops, each element is iterated once and the i is directly increased to check in the part of the array not inside the pair of \\'|\\'.\\nIf you liked the solution or found it easy to understand or found it unique, do upvote :)\\nThankyou!!",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i)==\\'|\\'){\\n\\t\\t\\t//We have found the first \\'|\\' . Now, we will look for another \\'|\\' in the array\\n                int j = i;\\n                while (j<s.length()){\\n                    if (j!=i && s.charAt(j)==\\'|\\'){\\n\\t\\t\\t\\t\\t//When we have found the hole pair, simply return the value of i equal to j and skip the array in between.\\n                        i = j;\\n                        break;//Breaking the loop\\n                    }else{\\n                        j++;//Iterating till we have found \\'|\\'\\n                    }\\n                }\\n            }\\n            if (s.charAt(i) == \\'*\\'){\\n\\t\\t\\t//Checkings for asterisks in the remaining part of the array\\n                ans++;\\n            }\\n        }\\n        return ans;//Returning the ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195839,
                "title": "c-odd-sequence-easy-to-understand",
                "content": "Approach: We will just cound * for the odd bar string let\\'s say 1,3,5,7...\\nFor example: \\n`\"l|*e*et|c**o|*de|\"`\\nthe odd bar sequence is : 1,3 & inside of that sequence => `l` &` c**o` string exist. so total number of * inside of that string is 2.\\n\\nSimilarly,\\nfor example \\n`\"yo|uar|e**|b|e***au|tifu|l\"`\\nthe odd bar sequence is : 1,3,5,7 & inside of that sequence => `yo` , ` e**` , `e***au` , `l` strings are existing. so total number of * inside of that string is 0+2+3=5.\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt=0,bar=1;\\n        for(auto & ch:s){\\n            if(ch==\\'|\\') bar++; \\n            else if(bar%2==1 && ch==\\'*\\') cnt++; // odd bar, so cnt++\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nP.S: It\\'s took much time to understand the qs clearly during the contest\\n**Upvote if you like it & if you have any doubt feel free to comment**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt=0,bar=1;\\n        for(auto & ch:s){\\n            if(ch==\\'|\\') bar++; \\n            else if(bar%2==1 && ch==\\'*\\') cnt++; // odd bar, so cnt++\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151518,
                "title": "simple-solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int flag = 0;\\n        int counter = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                flag++;\\n            }\\n            if (flag % 2 == 0 && s.charAt(i) == \\'*\\') {\\n                counter++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int flag = 0;\\n        int counter = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                flag++;\\n            }\\n            if (flag % 2 == 0 && s.charAt(i) == \\'*\\') {\\n                counter++;\\n            }\\n        }\\n\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196438,
                "title": "c-with-comments-o-n-solution",
                "content": "```\\n/*\\n1.) Maintain a counter to store the \\'|\\'\\n2.) After every even no. of \\'|\\' count the asteriks. \\n*/\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n\\t\\n\\t int ans=0;\\n\\t \\n\\t// count of no. of \\'|\\'\\n        int cnt=0;\\n\\t\\t\\n        for(int i=0;i<s.size() ;i++) {\\n\\t\\t //if count is even then count the asteriks\\n              if(cnt%2==0) {\\n                  if(s[i]==\\'*\\') ans++;\\n              }\\n              if(s[i]==\\'|\\') cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n1.) Maintain a counter to store the \\'|\\'\\n2.) After every even no. of \\'|\\' count the asteriks. \\n*/\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n\\t\\n\\t int ans=0;\\n\\t \\n\\t// count of no. of \\'|\\'\\n        int cnt=0;\\n\\t\\t\\n        for(int i=0;i<s.size() ;i++) {\\n\\t\\t //if count is even then count the asteriks\\n              if(cnt%2==0) {\\n                  if(s[i]==\\'*\\') ans++;\\n              }\\n              if(s[i]==\\'|\\') cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821546,
                "title": "the-simplest-answer-there-is-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int ig = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'|\\') ig++;\\n            if(ig%2==0){\\n                if(s[i]==\\'*\\') ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int ig = 0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'|\\') ig++;\\n            if(ig%2==0){\\n                if(s[i]==\\'*\\') ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382975,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n\\n    int count_star = 0;\\n    int count_bar = 0;\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (s[i] == \\'|\\')\\n            count_bar++;\\n        if (s[i] == \\'*\\' && count_bar % 2 == 0)\\n            count_star++;\\n    }\\n    return count_star;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n\\n    int count_star = 0;\\n    int count_bar = 0;\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n        if (s[i] == \\'|\\')\\n            count_bar++;\\n        if (s[i] == \\'*\\' && count_bar % 2 == 0)\\n            count_star++;\\n    }\\n    return count_star;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362053,
                "title": "basic-and-easy-approach-cpp-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int flag=0, count=0;\\n        for(char c:s){\\n            if(flag%2==0 && c==\\'*\\'){\\n                count++;\\n            }\\n            else if(c==\\'|\\'){\\n                flag+=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int flag=0, count=0;\\n        for(char c:s){\\n            if(flag%2==0 && c==\\'*\\'){\\n                count++;\\n            }\\n            else if(c==\\'|\\'){\\n                flag+=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334358,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int bar = 0;\\n        int count= 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                bar++;\\n            }\\n            if (bar % 2 == 0 && s.charAt(i) == \\'*\\') {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int bar = 0;\\n        int count= 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'|\\') {\\n                bar++;\\n            }\\n            if (bar % 2 == 0 && s.charAt(i) == \\'*\\') {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294533,
                "title": "java-simple-approach-2ms",
                "content": "# Intuition\\nBrute Force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n       int c=0,count=0;\\n       char ch[]=new char[s.length()];\\n       for(int i=0;i<s.length();i++){\\n           ch[i]=s.charAt(i);\\n           if(ch[i]==\\'|\\')\\n           count++;\\n           if((ch[i]==42||ch[i]==\\'*\\')&&(count%2==0))\\n           c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n       int c=0,count=0;\\n       char ch[]=new char[s.length()];\\n       for(int i=0;i<s.length();i++){\\n           ch[i]=s.charAt(i);\\n           if(ch[i]==\\'|\\')\\n           count++;\\n           if((ch[i]==42||ch[i]==\\'*\\')&&(count%2==0))\\n           c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219947,
                "title": "python-o-n",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        ans,t = 0,0\\n        for i in s:\\n            if i == \"|\":\\n                t += 1\\n            elif t % 2 ==0:\\n                ans += i==\"*\"\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        ans,t = 0,0\\n        for i in s:\\n            if i == \"|\":\\n                t += 1\\n            elif t % 2 ==0:\\n                ans += i==\"*\"\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098928,
                "title": "c-beats-100",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a flag that keeps track of braces.\\nif flag == -1 implies we are out of braces. we can count here.\\nif flag==1 implies we are inside braces. we cannot count here.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int flag=-1,count=0;\\n        for(char c:s){\\n            if(c==\\'|\\') ((flag)*=(-1));\\n            if(flag==-1 && c==\\'*\\') count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int flag=-1,count=0;\\n        for(char c:s){\\n            if(c==\\'|\\') ((flag)*=(-1));\\n            if(flag==-1 && c==\\'*\\') count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830563,
                "title": "fast-and-easy-java-soln-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the whole string char by char and check the required condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to count * after every even bar\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int bar=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'|\\') bar++;\\n            if(bar%2==0){\\n                if(ch==\\'*\\') count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int bar=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(ch==\\'|\\') bar++;\\n            if(bar%2==0){\\n                if(ch==\\'*\\') count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814179,
                "title": "c-beginner-solution",
                "content": "\\n# Approach\\nCount the number of pipes if these are even then count the asterisks .\\n\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0,orcnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             if(s[i]==\\'|\\')\\n            orcnt++;\\n            if(orcnt%2==0)\\n            {\\n            if(s[i]==\\'*\\')\\n            count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0,orcnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n             if(s[i]==\\'|\\')\\n            orcnt++;\\n            if(orcnt%2==0)\\n            {\\n            if(s[i]==\\'*\\')\\n            count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686424,
                "title": "java-1-ms-simple-solution",
                "content": "Time Complexity : O(n)\\nSpace Complexity : O(1)\\n``` \\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean flag = true;\\n        int count = 0;\\n        \\n        for(char ch : s.toCharArray()){\\n            if(ch == \\'*\\' && flag){\\n                count += 1;\\n                continue;\\n            }\\n            if(ch == \\'|\\') flag = !flag;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "``` \\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean flag = true;\\n        int count = 0;\\n        \\n        for(char ch : s.toCharArray()){\\n            if(ch == \\'*\\' && flag){\\n                count += 1;\\n                continue;\\n            }\\n            if(ch == \\'|\\') flag = !flag;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667302,
                "title": "simple-and-easy-js-solution",
                "content": "var countAsterisks = function(s) {\\n    let flag = true,\\n  count = 0;\\nfor (let i = 0; i < s.length; i++) {\\n  if (s[i] == \"|\") {\\n    flag = !flag;\\n  }\\n  if (flag) {\\n    if (s[i] == \"*\") count++;\\n  }\\n}\\n    return count\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var countAsterisks = function(s) {\\n    let flag = true,\\n  count = 0;\\nfor (let i = 0; i < s.length; i++) {\\n  if (s[i] == \"|\") {\\n    flag = !flag;\\n  }\\n  if (flag) {\\n    if (s[i] == \"*\") count++;\\n  }\\n}\\n    return count\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2616225,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity: O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int pair=0, count=0;\\n        for(int c: s.toCharArray()){\\n            if(c == \\'|\\')    pair++;\\n            if(pair % 2 == 0 && c == \\'*\\')    count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar countAsterisks = function(s) {\\n    let pair=0, count=0;\\n    for(let c of s){\\n        if(c == \\'|\\')    pair++;\\n        if(pair % 2 == 0 && c == \\'*\\')    count++;\\n    }\\n    return count;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def countAsterisks(self, s):\\n        pair = count = 0;\\n        for c in s:\\n            if c == \\'|\\':\\n                pair += 1\\n            if pair % 2 == 0 and c == \\'*\\':\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int pair=0, count=0;\\n        for(int c: s.toCharArray()){\\n            if(c == \\'|\\')    pair++;\\n            if(pair % 2 == 0 && c == \\'*\\')    count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar countAsterisks = function(s) {\\n    let pair=0, count=0;\\n    for(let c of s){\\n        if(c == \\'|\\')    pair++;\\n        if(pair % 2 == 0 && c == \\'*\\')    count++;\\n    }\\n    return count;\\n};\\n```\n```\\nclass Solution(object):\\n    def countAsterisks(self, s):\\n        pair = count = 0;\\n        for c in s:\\n            if c == \\'|\\':\\n                pair += 1\\n            if pair % 2 == 0 and c == \\'*\\':\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484633,
                "title": "python-elegant-short-two-solutions-one-pass-one-line",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\tis_closed = True\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\tfor c in s:\\n\\t\\t\\t\\tcount += is_closed * c == \\'*\\'\\n\\t\\t\\t\\tis_closed ^= c == \\'|\\'\\n\\n\\t\\t\\treturn count\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\treturn sum(chunk.count(\\'*\\') for chunk in s.split(\\'|\\')[0::2])\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\tis_closed = True\\n\\t\\t\\tcount = 0\\n\\n\\t\\t\\tfor c in s:\\n\\t\\t\\t\\tcount += is_closed * c == \\'*\\'\\n\\t\\t\\t\\tis_closed ^= c == \\'|\\'\\n\\n\\t\\t\\treturn count\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\treturn sum(chunk.count(\\'*\\') for chunk in s.split(\\'|\\')[0::2])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2272171,
                "title": "go-xor",
                "content": "```\\nfunc countAsterisks(s string) int {\\n    res, pipe := 0, 0\\n    \\n    for _, v := range s {\\n        if v == \\'|\\' {\\n            pipe ^= 1\\n        }\\n        \\n        if v == \\'*\\' && pipe == 0 {\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countAsterisks(s string) int {\\n    res, pipe := 0, 0\\n    \\n    for _, v := range s {\\n        if v == \\'|\\' {\\n            pipe ^= 1\\n        }\\n        \\n        if v == \\'*\\' && pipe == 0 {\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196900,
                "title": "python-straightforward-count-t-m-100-58",
                "content": "Iterate through the string and toggle a boolean switch each time a \"|\" is encountered. Count the asterisks when the switch is on and skip over the asterisks when the switch is off. The initial state of the switch is on.\\n```\\nclass Solution: \\n    def countAsterisks(self, s: str) -> int:\\n        ans, switch = 0, True\\n\\n        for i in range(len(s)):\\n            if s[i] == \\'|\\': \\n\\t\\t\\t\\tswitch^= True \\n            elif switch and s[i] == \\'*\\':\\n\\t\\t\\t\\tans+= 1\\n\\n        return ans",
                "solutionTags": [],
                "code": "Iterate through the string and toggle a boolean switch each time a \"|\" is encountered. Count the asterisks when the switch is on and skip over the asterisks when the switch is off. The initial state of the switch is on.\\n```\\nclass Solution: \\n    def countAsterisks(self, s: str) -> int:\\n        ans, switch = 0, True\\n\\n        for i in range(len(s)):\\n            if s[i] == \\'|\\': \\n\\t\\t\\t\\tswitch^= True \\n            elif switch and s[i] == \\'*\\':\\n\\t\\t\\t\\tans+= 1\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2196026,
                "title": "simple-string-traversal-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int brc=0,c=0,mcm=0;\\n        for(char it:s){\\n            if(it==\\'|\\' and brc==0){\\n                brc=1;\\n                mcm += c;\\n                c=0;\\n            }            \\n            else if(it==\\'|\\' and brc==1) {\\n                brc=0;\\n            }\\n            else if(it==\\'*\\' and brc==0){\\n                c++;\\n            }\\n        }\\n        mcm+=c;\\n        return mcm;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int brc=0,c=0,mcm=0;\\n        for(char it:s){\\n            if(it==\\'|\\' and brc==0){\\n                brc=1;\\n                mcm += c;\\n                c=0;\\n            }            \\n            else if(it==\\'|\\' and brc==1) {\\n                brc=0;\\n            }\\n            else if(it==\\'*\\' and brc==0){\\n                c++;\\n            }\\n        }\\n        mcm+=c;\\n        return mcm;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195817,
                "title": "java-straightforward",
                "content": "```\\nclass Solution\\n{\\n    public int countAsterisks(String s)\\n    {\\n        int count = 0, ret = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'*\\')\\n                if(count % 2 == 0)\\n                    ret++;\\n            if(ch == \\'|\\')\\n                count++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countAsterisks(String s)\\n    {\\n        int count = 0, ret = 0;\\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'*\\')\\n                if(count % 2 == 0)\\n                    ret++;\\n            if(ch == \\'|\\')\\n                count++;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769859,
                "title": "easy-python-solution-using-flag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the string and whenever \\'|\\' encounter in string reverse the flag value. And If the flag value is Flase i only count those \\'*\\'.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        c=0\\n        flag=False\\n        for i in s:\\n            if (i==\\'|\\'):\\n                flag=not(flag)\\n            if(i==\\'*\\' and flag==False):\\n                c=c+1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        c=0\\n        flag=False\\n        for i in s:\\n            if (i==\\'|\\'):\\n                flag=not(flag)\\n            if(i==\\'*\\' and flag==False):\\n                c=c+1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566937,
                "title": "simple-java-solution-for-beginners-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int barCount = 0;\\n        int asteriskCount = 0;\\n        for(char ch : s.toCharArray()) {\\n            barCount += ch == \\'|\\' ? 1 : 0;\\n            asteriskCount += barCount == 0 && ch == \\'*\\' ? 1 : 0;\\n            barCount = barCount == 2 ? 0 : barCount;\\n        }\\n        return asteriskCount;\\n    }\\n}\\n// ************Explanation************\\n// class Solution {\\n//     public int countAsterisks(String s) {\\n//         int barCount = 0;\\n//         int asteriskCount = 0;\\n//         for(char ch : s.toCharArray()) {\\n//             if(ch == \\'|\\') {\\n//                 barCount++;\\n//             }\\n//             if(barCount == 0 && ch == \\'*\\') {\\n//                 asteriskCount++;\\n//             }\\n//             if(barCount == 2) {\\n//                 barCount = 0;\\n//             }\\n//         }\\n//         return asteriskCount;\\n//     }\\n// }\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int barCount = 0;\\n        int asteriskCount = 0;\\n        for(char ch : s.toCharArray()) {\\n            barCount += ch == \\'|\\' ? 1 : 0;\\n            asteriskCount += barCount == 0 && ch == \\'*\\' ? 1 : 0;\\n            barCount = barCount == 2 ? 0 : barCount;\\n        }\\n        return asteriskCount;\\n    }\\n}\\n// ************Explanation************\\n// class Solution {\\n//     public int countAsterisks(String s) {\\n//         int barCount = 0;\\n//         int asteriskCount = 0;\\n//         for(char ch : s.toCharArray()) {\\n//             if(ch == \\'|\\') {\\n//                 barCount++;\\n//             }\\n//             if(barCount == 0 && ch == \\'*\\') {\\n//                 asteriskCount++;\\n//             }\\n//             if(barCount == 2) {\\n//                 barCount = 0;\\n//             }\\n//         }\\n//         return asteriskCount;\\n//     }\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264756,
                "title": "5-liner-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0;\\n        int bracket = 0;\\n        for(int i=0;i<s.size();++i){\\n            if(s[i]==\\'|\\'){\\n                bracket++;\\n            }\\n            if( bracket%2==0 && s[i]==\\'*\\'){\\n                count++;\\n            }\\n    \\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0;\\n        int bracket = 0;\\n        for(int i=0;i<s.size();++i){\\n            if(s[i]==\\'|\\'){\\n                bracket++;\\n            }\\n            if( bracket%2==0 && s[i]==\\'*\\'){\\n                count++;\\n            }\\n    \\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130279,
                "title": "simple-easy-to-understand-runtime-0ms-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreated a flag variable called ***open*** through which the code decides whether to count the asterisk or not.\\n\\n***open*** is initially **true** and is closed when the loop enocounters firs **\\'|\\'**. \\nWe don\\'t count any asterisk when the ***open*** is **false**.\\n***open*** is set to **true** again when it encounters next **\\'|\\'**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0, n = s.size();\\n        bool open = true;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(open == true && s[i] == \\'*\\')\\n                count++;\\n\\n            if(s[i] == \\'|\\' && open == true)\\n                open = false;\\n            else if(s[i] == \\'|\\' && open == false)\\n                open = true;\\n            continue;\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0, n = s.size();\\n        bool open = true;\\n\\n        for(int i = 0; i < n; i++){\\n\\n            if(open == true && s[i] == \\'*\\')\\n                count++;\\n\\n            if(s[i] == \\'|\\' && open == true)\\n                open = false;\\n            else if(s[i] == \\'|\\' && open == false)\\n                open = true;\\n            continue;\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054882,
                "title": "100-easy-c-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int bar = 0,count=0;\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(bar%2 == 0 && s[i] == \\'*\\')\\n                count++;\\n            if(s[i] == \\'|\\')\\n                bar++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int bar = 0,count=0;\\n        for(int i = 0; i < s.size();i++)\\n        {\\n            if(bar%2 == 0 && s[i] == \\'*\\')\\n                count++;\\n            if(s[i] == \\'|\\')\\n                bar++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986224,
                "title": "easy-c-single-pass-0ms-o-n",
                "content": "# Time complexity \\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int barbel=0;\\n        int cnt_Asterisks=0;\\n        for(int i=0;i<s.size();++i){\\n            if(barbel%2==0 && s[i]==\\'*\\'){\\n// checking the number of the barbel should be odd means we can count the \\'*\\' between them \\n                cnt_Asterisks++;\\n            }\\n            if(s[i]==\\'|\\'){\\n// barbell counter\\n                barbel++;\\n            }\\n        }\\n        return cnt_Asterisks;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int barbel=0;\\n        int cnt_Asterisks=0;\\n        for(int i=0;i<s.size();++i){\\n            if(barbel%2==0 && s[i]==\\'*\\'){\\n// checking the number of the barbel should be odd means we can count the \\'*\\' between them \\n                cnt_Asterisks++;\\n            }\\n            if(s[i]==\\'|\\'){\\n// barbell counter\\n                barbel++;\\n            }\\n        }\\n        return cnt_Asterisks;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876898,
                "title": "100-beats-java-using-stack",
                "content": "<h1> Please UpVote :\\') \\uD83E\\uDEE1</h1>\\n<h1 style = \"font-weight = 100px\"># Intuition</h1>\\nJava Using Stack\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n```Push every first | and pop every second | then if it is closed then only count``` \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- ```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int countAsterisks(String s) \\n    {\\n        int count = 0 ;\\n        Stack<Character> stack = new Stack<>(); \\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'|\\') \\n            {\\n                if(stack.isEmpty()) // if Reading First \\'|\\' then push\\n                {\\n                    stack.push(\\'|\\');\\n                }\\n                else // if reading second \\'|\\' then pop\\n                {\\n                    stack.pop(); \\n                }\\n            }\\n            else\\n            {\\n                if(ch == \\'*\\' && stack.isEmpty()) // if no | is open then count * \\n                {\\n                    count++ ;\\n                }\\n                else  // else continue to run...     Please UpVote :)\\n                    continue ;\\n            }\\n        }\\n        return count ; // returning the count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Push every first | and pop every second | then if it is closed then only count```\n```O(n)```\n```O(n)```\n```\\nclass Solution\\n{\\n    public int countAsterisks(String s) \\n    {\\n        int count = 0 ;\\n        Stack<Character> stack = new Stack<>(); \\n        for(char ch : s.toCharArray())\\n        {\\n            if(ch == \\'|\\') \\n            {\\n                if(stack.isEmpty()) // if Reading First \\'|\\' then push\\n                {\\n                    stack.push(\\'|\\');\\n                }\\n                else // if reading second \\'|\\' then pop\\n                {\\n                    stack.pop(); \\n                }\\n            }\\n            else\\n            {\\n                if(ch == \\'*\\' && stack.isEmpty()) // if no | is open then count * \\n                {\\n                    count++ ;\\n                }\\n                else  // else continue to run...     Please UpVote :)\\n                    continue ;\\n            }\\n        }\\n        return count ; // returning the count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860173,
                "title": "java-best-optimal-soln",
                "content": "class Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int bars=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'*\\' && bars%2==0){\\n                count+=1;\\n            }\\n            if(s.charAt(i)==\\'|\\'){\\n                bars+=1;\\n                \\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int bars=0;\\n        for (int i=0;i<s.length();i++){\\n            if (s.charAt(i)==\\'*\\' && bars%2==0){\\n                count+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2831596,
                "title": "python3-solution-using-for-loop-and-continue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo ignore the characters in between a pair of ```|```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a ```for``` loop and ```continue``` to skip the characters in between a pair of ```|```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are iterating the string once\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nA new list is created\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        l = []\\n        temp = \\'\\'\\n        for i in s:\\n            if i == \\'|\\':\\n                temp += i\\n                # reset the temp, if a pair is closed\\n                if temp.count(\\'|\\') == 2:\\n                    temp = \\'\\'\\n            # ignore the characters in between a pair\\n            if \\'|\\' in temp:\\n                continue\\n            # if none of the above conditions are met append the character into the list\\n            elif i != \\'|\\':\\n                l.append(i)\\n        return \\'\\'.join(l).count(\\'*\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```|```\n```for```\n```continue```\n```|```\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        l = []\\n        temp = \\'\\'\\n        for i in s:\\n            if i == \\'|\\':\\n                temp += i\\n                # reset the temp, if a pair is closed\\n                if temp.count(\\'|\\') == 2:\\n                    temp = \\'\\'\\n            # ignore the characters in between a pair\\n            if \\'|\\' in temp:\\n                continue\\n            # if none of the above conditions are met append the character into the list\\n            elif i != \\'|\\':\\n                l.append(i)\\n        return \\'\\'.join(l).count(\\'*\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766976,
                "title": "java-straight-forward-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n      int bars = 0, ans = 0;\\n      for(int i = 0; i < s.length(); ++ i) {\\n          if(s.charAt(i) == \\'*\\' && bars % 2 == 0)\\n          ans ++;\\n          \\n          if(s.charAt(i) == \\'|\\')\\n          bars ++;\\n      } \\n      return ans; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n      int bars = 0, ans = 0;\\n      for(int i = 0; i < s.length(); ++ i) {\\n          if(s.charAt(i) == \\'*\\' && bars % 2 == 0)\\n          ans ++;\\n          \\n          if(s.charAt(i) == \\'|\\')\\n          bars ++;\\n      } \\n      return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591472,
                "title": "simple-one-pass-c-solution",
                "content": "O(n) time complexity C++ code:\\n```\\nint countAsterisks(string s) {\\n\\tbool ignore = false;\\n\\tint count = 0;\\n\\tfor(int i = 0; i < s.length(); i++){\\n\\t\\tswitch(s[i]){\\n\\t\\t\\tcase \\'|\\':\\n\\t\\t\\t\\tignore = not ignore;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'*\\':\\n\\t\\t\\t\\tif(not ignore){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countAsterisks(string s) {\\n\\tbool ignore = false;\\n\\tint count = 0;\\n\\tfor(int i = 0; i < s.length(); i++){\\n\\t\\tswitch(s[i]){\\n\\t\\t\\tcase \\'|\\':\\n\\t\\t\\t\\tignore = not ignore;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'*\\':\\n\\t\\t\\t\\tif(not ignore){\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484191,
                "title": "100-faster-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int check=1,count=0;\\n        for(char c:s.toCharArray()){\\n            if(check==1 && c==\\'*\\')count++;\\n            else if(check==1&& c==\\'|\\')check=0;\\n            else if(check==0&& c==\\'|\\')check=1;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int check=1,count=0;\\n        for(char c:s.toCharArray()){\\n            if(check==1 && c==\\'*\\')count++;\\n            else if(check==1&& c==\\'|\\')check=0;\\n            else if(check==0&& c==\\'|\\')check=1;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455815,
                "title": "python-easy-and-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\tif \\'*\\' not in s:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tbars=0\\n\\t\\t\\t\\tfor i in range(0,len(s)):\\n\\t\\t\\t\\t\\tif s[i]==\"|\":\\n\\t\\t\\t\\t\\t\\tbars=bars+1\\n\\t\\t\\t\\t\\tif bars%2==0 and s[i]==\"*\":\\n\\t\\t\\t\\t\\t\\tc=c+1\\n\\t\\t\\t\\treturn c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef countAsterisks(self, s: str) -> int:\\n\\t\\t\\tif \\'*\\' not in s:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\tc=0\\n\\t\\t\\t\\tbars=0\\n\\t\\t\\t\\tfor i in range(0,len(s)):\\n\\t\\t\\t\\t\\tif s[i]==\"|\":\\n\\t\\t\\t\\t\\t\\tbars=bars+1\\n\\t\\t\\t\\t\\tif bars%2==0 and s[i]==\"*\":\\n\\t\\t\\t\\t\\t\\tc=c+1\\n\\t\\t\\t\\treturn c",
                "codeTag": "Java"
            },
            {
                "id": 2365051,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = s => s.split(`|`).filter((w, i) => w.includes(`*`) && i % 2 === 0).reduce((count, w) => count + w.replaceAll(/\\\\w*/g, ``).length, 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = s => s.split(`|`).filter((w, i) => w.includes(`*`) && i % 2 === 0).reduce((count, w) => count + w.replaceAll(/\\\\w*/g, ``).length, 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332609,
                "title": "python-o-n-o-1-runtime-47ms-64-61-memory-13-7mb-97-39",
                "content": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 47ms 64.61% || Memory: 13.7mb 97.39%\\n    def countAsterisks(self, string: str) -> int:\\n        if not string:\\n            return 0\\n\\n        isBetweenBar = False\\n\\n        asteriskCount = 0\\n\\n        for char in string:\\n            if char == \\'|\\' and not isBetweenBar:\\n                isBetweenBar = True\\n\\n            elif char == \\'|\\' and isBetweenBar:\\n                isBetweenBar = False\\n\\n            if not isBetweenBar and char == \\'*\\':\\n                asteriskCount += 1\\n\\n        return asteriskCount\\n```\\nbe a part of it https://github.com/ArshErgon/Leetcode-Question-In-Python",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 47ms 64.61% || Memory: 13.7mb 97.39%\\n    def countAsterisks(self, string: str) -> int:\\n        if not string:\\n            return 0\\n\\n        isBetweenBar = False\\n\\n        asteriskCount = 0\\n\\n        for char in string:\\n            if char == \\'|\\' and not isBetweenBar:\\n                isBetweenBar = True\\n\\n            elif char == \\'|\\' and isBetweenBar:\\n                isBetweenBar = False\\n\\n            if not isBetweenBar and char == \\'*\\':\\n                asteriskCount += 1\\n\\n        return asteriskCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274572,
                "title": "one-line-javascript-solution-with-81-faster",
                "content": "Runtime: 74 ms, faster than 81.76% of JavaScript online submissions for Count Asterisks.\\n\\nconst countAsterisks = (s) => {\\n  return s\\n    .split(\"|\")\\n    .filter((_, i) => i % 2 === 0)\\n    .join(\"\")\\n    .replace(/[a-z]/g, \"\").length;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Runtime: 74 ms, faster than 81.76% of JavaScript online submissions for Count Asterisks.\\n\\nconst countAsterisks = (s) => {\\n  return s\\n    .split(\"|\")\\n    .filter((_, i) => i % 2 === 0)\\n    .join(\"\")\\n    .replace(/[a-z]/g, \"\").length;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2260229,
                "title": "go-python-c-one-loop-2-ifs-w-comments",
                "content": "<iframe src=\"https://leetcode.com/playground/jTrbcupH/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/jTrbcupH/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2237404,
                "title": "my-java-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        int res = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c == \\'|\\')\\n            {\\n                count++;\\n            }\\n            if(count == 2)\\n            {\\n                count = 0;\\n            }\\n            if(count == 0)\\n            {\\n                if(c == \\'*\\')\\n                {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        int res = 0;\\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c == \\'|\\')\\n            {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2226103,
                "title": "o-n-java-solution-simple",
                "content": "```\\n\\tpublic int countAsterisks(String s) {\\n        \\n        int pipe = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            char c = s.charAt(i);\\n            \\n            if(c == \\'|\\') pipe += 1;\\n            else if (c == \\'*\\' && (pipe % 2 == 0)) count += 1;\\n            \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int countAsterisks(String s) {\\n        \\n        int pipe = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            char c = s.charAt(i);\\n            \\n            if(c == \\'|\\') pipe += 1;\\n            else if (c == \\'*\\' && (pipe % 2 == 0)) count += 1;\\n            \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200493,
                "title": "rust-one-liner",
                "content": "Two similar versions\\n```\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        s.split(\\'|\\')\\n            .enumerate()\\n            .filter(|&(i, _)| i % 2 == 0)\\n            .flat_map(|(_, s)| s.chars())\\n            .filter(|&c| c == \\'*\\')\\n            .count() as _\\n    }\\n}\\n```\\n\\n```\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        s.split(\\'|\\')\\n            .enumerate()\\n            .filter_map(|(i, s)| if i % 2 == 0 { Some(s.chars()) } else { None })\\n            .flatten()\\n            .filter(|&c| c == \\'*\\')\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        s.split(\\'|\\')\\n            .enumerate()\\n            .filter(|&(i, _)| i % 2 == 0)\\n            .flat_map(|(_, s)| s.chars())\\n            .filter(|&c| c == \\'*\\')\\n            .count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        s.split(\\'|\\')\\n            .enumerate()\\n            .filter_map(|(i, s)| if i % 2 == 0 { Some(s.chars()) } else { None })\\n            .flatten()\\n            .filter(|&c| c == \\'*\\')\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197492,
                "title": "javascript-count",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function (s) {\\n  let asterisks = 0;\\n  s.split(\\'|\\').forEach((sub, i) => {\\n    if (i % 2 === 0) {\\n      asterisks += sub.split(\\'\\').filter((c) => c === \\'*\\').length;\\n    }\\n  });\\n  \\n  return asterisks;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function (s) {\\n  let asterisks = 0;\\n  s.split(\\'|\\').forEach((sub, i) => {\\n    if (i % 2 === 0) {\\n      asterisks += sub.split(\\'\\').filter((c) => c === \\'*\\').length;\\n    }\\n  });\\n  \\n  return asterisks;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196884,
                "title": "two-pointer-0-ms-faster-than-100-00-of-c-simple",
                "content": "Runtime: 0 ms, faster than 100.00% of C++\\n\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int n=s.size();\\n        int cnt=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n             if(s[i]==\\'|\\') temp+=1;\\n             if(s[i]==\\'*\\' && temp%2==0) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int n=s.size();\\n        int cnt=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n             if(s[i]==\\'|\\') temp+=1;\\n             if(s[i]==\\'*\\' && temp%2==0) cnt+=1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196237,
                "title": "java-2-simple-approaches-beats-100",
                "content": "**Approach 1: Somewhat slower:**\\n ```\\n class Solution {\\n    public int countAsterisks(String s) {\\n        boolean bar = false;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n           if(bar && s.charAt(i)==\\'|\\') \\n\\t\\t       bar = false;\\n            \\n\\t\\t\\telse if(!bar){\\n               if(s.charAt(i)==\\'*\\')\\n                  count++;\\n            \\n               else if(s.charAt(i)==\\'|\\') \\n\\t\\t\\t          bar = true;\\n            }\\n         }\\n        return count;\\n    }\\n}\\n\\n ```\\n \\n **Approach 2: Using 2 counter/pointers || Beats 100%**\\n ```\\n class Solution{\\n   public int countAsterisks(String s){\\n       int  ast = 0,count = 0;\\n       for(char c : s.toCharArray()){\\n           if(c == \\'*\\')  \\n   \\t\\t    if(count % 2 == 0)\\n                    ast++;\\n           \\n            if(c == \\'|\\')\\n                   count++;\\n   }\\n       return ast;\\n   }\\n}\\n\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    public int countAsterisks(String s) {\\n        boolean bar = false;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n           if(bar && s.charAt(i)==\\'|\\') \\n\\t\\t       bar = false;\\n            \\n\\t\\t\\telse if(!bar){\\n               if(s.charAt(i)==\\'*\\')\\n                  count++;\\n            \\n               else if(s.charAt(i)==\\'|\\') \\n\\t\\t\\t          bar = true;\\n            }\\n         }\\n        return count;\\n    }\\n}\\n\\n ```\n```\\n class Solution{\\n   public int countAsterisks(String s){\\n       int  ast = 0,count = 0;\\n       for(char c : s.toCharArray()){\\n           if(c == \\'*\\')  \\n   \\t\\t    if(count % 2 == 0)\\n                    ast++;\\n           \\n            if(c == \\'|\\')\\n                   count++;\\n   }\\n       return ast;\\n   }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2196191,
                "title": "2315-count-asterisks-single-pointer",
                "content": "```\\n/*cnt for | get inc by  1 if cnt ==2 the we get cage | |\\nif cage starts means cnt==1 no count..\\ncount only if cnt=0 means no cage or cage is closed!*/\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        char ch[]=s.toCharArray();\\n        int cnt=0,ast=0;\\n        for(char c:ch){\\n            if(cnt==0&&c==\\'*\\')\\n                ast++;\\n            if(c==\\'|\\'){\\n                cnt++;\\n            }\\n            if(cnt==2) cnt=0;\\n        }\\n        return ast;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n/*cnt for | get inc by  1 if cnt ==2 the we get cage | |\\nif cage starts means cnt==1 no count..\\ncount only if cnt=0 means no cage or cage is closed!*/\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        char ch[]=s.toCharArray();\\n        int cnt=0,ast=0;\\n        for(char c:ch){\\n            if(cnt==0&&c==\\'*\\')\\n                ast++;\\n            if(c==\\'|\\'){\\n                cnt++;\\n            }\\n            if(cnt==2) cnt=0;\\n        }\\n        return ast;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196174,
                "title": "c-count",
                "content": "**Approach:**\\nJust count in odd bar (\\'|\\') element start (`*`)\\n\\n**Time:** `O(N), N = Length of s`\\n**Space:** `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool flag = true;\\n        int count = 0;\\n        for(auto c : s){\\n            if(c ==\\'|\\') flag = !flag;\\n            if(flag && c == \\'*\\') count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool flag = true;\\n        int count = 0;\\n        for(auto c : s){\\n            if(c ==\\'|\\') flag = !flag;\\n            if(flag && c == \\'*\\') count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196089,
                "title": "python3-solution-o-n",
                "content": "```Time``` : ```O(n)```\\n```Space``` : ```O(1)```\\n\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        res, flag = 0, True\\n        for i in s:\\n            if i == \\'|\\':\\n                flag = not flag\\n            if flag and i == \\'*\\':\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Time```\n```O(n)```\n```Space```\n```O(1)```\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        res, flag = 0, True\\n        for i in s:\\n            if i == \\'|\\':\\n                flag = not flag\\n            if flag and i == \\'*\\':\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195987,
                "title": "java-solution-simple-o-n-solution",
                "content": "\\n\\t\\n\\tclass Solution {\\n    public int countAsterisks(String s) {\\n        \\n        char st[]=s.toCharArray();\\n        int bar=0;\\n        int count=0;\\n        for(char ch:st){\\n            if(ch==\\'|\\') // count the number of \\'|\\' faced so far\\n                bar++;\\n            // if current character is in between two pairs of \\'|\\' , such that it is in between (2,3) or (4,5) , then we count the # of \\'*\\' in between those \\'|\\'\\n            else if(ch==\\'*\\' && bar%2==0) \\n                count++;\\n        }\\n        return count; \\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        \\n        char st[]=s.toCharArray();\\n        int bar=0;\\n        int count=0;\\n        for(char ch:st){\\n            if(ch==\\'|\\') // count the number of \\'|\\' faced so far\\n                bar++;\\n            // if current character is in between two pairs of \\'|\\' , such that it is in between (2,3) or (4,5) , then we count the # of \\'*\\' in between those \\'|\\'\\n            else if(ch==\\'*\\' && bar%2==0) \\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2195901,
                "title": "java-intuition-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm:\\n     *  1. Iterate over each character of string and keep a state boolean to determine if you\\'re in a pair or outside pair\\n     *  2. If current char is asterisk and outside pair, then increment the general counter\\n     */\\n    public int countAsterisks(String s) {\\n        boolean pairMode = false;\\n        int asterisks = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'|\\') {\\n                pairMode = !pairMode;\\n            } else if (c == \\'*\\') {\\n                asterisks += (pairMode ? 0 : 1);\\n            }\\n        }\\n        return asterisks;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm:\\n     *  1. Iterate over each character of string and keep a state boolean to determine if you\\'re in a pair or outside pair\\n     *  2. If current char is asterisk and outside pair, then increment the general counter\\n     */\\n    public int countAsterisks(String s) {\\n        boolean pairMode = false;\\n        int asterisks = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'|\\') {\\n                pairMode = !pairMode;\\n            } else if (c == \\'*\\') {\\n                asterisks += (pairMode ? 0 : 1);\\n            }\\n        }\\n        return asterisks;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906148,
                "title": "cursed-c-one-liner",
                "content": "\\uD83D\\uDE28\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt{}, i{}; for (; i < size(s); ++i) if (s[i] == \\'|\\') while (i < size(s) && s[++i] ^ \\'|\\') {} else cnt += !(s[i] ^ \\'*\\'); return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt{}, i{}; for (; i < size(s); ++i) if (s[i] == \\'|\\') while (i < size(s) && s[++i] ^ \\'|\\') {} else cnt += !(s[i] ^ \\'*\\'); return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848316,
                "title": "java-2-approach-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0 , count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'|\\') count++;\\n            if(count%2==0){\\n                if(c == \\'*\\') ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n//        Another solution using stack\\n\\n        // int ans = 0 ;\\n        // Stack<Character> stack = new Stack<>(); \\n        // for(char i : s.toCharArray()) {\\n        //     if(i == \\'|\\') {\\n        //         if(stack.isEmpty()) stack.push(\\'|\\');\\n        //         else stack.pop();\\n        //     }\\n        //     else {\\n        //         if(i == \\'*\\' && stack.isEmpty()) ans++ ;\\n        //         else  continue ;\\n        //     }\\n        // }\\n        // return ans; \\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0 , count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'|\\') count++;\\n            if(count%2==0){\\n                if(c == \\'*\\') ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n//        Another solution using stack\\n\\n        // int ans = 0 ;\\n        // Stack<Character> stack = new Stack<>(); \\n        // for(char i : s.toCharArray()) {\\n        //     if(i == \\'|\\') {\\n        //         if(stack.isEmpty()) stack.push(\\'|\\');\\n        //         else stack.pop();\\n        //     }\\n        //     else {\\n        //         if(i == \\'*\\' && stack.isEmpty()) ans++ ;\\n        //         else  continue ;\\n        //     }\\n        // }\\n        // return ans; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732676,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                count++;\\n            }\\n            if(count%2==0 && s.charAt(i)==\\'*\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                count++;\\n            }\\n            if(count%2==0 && s.charAt(i)==\\'*\\'){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618956,
                "title": "simple-java-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int pipe=0;\\n        int asterisk=0;\\n        for(char ch : s.toCharArray()){\\n            if(ch==\\'|\\'){\\n                pipe++;\\n            }\\n            if(pipe%2==0){\\n                if(ch==\\'*\\')\\n                asterisk++;\\n            }\\n        }\\n        return asterisk;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int pipe=0;\\n        int asterisk=0;\\n        for(char ch : s.toCharArray()){\\n            if(ch==\\'|\\'){\\n                pipe++;\\n            }\\n            if(pipe%2==0){\\n                if(ch==\\'*\\')\\n                asterisk++;\\n            }\\n        }\\n        return asterisk;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543387,
                "title": "o-n-count-asterisks-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int i, lines=0, count=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'*\\' && lines==0)\\n            {\\n                count++;\\n            }\\n            else if(s[i]==\\'|\\' && lines==0)\\n            {\\n                lines=1;\\n            }\\n            else if(s[i]==\\'|\\' && lines==1)\\n            {\\n                lines=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/004c5282-c0a9-488a-88da-135323c86323_1684553476.1270168.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int i, lines=0, count=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'*\\' && lines==0)\\n            {\\n                count++;\\n            }\\n            else if(s[i]==\\'|\\' && lines==0)\\n            {\\n                lines=1;\\n            }\\n            else if(s[i]==\\'|\\' && lines==1)\\n            {\\n                lines=0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389707,
                "title": "javascript-solution-using-two-counters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n# Approach 1\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function(s) {\\n    let starCount = 0;\\n    let barCount = 0;\\n\\n    for(let i = 0; i < s.length; i++) {\\n        if(barCount === 0 && s[i] === \\'*\\') {\\n            starCount++;\\n        } else if(barCount === 1 && s[i] === \\'|\\') {\\n            barCount = 0;\\n        } else if(s[i] === \\'|\\') {\\n            barCount++;\\n        }\\n    }\\n    return starCount;\\n};\\n```\\n\\n# Approach 2\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function(s) {\\n    let green = true;\\n    let count = 0;\\n    for(let i = 0; i < s.length; i++) {\\n        if(green && s[i] === \\'*\\') count++;\\n        if(s[i] === \\'|\\') green = !green;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function(s) {\\n    let starCount = 0;\\n    let barCount = 0;\\n\\n    for(let i = 0; i < s.length; i++) {\\n        if(barCount === 0 && s[i] === \\'*\\') {\\n            starCount++;\\n        } else if(barCount === 1 && s[i] === \\'|\\') {\\n            barCount = 0;\\n        } else if(s[i] === \\'|\\') {\\n            barCount++;\\n        }\\n    }\\n    return starCount;\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countAsterisks = function(s) {\\n    let green = true;\\n    let count = 0;\\n    for(let i = 0; i < s.length; i++) {\\n        if(green && s[i] === \\'*\\') count++;\\n        if(s[i] === \\'|\\') green = !green;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3378362,
                "title": "count-asterisks-in-1ms-please-upvote-if-you-like-the-answer",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean b = false;\\n        int ans=0;\\n        for(char i : s.toCharArray()){\\n            if(!b && i == \\'*\\'){\\n                ans++;\\n            }else if(i==\\'|\\'){\\n                b = !b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean b = false;\\n        int ans=0;\\n        for(char i : s.toCharArray()){\\n            if(!b && i == \\'*\\'){\\n                ans++;\\n            }else if(i==\\'|\\'){\\n                b = !b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358024,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var c = s.Split(\\'|\\');\\n        int res = 0;\\n\\n        for (int i = 0; i < c.Length; i+=2)\\n        {\\n            res += c[i].Count(x => x == \\'*\\');\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var c = s.Split(\\'|\\');\\n        int res = 0;\\n\\n        for (int i = 0; i < c.Length; i+=2)\\n        {\\n            res += c[i].Count(x => x == \\'*\\');\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113185,
                "title": "0ms-100-fastest-c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n![image.png](https://assets.leetcode.com/users/images/29b4cdbf-6279-4caa-b30d-0ee15efc31d1_1674989251.4794273.png)\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int open=0;\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'|\\' && open==0) open++;\\n            else if(s[i]==\\'|\\'&& open>0) open--;\\n            else if(s[i]==\\'*\\'&& open==0 ) count++;\\n                \\n\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int open=0;\\n        \\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'|\\' && open==0) open++;\\n            else if(s[i]==\\'|\\'&& open>0) open--;\\n            else if(s[i]==\\'*\\'&& open==0 ) count++;\\n                \\n\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998990,
                "title": "optimized-split-method-beginner-friendly-brute-force",
                "content": "## Please upvote if you found it helpful !\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**We can directly split the string based on \\'|\\' character but the split method will not function correctly in this case because the character \\'|\\' is escape character and to accept it we need to give \"\\\\\\\\|\" in the split method.\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)**\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int res=0;\\n\\n        String st[]=s.split(\"\\\\\\\\|\");\\n        // System.out.println(Arrays.toString(st));\\n\\n        for(int i=0;i<st.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                String t=st[i];\\n\\n                for(int j=0;j<t.length();j++)\\n                {\\n                    if(t.charAt(j)==\\'*\\')\\n                    {\\n                        res++;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        \\n            \\n\\n            \\n            \\n            \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Design",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int res=0;\\n\\n        String st[]=s.split(\"\\\\\\\\|\");\\n        // System.out.println(Arrays.toString(st));\\n\\n        for(int i=0;i<st.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                String t=st[i];\\n\\n                for(int j=0;j<t.length();j++)\\n                {\\n                    if(t.charAt(j)==\\'*\\')\\n                    {\\n                        res++;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        \\n            \\n\\n            \\n            \\n            \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859397,
                "title": "simple-java-code",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int c1 = 0, res = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            if(s.charAt(i) == \\'|\\') {\\n                c1++;\\n                \\n            }\\n            if(c1%2 == 0) {\\n                if(s.charAt(i) == \\'*\\') {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int c1 = 0, res = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            if(s.charAt(i) == \\'|\\') {\\n                c1++;\\n                \\n            }\\n            if(c1%2 == 0) {\\n                if(s.charAt(i) == \\'*\\') {\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819331,
                "title": "easiest-solution-c-plus-plus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int brace = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\' && brace!=1) brace=1;\\n            else if(s[i]==\\'*\\' && brace!=1) ans++;\\n            else if(s[i]==\\'|\\' && brace==1) brace=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int brace = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'|\\' && brace!=1) brace=1;\\n            else if(s[i]==\\'*\\' && brace!=1) ans++;\\n            else if(s[i]==\\'|\\' && brace==1) brace=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572012,
                "title": "java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        Stack<Character> a=new Stack<>();\\n        int i,n=s.length();\\n        int k=0;\\n        for(i=0;i<n;i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'|\\')\\n            {\\n                if(!a.isEmpty() && k%2==1)\\n                {\\n                    while(a.peek()!=\\'|\\')\\n                        a.pop();\\n                    a.pop();\\n                    k--;\\n                }\\n                else \\n                {\\n                    a.push(ch);\\n                    k++;\\n                }\\n            }\\n            else\\n                a.push(ch);\\n            \\n        }\\n        int count=0;\\n        while(!a.isEmpty())\\n        {\\n            char c=a.pop();\\n            if(c==\\'*\\')\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        Stack<Character> a=new Stack<>();\\n        int i,n=s.length();\\n        int k=0;\\n        for(i=0;i<n;i++)\\n        {\\n            char ch=s.charAt(i);\\n            if(ch==\\'|\\')\\n            {\\n                if(!a.isEmpty() && k%2==1)\\n                {\\n                    while(a.peek()!=\\'|\\')\\n                        a.pop();\\n                    a.pop();\\n                    k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2553264,
                "title": "easy-python-solution",
                "content": "***Upvote if you like the solution!!***\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        flag=False\\n        count=0\\n        for ch in s:\\n            if ch==\"|\" and flag:\\n                flag = False\\n            elif ch==\"|\" and not flag:\\n                flag = True\\n            elif not flag and ch==\"*\":\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        flag=False\\n        count=0\\n        for ch in s:\\n            if ch==\"|\" and flag:\\n                flag = False\\n            elif ch==\"|\" and not flag:\\n                flag = True\\n            elif not flag and ch==\"*\":\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550303,
                "title": "easy-java-solution",
                "content": "**Space Complexity: O(1) and Time Complexity O(n)**\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        int vBarCount = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                vBarCount++;\\n            }\\n            if(vBarCount % 2 == 0 && s.charAt(i) == \\'*\\'){\\n                count++;\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        int vBarCount = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'|\\'){\\n                vBarCount++;\\n            }\\n            if(vBarCount % 2 == 0 && s.charAt(i) == \\'*\\'){\\n                count++;\\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545886,
                "title": "python-solution",
                "content": "```\\n    def countAsterisks(self, s: str) -> int:\\n        words = s.split(\\'|\\')\\n        count = 0\\n        for i in range(0, len(words), 2):\\n            for char in words[i]:\\n                if char == \\'*\\':\\n                    count += 1\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def countAsterisks(self, s: str) -> int:\\n        words = s.split(\\'|\\')\\n        count = 0\\n        for i in range(0, len(words), 2):\\n            for char in words[i]:\\n                if char == \\'*\\':\\n                    count += 1\\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2534272,
                "title": "using-flag-c",
                "content": "*I would love to get your feedback*\\n```\\n   int countAsterisks(string s) {\\n        bool flag = true;\\n        int count = 0;\\n        for(auto str:s){\\n            if(str == \\'|\\') flag = !flag;\\n            if(flag && str == \\'*\\') count++;\\n        }\\n    return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int countAsterisks(string s) {\\n        bool flag = true;\\n        int count = 0;\\n        for(auto str:s){\\n            if(str == \\'|\\') flag = !flag;\\n            if(flag && str == \\'*\\') count++;\\n        }\\n    return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505394,
                "title": "c",
                "content": "```\\npublic class Solution \\n{\\n    public int CountAsterisks(string s) \\n    {\\n        int start = s.IndexOf(\\'|\\');\\n\\n        while (start != -1)\\n        {\\n            int end = s.IndexOf(\\'|\\', start + 1);\\n            s = s.Remove(start, end - start + 1);\\n\\n            start = s.IndexOf(\\'|\\');\\n        }\\n\\n        return s.Count(x=>x == \\'*\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int CountAsterisks(string s) \\n    {\\n        int start = s.IndexOf(\\'|\\');\\n\\n        while (start != -1)\\n        {\\n            int end = s.IndexOf(\\'|\\', start + 1);\\n            s = s.Remove(start, end - start + 1);\\n\\n            start = s.IndexOf(\\'|\\');\\n        }\\n\\n        return s.Count(x=>x == \\'*\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502085,
                "title": "1ms-one-pass-elegant-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int res = 0;\\n        boolean canCount = true;\\n        for (char c: s.toCharArray()){\\n            if (c == \\'*\\' && canCount) ++res;\\n            else if (c == \\'|\\'){\\n                canCount = !canCount;    \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int res = 0;\\n        boolean canCount = true;\\n        for (char c: s.toCharArray()){\\n            if (c == \\'*\\' && canCount) ++res;\\n            else if (c == \\'|\\'){\\n                canCount = !canCount;    \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447160,
                "title": "java-split-func",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countAsterisks(String s) {\\n\\t\\t\\tString [] temp = s.split(\"\\\\\\\\|\");\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<temp.length; i+=2){\\n\\t\\t\\t\\tfor(int j=0; j<temp[i].length(); ++j){\\n\\t\\t\\t\\t\\tif(temp[i].charAt(j) == \\'*\\')\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t}\\n\\t// time O(n)\\n\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countAsterisks(String s) {\\n\\t\\t\\tString [] temp = s.split(\"\\\\\\\\|\");\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<temp.length; i+=2){\\n\\t\\t\\t\\tfor(int j=0; j<temp[i].length(); ++j){\\n\\t\\t\\t\\t\\tif(temp[i].charAt(j) == \\'*\\')\\n\\t\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2432217,
                "title": "python-iterative-method-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        \\n        ans=0\\n        inpair=0\\n        for i in s:\\n            if i==\"|\":\\n                inpair+=1\\n            if inpair%2==0 and i==\"*\":\\n                ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        \\n        ans=0\\n        inpair=0\\n        for i in s:\\n            if i==\"|\":\\n                inpair+=1\\n            if inpair%2==0 and i==\"*\":\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430449,
                "title": "count-asterisks",
                "content": "python 3 solution \\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        tempCount = 0\\n        count=0 \\n        for i in s : \\n            if i ==\"|\":\\n                tempCount+=1\\n            if tempCount==2:\\n                tempCount = 0 \\n            if tempCount==0 and i ==\"*\":\\n                count+=1\\n        return(count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        tempCount = 0\\n        count=0 \\n        for i in s : \\n            if i ==\"|\":\\n                tempCount+=1\\n            if tempCount==2:\\n                tempCount = 0 \\n            if tempCount==0 and i ==\"*\":\\n                count+=1\\n        return(count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429186,
                "title": "java-easy-2ms",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n      \\n        int startCount = 0;\\n        int barCount = 0;\\n        for(int i = 0; i<s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'|\\')\\n            {\\n                barCount++;\\n            }\\n            \\n            if(c == \\'*\\' && barCount%2 == 0)\\n            {\\n                startCount++;\\n            }\\n        }\\n        \\n        return startCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n      \\n        int startCount = 0;\\n        int barCount = 0;\\n        for(int i = 0; i<s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'|\\')\\n            {\\n                barCount++;\\n            }\\n            \\n            if(c == \\'*\\' && barCount%2 == 0)\\n            {\\n                startCount++;\\n            }\\n        }\\n        \\n        return startCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425737,
                "title": "fastest-java-solution-100",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        boolean flag = false;\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'|\\'){\\n               flag = !flag;\\n            }\\n            else if(ch == \\'*\\' && !flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        int count = 0;\\n        boolean flag = false;\\n        for(char ch:s.toCharArray()){\\n            if(ch==\\'|\\'){\\n               flag = !flag;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2425380,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int c = 0,ans =0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'|\\')\\n                c++;\\n            if(c%2==0)\\n            {\\n                if(s[i] == \\'*\\')\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int c = 0,ans =0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'|\\')\\n                c++;\\n            if(c%2==0)\\n            {\\n                if(s[i] == \\'*\\')\\n                    ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419813,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countAsterisks(string s) {\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint flag = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<s.size() ; i++){\\n\\n\\t\\t\\t\\tif(s[i] == \\'|\\'){\\n\\t\\t\\t\\t\\tflag++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(flag % 2 == 0){\\n\\t\\t\\t\\t\\tif(s[i] == \\'*\\'){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countAsterisks(string s) {\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint flag = 0;\\n\\n\\t\\t\\tfor(int i=0 ; i<s.size() ; i++){\\n\\n\\t\\t\\t\\tif(s[i] == \\'|\\'){\\n\\t\\t\\t\\t\\tflag++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2417795,
                "title": "javascript",
                "content": "```\\nvar countAsterisks = function(s) {\\n    let sum = 0;\\n    const splitS = s.split(\\'|\\');\\n    for(let i = 0; i < splitS.length; i++){\\n        if(i === 0 || i % 2 ===0){\\n            for(let j = 0; j < splitS[i].length; j++){\\n                if(splitS[i][j] === \\'*\\') sum++\\n            }\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countAsterisks = function(s) {\\n    let sum = 0;\\n    const splitS = s.split(\\'|\\');\\n    for(let i = 0; i < splitS.length; i++){\\n        if(i === 0 || i % 2 ===0){\\n            for(let j = 0; j < splitS[i].length; j++){\\n                if(splitS[i][j] === \\'*\\') sum++\\n            }\\n        }\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2407054,
                "title": "python-readable-approach-one-liner-w-explanation",
                "content": "We can split the string into a list with *n* + 1 items where *n* is the numer of \\'|\\'s in the list. \\nE.g. `\"l|*e*et|c**o|*de|\".split(\\'|\\') -> [\\'l\\', \\'*e*et\\', \\'c**o\\', \\'*de\\', \\'\\']` .\\n\\nNext, iterate over the index and values of the list using enumerate. If the index is odd, that means that the substring occured between two \\'|\\' in the original string so it is ignored. On the other hand, if the index is even then the substring occured outside of \\'|\\' pairs. In that case, we count the number of asterisks and add them to the counter variable.\\n\\nGoing through the testcase where `s=\"l|*e*et|c**o|*de|\"` only the list items `[\\'l\\',\\'c**o\\', \\'\\'] ` are counted.\\n\\n```\\ndef countAsterisks(self, s: str) -> int:\\n\\tl = s.split(\\'|\\')\\n\\tc = 0\\n\\tfor i, string in enumerate(l):\\n\\t\\tif i % 2 == 0:\\n\\t\\t\\tc += string.count(\\'*\\')\\n\\treturn c\\n```\\nThe code above can be unnecessarily compressed into a single difficult to read line if that kind of thing floats your boat\\n```\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([string.count(\\'*\\') for i, string in enumerate(s.split(\\'|\\'))  if i % 2 == 0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countAsterisks(self, s: str) -> int:\\n\\tl = s.split(\\'|\\')\\n\\tc = 0\\n\\tfor i, string in enumerate(l):\\n\\t\\tif i % 2 == 0:\\n\\t\\t\\tc += string.count(\\'*\\')\\n\\treturn c\\n```\n```\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([string.count(\\'*\\') for i, string in enumerate(s.split(\\'|\\'))  if i % 2 == 0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2406690,
                "title": "simple-approach-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int barCount = 0;\\n        int starCount = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'|\\') {\\n                barCount++;\\n            }\\n            if (barCount % 2 != 0) {\\n                continue;\\n            }\\n            if (c == \\'*\\') {\\n                starCount++;\\n            }\\n        }\\n        return starCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int barCount = 0;\\n        int starCount = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'|\\') {\\n                barCount++;\\n            }\\n            if (barCount % 2 != 0) {\\n                continue;\\n            }\\n            if (c == \\'*\\') {\\n                starCount++;\\n            }\\n        }\\n        return starCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304319,
                "title": "simplest-c-100-fast-easy",
                "content": "```\\nint countAsterisks(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i]==\\'|\\'){\\n                ans=ans^1; //to make swaps between \\'|\\'.\\n            }\\n            if(s[i]==\\'*\\' && ans == 1){\\n                sum++;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint countAsterisks(string s) {\\n        int n = s.size();\\n        int ans = 1;\\n        int sum = 0;\\n        for(int i = 0;i<n;i++){\\n            if(s[i]==\\'|\\'){\\n                ans=ans^1; //to make swaps between \\'|\\'.\\n            }\\n            if(s[i]==\\'*\\' && ans == 1){\\n                sum++;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300923,
                "title": "c-easy-o-n-6ms-single-traversal-o-1-sc-100-understandable-have-a-nice-day",
                "content": "What is this approach actually doing?\\n1. We know that only pairing of | | will count asterisks inbetween, So I used a even odd counter approach like if count of | is odd, means now its time to add every asterisk which comes after this |, and if i again get a new | or the count becomes even now, it means I have got my one pair out of this given string so I can add their asterisk frequency into my ans counter.\\n2. At last, if any occurence is leftover, add it at last to the ans counter.\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int fc=0,cc=0,lc=0;\\n        for(char c:s){\\n            if(c==\\'|\\'){\\n                lc++;\\n            }\\n            \\n            if(lc%2!=0)\\n            {\\n                fc=fc+cc;\\n                cc=0;\\n                \\n            }\\n            else{\\n                if(c==\\'*\\'){\\n             \\n                cc++;\\n                }\\n            }\\n            \\n        }\\n        if(cc!=0)\\n            fc=fc+cc;\\n        \\n        return fc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int fc=0,cc=0,lc=0;\\n        for(char c:s){\\n            if(c==\\'|\\'){\\n                lc++;\\n            }\\n            \\n            if(lc%2!=0)\\n            {\\n                fc=fc+cc;\\n                cc=0;\\n                \\n            }\\n            else{\\n                if(c==\\'*\\'){\\n             \\n                cc++;\\n                }\\n            }\\n            \\n        }\\n        if(cc!=0)\\n            fc=fc+cc;\\n        \\n        return fc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297561,
                "title": "javascript-easy-approach-o-n-time-o-1-space",
                "content": "Every time you see a pipe, toggle a boolean to indicate you can add any asterisks you see before the next pipe to the total count.\\n\\n```\\nvar countAsterisks = function(s) {\\n    let i = 0, toggle = false, ct = 0;\\n    while (i < s.length) {\\n        let c = s[i];\\n        if (c === \"|\") toggle = !toggle;\\n        if (!toggle) {\\n            if (c === \"*\") ct++;\\n        }\\n        i++;\\n    }\\n    return ct;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAsterisks = function(s) {\\n    let i = 0, toggle = false, ct = 0;\\n    while (i < s.length) {\\n        let c = s[i];\\n        if (c === \"|\") toggle = !toggle;\\n        if (!toggle) {\\n            if (c === \"*\") ct++;\\n        }\\n        i++;\\n    }\\n    return ct;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286718,
                "title": "python-stack-easy-solution",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        \\n        stack = []\\n        \\n        count = 0\\n        \\n        for i in s:\\n            if \\'|\\' in stack:\\n                if i==\\'|\\':\\n                    stack=[]\\n                else:\\n                    stack.append(i)\\n            else:\\n                if i==\\'|\\':\\n                    stack.append(i)\\n                else:\\n                    if i==\\'*\\':\\n                        count+=1\\n                                \\n        return count \\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        \\n        stack = []\\n        \\n        count = 0\\n        \\n        for i in s:\\n            if \\'|\\' in stack:\\n                if i==\\'|\\':\\n                    stack=[]\\n                else:\\n                    stack.append(i)\\n            else:\\n                if i==\\'|\\':\\n                    stack.append(i)\\n                else:\\n                    if i==\\'*\\':\\n                        count+=1\\n                                \\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266643,
                "title": "c-solution",
                "content": "```\\n\\n\\nint countAsterisks(char * s){\\n    int i,count=0;\\n    bool unlock=true;                   //lock variable\\n    for(i=0;s[i];i++)\\n    {\\n        if(s[i]==\\'|\\')                   // if we detecect any \\'|\\' then we\\'ll lock section untill we foun another \\'|\\'\\n            unlock=true^unlock;\\n        else if(unlock && s[i]==\\'*\\')    //if it is unlocked and character is \\'*\\' then count++\\n            count++;\\n    }\\n    return count;                       //return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint countAsterisks(char * s){\\n    int i,count=0;\\n    bool unlock=true;                   //lock variable\\n    for(i=0;s[i];i++)\\n    {\\n        if(s[i]==\\'|\\')                   // if we detecect any \\'|\\' then we\\'ll lock section untill we foun another \\'|\\'\\n            unlock=true^unlock;\\n        else if(unlock && s[i]==\\'*\\')    //if it is unlocked and character is \\'*\\' then count++\\n            count++;\\n    }\\n    return count;                       //return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263176,
                "title": "simple-java-solution-o-n",
                "content": "class Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int pipeCount=0, asterisks=0;\\n        \\n        for(char c: s.toCharArray()){\\n            if(c==\\'|\\') pipeCount++;\\n            else{\\n                if(pipeCount%2==0 && c==\\'*\\')\\n                    asterisks++;\\n            }\\n        }\\n        \\n        return asterisks;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        \\n        int pipeCount=0, asterisks=0;\\n        \\n        for(char c: s.toCharArray()){\\n            if(c==\\'|\\') pipeCount++;\\n            else{\\n                if(pipeCount%2==0 && c==\\'*\\')\\n                    asterisks++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2263080,
                "title": "c-one-pass-beats-100",
                "content": "class Solution {\\npublic:\\n\\n    int countAsterisks(string s) {\\n        bool flag = false;\\n        int count = 0;\\n        int c = 0;\\n        for(int i =0; i<s.size(); i++){\\n            if(s[i] == \\'|\\'){\\n                flag = true;\\n                c++;\\n            }\\n            if(c == 2){\\n                flag = false;\\n                c = 0;\\n            }\\n            if(flag == false && s[i] == \\'*\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countAsterisks(string s) {\\n        bool flag = false;\\n        int count = 0;\\n        int c = 0;\\n        for(int i =0; i<s.size(); i++){\\n            if(s[i] == \\'|\\'){\\n                flag = true;\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2248292,
                "title": "python-return-if-base-case-then-iterate-with-one-liner",
                "content": "I like this approach primarily for the readibility. Though I\\'m iterating to see if \\'|\\' is in the string first, i.e. it\\'s definitely less efficient than other only O(n) solutions.\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        if \\'|\\' not in s:\\n            return s.count(\\'*\\')\\n        s = s.split(\\'|\\')\\n        return sum([i.count(\\'*\\') for i in s[0::2]])\\n```\\n\\nAnd the One-Liner if ya want it: \\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([i.count(\\'*\\') for i in s.split(\\'|\\')[0::2]]) if \\'|\\' in s else s.count(\\'*\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        if \\'|\\' not in s:\\n            return s.count(\\'*\\')\\n        s = s.split(\\'|\\')\\n        return sum([i.count(\\'*\\') for i in s[0::2]])\\n```\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        return sum([i.count(\\'*\\') for i in s.split(\\'|\\')[0::2]]) if \\'|\\' in s else s.count(\\'*\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241765,
                "title": "python-easy-to-understand-simple",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count = 0\\n        flag = True\\n        for i in s:\\n            if i==\\'|\\':\\n                flag = not flag\\n            if i==\\'*\\' and flag:\\n                count+=1\\n        return count\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count = 0\\n        flag = True\\n        for i in s:\\n            if i==\\'|\\':\\n                flag = not flag\\n            if i==\\'*\\' and flag:\\n                count+=1\\n        return count\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2239855,
                "title": "python-using-split-o-n",
                "content": "class Solution:\\n\\n    def countAsterisks(self, s: str) -> int:\\n        splited = s.split(\\'|\\')[::2]\\n        count = 0\\n        for element in splited:\\n            count += element.count(\\'*\\')\\n        return count\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def countAsterisks(self, s: str) -> int:\\n        splited = s.split(\\'|\\')[::2]\\n        count = 0\\n        for element in splited:\\n            count += element.count(\\'*\\')\\n        return count\\n",
                "codeTag": "Java"
            },
            {
                "id": 2237745,
                "title": "easy-to-understand-simple-javascript-solution-60sm",
                "content": "\\n\\n```\\nvar countAsterisks = function(s) {\\n    \\n    let count = 0;\\n    let res = 0;\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] === \\'|\\'){\\n           count ++\\n         }\\n        \\n        if(count % 2 === 0 && s[i] === \\'*\\'){\\n            res ++\\n        }\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nvar countAsterisks = function(s) {\\n    \\n    let count = 0;\\n    let res = 0;\\n    \\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] === \\'|\\'){\\n           count ++\\n         }\\n        \\n        if(count % 2 === 0 && s[i] === \\'*\\'){\\n            res ++\\n        }\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2236956,
                "title": "c-easy-solution-o-n-simple-for-understandable-as-well-as-readable",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n       bool temp=true;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'*\\' && temp ){\\n                count++;\\n            }\\n            else if(s[i]==\\'|\\'){\\n                temp=! temp;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n       bool temp=true;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'*\\' && temp ){\\n                count++;\\n            }\\n            else if(s[i]==\\'|\\'){\\n                temp=! temp;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235684,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def countAsterisks(self, s):        \\n        if s.count(\\'|\\') < 2:\\n            return s.count(\\'*\\')\\n        \\n        arr = s.split(\\'|\\')\\n\\n        res = 0\\n        for i in range( len(arr)):\\n            if (i+1) <= len(arr) and (i+1)%2==0:\\n                continue\\n            res += arr[i].count(\\'*\\')\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countAsterisks(self, s):        \\n        if s.count(\\'|\\') < 2:\\n            return s.count(\\'*\\')\\n        \\n        arr = s.split(\\'|\\')\\n\\n        res = 0\\n        for i in range( len(arr)):\\n            if (i+1) <= len(arr) and (i+1)%2==0:\\n                continue\\n            res += arr[i].count(\\'*\\')\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229019,
                "title": "python-solution-using-stack",
                "content": "class Solution(object):\\n    def countAsterisks(self, s):\\n        \\n        if not \"*\" in s:\\n            return 0\\n        \\n        stack = []\\n        count = 0\\n        \\n        for c in s:\\n            if c == \"|\":\\n                count += 1\\n            \\n            stack.append(c)\\n                \\n            if count == 2:\\n                while count:\\n                    el = stack.pop()\\n                    if el == \"|\":\\n                        count -= 1\\n                        \\n    \\n        return \"\".join(stack).count(\"*\")",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def countAsterisks(self, s):\\n        \\n        if not \"*\" in s:\\n            return 0\\n        \\n        stack = []\\n        count = 0\\n        \\n        for c in s:\\n            if c == \"|\":\\n                count += 1\\n            \\n            stack.append(c)\\n                \\n            if count == 2:\\n                while count:\\n                    el = stack.pop()\\n                    if el == \"|\":\\n                        count -= 1\\n                        \\n    \\n        return \"\".join(stack).count(\"*\")",
                "codeTag": "Java"
            },
            {
                "id": 2218624,
                "title": "python-simple-one-line-solution",
                "content": "That is one line solution:\\n```\\nclass Solution(object):\\n    def countAsterisks(self, s: str = \\'l|*e*et|c**o|*de|\\') -> int:\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return \\'\\'.join([char for char in s.split(\\'|\\')[::2]]).count(\\'*\\')\\n```\\nis equivalent:\\n```\\nclass Solution(object):\\n    def countAsterisks(self, s: str = \\'l|*e*et|c**o|*de|\\') -> int:\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\t\\tcycle_string = s.split(\\'|\\')      # cycle_string: [\\'l\\', \\'*e*et\\', \\'c**o\\', \\'*de\\', \\'\\']\\n\\t\\tbase_string = \\'\\'\\n\\n\\t\\tfor char in cycle_string[::2]:   # here we start the for-cycle from 0-indexed to last indexed with step = 2\\n\\t\\t\\tbase_string += char\\n\\n\\t\\treturn base_string.count(\\'*\\')    # base_string: lc**o\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countAsterisks(self, s: str = \\'l|*e*et|c**o|*de|\\') -> int:\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        return \\'\\'.join([char for char in s.split(\\'|\\')[::2]]).count(\\'*\\')\\n```\n```\\nclass Solution(object):\\n    def countAsterisks(self, s: str = \\'l|*e*et|c**o|*de|\\') -> int:\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\t\\tcycle_string = s.split(\\'|\\')      # cycle_string: [\\'l\\', \\'*e*et\\', \\'c**o\\', \\'*de\\', \\'\\']\\n\\t\\tbase_string = \\'\\'\\n\\n\\t\\tfor char in cycle_string[::2]:   # here we start the for-cycle from 0-indexed to last indexed with step = 2\\n\\t\\t\\tbase_string += char\\n\\n\\t\\treturn base_string.count(\\'*\\')    # base_string: lc**o\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201111,
                "title": "c-easy-approach-simple-if-else-problem",
                "content": "```\\nint countAsterisks(string s) {\\n        bool isPaired=false;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'*\\' and isPaired==false)\\n                count++;\\n            else if(s[i]==\\'|\\' and isPaired==false)\\n                isPaired=true;\\n            else if(s[i]==\\'|\\' and isPaired==true)\\n                isPaired=false;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nint countAsterisks(string s) {\\n        bool isPaired=false;\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'*\\' and isPaired==false)\\n                count++;\\n            else if(s[i]==\\'|\\' and isPaired==false)\\n                isPaired=true;\\n            else if(s[i]==\\'|\\' and isPaired==true)\\n                isPaired=false;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200448,
                "title": "c-easy-to-understand-basic-code",
                "content": "int n = s.size();\\n    int cnt = 0;\\n    for(int i=0;i<n;i++){\\n        if(s[i] == \\'|\\'){\\n            i++;\\n            while(i<n && s[i] != \\'|\\'){\\n                i++;\\n            }\\n            //cout << \"pair\" << end;\\n     //       i+=2;\\n        }else if(s[i] == \\'*\\'){\\n            cnt++;\\n        }\\n    }\\n    return cnt;",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "int n = s.size();\\n    int cnt = 0;\\n    for(int i=0;i<n;i++){\\n        if(s[i] == \\'|\\'){\\n            i++;\\n            while(i<n && s[i] != \\'|\\'){\\n                i++;\\n            }\\n            //cout << \"pair\" << end;\\n     //       i+=2;\\n        }else if(s[i] == \\'*\\'){\\n            cnt++;\\n        }\\n    }\\n    return cnt;",
                "codeTag": "C++"
            },
            {
                "id": 2200104,
                "title": "simple-java-solution-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        String str = \"\";\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'*\\')\\n                count++;\\n            if(s.charAt(i)==\\'|\\'){\\n                int j = i+1;\\n                while(s.charAt(j) != \\'|\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        String str = \"\";\\n        int count = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'*\\')\\n                count++;\\n            if(s.charAt(i)==\\'|\\'){\\n                int j = i+1;\\n                while(s.charAt(j) != \\'|\\'){\\n                    j++;\\n                }\\n                i = j;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199925,
                "title": "one-pass-100-speed",
                "content": "![image](https://assets.leetcode.com/users/images/d74a93a6-1e91-48a3-8351-b88232475be8_1656235662.2867875.png)\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count_stars, count = True, 0\\n        for c in s:\\n            if c == \"|\":\\n                count_stars = not count_stars\\n            elif count_stars and c == \"*\":\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count_stars, count = True, 0\\n        for c in s:\\n            if c == \"|\":\\n                count_stars = not count_stars\\n            elif count_stars and c == \"*\":\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199422,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        str1 = list(s)\\n        res = []\\n        bar = 0\\n        star=0\\n        for i in range(0,len(str1)):\\n            if(str1[i]==\\'|\\'):\\n                if(\\'|\\' not in res):\\n                    res.append(\\'|\\')\\n                else:\\n                    res.append(\\'|\\')\\n                    res.pop(len(res)-1)\\n                    j = len(res)-1\\n                    while(res[j]!=\\'|\\' and j>=0):\\n                        res.pop(j)\\n                        j=j-1\\n                    res.pop(j)\\n            if(str1[i]==\\'*\\'):\\n                res.append(\\'*\\')\\n        return res.count(\\'*\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        str1 = list(s)\\n        res = []\\n        bar = 0\\n        star=0\\n        for i in range(0,len(str1)):\\n            if(str1[i]==\\'|\\'):\\n                if(\\'|\\' not in res):\\n                    res.append(\\'|\\')\\n                else:\\n                    res.append(\\'|\\')\\n                    res.pop(len(res)-1)\\n                    j = len(res)-1\\n                    while(res[j]!=\\'|\\' and j>=0):\\n                        res.pop(j)\\n                        j=j-1\\n                    res.pop(j)\\n            if(str1[i]==\\'*\\'):\\n                res.append(\\'*\\')\\n        return res.count(\\'*\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198443,
                "title": "two-counters-c-easy-solution",
                "content": "\\'\\'\\'\\n\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        \\n        int cnt1 = 0;//For counting number of \\'*\\' in s, excluding the \\'*\\' between each pair of \\'|\\'\\n        int cnt2 = 0;//For counting number of \\'|\\'\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            //As * between each pair of \\'|\\' is excluded i.e only even pairs between \\'|\\' are considered\\n            if(cnt2 % 2 == 0){\\n                if(s[i] == \\'*\\')\\n                    cnt1++;\\n            }\\n            if(s[i] == \\'|\\')\\n                cnt2++;\\n        }\\n        return cnt1;\\n    }\\n    \\n};\\n```\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        \\n        int cnt1 = 0;//For counting number of \\'*\\' in s, excluding the \\'*\\' between each pair of \\'|\\'\\n        int cnt2 = 0;//For counting number of \\'|\\'\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            //As * between each pair of \\'|\\' is excluded i.e only even pairs between \\'|\\' are considered\\n            if(cnt2 % 2 == 0){\\n                if(s[i] == \\'*\\')\\n                    cnt1++;\\n            }\\n            if(s[i] == \\'|\\')\\n                cnt2++;\\n        }\\n        return cnt1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197936,
                "title": "easy-and-simple-two-solutions-c-explained",
                "content": "**Approach 1**\\n\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0;\\n        int open = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'|\\' && open == 0)  open++;\\n            else if(s[i] == \\'|\\' && open > 0)  open--;\\n            else if(s[i] == \\'*\\' && open == 0)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach 2**\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int n = s.length();\\n        //Storing the indices of bars\\n        vector<int> bars;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                bars.push_back(i);\\n            }\\n        }\\n        \\n        //Recording if there\\'s a \\'*\\' at a particular index\\n        vector<int> stars(n, 0);\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'*\\'){\\n                stars[i] = 1;\\n                count++;\\n            }\\n        }\\n        \\n        //Finding the cummulative count of stars\\n        for(int i = 1; i < n; i++){\\n            stars[i] += stars[i-1];\\n        }\\n        \\n        //Subtracting the number of stars to be excluded - lying in the middle of each pair\\n        for(int i = 0; i < bars.size(); i += 2){\\n            count -= (stars[bars[i+1]] - stars[bars[i]]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count = 0;\\n        int open = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s[i] == \\'|\\' && open == 0)  open++;\\n            else if(s[i] == \\'|\\' && open > 0)  open--;\\n            else if(s[i] == \\'*\\' && open == 0)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int n = s.length();\\n        //Storing the indices of bars\\n        vector<int> bars;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                bars.push_back(i);\\n            }\\n        }\\n        \\n        //Recording if there\\'s a \\'*\\' at a particular index\\n        vector<int> stars(n, 0);\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'*\\'){\\n                stars[i] = 1;\\n                count++;\\n            }\\n        }\\n        \\n        //Finding the cummulative count of stars\\n        for(int i = 1; i < n; i++){\\n            stars[i] += stars[i-1];\\n        }\\n        \\n        //Subtracting the number of stars to be excluded - lying in the middle of each pair\\n        for(int i = 0; i < bars.size(); i += 2){\\n            count -= (stars[bars[i+1]] - stars[bars[i]]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197905,
                "title": "100-faster-c-java-o-n-explanation-using-image",
                "content": "The idea is simple just skip the * between the paired pipes(|)\\n![image](https://assets.leetcode.com/users/images/1b74c8fa-2885-4223-a15d-96cac4b757b7_1656209951.4997597.png)\\nThe asterisk between 1st & 6th pipe will be skipped & the two asterisks at 8th and 9th posn will be added to result\\n \\nclass Solution {\\npublic:\\n    int countAsterisks(string str) {\\n        \\n        int count = 0;\\n        int n = str.length();\\n        \\n        for(int i =0;i<n;i++){\\n            if(str[i] == \\'|\\')\\n            {\\n                i++;\\n\\t\\t\\t\\t//skip the chars till next pipe or bar\\n                while(str[i] != \\'|\\')\\n                    i++;\\n            }\\n            if(str[i] == \\'*\\')\\n                count++;\\n            \\n        }\\n        return count;\\n    }\\n};\\n\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int c = 0;\\n        int n= s.length();\\n        for(int i =0;i<n;i++){\\n            if(s.charAt(i) == \\'|\\')\\n            {\\n                i++;\\n                while(s.charAt(i) != \\'|\\')\\n                    i++;\\n            }\\n            if(s.charAt(i) == \\'*\\')\\n                c++;\\n            \\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countAsterisks(string str) {\\n        \\n        int count = 0;\\n        int n = str.length();\\n        \\n        for(int i =0;i<n;i++){\\n            if(str[i] == \\'|\\')\\n            {\\n                i++;\\n\\t\\t\\t\\t//skip the chars till next pipe or bar\\n                while(str[i] != \\'|\\')\\n                    i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2197386,
                "title": "c-solutions",
                "content": "**One-pass solution**\\nIt passes the entire string 1 time and counts only valid asterisks.\\n```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var count = 0;\\n        var isValid = true;\\n        foreach(char ch in s){\\n            if(ch == \\'|\\') isValid = !isValid;\\n            else if (ch == \\'*\\' && isValid) count++;\\n        }\\n        return count;\\n    }    \\n}\\n```\\n\\n**Split method**\\nSplits the string into string array, checks only valid ones and counts asterisks.\\n```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var words = s.Split(\"|\");\\n        var count = 0;\\n        for(int i = 0; i<words.Length; i=i+2){\\n            count+=Count(words[i]);\\n        }\\n        return count;\\n    }\\n    \\n    public int Count(string str){\\n        var count = 0;\\n        foreach(var s in str){\\n            if(s == \\'*\\' ) count++;\\n        }        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var count = 0;\\n        var isValid = true;\\n        foreach(char ch in s){\\n            if(ch == \\'|\\') isValid = !isValid;\\n            else if (ch == \\'*\\' && isValid) count++;\\n        }\\n        return count;\\n    }    \\n}\\n```\n```\\npublic class Solution {\\n    public int CountAsterisks(string s) {\\n        var words = s.Split(\"|\");\\n        var count = 0;\\n        for(int i = 0; i<words.Length; i=i+2){\\n            count+=Count(words[i]);\\n        }\\n        return count;\\n    }\\n    \\n    public int Count(string str){\\n        var count = 0;\\n        foreach(var s in str){\\n            if(s == \\'*\\' ) count++;\\n        }        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197287,
                "title": "java-1-ms-faster-than-100-one-pass",
                "content": "Since we cannot count the ones between two bars, we should keep track of bar count. When we are allowed to count the asterisks, we do so. Simple modulus will allow us to determine if we are in the allowed range or not, because between two bars is not allowed.\\n\\n```\\npublic int countAsterisks(String s) {\\n        int count = 0;\\n        int countBar = 0;\\n        boolean isValid = true;\\n        \\n        for(char ch : s.toCharArray()){ //traverse string\\n            if(ch == \\'*\\' && isValid) //if it is an asterisk and we are allowed to count, count\\n                count++;\\n            else if(ch == \\'|\\'){ //if we see a bar, we increase our bar count and then check how that changes our valid range\\n                isValid = !isValid //we update isValid boolean so that next time we count/do not count. Other solutions post with modulus but since it is modulus 2, we can simple take the reverse of it.\\n            }\\n\\t\\t\\t//notice that there is not else part because we do not need to do anything if the char is not a bar or an asteriks\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countAsterisks(String s) {\\n        int count = 0;\\n        int countBar = 0;\\n        boolean isValid = true;\\n        \\n        for(char ch : s.toCharArray()){ //traverse string\\n            if(ch == \\'*\\' && isValid) //if it is an asterisk and we are allowed to count, count\\n                count++;\\n            else if(ch == \\'|\\'){ //if we see a bar, we increase our bar count and then check how that changes our valid range\\n                isValid = !isValid //we update isValid boolean so that next time we count/do not count. Other solutions post with modulus but since it is modulus 2, we can simple take the reverse of it.\\n            }\\n\\t\\t\\t//notice that there is not else part because we do not need to do anything if the char is not a bar or an asteriks\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2197091,
                "title": "simple-javascript-solution",
                "content": "```\\nvar countAsterisks = function(s) {\\n    let flag = false;\\n    let ast = 0;\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] == \\'|\\')\\n            flag = !flag;\\n        else if(!flag && s[i] == \\'*\\')\\n            ast++;            \\n    }\\n    return ast;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAsterisks = function(s) {\\n    let flag = false;\\n    let ast = 0;\\n    for(let i = 0; i < s.length; i++){\\n        if(s[i] == \\'|\\')\\n            flag = !flag;\\n        else if(!flag && s[i] == \\'*\\')\\n            ast++;            \\n    }\\n    return ast;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196890,
                "title": "c-implement-simple-solution",
                "content": "```\\nint countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }\\n        else if( in && s[i]==\\'*\\'){\\n            out++;\\n        }\\n    }\\n    return out;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countAsterisks(char * s){\\n    bool in=true;\\n    int len=strlen( s), out=0;\\n    for( int i=0; i<len; i++){\\n        if( s[i]==\\'|\\'){\\n            in=true^in;\\n        }\\n        else if( in && s[i]==\\'*\\'){\\n            out++;\\n        }\\n    }\\n    return out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196836,
                "title": "rust-solution-1ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        let mut count = 0;\\n        let mut odd = true;\\n        \\n        for i in s.chars() {\\n            if i == \\'|\\' {\\n                odd = !odd;\\n            }\\n            \\n            if odd && i == \\'*\\' {\\n                count+=1;\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn count_asterisks(s: String) -> i32 {\\n        let mut count = 0;\\n        let mut odd = true;\\n        \\n        for i in s.chars() {\\n            if i == \\'|\\' {\\n                odd = !odd;\\n            }\\n            \\n            if odd && i == \\'*\\' {\\n                count+=1;\\n            }\\n        }\\n        \\n        return count\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196538,
                "title": "easy-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    int countAsterisks(const string& s) {\\n        ll sz = s.length(), res = 0;\\n        bool pre = false;\\n        for (const char& ch : s) {\\n            if (ch == \\'|\\')\\n                pre = !pre;\\n            else if (ch == \\'*\\' && !pre)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    int countAsterisks(const string& s) {\\n        ll sz = s.length(), res = 0;\\n        bool pre = false;\\n        for (const char& ch : s) {\\n            if (ch == \\'|\\')\\n                pre = !pre;\\n            else if (ch == \\'*\\' && !pre)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196405,
                "title": "two-counters",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int pc=0;\\n        int ac=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'|\\'){\\n                if(pc%2==0 && s[i]==\\'*\\')\\n                    ac++;\\n            }\\n            else\\n                pc++;\\n        }\\n        return ac;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "MySQL",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int pc=0;\\n        int ac=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'|\\'){\\n                if(pc%2==0 && s[i]==\\'*\\')\\n                    ac++;\\n            }\\n            else\\n                pc++;\\n        }\\n        return ac;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196328,
                "title": "c-array-solution-simple",
                "content": "```\\nclass Solution{\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int countH = 0;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                countH++;\\n            }\\n            if(countH % 2 == 0){\\n                if(s[i] == \\'*\\'){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0;\\n        int countH = 0;\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            if(s[i] == \\'|\\'){\\n                countH++;\\n            }\\n            if(countH % 2 == 0){\\n                if(s[i] == \\'*\\'){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196313,
                "title": "c-easy-approach-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0;\\n        bool first=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                first=first==false?true:false;\\n            }\\n            if(s[i]==\\'*\\' and first==false)count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**T.C==>O(N)**\\n**S.C==>O(1)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0;\\n        bool first=false;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'|\\'){\\n                first=first==false?true:false;\\n            }\\n            if(s[i]==\\'*\\' and first==false)count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196240,
                "title": "cpp",
                "content": "class Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool toCountStar = true;\\n         \\n        int count=0;\\n        for(int i=0;i<s.size();++i){\\n            \\n            if(s[i]==\\'|\\') toCountStar = !toCountStar;\\n            if(toCountStar && s[i]==\\'*\\') count++;\\n        }\\n          \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        bool toCountStar = true;\\n         \\n        int count=0;\\n        for(int i=0;i<s.size();++i){\\n            \\n            if(s[i]==\\'|\\') toCountStar = !toCountStar;\\n            if(toCountStar && s[i]==\\'*\\') count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2196177,
                "title": "shortest-and-easiest",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans= 0, lines = 0;\\n        for (auto ch : s) \\n        {\\n        lines += ch == \\'|\\';\\n        ans += ch == \\'*\\' && lines % 2 == 0;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans= 0, lines = 0;\\n        for (auto ch : s) \\n        {\\n        lines += ch == \\'|\\';\\n        ans += ch == \\'*\\' && lines % 2 == 0;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196146,
                "title": "c-for-beginners-easy-understanding-one-pass-fastest",
                "content": "The trick here is to find all the windows between the bar containers. As we know 2 bars form 1 container so after every 1 container comprising 2 bars, count the number of * in that window.\\nit can be done using %2 . Check code for reference :\\n\\n\\n```\\nint countAsterisks(string s) {\\nint bar=0,ans=0;\\nfor(int i=0;i<s.length();i++){\\nif(s[i]==\\'|\\') bar++;\\nif(s[i]==\\'*\\' && bar%2==0) ans++;\\n}\\nreturn ans;\\n}```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint countAsterisks(string s) {\\nint bar=0,ans=0;\\nfor(int i=0;i<s.length();i++){\\nif(s[i]==\\'|\\') bar++;\\nif(s[i]==\\'*\\' && bar%2==0) ans++;\\n}\\nreturn ans;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196075,
                "title": "scala-single-pass-o-n",
                "content": "```\\nobject Solution {\\n  def countAsterisks(s: String): Int =\\n    s.foldLeft((false, 0)) { case ((pair, count), c) =>\\n      c match {\\n        case \\'|\\' => !pair -> count\\n        case \\'*\\' => pair -> (if (pair) count else count + 1)\\n        case _ => pair -> count\\n      }\\n    }._2\\n}\\n\\n//Runtime: 636 ms, faster than 100.00% of Scala online submissions for Count Asterisks.\\n//Memory Usage: 67.4 MB, less than 100.00% of Scala online submissions for Count Asterisks.\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def countAsterisks(s: String): Int =\\n    s.foldLeft((false, 0)) { case ((pair, count), c) =>\\n      c match {\\n        case \\'|\\' => !pair -> count\\n        case \\'*\\' => pair -> (if (pair) count else count + 1)\\n        case _ => pair -> count\\n      }\\n    }._2\\n}\\n\\n//Runtime: 636 ms, faster than 100.00% of Scala online submissions for Count Asterisks.\\n//Memory Usage: 67.4 MB, less than 100.00% of Scala online submissions for Count Asterisks.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2196068,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans=0;\\n        int p=0;\\n        for(char c:s){\\n            if(c==\\'|\\')p++;\\n            ans+=(p%2==0 && c==\\'*\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans=0;\\n        int p=0;\\n        for(char c:s){\\n            if(c==\\'|\\')p++;\\n            ans+=(p%2==0 && c==\\'*\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196035,
                "title": "c-easiest-solution-one-pass-solution-commented-and-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int countAsterisks(string s) {\\n        int n = s.length();\\n        if(n==1) return s[0]==\\'*\\';\\n        int cnts=0;   // indicating count of \\'*\\'\\n        int cntl=0;  // indicating count of \\'|\\'\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'|\\') cntl++;\\n            if(s[i] == \\'*\\'){\\n                if(cntl % 2 == 0) cnts++;  \\n            }\\n        }\\n        return cnts;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int countAsterisks(string s) {\\n        int n = s.length();\\n        if(n==1) return s[0]==\\'*\\';\\n        int cnts=0;   // indicating count of \\'*\\'\\n        int cntl=0;  // indicating count of \\'|\\'\\n        for(int i=0;i<n;i++){\\n            if(s[i] == \\'|\\') cntl++;\\n            if(s[i] == \\'*\\'){\\n                if(cntl % 2 == 0) cnts++;  \\n            }\\n        }\\n        return cnts;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196032,
                "title": "crisp-pythonic-explanation",
                "content": "We split the string by the char \"|\" and then count the number of \\'*\\' in every even indexed split element.\\n\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        words = s.split(\"|\")\\n        count = 0\\n\\n        for i in range(0,len(words)):\\n            if i%2==0:\\n                tmp = 0\\n                for c in words[i]:\\n                    if c==\\'*\\':\\n                        tmp+=1\\n                count+=tmp\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        words = s.split(\"|\")\\n        count = 0\\n\\n        for i in range(0,len(words)):\\n            if i%2==0:\\n                tmp = 0\\n                for c in words[i]:\\n                    if c==\\'*\\':\\n                        tmp+=1\\n                count+=tmp\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195986,
                "title": "easy-istringstream-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n    istringstream ss(s);\\n    string token;\\n    bool flag = true;\\n    int ans = 0;\\n    while(getline(ss, token, \\'|\\')) {\\n        if(flag){\\n            for(auto it: token){\\n                if(it == \\'*\\')\\n                    ans++;\\n            }\\n        }\\n        flag = !flag;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n    istringstream ss(s);\\n    string token;\\n    bool flag = true;\\n    int ans = 0;\\n    while(getline(ss, token, \\'|\\')) {\\n        if(flag){\\n            for(auto it: token){\\n                if(it == \\'*\\')\\n                    ans++;\\n            }\\n        }\\n        flag = !flag;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195981,
                "title": "simple-and-short-solution-o-n",
                "content": "All asterisks after even number of bars are outside any pair of two bars.\\nSo just count the asterisks that appear after even number of bars till now.\\n\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int bars = 0, asterisks = 0;\\n        for(char c: s) {\\n            if(c == \\'|\\') bars++;\\n            else if(c == \\'*\\' and bars % 2 == 0) asterisks++;\\n        }\\n        return asterisks;\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int bars = 0, asterisks = 0;\\n        for(char c: s) {\\n            if(c == \\'|\\') bars++;\\n            else if(c == \\'*\\' and bars % 2 == 0) asterisks++;\\n        }\\n        return asterisks;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195867,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a67de4e975be771355e048bf8dde4cf0906e360) for solutions of biweekly 81. \\n\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        return sum(w.count(\\'*\\') for i, w in enumerate(s.split(\\'|\\')) if not i&1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        return sum(w.count(\\'*\\') for i, w in enumerate(s.split(\\'|\\')) if not i&1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195847,
                "title": "python-linear-solution-comments",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        isPair = False # tracks pair of \"|\" \\n        \\n        for i in range(n):\\n            # if * is outside of a pair add to result\\n            if not isPair and s[i] == \"*\":\\n                res += 1\\n                \\n            # track \"|\" pair by boolean toggle\\n            if s[i] == \"|\":\\n                isPair = not isPair\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        n = len(s)\\n        res = 0\\n        isPair = False # tracks pair of \"|\" \\n        \\n        for i in range(n):\\n            # if * is outside of a pair add to result\\n            if not isPair and s[i] == \"*\":\\n                res += 1\\n                \\n            # track \"|\" pair by boolean toggle\\n            if s[i] == \"|\":\\n                isPair = not isPair\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195813,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt = 0;\\n        int noOfBar = 0;\\n        \\n        for(int i=0;i<size(s);i++)\\n            if(s[i] == \\'|\\') noOfBar++;\\n            else if(noOfBar%2 == 0 and s[i] == \\'*\\') ++cnt;\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt = 0;\\n        int noOfBar = 0;\\n        \\n        for(int i=0;i<size(s);i++)\\n            if(s[i] == \\'|\\') noOfBar++;\\n            else if(noOfBar%2 == 0 and s[i] == \\'*\\') ++cnt;\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095609,
                "title": "odd-even-simple",
                "content": "# Intuition\\n### by looking at constrains, you can tell that this question is about odd-even \\n# Approach\\n**if |\\'s count is even,then add count**\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int c=0,cp=0;\\n        for(int i=0; i<s.length(); i++){\\n            if (s.charAt(i)==\\'|\\'){\\n                c++;\\n            }\\n            if (s.charAt(i)==\\'*\\' && c % 2 ==0){\\n                cp++;\\n            }\\n        }\\n        return cp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int c=0,cp=0;\\n        for(int i=0; i<s.length(); i++){\\n            if (s.charAt(i)==\\'|\\'){\\n                c++;\\n            }\\n            if (s.charAt(i)==\\'*\\' && c % 2 ==0){\\n                cp++;\\n            }\\n        }\\n        return cp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091455,
                "title": "php-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countAsterisks($s) {\\n        $s = explode(\"|\",$s);\\n        $result = 0;\\n        $count = count($s);\\n        for($i = 0;$i < $count;$i = $i+2){\\n          $result+= substr_count($s[$i],\\'*\\');\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countAsterisks($s) {\\n        $s = explode(\"|\",$s);\\n        $result = 0;\\n        $count = count($s);\\n        for($i = 0;$i < $count;$i = $i+2){\\n          $result+= substr_count($s[$i],\\'*\\');\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086250,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int: \\n        return sum(w.count(\\'*\\') for w in islice(s.split(\\'|\\'), 0, None, 2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int: \\n        return sum(w.count(\\'*\\') for w in islice(s.split(\\'|\\'), 0, None, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086019,
                "title": "java-easy-solution-100-00-faster-69-52-efficient-1-ms",
                "content": "class Solution {\\n    public int countAsterisks(String s) {\\n        char[] arr = s.toCharArray();\\n        int c = 0;\\n        int p = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'*\\' && p == 0){\\n                c++;\\n            }else if(ch == \\'|\\'){\\n                p++;\\n                if(p > 1){\\n                    p = 0;\\n                    continue;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int countAsterisks(String s) {\\n        char[] arr = s.toCharArray();\\n        int c = 0;\\n        int p = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            char ch = arr[i];\\n            if(ch == \\'*\\' && p == 0){\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4085693,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        int bars = 0;\\n\\n        for (final char c : s.toCharArray()) {\\n        if (c == \\'|\\')\\n            ++bars;\\n        else if (c == \\'*\\' && bars % 2 == 0)\\n            ++ans;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        int bars = 0;\\n\\n        for (final char c : s.toCharArray()) {\\n        if (c == \\'|\\')\\n            ++bars;\\n        else if (c == \\'*\\' && bars % 2 == 0)\\n            ++ans;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084342,
                "title": "python-solution-using-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        s1=0\\n        e=0\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'*\\' and s1==0 and e==0:\\n                c=c+1\\n            elif s[i]==\\'|\\' and s1==0 and e==0:\\n                s1=1\\n            elif s[i]==\\'|\\' and s1==1 and e==0:\\n                s1=0\\n            else:\\n                pass\\n        return c\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        s1=0\\n        e=0\\n        c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'*\\' and s1==0 and e==0:\\n                c=c+1\\n            elif s[i]==\\'|\\' and s1==0 and e==0:\\n                s1=1\\n            elif s[i]==\\'|\\' and s1==1 and e==0:\\n                s1=0\\n            else:\\n                pass\\n        return c\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083499,
                "title": "simple-0-n-complexity-python3-approach",
                "content": "# Intuition\\nIf count of bar(\"|\") is even then we count the number of succeding astriks(\"*\"), but if bar\\'s count is off then we do not count the succeding astriks.\\n\\n# Approach\\nSimple for loop and if-else statement approach.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count = 0\\n        as_count = 0\\n        j = 0\\n        #if astriks is present before the first bar then it is counted therefore, we need to count the initial astriks.\\n        for j  in range(len(s)):\\n            if(s[j] ==\"|\"):\\n                break\\n            elif(s[j] == \"*\"):\\n                as_count = as_count + 1\\n            else:\\n                continue\\n        for i in range(len(s)):\\n            if(s[i] == \"|\"):\\n                count = count + 1\\n            if(count != 0 and count != 1 and count%2 == 0):\\n                    if(s[i] == \"*\"):\\n                        as_count = as_count + 1\\n        return as_count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        count = 0\\n        as_count = 0\\n        j = 0\\n        #if astriks is present before the first bar then it is counted therefore, we need to count the initial astriks.\\n        for j  in range(len(s)):\\n            if(s[j] ==\"|\"):\\n                break\\n            elif(s[j] == \"*\"):\\n                as_count = as_count + 1\\n            else:\\n                continue\\n        for i in range(len(s)):\\n            if(s[i] == \"|\"):\\n                count = count + 1\\n            if(count != 0 and count != 1 and count%2 == 0):\\n                    if(s[i] == \"*\"):\\n                        as_count = as_count + 1\\n        return as_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082614,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n       int ans = 0, k = 0, cnt = 0, n = s.size(), i = 0;\\n       for(auto x: s){\\n           i++;\\n           if(x == \\'*\\')\\n                cnt++;\\n           if(x == \\'|\\' || i == n){\\n                k++;\\n            if(k % 2 == 1)\\n                ans += cnt;\\n             cnt = 0;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n       int ans = 0, k = 0, cnt = 0, n = s.size(), i = 0;\\n       for(auto x: s){\\n           i++;\\n           if(x == \\'*\\')\\n                cnt++;\\n           if(x == \\'|\\' || i == n){\\n                k++;\\n            if(k % 2 == 1)\\n                ans += cnt;\\n             cnt = 0;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077963,
                "title": "simple-and-intuitive-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0,cnt = 0;\\n        for(char ch: s)\\n        {\\n            if(ch==\\'*\\')\\n                ans++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt = 0;\\n            if(s[i] == \\'|\\'){\\n                i++;\\n                while(i<s.length()&&s[i]!=\\'|\\')\\n                {\\n                    if(s[i]==\\'*\\')\\n                        cnt++;\\n                    i++;\\n                }\\n            }\\n            if(i<s.length() && s[i]!=\\'|\\')\\n                cnt = 0;\\n            ans-=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int ans = 0,cnt = 0;\\n        for(char ch: s)\\n        {\\n            if(ch==\\'*\\')\\n                ans++;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt = 0;\\n            if(s[i] == \\'|\\'){\\n                i++;\\n                while(i<s.length()&&s[i]!=\\'|\\')\\n                {\\n                    if(s[i]==\\'*\\')\\n                        cnt++;\\n                    i++;\\n                }\\n            }\\n            if(i<s.length() && s[i]!=\\'|\\')\\n                cnt = 0;\\n            ans-=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076478,
                "title": "100-beat-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0,c=0;\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(count%2==0)\\n            {\\n                if(s[i]==\\'*\\')\\n                c++;\\n            }\\n            \\n            if(s[i]==\\'|\\')\\n            {count++;}\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int count=0,c=0;\\n\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(count%2==0)\\n            {\\n                if(s[i]==\\'*\\')\\n                c++;\\n            }\\n            \\n            if(s[i]==\\'|\\')\\n            {count++;}\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075716,
                "title": "simple-java-solution-100-beats-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int bar =0, answer =0;\\n        // iterate through the array.\\n        for(char c:s.toCharArray()){\\n            // if current character is \\'|\\' then increse the count of bar.\\n            if(c == \\'|\\') bar++;\\n            // else if current character is \\'*\\'  and number of bar is multiple of two \\n            // then increse the answer of asterisks count.\\n            else if(c == \\'*\\' && bar%2 == 0){\\n                answer++;\\n            }\\n        }\\n        // return your naswer.\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int bar =0, answer =0;\\n        // iterate through the array.\\n        for(char c:s.toCharArray()){\\n            // if current character is \\'|\\' then increse the count of bar.\\n            if(c == \\'|\\') bar++;\\n            // else if current character is \\'*\\'  and number of bar is multiple of two \\n            // then increse the answer of asterisks count.\\n            else if(c == \\'*\\' && bar%2 == 0){\\n                answer++;\\n            }\\n        }\\n        // return your naswer.\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075538,
                "title": "0ms-using-java-simple-approach",
                "content": "# EXPLANATION\\n\\n* int count = 0;: Initialize a variable count to keep track of the number of asterisks.\\n\\n* boolean insidePair = false;: Initialize a boolean variable insidePair to false. This variable acts as a flag to determine whether we are currently inside a pair of vertical bars or not.\\n\\n* for (char c : s.toCharArray()) {: Start iterating through each character c in the input string s.\\n\\n* if (c == \\'|\\') {: Check if the current character is a vertical bar (\\'|\\').\\n\\n* insidePair = !insidePair;: Toggle the insidePair flag. If it was false, it becomes true, and vice versa. This means we switch between being inside and outside of a pair of vertical bars.\\n\\n* else if (c == \\'*\\' && insidePair == false) {: If the current character is an asterisk (\\'*\\') and we are not inside a pair (i.e., insidePair is false), then:\\n\\n* count++;: Increment the count by 1. This means we found an asterisk that is outside of any pair.\\n\\n* Finally, the method returns the count, which represents the total count of asterisks outside of pairs in the input string.\\n\\n**REMEMBER** : You can also use other method like first count \\'|\\' then if count%2==0 then program should count the \\'|\\' , else you can use boolean value that if the boolean value is false that\\'s mean our \\'|\\' isn\\'t in between \\'|\\' then our program should count the \\'|\\' both the approaches are fine.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n         int count = 0;\\n    boolean insidePair = false;  \\n    \\n    for (char c : s.toCharArray()) {\\n        if (c == \\'|\\') {\\n            insidePair = !insidePair;  \\n        } else if (c == \\'*\\' && insidePair==false) {\\n            count++; \\n        }\\n    \\n    }return count;}}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n         int count = 0;\\n    boolean insidePair = false;  \\n    \\n    for (char c : s.toCharArray()) {\\n        if (c == \\'|\\') {\\n            insidePair = !insidePair;  \\n        } else if (c == \\'*\\' && insidePair==false) {\\n            count++; \\n        }\\n    \\n    }return count;}}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072641,
                "title": "java-solution-with-boolean-pair-flag",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust take boolean flag. If area is paired area, then flag is true. If flag is true then don\\'t count stars. If you left paired area, then can contiune count stars. Just one counter, one loop.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean pairFlag = false;\\n        int countOfStars = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n           if(s.charAt(i) == \\'|\\')\\n               pairFlag = !pairFlag;\\n           if (s.charAt(i) == \\'*\\' && !pairFlag)\\n               countOfStars++;\\n        }\\n        \\n        return countOfStars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean pairFlag = false;\\n        int countOfStars = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n           if(s.charAt(i) == \\'|\\')\\n               pairFlag = !pairFlag;\\n           if (s.charAt(i) == \\'*\\' && !pairFlag)\\n               countOfStars++;\\n        }\\n        \\n        return countOfStars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072522,
                "title": "assterisks-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean ass = false;\\n        int count=0;\\n        char [] arr = s.toCharArray();\\n        for(char ch:arr){\\n            if(ass==false && ch==\\'*\\') count++;\\n            if(ch==\\'|\\') ass=!ass;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        boolean ass = false;\\n        int count=0;\\n        char [] arr = s.toCharArray();\\n        for(char ch:arr){\\n            if(ass==false && ch==\\'*\\') count++;\\n            if(ch==\\'|\\') ass=!ass;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068843,
                "title": "count-asterisks-solution-1ms-bcr",
                "content": "# Approach\\n\\n1. **Check for Edge Cases**: Check if the input string `s` is `null` or `empty`. If it is, return `ans` immediately. This handles the case where there are no asterisks to count.\\n\\n2. **Iterate Through Characters**: Use a `for-each` loop to iterate through each character (c) in the input string `s`.\\n\\n3. **Toggle Inside a Pair Flag**: If `c` is a vertical bar (`\\'|\\'`), toggle the `isInsideAPair` flag. This flag keeps track of whether the current character is inside a pair of vertical bars.\\n\\n4. **Count Asterisks**: If `c` is not inside a pair (`!isInsideAPair`) and is an asterisk (`\\'*\\'`), increment `ans`. This means you\\'ve found an asterisk that should be counted.\\n\\n5. **Return the Count**: After iterating through all the characters, return the final value of `ans`, which represents the count of asterisks excluding those between pairs of vertical bars.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        boolean isInsideAPair = false;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'|\\') {\\n                isInsideAPair = !isInsideAPair;\\n            } else if (!isInsideAPair && c == \\'*\\') {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int ans = 0;\\n        if (s == null || s.length() == 0) {\\n            return ans;\\n        }\\n        boolean isInsideAPair = false;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'|\\') {\\n                isInsideAPair = !isInsideAPair;\\n            } else if (!isInsideAPair && c == \\'*\\') {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066408,
                "title": "linear-scan-with-2-modes-time-o-n-space-o-1",
                "content": "# Intuition\\n\\nThe problem states that we should count the number of asterisks (`*`) in the string only if they are outside of a pair of `|` characters. This can be solved with a linear scan with two modes (inside a pair, between pairs). When the scanner finds a `|` character, it switches modes.\\n\\n# Approach\\n\\n1. Create a variable to hold the number of asterisks seen so far, `result`.\\n2. Create a variable to track which mode the scanner is in.\\n3. Scan each character in the string:\\n    1. If the character is an asterisks,\\n        2. And the scanner is in the \"between pairs\" mode\\n            3. Increment `result`\\n    4. If the character is a `|`\\n        5. Switch modes\\n6. Return the result \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\nThis algorithm always scans every character in the string, so the time complexity is $$O(n)$$.\\n\\n- Space complexity: $$O(1)$$\\n\\nSince the algorithm uses 2 variables during its runtime, so the space complexity is $$O(1)$$\\n\\n# Code\\n```\\nfunction countAsterisks(s: string): number {\\n  let result = 0;\\n  let betweenPairs = true;\\n\\n  for (const c of s) {\\n    if (c === \\'*\\') {\\n      if (betweenPairs) result++;\\n    } else if (c === \\'|\\') {\\n      betweenPairs = !betweenPairs;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction countAsterisks(s: string): number {\\n  let result = 0;\\n  let betweenPairs = true;\\n\\n  for (const c of s) {\\n    if (c === \\'*\\') {\\n      if (betweenPairs) result++;\\n    } else if (c === \\'|\\') {\\n      betweenPairs = !betweenPairs;\\n    }\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065546,
                "title": "very-simple-and-beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA very simple approach. Just one loop required.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstrp 1- cnt=0 and bar=0 to keep track of no of astericks and bar respectively.\\nstep 2- start loop from i=0 to n-1\\nstep 3- if opening bar(bar=0) comes then increment bar by 1 else decrement when closing bar(bar=1) is encountered\\nstep 4- increment cnt if there\\'s no pair of bars i.e. bar==0\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt=0;\\n        int bar=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(s[i]==\\'|\\' && bar==0) {\\n                bar++;\\n            }\\n            else if(s[i]==\\'|\\' && bar==1) {\\n                bar--;\\n            }\\n            if(bar==0 && s[i]==\\'*\\') {\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countAsterisks(string s) {\\n        int cnt=0;\\n        int bar=0;\\n        for(int i=0; i<s.size(); i++) {\\n            \\n            if(s[i]==\\'|\\' && bar==0) {\\n                bar++;\\n            }\\n            else if(s[i]==\\'|\\' && bar==1) {\\n                bar--;\\n            }\\n            if(bar==0 && s[i]==\\'*\\') {\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065298,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int c1=0;\\n        int c2=0;\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)==\\'|\\'){\\n               c1++;\\n           }\\n           if(c1%2==0){\\n               if(s.charAt(i)==\\'*\\'){\\n                   c2++;\\n               }\\n           }\\n       }\\n       return c2; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        int c1=0;\\n        int c2=0;\\n       for(int i=0;i<s.length();i++){\\n           if(s.charAt(i)==\\'|\\'){\\n               c1++;\\n           }\\n           if(c1%2==0){\\n               if(s.charAt(i)==\\'*\\'){\\n                   c2++;\\n               }\\n           }\\n       }\\n       return c2; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065136,
                "title": "runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        char []chars = s.toCharArray();\\n        int indexOfAstrik = 0;\\n        int count =0;\\n        for (int i=0;i<chars.length; i++){\\n            if (chars[i]==\\'|\\'){\\n                indexOfAstrik++;\\n            }\\n            if(chars[i]==\\'*\\' && indexOfAstrik%2==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countAsterisks(String s) {\\n        char []chars = s.toCharArray();\\n        int indexOfAstrik = 0;\\n        int count =0;\\n        for (int i=0;i<chars.length; i++){\\n            if (chars[i]==\\'|\\'){\\n                indexOfAstrik++;\\n            }\\n            if(chars[i]==\\'*\\' && indexOfAstrik%2==0){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1918996,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1733301,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1815200,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 2018321,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1997135,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1938474,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1934667,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1779255,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1693817,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1709939,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1918996,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1733301,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1815200,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 2018321,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1997135,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1938474,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1934667,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1779255,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1693817,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            },
            {
                "id": 1709939,
                "content": [
                    {
                        "username": "ASWINNATH123",
                        "content": "description is not given correctly is actually confusing to choose the pairs\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "One Simple Approach could be - We can split the string into array. Then we will iterate only on even indexes to find the count of `*`"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "in fact asterisks on the ends are counted so description might be misleading\\n*|*e*et|* = 2"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "In case anyone is confused, here is the tip for you:\\n1. Split the array by |\\n2. Loop on it and check if the i %2 ==0 \\n3. if yes then take that word from array and loop on it\\n4. now check if word[i] == \\'*\\', if yes then increase count else skip"
                    },
                    {
                        "username": "abhisheksingh78617",
                        "content": "[@kaushalkrgupta02](/kaushalkrgupta02) after splitting the string, you\\'ll get the array, \\nnow execute a for loop for splitted Array\\nso here i is your index(int) so you can apply the % here"
                    },
                    {
                        "username": "kaushalkrgupta02",
                        "content": "how comes you check i%2==0 as splitted arr is in str not int\\n"
                    },
                    {
                        "username": "dhwyaan",
                        "content": "In both examples (1 and 3), the vertical bars considered aren\\'t 1st and 2nd; 3rd and 4th as described, the ones considered are 0th and 1st; 2nd and 3rd and so on"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hey, can someone please specify the task for me, because I'm quite confusing to be honest.\nHere is my approach\n```\nclass Solution:\n    def countAsterisks(self, s: str) -> int:\n        parts = s.split('|')\n\n        max_cnt = 0\n\n        for part in parts:\n            max_cnt = max(max_cnt, part.count('*'))\n\n        return max_cnt\n```\n\nAnd with this test input I get an error \"yo|uar|e**|b|e***au|tifu|l\"\nMy output is 3 and expected ouyput is 5. Can someone explain to me please why 5 is the right for this data?"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Thanks, I don\\'t know why I ignored the description and didn\\'t read explanation, for some reason I looked for the maximum number of * between two |, but the task isn\\'t about it. Thanks for pointing this out"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "[@Stepash_ka](/Stepash_ka) \\nwe count stars between blocks\\nblocks are 1st and 2nd quotes, 3rd and 4th, and so on.\\nin other words, as soon as we meet an even quote, we start counting asterisks"
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "[@oleg-mng](/oleg-mng) Still don\\'t get it, can you provide some more examples please of test data and expected output, because I can see that we need to find the maximum number of * enclosed with | symbol, so I don\\'t get why here the answer is 2 \"l|*e*et|c**o|*de|\" and here is 5 \"yo|uar|e**|b|e***au|tifu|l\""
                    },
                    {
                        "username": "oleg-mng",
                        "content": "yo   |uar|    e**     |b|    e***au   |tifu|   l\\nwe need to count the number of asterisks between expressions in pairwise vertical brackets\\ncontent inside brackets is not considered"
                    },
                    {
                        "username": "oleg-mng",
                        "content": "the description is also a bit confusing, in fact we count asterisks as if only between blocks |...|"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "0ms solution Just Focus on occurrence of | <br>\\nHint our answer increases when | count is 0  .<br>\\nSolution link :-> https://leetcode.com/problems/count-asterisks/solutions/3113185/0ms-100-fastest-c-easy-and-simple-solution/"
                    },
                    {
                        "username": "Bobzero",
                        "content": "I come up with idea of using the split method to store the pairs of words into the array and then start counting the asterisks accordingly, but the thing is I couldn't store the words into the array when I said  `String[] arr = s.split(\"|\");`.... I know there is a proper solution for this question but I wonder why it didn't work though.."
                    },
                    {
                        "username": "AmanSinghRajawat",
                        "content": "try with this ``` string.split(\"\\\\\\\\|\"); ```"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "\\n\\nUse escape character before | like below:\\n\\nString[] res = \"12345|6\".split(\"\\\\\\\\|\");\\nSimilar \"escape character logic\" is required, when you are dealing/splitting with any of the below special characters (used by Regular Expression):\\n\\nOR sign (|)\\nquestion mark (?)\\nasterisk (*)\\nplus sign (+)\\nbackslash (\\\\)\\nperiod (.)\\ncaret (^)\\nsquare brackets ([ and ])\\ndollar sign ($)\\nampersand (&)"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@oscargaytan](/oscargaytan) May I know why?"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Just use `s.Split(\\'|\\');`"
                    },
                    {
                        "username": "oscargaytan",
                        "content": "try with `s.split(\"\\\\\\\\|\");`  instead"
                    },
                    {
                        "username": "angshuman_coder",
                        "content": "Here the solution is easy and simple the approach is that we hav eto take two counters one which will count the number of asterisk and the one which will count the number of bars is the string of i encounters a | then it will count in the number of bars and in the next if statement we will check if the number of bars %2==0 and if the string[i] ==* if it is true then the count for  the asterisk will be incremented "
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Increasing Paths in a Grid",
        "question_content": "<p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p>\n\n<p>Return <em>the number of <strong>strictly</strong> <strong>increasing</strong> paths in the grid such that you can start from <strong>any</strong> cell and end at <strong>any</strong> cell. </em>Since the answer may be very large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>\n\n<p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/10/griddrawio-4.png\" style=\"width: 181px; height: 121px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,1],[3,4]]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> The strictly increasing paths are:\n- Paths with length 1: [1], [1], [3], [4].\n- Paths with length 2: [1 -&gt; 3], [1 -&gt; 4], [3 -&gt; 4].\n- Paths with length 3: [1 -&gt; 3 -&gt; 4].\nThe total number of paths is 4 + 3 + 1 = 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[1],[2]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The strictly increasing paths are:\n- Paths with length 1: [1], [2].\n- Paths with length 2: [1 -&gt; 2].\nThe total number of paths is 2 + 1 = 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= grid[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2229819,
                "title": "c-python-top-down-dp",
                "content": "## Observation\\n\\nLet\\'s try to solve the 1D version of this problem. We are given the following array and we can only move forward:\\n\\n`[1,2,3,4,3]`. How do we find the number of increasing sequences?\\n\\n Let\\'s try to pick each element/index as our starting point and find the answer. `1 -> [1,2,3,4] = 4`, `2 -> [2,3,4] = 3`, `3-> [3,4] = 2`, `[4] = 1`, `[3] = 1`. Summing these individual values will produce the answer. But what do these individual results essentially mean? \\n\\nLet\\'s look at `[1,2,3,4] = 4`, this means starting from 1 we have a total of 4 increasing sequences/paths. `[1,2,3,4]`,  `[1,2,3]`,  `[1,2]`,  `[1]`. We are calculating the same for each starting point.\\n\\nThe 2D version is similar as it forms a DAG and hence are no cycles in the graph/path.\\n\\nThese observations are the only thing we need to understand and we can do the same in the converted/complex problem with 2D grid and 4 directional movement. For a 2D grid for each starting cell you find the number of elements/cell in the longest possible increasing path for all directions and the sum of all these results will be the answer.\\n\\n## Solution\\n\\nWe use top-down DP to store the intermediate results, each state `i,j` could be called multiple times and we can cache the results and thus bring down the time complexity.\\n\\n### C++\\n```c++\\nstatic int MOD=1e9+7;\\nstatic vector<int> dirs={0,1,0,-1,0};\\nclass Solution {\\npublic:\\n    vector<vector<long>> memo;\\n    long dp(vector<vector<int>>& grid,int i,int j) {\\n        long result=1;  // Contribution of current cell as an increasing sequence.\\n        if(memo[i][j]!=-1)  // Return the cached results if they exist.\\n            return memo[i][j];\\n        for(int d=0;d<4;d++) {  // Check all 4 directions.\\n            int x=i+dirs[d],y=j+dirs[d+1];\\n            if(x>=0&&y>=0&&x<grid.size()&&y<grid[0].size()&&grid[x][y]>grid[i][j])\\n                result=(result+dp(grid,x,y))%MOD;       // Add the total number of cells in the longest path for all directions.\\n        }\\n        return memo[i][j]=result;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        long result=0;\\n        memo.resize(grid.size(),vector<long>(grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++)      // For each cell as a starting point calculate the number of increasing paths it can contribute.\\n            for(int j=0;j<grid[0].size();j++)\\n                result=(result+dp(grid,i,j))%MOD;\\n        return result;\\n    }\\n};\\n```\\n\\n### Python\\n\\nPlease upvote [@tojuna\\'s](https://leetcode.com/tojuna/) python solution in the comments below. Credits  [@tojuna](https://leetcode.com/tojuna/).\\n\\n```python\\ndef countPaths(self, A: List[List[int]]) -> int:\\n    m, n, mod, dirs = len(A), len(A[0]), (10 ** 9) + 7, [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n    @cache\\n    def dp(i, j):\\n        return sum((1 + dp(i + x, j + y)) for x, y in dirs if 0 <= i + x < m and 0 <= j + y < n and A[i + x][j + y] > A[i][j]) % mod\\n    return (sum(dp(i, j) % mod for i in range(m) for j in range(n)) + (m * n)) % mod\\n```\\n\\n## Complexity\\n**Space:** `O(mn)`. Due to memoization.\\n**Time** `O(4mn) = O(mn)`. At each recursion at max you have 4 directions thus `O(1)` further calls and we have a total of `m*n` states for the DP.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```c++\\nstatic int MOD=1e9+7;\\nstatic vector<int> dirs={0,1,0,-1,0};\\nclass Solution {\\npublic:\\n    vector<vector<long>> memo;\\n    long dp(vector<vector<int>>& grid,int i,int j) {\\n        long result=1;  // Contribution of current cell as an increasing sequence.\\n        if(memo[i][j]!=-1)  // Return the cached results if they exist.\\n            return memo[i][j];\\n        for(int d=0;d<4;d++) {  // Check all 4 directions.\\n            int x=i+dirs[d],y=j+dirs[d+1];\\n            if(x>=0&&y>=0&&x<grid.size()&&y<grid[0].size()&&grid[x][y]>grid[i][j])\\n                result=(result+dp(grid,x,y))%MOD;       // Add the total number of cells in the longest path for all directions.\\n        }\\n        return memo[i][j]=result;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        long result=0;\\n        memo.resize(grid.size(),vector<long>(grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++)      // For each cell as a starting point calculate the number of increasing paths it can contribute.\\n            for(int j=0;j<grid[0].size();j++)\\n                result=(result+dp(grid,i,j))%MOD;\\n        return result;\\n    }\\n};\\n```\n```python\\ndef countPaths(self, A: List[List[int]]) -> int:\\n    m, n, mod, dirs = len(A), len(A[0]), (10 ** 9) + 7, [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n    @cache\\n    def dp(i, j):\\n        return sum((1 + dp(i + x, j + y)) for x, y in dirs if 0 <= i + x < m and 0 <= j + y < n and A[i + x][j + y] > A[i][j]) % mod\\n    return (sum(dp(i, j) % mod for i in range(m) for j in range(n)) + (m * n)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650111,
                "title": "java-c-python-solution-easy-to-understand",
                "content": "# :) Guys Please VoteUp\\nThe code provided seems to be solving a problem related to counting paths in a grid. However, without a clear problem statement, it\\'s difficult to provide specific intuition.\\n\\n# Approach\\nThe code uses a dynamic programming approach to count the number of paths in the given grid. It employs memoization to avoid redundant calculations. The countPaths method initializes a 2D array dp to store the number of paths for each grid cell. It then iterates through each cell in the grid and calls the solve method to calculate the number of paths starting from that cell.\\n\\nThe solve method takes the current grid, cell coordinates, the previous value (for comparison), and the memoization array dp. It first checks the base cases: if the current cell is out of bounds or has a value less than or equal to the previous value, it returns 0. If the result for the current cell is already calculated and stored in dp, it directly returns the stored value.\\n\\nIf the base cases are not met, the method recursively calls itself for the left, right, up, and down neighboring cells. It passes the current cell value as the new previous value to ensure that paths only move to cells with greater values. The results from these recursive calls are summed up, and 1 is added to account for the current cell. The sum is then stored in dp for memoization.\\n\\nFinally, the countPaths method returns the total number of paths calculated for all cells in the grid\\n\\n# Complexity\\nTime complexity: The time complexity of the countPaths method is O(n * m), where n and m are the dimensions of the grid. This is because it iterates through each cell in the grid exactly once. The solve method has recursive calls, but each cell\\'s result is memoized, ensuring that each cell is calculated only once.\\n\\nSpace complexity: The space complexity of the code is O(n * m) as well. It is determined by the memoization array dp, which has the same dimensions as the grid. The memory usage is proportional to the number of cells in the grid.\\n\\nOverall, the code uses a dynamic programming approach with memoization to efficiently calculate the number of paths in a grid.\\n\\n\\n\\n#  Java Code\\n```\\nclass Solution {\\n    int mod = (int)(1e9+7);\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        for(int[] arr: dp){\\n            Arrays.fill(arr, -1);\\n        }\\n        int paths = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                paths = (paths+solve(grid, i, j, -1, dp))%mod;\\n            }\\n        }\\n        \\n        return paths;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int prev, int[][] dp){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int left = solve(grid, i, j-1, grid[i][j], dp);\\n        int right = solve(grid, i, j+1, grid[i][j], dp);\\n        int up = solve(grid, i-1, j, grid[i][j], dp);\\n        int down = solve(grid, i+1, j, grid[i][j], dp);\\n        \\n        return dp[i][j] = (1+left+right+up+down)%mod;\\n    }\\n}\\n```\\n#  C++ Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int Helper(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp, int prev)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || prev>=grid[i][j])\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int top =  Helper(grid,i-1,j,dp,grid[i][j]);\\n        int bottom =  Helper(grid,i+1,j,dp,grid[i][j]);\\n        int right = Helper(grid,i,j+1,dp,grid[i][j]);\\n        int left =  Helper(grid,i,j-1,dp,grid[i][j]);\\n        \\n        dp[i][j] = (1 + top + bottom + right + left)%1000000007; // it will give signed integer overflow run time error if you do not modulo at this point of code\\n        return dp[i][j];\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 && n==1)\\n            return 1;\\n        vector<vector<int> > dp(m,vector<int> (n,-1));\\n        \\n        int ans =0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                  ans = (ans + Helper(grid,i,j,dp,-1))%1000000007;\\n                else\\n                  ans = (ans + dp[i][j])%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n#  Python3 Code\\n\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        noOfRows, noOfCols, res = len(grid), len(grid[0]), 0\\n        dp = [[-1 for _ in range(noOfCols)] for _ in range(noOfRows)]\\n        \\n        def dfs(row: int, col: int, prev: int, dp: List[List[int]], grid: List[List[int]]) -> int:\\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            ans = 1\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                ans += dfs(newRow, newCol, grid[row][col], dp, grid)\\n            dp[row][col] = ans\\n            return ans\\n        \\n        for row in range(noOfRows):\\n            for col in range(noOfCols):\\n                res += dfs(row, col, -1, dp, grid)\\n        return res % (10 ** 9 + 7)\\n```\\n\\n# Java Code Explaination\\nThe code represents a Solution class with two methods: countPaths and solve. Here\\'s an explanation of each part:\\n\\nThe class-level variable mod is set to (int)(1e9+7), which is a common approach to store a large constant value for modulo operations.\\n\\nThe countPaths method takes a 2D grid as input and returns the total number of paths. It initializes variables n and m with the dimensions of the grid. It also creates a 2D array dp with the same dimensions to store the number of paths for each cell.\\n\\nThe dp array is initialized with -1 using the Arrays.fill method. This is done to indicate that the paths for each cell have not been calculated yet.\\n\\nThe paths variable is initialized to 0 to store the cumulative number of paths.\\n\\nThe nested for loops iterate through each cell in the grid using the variables i and j.\\n\\nWithin the loops, the solve method is called for each cell to calculate the number of paths starting from that cell. The solve method is passed the grid, the current cell coordinates (i and j), the previous value (initialized as -1), and the dp array.\\n\\nThe solve method first checks if the current cell is out of bounds or if its value is less than or equal to the previous value. If so, it returns 0 indicating that no paths are possible from that cell.\\n\\nIf the base cases are not met, the method checks if the result for the current cell has already been calculated and stored in the dp array. If so, it directly returns the stored value.\\n\\nIf the base cases are not met and the result is not stored in dp, the method proceeds to recursively call itself for the neighboring cells (left, right, up, and down). It passes the current cell\\'s value as the new previous value to ensure that paths only move to cells with greater values.\\n\\nThe results from the recursive calls (left, right, up, and down) are summed up, and 1 is added to account for the current cell. The modulo operation % mod is applied to keep the result within the given modulo value.\\n\\nFinally, the calculated result is stored in the dp array for memoization, and it is also returned as the result of the solve method.\\n\\nThe cumulative paths variable in the countPaths method is updated by adding the result of the solve method for each cell. The modulo operation % mod is applied to keep the result within the given modulo value.\\n\\nAfter iterating through all the cells, the paths variable contains the total number of paths in the grid, and it is returned as the final result of the countPaths method.\\n\\nIn summary, the code uses a dynamic programming approach with memoization to efficiently calculate the number of paths in a grid. The solve method handles the recursive calculation for each cell, storing intermediate results in the dp array to avoid redundant calculations. The countPaths method orchestrates the process by iterating through each cell and accumulating the results.\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(1e9+7);\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        for(int[] arr: dp){\\n            Arrays.fill(arr, -1);\\n        }\\n        int paths = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                paths = (paths+solve(grid, i, j, -1, dp))%mod;\\n            }\\n        }\\n        \\n        return paths;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int prev, int[][] dp){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int left = solve(grid, i, j-1, grid[i][j], dp);\\n        int right = solve(grid, i, j+1, grid[i][j], dp);\\n        int up = solve(grid, i-1, j, grid[i][j], dp);\\n        int down = solve(grid, i+1, j, grid[i][j], dp);\\n        \\n        return dp[i][j] = (1+left+right+up+down)%mod;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int Helper(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp, int prev)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || prev>=grid[i][j])\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int top =  Helper(grid,i-1,j,dp,grid[i][j]);\\n        int bottom =  Helper(grid,i+1,j,dp,grid[i][j]);\\n        int right = Helper(grid,i,j+1,dp,grid[i][j]);\\n        int left =  Helper(grid,i,j-1,dp,grid[i][j]);\\n        \\n        dp[i][j] = (1 + top + bottom + right + left)%1000000007; // it will give signed integer overflow run time error if you do not modulo at this point of code\\n        return dp[i][j];\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(m==1 && n==1)\\n            return 1;\\n        vector<vector<int> > dp(m,vector<int> (n,-1));\\n        \\n        int ans =0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                  ans = (ans + Helper(grid,i,j,dp,-1))%1000000007;\\n                else\\n                  ans = (ans + dp[i][j])%1000000007;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        noOfRows, noOfCols, res = len(grid), len(grid[0]), 0\\n        dp = [[-1 for _ in range(noOfCols)] for _ in range(noOfRows)]\\n        \\n        def dfs(row: int, col: int, prev: int, dp: List[List[int]], grid: List[List[int]]) -> int:\\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            ans = 1\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                ans += dfs(newRow, newCol, grid[row][col], dp, grid)\\n            dp[row][col] = ans\\n            return ans\\n        \\n        for row in range(noOfRows):\\n            for col in range(noOfCols):\\n                res += dfs(row, col, -1, dp, grid)\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230147,
                "title": "python-topo-dp-solution-and-dfs-solution",
                "content": "# **Intuition**\\nBecause we want strictly increasing paths,\\nthere is no cycle of path.\\nWe can iterative all `A[i][j]` in increasing order.\\n<br>\\n\\n# **Explanation**\\n`dp[i][j]` means the number of paths ending at `A[i][j]`.\\nWe initial all `dp[i][j] = 1`.\\n\\nBecause we want strictly increasing paths, there is no cycle of path.\\nWe iterative all `A[i][j]` in increasing order,\\n`d[i][j] += dp[x][y] from smaller neighbours`.\\n\\nFinally return the sum of `dp`.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn^2log(m+n))`\\nSpace `O(mn)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def countPaths(self, A):\\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\\n        dp = [[1] * n for i in range(m)]\\n        for a, i, j in sorted([A[i][j], i, j] for i in range(m) for j in range(n)):\\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\\n                    dp[i][j] += dp[x][y] % mod\\n        return sum(map(sum, dp)) % mod\\n```\\n<br>\\n\\n# Solution 2: DFS\\nTime `O(mn)`\\nSpace `O(mn)`\\n```py\\n    def countPaths(self, A):\\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\\n\\n        @lru_cache(None)\\n        def count(i, j):\\n            res = 1\\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\\n                    res += count(x, y) % mod\\n            return res\\n\\n        return sum(count(i,j) for i in range(m) for j in range(n)) % mod\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```py\\n    def countPaths(self, A):\\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\\n        dp = [[1] * n for i in range(m)]\\n        for a, i, j in sorted([A[i][j], i, j] for i in range(m) for j in range(n)):\\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\\n                    dp[i][j] += dp[x][y] % mod\\n        return sum(map(sum, dp)) % mod\\n```\n```py\\n    def countPaths(self, A):\\n        m, n, mod = len(A), len(A[0]), 10 ** 9 + 7\\n\\n        @lru_cache(None)\\n        def count(i, j):\\n            res = 1\\n            for x, y in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:\\n                if 0 <= x < m and 0 <= y < n and A[x][y] < A[i][j]:\\n                    res += count(x, y) % mod\\n            return res\\n\\n        return sum(count(i,j) for i in range(m) for j in range(n)) % mod\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2229827,
                "title": "dfs-memo",
                "content": "We do DFS from each cell, and then memoise the result.\\n\\nThe key is to realize that it\\'s easy to memoise - as we can only explore increasing path. If we step on the cell that was already explored - we know how many paths it adds.\\n**C++**\\n```cpp    \\nint dp[1000][1000] = {}, mod = 1000000007;\\nint dfs(vector<vector<int>>& g, int i, int j, int v) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || g[i][j] <= v)\\n        return 0;\\n    return dp[i][j] ?: dp[i][j] = (1LL + dfs(g, i + 1, j, g[i][j]) + dfs(g, i - 1, j, g[i][j]) \\n        + dfs(g, i, j + 1, g[i][j]) + dfs(g, i, j - 1, g[i][j])) % mod;\\n}\\nint countPaths(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            res = (res + dfs(g, i, j, 0)) % mod;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nint dp[1000][1000] = {}, mod = 1000000007;\\nint dfs(vector<vector<int>>& g, int i, int j, int v) {\\n    if (min(i, j) < 0 || i >= g.size() || j >= g[i].size() || g[i][j] <= v)\\n        return 0;\\n    return dp[i][j] ?: dp[i][j] = (1LL + dfs(g, i + 1, j, g[i][j]) + dfs(g, i - 1, j, g[i][j]) \\n        + dfs(g, i, j + 1, g[i][j]) + dfs(g, i, j - 1, g[i][j])) % mod;\\n}\\nint countPaths(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j)\\n            res = (res + dfs(g, i, j, 0)) % mod;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230611,
                "title": "c-normal-recursion-w-memo",
                "content": "This question is as simple as it reads. You must\\'ve thought of the brute force way of doing this problem, that applying recursion from every cell and keep moving until you can move. Well, if thought that, Congrats! You\\'ve already solved the problem.\\nNow the only thing you need to do to handle that TLE, is memoize it.  Yes! Just run the Brute force approach and apply DP. As simple as it is. \\n\\n### Brute Force\\nSo we start from every cell and we check in all four directions and if in any direction, we can make a move, then we move. \\n### Memoize\\nWe need to memoize the answer we get for every cell. As there will be many repeated subproblems that we would not want to solve again and again. So, we just store those values in another matrix and use them futher. \\n\\n```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n    int countPaths(vector<vector<int>>& grid) {\\n        vector <vector <int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        long long count = 0;\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[0].size(); j++){\\n                count = (count%mod + dfs(i,j,grid,dp)%mod)%mod;\\n            }\\n        }\\n        return (int)count%mod;\\n    }\\nprotected:\\n    bool isvalid(int x, int y, vector<vector<int>>&grid){\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size()) return false;\\n        return true;\\n    }\\n    int dfs(int x, int y, vector <vector<int>>&grid,vector <vector<int>>&dp){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        \\n        int ans = 1;\\n        for(int i = 0; i<4; i++){\\n            if(isvalid(x+dx[i],y+dy[i],grid) and grid[x][y]>grid[x+dx[i]][y+dy[i]]){\\n                ans = (ans%mod+dfs(x+dx[i],y+dy[i],grid,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[x][y] = ans%mod;\\n    }\\n};\\n```\\n```\\n/*\\n[[12469,18741,68716,30594,65029,44019,92944,84784,92781,5655,43120,81333,54113,88220,23446,6129,2904,48677,20506,79604,82841,3938,46511,60870,10825,31759,78612,19776,43160,86915,74498,38366,28228,23687,40729,42613,61154,22726,51028,45603,53586,44657,97573,61067,27187,4619,6135,24668,69634,24564,30255,51939,67573,87012,4106,76312,28737,7704,35798]]\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,1,0,-1};\\n    int countPaths(vector<vector<int>>& grid) {\\n        vector <vector <int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        long long count = 0;\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[0].size(); j++){\\n                count = (count%mod + dfs(i,j,grid,dp)%mod)%mod;\\n            }\\n        }\\n        return (int)count%mod;\\n    }\\nprotected:\\n    bool isvalid(int x, int y, vector<vector<int>>&grid){\\n        if(x<0 or x>=grid.size() or y<0 or y>=grid[0].size()) return false;\\n        return true;\\n    }\\n    int dfs(int x, int y, vector <vector<int>>&grid,vector <vector<int>>&dp){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        \\n        int ans = 1;\\n        for(int i = 0; i<4; i++){\\n            if(isvalid(x+dx[i],y+dy[i],grid) and grid[x][y]>grid[x+dx[i]][y+dy[i]]){\\n                ans = (ans%mod+dfs(x+dx[i],y+dy[i],grid,dp)%mod)%mod;\\n            }\\n        }\\n        return dp[x][y] = ans%mod;\\n    }\\n};\\n```\n```\\n/*\\n[[12469,18741,68716,30594,65029,44019,92944,84784,92781,5655,43120,81333,54113,88220,23446,6129,2904,48677,20506,79604,82841,3938,46511,60870,10825,31759,78612,19776,43160,86915,74498,38366,28228,23687,40729,42613,61154,22726,51028,45603,53586,44657,97573,61067,27187,4619,6135,24668,69634,24564,30255,51939,67573,87012,4106,76312,28737,7704,35798]]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650311,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49`  Number of Increasing Paths in a Grid By Tech Wired`\\n# or\\n# Click the Link in my Profile\\n\\n```Python []\\nclass Solution:\\n    def countPaths(self, grid):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        mod = 10 ** 9 + 7\\n\\n        @lru_cache(None)\\n        def count(row, col):\\n            res = 1\\n            for dx, dy in [[row, col + 1], [row, col - 1], [row + 1, col], [row - 1, col]]:\\n                if 0 <= dx < rows and 0 <= dy < cols and grid[dx][dy] > grid[row][col]:\\n                    res += count(dx, dy) % mod\\n            return res\\n\\n        count_values = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                count_values.append(count(i, j))\\n        path_sum = sum(count_values) % mod\\n\\n        return path_sum\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n\\n    public int countPaths(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        int[][] dp = new int[rows][cols];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long pathSum = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                pathSum = (pathSum + dp[i][j]) % mod;\\n            }\\n        }\\n        return (int) pathSum;\\n    }\\n\\n    public int helper(int row, int col, int[][] grid, int[][] dp, int parent) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n\\n        int down = helper(row + 1, col, grid, dp, grid[row][col]) % mod;\\n        int up = helper(row - 1, col, grid, dp, grid[row][col]) % mod;\\n        int right = helper(row, col + 1, grid, dp, grid[row][col]) % mod;\\n        int left = helper(row, col - 1, grid, dp, grid[row][col]) % mod;\\n\\n        return dp[row][col] = (down + up + right + left + 1) % mod;\\n    }\\n}\\n\\n```\\n```C++ []\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int mod = 1e9 + 7;\\n\\n        vector<vector<int>> dp(rows, vector<int>(cols, -1));\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long long pathSum = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                pathSum = (pathSum + dp[i][j]) % mod;\\n            }\\n        }\\n        return static_cast<int>(pathSum);\\n    }\\n\\n    int helper(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp, int parent) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n\\n        int down = helper(row + 1, col, grid, dp, grid[row][col]) % mod;\\n        int up = helper(row - 1, col, grid, dp, grid[row][col]) % mod;\\n        int right = helper(row, col + 1, grid, dp, grid[row][col]) % mod;\\n        int left = helper(row, col - 1, grid, dp, grid[row][col]) % mod;\\n\\n        return dp[row][col] = (down + up + right + left + 1) % mod;\\n    }\\n};\\n\\n```\\n\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```Python []\\nclass Solution:\\n    def countPaths(self, grid):\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        mod = 10 ** 9 + 7\\n\\n        @lru_cache(None)\\n        def count(row, col):\\n            res = 1\\n            for dx, dy in [[row, col + 1], [row, col - 1], [row + 1, col], [row - 1, col]]:\\n                if 0 <= dx < rows and 0 <= dy < cols and grid[dx][dy] > grid[row][col]:\\n                    res += count(dx, dy) % mod\\n            return res\\n\\n        count_values = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                count_values.append(count(i, j))\\n        path_sum = sum(count_values) % mod\\n\\n        return path_sum\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n\\n    public int countPaths(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        int[][] dp = new int[rows][cols];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long pathSum = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                pathSum = (pathSum + dp[i][j]) % mod;\\n            }\\n        }\\n        return (int) pathSum;\\n    }\\n\\n    public int helper(int row, int col, int[][] grid, int[][] dp, int parent) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n\\n        int down = helper(row + 1, col, grid, dp, grid[row][col]) % mod;\\n        int up = helper(row - 1, col, grid, dp, grid[row][col]) % mod;\\n        int right = helper(row, col + 1, grid, dp, grid[row][col]) % mod;\\n        int left = helper(row, col - 1, grid, dp, grid[row][col]) % mod;\\n\\n        return dp[row][col] = (down + up + right + left + 1) % mod;\\n    }\\n}\\n\\n```\n```C++ []\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int mod = 1e9 + 7;\\n\\n        vector<vector<int>> dp(rows, vector<int>(cols, -1));\\n\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long long pathSum = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                pathSum = (pathSum + dp[i][j]) % mod;\\n            }\\n        }\\n        return static_cast<int>(pathSum);\\n    }\\n\\n    int helper(int row, int col, vector<vector<int>>& grid, vector<vector<int>>& dp, int parent) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n\\n        int down = helper(row + 1, col, grid, dp, grid[row][col]) % mod;\\n        int up = helper(row - 1, col, grid, dp, grid[row][col]) % mod;\\n        int right = helper(row, col + 1, grid, dp, grid[row][col]) % mod;\\n        int left = helper(row, col - 1, grid, dp, grid[row][col]) % mod;\\n\\n        return dp[row][col] = (down + up + right + left + 1) % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2229956,
                "title": "java-dp",
                "content": "```\\n    long mod=1000000007;\\n    long dp[][];\\n    public int countPaths(int[][] grid) {\\n        \\n        int n=grid.length,m=grid[0].length;\\n        dp=new long[n][m];\\n        long ans=0;\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n\\n               ans=(ans+find(i,j,grid))%mod;\\n               ans=(ans+mod)%mod;\\n           }\\n       }\\n        return (int)(ans%1000000007);\\n    }\\n    int dir[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n     long find(int i,int j,int grid[][]){\\n\\n        if(dp[i][j]!=0) return dp[i][j];\\n\\n        long ans=1;\\n        for(int k=0;k<4;k++){\\n            int i1=i+dir[k][0],j1=j+dir[k][1];\\n\\n            if(i1<0 || j1<0 || i1==dp.length || j1==dp[0].length || grid[i][j]<=grid[i1][j1])\\n             continue;\\n\\n            ans=(ans+find(i1,j1,grid))%mod;\\n        }\\n        ans=(ans+mod)%mod;\\n        return dp[i][j]=(ans);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    long mod=1000000007;\\n    long dp[][];\\n    public int countPaths(int[][] grid) {\\n        \\n        int n=grid.length,m=grid[0].length;\\n        dp=new long[n][m];\\n        long ans=0;\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<m;j++){\\n\\n               ans=(ans+find(i,j,grid))%mod;\\n               ans=(ans+mod)%mod;\\n           }\\n       }\\n        return (int)(ans%1000000007);\\n    }\\n    int dir[][]={{-1,0},{1,0},{0,1},{0,-1}};\\n     long find(int i,int j,int grid[][]){\\n\\n        if(dp[i][j]!=0) return dp[i][j];\\n\\n        long ans=1;\\n        for(int k=0;k<4;k++){\\n            int i1=i+dir[k][0],j1=j+dir[k][1];\\n\\n            if(i1<0 || j1<0 || i1==dp.length || j1==dp[0].length || grid[i][j]<=grid[i1][j1])\\n             continue;\\n\\n            ans=(ans+find(i1,j1,grid))%mod;\\n        }\\n        ans=(ans+mod)%mod;\\n        return dp[i][j]=(ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651427,
                "title": "c-java-python-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem is to find the number of distinct paths in a grid such that the values in the cells along the path are strictly increasing. The task can be solved efficiently using dynamic programming and recursion.\\n\\n# Approach:\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The `helper` function is a recursive function that calculates the number of distinct paths from a given position `(i, j)` in the grid. It takes the current position `(i, j)`, the grid, a memoization table `dp`, and the parent value as parameters.\\n2. The function first checks if the current position `(i, j)` is out of bounds or if the value in the current cell is less than or equal to the parent value. If either condition is true, it means there is no valid path from this position, so the function returns 0.\\n3. Next, the function checks if the result for the current position `(i, j)` has already been computed and stored in the `dp` table. If it has, it directly returns the result from the `dp` table, avoiding redundant calculations.\\n4. If the above conditions are not met, the function proceeds to calculate the number of distinct paths. It does this by making recursive calls to the `helper` function for the four neighboring cells (up, down, left, right) from the current position `(i, j)`. It passes the updated `parent` value as the value of the current cell. This ensures that the values along the path are strictly increasing.\\n5. The results of the four recursive calls (up, down, left, right) are stored in variables (`down`, `up`, `right`, `left`).\\n6. Finally, the function computes the number of distinct paths from the current position `(i, j)` as the sum of the four results plus 1 (to account for the current cell). It stores this computed result in the `dp` table at index `(i, j)` and returns the result.\\n7. The `countPaths` function is the entry point for the solution. It initializes the memoization table `dp` with appropriate dimensions. Each cell in `dp` is initially set to a default value (in this case, -1) to indicate that the result for that position has not been computed yet.\\n8. It then iterates through all positions in the grid using two nested loops. For each position `(i, j)`, it checks if the result for that position has already been computed (i.e., `dp[i][j]` is equal to -1). If the result has not been computed, it calls the `helper` function to calculate and store the result in the `dp` table.\\n9. After computing all the results, the function iterates through the `dp` table and sums up all the values. The final sum represents the desired output, which is the total number of distinct paths in the grid.\\n10. Finally, the `countPaths` function returns the computed sum, representing the total number of distinct paths in the grid.\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int mod = pow(10, 9) + 7;\\n    int helper(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp, int parent){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= parent){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        int down  = helper(i + 1, j, grid, dp, grid[i][j]) % mod;\\n        int up    = helper(i - 1, j, grid, dp, grid[i][j]) % mod;\\n        int right = helper(i, j + 1, grid, dp, grid[i][j]) % mod;\\n        int left  = helper(i, j - 1, grid, dp, grid[i][j]) % mod;\\n\\n        return dp[i][j] = (down + up + right + left + 1) % mod;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(dp[i][j] == -1){\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        } \\n\\n        long long ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans = (ans + dp[i][j]) % mod;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n\\n    public int helper(int i, int j, int[][] grid, int[][] dp, int parent) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        int down = helper(i + 1, j, grid, dp, grid[i][j]) % mod;\\n        int up = helper(i - 1, j, grid, dp, grid[i][j]) % mod;\\n        int right = helper(i, j + 1, grid, dp, grid[i][j]) % mod;\\n        int left = helper(i, j - 1, grid, dp, grid[i][j]) % mod;\\n\\n        return dp[i][j] = (down + up + right + left + 1) % mod;\\n    }\\n\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[][] dp = new int[m][n];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = (ans + dp[i][j]) % mod;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        mod = pow(10, 9) + 7\\n        \\n        def helper(i, j, grid, dp, parent):\\n            m = len(grid)\\n            n = len(grid[0])\\n\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] <= parent:\\n                return 0\\n\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n\\n            down = helper(i + 1, j, grid, dp, grid[i][j]) % mod\\n            up = helper(i - 1, j, grid, dp, grid[i][j]) % mod\\n            right = helper(i, j + 1, grid, dp, grid[i][j]) % mod\\n            left = helper(i, j - 1, grid, dp, grid[i][j]) % mod\\n\\n            dp[i][j] = (down + up + right + left + 1) % mod\\n            return dp[i][j]\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j] == -1:\\n                    helper(i, j, grid, dp, -1)\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                ans = (ans + dp[i][j]) % mod\\n        return ans\\n```\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/d80430d7-2598-4086-84c4-4df68b8e87ce_1687072981.3507318.png)\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mod = pow(10, 9) + 7;\\n    int helper(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp, int parent){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= parent){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n\\n        int down  = helper(i + 1, j, grid, dp, grid[i][j]) % mod;\\n        int up    = helper(i - 1, j, grid, dp, grid[i][j]) % mod;\\n        int right = helper(i, j + 1, grid, dp, grid[i][j]) % mod;\\n        int left  = helper(i, j - 1, grid, dp, grid[i][j]) % mod;\\n\\n        return dp[i][j] = (down + up + right + left + 1) % mod;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(dp[i][j] == -1){\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        } \\n\\n        long long ans = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans = (ans + dp[i][j]) % mod;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n\\n    public int helper(int i, int j, int[][] grid, int[][] dp, int parent) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= parent) {\\n            return 0;\\n        }\\n\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n\\n        int down = helper(i + 1, j, grid, dp, grid[i][j]) % mod;\\n        int up = helper(i - 1, j, grid, dp, grid[i][j]) % mod;\\n        int right = helper(i, j + 1, grid, dp, grid[i][j]) % mod;\\n        int left = helper(i, j - 1, grid, dp, grid[i][j]) % mod;\\n\\n        return dp[i][j] = (down + up + right + left + 1) % mod;\\n    }\\n\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        int[][] dp = new int[m][n];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (dp[i][j] == -1) {\\n                    helper(i, j, grid, dp, -1);\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = (ans + dp[i][j]) % mod;\\n            }\\n        }\\n        return (int) ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        mod = pow(10, 9) + 7\\n        \\n        def helper(i, j, grid, dp, parent):\\n            m = len(grid)\\n            n = len(grid[0])\\n\\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] <= parent:\\n                return 0\\n\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n\\n            down = helper(i + 1, j, grid, dp, grid[i][j]) % mod\\n            up = helper(i - 1, j, grid, dp, grid[i][j]) % mod\\n            right = helper(i, j + 1, grid, dp, grid[i][j]) % mod\\n            left = helper(i, j - 1, grid, dp, grid[i][j]) % mod\\n\\n            dp[i][j] = (down + up + right + left + 1) % mod\\n            return dp[i][j]\\n\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        dp = [[-1] * n for _ in range(m)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if dp[i][j] == -1:\\n                    helper(i, j, grid, dp, -1)\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                ans = (ans + dp[i][j]) % mod\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230257,
                "title": "java-solution-100-faster",
                "content": "Simple DFS+Memo!\\n\\nclass Solution {\\n    int path[][];\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int countPaths(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int ans=0;\\n        path=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               \\n                ans=(ans%mod+ dfs(grid,i,j,m,n,-1)%mod)%mod;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] grid,int x,int y,int m,int n,int pre){\\n        if(x<0 || y<0 || x>=n || y>=m)return 0;\\n        if(grid[x][y]<=pre)return 0;\\n        if(path[x][y]!=0)return path[x][y];\\n       \\n        int l1=dfs(grid,x+1,y,m,n,grid[x][y]);\\n        int l2=dfs(grid,x-1,y,m,n,grid[x][y]);\\n        int l3=dfs(grid,x,y+1,m,n,grid[x][y]);\\n        int l4=dfs(grid,x,y-1,m,n,grid[x][y]);\\n        \\n        return  path[x][y]=(1+l1+l2+l3+l4)%mod;\\n    }  \\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int path[][];\\n    int mod=(int)Math.pow(10,9)+7;\\n    public int countPaths(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        \\n        int ans=0;\\n        path=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               \\n                ans=(ans%mod+ dfs(grid,i,j,m,n,-1)%mod)%mod;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2230026,
                "title": "dp-dfs-solutiion-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll m,n;\\n    ll mod=1e9+7;\\n    ll dp[1005][1005],a[1005][1005],vis[1005][1005];\\n    ll dx[4]={1,-1,0,0};\\n    ll dy[4]={0,0,1,-1};\\n    void dfs(ll x,ll y){\\n        if(vis[x][y])\\n            return;\\n        vis[x][y]=1;\\n        dp[x][y]=1;\\n        for(ll i=0;i<4;i++){\\n            ll x1=x+dx[i],y1=y+dy[i];\\n            if(x1>=0 && x1<m && y1>=0 && y1<n && a[x][y]<a[x1][y1]){\\n                dfs(x1,y1);\\n                if(dp[x1][y1]){\\n                    dp[x][y]=(dp[x][y]+dp[x1][y1])%mod;\\n                }\\n            }\\n        }\\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        m=matrix.size();\\n        n=matrix[0].size();\\n        for(ll i=0;i<m;i++){\\n            for(ll j=0;j<n;j++){\\n                dp[i][j]=0;\\n                a[i][j]=matrix[i][j];\\n                vis[i][j]=0;\\n            }\\n        }\\n        ll ans=0;\\n        for(ll i=0;i<m;i++){\\n            for(ll j=0;j<n;j++){\\n                if(vis[i][j]==0){\\n                    dfs(i,j);\\n                }\\n                ans=(ans+dp[i][j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    ll m,n;\\n    ll mod=1e9+7;\\n    ll dp[1005][1005],a[1005][1005],vis[1005][1005];\\n    ll dx[4]={1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3650935,
                "title": "c-dp-memoization-easy-solution-very-intuitive",
                "content": "1. Let\\'s first look out for the base cases.\\n\\tIf we move ***out*** of the grid, then there is no path possible.\\n2. Since we can move in all the four directions - **{up, down, left, right}**, we try to explore all the possible paths.\\n3. While ***transition***, check whether the increasing path condition holds or not.\\n4. Since every element in itself forms a increasing path, *hence every element in itself contributes to a single path.*\\n5. Memoize the following recursion.\\n6. While returning, **Total Paths = 1 (single element) + ans due to all four directions**\\n7. We can start from any cell to look out for the increasing path, ans hence traverse n * m cells and add all the possible paths to get the total answer.\\n\\nTime Complexity : O(n * m)\\nSpace Complexity : O(n * m)\\n\\n```\\nconst int MOD = 1e9 + 7;\\n    \\n    int solve(int i, int j, int &n, int &m, vector<vector<int>>&grid, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int up = 0, down = 0, left = 0, right = 0;\\n        \\n        if (i - 1 >= 0 and grid[i - 1][j] > grid[i][j])\\n            up = solve(i - 1, j, n, m, grid, dp);\\n        \\n        if (i + 1 < n and grid[i + 1][j] > grid[i][j])\\n            down = solve(i + 1, j, n, m, grid, dp);\\n        \\n        if (j - 1 >= 0 and grid[i][j - 1] > grid[i][j])\\n            left = solve(i, j - 1, n, m, grid, dp);\\n        \\n        if (j + 1 < m and grid[i][j + 1] > grid[i][j])\\n            right = solve(i, j + 1, n, m, grid, dp);\\n        \\n        return dp[i][j] = (1 + up + down + left + right) % MOD;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                ans = (ans + solve(i, j, n, m, grid, dp)) % MOD;\\n            }\\n        }\\n        \\n        return ans % MOD;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nconst int MOD = 1e9 + 7;\\n    \\n    int solve(int i, int j, int &n, int &m, vector<vector<int>>&grid, vector<vector<int>>&dp)\\n    {\\n        if (i < 0 or j < 0 or i >= n or j >= m)\\n            return 0;\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int up = 0, down = 0, left = 0, right = 0;\\n        \\n        if (i - 1 >= 0 and grid[i - 1][j] > grid[i][j])\\n            up = solve(i - 1, j, n, m, grid, dp);\\n        \\n        if (i + 1 < n and grid[i + 1][j] > grid[i][j])\\n            down = solve(i + 1, j, n, m, grid, dp);\\n        \\n        if (j - 1 >= 0 and grid[i][j - 1] > grid[i][j])\\n            left = solve(i, j - 1, n, m, grid, dp);\\n        \\n        if (j + 1 < m and grid[i][j + 1] > grid[i][j])\\n            right = solve(i, j + 1, n, m, grid, dp);\\n        \\n        return dp[i][j] = (1 + up + down + left + right) % MOD;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                ans = (ans + solve(i, j, n, m, grid, dp)) % MOD;\\n            }\\n        }\\n        \\n        return ans % MOD;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229887,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int fun(vector<vector<int>>& grid,int i,int j,vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j]!=0) return dp[i][j];\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i<0 && j<0 && i>=m && j>=n)\\n        {\\n            return 0;\\n        }\\n        \\n        int res=1;\\n        \\n        if(i>0 && grid[i][j]<grid[i-1][j])\\n        {\\n            res=res%mod+fun(grid,i-1,j,dp)%mod;\\n        }\\n        if(j>0 && grid[i][j]<grid[i][j-1])\\n        {\\n            res=res%mod+fun(grid,i,j-1,dp)%mod;\\n        }\\n        if(i<m-1 && grid[i][j]<grid[i+1][j])\\n        {\\n            res=res%mod+fun(grid,i+1,j,dp)%mod;\\n        }\\n        if(j<n-1 && grid[i][j]<grid[i][j+1])\\n        {\\n            res=res%mod+fun(grid,i,j+1,dp)%mod;\\n        }\\n        \\n        return dp[i][j]=res%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        \\n        int res=0;\\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                res=(res%mod+ fun(grid,i,j,dp)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int fun(vector<vector<int>>& grid,int i,int j,vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j]!=0) return dp[i][j];\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i<0 && j<0 && i>=m && j>=n)\\n        {\\n            return 0;\\n        }\\n        \\n        int res=1;\\n        \\n        if(i>0 && grid[i][j]<grid[i-1][j])\\n        {\\n            res=res%mod+fun(grid,i-1,j,dp)%mod;\\n        }\\n        if(j>0 && grid[i][j]<grid[i][j-1])\\n        {\\n            res=res%mod+fun(grid,i,j-1,dp)%mod;\\n        }\\n        if(i<m-1 && grid[i][j]<grid[i+1][j])\\n        {\\n            res=res%mod+fun(grid,i+1,j,dp)%mod;\\n        }\\n        if(j<n-1 && grid[i][j]<grid[i][j+1])\\n        {\\n            res=res%mod+fun(grid,i,j+1,dp)%mod;\\n        }\\n        \\n        return dp[i][j]=res%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,0));\\n        \\n        int res=0;\\n        \\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                res=(res%mod+ fun(grid,i,j,dp)%mod)%mod;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229813,
                "title": "clean-python-dp",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j):\\n            \\n            drs = [(-1,0),(1,0),(0,-1),(0,1)]\\n            t = 0\\n            for x,y in drs:\\n                if  0 <= i+x < row and 0 <= j+y < col and grid[i+x][j+y] > grid[i][j]:\\n                    t += 1+helper(i+x, j+y)\\n            return t\\n                    \\n\\n        \\n        m = (10**9) + 7\\n        ans = row*col%m\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                ans += helper(i, j)%m\\n                ans %= m\\n                \\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row = len(grid)\\n        col = len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j):\\n            \\n            drs = [(-1,0),(1,0),(0,-1),(0,1)]\\n            t = 0\\n            for x,y in drs:\\n                if  0 <= i+x < row and 0 <= j+y < col and grid[i+x][j+y] > grid[i][j]:\\n                    t += 1+helper(i+x, j+y)\\n            return t\\n                    \\n\\n        \\n        m = (10**9) + 7\\n        ans = row*col%m\\n        \\n        for i in range(row):\\n            for j in range(col):\\n                ans += helper(i, j)%m\\n                ans %= m\\n                \\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650814,
                "title": "c-understandable-dp-solution-with-clear-approach-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> The first thing that comes to mind when we encounter questions where we need to count the number of possible paths is recursion + dynamic programming (DP).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Initialize a 2D vector \\'dp\\' of size \\'n\\' by \\'m\\', where \\'n\\' represents the number of rows and \\'m\\' represents the number of columns in the grid.\\n-> Check for all possible increasing paths for each element one by one.\\n-> Initialize the previous value \\'prev\\' as -1, assuming there are no negative values in the array, and make a recursive call.\\n-> Check if the indexes are valid and if the current element is greater than the previous one.\\n-> If we have already counted the paths going via current elements, then retrieve the data from the dp table.\\n-> Increment the count by 1 each time if the curr element is greater than the previous one, as we can start from any cell and end at any cell according to the given question. Then, proceed in all four directions by making a recursive call.\\n-> Return the count while storing it in the \\'dp\\' table.\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dfs(int i,int j,int prev,vector<vector<int>>&dp,vector<vector<int>>&v){\\n        int n=v.size(),m=v[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m || v[i][j]<=prev)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        return dp[i][j]=(1+dfs(i+1,j,v[i][j],dp,v)+dfs(i-1,j,v[i][j],dp,v)+dfs(i,j+1,v[i][j],dp,v)+dfs(i,j-1,v[i][j],dp,v))%mod;\\n    }\\n    int countPaths(vector<vector<int>>&v) {\\n        int i,j,n=v.size(),m=v[0].size(),ans=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                ans=(ans+dfs(i,j,-1,dp,v))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int dfs(int i,int j,int prev,vector<vector<int>>&dp,vector<vector<int>>&v){\\n        int n=v.size(),m=v[0].size();\\n        if(i<0 || j<0 || i>=n || j>=m || v[i][j]<=prev)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        return dp[i][j]=(1+dfs(i+1,j,v[i][j],dp,v)+dfs(i-1,j,v[i][j],dp,v)+dfs(i,j+1,v[i][j],dp,v)+dfs(i,j-1,v[i][j],dp,v))%mod;\\n    }\\n    int countPaths(vector<vector<int>>&v) {\\n        int i,j,n=v.size(),m=v[0].size(),ans=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(i=0;i<n;i++){\\n            for(j=0;j<m;j++){\\n                ans=(ans+dfs(i,j,-1,dp,v))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230178,
                "title": "idea-explained-dp-memoization-dfs-based-approach-c-clean-code",
                "content": "---------------------------------------\\n**Intuition :** \\n ---------------------------------------\\n * Idea here is pretty straightforward, we need to start from any cell/node and then explore all the path in every direction i.e up, down, left, right. \\n* And at each cell/node, we check if its adjacent cell/node has value greater than current node or not.\\n* If no then check for some other node, else we increment count of increasing path since till current node path is increasing. And then further explore that path using DFS.\\n* Now, brute force way will give TLE. So we need to memoize our count of inc. paths.\\n* To do this we maintain a DP table which will be a hashmap.\\n\\t* `dp[id] = count of inc paths`, here `id = x * no. of columns in grid + y`, \\n\\t* `id` is for converting cell coordinate from 2D -> 1D.\\n    * `(x, y)` is coordinate of node/cell in grid.\\n * Check comments in the code below to get better understanding.\\n---------------------------------------\\n# Code : \\n---------------------------------------\\n```\\nstatic int X[4] = {-1, 1, 0, 0};\\nstatic int Y[4] = {0, 0, -1, 1};\\nclass Solution {\\n    const long long MOD = 1e9 + 7;\\npublic:\\n    \\n\\t// Explore paths that are increasing using DFS, memoize and return count of inc. paths\\n    long long exploreIncreasingPaths(vector<vector<int>>& grid, unordered_map<long long, long long>& dp, int x, int y, int m, int n) {\\n        \\n        int count = 0;\\n        int id = x * n + y; // Id is nothing but the value of node if we traverse grid in 1 manner\\n        \\n\\t\\t// Check if count of inc. paths is already calculated and memoized for current node\\n        if(dp.find(id) != dp.end()) return dp[id];\\n        \\n\\t\\t// Check for adjacent node if it is has value greater than current node/cell\\n\\t\\t// If yes then increment count and explore that path further \\n        for(int k=0; k<4; k++) {\\n            int i = X[k] + x;\\n            int j = Y[k] + y;\\n            \\n            if(i >= 0 && i < m && j >=0 && j < n && grid[i][j] > grid[x][y]) {\\n                count += (1 + exploreIncreasingPaths(grid, dp, i, j, m, n)) % MOD;\\n            }\\n        }\\n        \\n\\t\\t// Memoize count of inc. paths and return count\\n        return dp[id] = count % MOD;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        long long count = 0;\\n        \\n\\t\\t// Store count of increasing path for some node/cell in grid\\n        unordered_map<long long, long long> dp;\\n        \\n\\t\\t// Start exploring from each node/cell in grid\\n\\t\\t// And keep count of number of paths explored that are increasing\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                count += (1LL + exploreIncreasingPaths(grid, dp, i, j, m, n)) % MOD;\\n            }\\n        }\\n        \\n        return (int)(count % MOD);\\n    }\\n};\\n```\\n\\n---------------------------------------\\n**Complexity :**\\n---------------------------------------\\n\\n * **Time** : `O(M * N)` , iterating over grid and then exploring paths for each node/cell\\n * **Space** : `O(M * N)`, memoizing count of inc. paths for each node/cell in grid.\\n\\t* `M` : number of rows\\n\\t* `N` : number of columns\\n---------------------------------------\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nstatic int X[4] = {-1, 1, 0, 0};\\nstatic int Y[4] = {0, 0, -1, 1};\\nclass Solution {\\n    const long long MOD = 1e9 + 7;\\npublic:\\n    \\n\\t// Explore paths that are increasing using DFS, memoize and return count of inc. paths\\n    long long exploreIncreasingPaths(vector<vector<int>>& grid, unordered_map<long long, long long>& dp, int x, int y, int m, int n) {\\n        \\n        int count = 0;\\n        int id = x * n + y; // Id is nothing but the value of node if we traverse grid in 1 manner\\n        \\n\\t\\t// Check if count of inc. paths is already calculated and memoized for current node\\n        if(dp.find(id) != dp.end()) return dp[id];\\n        \\n\\t\\t// Check for adjacent node if it is has value greater than current node/cell\\n\\t\\t// If yes then increment count and explore that path further \\n        for(int k=0; k<4; k++) {\\n            int i = X[k] + x;\\n            int j = Y[k] + y;\\n            \\n            if(i >= 0 && i < m && j >=0 && j < n && grid[i][j] > grid[x][y]) {\\n                count += (1 + exploreIncreasingPaths(grid, dp, i, j, m, n)) % MOD;\\n            }\\n        }\\n        \\n\\t\\t// Memoize count of inc. paths and return count\\n        return dp[id] = count % MOD;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        long long count = 0;\\n        \\n\\t\\t// Store count of increasing path for some node/cell in grid\\n        unordered_map<long long, long long> dp;\\n        \\n\\t\\t// Start exploring from each node/cell in grid\\n\\t\\t// And keep count of number of paths explored that are increasing\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                count += (1LL + exploreIncreasingPaths(grid, dp, i, j, m, n)) % MOD;\\n            }\\n        }\\n        \\n        return (int)(count % MOD);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229934,
                "title": "python-3-explanation-with-pictures",
                "content": "Iterate over cells in the order of value. Let \\'path[i][j]\\' be the number of ways that **end by** cell `i, j`.\\n\\nOne cell can only increment the number of way to a neighbor if the neighbor has higher value.\\n![image](https://assets.leetcode.com/users/images/ba6d8247-e3dd-4b5f-9da2-3097c2308f3e_1656820841.9378214.png)\\n\\nFor example:\\n\\n![image](https://assets.leetcode.com/users/images/fa06023e-23f0-4bf6-8176-1b016aaee738_1656820866.2006803.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def countPaths(self, G: List[List[int]]) -> int:\\n        m, n, mod = len(G), len(G[0]), 1000000007\\n        A, heap = [[1] * n for _ in range(m)], []\\n        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        for i in range(m):\\n            for j in range(n):\\n                heapq.heappush(heap, [G[i][j], i, j])\\n        while heap:\\n            val, i, j = heapq.heappop(heap)\\n            for d in dirs:\\n                ii, jj = i + d[0], j + d[1]\\n                if 0 <= ii < m and 0 <= jj < n and G[ii][jj] > G[i][j]:\\n                    A[ii][jj] += A[i][j]\\n                    A[ii][jj] %= mod\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                ans += A[i][j]\\n        return ans % mod\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, G: List[List[int]]) -> int:\\n        m, n, mod = len(G), len(G[0]), 1000000007\\n        A, heap = [[1] * n for _ in range(m)], []\\n        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\\n        for i in range(m):\\n            for j in range(n):\\n                heapq.heappush(heap, [G[i][j], i, j])\\n        while heap:\\n            val, i, j = heapq.heappop(heap)\\n            for d in dirs:\\n                ii, jj = i + d[0], j + d[1]\\n                if 0 <= ii < m and 0 <= jj < n and G[ii][jj] > G[i][j]:\\n                    A[ii][jj] += A[i][j]\\n                    A[ii][jj] %= mod\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                ans += A[i][j]\\n        return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230584,
                "title": "c-simple-2d-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[1001][1001];\\n    int path[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n    long long int solve(vector<vector<int>>&v, int i, int j, int m, int n){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j]%mod;\\n        long long int sum =1;\\n        for(int k=0; k<4; k++){\\n            int newi = i+path[k][0];\\n            int newj = j+path[k][1];\\n            if(newi<0 or newj<0 or newi>=m or newj>=n or v[newi][newj]<=v[i][j])\\n                continue;\\n            sum = (long long int)(sum%mod+solve(v, newi, newj, m, n)%mod);\\n        }\\n        return dp[i][j]=sum%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        memset(dp, -1, sizeof(dp));\\n        int n = grid[0].size();\\n        long long int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans +=((solve(grid, i, j, m, n))%mod);\\n            }\\n        }\\n        return (ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int dp[1001][1001];\\n    int path[4][2] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n    long long int solve(vector<vector<int>>&v, int i, int j, int m, int n){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j]%mod;\\n        long long int sum =1;\\n        for(int k=0; k<4; k++){\\n            int newi = i+path[k][0];\\n            int newj = j+path[k][1];\\n            if(newi<0 or newj<0 or newi>=m or newj>=n or v[newi][newj]<=v[i][j])\\n                continue;\\n            sum = (long long int)(sum%mod+solve(v, newi, newj, m, n)%mod);\\n        }\\n        return dp[i][j]=sum%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        memset(dp, -1, sizeof(dp));\\n        int n = grid[0].size();\\n        long long int ans=0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                ans +=((solve(grid, i, j, m, n))%mod);\\n            }\\n        }\\n        return (ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230195,
                "title": "c-easy-to-understand-dp-on-grid-dfs-approach-100-faster",
                "content": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    int n,m;\\n    bool isvalid(int i,int j)\\n    {\\n        return (i>=0&&i<n&&j>=0&&j<m);\\n    }\\n    int dfs( int i, int j,vector<vector<int>> &dp,vector<vector<int>> &grid)\\n    {\\n        if(dp[i][j]!=0)\\n        return dp[i][j];\\n        if(i<0||j<0||i>=n&&j>=m)\\n        return 0;\\n        int ans=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int new_x,new_y;\\n            new_x=i+dx[k];\\n            new_y=j+dy[k];\\n            \\n            if(isvalid(new_x,new_y)&&grid[new_x][new_y]>grid[i][j])\\n            {\\n                ans=(ans%mod+dfs(new_x,new_y,dp,grid)%mod)%mod;\\n            }\\n        }\\n        \\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        ll sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 sum=(sum%mod+dfs(i,j,dp,grid)%mod)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```\\n**Give an upvote if you like :)**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nll mod=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> dx={1,-1,0,0};\\n    vector<int> dy={0,0,1,-1};\\n    int n,m;\\n    bool isvalid(int i,int j)\\n    {\\n        return (i>=0&&i<n&&j>=0&&j<m);\\n    }\\n    int dfs( int i, int j,vector<vector<int>> &dp,vector<vector<int>> &grid)\\n    {\\n        if(dp[i][j]!=0)\\n        return dp[i][j];\\n        if(i<0||j<0||i>=n&&j>=m)\\n        return 0;\\n        int ans=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int new_x,new_y;\\n            new_x=i+dx[k];\\n            new_y=j+dy[k];\\n            \\n            if(isvalid(new_x,new_y)&&grid[new_x][new_y]>grid[i][j])\\n            {\\n                ans=(ans%mod+dfs(new_x,new_y,dp,grid)%mod)%mod;\\n            }\\n        }\\n        \\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        ll sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                 sum=(sum%mod+dfs(i,j,dp,grid)%mod)%mod;\\n            }\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229915,
                "title": "c-topological-sort-dp",
                "content": "\\n**1 topological sort via Kahn\\'s algorithm**\\nCompute the indegree of matrix elements defined as the number of neighbors strictly larger than itself. Collect all points with 0 indegree in a queue. \\nProcess the points in the queue as follow: \\nAt each point (i, j), update and answer. Check those neighbors whose values are smaller. Update its count and lower its indegree. If its indegree becomes zero, add to queue. \\nUpon exausting the queue elements, the answer is calculated. \\n\\nComplexity \\nO(MN) time \\nO(MN) space \\n\\n```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), d[5] = {-1, 0, 1, 0, -1}, MOD = 1\\'000\\'000\\'007; \\n        vector<vector<int>> indeg(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i+d[k], jj = j+d[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[i][j] < grid[ii][jj]) \\n                        ++indeg[i][j]; \\n                }\\n        \\n        queue<pair<int, int>> q; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (indeg[i][j] == 0) q.emplace(i, j); \\n        \\n        long long ans = 0; \\n        vector<vector<long long>> dp(m, vector<long long>(n, 1)); \\n        while (q.size()) {\\n            auto [i, j] = q.front(); q.pop(); \\n            ans = (ans + dp[i][j]) % MOD; \\n            for (int k = 0; k < 4; ++k) {\\n                int ii = i+d[k], jj = j+d[k+1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n) {\\n                    if (grid[i][j] > grid[ii][jj]) {\\n                        dp[ii][jj] = (dp[i][j] + dp[ii][jj]) % MOD; \\n                        if (--indeg[ii][jj] == 0) q.emplace(ii, jj); \\n                    }\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n    \\n};\\n```\\n\\n**2 dynamic programming**\\nDefine fn(i, j) as the number of increasing path starting from (i, j). Then, \\n* the ending condition is that at point no larger neightbor is available its value is 1; \\n* the recurrence relation is that fn(i, j) = 1 + sum(fn(ii, jj)) where (ii, jj) is a neighbor of (i, j) and grid[i][j] > grid[ii][jj]. \\nThe sum of all fn(i, j) (with properly modulo) is the desired answer. \\n\\nComplexity \\nO(MN) time\\nO(MN) space \\n```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), d[5] = {-1, 0, 1, 0, -1}, MOD = 1\\'000\\'000\\'007; \\n        \\n        vector<vector<long long>> memo(m, vector<long long>(n, -1)); \\n        function<long long(int, int)> fn = [&](int i, int j) {\\n            if (i < 0 || i == m || j < 0 || j == n) return 0ll; \\n            if (memo[i][j] == -1) {\\n                memo[i][j] = 1; \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i + d[k], jj = j + d[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[i][j] < grid[ii][jj]) \\n                        memo[i][j] = (memo[i][j] + fn(ii, jj)) % MOD; \\n                }\\n            }\\n            return memo[i][j]; \\n        }; \\n        \\n        long long ans = 0; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans = (ans + fn(i, j)) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), d[5] = {-1, 0, 1, 0, -1}, MOD = 1\\'000\\'000\\'007; \\n        vector<vector<int>> indeg(m, vector<int>(n)); \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i+d[k], jj = j+d[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[i][j] < grid[ii][jj]) \\n                        ++indeg[i][j]; \\n                }\\n        \\n        queue<pair<int, int>> q; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                if (indeg[i][j] == 0) q.emplace(i, j); \\n        \\n        long long ans = 0; \\n        vector<vector<long long>> dp(m, vector<long long>(n, 1)); \\n        while (q.size()) {\\n            auto [i, j] = q.front(); q.pop(); \\n            ans = (ans + dp[i][j]) % MOD; \\n            for (int k = 0; k < 4; ++k) {\\n                int ii = i+d[k], jj = j+d[k+1]; \\n                if (0 <= ii && ii < m && 0 <= jj && jj < n) {\\n                    if (grid[i][j] > grid[ii][jj]) {\\n                        dp[ii][jj] = (dp[i][j] + dp[ii][jj]) % MOD; \\n                        if (--indeg[ii][jj] == 0) q.emplace(ii, jj); \\n                    }\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size(), d[5] = {-1, 0, 1, 0, -1}, MOD = 1\\'000\\'000\\'007; \\n        \\n        vector<vector<long long>> memo(m, vector<long long>(n, -1)); \\n        function<long long(int, int)> fn = [&](int i, int j) {\\n            if (i < 0 || i == m || j < 0 || j == n) return 0ll; \\n            if (memo[i][j] == -1) {\\n                memo[i][j] = 1; \\n                for (int k = 0; k < 4; ++k) {\\n                    int ii = i + d[k], jj = j + d[k+1]; \\n                    if (0 <= ii && ii < m && 0 <= jj && jj < n && grid[i][j] < grid[ii][jj]) \\n                        memo[i][j] = (memo[i][j] + fn(ii, jj)) % MOD; \\n                }\\n            }\\n            return memo[i][j]; \\n        }; \\n        \\n        long long ans = 0; \\n        for (int i = 0; i < m; ++i) \\n            for (int j = 0; j < n; ++j) \\n                ans = (ans + fn(i, j)) % MOD; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230117,
                "title": "c-dfs-dp-on-grids-memoization-easy-explanation",
                "content": "Perform Simple DFS Through The Increasing Paths And Compute The Results In The DP Table\\nWhere **DP[I][J]** Represents The Number Of Increasing Paths From (I,J) To Any Other Cell.\\n\\nThe Answer Is The **Sum Of The DP Table**.\\n```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    long long ans=0;\\n    int m,n;\\n    vector<int> dx={0,1,0,-1};\\n    vector<int> dy={1,0,-1,0};\\n    long long modadd(long a,long b){return (a%M+b%M)%M;}\\n\\n    int func(int i,int j,vector<vector<int>> &grid,vector<vector<long long>> &dp)\\n    {\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=i+dx[k];\\n            int newy=j+dy[k];\\n            if(newx<0 || newy<0 || newx>=m || newy>=n)continue;\\n            if(grid[newx][newy]>grid[i][j])\\n            {\\n            if(dp[newx][newy]==0)\\n            {\\n                dp[i][j]=modadd(dp[i][j],func(newx,newy,grid,dp));\\n            }\\n            else\\n                dp[i][j]=modadd(dp[i][j],dp[newx][newy]);\\n            }\\n        }        \\n        dp[i][j]=modadd(dp[i][j],1);\\n        return dp[i][j];\\n    }\\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==0)\\n                    int lmao=func(i,j,grid,dp);\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                ans=modadd(ans,dp[i][j]);\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int M=1e9+7;\\n    long long ans=0;\\n    int m,n;\\n    vector<int> dx={0,1,0,-1};\\n    vector<int> dy={1,0,-1,0};\\n    long long modadd(long a,long b){return (a%M+b%M)%M;}\\n\\n    int func(int i,int j,vector<vector<int>> &grid,vector<vector<long long>> &dp)\\n    {\\n        for(int k=0;k<4;k++)\\n        {\\n            int newx=i+dx[k];\\n            int newy=j+dy[k];\\n            if(newx<0 || newy<0 || newx>=m || newy>=n)continue;\\n            if(grid[newx][newy]>grid[i][j])\\n            {\\n            if(dp[newx][newy]==0)\\n            {\\n                dp[i][j]=modadd(dp[i][j],func(newx,newy,grid,dp));\\n            }\\n            else\\n                dp[i][j]=modadd(dp[i][j],dp[newx][newy]);\\n            }\\n        }        \\n        dp[i][j]=modadd(dp[i][j],1);\\n        return dp[i][j];\\n    }\\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vector<vector<long long>> dp(m,vector<long long>(n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==0)\\n                    int lmao=func(i,j,grid,dp);\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                ans=modadd(ans,dp[i][j]);\\n        }\\n        return ans%M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230038,
                "title": "c-dp-dfs",
                "content": "```\\nint n, m;\\nconst int MOD = 1e9 + 7;\\n\\nvector<pair<int, int> > dir{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\nvector<vector<int> > dp;\\n\\nint dfs(vector<vector<int>>& G, int i, int j) {\\n    if (dp[i][j] != -1) return dp[i][j];\\n\\n    int cnt = 1;\\n    for (auto x : dir) {\\n        int ni = i + x.first, nj = j + x.second;\\n\\n        if (ni >= 0 && nj >= 0 && ni < n && nj < m && G[ni][nj] > G[i][j]) {\\n            cnt = (cnt % MOD + dfs(G, ni, nj) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[i][j] = cnt;\\n}\\n\\nint countPaths(vector<vector<int>>& G) {\\n    n = G.size(), m = G[0].size();\\n\\n    // dp[i][j] -> number of increasing paths from {i, j}\\n    dp.resize(n, vector<int> (m, -1));\\n\\n\\tint ans = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            ans = (ans % MOD + dfs(G, i, j) % MOD) % MOD;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nint n, m;\\nconst int MOD = 1e9 + 7;\\n\\nvector<pair<int, int> > dir{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\nvector<vector<int> > dp;\\n\\nint dfs(vector<vector<int>>& G, int i, int j) {\\n    if (dp[i][j] != -1) return dp[i][j];\\n\\n    int cnt = 1;\\n    for (auto x : dir) {\\n        int ni = i + x.first, nj = j + x.second;\\n\\n        if (ni >= 0 && nj >= 0 && ni < n && nj < m && G[ni][nj] > G[i][j]) {\\n            cnt = (cnt % MOD + dfs(G, ni, nj) % MOD) % MOD;\\n        }\\n    }\\n\\n    return dp[i][j] = cnt;\\n}\\n\\nint countPaths(vector<vector<int>>& G) {\\n    n = G.size(), m = G[0].size();\\n\\n    // dp[i][j] -> number of increasing paths from {i, j}\\n    dp.resize(n, vector<int> (m, -1));\\n\\n\\tint ans = 0;\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            ans = (ans % MOD + dfs(G, i, j) % MOD) % MOD;\\n        }\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229925,
                "title": "just-do-not-overthink-apply-dp",
                "content": "PreRequiste: \\nhttps://leetcode.com/problems/longest-increasing-path-in-a-matrix/\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> dx = {-1,1,0,0};\\n    vector<int> dy = {0,0,-1,1};\\n    \\n    int mod = 1e9 + 7;\\n    \\n    int dp[1001][1001];\\n    \\n    int m,n;\\n    \\n    int func(int x,int y,vector<vector<int>>& G){\\n        \\n        \\n        int ans = 0;\\n        if(dp[x][y] != -1) return dp[x][y];\\n        for(int d=0;d<4;d++){\\n            int X = x + dx[d];\\n            int Y = y + dy[d];\\n            \\n            if(X >= 0 and Y >= 0 and X < m and Y < n and G[X][Y] > G[x][y]){\\n                int tmp = func(X,Y,G);\\n                \\n                ans = (ans%mod + tmp%mod)%mod;\\n                \\n            }\\n            \\n        }\\n        \\n        return dp[x][y] = 1 + ans;\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& G) {\\n        m = G.size();\\n        n = G[0].size();\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans += func(i,j,G);\\n                ans%=mod;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> dx = {-1,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2229905,
                "title": "c-top-down-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    #define MAX 1000\\n    \\n    int mod = 1e9+7;\\n\\n    int solvefunction(vector<vector<int>>& grid, int dp[MAX][MAX],int n, int m,int x, int y)\\n  {\\n      if (dp[x][y] != -1)\\n            return dp[x][y];\\n \\n   \\n    int delta[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int newx, newy;\\n \\n   \\n    int ans = 1;\\n \\n    for (int i = 0; i < 4; i++) {\\n \\n       \\n        newx = x + delta[i][0];\\n        newy = y + delta[i][1];\\n \\n     \\n        if (newx >= 0 && newx < n && newy >= 0\\n            && newy < m && grid[newx][newy] > grid[x][y]) {\\n            ans += solvefunction(grid, dp, n, m,newx, newy);\\n            ans = ans% mod;\\n        }\\n    }\\n   \\n    return dp[x][y] = ans;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n        int dp[MAX][MAX];\\n        int n = grid.size();\\n        int m= grid[0].size();\\n \\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            dp[i][j] = -1;\\n \\n        int sum = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++){\\n            sum += solvefunction(grid, dp, n,m, i, j);\\n            sum = sum% mod;\\n        }\\n        \\n \\n        return sum % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define MAX 1000\\n    \\n    int mod = 1e9+7;\\n\\n    int solvefunction(vector<vector<int>>& grid, int dp[MAX][MAX],int n, int m,int x, int y)\\n  {\\n      if (dp[x][y] != -1)\\n            return dp[x][y];\\n \\n   \\n    int delta[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int newx, newy;\\n \\n   \\n    int ans = 1;\\n \\n    for (int i = 0; i < 4; i++) {\\n \\n       \\n        newx = x + delta[i][0];\\n        newy = y + delta[i][1];\\n \\n     \\n        if (newx >= 0 && newx < n && newy >= 0\\n            && newy < m && grid[newx][newy] > grid[x][y]) {\\n            ans += solvefunction(grid, dp, n, m,newx, newy);\\n            ans = ans% mod;\\n        }\\n    }\\n   \\n    return dp[x][y] = ans;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n        int dp[MAX][MAX];\\n        int n = grid.size();\\n        int m= grid[0].size();\\n \\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++)\\n            dp[i][j] = -1;\\n \\n        int sum = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n        for (int j = 0; j < m; j++){\\n            sum += solvefunction(grid, dp, n,m, i, j);\\n            sum = sum% mod;\\n        }\\n        \\n \\n        return sum % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651863,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4] ={0,0,-1,1};\\n    long long mod=1e9+7;\\n    int n;int m;\\n    bool valid(int i,int j){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n        return true;\\n    }\\n    long long c(int i,int j,vector<vector<int>>& g,vector<vector<long long>>& dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1;\\n        for(int k=0;k<4;k++){\\n            int ni=i+dx[k];\\n            int nj=j+dy[k];\\n            if(valid(ni,nj) && g[i][j]<g[ni][nj]){\\n                ans  =  (ans%mod+ c(ni,nj,g,dp)%mod)%mod;\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& g) {\\n         n=g.size(),m=g[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,-1));\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = (ans%mod +c(i,j,g,dp)%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/08612df9-441b-41aa-89a4-74c17d1485cf_1687080667.1954727.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={1,-1,0,0};\\n    int dy[4] ={0,0,-1,1};\\n    long long mod=1e9+7;\\n    int n;int m;\\n    bool valid(int i,int j){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n        return true;\\n    }\\n    long long c(int i,int j,vector<vector<int>>& g,vector<vector<long long>>& dp){\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1;\\n        for(int k=0;k<4;k++){\\n            int ni=i+dx[k];\\n            int nj=j+dy[k];\\n            if(valid(ni,nj) && g[i][j]<g[ni][nj]){\\n                ans  =  (ans%mod+ c(ni,nj,g,dp)%mod)%mod;\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& g) {\\n         n=g.size(),m=g[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,-1));\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = (ans%mod +c(i,j,g,dp)%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650289,
                "title": "c-dfs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon first glance, the problem seems to involve finding the number of paths in a grid. The task is to count the number of paths starting from each cell and traversing only to cells with greater values. \\n\\nTo approach this problem, a depth-first search (DFS) strategy combined with dynamic programming (DP) can be used. We can start from each cell in the grid and recursively explore all valid neighboring cells to calculate the number of paths starting from that cell. \\n\\nTo avoid redundant calculations, memoization can be employed by using a DP array to store the intermediate results. By memoizing the results, we can quickly retrieve the number of paths for previously visited cells instead of recomputing them.\\n\\nThe overall steps for the solution might involve:\\n1. Define a function to perform the DFS traversal and calculate the number of paths starting from a given cell.\\n2. Use a DP array to store the intermediate results. Initialize all values to -1.\\n3. Iterate over all cells in the grid and call the DFS function for each cell.\\n4. Sum up the number of paths for all cells and return the final result modulo the given value `1e9 + 7`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The approach to solving the problem involves using a combination of depth-first search (DFS) and dynamic programming (DP). Here is a step-by-step description of the approach:\\n\\n1. Define a recursive function, let\\'s call it `func`, that takes the following parameters: the grid, a DP array to store intermediate results, the current cell coordinates (x, y), and the dimensions of the grid (m, n).\\n\\n2. Inside the `func` function, initialize a variable `seju` to 1. This variable will represent the number of paths starting from the current cell.\\n\\n3. Check if the DP array already has a value for the current cell (dp[x][y] != -1). If it does, return the stored value from the DP array. This is a memoization step that avoids redundant calculations.\\n\\n4. Iterate over the four possible directions (up, down, left, and right) using the DX and DY arrays. For each direction, calculate the coordinates of the neighboring cell (cx, cy) relative to the current cell (x, y).\\n\\n5. Check if the neighboring cell (cx, cy) is within the grid boundaries (cx >= 0 && cx < m && cy >= 0 && cy < n) and if the value in the neighboring cell is greater than the current cell (grid[x][y] < grid[cx][cy]).\\n\\n6. If the above conditions are satisfied, recursively call the `func` function for the neighboring cell (cx, cy) and add the returned value to the `seju` variable. This step ensures that all valid paths starting from the current cell are explored.\\n\\n7. Store the calculated `seju` value in the DP array for the current cell (dp[x][y] = seju).\\n\\n8. Return the `seju` value modulo `1e9 + 7` as the number of paths starting from the current cell.\\n\\n9. In the `countPaths` function, initialize a variable `seju` to 0, which will be used to store the total number of paths.\\n\\n10. Iterate over all cells in the grid using nested loops. For each cell, call the `func` function to calculate the number of paths starting from that cell and add it to the `seju` variable.\\n\\n11. Finally, return the `seju` value modulo `1e9 + 7` as the total number of paths in the grid.DFS\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int DX[4] = {-1, 1, 0, 0};\\n    int DY[4] = {0, 0, -1, 1};\\n    \\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp, int x, int y, int m, int n) {\\n        long long seju = 1;\\n        \\n        // Check if the result for the current position is already calculated\\n        if (dp[x][y] != -1) {\\n            return dp[x][y];\\n        }\\n        \\n        // Iterate over the neighboring cells\\n        for (int i = 0; i < 4; i++) {\\n            int cx = x + DX[i];\\n            int cy = y + DY[i];\\n            \\n            // Check if the neighboring cell is within the grid boundaries and has a greater value\\n            if (cx >= 0 && cx < m && cy >= 0 && cy < n && grid[x][y] < grid[cx][cy]) {\\n                seju += func(grid, dp, cx, cy, m, n);\\n            }\\n        }\\n        \\n        // Store the calculated result in the dp array for future reference\\n        return dp[x][y] = seju % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp array to store the intermediate results\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long seju = 0;\\n        \\n        // Iterate over all cells in the grid\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Calculate the number of paths starting from each cell\\n                seju += func(grid, dp, i, j, m, n);\\n            }\\n        }\\n        \\n        // Return the total number of paths modulo 10^9 + 7\\n        return seju % mod;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/46c65077-f61d-4642-9cf5-59a424fe14c1_1687056302.0024745.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int DX[4] = {-1, 1, 0, 0};\\n    int DY[4] = {0, 0, -1, 1};\\n    \\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp, int x, int y, int m, int n) {\\n        long long seju = 1;\\n        \\n        // Check if the result for the current position is already calculated\\n        if (dp[x][y] != -1) {\\n            return dp[x][y];\\n        }\\n        \\n        // Iterate over the neighboring cells\\n        for (int i = 0; i < 4; i++) {\\n            int cx = x + DX[i];\\n            int cy = y + DY[i];\\n            \\n            // Check if the neighboring cell is within the grid boundaries and has a greater value\\n            if (cx >= 0 && cx < m && cy >= 0 && cy < n && grid[x][y] < grid[cx][cy]) {\\n                seju += func(grid, dp, cx, cy, m, n);\\n            }\\n        }\\n        \\n        // Store the calculated result in the dp array for future reference\\n        return dp[x][y] = seju % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp array to store the intermediate results\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long seju = 0;\\n        \\n        // Iterate over all cells in the grid\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Calculate the number of paths starting from each cell\\n                seju += func(grid, dp, i, j, m, n);\\n            }\\n        }\\n        \\n        // Return the total number of paths modulo 10^9 + 7\\n        return seju % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357504,
                "title": "python3-16-lines-recursion-w-explanation-t-m-84-73",
                "content": "```\\n                        # Here\\'s the plan:\\n                        #   \\u2022  We iterate through the 2D array and row by row,\\n                        #      determining for each cell the number of sequences that\\n                        #      begin with that cell.\\n                        #  \\n                        #   \\u2022  The sequence count for each cell is the sum of the\\n                        #      the sequence counts of its neighbors (up, right, down, left)\\n                        #      that have values greater than the value the cell, plus 1. If no \\n                        #      neighbors have greater values, then the cell\\'s count is 1.\\n                        #   \\n                        #   \\u2022  We determine the count for a cell recursively. We cache the\\n                        #      computed values to avoid redundant computation. The base \\n                        #      cases are those cells with a count of 1. Because we only recurse\\n                        #      to cells that have a greater value, we don\\'t need to be concerned\\n                        #      with revisiting cells.\\n\\n                        # Suppose for example:\\n                        #       grid  = [[2, 8, 9, 4],\\n                        #                [3, 1, 2, 4],\\n                        #                [5, 7, 6,13]]\\n```\\n![image](https://assets.leetcode.com/users/images/9b83455a-e343-4b29-957c-9f6c8236c9e5_1659233818.2863142.png)\\n```\\n                        # In the figure above, we iterate through the array, starting top-left at \\n                        # the cell with value 2. The cells that initiate the recursive calls are in \\n                        # squares. The base cases are in circles. (The cells visited in recursion \\n\\t\\t\\t\\t\\t\\t# starting with 2 are in red.)  The sum of the counts of all cells in the\\n                        # array is 44--we return this as the answer.\\n                        #\\ndef countPaths(self, grid: List[List[int]]) -> int:\\n        di, dj, mod, ans = 1, 0, 1000000007, 0\\n        R, C = range(len(grid)), range(len(grid[0]))\\n    \\n        @lru_cache(None)                            # <-- cache the results in recursion\\n        def dfs(i,j):                               \\n            nonlocal di, dj\\n            res = 0\\n            for _ in range(4):\\n                I, J, di, dj = i+di, j+dj, dj, -di  # <-- explores through neighbors\\n                if (I in R and J in C and \\n                    grid[I][J] > grid[i][j]):\\n                    res+= dfs(I,J)      \\n            return (1+res)%mod\\n\\n        for i in R:                                  # <-- iterates through the 2D array\\n            for j in C:                              #     and sums the counts of seq\\'s\\n                ans+= dfs(i,j)\\n        return  ans%mod\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n                        # Here\\'s the plan:\\n                        #   \\u2022  We iterate through the 2D array and row by row,\\n                        #      determining for each cell the number of sequences that\\n                        #      begin with that cell.\\n                        #  \\n                        #   \\u2022  The sequence count for each cell is the sum of the\\n                        #      the sequence counts of its neighbors (up, right, down, left)\\n                        #      that have values greater than the value the cell, plus 1. If no \\n                        #      neighbors have greater values, then the cell\\'s count is 1.\\n                        #   \\n                        #   \\u2022  We determine the count for a cell recursively. We cache the\\n                        #      computed values to avoid redundant computation. The base \\n                        #      cases are those cells with a count of 1. Because we only recurse\\n                        #      to cells that have a greater value, we don\\'t need to be concerned\\n                        #      with revisiting cells.\\n\\n                        # Suppose for example:\\n                        #       grid  = [[2, 8, 9, 4],\\n                        #                [3, 1, 2, 4],\\n                        #                [5, 7, 6,13]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230340,
                "title": "javascript-dfs-faster-than-100",
                "content": "```\\nvar countPaths = function(grid) {\\n  let mod = Math.pow(10, 9) + 7;\\n  let result = 0;\\n  let rows = grid.length, columns = grid[0].length;\\n  let dp = Array(rows).fill(null).map(_ => Array(columns).fill(0));\\n  \\n  const dfs = (r, c, preVal)=> {\\n    if (r < 0 || r == rows || c < 0 || c == columns || grid[r][c] <= preVal) return 0\\n    if (dp[r][c]) return dp[r][c]\\n    return dp[r][c] = (1 + dfs(r + 1, c, grid[r][c]) + \\n                       dfs(r - 1, c, grid[r][c]) + \\n                       dfs(r , c + 1, grid[r][c]) +  \\n                       dfs(r , c - 1, grid[r][c])) % mod;\\n  }\\n   for(let i = 0; i < rows; i++) {\\n    for(let j = 0; j < columns; j++) {\\n      result += dfs(i, j, -1) % mod;\\n    }\\n  }\\n \\n  return result % mod;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar countPaths = function(grid) {\\n  let mod = Math.pow(10, 9) + 7;\\n  let result = 0;\\n  let rows = grid.length, columns = grid[0].length;\\n  let dp = Array(rows).fill(null).map(_ => Array(columns).fill(0));\\n  \\n  const dfs = (r, c, preVal)=> {\\n    if (r < 0 || r == rows || c < 0 || c == columns || grid[r][c] <= preVal) return 0\\n    if (dp[r][c]) return dp[r][c]\\n    return dp[r][c] = (1 + dfs(r + 1, c, grid[r][c]) + \\n                       dfs(r - 1, c, grid[r][c]) + \\n                       dfs(r , c + 1, grid[r][c]) +  \\n                       dfs(r , c - 1, grid[r][c])) % mod;\\n  }\\n   for(let i = 0; i < rows; i++) {\\n    for(let j = 0; j < columns; j++) {\\n      result += dfs(i, j, -1) % mod;\\n    }\\n  }\\n \\n  return result % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650288,
                "title": "c-dfs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon first glance, the problem seems to involve finding the number of paths in a grid. The task is to count the number of paths starting from each cell and traversing only to cells with greater values. \\n\\nTo approach this problem, a depth-first search (DFS) strategy combined with dynamic programming (DP) can be used. We can start from each cell in the grid and recursively explore all valid neighboring cells to calculate the number of paths starting from that cell. \\n\\nTo avoid redundant calculations, memoization can be employed by using a DP array to store the intermediate results. By memoizing the results, we can quickly retrieve the number of paths for previously visited cells instead of recomputing them.\\n\\nThe overall steps for the solution might involve:\\n1. Define a function to perform the DFS traversal and calculate the number of paths starting from a given cell.\\n2. Use a DP array to store the intermediate results. Initialize all values to -1.\\n3. Iterate over all cells in the grid and call the DFS function for each cell.\\n4. Sum up the number of paths for all cells and return the final result modulo the given value `1e9 + 7`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The approach to solving the problem involves using a combination of depth-first search (DFS) and dynamic programming (DP). Here is a step-by-step description of the approach:\\n\\n1. Define a recursive function, let\\'s call it `func`, that takes the following parameters: the grid, a DP array to store intermediate results, the current cell coordinates (x, y), and the dimensions of the grid (m, n).\\n\\n2. Inside the `func` function, initialize a variable `seju` to 1. This variable will represent the number of paths starting from the current cell.\\n\\n3. Check if the DP array already has a value for the current cell (dp[x][y] != -1). If it does, return the stored value from the DP array. This is a memoization step that avoids redundant calculations.\\n\\n4. Iterate over the four possible directions (up, down, left, and right) using the DX and DY arrays. For each direction, calculate the coordinates of the neighboring cell (cx, cy) relative to the current cell (x, y).\\n\\n5. Check if the neighboring cell (cx, cy) is within the grid boundaries (cx >= 0 && cx < m && cy >= 0 && cy < n) and if the value in the neighboring cell is greater than the current cell (grid[x][y] < grid[cx][cy]).\\n\\n6. If the above conditions are satisfied, recursively call the `func` function for the neighboring cell (cx, cy) and add the returned value to the `seju` variable. This step ensures that all valid paths starting from the current cell are explored.\\n\\n7. Store the calculated `seju` value in the DP array for the current cell (dp[x][y] = seju).\\n\\n8. Return the `seju` value modulo `1e9 + 7` as the number of paths starting from the current cell.\\n\\n9. In the `countPaths` function, initialize a variable `seju` to 0, which will be used to store the total number of paths.\\n\\n10. Iterate over all cells in the grid using nested loops. For each cell, call the `func` function to calculate the number of paths starting from that cell and add it to the `seju` variable.\\n\\n11. Finally, return the `seju` value modulo `1e9 + 7` as the total number of paths in the grid.DFS\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int DX[4] = {-1, 1, 0, 0};\\n    int DY[4] = {0, 0, -1, 1};\\n    \\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp, int x, int y, int m, int n) {\\n        long long seju = 1;\\n        \\n        // Check if the result for the current position is already calculated\\n        if (dp[x][y] != -1) {\\n            return dp[x][y];\\n        }\\n        \\n        // Iterate over the neighboring cells\\n        for (int i = 0; i < 4; i++) {\\n            int cx = x + DX[i];\\n            int cy = y + DY[i];\\n            \\n            // Check if the neighboring cell is within the grid boundaries and has a greater value\\n            if (cx >= 0 && cx < m && cy >= 0 && cy < n && grid[x][y] < grid[cx][cy]) {\\n                seju += func(grid, dp, cx, cy, m, n);\\n            }\\n        }\\n        \\n        // Store the calculated result in the dp array for future reference\\n        return dp[x][y] = seju % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp array to store the intermediate results\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long seju = 0;\\n        \\n        // Iterate over all cells in the grid\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Calculate the number of paths starting from each cell\\n                seju += func(grid, dp, i, j, m, n);\\n            }\\n        }\\n        \\n        // Return the total number of paths modulo 10^9 + 7\\n        return seju % mod;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/46c65077-f61d-4642-9cf5-59a424fe14c1_1687056302.0024745.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int DX[4] = {-1, 1, 0, 0};\\n    int DY[4] = {0, 0, -1, 1};\\n    \\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp, int x, int y, int m, int n) {\\n        long long seju = 1;\\n        \\n        // Check if the result for the current position is already calculated\\n        if (dp[x][y] != -1) {\\n            return dp[x][y];\\n        }\\n        \\n        // Iterate over the neighboring cells\\n        for (int i = 0; i < 4; i++) {\\n            int cx = x + DX[i];\\n            int cy = y + DY[i];\\n            \\n            // Check if the neighboring cell is within the grid boundaries and has a greater value\\n            if (cx >= 0 && cx < m && cy >= 0 && cy < n && grid[x][y] < grid[cx][cy]) {\\n                seju += func(grid, dp, cx, cy, m, n);\\n            }\\n        }\\n        \\n        // Store the calculated result in the dp array for future reference\\n        return dp[x][y] = seju % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // Create a dp array to store the intermediate results\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long seju = 0;\\n        \\n        // Iterate over all cells in the grid\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // Calculate the number of paths starting from each cell\\n                seju += func(grid, dp, i, j, m, n);\\n            }\\n        }\\n        \\n        // Return the total number of paths modulo 10^9 + 7\\n        return seju % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650209,
                "title": "easy-solution-video-java-c-python",
                "content": "# Intuition\\nLets take a simple example [3,4] the paths are [3] ,[4], [3,4] \\nThe paths starting from 3 = 1+ paths starting from 4. = 1+1\\n\\nthis applies in all 4 directions: paths starting at [3] = total paths on left, right, up and down.\\n\\nRemember we can return 0 if the number is lesser than 3. say if on top of 3 there\\'s a 2, it will contribute 0 to the sum.\\n\\ndfs[i,j] = dfs of all 4 directions+1\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/SRgwyt6Wu-0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    int [][] dp;\\n    int [] di = {0,0,-1,1};\\n    int [] dj = {-1,1,0,0};\\n    int mod = 1000000007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new int[n][m];\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = (ans+dfs(grid, i, j, -1))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int dfs(int [][] grid, int i, int j, int prev){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        dp[i][j] = 1;\\n        for(int k = 0;k<4;k++){\\n            dp[i][j] += dfs(grid, i+di[k],j+dj[k], grid[i][j]);\\n            dp[i][j] = dp[i][j]%mod;\\n        }\\n        return dp[i][j]%mod;\\n        \\n    }\\n}\\n```\\n\\n```\\n\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    vector<int> di = {0, 0, -1, 1};\\n    vector<int> dj = {-1, 1, 0, 0};\\n    int mod = 1000000007;\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans = (ans + dfs(grid, i, j, -1)) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int prev) {\\n        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] <= prev) {\\n            return 0;\\n        }\\n        if (dp[i][j] != 0) {\\n            return dp[i][j];\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < 4; k++) {\\n            dp[i][j] += dfs(grid, i + di[k], j + dj[k], grid[i][j]);\\n            dp[i][j] %= mod;\\n        }\\n        return dp[i][j] % mod;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dp = None\\n        self.di = [0, 0, -1, 1]\\n        self.dj = [-1, 1, 0, 0]\\n        self.mod = 1000000007\\n    \\n    def countPaths(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n        self.dp = [[0] * m for _ in range(n)]\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                ans = (ans + self.dfs(grid, i, j, -1)) % self.mod\\n        return ans\\n    \\n    def dfs(self, grid, i, j, prev):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] <= prev:\\n            return 0\\n        if self.dp[i][j] != 0:\\n            return self.dp[i][j]\\n        self.dp[i][j] = 1\\n        for k in range(4):\\n            self.dp[i][j] += self.dfs(grid, i + self.di[k], j + self.dj[k], grid[i][j])\\n            self.dp[i][j] %= self.mod\\n        return self.dp[i][j] % self.mod\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int [][] dp;\\n    int [] di = {0,0,-1,1};\\n    int [] dj = {-1,1,0,0};\\n    int mod = 1000000007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        dp = new int[n][m];\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = (ans+dfs(grid, i, j, -1))%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public int dfs(int [][] grid, int i, int j, int prev){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        dp[i][j] = 1;\\n        for(int k = 0;k<4;k++){\\n            dp[i][j] += dfs(grid, i+di[k],j+dj[k], grid[i][j]);\\n            dp[i][j] = dp[i][j]%mod;\\n        }\\n        return dp[i][j]%mod;\\n        \\n    }\\n}\\n```\n```\\n\\n\\nclass Solution {\\n    vector<vector<int>> dp;\\n    vector<int> di = {0, 0, -1, 1};\\n    vector<int> dj = {-1, 1, 0, 0};\\n    int mod = 1000000007;\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m));\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                ans = (ans + dfs(grid, i, j, -1)) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int prev) {\\n        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] <= prev) {\\n            return 0;\\n        }\\n        if (dp[i][j] != 0) {\\n            return dp[i][j];\\n        }\\n        dp[i][j] = 1;\\n        for (int k = 0; k < 4; k++) {\\n            dp[i][j] += dfs(grid, i + di[k], j + dj[k], grid[i][j]);\\n            dp[i][j] %= mod;\\n        }\\n        return dp[i][j] % mod;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.dp = None\\n        self.di = [0, 0, -1, 1]\\n        self.dj = [-1, 1, 0, 0]\\n        self.mod = 1000000007\\n    \\n    def countPaths(self, grid):\\n        n = len(grid)\\n        m = len(grid[0])\\n        self.dp = [[0] * m for _ in range(n)]\\n        ans = 0\\n        for i in range(n):\\n            for j in range(m):\\n                ans = (ans + self.dfs(grid, i, j, -1)) % self.mod\\n        return ans\\n    \\n    def dfs(self, grid, i, j, prev):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] <= prev:\\n            return 0\\n        if self.dp[i][j] != 0:\\n            return self.dp[i][j]\\n        self.dp[i][j] = 1\\n        for k in range(4):\\n            self.dp[i][j] += self.dfs(grid, i + self.di[k], j + self.dj[k], grid[i][j])\\n            self.dp[i][j] %= self.mod\\n        return self.dp[i][j] % self.mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650170,
                "title": "dfs-c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &m,int &n,vector<vector<int>> &g,vector<vector<int>> &dp,int &mod){\\n    if(i<0||j<0||i>=m||j>=n)return 0;\\n    if(dp[i][j]>0)return dp[i][j];\\n    int a = 0, b = 0, c = 0, d = 0;\\n    if(i+1<m && g[i][j] < g[i+1][j]){\\n        a = solve(i+1,j,m,n,g,dp,mod);\\n    }\\n    if(i-1>=0 && g[i][j] < g[i-1][j]){\\n        b = solve(i-1,j,m,n,g,dp,mod);\\n    }\\n    if(j+1<n && g[i][j] < g[i][j+1]){\\n        c = solve(i,j+1,m,n,g,dp,mod);\\n    }\\n    if(j-1>=0 && g[i][j] < g[i][j-1]){\\n        d = solve(i,j-1,m,n,g,dp,mod);\\n    }\\n    return dp[i][j] = ((((a+b)%mod+c)%mod+d)%mod+1)%mod;\\n}\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size();\\n        int ans = 0, mod = 1e9+7;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]<0){\\n                    solve(i,j,m,n,grid,dp,mod);\\n                }\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        // ans = 0;\\n        // for(auto &i: dp){\\n        //     for(auto &j: i)\\n        //         cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &m,int &n,vector<vector<int>> &g,vector<vector<int>> &dp,int &mod){\\n    if(i<0||j<0||i>=m||j>=n)return 0;\\n    if(dp[i][j]>0)return dp[i][j];\\n    int a = 0, b = 0, c = 0, d = 0;\\n    if(i+1<m && g[i][j] < g[i+1][j]){\\n        a = solve(i+1,j,m,n,g,dp,mod);\\n    }\\n    if(i-1>=0 && g[i][j] < g[i-1][j]){\\n        b = solve(i-1,j,m,n,g,dp,mod);\\n    }\\n    if(j+1<n && g[i][j] < g[i][j+1]){\\n        c = solve(i,j+1,m,n,g,dp,mod);\\n    }\\n    if(j-1>=0 && g[i][j] < g[i][j-1]){\\n        d = solve(i,j-1,m,n,g,dp,mod);\\n    }\\n    return dp[i][j] = ((((a+b)%mod+c)%mod+d)%mod+1)%mod;\\n}\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size();\\n        int ans = 0, mod = 1e9+7;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]<0){\\n                    solve(i,j,m,n,grid,dp,mod);\\n                }\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        // ans = 0;\\n        // for(auto &i: dp){\\n        //     for(auto &j: i)\\n        //         cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2229862,
                "title": "c-dfs-dp-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int DX[4]={-1,1,0,0};\\n    int DY[4]={0,0,-1,1};\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp,int x, int y, int m, int n){\\n        long long cnt=1;\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        \\n        for(int i=0;i<4;i++){\\n            int cx=x+DX[i], cy=y+DY[i];\\n            if(cx>=0 && cx<m && cy>=0 && cy<n && grid[x][y]<grid[cx][cy]){\\n                cnt+=func(grid,dp,cx,cy,m,n);\\n            }\\n        }\\n        \\n        return dp[x][y]=cnt%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n       int m=grid.size(), n=grid[0].size();  \\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        long long cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                cnt+=func(grid,dp,i,j,m,n);\\n            }\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int DX[4]={-1,1,0,0};\\n    int DY[4]={0,0,-1,1};\\n    int func(vector<vector<int>>& grid, vector<vector<int>>& dp,int x, int y, int m, int n){\\n        long long cnt=1;\\n        if(dp[x][y]!=-1){\\n            return dp[x][y];\\n        }\\n        \\n        for(int i=0;i<4;i++){\\n            int cx=x+DX[i], cy=y+DY[i];\\n            if(cx>=0 && cx<m && cy>=0 && cy<n && grid[x][y]<grid[cx][cy]){\\n                cnt+=func(grid,dp,cx,cy,m,n);\\n            }\\n        }\\n        \\n        return dp[x][y]=cnt%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n       int m=grid.size(), n=grid[0].size();  \\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        long long cnt=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                cnt+=func(grid,dp,i,j,m,n);\\n            }\\n        }\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652087,
                "title": "golang-topological-sort",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\nfunc countPaths(grid [][]int) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n    MOD := 1000000007\\n\\n    inDegree := make([][]int, m)\\n    for r := 0; r < m; r++ {\\n        inDegree[r] = make([]int, n)\\n    }\\n\\n    // Find InDegree O(m*n)\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            for _, dir := range [][]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} {\\n                nr := r + dir[0]\\n                nc := c + dir[1]\\n\\n                if nr < 0 || nc < 0 || nr == m || nc == n {\\n                    continue\\n                }\\n                if grid[nr][nc] > grid[r][c] {\\n                    inDegree[nr][nc]++\\n                }\\n            }\\n        }\\n    }\\n\\n    dp := make([][]int, m)\\n    for r := 0; r < m; r++ {\\n        dp[r] = make([]int, n)\\n        for c := 0; c < n; c++ {\\n            dp[r][c] = 1\\n        }\\n    }\\n\\n    // Find Starting cells O(m*n)\\n    queue := [][]int{}\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if inDegree[r][c] == 0 {\\n                queue = append(queue, []int{r, c})\\n            }\\n        }\\n    }\\n\\n    // Find Paths O(m*n)\\n    for len(queue) > 0 {\\n        cell := queue[0]\\n        queue = queue[1:]\\n        r := cell[0]\\n        c := cell[1]\\n\\n        for _, dir := range [][]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} {\\n            nr := r + dir[0]\\n            nc := c + dir[1]\\n\\n            if nr < 0 || nc < 0 || nr == m || nc == n {\\n                continue\\n            }\\n                \\n            if grid[nr][nc] > grid[r][c] {\\n                inDegree[nr][nc]--\\n                dp[nr][nc] = (dp[nr][nc] + dp[r][c]) % MOD\\n                if inDegree[nr][nc] == 0 {\\n                    queue = append(queue, []int{nr, nc})\\n                }\\n            }\\n        }\\n    }\\n\\n    // Sum Up Paths O(m*n)\\n    res := 0\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            res =  (res + dp[r][c]) % MOD\\n        }\\n    }\\n    return res   \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPaths(grid [][]int) int {\\n    m := len(grid)\\n    n := len(grid[0])\\n    MOD := 1000000007\\n\\n    inDegree := make([][]int, m)\\n    for r := 0; r < m; r++ {\\n        inDegree[r] = make([]int, n)\\n    }\\n\\n    // Find InDegree O(m*n)\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            for _, dir := range [][]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} {\\n                nr := r + dir[0]\\n                nc := c + dir[1]\\n\\n                if nr < 0 || nc < 0 || nr == m || nc == n {\\n                    continue\\n                }\\n                if grid[nr][nc] > grid[r][c] {\\n                    inDegree[nr][nc]++\\n                }\\n            }\\n        }\\n    }\\n\\n    dp := make([][]int, m)\\n    for r := 0; r < m; r++ {\\n        dp[r] = make([]int, n)\\n        for c := 0; c < n; c++ {\\n            dp[r][c] = 1\\n        }\\n    }\\n\\n    // Find Starting cells O(m*n)\\n    queue := [][]int{}\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if inDegree[r][c] == 0 {\\n                queue = append(queue, []int{r, c})\\n            }\\n        }\\n    }\\n\\n    // Find Paths O(m*n)\\n    for len(queue) > 0 {\\n        cell := queue[0]\\n        queue = queue[1:]\\n        r := cell[0]\\n        c := cell[1]\\n\\n        for _, dir := range [][]int{{-1, 0}, {0, -1}, {1, 0}, {0, 1}} {\\n            nr := r + dir[0]\\n            nc := c + dir[1]\\n\\n            if nr < 0 || nc < 0 || nr == m || nc == n {\\n                continue\\n            }\\n                \\n            if grid[nr][nc] > grid[r][c] {\\n                inDegree[nr][nc]--\\n                dp[nr][nc] = (dp[nr][nc] + dp[r][c]) % MOD\\n                if inDegree[nr][nc] == 0 {\\n                    queue = append(queue, []int{nr, nc})\\n                }\\n            }\\n        }\\n    }\\n\\n    // Sum Up Paths O(m*n)\\n    res := 0\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            res =  (res + dp[r][c]) % MOD\\n        }\\n    }\\n    return res   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650724,
                "title": "c-striver-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int f(vector<vector<int>>& grid, int i, int j, int preVal,vector<vector<int>>&dp){\\n//check for valid traversal ie inside grid \\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || preVal >= grid[i][j])return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n   \\n        dp[i][j] = 1;\\n        //traverse all 4 directions\\n        int l = f(grid, i, j - 1, grid[i][j],dp);\\n        int r = f(grid, i, j + 1, grid[i][j],dp);\\n        int u = f(grid, i - 1, j, grid[i][j],dp);\\n        int d = f(grid, i + 1, j, grid[i][j],dp);\\n        //taking mod and summing up all the values\\n        return dp[i][j] = (dp[i][j] + l + r + u + d) % 1000000007;\\n\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int md = 1000000007;\\n        int n=grid.size();\\n        int m=grid[0].size();\\nvector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                ans = (ans + f(grid, i, j, -1,dp)) % md;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int f(vector<vector<int>>& grid, int i, int j, int preVal,vector<vector<int>>&dp){\\n//check for valid traversal ie inside grid \\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || preVal >= grid[i][j])return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n   \\n        dp[i][j] = 1;\\n        //traverse all 4 directions\\n        int l = f(grid, i, j - 1, grid[i][j],dp);\\n        int r = f(grid, i, j + 1, grid[i][j],dp);\\n        int u = f(grid, i - 1, j, grid[i][j],dp);\\n        int d = f(grid, i + 1, j, grid[i][j],dp);\\n        //taking mod and summing up all the values\\n        return dp[i][j] = (dp[i][j] + l + r + u + d) % 1000000007;\\n\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int md = 1000000007;\\n        int n=grid.size();\\n        int m=grid[0].size();\\nvector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                ans = (ans + f(grid, i, j, -1,dp)) % md;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650320,
                "title": "easy-c-python-dfs-solutions-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse standard DFS to solve! After the DFS process, the value for visited[i][j] is the number of ways for starting from position (i, j) modulo the pretty prime number  $10^9+7$!( since the if-condition is set to be grid[a][b]>grid[i][j] for (a, b) adjacent to (i, j) )\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstandard DFS algoirhm \\n```\\nDFS(i, j):\\n   if visited(i, j)==-1:\\n      ans = 1\\n      for each (a, b) adjacent to (i, j)  within the grid:\\n         if grid(a, b) > grid(i, j):\\n            ans += DFS(a, b)\\n      visited(i, j)=ans\\n      return ans\\t\\n```\\nA 2D list called visited is created to track the visited state of each position in the grid. All positions are initialized to -1, indicating they have not been visited.\\n\\nThe dfs function performs a depth-first search. It takes the current position as input. If the current position has been visited before, it returns the previously calculated result. Otherwise, it calculates the number of paths from the current position to the destination by exploring valid adjacent positions and recursively calling dfs on them. The result is saved in the visited state for future reference and returned.\\n\\nA test case produced by me.\\n```\\n[[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13],[5,6,7,8,9,92,11,12,13,14],[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13],[5,6,7,689,9,10,11,12,13,14]]\\n```\\nThe array visited after DFS process\\n```\\nResult: 22623\\n 2582 1777 1181  751  451  251  126   55   20    5\\n  804  595  429  299  199  124   70   34   14    4\\n  208  165  129   99   74   53   35   19    9    3\\n   42   35   29   24   20   17   15    9    5    2\\n    6    5    4    3    2    1    5    3    2    1\\n 2859 1957 1287  806  476  263  136   61   23    6\\n  895  664  476  326  210  125   69   34   14    4\\n  230  187  149  115   84   55   34   19    9    3\\n   42   37   33   30   28   20   14    9    5    2\\n    4    3    2    1    7    5    4    3    2    1\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$ O(n * m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$ O(n * m)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    int countPaths(vector<vector<int>>& grid) {\\n        const int Mod=1e9+7;\\n        int n=grid.size(), m=grid[0].size();\\n        //cout<<n<<\",\"<<m<<endl;\\n        vector<vector<int>> visited(n, vector<int>(m, -1));\\n        \\n        function<int(int, int)> dfs=[&](int i, int j){\\n        //\\tcout<<\"i=\"<<i<<\",j=\"<<j<<\"->\"<<grid[i][j]<<endl;\\n            if (visited[i][j]!=-1) return visited[i][j];\\n            long result=1;\\n            vector<int2> adj={{i+1, j},{i, j+1}, {i-1, j}, {i, j-1}};\\n            for(auto& [a, b]: adj){\\n            \\tif (a>=0 && a<n && b>=0 && b<m) \\n                    if (grid[a][b]>grid[i][j]){\\t//strictly increasing\\n                    //    cout<<\"(\"<<a<<\",\"<<b<<\")\\\\n\";\\n                        result=(result+dfs(a, b))%Mod;\\n                    }   \\n            }\\n            return visited[i][j]=result;\\n        };\\n\\n        long result=0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++){\\n            \\tif (visited[i][j]==-1)\\n                    dfs(i, j);\\n                result=(result+visited[i][j])%Mod;\\n            }\\n        return result;\\n    }\\n};\\n\\n```\\n# Python solution w Explanation in comments\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        Mod = 10**9+7  # Define the modulus\\n        n, m = len(grid), len(grid[0])  # Get the size of the grid\\n        row = [-1 for _ in range(m)]  # Initialize the visited state of each row as -1\\n        visited = [row[:] for _ in range(n)]  # Initialize the visited state of the entire grid as -1\\n\\n        def dfs(i, j):\\n            if visited[i][j] != -1:  # If the position has been visited before, directly return the visited result\\n                return visited[i][j]\\n            result = 1  # Initial result is 1, representing the number of paths from the current position to the destination\\n            adj = [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]  # Define the four directions for adjacent positions\\n            for a, b in adj:\\n                if 0 <= a < n and 0 <= b < m:  # Make sure the adjacent position is within the grid\\n                    if grid[a][b] > grid[i][j]:  # If the height of the adjacent position is greater than the current position, continue exploring in that direction\\n                        result = (result + dfs(a, b)) % Mod  # Update the result and take the modulus\\n            visited[i][j] = result  # Save the result to the visited state to avoid duplicate calculations\\n            return result\\n\\n        result = 0  # Initial result is 0\\n        for i in range(n):\\n            for j in range(m):\\n                if visited[i][j] == -1:  # If the position has not been visited yet, perform depth-first search\\n                    visited[i][j] = dfs(i, j)  # Update the visited result of that position\\n                result = (result + visited[i][j]) % Mod  # Add the visited result of that position to the final result and take the modulus\\n\\n        # Uncomment the following line to print the visited state matrix\\n        # print(visited)\\n\\n        return result  # Return the final result\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nDFS(i, j):\\n   if visited(i, j)==-1:\\n      ans = 1\\n      for each (a, b) adjacent to (i, j)  within the grid:\\n         if grid(a, b) > grid(i, j):\\n            ans += DFS(a, b)\\n      visited(i, j)=ans\\n      return ans\\t\\n```\n```\\n[[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13],[5,6,7,8,9,92,11,12,13,14],[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13],[5,6,7,689,9,10,11,12,13,14]]\\n```\n```\\nResult: 22623\\n 2582 1777 1181  751  451  251  126   55   20    5\\n  804  595  429  299  199  124   70   34   14    4\\n  208  165  129   99   74   53   35   19    9    3\\n   42   35   29   24   20   17   15    9    5    2\\n    6    5    4    3    2    1    5    3    2    1\\n 2859 1957 1287  806  476  263  136   61   23    6\\n  895  664  476  326  210  125   69   34   14    4\\n  230  187  149  115   84   55   34   19    9    3\\n   42   37   33   30   28   20   14    9    5    2\\n    4    3    2    1    7    5    4    3    2    1\\n```\n```\\nclass Solution {\\npublic:\\n    using int2=pair<int, int>;\\n    int countPaths(vector<vector<int>>& grid) {\\n        const int Mod=1e9+7;\\n        int n=grid.size(), m=grid[0].size();\\n        //cout<<n<<\",\"<<m<<endl;\\n        vector<vector<int>> visited(n, vector<int>(m, -1));\\n        \\n        function<int(int, int)> dfs=[&](int i, int j){\\n        //\\tcout<<\"i=\"<<i<<\",j=\"<<j<<\"->\"<<grid[i][j]<<endl;\\n            if (visited[i][j]!=-1) return visited[i][j];\\n            long result=1;\\n            vector<int2> adj={{i+1, j},{i, j+1}, {i-1, j}, {i, j-1}};\\n            for(auto& [a, b]: adj){\\n            \\tif (a>=0 && a<n && b>=0 && b<m) \\n                    if (grid[a][b]>grid[i][j]){\\t//strictly increasing\\n                    //    cout<<\"(\"<<a<<\",\"<<b<<\")\\\\n\";\\n                        result=(result+dfs(a, b))%Mod;\\n                    }   \\n            }\\n            return visited[i][j]=result;\\n        };\\n\\n        long result=0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++){\\n            \\tif (visited[i][j]==-1)\\n                    dfs(i, j);\\n                result=(result+visited[i][j])%Mod;\\n            }\\n        return result;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        Mod = 10**9+7  # Define the modulus\\n        n, m = len(grid), len(grid[0])  # Get the size of the grid\\n        row = [-1 for _ in range(m)]  # Initialize the visited state of each row as -1\\n        visited = [row[:] for _ in range(n)]  # Initialize the visited state of the entire grid as -1\\n\\n        def dfs(i, j):\\n            if visited[i][j] != -1:  # If the position has been visited before, directly return the visited result\\n                return visited[i][j]\\n            result = 1  # Initial result is 1, representing the number of paths from the current position to the destination\\n            adj = [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]  # Define the four directions for adjacent positions\\n            for a, b in adj:\\n                if 0 <= a < n and 0 <= b < m:  # Make sure the adjacent position is within the grid\\n                    if grid[a][b] > grid[i][j]:  # If the height of the adjacent position is greater than the current position, continue exploring in that direction\\n                        result = (result + dfs(a, b)) % Mod  # Update the result and take the modulus\\n            visited[i][j] = result  # Save the result to the visited state to avoid duplicate calculations\\n            return result\\n\\n        result = 0  # Initial result is 0\\n        for i in range(n):\\n            for j in range(m):\\n                if visited[i][j] == -1:  # If the position has not been visited yet, perform depth-first search\\n                    visited[i][j] = dfs(i, j)  # Update the visited result of that position\\n                result = (result + visited[i][j]) % Mod  # Add the visited result of that position to the final result and take the modulus\\n\\n        # Uncomment the following line to print the visited state matrix\\n        # print(visited)\\n\\n        return result  # Return the final result\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3561201,
                "title": "dfs-c-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &m,int &n,vector<vector<int>> &g,vector<vector<int>> &dp,int &mod){\\n    if(i<0||j<0||i>=m||j>=n)return 0;\\n    if(dp[i][j]>0)return dp[i][j];\\n    int a = 0, b = 0, c = 0, d = 0;\\n    if(i+1<m && g[i][j] < g[i+1][j]){\\n        a = solve(i+1,j,m,n,g,dp,mod);\\n    }\\n    if(i-1>=0 && g[i][j] < g[i-1][j]){\\n        b = solve(i-1,j,m,n,g,dp,mod);\\n    }\\n    if(j+1<n && g[i][j] < g[i][j+1]){\\n        c = solve(i,j+1,m,n,g,dp,mod);\\n    }\\n    if(j-1>=0 && g[i][j] < g[i][j-1]){\\n        d = solve(i,j-1,m,n,g,dp,mod);\\n    }\\n    return dp[i][j] = ((((a+b)%mod+c)%mod+d)%mod+1)%mod;\\n}\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size();\\n        int ans = 0, mod = 1e9+7;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]<0){\\n                    solve(i,j,m,n,grid,dp,mod);\\n                }\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        // ans = 0;\\n        // for(auto &i: dp){\\n        //     for(auto &j: i)\\n        //         cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(int i,int j,int &m,int &n,vector<vector<int>> &g,vector<vector<int>> &dp,int &mod){\\n    if(i<0||j<0||i>=m||j>=n)return 0;\\n    if(dp[i][j]>0)return dp[i][j];\\n    int a = 0, b = 0, c = 0, d = 0;\\n    if(i+1<m && g[i][j] < g[i+1][j]){\\n        a = solve(i+1,j,m,n,g,dp,mod);\\n    }\\n    if(i-1>=0 && g[i][j] < g[i-1][j]){\\n        b = solve(i-1,j,m,n,g,dp,mod);\\n    }\\n    if(j+1<n && g[i][j] < g[i][j+1]){\\n        c = solve(i,j+1,m,n,g,dp,mod);\\n    }\\n    if(j-1>=0 && g[i][j] < g[i][j-1]){\\n        d = solve(i,j-1,m,n,g,dp,mod);\\n    }\\n    return dp[i][j] = ((((a+b)%mod+c)%mod+d)%mod+1)%mod;\\n}\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i = 0, j = 0, m = grid.size(), n = grid[0].size();\\n        int ans = 0, mod = 1e9+7;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(dp[i][j]<0){\\n                    solve(i,j,m,n,grid,dp,mod);\\n                }\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        // ans = 0;\\n        // for(auto &i: dp){\\n        //     for(auto &j: i)\\n        //         cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2732261,
                "title": "c-dfs-memo-sol",
                "content": "```\\nclass Solution {\\n    int n,m,ans = 0,mod = 1e9+7;\\n    using vvi = vector<vector<int>>;\\n    vector<int>  dx{0,0,1,-1}, dy{1,-1,0,0};\\n    int dfs(int i,int j,vvi& grid,vvi& dp){\\n        if(dp[i][j]!=1) return dp[i][j];\\n        int count = 1;\\n        for(int k = 0;k<4;k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(x<0 || y<0 || y>=m || x>=n)continue;\\n            if(grid[x][y]>grid[i][j]) count = (count+dfs(x,y,grid,dp))%mod;\\n        }\\n        return dp[i][j] = count;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        n = grid.size(),m = grid[0].size();\\n        vvi dp(n,vector(m,1));\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++) ans = (ans + dfs(i,j,grid,dp))%mod;\\n            // cout<<ans<<\" \\\\n\";\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(int i:it)cout<<i<<\" \";\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int n,m,ans = 0,mod = 1e9+7;\\n    using vvi = vector<vector<int>>;\\n    vector<int>  dx{0,0,1,-1}, dy{1,-1,0,0};\\n    int dfs(int i,int j,vvi& grid,vvi& dp){\\n        if(dp[i][j]!=1) return dp[i][j];\\n        int count = 1;\\n        for(int k = 0;k<4;k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(x<0 || y<0 || y>=m || x>=n)continue;\\n            if(grid[x][y]>grid[i][j]) count = (count+dfs(x,y,grid,dp))%mod;\\n        }\\n        return dp[i][j] = count;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        n = grid.size(),m = grid[0].size();\\n        vvi dp(n,vector(m,1));\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++) ans = (ans + dfs(i,j,grid,dp))%mod;\\n            // cout<<ans<<\" \\\\n\";\\n        }\\n        \\n        // for(auto it:dp){\\n        //     for(int i:it)cout<<i<<\" \";\\n        //     cout<<endl;\\n        // }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2241760,
                "title": "java-recursion-memoization-faster-than-90-74-of-java-online-submissions",
                "content": "**Approach**\\n* Treat each index `grid[i][j]` as the starting point for an strictly increasing path.\\n* From each index travel *up, down, left, right* recursively counting length of the path.\\n* Add to the final result the total number of cells (`grid.length*grid[0].length`) in the grid for each path of length 1.\\n\\n**Code**\\n```\\nclass Solution {\\n    int[][] dp;\\n    int mod = (int) 1e9+7;\\n    public int countPaths(int[][] grid) {\\n        int res = 0;\\n        dp = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                res += f(i, j, grid); \\n                res %= mod;\\n            }\\n        }\\n        return (res + grid.length*grid[0].length) % mod;\\n    }\\n    \\n    private int f(int i, int j, int[][] grid) {\\n        \\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        int count = 0;\\n        \\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length) return 0;\\n        \\n        // Up\\n        if(i > 0 && grid[i][j] < grid[i-1][j])\\n            count += f(i-1, j, grid) + 1;\\n        \\n        // Down\\n        if(i < grid.length-1 && grid[i][j] < grid[i+1][j])\\n            count += f(i+1, j, grid) + 1;        \\n        \\n        // Left\\n         if(j > 0 && grid[i][j] < grid[i][j-1])\\n            count += f(i, j-1, grid) + 1;\\n        \\n        // Right\\n        if(j < grid[i].length-1 && grid[i][j] < grid[i][j+1])\\n            count += f(i, j+1, grid) + 1;\\n        \\n        count = count % mod;\\n        dp[i][j] = count;\\n        return count;\\n    }\\n}\\n```\\n  \\n**Result**\\n![image](https://assets.leetcode.com/users/images/c10c3c53-627f-4050-80a4-560c37fa5b0c_1657030038.6999853.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    int mod = (int) 1e9+7;\\n    public int countPaths(int[][] grid) {\\n        int res = 0;\\n        dp = new int[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[i].length; j++) {\\n                res += f(i, j, grid); \\n                res %= mod;\\n            }\\n        }\\n        return (res + grid.length*grid[0].length) % mod;\\n    }\\n    \\n    private int f(int i, int j, int[][] grid) {\\n        \\n        if (dp[i][j] != -1) return dp[i][j];\\n        \\n        int count = 0;\\n        \\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length) return 0;\\n        \\n        // Up\\n        if(i > 0 && grid[i][j] < grid[i-1][j])\\n            count += f(i-1, j, grid) + 1;\\n        \\n        // Down\\n        if(i < grid.length-1 && grid[i][j] < grid[i+1][j])\\n            count += f(i+1, j, grid) + 1;        \\n        \\n        // Left\\n         if(j > 0 && grid[i][j] < grid[i][j-1])\\n            count += f(i, j-1, grid) + 1;\\n        \\n        // Right\\n        if(j < grid[i].length-1 && grid[i][j] < grid[i][j+1])\\n            count += f(i, j+1, grid) + 1;\\n        \\n        count = count % mod;\\n        dp[i][j] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232390,
                "title": "dfs-dp-easy-readable-code",
                "content": "```\\n    int dp[1001][1001];\\n    const int dx[4]={1,0,-1,0};\\n    const int dy[4]={0,1,0,-1};\\n    const int mod=1e9+7;\\n    bool ok(int i,int j,int n,int m)\\n    {\\n       return (i>=0 && i<n && j>=0 && j<m); \\n    }\\n    int dfs(int i , int j ,vector<vector<int>>&adj,int n,int m)\\n    {\\n        \\n        if(~dp[i][j]){return dp[i][j];}\\n         int cur=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx=dx[k]+i;\\n            int ny=dy[k]+j;\\n            if(ok(nx,ny,n,m) && adj[nx][ny]>adj[i][j])\\n            {\\n                dfs(nx,ny,adj,n,m);\\n                cur+= dp[nx][ny];\\n                cur%=mod;\\n            }\\n        }\\n        cur%=mod;\\n        return dp[i][j]=cur;\\n        \\n    }\\n    \\n    \\n    int countPaths(vector<vector<int>>& adj) {\\n        \\n        int n=adj.size();\\n        int m=adj[0].size();\\n        // paths starting at x and ending at any cell;\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    ans+= dfs(i,j,adj,n,m);\\n                    ans%=mod;\\n                }else{\\n                    ans+= dp[i][j];\\n                    ans%=mod;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    int dp[1001][1001];\\n    const int dx[4]={1,0,-1,0};\\n    const int dy[4]={0,1,0,-1};\\n    const int mod=1e9+7;\\n    bool ok(int i,int j,int n,int m)\\n    {\\n       return (i>=0 && i<n && j>=0 && j<m); \\n    }\\n    int dfs(int i , int j ,vector<vector<int>>&adj,int n,int m)\\n    {\\n        \\n        if(~dp[i][j]){return dp[i][j];}\\n         int cur=1;\\n        for(int k=0;k<4;k++)\\n        {\\n            int nx=dx[k]+i;\\n            int ny=dy[k]+j;\\n            if(ok(nx,ny,n,m) && adj[nx][ny]>adj[i][j])\\n            {\\n                dfs(nx,ny,adj,n,m);\\n                cur+= dp[nx][ny];\\n                cur%=mod;\\n            }\\n        }\\n        cur%=mod;\\n        return dp[i][j]=cur;\\n        \\n    }\\n    \\n    \\n    int countPaths(vector<vector<int>>& adj) {\\n        \\n        int n=adj.size();\\n        int m=adj[0].size();\\n        // paths starting at x and ending at any cell;\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    ans+= dfs(i,j,adj,n,m);\\n                    ans%=mod;\\n                }else{\\n                    ans+= dp[i][j];\\n                    ans%=mod;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232120,
                "title": "dfs-memoization",
                "content": "Applying DFS + memoization\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        if(i<0||j<0||i>=m||j>=n)return false;\\n        return true;\\n    }\\n    int dfs(vector<vector<int>>&visited,vector<vector<int>>&count,vector<vector<int>>&grid,int i,int j,int m,int n)\\n    {\\n        if(visited[i][j])return count[i][j];\\n        visited[i][j]=true;\\n        int mod=1e9+7;\\n        if(isValid(i+1,j,m,n)&&grid[i+1][j]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i+1,j,m,n))%mod;\\n        if(isValid(i-1,j,m,n)&&grid[i-1][j]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i-1,j,m,n))%mod;\\n        if(isValid(i,j+1,m,n)&&grid[i][j+1]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i,j+1,m,n))%mod;\\n        if(isValid(i,j-1,m,n)&&grid[i][j-1]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i,j-1,m,n))%mod;\\n        return count[i][j];\\n \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        vector<vector<int>>count(m,vector<int>(n,1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j])\\n                    dfs(visited,count,grid,i,j,m,n);\\n            }   \\n        }\\n        \\n        long long c=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                c=(c+count[i][j])%mod;\\n            }   \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int m,int n)\\n    {\\n        if(i<0||j<0||i>=m||j>=n)return false;\\n        return true;\\n    }\\n    int dfs(vector<vector<int>>&visited,vector<vector<int>>&count,vector<vector<int>>&grid,int i,int j,int m,int n)\\n    {\\n        if(visited[i][j])return count[i][j];\\n        visited[i][j]=true;\\n        int mod=1e9+7;\\n        if(isValid(i+1,j,m,n)&&grid[i+1][j]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i+1,j,m,n))%mod;\\n        if(isValid(i-1,j,m,n)&&grid[i-1][j]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i-1,j,m,n))%mod;\\n        if(isValid(i,j+1,m,n)&&grid[i][j+1]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i,j+1,m,n))%mod;\\n        if(isValid(i,j-1,m,n)&&grid[i][j-1]>grid[i][j])     count[i][j]=(count[i][j]+dfs(visited,count,grid,i,j-1,m,n))%mod;\\n        return count[i][j];\\n \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        vector<vector<int>>count(m,vector<int>(n,1));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!visited[i][j])\\n                    dfs(visited,count,grid,i,j,m,n);\\n            }   \\n        }\\n        \\n        long long c=0;\\n        int mod=1e9+7;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                c=(c+count[i][j])%mod;\\n            }   \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230903,
                "title": "dp-dfs-easy-to-understand",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int dp[1000][1000]; // here dp[i][j] stores the number of strictly increasing sequences ending at the position (i,j)\\n    int mod = 1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1; \\n            }\\n        }\\n        long long int sum = 0; ///sum stores the total number of sequences \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                sum=(sum+dfs(grid,i,j))%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n    int dfs(vector<vector<int>>&grid,int i,int j)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();        \\n        if(dp[i][j]!=-1) // If the value is already calculated we are just returning the value;\\n            return dp[i][j];\\n        long long int sum = 1; //intially there is only one sequence of length one  ( sequence : grid[i][j] )\\n        if(i>0 && grid[i-1][j]<grid[i][j]) \\n        {\\n            sum  = (sum+dfs(grid,i-1,j))%mod;  //if its neighbour( grid[i-1][j] ) is strictly less than the current element (grid[i][j])  \\n\\t\\t\\t// then we can get extra dp[i-1][j] sequences by putting grid[i][j] as last element to the sequences that are in dp[i-1][j];\\n        }\\n        if(j>0 && grid[i][j-1]<grid[i][j])\\n        {\\n           sum = (sum+dfs(grid,i,j-1))%mod; //if its neighbour( grid[i][j-1] ) is strictly less than the current element (grid[i][j])    \\n\\t\\t   //then we can get extra dp[i][j-1] sequences by putting grid[i][j] as last element to the sequences that are in dp[i][j-1];\\n        }\\n        if(i+1<n && grid[i+1][j]<grid[i][j])\\n        {\\n            sum = (sum+dfs(grid,i+1,j))%mod; //if its neighbour( grid[i+1][j] ) is strictly less than the current element (grid[i][j])    \\n\\t\\t\\t//then we can get extra dp[i+1][j] sequences by putting grid[i][j] as last element to the sequences that are in dp[i+1][j];\\n        }\\n        if(j+1<m && grid[i][j+1]<grid[i][j])\\n        {\\n            sum = (sum+dfs(grid,i,j+1))%mod;\\n\\t\\t\\t//if its neighbour( grid[i][j+1] ) is strictly less than the current element (grid[i][j]) \\n\\t\\t\\t// then we can get extra dp[i][j+1] sequences by putting grid[i][j] as last element to the sequences that are in dp[i][j+1];\\n        }\\n        return dp[i][j]=sum; //storing the calculate value to use it again when we needed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int dp[1000][1000]; // here dp[i][j] stores the number of strictly increasing sequences ending at the position (i,j)\\n    int mod = 1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1; \\n            }\\n        }\\n        long long int sum = 0; ///sum stores the total number of sequences \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                sum=(sum+dfs(grid,i,j))%mod;\\n            }\\n        }\\n        return sum;\\n    }\\n    int dfs(vector<vector<int>>&grid,int i,int j)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();        \\n        if(dp[i][j]!=-1) // If the value is already calculated we are just returning the value;\\n            return dp[i][j];\\n        long long int sum = 1; //intially there is only one sequence of length one  ( sequence : grid[i][j] )\\n        if(i>0 && grid[i-1][j]<grid[i][j]) \\n        {\\n            sum  = (sum+dfs(grid,i-1,j))%mod;  //if its neighbour( grid[i-1][j] ) is strictly less than the current element (grid[i][j])  \\n\\t\\t\\t// then we can get extra dp[i-1][j] sequences by putting grid[i][j] as last element to the sequences that are in dp[i-1][j];\\n        }\\n        if(j>0 && grid[i][j-1]<grid[i][j])\\n        {\\n           sum = (sum+dfs(grid,i,j-1))%mod; //if its neighbour( grid[i][j-1] ) is strictly less than the current element (grid[i][j])    \\n\\t\\t   //then we can get extra dp[i][j-1] sequences by putting grid[i][j] as last element to the sequences that are in dp[i][j-1];\\n        }\\n        if(i+1<n && grid[i+1][j]<grid[i][j])\\n        {\\n            sum = (sum+dfs(grid,i+1,j))%mod; //if its neighbour( grid[i+1][j] ) is strictly less than the current element (grid[i][j])    \\n\\t\\t\\t//then we can get extra dp[i+1][j] sequences by putting grid[i][j] as last element to the sequences that are in dp[i+1][j];\\n        }\\n        if(j+1<m && grid[i][j+1]<grid[i][j])\\n        {\\n            sum = (sum+dfs(grid,i,j+1))%mod;\\n\\t\\t\\t//if its neighbour( grid[i][j+1] ) is strictly less than the current element (grid[i][j]) \\n\\t\\t\\t// then we can get extra dp[i][j+1] sequences by putting grid[i][j] as last element to the sequences that are in dp[i][j+1];\\n        }\\n        return dp[i][j]=sum; //storing the calculate value to use it again when we needed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230165,
                "title": "simple-dfs-with-memo-c",
                "content": "dp[i][j]=increasing paths that will start from grid[i][j];\\nour final answer would be sum(dp[i][j]);\\n\\nif there is no next greater element then our answer will be 1 that\\'s why dp[i][j]=ans+1\\n\\n```\\nclass Solution {\\npublic:\\n   int Mod=1e9+7;\\n   int helper(vector<vector<int>>& grid,vector<vector<int>> &dp,int i,int j,int n,int m){\\n      int ans=0;\\n      if(dp[i][j]!=-1) return dp[i][j];\\n      if(i+1<n && grid[i][j]<grid[i+1][j]){\\n         ans=((long long)ans+helper(grid,dp,i+1,j,n,m))%Mod;\\n      }\\n      if(i-1>=0 && grid[i][j]<grid[i-1][j]){\\n         ans=((long long)ans+helper(grid,dp,i-1,j,n,m))%Mod;\\n      }\\n      if(j+1<m && grid[i][j]<grid[i][j+1]){\\n         ans=((long long)ans+helper(grid,dp,i,j+1,n,m))%Mod;\\n      }\\n      if(j-1>=0 && grid[i][j]<grid[i][j-1]){\\n         ans=((long long)ans+helper(grid,dp,i,j-1,n,m))%Mod;\\n      }\\n      return dp[i][j]=ans+1;\\n   }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n         for(int j=0;j<m;j++){\\n            ans=((long long)ans+helper(grid,dp,i,j,n,m))%Mod;\\n         }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps\\nComment down if any query\\nThanks",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int Mod=1e9+7;\\n   int helper(vector<vector<int>>& grid,vector<vector<int>> &dp,int i,int j,int n,int m){\\n      int ans=0;\\n      if(dp[i][j]!=-1) return dp[i][j];\\n      if(i+1<n && grid[i][j]<grid[i+1][j]){\\n         ans=((long long)ans+helper(grid,dp,i+1,j,n,m))%Mod;\\n      }\\n      if(i-1>=0 && grid[i][j]<grid[i-1][j]){\\n         ans=((long long)ans+helper(grid,dp,i-1,j,n,m))%Mod;\\n      }\\n      if(j+1<m && grid[i][j]<grid[i][j+1]){\\n         ans=((long long)ans+helper(grid,dp,i,j+1,n,m))%Mod;\\n      }\\n      if(j-1>=0 && grid[i][j]<grid[i][j-1]){\\n         ans=((long long)ans+helper(grid,dp,i,j-1,n,m))%Mod;\\n      }\\n      return dp[i][j]=ans+1;\\n   }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n         for(int j=0;j<m;j++){\\n            ans=((long long)ans+helper(grid,dp,i,j,n,m))%Mod;\\n         }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026214,
                "title": "simple-and-easy-dp-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n// If your are beginner then it is not for you Please skip the approach \\n\\nSince it is total count possible increasing path in matrix or grid So,it hits in mind that it is explore each cell one by one using DFS.\\nThought will be only developed  when you practice more and more.\\nRecommended : LeetCode 329.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic idea behind the solution of this questions is to call dfs function on each cell and until matrix[nextRow][nextColumn] > matrix[currentRow][currentColumn]  we increase variable count.\\nSince it is overlapping subproblem ,so we memoies the solution using  2-D array because we have to variable parameter.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\n    int[][] dir={{1,0},{-1,0},{0,1},{0,-1}};\\n    int mod=1000000007;\\n    public int countPaths(int[][] grid) {\\n         int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] x:dp)\\n        {\\n            Arrays.fill(x,-1);\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               max=(max+dfs(i,j,grid,dp))%mod;\\n                // System.out.println(\"divyanshu\");\\n            }\\n        }\\n        return (max);\\n    }\\n    public int dfs(int i,int j,int[][] matrix,int[][] dp)\\n    {\\n       int count=1;\\n       if(dp[i][j]!=-1)\\n       {\\n           return dp[i][j];\\n       }\\n       for(int[] d:dir)\\n       {\\n           int x=i+d[0],y=j+d[1];\\n           if(x>=0 && y>=0 && x<matrix.length && y<matrix[0].length && matrix[x][y]>matrix[i][j])\\n           {\\n             count=(count+dfs(x,y,matrix,dp))%mod;\\n           }\\n       }\\n       return dp[i][j]=count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir={{1,0},{-1,0},{0,1},{0,-1}};\\n    int mod=1000000007;\\n    public int countPaths(int[][] grid) {\\n         int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] x:dp)\\n        {\\n            Arrays.fill(x,-1);\\n        }\\n        int max=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               max=(max+dfs(i,j,grid,dp))%mod;\\n                // System.out.println(\"divyanshu\");\\n            }\\n        }\\n        return (max);\\n    }\\n    public int dfs(int i,int j,int[][] matrix,int[][] dp)\\n    {\\n       int count=1;\\n       if(dp[i][j]!=-1)\\n       {\\n           return dp[i][j];\\n       }\\n       for(int[] d:dir)\\n       {\\n           int x=i+d[0],y=j+d[1];\\n           if(x>=0 && y>=0 && x<matrix.length && y<matrix[0].length && matrix[x][y]>matrix[i][j])\\n           {\\n             count=(count+dfs(x,y,matrix,dp))%mod;\\n           }\\n       }\\n       return dp[i][j]=count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945338,
                "title": "recursion-memoisation-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int mod = 1e9+7;\\n    bool ispossible(int i,int j,int r,int c)\\n    {\\n        if(i<0 || i>=r || j<0 || j>=c)\\n        return false;\\n        else\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &nums,int i,int j)\\n    {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        if(memo[i][j]!=-1)\\n        {\\n            return memo[i][j];\\n        }\\n        int ans = 0;\\n        if(ispossible(i+1,j,r,c) && nums[i+1][j]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i+1,j))%mod;\\n\\n        if(ispossible(i-1,j,r,c) && nums[i-1][j]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i-1,j))%mod;\\n\\n        if(ispossible(i,j+1,r,c) && nums[i][j+1]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i,j+1))%mod;\\n\\n        if(ispossible(i,j-1,r,c) && nums[i][j-1]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i,j-1))%mod;\\n\\n        return memo[i][j] = ((long long)ans+1)%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        memset(memo,-1,sizeof(memo));\\n        int answer = 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                answer = ((long long)answer+solve(grid,i,j))%mod;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[1001][1001];\\n    int mod = 1e9+7;\\n    bool ispossible(int i,int j,int r,int c)\\n    {\\n        if(i<0 || i>=r || j<0 || j>=c)\\n        return false;\\n        else\\n        return true;\\n    }\\n    int solve(vector<vector<int>> &nums,int i,int j)\\n    {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        if(memo[i][j]!=-1)\\n        {\\n            return memo[i][j];\\n        }\\n        int ans = 0;\\n        if(ispossible(i+1,j,r,c) && nums[i+1][j]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i+1,j))%mod;\\n\\n        if(ispossible(i-1,j,r,c) && nums[i-1][j]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i-1,j))%mod;\\n\\n        if(ispossible(i,j+1,r,c) && nums[i][j+1]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i,j+1))%mod;\\n\\n        if(ispossible(i,j-1,r,c) && nums[i][j-1]>nums[i][j])\\n        ans = ((long long)ans+solve(nums,i,j-1))%mod;\\n\\n        return memo[i][j] = ((long long)ans+1)%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        memset(memo,-1,sizeof(memo));\\n        int answer = 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                answer = ((long long)answer+solve(grid,i,j))%mod;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653622,
                "title": "python-short-and-clean-dp-dfs-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution, Approach 2](https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/editorial/) but using functional programming.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n\\n- Space complexity: $$O(m * n)$$\\n\\nwhere, `m x n is the dimensions of grid.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def countPaths(self, grid: list[list[int]]) -> int:\\n        M = 1_000_000_007\\n        m, n = len(grid), len(grid[0])\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n\\n        in_bounds = lambda i, j: 0 <= i < m and 0 <= j < n\\n        nbrs = lambda i, j: ((i + di, j + dj) for di, dj in dirs)\\n        starfilter = lambda f, xs: filter(lambda args: f(*args), xs)\\n\\n        @cache\\n        def paths_to(i: int, j: int) -> int:\\n            valid_nbrs = starfilter(in_bounds, nbrs(i, j))\\n            increasing_nbrs = starfilter(lambda ni, nj: grid[ni][nj] > grid[i][j], valid_nbrs)\\n            return (sum(starmap(paths_to, increasing_nbrs)) + 1) % M\\n        \\n        return sum(starmap(paths_to, product(range(m), range(n)))) % M\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```python\\nclass Solution:\\n    def countPaths(self, grid: list[list[int]]) -> int:\\n        M = 1_000_000_007\\n        m, n = len(grid), len(grid[0])\\n        dirs = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n\\n        in_bounds = lambda i, j: 0 <= i < m and 0 <= j < n\\n        nbrs = lambda i, j: ((i + di, j + dj) for di, dj in dirs)\\n        starfilter = lambda f, xs: filter(lambda args: f(*args), xs)\\n\\n        @cache\\n        def paths_to(i: int, j: int) -> int:\\n            valid_nbrs = starfilter(in_bounds, nbrs(i, j))\\n            increasing_nbrs = starfilter(lambda ni, nj: grid[ni][nj] > grid[i][j], valid_nbrs)\\n            return (sum(starmap(paths_to, increasing_nbrs)) + 1) % M\\n        \\n        return sum(starmap(paths_to, product(range(m), range(n)))) % M\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653404,
                "title": "c-dp-dfs-100-time-168ms-50-space-39-2mb",
                "content": "This is a fascinating problem, since it can be solved in multiple, rather different ways.\\n\\nThe approach I decided to follow is to use a Depht First Search (AKA \"DFS\") and to explore each cell, seeing how many paths we can find from the adjacent cells which have a value `>` than the current one; we will also store all the already explored cells in another grid of the same size that we will call `dp`, in order to avoid repeating the same traversal over and over again; to know which cells we already visited or no, we might set each cell of `dp` to any initial value `<` the minimum about of paths we can get from each cell, which is `1`.\\n\\nWe will set everything to `0` for our own convenience.\\n\\nFor example, with:\\n\\n```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    0   0\\n    0   0\\n    0   0\\n```\\n\\nWe will start exploring for the first cell (the one with value `3`) and find that we have one possible path from the cell itself (`3`), plus all the paths we can get from the cells with `4` and `5`.\\n\\n`5` can then lead to itself and to `7`, while `4` can lead to itself and to both `6` or to `7`, which would be our end of the line.\\n\\nAfter our first DFS in this simplified scenario, we would have:\\n\\n```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    6   2\\n    3   1\\n    1   0\\n```\\n\\nIn a similar fashion, we would move to other cells and see that we already know how many paths we can get from them, until we reach the last cell `1`, that will give us the paths including itself, and the ones going to `6` and `7`:\\n\\n```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    6   2\\n    3   1\\n    1   3\\n```\\n\\nIf we sum all the values in `dp`, we can see that the initial matrix would offer us `6 + 2 + 3 + 1 + 1 + 3 == 16` different paths, which is the correct answer.\\n\\nNow, to code all of this, we will start declaring the `constexpr` `modVal` matching the upper limit of what we can `return` and a few instance variables:\\n* `maxX` and `maxY` will store the maximum coordinates we can get for column and row indexes, respectively;\\n* `grid` will be a copy of the provided matrix;\\n* `dp` will be where we store information on how many paths we can obtain from each already explored cell.\\n\\nIn our main function we will also declare our usual accumulator variable `res`, initially set to `0`, and then proceed to populate the instance variable; we will:\\n* `swap` the provided matrix `tmp` and `grid`;\\n* set `maxX` and `maxY` to be temporarily the number of rows and columns in `grid`;\\n* declare `tmpDp` as a matrix of the same size;\\n* reduce both `maxX` and `maxY` by `1`;\\n* `swap` `tmpDp` and `dp`.\\n\\nNow that we have all ready, we can confidently start parsing `grid` for each value with coordinates `y` (row index) and `x` (column index) in (it and we will:\\n* check if we have no explored this cell yet (ie: `dp[y][x] == 0`) and if so, call `dfs` with two coordinates and assign its returned value to `dp[y][x]` (thus also marking this cell as explored);\\n* increase `res` bt `dp[y][x]`.\\n\\nThe helper function `dfs` will take two coordinates `x` and `y` and:\\n* check if we have already been here (ie: `dp[y][x] != 0`) and if so, `return` `dp[y][x]`;\\n* if not, we will start declaring a couple of support variables:\\n    * `currCell` will store the value of `grid[y][x]`;\\n    * `subRes` will store our sub-result, which it is to say all the paths achievable from this cell, initially set to `1` (ie: just the cell itself);\\n* explore the neighbours east, south, west and north, provided we would not go out of boundaries and each specific neighbour has a value `> currCell`, by calling `dfs` on those coordinates and increasing `subRes` with the result of that call;\\n* once we have explored all the neighbours, we will:\\n    * compute `subRes % modVal`;\\n    * store this value in `dp[y][x]`;\\n    * `return` it. \\n\\nOnce done, we can just `return` `res & modVal`.\\n\\n# Complexity\\n- Time complexity: $$O(r * c)$$ (with `r` and `c` being the number of rows and columns, respectively)\\n- Space complexity: $$O(r * c)$$\\n\\n# Code\\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY;\\n    vector<vector<int>> grid;\\n    vector<vector<long long>> dp;\\n    int dfs(int x, int y) {\\n        // base case: been here before\\n        if (dp[y][x]) return dp[y][x];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1);\\n        return dp[y][x] = subRes % modVal;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // support variables\\n        long long res = 0;\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size(), maxY = grid.size();\\n        vector<vector<long long>> tmpDp(maxY--, vector<long long>(maxX--, 0));\\n        swap(tmpDp, dp);\\n        // parsing grid\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // if we never visited this cell before\\n                if (!dp[y][x]) {\\n                    dp[y][x] = dfs(x, y);\\n                }\\n                res += dp[y][x];\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```\\n\\nAlternatively we can avoid using `% modVal` replacing it with a `while` loop in the recursive calls (cheaper, since we will never get a `subRes` value `> 4 * modVal`) and increase `res` directly in our recursive calls:\\n\\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY;\\n    vector<vector<int>> grid;\\n    vector<vector<long long>> dp;\\n    long long res = 0;\\n    int dfs(int x, int y) {\\n        // base case: been here before\\n        if (dp[y][x]) return dp[y][x];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1);\\n        while (subRes >= modVal) subRes -= modVal;\\n        res += subRes; \\n        return dp[y][x] = subRes;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size(), maxY = grid.size();\\n        vector<vector<long long>> tmpDp(maxY--, vector<long long>(maxX--, 0));\\n        swap(tmpDp, dp);\\n        // parsing grid\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // if we never visited this cell before\\n                if (!dp[y][x]) {\\n                    dp[y][x] = dfs(x, y);\\n                }\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```\\n\\nCan we do better? Well, yes, if we optimise `dp` a bit by:\\n* making it an array;\\n* storing the length of a row in `rowLen`;\\n* flattening to be only one dimension, with an index `dpPos` that will increase as we go in the main loop and change depending on the direction of the neighbour we are exploring (`dpPos` will change by `+/-1` when moving horizontally and `+/-rowLen` when moving vertically);\\n* populating only the part of `dp` we need with `0`s.\\n\\nThis approach will go a good 40ms faster and burn way less memory than using vectors :)\\n\\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY, rowLen;\\n    vector<vector<int>> grid;\\n    long long res = 0, dp[100000];\\n    int dfs(int x, int y, int dpPos) {\\n        // base case: been here before\\n        if (dp[dpPos]) return dp[dpPos];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y, dpPos + 1);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1, dpPos + rowLen);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y, dpPos - 1);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1, dpPos - rowLen);\\n        while (subRes >= modVal) subRes -= modVal;\\n        res += subRes; \\n        return dp[dpPos] = subRes;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // populating instance variables\\n        swap(tmp, grid);\\n        rowLen = maxX = grid[0].size(), maxY = grid.size();\\n        memset(dp, 0, maxX-- * maxY-- * sizeof(long long));\\n        // parsing grid\\n        for (int y = 0, dpPos = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++, dpPos++) {\\n                // if we never visited this cell before\\n                if (!dp[dpPos]) {\\n                    dp[dpPos] = dfs(x, y, dpPos);\\n                }\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```\\n\\n# Brag:\\n![image.png](https://assets.leetcode.com/users/images/7aed4606-2af8-4ead-ae09-5aa5f4d07b79_1687109158.4687502.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    0   0\\n    0   0\\n    0   0\\n```\n```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    6   2\\n    3   1\\n    1   0\\n```\n```cpp\\n// grid\\n    3   5\\n    4   7\\n    6   1\\n// dp\\n    6   2\\n    3   1\\n    1   3\\n```\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY;\\n    vector<vector<int>> grid;\\n    vector<vector<long long>> dp;\\n    int dfs(int x, int y) {\\n        // base case: been here before\\n        if (dp[y][x]) return dp[y][x];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1);\\n        return dp[y][x] = subRes % modVal;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // support variables\\n        long long res = 0;\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size(), maxY = grid.size();\\n        vector<vector<long long>> tmpDp(maxY--, vector<long long>(maxX--, 0));\\n        swap(tmpDp, dp);\\n        // parsing grid\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // if we never visited this cell before\\n                if (!dp[y][x]) {\\n                    dp[y][x] = dfs(x, y);\\n                }\\n                res += dp[y][x];\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY;\\n    vector<vector<int>> grid;\\n    vector<vector<long long>> dp;\\n    long long res = 0;\\n    int dfs(int x, int y) {\\n        // base case: been here before\\n        if (dp[y][x]) return dp[y][x];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1);\\n        while (subRes >= modVal) subRes -= modVal;\\n        res += subRes; \\n        return dp[y][x] = subRes;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // populating instance variables\\n        swap(tmp, grid);\\n        maxX = grid[0].size(), maxY = grid.size();\\n        vector<vector<long long>> tmpDp(maxY--, vector<long long>(maxX--, 0));\\n        swap(tmpDp, dp);\\n        // parsing grid\\n        for (int y = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++) {\\n                // if we never visited this cell before\\n                if (!dp[y][x]) {\\n                    dp[y][x] = dfs(x, y);\\n                }\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```\n```cpp\\nconstexpr long long modVal = 1000000007; \\n\\nclass Solution {\\n    int maxX, maxY, rowLen;\\n    vector<vector<int>> grid;\\n    long long res = 0, dp[100000];\\n    int dfs(int x, int y, int dpPos) {\\n        // base case: been here before\\n        if (dp[dpPos]) return dp[dpPos];\\n        // general case:\\n        // support variables\\n        int currCell = grid[y][x];\\n        long long subRes = 1;\\n        // going east\\n        if (x < maxX && currCell < grid[y][x + 1]) subRes += dfs(x + 1, y, dpPos + 1);\\n        // going south\\n        if (y < maxY && currCell < grid[y + 1][x]) subRes += dfs(x, y + 1, dpPos + rowLen);\\n        // going west\\n        if (x && currCell < grid[y][x - 1]) subRes += dfs(x - 1, y, dpPos - 1);\\n        // going north\\n        if (y && currCell < grid[y - 1][x]) subRes += dfs(x, y - 1, dpPos - rowLen);\\n        while (subRes >= modVal) subRes -= modVal;\\n        res += subRes; \\n        return dp[dpPos] = subRes;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>> &tmp) {\\n        // populating instance variables\\n        swap(tmp, grid);\\n        rowLen = maxX = grid[0].size(), maxY = grid.size();\\n        memset(dp, 0, maxX-- * maxY-- * sizeof(long long));\\n        // parsing grid\\n        for (int y = 0, dpPos = 0; y <= maxY; y++) {\\n            for (int x = 0; x <= maxX; x++, dpPos++) {\\n                // if we never visited this cell before\\n                if (!dp[dpPos]) {\\n                    dp[dpPos] = dfs(x, y, dpPos);\\n                }\\n            }\\n        }\\n        return res % modVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653132,
                "title": "c-java-easy-and-clean-code-topological-sorting-beats",
                "content": "# Please Upvote if you like my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity \\n- Time complexity: $$O(N*M)$$ where `N = grid.length` and `M = grid[0].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    // Topo Sort\\n    int countPathsHelp(vector<vector<int>> &adj){\\n        int n = adj.size(), cnt = 0;\\n        vector<int> indeg(n, 0), path(n, 1);\\n        for(int i=0; i<n; i++){\\n            for(auto nbr : adj[i]) \\n                indeg[nbr]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++) \\n            if( indeg[i] == 0 ) q.push(i);\\n        \\n        while(q.size()){\\n            int node = q.front();\\n            q.pop();\\n            cnt = ( cnt + path[node])%mod;\\n\\n            for(auto nbr : adj[node]){\\n                path[nbr] = (path[nbr] + path[node])%mod;\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0) q.push(nbr);\\n            }        \\n        }\\n        return cnt;\\n    }\\n\\npublic:\\n    int countPaths(vector<vector<int>>& g) {\\n        int n = g.size(), m = g[0].size();\\n        vector<vector<int>> ways = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        vector<vector<int>> adj(n*m);\\n\\n        auto findInd = [&](int r, int c){\\n            return m*r + c;\\n        };\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(auto w : ways){\\n                    int x = i + w[0], y = j + w[1];\\n                    if( x>=0 && y>=0 && x<n && y<m && g[i][j] < g[x][y] ) \\n                        adj[findInd(i, j)].push_back(findInd(x,y));\\n                }\\n            }\\n        }\\n        return countPathsHelp(adj);\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    // Topological sorting\\n    private int countPathsHelp(List<List<Integer>> adj) {\\n        int n = adj.size(), cnt = 0;\\n        int indeg[] = new int[n], path[] = new int[n];\\n        Arrays.fill(path, 1);\\n\\n        for(int i=0; i<n; i++){\\n            for(int nbr : adj.get(i))\\n                indeg[nbr]++;\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0; i<n; i++) if(indeg[i] == 0) q.add(i);\\n\\n        while(q.size()>0){\\n            int node = q.poll();\\n            cnt = (cnt + path[node])%mod;\\n\\n            for(Integer nbr : adj.get(node)){\\n                path[nbr] = (path[nbr] + path[node])%mod;\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0 ) q.add(nbr);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n\\n    public int countPaths(int[][] g) {\\n        int n = g.length, m = g[0].length;\\n        int ways[][] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<n*m; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(int[] w : ways){\\n                    int x = i + w[0], y = j + w[1];\\n                    if( x>=0 && y>=0 && x<n && y<m && g[i][j] < g[x][y] ) \\n                        adj.get(m*i+j).add(m*x+y);\\n                }\\n            }\\n        }\\n        return countPathsHelp(adj);\\n    }\\n}\\n```\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    // Topo Sort\\n    int countPathsHelp(vector<vector<int>> &adj){\\n        int n = adj.size(), cnt = 0;\\n        vector<int> indeg(n, 0), path(n, 1);\\n        for(int i=0; i<n; i++){\\n            for(auto nbr : adj[i]) \\n                indeg[nbr]++;\\n        }\\n        queue<int> q;\\n        for(int i=0; i<n; i++) \\n            if( indeg[i] == 0 ) q.push(i);\\n        \\n        while(q.size()){\\n            int node = q.front();\\n            q.pop();\\n            cnt = ( cnt + path[node])%mod;\\n\\n            for(auto nbr : adj[node]){\\n                path[nbr] = (path[nbr] + path[node])%mod;\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0) q.push(nbr);\\n            }        \\n        }\\n        return cnt;\\n    }\\n\\npublic:\\n    int countPaths(vector<vector<int>>& g) {\\n        int n = g.size(), m = g[0].size();\\n        vector<vector<int>> ways = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        vector<vector<int>> adj(n*m);\\n\\n        auto findInd = [&](int r, int c){\\n            return m*r + c;\\n        };\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(auto w : ways){\\n                    int x = i + w[0], y = j + w[1];\\n                    if( x>=0 && y>=0 && x<n && y<m && g[i][j] < g[x][y] ) \\n                        adj[findInd(i, j)].push_back(findInd(x,y));\\n                }\\n            }\\n        }\\n        return countPathsHelp(adj);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    // Topological sorting\\n    private int countPathsHelp(List<List<Integer>> adj) {\\n        int n = adj.size(), cnt = 0;\\n        int indeg[] = new int[n], path[] = new int[n];\\n        Arrays.fill(path, 1);\\n\\n        for(int i=0; i<n; i++){\\n            for(int nbr : adj.get(i))\\n                indeg[nbr]++;\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=0; i<n; i++) if(indeg[i] == 0) q.add(i);\\n\\n        while(q.size()>0){\\n            int node = q.poll();\\n            cnt = (cnt + path[node])%mod;\\n\\n            for(Integer nbr : adj.get(node)){\\n                path[nbr] = (path[nbr] + path[node])%mod;\\n                indeg[nbr]--;\\n                if(indeg[nbr] == 0 ) q.add(nbr);\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n\\n    public int countPaths(int[][] g) {\\n        int n = g.length, m = g[0].length;\\n        int ways[][] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i=0; i<n*m; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                for(int[] w : ways){\\n                    int x = i + w[0], y = j + w[1];\\n                    if( x>=0 && y>=0 && x<n && y<m && g[i][j] < g[x][y] ) \\n                        adj.get(m*i+j).add(m*x+y);\\n                }\\n            }\\n        }\\n        return countPathsHelp(adj);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652765,
                "title": "java-python-c-dfs-well-described-tc-sc-o-m-n-faster-than-98-21-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe uses a depth-first search (DFS) approach to explore all possible paths in the grid. Starting from each cell, it recursively explores its neighboring cells if they are strictly increasing in value. The base case is when the current cell is out of bounds or its value is not strictly smaller than the previous cell. The DP array is used to store and retrieve the calculated results to avoid recomputing the same paths.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, We uses a recursive approach to find the number of strictly increasing paths in the given grid. It initializes a dynamic programming (DP) array, dp, to store the number of paths starting from each cell. It then iterates through each cell in the grid and calls a recursive function, func, to calculate the number of strictly increasing paths starting from that cell. The func function checks the neighboring cells and recursively calls itself to calculate the number of paths for each neighbor. It stores the result in the DP array to avoid redundant calculations. Finally, the code sums up the values in the DP array to get the total number of strictly increasing paths in the grid.\\n\\nLet\\'s see whole approach in just 3 step:\\n\\n**Step 1:** Function checkLimits\\nThis function is used to check whether the given indices (i, j) are within the valid limits of the grid (n x m). It returns true if the indices are within bounds and false otherwise.\\n\\n**Step 2:** Function func\\nThis is a recursive function that calculates the number of strictly increasing paths starting from the current cell (i, j) in the grid. It takes the following parameters:\\n\\nmatrix: The input grid of size n x m.\\ndp: The dynamic programming array to store the calculated results.\\ni, j: The current cell\\'s indices.\\nn, m: The dimensions of the grid.\\nThe function starts by checking if the current cell\\'s result is already present in the dp array. If it is, the function returns the stored result.\\n\\nNext, it initializes four variables c1, c2, c3, and c4 to keep track of the number of paths found by exploring the neighboring cells.\\n\\nc1: Number of paths from the cell (i, j) to the right cell (i, j+1).\\nc2: Number of paths from the cell (i, j) to the left cell (i, j-1).\\nc3: Number of paths from the cell (i, j) to the bottom cell (i+1, j).\\nc4: Number of paths from the cell (i, j) to the top cell (i-1, j).\\nThe function checks if the neighboring cells are within bounds and if their values are strictly greater than the current cell\\'s value. If these conditions are met, it recursively calls the func function for each valid neighboring cell to find the number of paths starting from that cell.\\n\\nAfter calculating the number of paths from all valid neighbors, the function updates the dp array for the current cell as the sum of 1 and the counts from all the valid neighbors. It then returns the updated result.\\n\\n**Step 3:** Function countPaths\\nThis function calculates the total number of strictly increasing paths in the grid. It takes the following parameters:\\n\\nmatrix: The input grid of size n x m.\\nThe function initializes the dp array to store the calculated results for each cell. It then iterates through each cell in the grid using two nested loops. For each cell, it calls the func function to calculate the number of strictly increasing paths starting from that cell. It adds the result to the ans variable and takes the modulus of the sum with mod to avoid overflow.\\n\\nFinally, the function returns the final result ans, which represents the total number of strictly increasing paths in the grid.\\n\\nHope this helps!\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(m * n), where m and n are the dimensions of the grid. This is because the code iterates through each cell in the grid once.\\n\\n- Space complexity: O(m * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(m * n), where m and n are the dimensions of the grid. This is because the code uses a DP array of the same size to store the calculated results for each cell.\\n\\n# Code\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    final int mod = (int) 1e9 + 7;\\n\\n    boolean checkLimits(int i, int j, int n, int m) {\\n        return (i >= 0 && i < n && j >= 0 && j < m);\\n    }\\n\\n    int func(int[][] matrix, int[][] dp, int i, int j, int n, int m) {\\n        if (!checkLimits(i, j, n, m))\\n            return 0;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\\n\\n        if (checkLimits(i, j + 1, n, m) && matrix[i][j + 1] > matrix[i][j]) {\\n            c1 = func(matrix, dp, i, j + 1, n, m);\\n        }\\n\\n        if (checkLimits(i, j - 1, n, m) && matrix[i][j - 1] > matrix[i][j]) {\\n            c2 = func(matrix, dp, i, j - 1, n, m);\\n        }\\n\\n        if (checkLimits(i + 1, j, n, m) && matrix[i + 1][j] > matrix[i][j]) {\\n            c3 = func(matrix, dp, i + 1, j, n, m);\\n        }\\n\\n        if (checkLimits(i - 1, j, n, m) && matrix[i - 1][j] > matrix[i][j]) {\\n            c4 = func(matrix, dp, i - 1, j, n, m);\\n        }\\n\\n        dp[i][j] = (1 + c1 + c2 + c3 + c4) % mod;\\n\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] dp = new int[row][col];\\n        int ans = 0;\\n\\n        for (int i = 0; i < row; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans += func(matrix, dp, i, j, row, col);\\n                ans %= mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    const unsigned int mod=1e9+7;\\n    bool checkLimits(int i, int j, int n, int m){    \\n        return (i>=0 and i<n and j>=0 and j<m);  \\n    }\\n     int func(vector<vector<int>> &matrix, vector<vector<int>> &dp, int i, int j, int n, int m){\\n        \\n        if(!checkLimits(i, j, n, m)) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0, c4 =0;\\n        \\n        if(checkLimits(i, j+1, n, m) and matrix[i][j+1]>matrix[i][j]){\\n            c1 = func(matrix, dp, i, j+1, n, m);\\n        }\\n        \\n        if(checkLimits(i, j-1, n, m) and matrix[i][j-1]>matrix[i][j]){\\n            c2 = func(matrix, dp, i, j-1, n, m);\\n        }\\n        \\n        if(checkLimits(i+1, j, n, m) and matrix[i+1][j]>matrix[i][j]){\\n            c3 = func(matrix, dp, i+1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i-1, j, n, m) and matrix[i-1][j]>matrix[i][j]){\\n            c4 = func(matrix, dp, i-1, j, n, m);\\n        }\\n        \\n        dp[i][j] = (1 + c1+c2+c3+c4)%mod;\\n        \\n        return dp[i][j];        \\n        \\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int row =matrix.size();\\n        int col =matrix[0].size();\\n        vector<vector<int>> dp(row,vector<int>(col,-1));\\n        int ans =0;\\n        for(int i =0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ans += func(matrix,dp,i,j,row,col);\\n                ans%=mod;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    mod = int(1e9) + 7\\n\\n    def checkLimits(self, i, j, n, m):\\n        return i >= 0 and i < n and j >= 0 and j < m\\n\\n    def func(self, matrix, dp, i, j, n, m):\\n        if not self.checkLimits(i, j, n, m):\\n            return 0\\n\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n\\n        c1 = c2 = c3 = c4 = 0\\n\\n        if self.checkLimits(i, j + 1, n, m) and matrix[i][j + 1] > matrix[i][j]:\\n            c1 = self.func(matrix, dp, i, j + 1, n, m)\\n\\n        if self.checkLimits(i, j - 1, n, m) and matrix[i][j - 1] > matrix[i][j]:\\n            c2 = self.func(matrix, dp, i, j - 1, n, m)\\n\\n        if self.checkLimits(i + 1, j, n, m) and matrix[i + 1][j] > matrix[i][j]:\\n            c3 = self.func(matrix, dp, i + 1, j, n, m)\\n\\n        if self.checkLimits(i - 1, j, n, m) and matrix[i - 1][j] > matrix[i][j]:\\n            c4 = self.func(matrix, dp, i - 1, j, n, m)\\n\\n        dp[i][j] = (1 + c1 + c2 + c3 + c4) % self.mod\\n\\n        return dp[i][j]\\n\\n    def countPaths(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dp = [[-1] * col for _ in range(row)]\\n        ans = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans += self.func(matrix, dp, i, j, row, col)\\n                ans %= self.mod\\n\\n        return ans\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    final int mod = (int) 1e9 + 7;\\n\\n    boolean checkLimits(int i, int j, int n, int m) {\\n        return (i >= 0 && i < n && j >= 0 && j < m);\\n    }\\n\\n    int func(int[][] matrix, int[][] dp, int i, int j, int n, int m) {\\n        if (!checkLimits(i, j, n, m))\\n            return 0;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int c1 = 0, c2 = 0, c3 = 0, c4 = 0;\\n\\n        if (checkLimits(i, j + 1, n, m) && matrix[i][j + 1] > matrix[i][j]) {\\n            c1 = func(matrix, dp, i, j + 1, n, m);\\n        }\\n\\n        if (checkLimits(i, j - 1, n, m) && matrix[i][j - 1] > matrix[i][j]) {\\n            c2 = func(matrix, dp, i, j - 1, n, m);\\n        }\\n\\n        if (checkLimits(i + 1, j, n, m) && matrix[i + 1][j] > matrix[i][j]) {\\n            c3 = func(matrix, dp, i + 1, j, n, m);\\n        }\\n\\n        if (checkLimits(i - 1, j, n, m) && matrix[i - 1][j] > matrix[i][j]) {\\n            c4 = func(matrix, dp, i - 1, j, n, m);\\n        }\\n\\n        dp[i][j] = (1 + c1 + c2 + c3 + c4) % mod;\\n\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[][] dp = new int[row][col];\\n        int ans = 0;\\n\\n        for (int i = 0; i < row; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                ans += func(matrix, dp, i, j, row, col);\\n                ans %= mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    const unsigned int mod=1e9+7;\\n    bool checkLimits(int i, int j, int n, int m){    \\n        return (i>=0 and i<n and j>=0 and j<m);  \\n    }\\n     int func(vector<vector<int>> &matrix, vector<vector<int>> &dp, int i, int j, int n, int m){\\n        \\n        if(!checkLimits(i, j, n, m)) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int c1 = 0, c2 = 0, c3 = 0, c4 =0;\\n        \\n        if(checkLimits(i, j+1, n, m) and matrix[i][j+1]>matrix[i][j]){\\n            c1 = func(matrix, dp, i, j+1, n, m);\\n        }\\n        \\n        if(checkLimits(i, j-1, n, m) and matrix[i][j-1]>matrix[i][j]){\\n            c2 = func(matrix, dp, i, j-1, n, m);\\n        }\\n        \\n        if(checkLimits(i+1, j, n, m) and matrix[i+1][j]>matrix[i][j]){\\n            c3 = func(matrix, dp, i+1, j, n, m);\\n        }\\n        \\n        if(checkLimits(i-1, j, n, m) and matrix[i-1][j]>matrix[i][j]){\\n            c4 = func(matrix, dp, i-1, j, n, m);\\n        }\\n        \\n        dp[i][j] = (1 + c1+c2+c3+c4)%mod;\\n        \\n        return dp[i][j];        \\n        \\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int row =matrix.size();\\n        int col =matrix[0].size();\\n        vector<vector<int>> dp(row,vector<int>(col,-1));\\n        int ans =0;\\n        for(int i =0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                ans += func(matrix,dp,i,j,row,col);\\n                ans%=mod;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    mod = int(1e9) + 7\\n\\n    def checkLimits(self, i, j, n, m):\\n        return i >= 0 and i < n and j >= 0 and j < m\\n\\n    def func(self, matrix, dp, i, j, n, m):\\n        if not self.checkLimits(i, j, n, m):\\n            return 0\\n\\n        if dp[i][j] != -1:\\n            return dp[i][j]\\n\\n        c1 = c2 = c3 = c4 = 0\\n\\n        if self.checkLimits(i, j + 1, n, m) and matrix[i][j + 1] > matrix[i][j]:\\n            c1 = self.func(matrix, dp, i, j + 1, n, m)\\n\\n        if self.checkLimits(i, j - 1, n, m) and matrix[i][j - 1] > matrix[i][j]:\\n            c2 = self.func(matrix, dp, i, j - 1, n, m)\\n\\n        if self.checkLimits(i + 1, j, n, m) and matrix[i + 1][j] > matrix[i][j]:\\n            c3 = self.func(matrix, dp, i + 1, j, n, m)\\n\\n        if self.checkLimits(i - 1, j, n, m) and matrix[i - 1][j] > matrix[i][j]:\\n            c4 = self.func(matrix, dp, i - 1, j, n, m)\\n\\n        dp[i][j] = (1 + c1 + c2 + c3 + c4) % self.mod\\n\\n        return dp[i][j]\\n\\n    def countPaths(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dp = [[-1] * col for _ in range(row)]\\n        ans = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans += self.func(matrix, dp, i, j, row, col)\\n                ans %= self.mod\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651387,
                "title": "c-top-down-memoization-dfs-solution-o-m-n",
                "content": "Here R[i][j] is the no. of strictly increasing paths starting from cell grid[i][j].\\nIf a cell grid[i][j] is greater than equal to all the cells in it\\'s four directions, then the no. of strictly increasing paths starting from it is 1 (starts from grid[i][j] and ends at grid[i][j] with length 1)\\nNow we call to each cell to find the paths starting from it and using DFS and memoization complete all cells.\\nThen the sum is calculated by adding all the R[i][j].\\n```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n\\n    void help(vector<vector<int>>& grid, int x, int y, vector<vector<long long>>& R){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> direc = {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        long long ans = 1;\\n        for(int i=0;i<4;i++){\\n            int u = direc[i][0] + x;\\n            int v = direc[i][1] + y;\\n            if(u<0 || u==m || v<0 || v==n || grid[u][v]<=grid[x][y]) continue;\\n            if(R[u][v]==-1) help(grid,u,v,R);\\n            ans += R[u][v]%MOD;\\n            ans %= MOD;\\n        }\\n\\n        R[x][y] = ans;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<long long>> R(m,vector<long long>(n,-1));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if((j+1==n || grid[i][j+1]<=grid[i][j]) && (i+1==m || grid[i+1][j]<=grid[i][j]) && (i==0 || grid[i-1][j]<=grid[i][j]) && (j==0 || grid[i][j-1]<=grid[i][j])){\\n                    R[i][j]=1;\\n                }\\n                \\n            }\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(R[i][j]==-1){\\n                    help(grid,i,j,R);\\n                }\\n            }\\n        }\\n\\n        long long sum = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum += R[i][j]%MOD;\\n                sum %= MOD;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int MOD = 1e9+7;\\n\\n    void help(vector<vector<int>>& grid, int x, int y, vector<vector<long long>>& R){\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> direc = {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        long long ans = 1;\\n        for(int i=0;i<4;i++){\\n            int u = direc[i][0] + x;\\n            int v = direc[i][1] + y;\\n            if(u<0 || u==m || v<0 || v==n || grid[u][v]<=grid[x][y]) continue;\\n            if(R[u][v]==-1) help(grid,u,v,R);\\n            ans += R[u][v]%MOD;\\n            ans %= MOD;\\n        }\\n\\n        R[x][y] = ans;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<long long>> R(m,vector<long long>(n,-1));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if((j+1==n || grid[i][j+1]<=grid[i][j]) && (i+1==m || grid[i+1][j]<=grid[i][j]) && (i==0 || grid[i-1][j]<=grid[i][j]) && (j==0 || grid[i][j-1]<=grid[i][j])){\\n                    R[i][j]=1;\\n                }\\n                \\n            }\\n        }\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(R[i][j]==-1){\\n                    help(grid,i,j,R);\\n                }\\n            }\\n        }\\n\\n        long long sum = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                sum += R[i][j]%MOD;\\n                sum %= MOD;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651367,
                "title": "java-solution-for-number-of-increasing-paths-in-a-grid-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo count the strictly increasing paths, we can start from each cell in the grid and explore all possible paths that strictly increase in value. We can use DFS to traverse the grid and increment the count of paths whenever we move to a cell with a larger value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the memoization array memo of the same size as the grid to store the count of paths for each cell.\\n1. Define the four possible directions (right, left, down, up) in the directions array.\\n1. Iterate over each cell in the grid:\\n- Call the dfs method to count the strictly increasing paths starting from that cell.\\n- Accumulate the counts in the totalPaths variable.\\n4. Implement the dfs method:\\n- Check if the count for the current cell is already memoized in the memo array. If so, return the memoized value.\\n- Initialize a paths variable to keep track of the count of paths from the current cell.\\n- Iterate over the four directions:\\n- Calculate the new row and column based on the current direction.\\n- Check if the new row and column are within the grid boundaries and the value in the new cell is strictly larger than the current cell.\\n- If the conditions are met, call the dfs method recursively for the new cell and add the returned count to paths.\\n- Add 1 to paths to account for the current cell itself.\\n- Take the modulo operation of paths to prevent overflow.\\n- Memoize the count paths for the current cell in the memo array.\\n- Return paths as the count of strictly increasing paths from the current cell.\\n5. Finally, return the totalPaths as the total count of strictly increasing paths in the grid.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(m * n), where m is the number of rows and n is the number of columns in the grid. We visit each cell once during the DFS process.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(m * n) as well. We use the memo array to store the count of paths for each cell, which requires the same amount of space as the grid.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length; // number of rows\\n        int n = grid[0].length; // number of columns\\n\\n    int[][] memo = new int[m][n];\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int modulo = 1000000007;\\n\\n    int totalPaths = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            totalPaths = (totalPaths + dfs(grid, memo, directions, modulo, i, j)) % modulo;\\n        }\\n    }\\n\\n    return totalPaths;\\n    }\\n    private int dfs(int[][] grid, int[][] memo, int[][] directions, int modulo, int row, int col) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n\\n    if (memo[row][col] > 0) {\\n        return memo[row][col];\\n    }\\n\\n    int paths = 0;\\n\\n    for (int[] direction : directions) {\\n        int newRow = row + direction[0];\\n        int newCol = col + direction[1];\\n\\n        if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] > grid[row][col]) {\\n            paths = (paths + dfs(grid, memo, directions, modulo, newRow, newCol)) % modulo;\\n        }\\n    }\\n\\n    paths = (paths + 1) % modulo;\\n    memo[row][col] = paths;\\n\\n    return paths;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length; // number of rows\\n        int n = grid[0].length; // number of columns\\n\\n    int[][] memo = new int[m][n];\\n    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    int modulo = 1000000007;\\n\\n    int totalPaths = 0;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            totalPaths = (totalPaths + dfs(grid, memo, directions, modulo, i, j)) % modulo;\\n        }\\n    }\\n\\n    return totalPaths;\\n    }\\n    private int dfs(int[][] grid, int[][] memo, int[][] directions, int modulo, int row, int col) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n\\n    if (memo[row][col] > 0) {\\n        return memo[row][col];\\n    }\\n\\n    int paths = 0;\\n\\n    for (int[] direction : directions) {\\n        int newRow = row + direction[0];\\n        int newCol = col + direction[1];\\n\\n        if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && grid[newRow][newCol] > grid[row][col]) {\\n            paths = (paths + dfs(grid, memo, directions, modulo, newRow, newCol)) % modulo;\\n        }\\n    }\\n\\n    paths = (paths + 1) % modulo;\\n    memo[row][col] = paths;\\n\\n    return paths;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651246,
                "title": "easy-memoization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define mod 1000000007;\\nclass Solution {\\nprivate:\\n    vector<pair<int,int>> dir={{-1,0},{0,-1},{1,0},{0,1}};\\n    int dfs(int& i,int& j,vector<vector<int>>& grid,vector<vector<int>>& dp) { \\n        //base case\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int curr_ans=1;\\n        for(auto &p : dir) {\\n            int new_i=i+p.first;\\n            int new_j=j+p.second;\\n            if(new_i>=0 && new_i<grid.size() and new_j>=0 && new_j<grid[0].size() and grid[new_i][new_j]<grid[i][j] ) {\\n                curr_ans+=dfs(new_i,new_j,grid,dp);\\n                curr_ans%=mod;\\n            }\\n        }\\n        return dp[i][j]=curr_ans;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(); \\n        int m=grid[0].size(); \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;++i) {\\n            for(int j=0;j<m;++j) { \\n                ans+=dfs(i,j,grid,dp);\\n                ans%=mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n#define mod 1000000007;\\nclass Solution {\\nprivate:\\n    vector<pair<int,int>> dir={{-1,0},{0,-1},{1,0},{0,1}};\\n    int dfs(int& i,int& j,vector<vector<int>>& grid,vector<vector<int>>& dp) { \\n        //base case\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int curr_ans=1;\\n        for(auto &p : dir) {\\n            int new_i=i+p.first;\\n            int new_j=j+p.second;\\n            if(new_i>=0 && new_i<grid.size() and new_j>=0 && new_j<grid[0].size() and grid[new_i][new_j]<grid[i][j] ) {\\n                curr_ans+=dfs(new_i,new_j,grid,dp);\\n                curr_ans%=mod;\\n            }\\n        }\\n        return dp[i][j]=curr_ans;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(); \\n        int m=grid[0].size(); \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;++i) {\\n            for(int j=0;j<m;++j) { \\n                ans+=dfs(i,j,grid,dp);\\n                ans%=mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651200,
                "title": "golang-simple-clean-solution-with-comments-dp-dfs-memo",
                "content": "# Code\\n```\\nconst (\\n\\tmod = 1_000_000_007\\n\\tmaxValue = 100_001 // by constraint\\n)\\n\\nfunc countPaths(grid [][]int) int {\\n\\t// dp holds number of paths for every cell of the grid\\n\\tdp := make([][]int, len(grid))\\n\\tfor i := range grid {\\n\\t\\tdp[i] = make([]int, len(grid[i]))\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tresult = (result + search(grid, dp, maxValue, i, j)) % mod\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\n// go down from bigger number to lower looking for answer since we have strictly increasing constraint\\nfunc search(grid, dp [][]int, previousValue, x, y int) int {\\n\\t// check if we fell out of the grid or previous cell\\'s value is not bigger\\n\\tif x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) || previousValue <= grid[x][y] {\\n\\t\\treturn 0\\n\\t}\\n\\t// return answer for the cell if we\\'ve been here\\n\\tif dp[x][y] > 0 {\\n\\t\\treturn dp[x][y]\\n\\t}\\n\\t// path consisting only cell itself is always possible\\n\\tdp[x][y] = 1\\n\\t// check adjacent cells\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x-1, y) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x+1, y) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x, y-1) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x, y+1) % mod\\n\\treturn dp[x][y]\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nconst (\\n\\tmod = 1_000_000_007\\n\\tmaxValue = 100_001 // by constraint\\n)\\n\\nfunc countPaths(grid [][]int) int {\\n\\t// dp holds number of paths for every cell of the grid\\n\\tdp := make([][]int, len(grid))\\n\\tfor i := range grid {\\n\\t\\tdp[i] = make([]int, len(grid[i]))\\n\\t}\\n\\n\\tresult := 0\\n\\tfor i := 0; i < len(grid); i++ {\\n\\t\\tfor j := 0; j < len(grid[0]); j++ {\\n\\t\\t\\tresult = (result + search(grid, dp, maxValue, i, j)) % mod\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n\\n// go down from bigger number to lower looking for answer since we have strictly increasing constraint\\nfunc search(grid, dp [][]int, previousValue, x, y int) int {\\n\\t// check if we fell out of the grid or previous cell\\'s value is not bigger\\n\\tif x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) || previousValue <= grid[x][y] {\\n\\t\\treturn 0\\n\\t}\\n\\t// return answer for the cell if we\\'ve been here\\n\\tif dp[x][y] > 0 {\\n\\t\\treturn dp[x][y]\\n\\t}\\n\\t// path consisting only cell itself is always possible\\n\\tdp[x][y] = 1\\n\\t// check adjacent cells\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x-1, y) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x+1, y) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x, y-1) % mod\\n\\tdp[x][y] += search(grid, dp, grid[x][y], x, y+1) % mod\\n\\treturn dp[x][y]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650352,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        vector<array<int, 3> > h;\\n        vector<vector<int> > dp;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            dp[i].resize(m);\\n        }\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                h.push_back({grid[i][j], i, j});\\n        sort(h.begin(), h.end());\\n        int mod = 1e9 + 7;\\n        int ans = 0;\\n        for (auto v : h) {\\n            int i = v[1], j = v[2];\\n            int mv[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n            dp[i][j] = 1;\\n            for (int k = 0; k < 4; k++) {\\n                int ei = i + mv[k][0], ej = j + mv[k][1];\\n                if (ei < 0 || ej < 0 || ei >= n || ej >= m) continue;\\n                if (grid[ei][ej] >= grid[i][j]) continue;\\n                dp[i][j] = (dp[i][j] + dp[ei][ej]) % mod;\\n            }\\n            ans = (ans + dp[i][j]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        vector<array<int, 3> > h;\\n        vector<vector<int> > dp;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n);\\n        for (int i = 0; i < n; i++) {\\n            dp[i].resize(m);\\n        }\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                h.push_back({grid[i][j], i, j});\\n        sort(h.begin(), h.end());\\n        int mod = 1e9 + 7;\\n        int ans = 0;\\n        for (auto v : h) {\\n            int i = v[1], j = v[2];\\n            int mv[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n            dp[i][j] = 1;\\n            for (int k = 0; k < 4; k++) {\\n                int ei = i + mv[k][0], ej = j + mv[k][1];\\n                if (ei < 0 || ej < 0 || ei >= n || ej >= m) continue;\\n                if (grid[ei][ej] >= grid[i][j]) continue;\\n                dp[i][j] = (dp[i][j] + dp[ei][ej]) % mod;\\n            }\\n            ans = (ans + dp[i][j]) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650340,
                "title": "python-3-one-line",
                "content": "```python\\nclass Solution:\\n    def countPaths(self, g: List[List[int]]) -> int:\\n        e=enumerate;return sum(map(f:=cache(lambda z:1+sum(f(t)for k in range(4)if g[z]>g.get(t:=z+1j**k,inf))),g:={i+j*1j:x for i,r in e(g)for j,x in e(r)}))%(10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def countPaths(self, g: List[List[int]]) -> int:\\n        e=enumerate;return sum(map(f:=cache(lambda z:1+sum(f(t)for k in range(4)if g[z]>g.get(t:=z+1j**k,inf))),g:={i+j*1j:x for i,r in e(g)for j,x in e(r)}))%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650317,
                "title": "simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mod = 10**9+7\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        res = 0\\n\\n        @lru_cache(maxsize = None)\\n        def dfs(i, j):\\n            ans = 0\\n            for dx, dy in directions:\\n                # if the next block is in bounds, and its value is greater than the prev\\n                if (0 <= i + dx < m) and (0 <= j + dy < n) and (grid[i+dx][j+dy] > grid[i][j]):\\n                    ans += (1 + dfs(i+dx, j+dy))\\n            return ans\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                res = (res + (dfs(i, j) % mod)) % mod\\n        \\n        return res+m*n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mod = 10**9+7\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\n        res = 0\\n\\n        @lru_cache(maxsize = None)\\n        def dfs(i, j):\\n            ans = 0\\n            for dx, dy in directions:\\n                # if the next block is in bounds, and its value is greater than the prev\\n                if (0 <= i + dx < m) and (0 <= j + dy < n) and (grid[i+dx][j+dy] > grid[i][j]):\\n                    ans += (1 + dfs(i+dx, j+dy))\\n            return ans\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                res = (res + (dfs(i, j) % mod)) % mod\\n        \\n        return res+m*n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650225,
                "title": "easiest-best-c-code-dp-on-graphs",
                "content": "#### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1,-1,0,0};\\n    vector<int> dy = {0,0,1,-1};\\n    int dp[1001][1001];\\n    int mod = 1e9 + 7;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid){\\n        int ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        for(int k=0;k<4;k++){\\n            int adj_i = dx[k] + i,adj_j = dy[k] + j;\\n            if(isValid(adj_i,adj_j,m,n) && grid[i][j] < grid[adj_i][adj_j])\\n                ans = (ans + dfs(adj_i,adj_j,m,n,grid)) % mod;\\n        }\\n        return dp[i][j] = 1 + ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                ans = (ans + dfs(i,j,m,n,grid)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/916f0232-f5ad-4376-8d7a-bbfc118a1a68_1687053964.7844274.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1,-1,0,0};\\n    vector<int> dy = {0,0,1,-1};\\n    int dp[1001][1001];\\n    int mod = 1e9 + 7;\\n    bool isValid(int i,int j,int m,int n){\\n        return ((i>=0 && i<m) && (j>=0 && j<n));\\n    }\\n    int dfs(int i,int j,int m,int n,vector<vector<int>>& grid){\\n        int ans = 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        for(int k=0;k<4;k++){\\n            int adj_i = dx[k] + i,adj_j = dy[k] + j;\\n            if(isValid(adj_i,adj_j,m,n) && grid[i][j] < grid[adj_i][adj_j])\\n                ans = (ans + dfs(adj_i,adj_j,m,n,grid)) % mod;\\n        }\\n        return dp[i][j] = 1 + ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size(),ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                ans = (ans + dfs(i,j,m,n,grid)) % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650130,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        mod = 10**9+7       \\n        n = len(grid)        \\n        m = len(grid[0])       \\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\\n        \\n        def solve(row,col,grid,prev,dp):\\n          \\n            if row < 0 or col<0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            directions=[[1,0],[-1,0],[0,-1],[0,1]]            \\n            total=1\\n            for dir in directions:\\n                new_row=row+dir[0]\\n                new_col=col+dir[1]\\n                total += solve(new_row,new_col,grid,grid[row][col],dp)\\n            dp[row][col] = total\\n            return total\\n      \\n        res=0\\n        for row in range(n):\\n            for col in range(m):\\n                res += solve(row,col,grid,-1,dp)\\n        return res % mod\\n\\n                    \\n                \\n\\n\\n                    \\n                \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        mod = 10**9+7       \\n        n = len(grid)        \\n        m = len(grid[0])       \\n        dp = [[-1 for _ in range(m)] for _ in range(n)]\\n        \\n        def solve(row,col,grid,prev,dp):\\n          \\n            if row < 0 or col<0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            directions=[[1,0],[-1,0],[0,-1],[0,1]]            \\n            total=1\\n            for dir in directions:\\n                new_row=row+dir[0]\\n                new_col=col+dir[1]\\n                total += solve(new_row,new_col,grid,grid[row][col],dp)\\n            dp[row][col] = total\\n            return total\\n      \\n        res=0\\n        for row in range(n):\\n            for col in range(m):\\n                res += solve(row,col,grid,-1,dp)\\n        return res % mod\\n\\n                    \\n                \\n\\n\\n                    \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759304,
                "title": "dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    vector<vector<int>>dp;\\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n       dp.resize(grid.size(),vector<int>(grid[0].size(),-1));\\n       int ans = 0;\\n       for(int i=0;i<grid.size();i++)\\n       {\\n          for(int j=0;j<grid[i].size();j++)\\n          {\\n             ans = ((ans % mod) + (fun(grid,i,j) % mod))%mod;\\n          }\\t\\n       }\\n       return ans % mod;\\n    }\\n    int fun(vector<vector<int>>&grid,int row,int col)\\n    {\\n        if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[row][col]!=-1)\\n        return dp[row][col];\\n\\n        int ele = grid[row][col];\\n\\n        int up=0;\\n        int down=0;\\n        int left=0;\\n        int right=0;\\n\\n        if(row-1>=0 and grid[row-1][col] > ele)\\n        up = fun(grid,row-1,col) % mod;\\n\\n        if(row+1<grid.size() and grid[row+1][col] > ele)\\n        down = fun(grid,row+1,col) % mod;\\n\\n        if(col+1<grid[0].size() and grid[row][col+1] > ele)\\n        right = fun(grid,row,col+1) % mod;\\n\\n        if(col-1>=0 and grid[row][col-1] > ele)\\n        left = fun(grid,row,col-1) % mod;\\n\\n        return dp[row][col] = (1+left+right+down+up)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9+7;\\n    vector<vector<int>>dp;\\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n       dp.resize(grid.size(),vector<int>(grid[0].size(),-1));\\n       int ans = 0;\\n       for(int i=0;i<grid.size();i++)\\n       {\\n          for(int j=0;j<grid[i].size();j++)\\n          {\\n             ans = ((ans % mod) + (fun(grid,i,j) % mod))%mod;\\n          }\\t\\n       }\\n       return ans % mod;\\n    }\\n    int fun(vector<vector<int>>&grid,int row,int col)\\n    {\\n        if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[row][col]!=-1)\\n        return dp[row][col];\\n\\n        int ele = grid[row][col];\\n\\n        int up=0;\\n        int down=0;\\n        int left=0;\\n        int right=0;\\n\\n        if(row-1>=0 and grid[row-1][col] > ele)\\n        up = fun(grid,row-1,col) % mod;\\n\\n        if(row+1<grid.size() and grid[row+1][col] > ele)\\n        down = fun(grid,row+1,col) % mod;\\n\\n        if(col+1<grid[0].size() and grid[row][col+1] > ele)\\n        right = fun(grid,row,col+1) % mod;\\n\\n        if(col-1>=0 and grid[row][col-1] > ele)\\n        left = fun(grid,row,col-1) % mod;\\n\\n        return dp[row][col] = (1+left+right+down+up)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503582,
                "title": "python-top-down-dp-dfs-solution",
                "content": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        noOfRows, noOfCols, res = len(grid), len(grid[0]), 0\\n        dp = [[-1 for _ in range(noOfCols)] for _ in range(noOfRows)]\\n        \\n        def dfs(row: int, col: int, prev: int, dp: List[List[int]], grid: List[List[int]]) -> int:\\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            ans = 1\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                ans += dfs(newRow, newCol, grid[row][col], dp, grid)\\n            dp[row][col] = ans\\n            return ans\\n        \\n        for row in range(noOfRows):\\n            for col in range(noOfCols):\\n                res += dfs(row, col, -1, dp, grid)\\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        noOfRows, noOfCols, res = len(grid), len(grid[0]), 0\\n        dp = [[-1 for _ in range(noOfCols)] for _ in range(noOfRows)]\\n        \\n        def dfs(row: int, col: int, prev: int, dp: List[List[int]], grid: List[List[int]]) -> int:\\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]) or grid[row][col] <= prev:\\n                return 0\\n            if dp[row][col] != -1: \\n                return dp[row][col]\\n            ans = 1\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                ans += dfs(newRow, newCol, grid[row][col], dp, grid)\\n            dp[row][col] = ans\\n            return ans\\n        \\n        for row in range(noOfRows):\\n            for col in range(noOfCols):\\n                res += dfs(row, col, -1, dp, grid)\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445379,
                "title": "recursion-dfs-dp",
                "content": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    const int N = 1e9 + 7;\\nprivate:\\n    bool checkBounds(int i, int j, int m, int n){\\n        if(i<0 or j<0 or i>=m or j>=n)\\n            return false;\\n        return true;\\n            \\n        \\n    }\\n    int longestPath(int i, int j, vector<vector<int>>& matrix){\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n        int d = 0;\\n        if(!checkBounds(i,j,matrix.size(),matrix[0].size())){return 0;}\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(i>0 and matrix[i-1][j] > matrix[i][j]){\\n            a = ((1%N) + (longestPath((i-1),j,matrix)%N))%N;\\n        }\\n        if(i< (matrix.size()-1) and matrix[i+1][j] > matrix[i][j]){\\n            b =  ((1%N) + (longestPath((i+1),j,matrix)%N))%N;  \\n        }\\n        if(j>0 and matrix[i][j-1] > matrix[i][j]){\\n            c = ((1%N) + (longestPath((i),(j-1),matrix)%N))%N; \\n        }\\n        if(j< (matrix[0].size()-1) and matrix[i][j+1] > matrix[i][j]){\\n            d =  ((1%N) + (longestPath(i,(j+1),matrix)%N))%N;  \\n        }\\n        \\n        return dp[i][j] = (((a%N)+(b%N)+(c%N)+(d%N))%N);\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int maxCnt = 0;\\n        memset(dp,-1,sizeof dp);\\n        for(int i = 0; i<matrix.size(); i++){\\n            for(int j = 0; j<matrix[0].size(); j++){\\n                maxCnt = ((maxCnt%N) + (longestPath(i,j,matrix)%N)%N);\\n            }\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        return ((maxCnt%N)+(((m%N)*(n%N))%N)%N);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[1001][1001];\\n    const int N = 1e9 + 7;\\nprivate:\\n    bool checkBounds(int i, int j, int m, int n){\\n        if(i<0 or j<0 or i>=m or j>=n)\\n            return false;\\n        return true;\\n            \\n        \\n    }\\n    int longestPath(int i, int j, vector<vector<int>>& matrix){\\n        int a = 0;\\n        int b = 0;\\n        int c = 0;\\n        int d = 0;\\n        if(!checkBounds(i,j,matrix.size(),matrix[0].size())){return 0;}\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(i>0 and matrix[i-1][j] > matrix[i][j]){\\n            a = ((1%N) + (longestPath((i-1),j,matrix)%N))%N;\\n        }\\n        if(i< (matrix.size()-1) and matrix[i+1][j] > matrix[i][j]){\\n            b =  ((1%N) + (longestPath((i+1),j,matrix)%N))%N;  \\n        }\\n        if(j>0 and matrix[i][j-1] > matrix[i][j]){\\n            c = ((1%N) + (longestPath((i),(j-1),matrix)%N))%N; \\n        }\\n        if(j< (matrix[0].size()-1) and matrix[i][j+1] > matrix[i][j]){\\n            d =  ((1%N) + (longestPath(i,(j+1),matrix)%N))%N;  \\n        }\\n        \\n        return dp[i][j] = (((a%N)+(b%N)+(c%N)+(d%N))%N);\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int maxCnt = 0;\\n        memset(dp,-1,sizeof dp);\\n        for(int i = 0; i<matrix.size(); i++){\\n            for(int j = 0; j<matrix[0].size(); j++){\\n                maxCnt = ((maxCnt%N) + (longestPath(i,j,matrix)%N)%N);\\n            }\\n        }\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        return ((maxCnt%N)+(((m%N)*(n%N))%N)%N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414552,
                "title": "easy-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int M=1e9+7;\\n\\t\\tbool check(int i,int j,int rows,int cols)\\n\\t\\t{\\n\\t\\t\\tif(i<0 || j<0 || i>=rows || j>=cols)return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint f(int i,int j,int m,int n,vector<vector<int>>& grid,vector<vector<int>> &dp)\\n\\t\\t{\\n\\t\\t\\tif(i < 0 || j < 0 || i >=m || j >=n) return 0;\\n\\t\\t\\tif(dp[i][j]!=-1)return dp[i][j];\\n\\t\\t\\tint up=0;\\n\\t\\t\\tif(check(i-1,j,m,n) and grid[i][j]<grid[i-1][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tup=1+f(i-1,j,m,n,grid,dp);\\n\\t\\t\\t}\\n\\t\\t\\tint down=0;\\n\\t\\t\\tif(check(i+1,j,m,n) and grid[i][j]<grid[i+1][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdown=1+f(i+1,j,m,n,grid,dp);\\n\\t\\t\\t}\\n\\t\\t\\tint left=0;\\n\\t\\t\\tif(check(i,j-1,m,n) and grid[i][j]<grid[i][j-1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tleft=1+f(i,j-1,m,n,grid,dp);\\n\\t\\t\\t}\\n\\t\\t\\tint right=0;\\n\\t\\t\\tif(check(i,j+1,m,n) and grid[i][j]<grid[i][j+1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tright=1+f(i,j+1,m,n,grid,dp);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j]=(up+down+right+left)%M;\\n\\t\\t}\\n\\t\\tint countPaths(vector<vector<int>>& grid) \\n\\t\\t{\\n\\t\\t\\tint m=grid.size();\\n\\t\\t\\tint n=grid[0].size();\\n\\t\\t\\tvector<vector<int>> dp(m,vector<int>(n,-1));\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t ans=(ans+f(i,j,m,n,grid,dp))%M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%M+(m*n);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t///////////////////////////////////////////////////////////////////////////////////\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int M=1e9+7;\\n\\t\\tint f(int i,int j,int mm,int n,vector<vector<int>>& m,vector<vector<int>>& dp)\\n\\t\\t{\\n\\t\\t\\tif(i<0 or j<0 or i>=mm or j>=n)return 0;\\n\\n\\t\\t\\tif(dp[i][j]!=-1)return dp[i][j];\\n\\n\\t\\t\\tint ans=1;\\n\\t\\t\\tif(i>0 and m[i][j]<m[i-1][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=f(i-1,j,mm,n,m,dp);\\n\\t\\t\\t}\\n\\t\\t\\tif(i+1<mm and m[i][j]<m[i+1][j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=f(i+1,j,mm,n,m,dp);\\n\\t\\t\\t}\\n\\t\\t\\tif(j>0 and m[i][j]<m[i][j-1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=f(i,j-1,mm,n,m,dp);\\n\\t\\t\\t}\\n\\t\\t\\tif(j+1<n and m[i][j]<m[i][j+1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tans+=f(i,j+1,mm,n,m,dp);\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j]=ans%M;\\n\\t\\t}\\n\\t\\tint countPaths(vector<vector<int>>& matrix) \\n\\t\\t{\\n\\t\\t\\tint m = matrix.size(), n = matrix[0].size();\\n\\t\\t\\tvector<vector<int>> dp(m, vector<int> (n, -1));\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans+=f(i,j,m,n,matrix,dp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%M;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst int M=1e9+7;\\n\\t\\tbool check(int i,int j,int rows,int cols)\\n\\t\\t{\\n\\t\\t\\tif(i<0 || j<0 || i>=rows || j>=cols)return false;\\n\\t\\t\\treturn true;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2252757,
                "title": "python3-dp",
                "content": "Use a list of tuple to remember grid[i][j] value and its coordinators (grid[i][j], i, j)\\nSort it ascendingly\\nAnd then use DP to find how many valid paths is available at [i,j] by sum up all neighbours\\n\\n```\\ndef countPaths(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = []\\n        for i in range(m):\\n            for j in range(n):\\n                d.append((grid[i][j],i,j))\\n               \\n\\t\\td = sorted(d)\\n        dp = [[1]*n for i in range(m)]\\n        ans = 0\\n        m1 = 10**9+7\\n        for (key,i,j) in d:\\n\\t\\t\\tif (i-1>=0):\\n\\t\\t\\t\\tif grid[i][j] > grid[i-1][j]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i-1][j]\\n\\t\\t\\tif j-1>=0:\\n\\t\\t\\t\\tif grid[i][j] > grid[i][j-1]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i][j-1]\\n\\t\\t\\tif i+1<m:\\n\\t\\t\\t\\tif grid[i][j] > grid[i+1][j]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i+1][j]\\n\\t\\t\\tif j+1<n:\\n\\t\\t\\t\\tif grid[i][j] > grid[i][j+1]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i][j+1]\\n\\t\\t\\tans = (ans+dp[i][j])%m1\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "Use a list of tuple to remember grid[i][j] value and its coordinators (grid[i][j], i, j)\\nSort it ascendingly\\nAnd then use DP to find how many valid paths is available at [i,j] by sum up all neighbours\\n\\n```\\ndef countPaths(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = []\\n        for i in range(m):\\n            for j in range(n):\\n                d.append((grid[i][j],i,j))\\n               \\n\\t\\td = sorted(d)\\n        dp = [[1]*n for i in range(m)]\\n        ans = 0\\n        m1 = 10**9+7\\n        for (key,i,j) in d:\\n\\t\\t\\tif (i-1>=0):\\n\\t\\t\\t\\tif grid[i][j] > grid[i-1][j]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i-1][j]\\n\\t\\t\\tif j-1>=0:\\n\\t\\t\\t\\tif grid[i][j] > grid[i][j-1]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i][j-1]\\n\\t\\t\\tif i+1<m:\\n\\t\\t\\t\\tif grid[i][j] > grid[i+1][j]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i+1][j]\\n\\t\\t\\tif j+1<n:\\n\\t\\t\\t\\tif grid[i][j] > grid[i][j+1]:\\n\\t\\t\\t\\t\\tdp[i][j] += dp[i][j+1]\\n\\t\\t\\tans = (ans+dp[i][j])%m1\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2242552,
                "title": "c-easy-recursion-memoization-dp-explained",
                "content": "RECURSIVE FUNCTION WITH EXPLAINATION:\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod =  1e9+7;\\n    int solve(vector<vector<int>>& grid , int n , int m , int i , int j ){\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return 0;\\n        \\n        //initialising our count which will give us the number of increasing paths starting from position (i,j)\\n     \\n        int count=0;\\n        \\n        // l->for left movement , r->for right movement , u->for up movement ,d->for down movement ,\\n        int l=0,r=0,u=0,d=0;\\n        \\n        // now here we will only move to left if the element to the left is greater than the current cell\\'s value and also apply conditions so that we dont go out of bounds , and do this right , up , down movement\\n        \\n        if(  j>=1  && grid[i][j-1]>grid[i][j])\\n            l=1+solve(grid,n,m,i,j-1);\\n        \\n        if(  j<m-1 && grid[i][j+1]>grid[i][j])\\n            r=1+solve(grid,n,m,i,j+1);\\n        \\n        if( i>=1  && grid[i-1][j]>grid[i][j])\\n            u=1+solve(grid,n,m,i-1,j);\\n        \\n        if(  i<n-1 && grid[i+1][j]>grid[i][j])\\n            d=1+solve(grid,n,m,i+1,j);\\n        \\n        \\n        // count will be addition of all lengths of increasing paths \\n        count+=l+r+u+d;\\n        count = count % mod;\\n        return count;\\n        \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int count=0;\\n      \\n        // as we can start from any cell , therefore we will traverse over the whole grid\\n        // now start from every cell having position (i,j) ,\\n        //  and then we will call our recursive function which will give us the number of increasing paths starting from position (i,j)\\n        \\n        // we will store these values in count which will give us the total no of increasing path in the grid\\n        \\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                count+=solve(grid,n,m,i,j);\\n                \\n                // we will be using mod for large values , as it is giving runtime after test case 34/36\\n                count %= mod;\\n            }\\n        }\\n        \\n        // at last we will add the count and here will also add the number of elements in the grid , because ATQ, paths with length 1 are also increasing paths \\n        return count+(n*m);\\n    }\\n};\\n```\\nRECURSION + MEMOIZATION \\n```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int mod =  1e9+7;\\n    int solve(vector<vector<int>>& grid , int n , int m , int i , int j ){\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return 0;\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int count=0;\\n        int l=0,r=0,u=0,d=0;\\n        \\n        if(  j>=1  && grid[i][j-1]>grid[i][j])\\n            l=1+solve(grid,n,m,i,j-1);\\n        \\n        if(  j<m-1 && grid[i][j+1]>grid[i][j])\\n            r=1+solve(grid,n,m,i,j+1);\\n        \\n        if( i>=1  && grid[i-1][j]>grid[i][j])\\n            u=1+solve(grid,n,m,i-1,j);\\n        \\n        if(  i<n-1 && grid[i+1][j]>grid[i][j])\\n            d=1+solve(grid,n,m,i+1,j);\\n        \\n        count+=l+r+u+d;\\n        count = count % mod;\\n        return dp[i][j]=count;\\n        \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                count+=solve(grid,n,m,i,j);\\n                count %= mod;\\n            }\\n        }\\n        \\n        return count+(n*m);\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod =  1e9+7;\\n    int solve(vector<vector<int>>& grid , int n , int m , int i , int j ){\\n        if(i<0 || i>=n || j<0 || j>=m)\\n            return 0;\\n        \\n        //initialising our count which will give us the number of increasing paths starting from position (i,j)\\n     \\n        int count=0;\\n        \\n        // l->for left movement , r->for right movement , u->for up movement ,d->for down movement ,\\n        int l=0,r=0,u=0,d=0;\\n        \\n        // now here we will only move to left if the element to the left is greater than the current cell\\'s value and also apply conditions so that we dont go out of bounds , and do this right , up , down movement\\n        \\n        if(  j>=1  && grid[i][j-1]>grid[i][j])\\n            l=1+solve(grid,n,m,i,j-1);\\n        \\n        if(  j<m-1 && grid[i][j+1]>grid[i][j])\\n            r=1+solve(grid,n,m,i,j+1);\\n        \\n        if( i>=1  && grid[i-1][j]>grid[i][j])\\n            u=1+solve(grid,n,m,i-1,j);\\n        \\n        if(  i<n-1 && grid[i+1][j]>grid[i][j])\\n            d=1+solve(grid,n,m,i+1,j);\\n        \\n        \\n        // count will be addition of all lengths of increasing paths \\n        count+=l+r+u+d;\\n        count = count % mod;\\n        return count;\\n        \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int count=0;\\n      \\n        // as we can start from any cell , therefore we will traverse over the whole grid\\n        // now start from every cell having position (i,j) ,\\n        //  and then we will call our recursive function which will give us the number of increasing paths starting from position (i,j)\\n        \\n        // we will store these values in count which will give us the total no of increasing path in the grid\\n        \\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                count+=solve(grid,n,m,i,j);\\n                \\n                // we will be using mod for large values , as it is giving runtime after test case 34/36\\n                count %= mod;\\n            }\\n        }\\n        \\n        // at last we will add the count and here will also add the number of elements in the grid , because ATQ, paths with length 1 are also increasing paths \\n        return count+(n*m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230881,
                "title": "java-dfs-with-memo",
                "content": "similar to https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\\n```\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    long[][] memo;\\n    long modulo = 1000000007; // 1e9+7\\n    \\n    public int countPaths(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        long count = 0;\\n        \\n        memo = new long[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                count = (count + dfs(grid, i, j)) % modulo;\\n                // System.out.println(\"(\" + i + \", \" + j + \"): count += \" + dfs(grid, i, j));\\n            }\\n        }\\n    \\n        return (int) (count % modulo);\\n    }\\n    \\n    \\n    long dfs(int[][] grid, int r, int c) {\\n\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        long ans = 1;\\n        \\n        for (int[] d : dirs) {\\n            int x = r + d[0];\\n            int y = c + d[1];\\n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] <= grid[r][c]) continue;\\n            ans += dfs(grid, x, y) % modulo;\\n        }\\n        \\n        memo[r][c] = ans;\\n\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    long[][] memo;\\n    long modulo = 1000000007; // 1e9+7\\n    \\n    public int countPaths(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        long count = 0;\\n        \\n        memo = new long[m][n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                count = (count + dfs(grid, i, j)) % modulo;\\n                // System.out.println(\"(\" + i + \", \" + j + \"): count += \" + dfs(grid, i, j));\\n            }\\n        }\\n    \\n        return (int) (count % modulo);\\n    }\\n    \\n    \\n    long dfs(int[][] grid, int r, int c) {\\n\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        long ans = 1;\\n        \\n        for (int[] d : dirs) {\\n            int x = r + d[0];\\n            int y = c + d[1];\\n            if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] <= grid[r][c]) continue;\\n            ans += dfs(grid, x, y) % modulo;\\n        }\\n        \\n        memo[r][c] = ans;\\n\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230546,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    private final long M = 1000000007;\\n    private final int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    private int[][] grid;\\n    private int m, n;\\n    private long[][] dp;\\n    \\n    public int countPaths(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        dp = new long[m][n];\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        long ans = 0;\\n        boolean[][] visited = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = (ans + dfs(i, j, 0, visited)) % M;\\n            }\\n        }\\n        \\n        return (int) ans;\\n    }\\n    \\n    private long dfs(int i, int j, int prev, boolean[][] visited) {\\n        if (grid[i][j] <= prev) return 0;\\n        \\n        if (dp[i][j] > -1) return dp[i][j];\\n        \\n        long ans = 1;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                ans = (ans + dfs(x, y, grid[i][j], visited)) % M;\\n            }\\n        }\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final long M = 1000000007;\\n    private final int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    private int[][] grid;\\n    private int m, n;\\n    private long[][] dp;\\n    \\n    public int countPaths(int[][] grid) {\\n        this.grid = grid;\\n        m = grid.length;\\n        n = grid[0].length;\\n        \\n        dp = new long[m][n];\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        \\n        long ans = 0;\\n        boolean[][] visited = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans = (ans + dfs(i, j, 0, visited)) % M;\\n            }\\n        }\\n        \\n        return (int) ans;\\n    }\\n    \\n    private long dfs(int i, int j, int prev, boolean[][] visited) {\\n        if (grid[i][j] <= prev) return 0;\\n        \\n        if (dp[i][j] > -1) return dp[i][j];\\n        \\n        long ans = 1;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) {\\n            int x = i + dir[0], y = j + dir[1];\\n            if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                ans = (ans + dfs(x, y, grid[i][j], visited)) % M;\\n            }\\n        }\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230431,
                "title": "java-simple-topological-sorting-solution",
                "content": "Treat the matrix as a graph, then it is just a standard topological sorting problem.\\n\\n```\\n    private int[][] DIRS = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int countPaths(int[][] grid) {\\n        int mod = (int) (1e9 + 7);\\n\\n        int[] outdegrees = new int[grid.length * grid[0].length];\\n        int[] sizes = new int[grid.length * grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                for (int[] dir : DIRS) {\\n                    int x = i + dir[0];\\n                    int y = j + dir[1];\\n\\n                    if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] > grid[i][j]) {\\n                        int ind = i * grid[0].length + j;\\n                        outdegrees[ind]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < outdegrees.length; i++) {\\n            if (outdegrees[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            sizes[curr] += 1;\\n\\n            int i = curr / grid[0].length;\\n            int j = curr % grid[0].length;\\n\\n            for (int[] dir : DIRS) {\\n                int x = i + dir[0];\\n                int y = j + dir[1];\\n\\n                if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] < grid[i][j]) {\\n                    int next = x * grid[0].length + y;\\n                    sizes[next] += sizes[curr];\\n                    sizes[next] %= mod;\\n                    outdegrees[next]--;\\n                    if (outdegrees[next] == 0) {\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 0;\\n\\n        for (int size : sizes) {\\n            result += size;\\n            result %= mod;\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n    private int[][] DIRS = new int[][] {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n\\n    public int countPaths(int[][] grid) {\\n        int mod = (int) (1e9 + 7);\\n\\n        int[] outdegrees = new int[grid.length * grid[0].length];\\n        int[] sizes = new int[grid.length * grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                for (int[] dir : DIRS) {\\n                    int x = i + dir[0];\\n                    int y = j + dir[1];\\n\\n                    if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] > grid[i][j]) {\\n                        int ind = i * grid[0].length + j;\\n                        outdegrees[ind]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < outdegrees.length; i++) {\\n            if (outdegrees[i] == 0) {\\n                queue.add(i);\\n            }\\n        }\\n\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            sizes[curr] += 1;\\n\\n            int i = curr / grid[0].length;\\n            int j = curr % grid[0].length;\\n\\n            for (int[] dir : DIRS) {\\n                int x = i + dir[0];\\n                int y = j + dir[1];\\n\\n                if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] < grid[i][j]) {\\n                    int next = x * grid[0].length + y;\\n                    sizes[next] += sizes[curr];\\n                    sizes[next] %= mod;\\n                    outdegrees[next]--;\\n                    if (outdegrees[next] == 0) {\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 0;\\n\\n        for (int size : sizes) {\\n            result += size;\\n            result %= mod;\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230078,
                "title": "clean-c-code-dp-memo-simple-to-understand",
                "content": "```\\n\\t#define MAX 1000\\n    int mod = 1e9+7;\\n\\n    int CountIncreasingPaths(vector<vector<int>>& grid, int dp[MAX][MAX],\\n                                              int n, int m,int x, int y){  \\n    if (dp[x][y] != -1)\\n        return dp[x][y];    //return if already present\\n   \\n    int neigh[4][2] = {{ 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 }}; //possible moves\\n    int newx, newy; \\n   \\n    int ans = 1;\\n \\n    for (int i = 0; i < 4; i++) {\\n        newx = x + neigh[i][0];   //new values of x & y\\n        newy = y + neigh[i][1];\\n     \\n        if (newx >= 0 && newx < n && newy >= 0           //check if they are valid\\n            && newy < m && grid[newx][newy] > grid[x][y]) {\\n            ans += CountIncreasingPaths(grid, dp, n, m,newx, newy);   //call the function for new values of x & y\\n            ans = ans% mod;   \\n        }\\n    }\\n   \\n    return dp[x][y] = ans;         //memoize\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n        int dp[MAX][MAX];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n \\n        for (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\tdp[i][j] = -1;\\n \\n        int sum = 0;\\n \\n        for (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 0; j < m; j++){\\n\\t\\t\\t\\tsum += CountIncreasingPaths(grid, dp, n, m, i, j);\\n\\t\\t\\t\\tsum = sum% mod;\\n        }\\n        \\n        return sum % mod;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\t#define MAX 1000\\n    int mod = 1e9+7;\\n\\n    int CountIncreasingPaths(vector<vector<int>>& grid, int dp[MAX][MAX],\\n                                              int n, int m,int x, int y){  \\n    if (dp[x][y] != -1)\\n        return dp[x][y];    //return if already present\\n   \\n    int neigh[4][2] = {{ 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 }}; //possible moves\\n    int newx, newy; \\n   \\n    int ans = 1;\\n \\n    for (int i = 0; i < 4; i++) {\\n        newx = x + neigh[i][0];   //new values of x & y\\n        newy = y + neigh[i][1];\\n     \\n        if (newx >= 0 && newx < n && newy >= 0           //check if they are valid\\n            && newy < m && grid[newx][newy] > grid[x][y]) {\\n            ans += CountIncreasingPaths(grid, dp, n, m,newx, newy);   //call the function for new values of x & y\\n            ans = ans% mod;   \\n        }\\n    }\\n   \\n    return dp[x][y] = ans;         //memoize\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n        int dp[MAX][MAX];\\n        int n = grid.size();\\n        int m = grid[0].size();\\n \\n        for (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\tdp[i][j] = -1;\\n \\n        int sum = 0;\\n \\n        for (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = 0; j < m; j++){\\n\\t\\t\\t\\tsum += CountIncreasingPaths(grid, dp, n, m, i, j);\\n\\t\\t\\t\\tsum = sum% mod;\\n        }\\n        \\n        return sum % mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230070,
                "title": "dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1000000007;\\n\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp,\\n                                              int n, int m)\\n{\\n  \\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n \\n   \\n    int arr[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int ii, jj;\\n \\n   \\n    int sum = 1;\\n \\n    for (int k = 0; k < 4; k++) {\\n \\n        \\n        ii = i + arr[k][0];\\n        jj = j + arr[k][1];\\n \\n     \\n        if (ii >= 0 && ii < n && jj >= 0\\n            && jj < m && grid[ii][jj] > grid[i][j]) {\\n            sum += solve(ii,jj,grid, dp, n, m);\\n            sum = sum %mod;\\n            \\n        }\\n    }\\n   \\n    return dp[i][j] = sum;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n   \\n        int n = grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n \\n        int ans = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n           for (int j = 0; j < m; j++){\\n            ans += solve(i,j,grid, dp, n,m);\\n            ans%= mod;\\n        }\\n        \\n \\n        return ans % mod;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1000000007;\\n\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp,\\n                                              int n, int m)\\n{\\n  \\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n \\n   \\n    int arr[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int ii, jj;\\n \\n   \\n    int sum = 1;\\n \\n    for (int k = 0; k < 4; k++) {\\n \\n        \\n        ii = i + arr[k][0];\\n        jj = j + arr[k][1];\\n \\n     \\n        if (ii >= 0 && ii < n && jj >= 0\\n            && jj < m && grid[ii][jj] > grid[i][j]) {\\n            sum += solve(ii,jj,grid, dp, n, m);\\n            sum = sum %mod;\\n            \\n        }\\n    }\\n   \\n    return dp[i][j] = sum;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n   \\n        int n = grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n \\n        int ans = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n           for (int j = 0; j < m; j++){\\n            ans += solve(i,j,grid, dp, n,m);\\n            ans%= mod;\\n        }\\n        \\n \\n        return ans % mod;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230019,
                "title": "dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1000000007;\\n\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp,\\n                                              int n, int m)\\n{\\n  \\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n \\n   \\n    int arr[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int ii, jj;\\n \\n   \\n    int sum = 1;\\n \\n    for (int k = 0; k < 4; k++) {\\n \\n        \\n        ii = i + arr[k][0];\\n        jj = j + arr[k][1];\\n \\n     \\n        if (ii >= 0 && ii < n && jj >= 0\\n            && jj < m && grid[ii][jj] > grid[i][j]) {\\n            sum += solve(ii,jj,grid, dp, n, m);\\n            sum = sum %mod;\\n            \\n        }\\n    }\\n   \\n    return dp[i][j] = sum;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n   \\n        int n = grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n \\n        int ans = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n           for (int j = 0; j < m; j++){\\n            ans += solve(i,j,grid, dp, n,m);\\n            ans%= mod;\\n        }\\n        \\n \\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1000000007;\\n\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp,\\n                                              int n, int m)\\n{\\n  \\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n \\n   \\n    int arr[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\\n    int ii, jj;\\n \\n   \\n    int sum = 1;\\n \\n    for (int k = 0; k < 4; k++) {\\n \\n        \\n        ii = i + arr[k][0];\\n        jj = j + arr[k][1];\\n \\n     \\n        if (ii >= 0 && ii < n && jj >= 0\\n            && jj < m && grid[ii][jj] > grid[i][j]) {\\n            sum += solve(ii,jj,grid, dp, n, m);\\n            sum = sum %mod;\\n            \\n        }\\n    }\\n   \\n    return dp[i][j] = sum;\\n}\\n \\n    int countPaths(vector<vector<int>>& grid) {\\n   \\n        int n = grid.size();\\n        int m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,-1));\\n \\n        int ans = 0;\\n \\n\\n        for (int i = 0; i < n; i++)\\n           for (int j = 0; j < m; j++){\\n            ans += solve(i,j,grid, dp, n,m);\\n            ans%= mod;\\n        }\\n        \\n \\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229833,
                "title": "c-dp",
                "content": "\\t#define mod 1000000007\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long dp[1001][1001];\\n\\t\\tint dir[4][2] = { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } },n,m;\\n\\t\\tint help(vector<vector<int>>& grid, int i, int j){\\n\\t\\t\\tif (dp[i][j] != -1) return dp[i][j];\\n\\t\\t\\tlong long res = 1;\\n\\t\\t\\tfor (auto d:dir) {\\n\\t\\t\\t\\tint  x = i + d[0];\\n\\t\\t\\t\\tint  y = j + d[1];\\n\\t\\t\\t\\tif (x >= 0 and x < n and y >= 0 and y < m and grid[x][y] > grid[i][j]) {\\n\\t\\t\\t\\t\\tres = (res + help(grid, x, y))%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j] = res%mod;\\n\\t\\t}\\n\\t\\tint countPaths(vector<vector<int>>& grid) {\\n\\t\\t\\tn = grid.size();\\n\\t\\t\\tm = grid[0].size();\\n\\t\\t\\tmemset(dp,-1,sizeof dp);\\n\\t\\t\\tlong long sum = 0;\\n\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t for (int j = 0; j < m; j++)\\n\\t\\t\\t\\tsum  = (sum + help(grid, i, j))%mod;\\n\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long dp[1001][1001];\\n\\t\\tint dir[4][2] = { { 0, 1 }",
                "codeTag": "Java"
            },
            {
                "id": 2229816,
                "title": "recursion-on-neighbours",
                "content": "```\\nclass Solution:\\n    def getNeighbours(self, i, j, m, n):\\n        for x, y in [(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)]:\\n            if 0 <= x < m and 0 <= y < n:\\n                yield (x, y)\\n    \\n    def numInc(self, matrix, i, j, m, n):\\n        if (i, j) in self.cache:\\n            return self.cache[(i, j)]\\n        res = 1\\n        for x, y in self.getNeighbours(i, j, m, n):\\n            if matrix[x][y] > matrix[i][j]:\\n                curr = self.numInc(matrix, x, y, m, n)\\n                res += curr\\n        self.cache[(i, j)] = res\\n        return res\\n    \\n    def countPaths(self, matrix: List[List[int]]) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        self.cache = {}\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res += self.numInc(matrix, i, j, m, n)\\n        return res % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getNeighbours(self, i, j, m, n):\\n        for x, y in [(i - 1, j), (i, j + 1), (i + 1, j), (i, j - 1)]:\\n            if 0 <= x < m and 0 <= y < n:\\n                yield (x, y)\\n    \\n    def numInc(self, matrix, i, j, m, n):\\n        if (i, j) in self.cache:\\n            return self.cache[(i, j)]\\n        res = 1\\n        for x, y in self.getNeighbours(i, j, m, n):\\n            if matrix[x][y] > matrix[i][j]:\\n                curr = self.numInc(matrix, x, y, m, n)\\n                res += curr\\n        self.cache[(i, j)] = res\\n        return res\\n    \\n    def countPaths(self, matrix: List[List[int]]) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        self.cache = {}\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res += self.numInc(matrix, i, j, m, n)\\n        return res % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857161,
                "title": "dfs-memoization-o-m-n-clean-java-code",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private final int mod = (int) (1e9 + 7);\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1}, new Integer[]{0, -1}, new Integer[]{1, 0}, new Integer[]{-1, 0}\\n    );\\n    public int countPaths(int[][] grid) {\\n        int count = 0;\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for (int[] row: memo) Arrays.fill(row, -1);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                count = (count + expand(i, j, 0, grid, memo)) % mod;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int expand(int i, int j, int prev, int[][] grid, int[][] memo) {\\n        if(grid[i][j] <= prev) return 0;\\n        if (memo[i][j] != -1) return memo[i][j];\\n        int count = 1;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            if (isValid(x, y, grid)) {\\n                count = (count + expand(x, y, grid[i][j], grid, memo)) % mod;\\n            }\\n        }\\n        memo[i][j] = count;\\n        return memo[i][j];\\n    }\\n\\n    private boolean isValid(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private final int mod = (int) (1e9 + 7);\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1}, new Integer[]{0, -1}, new Integer[]{1, 0}, new Integer[]{-1, 0}\\n    );\\n    public int countPaths(int[][] grid) {\\n        int count = 0;\\n        int[][] memo = new int[grid.length][grid[0].length];\\n        for (int[] row: memo) Arrays.fill(row, -1);\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                count = (count + expand(i, j, 0, grid, memo)) % mod;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private int expand(int i, int j, int prev, int[][] grid, int[][] memo) {\\n        if(grid[i][j] <= prev) return 0;\\n        if (memo[i][j] != -1) return memo[i][j];\\n        int count = 1;\\n        for (Integer[] direction: directions) {\\n            int x = i + direction[0], y = j + direction[1];\\n            if (isValid(x, y, grid)) {\\n                count = (count + expand(x, y, grid[i][j], grid, memo)) % mod;\\n            }\\n        }\\n        memo[i][j] = count;\\n        return memo[i][j];\\n    }\\n\\n    private boolean isValid(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684486,
                "title": "simple-solution-using-bfs-and-memoization-in-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        row , col = len(grid) , len(grid[0])\\n        dp = [[-1 for i in range(col+1)] for j in range(row+1)]\\n\\n        def solve( x , y ):\\n            if dp[x][y] != -1: return dp[x][y]\\n\\n            left , right , up , down = 0 , 0 , 0 , 0\\n\\n            if x > 0 and grid[x-1][y] > grid[x][y]:\\n                up = 1 + solve( x-1 , y )\\n            \\n            if x < row-1 and grid[x+1][y] > grid[x][y]:\\n                down = 1 + solve( x+1 , y )\\n            \\n            if y > 0 and grid[x][y-1] > grid[x][y]:\\n                left = 1 + solve( x , y-1 )\\n            \\n            if y < col-1 and grid[x][y+1] > grid[x][y]:\\n                right = 1 + solve( x , y+1 )\\n            \\n            dp[x][y] = left+right+up+down\\n            return dp[x][y]\\n        \\n        ans = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans += solve(i , j)\\n        \\n        return ( ans + (row*col) ) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        row , col = len(grid) , len(grid[0])\\n        dp = [[-1 for i in range(col+1)] for j in range(row+1)]\\n\\n        def solve( x , y ):\\n            if dp[x][y] != -1: return dp[x][y]\\n\\n            left , right , up , down = 0 , 0 , 0 , 0\\n\\n            if x > 0 and grid[x-1][y] > grid[x][y]:\\n                up = 1 + solve( x-1 , y )\\n            \\n            if x < row-1 and grid[x+1][y] > grid[x][y]:\\n                down = 1 + solve( x+1 , y )\\n            \\n            if y > 0 and grid[x][y-1] > grid[x][y]:\\n                left = 1 + solve( x , y-1 )\\n            \\n            if y < col-1 and grid[x][y+1] > grid[x][y]:\\n                right = 1 + solve( x , y+1 )\\n            \\n            dp[x][y] = left+right+up+down\\n            return dp[x][y]\\n        \\n        ans = 0\\n\\n        for i in range(row):\\n            for j in range(col):\\n                ans += solve(i , j)\\n        \\n        return ( ans + (row*col) ) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673789,
                "title": "c-super-easy-dfs-memoization-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint dx[4] = {0,0,-1,1};\\nint dy[4] = {-1,1,0,0};\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\nprivate:\\n    int dfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(dp[x][y] != -1) return dp[x][y];\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int count = 1;\\n        for(int i=0; i<4; i++){\\n\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n\\n            if(nx>=0 && ny>=0 && nx<n && ny < m && grid[x][y] < grid[nx][ny]){\\n                count = (count%mod + dfs(nx,ny,grid,dp)%mod)%mod;\\n            }\\n\\n        }\\n        return dp[x][y] = count;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = (ans%mod + dfs(i,j,grid,dp)%mod)%mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nint dx[4] = {0,0,-1,1};\\nint dy[4] = {-1,1,0,0};\\nconst int mod = 1e9+7;\\n\\nclass Solution {\\nprivate:\\n    int dfs(int x, int y, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(dp[x][y] != -1) return dp[x][y];\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int count = 1;\\n        for(int i=0; i<4; i++){\\n\\n            int nx = x + dx[i];\\n            int ny = y + dy[i];\\n\\n            if(nx>=0 && ny>=0 && nx<n && ny < m && grid[x][y] < grid[nx][ny]){\\n                count = (count%mod + dfs(nx,ny,grid,dp)%mod)%mod;\\n            }\\n\\n        }\\n        return dp[x][y] = count;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = (ans%mod + dfs(i,j,grid,dp)%mod)%mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662680,
                "title": "beats-70-c-dfs-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int delrow[4] = {-1, 1, 0, 0};\\n    int delcol[4] = {0, 0, -1, 1};\\n    \\n    int solve( int x, int y, int m, int n,vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        \\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        \\n        long long ans = 1;\\n        \\n        for (int i = 0; i < 4; i++) {\\n            int nr = x + delrow[i];\\n            int nc = y + delcol[i];\\n\\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[x][y] < grid[nr][nc]) {\\n                ans += solve( nr, nc, m, n,grid, dp);\\n            }\\n        }\\n        return dp[x][y] = ans % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long ans = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += solve( i, j, m, n,grid, dp);\\n            }\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int delrow[4] = {-1, 1, 0, 0};\\n    int delcol[4] = {0, 0, -1, 1};\\n    \\n    int solve( int x, int y, int m, int n,vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        \\n        if (dp[x][y] != -1)\\n            return dp[x][y];\\n        \\n        long long ans = 1;\\n        \\n        for (int i = 0; i < 4; i++) {\\n            int nr = x + delrow[i];\\n            int nc = y + delcol[i];\\n\\n            if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[x][y] < grid[nr][nc]) {\\n                ans += solve( nr, nc, m, n,grid, dp);\\n            }\\n        }\\n        return dp[x][y] = ans % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        \\n        long long ans = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                ans += solve( i, j, m, n,grid, dp);\\n            }\\n        }\\n        return ans % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658099,
                "title": "simple-and-optimal-python3-solution-dfs-memoization",
                "content": "# Complexity\\n- Time complexity: $$O(n \\\\cdot m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\cdot m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nfrom functools import cache\\n\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        modulo = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        @cache\\n        def recursive(i, j):\\n            result = 1\\n            elem = grid[i][j]\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if (\\n                    0 <= x < m\\n                    and 0 <= y < n\\n                    and elem < grid[x][y]\\n                ):\\n                    result += recursive(x, y)\\n            return result % modulo\\n        \\n        return sum(\\n            recursive(i, j)\\n            for i in range(m)\\n            for j in range(n)\\n        ) % modulo\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "``` python3 []\\nfrom functools import cache\\n\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        modulo = 1_000_000_007\\n        m = len(grid)\\n        n = len(grid[0])\\n\\n        @cache\\n        def recursive(i, j):\\n            result = 1\\n            elem = grid[i][j]\\n            for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):\\n                if (\\n                    0 <= x < m\\n                    and 0 <= y < n\\n                    and elem < grid[x][y]\\n                ):\\n                    result += recursive(x, y)\\n            return result % modulo\\n        \\n        return sum(\\n            recursive(i, j)\\n            for i in range(m)\\n            for j in range(n)\\n        ) % modulo\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656497,
                "title": "graph-dp-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply doing dfs traversal in through the matrix.\\nSince, we need to find strictly increasing path, therefore we can travel to next cell only if `grid[neighbour_row][neighbour_col] > grid[row][j=col]`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize variable `cnt` as 0.\\n- For all cells, call path function.\\n- The path function is defined as:\\n     1. Declare pathcost as 1.\\n     2. Check neighbour cell (left, right, up, down) if exist, only when `grid[neighbour_row][neighbour_col] > grid[row][j=col]`.\\n     3. Add it to pathcost, call function path for this cell.\\n     4. store pathcost for each cell(i, j) in `dp[i][j]`.\\n     5. return `dp[i][j]`.\\n- Add value returned by function to `cnt`.\\n- return `cnt`.\\n\\n# Complexity\\n- Time complexity: O(n x m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n x m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int path(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int n = grid.size(), m = grid[0].size();\\n\\n        int delrow[] = {0, 0, -1, 1};\\n        int delcol[] = {-1, 1, 0, 0};\\n\\n        int pathcost = 1;\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int row = delrow[k] + i, col = delcol[k] + j;\\n\\n            if(row >= 0 && row < n && col >= 0 && col < m  && grid[row][col] > grid[i][j])\\n                pathcost = (pathcost%mod + path(row, col, grid, dp)%mod) % mod;\\n        }\\n        return dp[i][j] = pathcost;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        long long cnt = 0;\\n\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                cnt = (cnt % mod + path(i, j, grid, dp) % mod) % mod;\\n        }\\n\\n        return (int)cnt % mod;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int path(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int n = grid.size(), m = grid[0].size();\\n\\n        int delrow[] = {0, 0, -1, 1};\\n        int delcol[] = {-1, 1, 0, 0};\\n\\n        int pathcost = 1;\\n\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int row = delrow[k] + i, col = delcol[k] + j;\\n\\n            if(row >= 0 && row < n && col >= 0 && col < m  && grid[row][col] > grid[i][j])\\n                pathcost = (pathcost%mod + path(row, col, grid, dp)%mod) % mod;\\n        }\\n        return dp[i][j] = pathcost;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dp(grid.size(),vector<int>(grid[0].size(),-1));\\n        long long cnt = 0;\\n\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n                cnt = (cnt % mod + path(i, j, grid, dp) % mod) % mod;\\n        }\\n\\n        return (int)cnt % mod;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655586,
                "title": "clear-explanation-with-2-d-dynamic-programming-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf ```grid[row][col]``` is greater than ```grid[row\\xB11][col\\xB11]```, then the we can extend all the increasing paths ending on the neighbouring cell by 1 to include the current cell. We can do this for all cells in the grid and compute the sum to determine the answer. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst thing to note is that each cell on its own counts as a path of length 1. Next, as mentioned above, if a cell is greater than its neighbour, than all the paths ending on the neighbouring cell can be extended by 1 to include the current cell. This hints at a dynamic programming solution. To start, we can create a 2D array ```dp``` which will store the number of strictly increasing paths ending at each position of the grid. \\n\\nWe know that the number of paths ending on a cell is related to the number of paths ending on the cells neighbours. However, we need to figure out how we should traverse the grid to calculate ```dp[row][col]```. If we start from the largest element in the grid \\u2014 let us assume that it is at index ```(len(grid)-1, len(grid[0])-1)```, then we can extend the paths ending at ```(len(grid)-2, len(grid[0])-1)``` and ```(len(grid)-1, len(grid[0])-2)``` to include the current cell. Now, when we move on the calculate ```dp[len(grid)-2][len(grid[0]) - 1]```, we might have to recompute ```dp[len(grid)-1][len(grid[0]) - 1]``` again if the current cell count is changed. Therefore it makes sense to traverse the cells in increasing order since that defines a concrete starting point as when we get to a particular cell in the grid, if any of its neighbours are smaller than the current cell, then we will already know the final number of paths ending on the neighbour and therefore we can avoid the aforementioned recomputation.\\n\\nKnowing this, let us sort the grid by its values and keep track of the indices as well. We can store this in an array ```cells```. Now, we iterate over all the cells in this array and if the neighbouring cell is within the range of the board and has a greater value, we can increment the neighbours path count by the current cells path count. \\n\\nAfter we have constructed our dp array, we can return the sum of all the path counts in the array to determine the final answer. \\n\\n# Complexity\\n- Time complexity: $O(n \\\\cdot m \\\\cdot \\\\log(m \\\\cdot n))$ where $n$ is the number of rows in the grid and $m$ is the number of columns in the grid.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n \\\\cdot m)$ where $n$ is the number of rows in the grid and $m$ is the number of columns in the grid.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Returns the number of strictly increasing paths in a grid.\\n\\n        Args:\\n            grid: List[List[int]] = Input grid\\n        \\n        Returns:\\n            count: int = Number of stricly increasing paths in a grid.\\n        \"\"\"\\n\\n        # Store the length and width of a grid for easy access \\n        rows, columns = len(grid), len(grid[0])\\n        # Store the mod value\\n        mod = 10 ** 9 + 7 \\n\\n        # Initialize a 2D array which holds the number of strictly increasing paths\\n        # ending on grid[row][col]\\n        dp = [[1 for value in row] for row in grid]\\n\\n        # Sort the cells in increasing order by value while keeping a track of their positions\\n        cells = [[grid[i][j], i, j] for i in range(rows) for j in range(columns)]\\n        cells.sort(key=lambda x: x[0])\\n\\n        # Iterate over all the cells in the grid\\n        for val, row, col in cells: \\n            # For each neighbour, first check if it is within range of the grid\\n            # and then check if the neighbour has a greater value. If it does, \\n            # then the number of increasing paths ending on the neighbouring cell\\n            # can be incremented by the number of increasing paths ending on the current\\n            # cell\\n\\n            if row + 1 < rows:\\n                if grid[row+1][col] > val:\\n                    dp[row+1][col] += dp[row][col] \\n\\n\\n            if row - 1 >= 0:\\n                if grid[row-1][col] > val:\\n                    dp[row-1][col] += dp[row][col] \\n\\n\\n            if col + 1 < columns:\\n                if grid[row][col+1] > val:\\n                    dp[row][col+1] += dp[row][col] \\n\\n            if col - 1 >= 0:\\n                if grid[row][col-1] > val:\\n                    dp[row][col-1] += dp[row][col] \\n\\n        # Initialize the ouput to 0\\n        count = 0 \\n\\n        # Sum all the paths in the dp array \\n        for row in range(rows):\\n            for col in range(columns):\\n                count += dp[row][col]\\n\\n        # Return the count modulo 10 ** 9 + 7\\n        return count % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```grid[row][col]```\n```grid[row\\xB11][col\\xB11]```\n```dp```\n```dp[row][col]```\n```(len(grid)-1, len(grid[0])-1)```\n```(len(grid)-2, len(grid[0])-1)```\n```(len(grid)-1, len(grid[0])-2)```\n```dp[len(grid)-2][len(grid[0]) - 1]```\n```dp[len(grid)-1][len(grid[0]) - 1]```\n```cells```\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        Returns the number of strictly increasing paths in a grid.\\n\\n        Args:\\n            grid: List[List[int]] = Input grid\\n        \\n        Returns:\\n            count: int = Number of stricly increasing paths in a grid.\\n        \"\"\"\\n\\n        # Store the length and width of a grid for easy access \\n        rows, columns = len(grid), len(grid[0])\\n        # Store the mod value\\n        mod = 10 ** 9 + 7 \\n\\n        # Initialize a 2D array which holds the number of strictly increasing paths\\n        # ending on grid[row][col]\\n        dp = [[1 for value in row] for row in grid]\\n\\n        # Sort the cells in increasing order by value while keeping a track of their positions\\n        cells = [[grid[i][j], i, j] for i in range(rows) for j in range(columns)]\\n        cells.sort(key=lambda x: x[0])\\n\\n        # Iterate over all the cells in the grid\\n        for val, row, col in cells: \\n            # For each neighbour, first check if it is within range of the grid\\n            # and then check if the neighbour has a greater value. If it does, \\n            # then the number of increasing paths ending on the neighbouring cell\\n            # can be incremented by the number of increasing paths ending on the current\\n            # cell\\n\\n            if row + 1 < rows:\\n                if grid[row+1][col] > val:\\n                    dp[row+1][col] += dp[row][col] \\n\\n\\n            if row - 1 >= 0:\\n                if grid[row-1][col] > val:\\n                    dp[row-1][col] += dp[row][col] \\n\\n\\n            if col + 1 < columns:\\n                if grid[row][col+1] > val:\\n                    dp[row][col+1] += dp[row][col] \\n\\n            if col - 1 >= 0:\\n                if grid[row][col-1] > val:\\n                    dp[row][col-1] += dp[row][col] \\n\\n        # Initialize the ouput to 0\\n        count = 0 \\n\\n        # Sum all the paths in the dp array \\n        for row in range(rows):\\n            for col in range(columns):\\n                count += dp[row][col]\\n\\n        # Return the count modulo 10 ** 9 + 7\\n        return count % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653887,
                "title": "solution-using-d-f-s-and-dp-memoization",
                "content": "# Intuition\\nCertainly! Here\\'s an intuitive explanation of the approach used in the code:\\n\\nThe problem is to count the number of paths in a given grid where each path consists of cells with increasing values. We can only move to adjacent cells (up, down, left, or right), and we can only move to a cell if its value is greater than the current cell.\\n\\nTo count the paths, we can use a Depth-First Search (DFS) approach. We start from each cell in the grid and explore all possible paths from that cell using DFS. \\n\\nThe DFS function (`dfs`) takes the current cell\\'s coordinates, the grid, a visited array (`vis`), and a memoization array (`dp`) as parameters. The visited array is used to keep track of cells that have been visited during the DFS, while the memoization array is used to store the results of already computed cells to avoid redundant calculations.\\n\\nInside the `dfs` function, we perform the following steps:\\n1. Check if the result for the current cell `(row, col)` is already calculated and stored in the `dp` array. If so, we directly return the result from the `dp` array. This step helps in memoizing previously computed results and avoids recalculating them.\\n\\n2. Mark the current cell `(row, col)` as visited by setting `vis[row][col] = 1`.\\n\\n3. Initialize a count variable `cnt` to keep track of the number of valid paths from the current cell.\\n\\n4. Iterate through all possible directions (up, down, left, right) from the current cell. For each valid neighboring cell `(nrow, ncol)`, we recursively call the `dfs` function on that cell and add the result to `cnt`. The condition for moving to a neighboring cell is that it should be within the grid boundaries, have a higher value than the current cell, and should not be visited.\\n\\n5. After exploring all possible directions, mark the current cell `(row, col)` as not visited by setting `vis[row][col] = 0`.\\n\\n6. Store the count `cnt` in the `dp` array for the current cell `(row, col)`.\\n\\n7. Return the count `cnt`.\\n\\nIn the `countPaths` function, we iterate through all cells in the grid using nested loops. For each cell `(i, j)`, we add the result of the `dfs` function starting from that cell to the `ans` variable. Finally, we return the value of `ans` modulo `mod` as the final result.\\n\\nThe DFS approach explores all possible paths from each cell, taking into account the increasing value constraint. The memoization technique ensures that we avoid redundant calculations by storing and reusing the results of already computed cells, thereby optimizing the solution.\\n\\nI hope this provides a clear intuition behind the approach used in the code! Let me know if you have any further questions.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSure! The approach used in the corrected code is a depth-first search (DFS) with memoization to count the number of paths in the given grid.\\n\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a constant `mod` with the value `1e9 + 7` to handle modulo arithmetic.\\n\\n2. Implement the `dfs` function, which takes the current `row` and `col` coordinates, the `grid`, a `vis` array to keep track of visited cells, and a `dp` array for memoization.\\n\\n3. Inside the `dfs` function:\\n   - Check if the result for the current cell `(row, col)` is already calculated and stored in the `dp` array. If so, return the result.\\n   - Mark the current cell `(row, col)` as visited by setting `vis[row][col] = 1`.\\n   - Initialize a count variable `cnt` to keep track of the number of valid paths from the current cell.\\n   - Define the possible directions to move: up, down, left, and right, using arrays `drow` and `dcol`.\\n   - Iterate through all possible directions and check if the neighboring cell `(nrow, ncol)` is within the grid boundaries, has a higher value than the current cell, and is not visited.\\n   - If the conditions are satisfied, recursively call the `dfs` function on the neighboring cell `(nrow, ncol)` and add the result to `cnt`.\\n   - After exploring all possible directions, mark the current cell `(row, col)` as not visited by setting `vis[row][col] = 0`.\\n   - Store the count `cnt` in the `dp` array for the current cell `(row, col)`.\\n   - Return the count `cnt`.\\n\\n4. Implement the `countPaths` function, which takes the input `grid`.\\n\\n5. Inside the `countPaths` function:\\n   - Get the number of rows and columns of the `grid` using `grid.size()` and `grid[0].size()`.\\n   - Initialize a 2D `dp` array of size `(n x m)` with all elements set to `-1`. This array will be used for memoization.\\n   - Initialize a 2D `vis` array of the same size, filled with zeros to keep track of visited cells during the DFS.\\n   - Initialize a variable `ans` to store the final count of paths.\\n   - Iterate through all cells in the `grid` using nested loops:\\n     - For each cell `(i, j)`, add the result of the `dfs` function starting from that cell to `ans`.\\n   - Return the value of `ans` modulo `mod` as the final result.\\n\\nThe DFS with memoization approach ensures that each cell is visited and processed only once, preventing redundant calculations and improving the overall efficiency of the algorithm.\\n\\nI hope this explanation helps clarify the approach used in the code! Let me know if you have any further questions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int mod=1e9+7;\\n      int dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&dp){\\n          if(dp[row][col]!=-1){\\n              return dp[row][col];\\n          }\\n         \\n           long long cnt=1;\\n          int drow[]={-1,1,0,0};\\n          int dcol[]={0,0,1,-1};\\n          for(int i=0;i<4;i++){\\n              int nrow=row+drow[i];\\n              int ncol=col+dcol[i];\\n              if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[row][col]<grid[nrow][ncol] ){\\n                  cnt=(cnt+dfs(nrow,ncol,grid,dp))%mod; \\n              }\\n          }\\n          \\n          return dp[row][col]=(int)cnt%mod;\\n      }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n      \\n       long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans+=(dfs(i,j,grid,dp))%mod;\\n            }\\n        }\\n        return static_cast<int>(ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int mod=1e9+7;\\n      int dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&dp){\\n          if(dp[row][col]!=-1){\\n              return dp[row][col];\\n          }\\n         \\n           long long cnt=1;\\n          int drow[]={-1,1,0,0};\\n          int dcol[]={0,0,1,-1};\\n          for(int i=0;i<4;i++){\\n              int nrow=row+drow[i];\\n              int ncol=col+dcol[i];\\n              if(nrow>=0 && nrow<grid.size() && ncol>=0 && ncol<grid[0].size() && grid[row][col]<grid[nrow][ncol] ){\\n                  cnt=(cnt+dfs(nrow,ncol,grid,dp))%mod; \\n              }\\n          }\\n          \\n          return dp[row][col]=(int)cnt%mod;\\n      }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n      \\n       long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans+=(dfs(i,j,grid,dp))%mod;\\n            }\\n        }\\n        return static_cast<int>(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653585,
                "title": "c-solution-using-sorting-dynamic-programming",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> direc={{1,0},{-1,0},{0,1},{0,-1}};\\n    int mod=1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n    \\n    vector<vector<int>>dp(m,vector<int>(n,1));\\n\\n    vector<pair<int,pair<int, int>>> cellList(m * n);\\n\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n          int index=i+j*m;\\n\\n          cellList[index]={grid[i][j],{i,j}};\\n        }\\n    }\\n\\n    sort(cellList.begin(),cellList.end());\\n\\n    //Iterate over each sorted cells for each cell of grid[i][j]\\n\\n     for(auto cell:cellList){\\n         \\n         int i=cell.second.first;\\n         int j=cell.second.second;\\n\\n\\n     // Check its four neighbor cells, if a neighbor cell grid[currI][currJ] has a\\n    // larger value, increment dp[currI][currJ] by dp[i][j]\\n\\n    for(auto d:direc){\\n        int currI=i+d[0];\\n        int currJ=j+d[1];\\n\\n        if(currI>=0 && currI<m && currJ>=0 && currJ<n && grid[currI][currJ]>grid[i][j]){\\n            dp[currI][currJ]+=dp[i][j];\\n            dp[currI][currJ]%=mod;\\n        }\\n    }\\n     }\\n     // Sum over dp[i][j].\\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                res += dp[i][j];\\n                res %= mod;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> direc={{1,0},{-1,0},{0,1},{0,-1}};\\n    int mod=1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n    \\n    vector<vector<int>>dp(m,vector<int>(n,1));\\n\\n    vector<pair<int,pair<int, int>>> cellList(m * n);\\n\\n    for(int i=0;i<m;i++){\\n        for(int j=0;j<n;j++){\\n          int index=i+j*m;\\n\\n          cellList[index]={grid[i][j],{i,j}};\\n        }\\n    }\\n\\n    sort(cellList.begin(),cellList.end());\\n\\n    //Iterate over each sorted cells for each cell of grid[i][j]\\n\\n     for(auto cell:cellList){\\n         \\n         int i=cell.second.first;\\n         int j=cell.second.second;\\n\\n\\n     // Check its four neighbor cells, if a neighbor cell grid[currI][currJ] has a\\n    // larger value, increment dp[currI][currJ] by dp[i][j]\\n\\n    for(auto d:direc){\\n        int currI=i+d[0];\\n        int currJ=j+d[1];\\n\\n        if(currI>=0 && currI<m && currJ>=0 && currJ<n && grid[currI][currJ]>grid[i][j]){\\n            dp[currI][currJ]+=dp[i][j];\\n            dp[currI][currJ]%=mod;\\n        }\\n    }\\n     }\\n     // Sum over dp[i][j].\\n        int res = 0;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                res += dp[i][j];\\n                res %= mod;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652822,
                "title": "dfs-java-c-easy-soln-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom every cell we have 4 option cells to go in which no out of boundary cell must be visited and no cell less than previous value must be visited.\\n\\n# Complexity\\n- Time complexity:$$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\n# Code\\n```\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n    public int countPaths(int[][] grid) {\\n        int ans=0;\\n        int dp[][]=new int[grid.length][grid[0].length];\\n        for( int row[]:dp)\\n        Arrays.fill(row,-1);\\n         for(int i=0;i<grid.length;i++)\\n            for( int j=0;j<grid[0].length;j++)\\n                ans=(ans+ dfs(i,j,grid,-1,dp))%mod;\\n                \\n         return ans;       \\n    }\\n    int dfs(int i,int j, int [][]grid,int prev, int dp[][]){\\n        \\n        if(i>=grid.length||i<0|| j>=grid[0].length||j<0) return 0;\\n        if(prev>=grid[i][j]) return 0;\\n\\n         if(dp[i][j]==-1){\\n         dp[i][j]= dfs( i+1, j, grid, grid[i][j],dp)%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i, j+1, grid, grid[i][j],dp))%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i-1, j, grid, grid[i][j],dp))%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i, j-1, grid, grid[i][j],dp)+1)%mod;\\n         }\\n         return dp[i][j];\\n\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int) Math.pow(10, 9) + 7;\\n    public int countPaths(int[][] grid) {\\n        int ans=0;\\n        int dp[][]=new int[grid.length][grid[0].length];\\n        for( int row[]:dp)\\n        Arrays.fill(row,-1);\\n         for(int i=0;i<grid.length;i++)\\n            for( int j=0;j<grid[0].length;j++)\\n                ans=(ans+ dfs(i,j,grid,-1,dp))%mod;\\n                \\n         return ans;       \\n    }\\n    int dfs(int i,int j, int [][]grid,int prev, int dp[][]){\\n        \\n        if(i>=grid.length||i<0|| j>=grid[0].length||j<0) return 0;\\n        if(prev>=grid[i][j]) return 0;\\n\\n         if(dp[i][j]==-1){\\n         dp[i][j]= dfs( i+1, j, grid, grid[i][j],dp)%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i, j+1, grid, grid[i][j],dp))%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i-1, j, grid, grid[i][j],dp))%mod;\\n         dp[i][j]=(dp[i][j]+dfs( i, j-1, grid, grid[i][j],dp)+1)%mod;\\n         }\\n         return dp[i][j];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652755,
                "title": "ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nThis is similar to Longest Increasing Path in a Matrix and can be solved with memoization.\\n\\n# Approach\\n1. Create class variables for dirs, mod, grid, m, n, and memo.  (Memo must be an array here -- an object is too slow.)\\n2. Find the max path from each starting point with a helper function and add them together.\\n3. Return the total mod 10**9+7\\n\\nHelper function:\\n1. Return stored value if it\\'s already been checked.\\n2. Start each path at 1.  Check if their are paths in each direction (direction keeps you inside the grid and the the value is increasing): if so, add it to total.\\n3. Memoize total, use mod for space, and return.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where *n* is the total number of cells.  ($$O(m * n)$$ if you prefer.)\\n\\n- Space complexity:\\n$$O(n)$$ or $$O(m * n)$$ (same as time).\\n\\n# Code\\n```\\n@dirs = [[1,0],[0,1],[-1,0],[0,-1]]\\n@mod = 1000000007\\n\\ndef count_paths(grid)\\n    @grid = grid\\n    @m,@n = grid.length, grid[0].length\\n    @memo = Array.new(@m) { Array.new(@n,nil) }\\n\\n    total = 0\\n    (0...@m).each do |i|\\n        (0...@n).each do |j|\\n            total += max_path(i,j)\\n        end\\n    end\\n\\n    total % @mod\\nend\\n\\ndef max_path(i,j)\\n    return @memo[i][j] if @memo[i][j]\\n\\n    total = 1\\n    @dirs.each do |dir|\\n        a,b = dir\\n        x,y = a+i,b+j\\n        if (0...@m).cover?(x) && (0...@n).cover?(y) && @grid[x][y] > @grid[i][j]\\n            total += max_path(x,y)\\n        end\\n    end\\n\\n    @memo[i][j] = total % @mod\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@dirs = [[1,0],[0,1],[-1,0],[0,-1]]\\n@mod = 1000000007\\n\\ndef count_paths(grid)\\n    @grid = grid\\n    @m,@n = grid.length, grid[0].length\\n    @memo = Array.new(@m) { Array.new(@n,nil) }\\n\\n    total = 0\\n    (0...@m).each do |i|\\n        (0...@n).each do |j|\\n            total += max_path(i,j)\\n        end\\n    end\\n\\n    total % @mod\\nend\\n\\ndef max_path(i,j)\\n    return @memo[i][j] if @memo[i][j]\\n\\n    total = 1\\n    @dirs.each do |dir|\\n        a,b = dir\\n        x,y = a+i,b+j\\n        if (0...@m).cover?(x) && (0...@n).cover?(y) && @grid[x][y] > @grid[i][j]\\n            total += max_path(x,y)\\n        end\\n    end\\n\\n    @memo[i][j] = total % @mod\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3652699,
                "title": "java-easy-to-understand-dp-o-n-m-98-4-beats",
                "content": "# Intuition\\nDon\\'t think about single then double then triple paths and so on.\\nwhat if we have a 2d grid that stores total paths ending upto that index? yes u can do that have a look into solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\napproach - consider a 2d array where at each cell is the number of paths ending at that cell, coming from 4 direction which are samller numbers than the cell, like in 4 path can come from 3, and 1 ,\\nnow for numbers that doesn\\'t have any number smaller then them on any of the 4 directions , has value = 1. why because paths ending to them are the single one and total path at 3 are 2(1 from 1->3 and 1 is 3->3(itself)) so total paths ending at 4 are pathsAT[3] + pathsAT[1] = 2+1 +1 = 3.\\n\\nbut wait we missed something don\\'t we? additonal 1 {path 4->4} so pathsAt[4] = 3+1 = 4\\nNow \\ntotal paths are : pathsAt[0][0] +Pathat[0][1] +pathsAt[1][0] PathsAt[1][1] = pathof(1) + pathsOf(1) + pathof(3) + pathsOf(4) = 1 +1+2 + 4 + 8 .\\nSo =>  for number having smaller numbers into any of the 4 direction has totalpaths = sum of those cells value which are smaller +1(single path originating and ending current cell), remembr u have to look into adjacent 4 cell only\\n\\nbut what if you have to goo deep to look for value?\\n\\n if any of them has value zero then go for other smaller ones to get value of those you will see that u r ending to that cell which doesn\\'t have any smaller in any 4 direction hance path ending at that cell is 1 now u can go back in recursive calls keep on updating paths for each cell u traversed so don\\'t have to come back looking for that cell again during loop in main method, hence TC will be O(n^2) coz u are accessing each cell aprx 1 time only, in loop if array already has value!= 0 then no need to call function for that.\\nApply this on more example you will get it more clearly\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length, m= grid[0].length  ;\\n        int[][] dp = new int[n][m];\\n        long ans= 0;\\n        for( int i= 0; i < n; i++)\\n        {\\n            for( int j= 0; j < m; j++)\\n            {\\n                if( dp[i][j]== 0) \\n                {\\n                   findPathsAt(i,j, dp, grid);\\n                }\\n                // to sum all values resolved.\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n    void findPathsAt(int i , int j, int[][] dp , int[][] grid)\\n    {\\n        long totalpaths= 0, num = grid[i][j];\\n        if( i > 0 && grid[i-1][j] < num)\\n        {\\n            if( dp[i-1][j] == 0)  findPathsAt(i-1, j, dp , grid);\\n            totalpaths+= dp[i-1][j];\\n        }\\n        if( i < dp.length -1 && grid[i+1][j] < num)\\n        {\\n            if( dp[i+1][j] == 0)  findPathsAt(i+1,j, dp , grid);\\n            totalpaths+= dp[i+1][j];\\n        }\\n        if( j > 0 && grid[i][j-1] < num)\\n        {\\n            if( dp[i][j-1] == 0)  findPathsAt(i, j-1, dp , grid);\\n            totalpaths+= dp[i][j-1];\\n        }\\n        if( j < dp[0].length -1 && grid[i][j+1] < num)\\n        {\\n            if( dp[i][j+1] == 0)  findPathsAt(i,j+1, dp , grid);\\n            totalpaths+= dp[i][j+1];\\n        }\\n        dp[i][j] = (int)(totalpaths+1)%mod;\\n    }\\n}\\n```\\n\\nplease UPVOTE guys IF you liked it and comment if you have any doubts. Thanks :) in advance\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    int mod = 1000000007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length, m= grid[0].length  ;\\n        int[][] dp = new int[n][m];\\n        long ans= 0;\\n        for( int i= 0; i < n; i++)\\n        {\\n            for( int j= 0; j < m; j++)\\n            {\\n                if( dp[i][j]== 0) \\n                {\\n                   findPathsAt(i,j, dp, grid);\\n                }\\n                // to sum all values resolved.\\n                ans = (ans+dp[i][j])%mod;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n    void findPathsAt(int i , int j, int[][] dp , int[][] grid)\\n    {\\n        long totalpaths= 0, num = grid[i][j];\\n        if( i > 0 && grid[i-1][j] < num)\\n        {\\n            if( dp[i-1][j] == 0)  findPathsAt(i-1, j, dp , grid);\\n            totalpaths+= dp[i-1][j];\\n        }\\n        if( i < dp.length -1 && grid[i+1][j] < num)\\n        {\\n            if( dp[i+1][j] == 0)  findPathsAt(i+1,j, dp , grid);\\n            totalpaths+= dp[i+1][j];\\n        }\\n        if( j > 0 && grid[i][j-1] < num)\\n        {\\n            if( dp[i][j-1] == 0)  findPathsAt(i, j-1, dp , grid);\\n            totalpaths+= dp[i][j-1];\\n        }\\n        if( j < dp[0].length -1 && grid[i][j+1] < num)\\n        {\\n            if( dp[i][j+1] == 0)  findPathsAt(i,j+1, dp , grid);\\n            totalpaths+= dp[i][j+1];\\n        }\\n        dp[i][j] = (int)(totalpaths+1)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652638,
                "title": "c-simple-dfs-with-memoization",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int CountPaths(int[][] grid) {\\n        int result = 0;\\n        cache = new int[grid.Length][];\\n        for(int i=0;i<grid.Length;i++)\\n            cache[i] = new int[grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n        {\\n            for(int j=0;j<grid[0].Length;j++)\\n                result = (result + DFS(i,j,grid)) % MOD;\\n        }\\n        return result;\\n    }\\n\\n    private int DFS(int i, int j, int[][] grid)\\n    {\\n        if(cache[i][j] != 0)\\n            return cache[i][j];\\n        \\n        int count = 1;\\n        foreach(var d in directions)\\n        {\\n            int p = i + d.x;\\n            int q = j + d.y;\\n            if(p >=0 && p < grid.Length && q >=0 && q < grid[0].Length && grid[p][q] < grid[i][j])\\n                count = (count + DFS(p,q,grid)) % MOD;\\n        }\\n        return cache[i][j] = count;\\n    }\\n    \\n    private int[][] cache;\\n    private List<(int x,int y)> directions = new(){\\n        (0,1),\\n        (1,0),\\n        (0,-1),\\n        (-1,0)\\n    };\\n    \\n    private int MOD = 1_000_000_007;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPaths(int[][] grid) {\\n        int result = 0;\\n        cache = new int[grid.Length][];\\n        for(int i=0;i<grid.Length;i++)\\n            cache[i] = new int[grid[0].Length];\\n        for(int i=0;i<grid.Length;i++)\\n        {\\n            for(int j=0;j<grid[0].Length;j++)\\n                result = (result + DFS(i,j,grid)) % MOD;\\n        }\\n        return result;\\n    }\\n\\n    private int DFS(int i, int j, int[][] grid)\\n    {\\n        if(cache[i][j] != 0)\\n            return cache[i][j];\\n        \\n        int count = 1;\\n        foreach(var d in directions)\\n        {\\n            int p = i + d.x;\\n            int q = j + d.y;\\n            if(p >=0 && p < grid.Length && q >=0 && q < grid[0].Length && grid[p][q] < grid[i][j])\\n                count = (count + DFS(p,q,grid)) % MOD;\\n        }\\n        return cache[i][j] = count;\\n    }\\n    \\n    private int[][] cache;\\n    private List<(int x,int y)> directions = new(){\\n        (0,1),\\n        (1,0),\\n        (0,-1),\\n        (-1,0)\\n    };\\n    \\n    private int MOD = 1_000_000_007;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652464,
                "title": "easy-c-greedy-and-dp-solution",
                "content": "\\n\\n## DP solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int n , m;\\n    vector<vector<int>> dp;\\n\\n    bool valid(int x, int y){\\n        return ((x >= 0) && (x < n) && (y >= 0) && (y < m));\\n    }\\n\\n    int back(int i, int j , vector<vector<int>> &grid){\\n\\n        if(!valid(i, j)) return 0;\\n        \\n        if(dp[i][j] != 1) return dp[i][j];\\n\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        for(int k = 0; k<4; k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(valid(x, y) && grid[x][y] < grid[i][j]){\\n                dp[i][j] = (dp[i][j] + back(x, y, grid))%mod;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        this->n = n;\\n        this->m = m;\\n\\n        dp.resize(n, vector<int> (m, 1));\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                ans = (ans + back(i, j, grid))%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n## Greedy Solution\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int> (m, 1));\\n\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        auto valid = [&](int x, int y) -> bool{\\n            return ((x >= 0) && (x < n) && (y >= 0) && (y < m));\\n        };\\n\\n        vector< pair<int, pair<int, int>> > v;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                v.push_back({grid[i][j], {i,j}});\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        for(auto it : v){\\n            int d = it.first;\\n            int i = it.second.first;\\n            int j = it.second.second;\\n            for(int k = 0; k<4; k++){\\n                int x = i + dx[k];\\n                int y = j + dy[k];\\n                if(valid(x, y) && grid[x][y] > grid[i][j]){\\n                    dp[x][y] = (dp[x][y] + dp[i][j])%mod;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                ans = (ans + dp[i][j])%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int n , m;\\n    vector<vector<int>> dp;\\n\\n    bool valid(int x, int y){\\n        return ((x >= 0) && (x < n) && (y >= 0) && (y < m));\\n    }\\n\\n    int back(int i, int j , vector<vector<int>> &grid){\\n\\n        if(!valid(i, j)) return 0;\\n        \\n        if(dp[i][j] != 1) return dp[i][j];\\n\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        for(int k = 0; k<4; k++){\\n            int x = i + dx[k];\\n            int y = j + dy[k];\\n            if(valid(x, y) && grid[x][y] < grid[i][j]){\\n                dp[i][j] = (dp[i][j] + back(x, y, grid))%mod;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        this->n = n;\\n        this->m = m;\\n\\n        dp.resize(n, vector<int> (m, 1));\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                ans = (ans + back(i, j, grid))%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n\\n        vector<vector<int>> dp(n, vector<int> (m, 1));\\n\\n        int dx[] = {0, 0, -1, 1};\\n        int dy[] = {1, -1, 0, 0};\\n\\n        auto valid = [&](int x, int y) -> bool{\\n            return ((x >= 0) && (x < n) && (y >= 0) && (y < m));\\n        };\\n\\n        vector< pair<int, pair<int, int>> > v;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                v.push_back({grid[i][j], {i,j}});\\n            }\\n        }\\n\\n        sort(v.begin(), v.end());\\n\\n        for(auto it : v){\\n            int d = it.first;\\n            int i = it.second.first;\\n            int j = it.second.second;\\n            for(int k = 0; k<4; k++){\\n                int x = i + dx[k];\\n                int y = j + dy[k];\\n                if(valid(x, y) && grid[x][y] > grid[i][j]){\\n                    dp[x][y] = (dp[x][y] + dp[i][j])%mod;\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j = 0; j<m; j++){\\n                ans = (ans + dp[i][j])%mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652365,
                "title": "easy-dfs-c-solution-recusrion-memo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dirx = {1,-1,0,0};\\n    vector<int> diry = {0,0,1,-1};\\n    int dp[1001][1001];\\n    int mod = 1e9+7;\\n    bool isSafe(int i, int j,vector<vector<int>>& grid) {\\n        return i < grid.size() and i >= 0 and j < grid[0].size() and j >= 0; \\n    }\\n    int solve(int i, int j,vector<vector<int>>& grid) {\\n\\n        // Find the number of paths ending at i, j\\n\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int result = 1;\\n        for(int k = 0; k < 4; k++) {\\n            int i_new = i + dirx[k];\\n            int j_new = j + diry[k];\\n            if(isSafe(i_new, j_new, grid) and grid[i][j] > grid[i_new][j_new]) {\\n                result = (result % mod + solve(i_new, j_new, grid) % mod) % mod;\\n            }\\n        }\\n        return dp[i][j] = result % mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n\\n        int ans = 0;\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n               ans = (ans % mod + solve(i,j,grid) % mod) % mod; \\n            }\\n        }\\n\\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dirx = {1,-1,0,0};\\n    vector<int> diry = {0,0,1,-1};\\n    int dp[1001][1001];\\n    int mod = 1e9+7;\\n    bool isSafe(int i, int j,vector<vector<int>>& grid) {\\n        return i < grid.size() and i >= 0 and j < grid[0].size() and j >= 0; \\n    }\\n    int solve(int i, int j,vector<vector<int>>& grid) {\\n\\n        // Find the number of paths ending at i, j\\n\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int result = 1;\\n        for(int k = 0; k < 4; k++) {\\n            int i_new = i + dirx[k];\\n            int j_new = j + diry[k];\\n            if(isSafe(i_new, j_new, grid) and grid[i][j] > grid[i_new][j_new]) {\\n                result = (result % mod + solve(i_new, j_new, grid) % mod) % mod;\\n            }\\n        }\\n        return dp[i][j] = result % mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n\\n        int ans = 0;\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < grid.size(); i++) {\\n            for(int j = 0; j < grid[0].size(); j++) {\\n               ans = (ans % mod + solve(i,j,grid) % mod) % mod; \\n            }\\n        }\\n\\n        return ans % mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652259,
                "title": "c-dfs-memoization",
                "content": "# Intuition\\n###### Same as Question no. **329** :- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/\\n\\n\\n###### Just you have to store all the path (not only **maximum**)\\n\\n\\n###### checkout **question no.329** solution:- https://leetcode.com/problems/longest-increasing-path-in-a-matrix/solutions/3652237/c-dfs-memoization/\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int mod = 1e9+7;\\n    int solve(vector<vector<int>>& mat,vector<vector<int>>& dp, int i, int j,int prev)\\n    {\\n        // r and c is the size of matrix \\n        // i and j is the current indices....\\n        if(i < 0 || i == r || j < 0 || j == c || mat[i][j] <= prev)\\n            return 0;\\n         \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int ans = 1;\\n        ans = (ans%mod + solve(mat, dp, i + 1, j, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i - 1, j, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i, j + 1, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i, j - 1, mat[i][j]))%mod;\\n        \\n        dp[i][j] = ans;\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid)\\n    {\\n        r = grid.size();\\n        c = grid[0].size();\\n\\n        vector<vector<int>> dp(r, vector<int>(c,-1));\\n\\n        int numberOfPath = 0;\\n        for(int i = 0; i < dp.size(); i++)\\n        {\\n            for(int j = 0; j < dp[0].size(); j++)\\n            {\\n                numberOfPath = ((numberOfPath)%mod + (solve(grid, dp, i, j, -1)%mod))%mod;\\n            }\\n        }\\n        return numberOfPath%mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int mod = 1e9+7;\\n    int solve(vector<vector<int>>& mat,vector<vector<int>>& dp, int i, int j,int prev)\\n    {\\n        // r and c is the size of matrix \\n        // i and j is the current indices....\\n        if(i < 0 || i == r || j < 0 || j == c || mat[i][j] <= prev)\\n            return 0;\\n         \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int ans = 1;\\n        ans = (ans%mod + solve(mat, dp, i + 1, j, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i - 1, j, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i, j + 1, mat[i][j]))%mod;\\n        ans = (ans%mod + solve(mat, dp, i, j - 1, mat[i][j]))%mod;\\n        \\n        dp[i][j] = ans;\\n        return dp[i][j];\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid)\\n    {\\n        r = grid.size();\\n        c = grid[0].size();\\n\\n        vector<vector<int>> dp(r, vector<int>(c,-1));\\n\\n        int numberOfPath = 0;\\n        for(int i = 0; i < dp.size(); i++)\\n        {\\n            for(int j = 0; j < dp[0].size(); j++)\\n            {\\n                numberOfPath = ((numberOfPath)%mod + (solve(grid, dp, i, j, -1)%mod))%mod;\\n            }\\n        }\\n        return numberOfPath%mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652200,
                "title": "dp-approach-to-solve",
                "content": "# Intuition\\nThe problem asks us to find the number of strictly increasing paths in a matrix such that we can start from any cell and end at any cell. We can use dynamic programming to solve this problem. We can start from each cell of the matrix and recursively move in all four directions to find all the strictly increasing paths starting from that cell. We can use memoization to avoid recomputing the same subproblem multiple times.\\n# Approach\\nThe given code implements the above approach using a recursive DFS function and memoization. The DFS function takes the current cell (i,j) and the size of the matrix (n,m) as input. It first checks if we have already computed the number of strictly increasing paths for the current cell (i,j) using memoization. If yes, it returns the precomputed value. Otherwise, it recursively moves in all four directions to find all the strictly increasing paths starting from the current cell. It checks if the adjacent cell is valid and strictly greater than the current cell. If yes, it adds the number of strictly increasing paths starting from the adjacent cell to the answer. It then stores the answer in the memoization table for future use.\\n\\nThe main function of the code initializes a memoization table of size n x m and iterates over all the cells of the matrix. For each cell, it calls the DFS function to find all the strictly increasing paths starting from that cell. Finally, it sums up all the values in the memoization table to get the total number of strictly increasing paths in the matrix.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) (n is max of either of dimension)\\n\\n- Space complexity:\\nO(n^2) (for Dp matrix)\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    long long DFS(vector<vector<int>>&grid,vector<vector<long long>>&dp,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int a[]={-1,1,0,0};\\n        int b[]={0,0,-1,1};\\n        long long ans=1;\\n        int mod=1e9+7;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+a[k];\\n            int y=j+b[k];\\n            if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]>grid[i][j])\\n            {if(dp[x][y]!=-1)\\n             {\\n                 ans=(ans+dp[x][y])%mod;\\n             }\\n             else\\n             {ans=(ans+DFS(grid,dp,x,y,n,m))%mod;\\n             \\n             }\\n\\n\\n            }\\n\\n        }\\n        return dp[i][j]=ans;\\n        \\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                int temp=DFS(grid,dp,i,j,n,m);\\n                }\\n            }\\n        }\\n        int mod=1e9+7;\\n        long long ans=0;\\n          for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {ans=(ans+dp[i][j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    long long DFS(vector<vector<int>>&grid,vector<vector<long long>>&dp,int i,int j,int n,int m)\\n    {\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int a[]={-1,1,0,0};\\n        int b[]={0,0,-1,1};\\n        long long ans=1;\\n        int mod=1e9+7;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+a[k];\\n            int y=j+b[k];\\n            if(x>=0&&x<n&&y>=0&&y<m&&grid[x][y]>grid[i][j])\\n            {if(dp[x][y]!=-1)\\n             {\\n                 ans=(ans+dp[x][y])%mod;\\n             }\\n             else\\n             {ans=(ans+DFS(grid,dp,x,y,n,m))%mod;\\n             \\n             }\\n\\n\\n            }\\n\\n        }\\n        return dp[i][j]=ans;\\n        \\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<long long>>dp(n,vector<long long>(m,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                int temp=DFS(grid,dp,i,j,n,m);\\n                }\\n            }\\n        }\\n        int mod=1e9+7;\\n        long long ans=0;\\n          for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {ans=(ans+dp[i][j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652158,
                "title": "dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<vector<int>> cache;\\n    bool check(int i,int j , int n, int m,vector<vector<int>>& g)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    int dfs(int i, int j,int n , int m , vector<vector<int>>& g)\\n    {\\n        if(!check(i,j,n,m,g))\\n            return 0;\\n        int ans = 1;\\n        if(cache[i][j]!=-1)\\n            return cache[i][j];\\n        if(check(i+1,j,n,m,g) && g[i][j]<g[i+1][j])\\n        {\\n            ans = ans%mod + dfs(i+1,j,n,m,g)%mod;\\n        }\\n        \\n        if(check(i-1,j,n,m,g) && g[i][j]<g[i-1][j])\\n        {\\n            ans = ans%mod+dfs(i-1,j,n,m,g)%mod;\\n        }\\n        \\n        if(check(i,j+1,n,m,g) && g[i][j]<g[i][j+1])\\n        {\\n            ans = ans%mod+dfs(i,j+1,n,m,g)%mod;\\n            \\n        }\\n        \\n        if(check(i,j-1,n,m,g) && g[i][j]<g[i][j-1])\\n        {\\n             ans = ans%mod + dfs(i,j-1,n,m,g)%mod;\\n            \\n        }\\n        \\n        return cache[i][j] = (ans%mod);\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        int ans;\\n        int res = 0;\\n        cache.resize(n+1,vector<int> (m+1,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans = dfs(i,j,n,m,g)%mod;\\n                res = (res%mod + ans%mod)%mod;     \\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<vector<int>> cache;\\n    bool check(int i,int j , int n, int m,vector<vector<int>>& g)\\n    {\\n        if(i>=n || j>=m || i<0 || j<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    int dfs(int i, int j,int n , int m , vector<vector<int>>& g)\\n    {\\n        if(!check(i,j,n,m,g))\\n            return 0;\\n        int ans = 1;\\n        if(cache[i][j]!=-1)\\n            return cache[i][j];\\n        if(check(i+1,j,n,m,g) && g[i][j]<g[i+1][j])\\n        {\\n            ans = ans%mod + dfs(i+1,j,n,m,g)%mod;\\n        }\\n        \\n        if(check(i-1,j,n,m,g) && g[i][j]<g[i-1][j])\\n        {\\n            ans = ans%mod+dfs(i-1,j,n,m,g)%mod;\\n        }\\n        \\n        if(check(i,j+1,n,m,g) && g[i][j]<g[i][j+1])\\n        {\\n            ans = ans%mod+dfs(i,j+1,n,m,g)%mod;\\n            \\n        }\\n        \\n        if(check(i,j-1,n,m,g) && g[i][j]<g[i][j-1])\\n        {\\n             ans = ans%mod + dfs(i,j-1,n,m,g)%mod;\\n            \\n        }\\n        \\n        return cache[i][j] = (ans%mod);\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& g) {\\n        \\n        int n = g.size();\\n        int m = g[0].size();\\n        int ans;\\n        int res = 0;\\n        cache.resize(n+1,vector<int> (m+1,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                ans = dfs(i,j,n,m,g)%mod;\\n                res = (res%mod + ans%mod)%mod;     \\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651949,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation-easy-to-understand",
                "content": "# Intuition\\nIn this problem, we are required to return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. The recurrsion can make some redundant calls. This hints towards Dynamic Programming.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe helper function recursively counts the number of valid paths starting from a given position (i, j) in the grid. It checks if the position is within the grid boundaries and if the current value is greater than the previous value. If not, it returns 0. Otherwise, it recursively calls itself for the four adjacent positions and stores the results in a dynamic programming matrix (dp).\\n\\nThe countPaths function iterates through the grid, calculating the number of valid paths starting from each position. It uses the helper function to compute the paths if needed and adds the results to the final count.\\n\\nThe solution uses dynamic programming to avoid redundant computations by storing and reusing results in the dp matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int helper(vector<vector<int>>& grid,int i,int j,vector<vector<int>>& dp,\\n    int previous){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or \\n        previous>=grid[i][j]) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int l=helper(grid,i-1,j,dp,grid[i][j]);\\n        int r=helper(grid,i+1,j,dp,grid[i][j]);\\n        int t=helper(grid,i,j-1,dp,grid[i][j]);\\n        int b=helper(grid,i,j+1,dp,grid[i][j]);\\n        dp[i][j]=(1+l+r+t+b)%mod;\\n        return dp[i][j];\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 and n==1){\\n            return 1;\\n        }\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==-1) res+=(helper(grid,i,j,dp,-1)%mod);\\n                else res=(res+dp[i][j])%mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int helper(vector<vector<int>>& grid,int i,int j,vector<vector<int>>& dp,\\n    int previous){\\n        if(i<0 or j<0 or i>=grid.size() or j>=grid[0].size() or \\n        previous>=grid[i][j]) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int l=helper(grid,i-1,j,dp,grid[i][j]);\\n        int r=helper(grid,i+1,j,dp,grid[i][j]);\\n        int t=helper(grid,i,j-1,dp,grid[i][j]);\\n        int b=helper(grid,i,j+1,dp,grid[i][j]);\\n        dp[i][j]=(1+l+r+t+b)%mod;\\n        return dp[i][j];\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        if(m==1 and n==1){\\n            return 1;\\n        }\\n        vector<vector<int>> dp(m,vector<int> (n,-1));\\n        int res=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==-1) res+=(helper(grid,i,j,dp,-1)%mod);\\n                else res=(res+dp[i][j])%mod;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651724,
                "title": "easy-c-beats-100-memoization-approach-explained",
                "content": "# Intuition\\nThe main intuition comes from all the grid path questions we have done yet, using backtracking. The only change was that we can go from any one cell to any cell, i.e. \\ngrid[i][j] -> grid[p][k]\\nwhere \\n1. i and p can be equal too, j and k can be equal too\\n2. In the path, every step must be increasing i.e. if we move from grid[x][y] to grid[r][s] in a single step then also :: grid[r][s] > grid[x][y]\\n\\n# Approach\\nThus we can just start from every cell once and keep counting \\nThis will cover the case of starting from any cell rather than just 0,0.\\n\\nNow coming to the path from a point x,y to any cell, we use basic recursion\\nWe can either move \\n>> up (x-1, y) \\n>> down (x+1, y)\\n>> left (x, y-1)\\n>> right (x, y+1)\\n\\nThe thing is we move only if :\\nup/down/left/right > current\\n\\nWe done need to keep track of whos visited or not, as we did this in normal grid questions because of the fact that we may get stuck infinitely between 2 blocks but here its not possible\\nAs if we moved from block \\'a\\' to \\'b\\' given \\'b\\'>\\'a\\', then we will never try to move back to \\'a\\' as \\'a\\'<\\'b\\'\\n\\nThus make a loop to move to different cells taking then as the start point and then for each starting point use a function based on recursion to get the number of paths.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int countPathsH(vector<vector<int>> &grid, int x, int y, vector<vector<int>>& dp)\\n{\\n    if(dp[x][y]!=-1){\\n        return dp[x][y];\\n    }\\n    int current = grid[x][y];\\n    int ans = 1;\\n    if (x > 0 && current < grid[x - 1][y])\\n    {\\n        ans += countPathsH(grid, x - 1, y, dp)%MOD;\\n    }\\n    if (x < grid.size() - 1 && current < grid[x + 1][y])\\n    {\\n        ans += countPathsH(grid, x + 1, y, dp)%MOD;\\n    }\\n    if (y < grid[0].size() - 1 && current < grid[x][y + 1])\\n    {\\n        ans += countPathsH(grid, x, y + 1, dp)%MOD;\\n    }\\n    if (y > 0 && current < grid[x][y - 1])\\n    {\\n        ans += countPathsH(grid, x, y - 1, dp)%MOD;\\n    }\\n\\n    dp[x][y] = ans%MOD;\\n    return dp[x][y]%MOD;\\n}\\n\\nint countPaths(vector<vector<int>> &grid)\\n{\\n    vector<vector<int>> dp (grid.size(), vector<int> (grid[0].size(), -1));\\n    int ans = 0;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        for (int j = 0; j < grid[0].size(); j++)\\n        {\\n            ans = ((ans)%MOD + (countPathsH(grid, i, j, dp))%MOD)%MOD;\\n        }\\n    }\\n    return ans%MOD;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int countPathsH(vector<vector<int>> &grid, int x, int y, vector<vector<int>>& dp)\\n{\\n    if(dp[x][y]!=-1){\\n        return dp[x][y];\\n    }\\n    int current = grid[x][y];\\n    int ans = 1;\\n    if (x > 0 && current < grid[x - 1][y])\\n    {\\n        ans += countPathsH(grid, x - 1, y, dp)%MOD;\\n    }\\n    if (x < grid.size() - 1 && current < grid[x + 1][y])\\n    {\\n        ans += countPathsH(grid, x + 1, y, dp)%MOD;\\n    }\\n    if (y < grid[0].size() - 1 && current < grid[x][y + 1])\\n    {\\n        ans += countPathsH(grid, x, y + 1, dp)%MOD;\\n    }\\n    if (y > 0 && current < grid[x][y - 1])\\n    {\\n        ans += countPathsH(grid, x, y - 1, dp)%MOD;\\n    }\\n\\n    dp[x][y] = ans%MOD;\\n    return dp[x][y]%MOD;\\n}\\n\\nint countPaths(vector<vector<int>> &grid)\\n{\\n    vector<vector<int>> dp (grid.size(), vector<int> (grid[0].size(), -1));\\n    int ans = 0;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        for (int j = 0; j < grid[0].size(); j++)\\n        {\\n            ans = ((ans)%MOD + (countPathsH(grid, i, j, dp))%MOD)%MOD;\\n        }\\n    }\\n    return ans%MOD;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651703,
                "title": "c-recursive-solution-to-dp-solution-easy-to-understand",
                "content": "# Intuition(why recursion)\\nWe need to return the total number of paths/ all the paths if any time problem is asking total number of paths, all the possible solution, think of recursion in that case.\\n\\n# Recursion- \\nProblem is saying you can start from any cell so start the call from every cell, then move to all 4- directions and see if increasing value is there. IF yes move in that direction.\\nin the last add up all the possible paths that you\\'re getting from the individual cells.\\n\\n# DP(Memoization)- \\nUse a dp table(m*n) and store the already solved subproblems\\' answer in that so that you can utilize it later.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int f(int i, int j, int prev, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //out of boundary and if path is not increasing I can\\'t make a possible path\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || prev>= grid[i][j])\\n            return 0;\\n\\n        //if I have answer, use that\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        //explore: go in all 4 direction to check increasing paths\\n        long long cnt = 1;\\n\\n        cnt += f(i+1, j, grid[i][j], grid, dp)% mod;\\n        cnt += f(i-1, j, grid[i][j], grid, dp) % mod;\\n        cnt += f(i, j+1, grid[i][j], grid, dp) % mod;\\n        cnt += f(i, j-1,  grid[i][j], grid, dp) % mod;\\n\\n        return dp[i][j] = cnt;\\n    }\\n\\npublic:\\n    int mod = 1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        long long cnt = 0, n= grid.size(), m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1)); //dp table\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                cnt += f(i, j, -1, grid, dp);\\n            }\\n        }\\n\\n        return cnt%mod;\\n    }\\n};\\n```\\n\\n# Full Explanation-\\n[https://youtu.be/3gF2vGbzvlw]()\\n\\n**Please upvote if it helps**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int f(int i, int j, int prev, vector<vector<int>> &grid, vector<vector<int>> &dp){\\n        //out of boundary and if path is not increasing I can\\'t make a possible path\\n        if(i<0 || j<0 || i>= grid.size() || j>= grid[0].size() || prev>= grid[i][j])\\n            return 0;\\n\\n        //if I have answer, use that\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        //explore: go in all 4 direction to check increasing paths\\n        long long cnt = 1;\\n\\n        cnt += f(i+1, j, grid[i][j], grid, dp)% mod;\\n        cnt += f(i-1, j, grid[i][j], grid, dp) % mod;\\n        cnt += f(i, j+1, grid[i][j], grid, dp) % mod;\\n        cnt += f(i, j-1,  grid[i][j], grid, dp) % mod;\\n\\n        return dp[i][j] = cnt;\\n    }\\n\\npublic:\\n    int mod = 1e9+7;\\n    int countPaths(vector<vector<int>>& grid) {\\n        long long cnt = 0, n= grid.size(), m= grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1)); //dp table\\n\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                cnt += f(i, j, -1, grid, dp);\\n            }\\n        }\\n\\n        return cnt%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651692,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\nSTEPS = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\nMOD = 10**9 + 7\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef count_paths(grid)\\n  @grid = grid\\n  @result_grid = Array.new(grid.size) {Array.new(grid.first.size, nil)}\\n  @max_row_index = grid.size - 1\\n  @max_col_index = grid.first.size - 1\\n  @total_result = 0\\n\\n  0.upto(@max_row_index) do |row_index|\\n    0.upto(@max_col_index) do |col_index|\\n      @total_result += check_cell(row_index, col_index, -Float::INFINITY)\\n    end\\n  end\\n  \\n  @total_result % MOD\\nend\\n\\ndef check_cell(row_index, col_index, previous)\\n  return 0 unless within_bounds?(row_index, col_index)\\n\\n  cell = @grid[row_index][col_index]\\n  return 0 unless cell > previous\\n\\n  return @result_grid[row_index][col_index] if @result_grid[row_index][col_index]\\n  \\n  result = STEPS.sum do |step_row, step_col|\\n    check_cell(row_index + step_row, col_index + step_col, cell)\\n  end + 1\\n\\n  @result_grid[row_index][col_index] = result % MOD\\nend\\n\\n\\ndef within_bounds?(row_index, col_index)\\n  row_index.between?(0, @max_row_index) && col_index.between?(0, @max_col_index)  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\nSTEPS = [[-1, 0], [1, 0], [0, -1], [0, 1]]\\nMOD = 10**9 + 7\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef count_paths(grid)\\n  @grid = grid\\n  @result_grid = Array.new(grid.size) {Array.new(grid.first.size, nil)}\\n  @max_row_index = grid.size - 1\\n  @max_col_index = grid.first.size - 1\\n  @total_result = 0\\n\\n  0.upto(@max_row_index) do |row_index|\\n    0.upto(@max_col_index) do |col_index|\\n      @total_result += check_cell(row_index, col_index, -Float::INFINITY)\\n    end\\n  end\\n  \\n  @total_result % MOD\\nend\\n\\ndef check_cell(row_index, col_index, previous)\\n  return 0 unless within_bounds?(row_index, col_index)\\n\\n  cell = @grid[row_index][col_index]\\n  return 0 unless cell > previous\\n\\n  return @result_grid[row_index][col_index] if @result_grid[row_index][col_index]\\n  \\n  result = STEPS.sum do |step_row, step_col|\\n    check_cell(row_index + step_row, col_index + step_col, cell)\\n  end + 1\\n\\n  @result_grid[row_index][col_index] = result % MOD\\nend\\n\\n\\ndef within_bounds?(row_index, col_index)\\n  row_index.between?(0, @max_row_index) && col_index.between?(0, @max_col_index)  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3651392,
                "title": "c-easiest-explanation-codestorywithmik-video",
                "content": "YouTube Video Link - [Number of Increasing Paths in a Grid](https://www.youtube.com/watch?v=s-dQjzykhVA)\\nMy Github Treasure - [Number of Increasing Paths in a Grid](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/DP/Number%20of%20Increasing%20Paths%20in%20a%20Grid.cpp)\\n\\n```\\n/*\\n    NOTE : This problem is similar to Leetcode-329.\\n           Leetcode-329 is a famous interview problem so this is \\n\\t\\t   kind of standard problem. That\\'s why I always say, \\n\\t\\t   don\\'t be afraid of new Hard Problems,these qns are standard and \\n\\t\\t   many other problems can be solved using the concept based on\\n\\t\\t   these problems.\\n*/\\n```\\n\\n```\\n//Approach-1 (Using simple DFS) - TLE\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    long long MOD = 1e9+7;\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        \\n        int answer = 1;\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            if(isSafe(i_, j_) && grid[i_][j_] < grid[i][j]) {\\n                answer = (answer + dfs(grid, i_, j_)) % MOD;\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                \\n                result = (result + dfs(grid, i, j)) % MOD;\\n                \\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (By Memoization of Approach-1 above) - Accepted -O(m*n)\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    int t[1001][1001];\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    long long MOD = 1e9+7;\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        int answer = 1;\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            if(isSafe(i_, j_) && grid[i_][j_] < grid[i][j]) {\\n                answer = (answer + dfs(grid, i_, j_)) % MOD;\\n            }\\n        }\\n        \\n        return t[i][j] = answer;\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                \\n                result = (result + dfs(grid, i, j)) % MOD;\\n                \\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\n\\n//Approach-3 (Using Dynamic Programming) - Coming Soon\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    NOTE : This problem is similar to Leetcode-329.\\n           Leetcode-329 is a famous interview problem so this is \\n\\t\\t   kind of standard problem. That\\'s why I always say, \\n\\t\\t   don\\'t be afraid of new Hard Problems,these qns are standard and \\n\\t\\t   many other problems can be solved using the concept based on\\n\\t\\t   these problems.\\n*/\\n```\n```\\n//Approach-1 (Using simple DFS) - TLE\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    long long MOD = 1e9+7;\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        \\n        int answer = 1;\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            if(isSafe(i_, j_) && grid[i_][j_] < grid[i][j]) {\\n                answer = (answer + dfs(grid, i_, j_)) % MOD;\\n            }\\n        }\\n        \\n        return answer;\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                \\n                result = (result + dfs(grid, i, j)) % MOD;\\n                \\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (By Memoization of Approach-1 above) - Accepted -O(m*n)\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>> directions = {\\n                {-1,0},\\n        {0,-1},         {0,1},\\n                {1, 0}\\n    };\\n    \\n    int t[1001][1001];\\n    \\n    bool isSafe(int i, int j) {\\n        return (i < m && i >= 0 && j < n && j >= 0);\\n    }\\n    \\n    long long MOD = 1e9+7;\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j) {\\n        \\n        if(t[i][j] != -1)\\n            return t[i][j];\\n        \\n        int answer = 1;\\n        \\n        for(auto &dir : directions) {\\n            int i_ = i + dir[0];\\n            int j_ = j + dir[1];\\n            \\n            if(isSafe(i_, j_) && grid[i_][j_] < grid[i][j]) {\\n                answer = (answer + dfs(grid, i_, j_)) % MOD;\\n            }\\n        }\\n        \\n        return t[i][j] = answer;\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int result = 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                \\n                result = (result + dfs(grid, i, j)) % MOD;\\n                \\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n\\n\\n//Approach-3 (Using Dynamic Programming) - Coming Soon\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651324,
                "title": "rust-bfs",
                "content": "```\\nimpl Solution {\\n    pub fn count_paths(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut values = vec![vec![-1; grid[0].len()]; grid.len()];\\n\\n        let n = grid.len() as i32;\\n        let m = grid[0].len() as i32;\\n        \\n        for i in 0..n {\\n            \\'outer: for j in 0..m {\\n                for (di, dj) in [(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                    if i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < m {\\n                        if grid[(i + di) as usize][(j + dj) as usize] < grid[i as usize][j as usize] {\\n                            continue \\'outer;\\n                        }\\n                    }\\n                }\\n                heap.push((Reverse(grid[i as usize][j as usize]), i, j));\\n                values[i as usize][j as usize] = 0;\\n            }\\n        }\\n\\n        let mut ret = 0;\\n        const M: i32 = 1_000_000_007;\\n        while let Some((_, i, j)) = heap.pop() {\\n            let mut tile_value = 1;\\n            for (di, dj) in [(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                if i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < m {\\n                    if grid[(i + di) as usize][(j + dj) as usize] < grid[i as usize][j as usize] {\\n                        tile_value = (values[(i + di) as usize][(j + dj) as usize] + tile_value) % M;\\n                    }\\n                    if values[(i + di) as usize][(j + dj) as usize] == -1 {\\n                        values[(i + di) as usize][(j + dj) as usize] = 0;\\n                        heap.push((Reverse(grid[(i + di) as usize][(j + dj) as usize]), i + di, j + dj));\\n                    }\\n                }\\n            }\\n            values[i as usize][j as usize] = tile_value;\\n            ret = (ret + tile_value) % M;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_paths(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut values = vec![vec![-1; grid[0].len()]; grid.len()];\\n\\n        let n = grid.len() as i32;\\n        let m = grid[0].len() as i32;\\n        \\n        for i in 0..n {\\n            \\'outer: for j in 0..m {\\n                for (di, dj) in [(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                    if i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < m {\\n                        if grid[(i + di) as usize][(j + dj) as usize] < grid[i as usize][j as usize] {\\n                            continue \\'outer;\\n                        }\\n                    }\\n                }\\n                heap.push((Reverse(grid[i as usize][j as usize]), i, j));\\n                values[i as usize][j as usize] = 0;\\n            }\\n        }\\n\\n        let mut ret = 0;\\n        const M: i32 = 1_000_000_007;\\n        while let Some((_, i, j)) = heap.pop() {\\n            let mut tile_value = 1;\\n            for (di, dj) in [(-1, 0), (0, 1), (1, 0), (0, -1)] {\\n                if i + di >= 0 && i + di < n && j + dj >= 0 && j + dj < m {\\n                    if grid[(i + di) as usize][(j + dj) as usize] < grid[i as usize][j as usize] {\\n                        tile_value = (values[(i + di) as usize][(j + dj) as usize] + tile_value) % M;\\n                    }\\n                    if values[(i + di) as usize][(j + dj) as usize] == -1 {\\n                        values[(i + di) as usize][(j + dj) as usize] = 0;\\n                        heap.push((Reverse(grid[(i + di) as usize][(j + dj) as usize]), i + di, j + dj));\\n                    }\\n                }\\n            }\\n            values[i as usize][j as usize] = tile_value;\\n            ret = (ret + tile_value) % M;\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651205,
                "title": "simple-dfs-dp-memoization-ii-clean-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimply check all possible paths from every possible grid location.\\nbut for solving it without TLE we need to memoize it....\\nHAPPY CODING....:)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- run loops (2 nested loop) to iterate over every point in grid and take that point as a source node and check from it for valid paths and store them in ans.\\n- to check every valid path we need to perform DFS.\\n- also need to memoize it in in 2D DP to avoid TLE.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//-------------------------------memoization---------------------------------\\nclass Solution {\\npublic:\\n    int dx[4] = {1, 0,-1,0};\\n    int dy[4] = {0,-1, 0,1};\\n    int check(int &i,int &j,int cnt_row,int cnt_col){\\n        //check for index\\'s boundary overflow\\n        return (i>=0 && j>=0 && i<cnt_row && j<cnt_col);\\n    }\\n    int dfs_memo(int &src_i,int &src_j,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        int ans = 0;\\n        if(dp[src_i][src_j]!=-1) return dp[src_i][src_j];\\n        for( int i=0;i<4;i++){ //check for path in all valid 4 directions\\n            int new_i = src_i+dx[i];\\n            int new_j = src_j+dy[i];\\n            if(check(new_i,new_j,grid.size(),grid[0].size()) &&  grid[new_i][new_j] > grid[src_i][src_j]) {\\n                ans = (ans + (1 + dfs_memo(new_i,new_j,grid,dp)))%1000000007;\\n            }\\n        }\\n        return dp[src_i][src_j] = ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int source;\\n        long long ans =0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        for( int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = (ans + dfs_memo(i,j,grid,dp))%1000000007 ;\\n            }\\n        }\\n        return (ans + m*n)%1000000007;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n//-------------------------------memoization---------------------------------\\nclass Solution {\\npublic:\\n    int dx[4] = {1, 0,-1,0};\\n    int dy[4] = {0,-1, 0,1};\\n    int check(int &i,int &j,int cnt_row,int cnt_col){\\n        //check for index\\'s boundary overflow\\n        return (i>=0 && j>=0 && i<cnt_row && j<cnt_col);\\n    }\\n    int dfs_memo(int &src_i,int &src_j,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        int ans = 0;\\n        if(dp[src_i][src_j]!=-1) return dp[src_i][src_j];\\n        for( int i=0;i<4;i++){ //check for path in all valid 4 directions\\n            int new_i = src_i+dx[i];\\n            int new_j = src_j+dy[i];\\n            if(check(new_i,new_j,grid.size(),grid[0].size()) &&  grid[new_i][new_j] > grid[src_i][src_j]) {\\n                ans = (ans + (1 + dfs_memo(new_i,new_j,grid,dp)))%1000000007;\\n            }\\n        }\\n        return dp[src_i][src_j] = ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int source;\\n        long long ans =0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n,vector<int> (m,-1));\\n        for( int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans = (ans + dfs_memo(i,j,grid,dp))%1000000007 ;\\n            }\\n        }\\n        return (ans + m*n)%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651159,
                "title": "dp-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool issafe(int i,int j , int m , int n  ,vector<vector<int>>& grid,int prev,vector<vector<bool>>&visited){\\n       if(i >= 0 && j >= 0 && i < m && j < n && grid[i][j] > prev && visited[i][j] == false) return true;\\n       return false;\\n   }\\n     int mod = pow(10,9)+7;\\n    int solve(int m  , int n , int i , int j,vector<vector<int>>&dp,vector<vector<int>>& grid,  vector<vector<bool>>&visited){\\n        // base case \\n        if(i >= m  && j >= n )  return 0;\\n    \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        int ans = 0;\\n        \\n        // righ check \\n        if(issafe(i,j+1, m , n,grid,grid[i][j],visited)) {\\n             visited[i][j] = true;\\n            ans = (ans +  1 + solve(m,n,i,j+1,dp,grid,visited))%mod;\\n             visited[i][j] = false;\\n        }\\n        \\n        // douwn check\\n        if(issafe(i+1,j,m,n,grid,grid[i][j],visited)){\\n             visited[i][j] = true;\\n             ans = (ans + 1 + solve(m,n,i+1,j,dp,grid,visited))%mod;\\n              visited[i][j] = false;\\n        }\\n        \\n        \\n        // left check \\n        if(issafe(i,j-1, m , n,grid,grid[i][j],visited)){\\n             visited[i][j] = true;\\n             ans = (ans +1 + solve(m,n,i,j-1,dp,grid,visited))%mod;\\n              visited[i][j] = false;\\n        }\\n        \\n        // up check\\n        if(issafe(i-1,j,m,n,grid,grid[i][j],visited)) {\\n            visited[i][j] = true;\\n            ans = (ans+ 1 +  solve(m,n,i-1,j,dp,grid,visited))%mod;\\n            visited[i][j] = false;\\n    }\\n        return dp[i][j] = ans;\\n        }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int clm = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>>dp(row+1,vector<int>(clm+1,-1));\\n        vector<vector<bool>>visited(row+1,vector<bool>(clm+1,false));\\n\\n        for(int i = 0 ;i<row;i++){\\n            for(int j = 0 ;j<clm ;j++){\\n             ans = (ans + solve(row,clm,i,j,dp,grid,visited))%mod;\\n            }\\n        }\\n        return (ans+(row*clm))%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool issafe(int i,int j , int m , int n  ,vector<vector<int>>& grid,int prev,vector<vector<bool>>&visited){\\n       if(i >= 0 && j >= 0 && i < m && j < n && grid[i][j] > prev && visited[i][j] == false) return true;\\n       return false;\\n   }\\n     int mod = pow(10,9)+7;\\n    int solve(int m  , int n , int i , int j,vector<vector<int>>&dp,vector<vector<int>>& grid,  vector<vector<bool>>&visited){\\n        // base case \\n        if(i >= m  && j >= n )  return 0;\\n    \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        int ans = 0;\\n        \\n        // righ check \\n        if(issafe(i,j+1, m , n,grid,grid[i][j],visited)) {\\n             visited[i][j] = true;\\n            ans = (ans +  1 + solve(m,n,i,j+1,dp,grid,visited))%mod;\\n             visited[i][j] = false;\\n        }\\n        \\n        // douwn check\\n        if(issafe(i+1,j,m,n,grid,grid[i][j],visited)){\\n             visited[i][j] = true;\\n             ans = (ans + 1 + solve(m,n,i+1,j,dp,grid,visited))%mod;\\n              visited[i][j] = false;\\n        }\\n        \\n        \\n        // left check \\n        if(issafe(i,j-1, m , n,grid,grid[i][j],visited)){\\n             visited[i][j] = true;\\n             ans = (ans +1 + solve(m,n,i,j-1,dp,grid,visited))%mod;\\n              visited[i][j] = false;\\n        }\\n        \\n        // up check\\n        if(issafe(i-1,j,m,n,grid,grid[i][j],visited)) {\\n            visited[i][j] = true;\\n            ans = (ans+ 1 +  solve(m,n,i-1,j,dp,grid,visited))%mod;\\n            visited[i][j] = false;\\n    }\\n        return dp[i][j] = ans;\\n        }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int clm = grid[0].size();\\n        int ans = 0;\\n        vector<vector<int>>dp(row+1,vector<int>(clm+1,-1));\\n        vector<vector<bool>>visited(row+1,vector<bool>(clm+1,false));\\n\\n        for(int i = 0 ;i<row;i++){\\n            for(int j = 0 ;j<clm ;j++){\\n             ans = (ans + solve(row,clm,i,j,dp,grid,visited))%mod;\\n            }\\n        }\\n        return (ans+(row*clm))%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651108,
                "title": "beats-100-runtime-dfs",
                "content": "# Approach\\n***TODO***\\n\\n# Time Complexity\\n***TODO***\\n\\n# Space complexity\\n***TODO***\\n\\n# Solution\\n```swift\\nclass Solution {\\n    \\n    func countPaths(_ grid: [[Int]]) -> Int {\\n        let m = grid.count\\n        let n = grid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        let mod = 1_000_000_007\\n        var answer = 0\\n        \\n        func dfs(_ grid: [[Int]], _ i: Int, _ j: Int) -> Int {\\n            guard dp[i][j] == 0 else { return dp[i][j] }\\n            var answer = 1\\n\\n            for d in directions {\\n                let prevI = i + d[0]\\n                let prevJ = j + d[1]\\n                let containsI = (0..<grid.count).contains(prevI)\\n                let containsJ = (0..<grid[0].count).contains(prevJ)\\n                \\n                if containsI && containsJ && grid[prevI][prevJ] < grid[i][j] {\\n                    answer += dfs(grid, prevI, prevJ)\\n                    answer %= mod\\n                }\\n            }\\n            \\n            dp[i][j] = answer\\n            return answer\\n        }\\n\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                answer = (answer + dfs(grid, i, j)) % mod\\n            }\\n        }\\n        return answer\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```swift\\nclass Solution {\\n    \\n    func countPaths(_ grid: [[Int]]) -> Int {\\n        let m = grid.count\\n        let n = grid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n), count: m)\\n        let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        let mod = 1_000_000_007\\n        var answer = 0\\n        \\n        func dfs(_ grid: [[Int]], _ i: Int, _ j: Int) -> Int {\\n            guard dp[i][j] == 0 else { return dp[i][j] }\\n            var answer = 1\\n\\n            for d in directions {\\n                let prevI = i + d[0]\\n                let prevJ = j + d[1]\\n                let containsI = (0..<grid.count).contains(prevI)\\n                let containsJ = (0..<grid[0].count).contains(prevJ)\\n                \\n                if containsI && containsJ && grid[prevI][prevJ] < grid[i][j] {\\n                    answer += dfs(grid, prevI, prevJ)\\n                    answer %= mod\\n                }\\n            }\\n            \\n            dp[i][j] = answer\\n            return answer\\n        }\\n\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                answer = (answer + dfs(grid, i, j)) % mod\\n            }\\n        }\\n        return answer\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651058,
                "title": "dp-approach",
                "content": "# Intuition\\nThere can be only two approach - DFS and DP.\\ndp[i][j] will store how many path exist that end on {i,j}.\\n\\n\\n# Approach\\nGo to all the sides and check for them recursively and increment the value in the dp table .\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n\\n- Space complexity:O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>a={{1,0},{-1,0},{0,-1},{0,1}};\\n    long long mod=1e9+7;\\n    vector<vector<long long>>dp;\\n    long long solve(int i,int j,vector<vector<int>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        if(dp[i][j]>1) return dp[i][j];\\n        int ans=1;\\n        for(auto it:a){\\n            int x=it.first+i,y=it.second+j;\\n            if(x<n && x>=0 && y<m && y>=0){\\n                if(grid[x][y]<grid[i][j]) {\\n                    ans+=solve(x,y,grid);\\n                }\\n            }\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        dp=vector<vector<long long>>(n,vector<long long>(m,1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==1) solve(i,j,grid);\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans+=dp[i][j];\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>a={{1,0},{-1,0},{0,-1},{0,1}};\\n    long long mod=1e9+7;\\n    vector<vector<long long>>dp;\\n    long long solve(int i,int j,vector<vector<int>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        if(dp[i][j]>1) return dp[i][j];\\n        int ans=1;\\n        for(auto it:a){\\n            int x=it.first+i,y=it.second+j;\\n            if(x<n && x>=0 && y<m && y>=0){\\n                if(grid[x][y]<grid[i][j]) {\\n                    ans+=solve(x,y,grid);\\n                }\\n            }\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        dp=vector<vector<long long>>(n,vector<long long>(m,1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(dp[i][j]==1) solve(i,j,grid);\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans+=dp[i][j];\\n            }\\n        }\\n        return (int)(ans%mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651047,
                "title": "c-recursion-memoization-dp-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int MOD = (int)(1e9 + 7); \\n    vector<int> dirs = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int row, int col, int n, int m) {\\n        return (row >= 0 && row < n && col >= 0 && col < m);\\n    }\\n\\n    int countTotalPaths(vector<vector<int>>& grid, int row, int col, vector<vector<int>>& dp) {\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int ans = 0;\\n\\n        for(int i = 0; i < 4; i++) {\\n            int newRow = row + dirs[i];\\n            int newCol = col + dirs[i + 1];\\n            if(!isValid(newRow, newCol, grid.size(), grid[0].size())) continue;\\n            if(grid[newRow][newCol] <= grid[row][col]) continue;\\n\\n            ans = (ans % MOD + countTotalPaths(grid, newRow, newCol, dp) % MOD) % MOD;\\n        } \\n        return dp[row][col] = ans + 1;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                ans = (ans % MOD + countTotalPaths(grid, i, j, dp) % MOD) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int MOD = (int)(1e9 + 7); \\n    vector<int> dirs = {0, 1, 0, -1, 0};\\n\\n    bool isValid(int row, int col, int n, int m) {\\n        return (row >= 0 && row < n && col >= 0 && col < m);\\n    }\\n\\n    int countTotalPaths(vector<vector<int>>& grid, int row, int col, vector<vector<int>>& dp) {\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int ans = 0;\\n\\n        for(int i = 0; i < 4; i++) {\\n            int newRow = row + dirs[i];\\n            int newCol = col + dirs[i + 1];\\n            if(!isValid(newRow, newCol, grid.size(), grid[0].size())) continue;\\n            if(grid[newRow][newCol] <= grid[row][col]) continue;\\n\\n            ans = (ans % MOD + countTotalPaths(grid, newRow, newCol, dp) % MOD) % MOD;\\n        } \\n        return dp[row][col] = ans + 1;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m, -1));\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                ans = (ans % MOD + countTotalPaths(grid, i, j, dp) % MOD) % MOD;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651019,
                "title": "typescript-solution-based-on-editorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The path with specific length would include the paths with smaller lenth, hence it would need **recursion**. \\n- Since the number of paths of specific cell is static, could use **dynamic programming** to **memorize** the result and enhance the run time. \\n- Use `BigInt` to handle the large numbers. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declare the `dp[i][j]` to log the path count once it has been calculted. \\n- Define a Depth First Search (DFS) function `dfs(i,j)` to calculate the path count of visiting `grid[i][j]`. \\n- In `dfs(i, j)`, if `dp[i][j]` exist then return the value, else initialize the path count `cost` as `1` (visit itself) and see its neighbor cells (4 directions next to `grid[i][j]`) could be visited or not. \\n- If neighbors could be visited (value < current cell), add the path count of neighbors to `cost`. Log the `cost` into `dp[i][j]` in the end. \\n- Sum all the `dp[i][j]` as result to be returned. \\n\\n# Complexity\\n- Time complexity: $$O(m \\\\cdot n)$$\\n    - All the cells would be calculated once. \\n    - Initial `dp` cost $$O(m)$$. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m \\\\cdot n)$$\\n    - Size of `dp[i][j]`. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction countPaths(grid: number[][]): number {\\n    let res = 0n;\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp: bigint[][] = [];\\n    const mod = BigInt(10**9+7);\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    // init dp\\n    for(let i=0; i<m; i++){\\n        dp[i] = [];\\n    }\\n\\n    function dfs(i: number, j: number): bigint{\\n        if(dp[i][j]){\\n            return dp[i][j];\\n        }\\n\\n        let cost = 1n;\\n        for(let k=0; k<directions.length; k++){\\n            const direction = directions[k];\\n            const previousRow = i+direction[0];\\n            const previousCol = j+direction[1];\\n            if(\\n                grid[previousRow] \\n                && grid[previousRow][previousCol]\\n                && grid[previousRow][previousCol] < grid[i][j]\\n            ){\\n                cost += dfs(previousRow, previousCol)\\n            }\\n        }\\n        dp[i][j] = cost\\n        return cost\\n    }\\n\\n    for(let i=0; i<m; i++){\\n        for(let j=0; j<n; j++){\\n            res += dfs(i, j);\\n        }\\n    }\\n    \\n    return Number(res%mod);\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction countPaths(grid: number[][]): number {\\n    let res = 0n;\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const dp: bigint[][] = [];\\n    const mod = BigInt(10**9+7);\\n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\n    // init dp\\n    for(let i=0; i<m; i++){\\n        dp[i] = [];\\n    }\\n\\n    function dfs(i: number, j: number): bigint{\\n        if(dp[i][j]){\\n            return dp[i][j];\\n        }\\n\\n        let cost = 1n;\\n        for(let k=0; k<directions.length; k++){\\n            const direction = directions[k];\\n            const previousRow = i+direction[0];\\n            const previousCol = j+direction[1];\\n            if(\\n                grid[previousRow] \\n                && grid[previousRow][previousCol]\\n                && grid[previousRow][previousCol] < grid[i][j]\\n            ){\\n                cost += dfs(previousRow, previousCol)\\n            }\\n        }\\n        dp[i][j] = cost\\n        return cost\\n    }\\n\\n    for(let i=0; i<m; i++){\\n        for(let j=0; j<n; j++){\\n            res += dfs(i, j);\\n        }\\n    }\\n    \\n    return Number(res%mod);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651008,
                "title": "c-clean-code-with-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool issafe(int i,int j,int n,int m)\\n{\\n    if(i>=0 && i<n && j<m && j>=0)\\n    {\\n        return true;\\n    }\\n    return false;\\n}\\nint dfs(map<pair<int,int>,int> &dp,int i,int j,map<pair<int,int>,int> &mp,vector<vector<int>>& grid,int n,int m)\\n{\\n    if(dp[{i,j}]>0)\\n    {\\n        return dp[{i,j}];\\n    }\\n    pair p={i+1,j},q={i,j+1},r={i-1,j},s={i,j-1};\\n    int x=1;\\n    if(issafe(p.first,p.second,n,m) && grid[p.first][p.second]>grid[i][j])\\n    {\\n        \\n        x+=dfs(dp,p.first,p.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(q.first,q.second,n,m) && grid[q.first][q.second]>grid[i][j])\\n    {\\n     \\n        x+=dfs(dp,q.first,q.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(r.first,r.second,n,m) && grid[r.first][r.second]>grid[i][j])\\n    {\\n        \\n        x+=dfs(dp,r.first,r.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(s.first,s.second,n,m) && grid[s.first][s.second]>grid[i][j])\\n    {\\n       \\n        x+=dfs(dp,s.first,s.second,mp,grid,n,m);\\n        x=x%1000000007;\\n    }\\n    return dp[{i,j}]=x;\\n}\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        map<pair<int,int>,int> mp,dp;\\n        long long int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                \\n                    ans+=dfs(dp,i,j,mp,grid,grid.size(),grid[0].size());\\n                ans=ans%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool issafe(int i,int j,int n,int m)\\n{\\n    if(i>=0 && i<n && j<m && j>=0)\\n    {\\n        return true;\\n    }\\n    return false;\\n}\\nint dfs(map<pair<int,int>,int> &dp,int i,int j,map<pair<int,int>,int> &mp,vector<vector<int>>& grid,int n,int m)\\n{\\n    if(dp[{i,j}]>0)\\n    {\\n        return dp[{i,j}];\\n    }\\n    pair p={i+1,j},q={i,j+1},r={i-1,j},s={i,j-1};\\n    int x=1;\\n    if(issafe(p.first,p.second,n,m) && grid[p.first][p.second]>grid[i][j])\\n    {\\n        \\n        x+=dfs(dp,p.first,p.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(q.first,q.second,n,m) && grid[q.first][q.second]>grid[i][j])\\n    {\\n     \\n        x+=dfs(dp,q.first,q.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(r.first,r.second,n,m) && grid[r.first][r.second]>grid[i][j])\\n    {\\n        \\n        x+=dfs(dp,r.first,r.second,mp,grid,n,m);\\n         x=x%1000000007;\\n    }\\n    if(issafe(s.first,s.second,n,m) && grid[s.first][s.second]>grid[i][j])\\n    {\\n       \\n        x+=dfs(dp,s.first,s.second,mp,grid,n,m);\\n        x=x%1000000007;\\n    }\\n    return dp[{i,j}]=x;\\n}\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        map<pair<int,int>,int> mp,dp;\\n        long long int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                \\n                    ans+=dfs(dp,i,j,mp,grid,grid.size(),grid[0].size());\\n                ans=ans%1000000007;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650933,
                "title": "memoization-dfs-dp-c",
                "content": "```\\nclass Solution {\\n    vector<int> dx= {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int mod = 1e9 + 7;\\n\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        int ans = dp[i][j];\\n        if(dp[i][j] > 1) return dp[i][j];\\n\\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[i][j] < grid[x][y]) {\\n                ans = (ans + dfs(x, y, n, m, grid, dp)) % mod;\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                ans = (ans + dfs(i, j, n, m, grid, dp)) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dx= {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\\n    int mod = 1e9 + 7;\\n\\n    int dfs(int i, int j, int n, int m, vector<vector<int>> &grid, vector<vector<int>> &dp) {\\n        int ans = dp[i][j];\\n        if(dp[i][j] > 1) return dp[i][j];\\n\\n        for(int k=0; k<4; k++) {\\n            int x = i + dx[k], y = j + dy[k];\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[i][j] < grid[x][y]) {\\n                ans = (ans + dfs(x, y, n, m, grid, dp)) % mod;\\n            }\\n        }\\n        return dp[i][j] = ans;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(m, 1));\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                ans = (ans + dfs(i, j, n, m, grid, dp)) % mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650815,
                "title": "faster-than-89-dfs-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        MOD = 10 ** 9 + 7\\n        m, n = len(grid), len(grid[0])\\n        dirxns = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        memo = [[-1] * n for _ in range(m)]\\n        res = 0\\n        def dfs(row, col):\\n            if memo[row][col] != -1:\\n                return memo[row][col]\\n            count = 1\\n            for dx, dy in dirxns:\\n                new_row, new_col = row + dx, col + dy\\n                if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] > grid[row][col]:\\n                    count += dfs(new_row, new_col)\\n            memo[row][col] = count\\n            return count\\n        for row in range(m):\\n            for col in range(n):\\n                res += dfs(row, col)\\n        return res % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        MOD = 10 ** 9 + 7\\n        m, n = len(grid), len(grid[0])\\n        dirxns = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        memo = [[-1] * n for _ in range(m)]\\n        res = 0\\n        def dfs(row, col):\\n            if memo[row][col] != -1:\\n                return memo[row][col]\\n            count = 1\\n            for dx, dy in dirxns:\\n                new_row, new_col = row + dx, col + dy\\n                if 0 <= new_row < m and 0 <= new_col < n and grid[new_row][new_col] > grid[row][col]:\\n                    count += dfs(new_row, new_col)\\n            memo[row][col] = count\\n            return count\\n        for row in range(m):\\n            for col in range(n):\\n                res += dfs(row, col)\\n        return res % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650374,
                "title": "java-dfs-memoization-dp-with-comments",
                "content": "This is a pretty standard DFS+Memo problem.\\nSteps to follow:\\n\\n1. We need to go at each and every cell and do a dfs.\\n2. We will only move to the next cell if its value is **greater** than the current value\\n3. At every successful move , we will increase our **counter by 1**\\n4. Also, before returning at the end , we ll add the total cells of grid since they are also standalone increasing paths\\n\\n```\\nclass Solution {\\n    int mod = (int) 1e9+7;\\n    public int countPaths(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m  = grid[0].length;\\n        \\n        Integer[][] dp = new Integer[n][m];\\n        // Traversing each and every cell to get the path count\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                res = res+ solve(i,j,grid,dp);\\n                res = res%mod;\\n            }\\n        }\\n         // adding the single cell paths\\n        return (res+ n*m) %mod;\\n    }\\n    \\n    \\n    public int solve(int i, int j, int[][] grid, Integer[][] dp)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        \\n        if(dp[i][j]!=null)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n\\t\\tbase condition\\n        if(i<0 || j<0 || i>=n || j>=m)\\n        {\\n            return 0;\\n        }\\n        \\n\\t\\t// Moving Up\\n        if(i > 0 && grid[i][j] < grid[i-1][j])\\n        {\\n            count  = count + solve(i-1, j, grid, dp) +1;\\n        }\\n        \\n\\t\\t// Moving left\\n        if(j > 0 && grid[i][j] < grid[i][j-1])\\n        {\\n            count  = count + solve(i, j-1, grid, dp) +1;\\n        }\\n        // Moving Down\\n        if(i < n-1 && grid[i][j] < grid[i+1][j])\\n        {\\n            count  = count + solve(i+1, j, grid, dp) +1;\\n        }\\n        // Moving Right\\n        if(j < m-1 && grid[i][j] < grid[i][j+1])\\n        {\\n            count  = count + solve(i, j+1, grid, dp) +1;\\n        }\\n        \\n        count = count%mod;\\n        dp[i][j] = count;\\n        return count;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9871e1c7-ba96-41df-aca1-cad24bac8532_1687059788.2307174.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int) 1e9+7;\\n    public int countPaths(int[][] grid) {\\n        int res = 0;\\n        int n = grid.length;\\n        int m  = grid[0].length;\\n        \\n        Integer[][] dp = new Integer[n][m];\\n        // Traversing each and every cell to get the path count\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                res = res+ solve(i,j,grid,dp);\\n                res = res%mod;\\n            }\\n        }\\n         // adding the single cell paths\\n        return (res+ n*m) %mod;\\n    }\\n    \\n    \\n    public int solve(int i, int j, int[][] grid, Integer[][] dp)\\n    {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int count = 0;\\n        \\n        if(dp[i][j]!=null)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n\\t\\tbase condition\\n        if(i<0 || j<0 || i>=n || j>=m)\\n        {\\n            return 0;\\n        }\\n        \\n\\t\\t// Moving Up\\n        if(i > 0 && grid[i][j] < grid[i-1][j])\\n        {\\n            count  = count + solve(i-1, j, grid, dp) +1;\\n        }\\n        \\n\\t\\t// Moving left\\n        if(j > 0 && grid[i][j] < grid[i][j-1])\\n        {\\n            count  = count + solve(i, j-1, grid, dp) +1;\\n        }\\n        // Moving Down\\n        if(i < n-1 && grid[i][j] < grid[i+1][j])\\n        {\\n            count  = count + solve(i+1, j, grid, dp) +1;\\n        }\\n        // Moving Right\\n        if(j < m-1 && grid[i][j] < grid[i][j+1])\\n        {\\n            count  = count + solve(i, j+1, grid, dp) +1;\\n        }\\n        \\n        count = count%mod;\\n        dp[i][j] = count;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650370,
                "title": "python-simple-dp-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDynamic programming.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N\\\\cdot M)$ for calculating paths for each cell.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N\\\\cdot M)$ for caching the counts for each cell.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        DIRS = ((-1, 0), (1, 0), (0, 1), (0, -1))\\n        MOD = int(1e9+7)\\n        @cache\\n        def search(row: int, col: int) -> int:\\n            \"\"\"Given this row and column, how many paths stem from here?\"\"\"\\n            count = 1 # Just visit the node itself\\n            for dr, dc in DIRS:\\n                if 0 <= row + dr < len(grid) and 0 <= col + dc < len(grid[0]):\\n                    # Must be strictly increasing\\n                    if not grid[row + dr][col + dc] > grid[row][col]:\\n                        continue\\n                    count += search(row + dr, col + dc)\\n            return count % MOD\\n        return sum(\\n            search(row, col)\\n            for row in range(len(grid))\\n            for col in range(len(grid[0]))\\n        ) % MOD\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        DIRS = ((-1, 0), (1, 0), (0, 1), (0, -1))\\n        MOD = int(1e9+7)\\n        @cache\\n        def search(row: int, col: int) -> int:\\n            \"\"\"Given this row and column, how many paths stem from here?\"\"\"\\n            count = 1 # Just visit the node itself\\n            for dr, dc in DIRS:\\n                if 0 <= row + dr < len(grid) and 0 <= col + dc < len(grid[0]):\\n                    # Must be strictly increasing\\n                    if not grid[row + dr][col + dc] > grid[row][col]:\\n                        continue\\n                    count += search(row + dr, col + dc)\\n            return count % MOD\\n        return sum(\\n            search(row, col)\\n            for row in range(len(grid))\\n            for col in range(len(grid[0]))\\n        ) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650359,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int path[][];\\nint mod=(int)Math.pow(10,9)+7;\\n\\n    public int countPaths(int[][] grid) {\\n        \\n        int n=grid.length;\\nint m=grid[0].length;\\n\\n    int ans=0;\\n    path=new int[n][m];\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n           \\n            ans=(ans%mod+ dfs(grid,i,j,m,n,-1)%mod)%mod;\\n            \\n        }\\n    }\\n    return ans;\\n}\\npublic int dfs(int[][] grid,int x,int y,int m,int n,int pre){\\n    if(x<0 || y<0 || x>=n || y>=m)return 0;\\n    if(grid[x][y]<=pre)return 0;\\n    if(path[x][y]!=0)return path[x][y];\\n   \\n    int l1=dfs(grid,x+1,y,m,n,grid[x][y]);\\n    int l2=dfs(grid,x-1,y,m,n,grid[x][y]);\\n    int l3=dfs(grid,x,y+1,m,n,grid[x][y]);\\n    int l4=dfs(grid,x,y-1,m,n,grid[x][y]);\\n    \\n    return  path[x][y]=(1+l1+l2+l3+l4)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int path[][];\\nint mod=(int)Math.pow(10,9)+7;\\n\\n    public int countPaths(int[][] grid) {\\n        \\n        int n=grid.length;\\nint m=grid[0].length;\\n\\n    int ans=0;\\n    path=new int[n][m];\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n           \\n            ans=(ans%mod+ dfs(grid,i,j,m,n,-1)%mod)%mod;\\n            \\n        }\\n    }\\n    return ans;\\n}\\npublic int dfs(int[][] grid,int x,int y,int m,int n,int pre){\\n    if(x<0 || y<0 || x>=n || y>=m)return 0;\\n    if(grid[x][y]<=pre)return 0;\\n    if(path[x][y]!=0)return path[x][y];\\n   \\n    int l1=dfs(grid,x+1,y,m,n,grid[x][y]);\\n    int l2=dfs(grid,x-1,y,m,n,grid[x][y]);\\n    int l3=dfs(grid,x,y+1,m,n,grid[x][y]);\\n    int l4=dfs(grid,x,y-1,m,n,grid[x][y]);\\n    \\n    return  path[x][y]=(1+l1+l2+l3+l4)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650282,
                "title": "python3-intuitive-heap-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen looking at this problem, we note that the largest node will only have a path to itself. Furthermore, any node\\'s paths can be counted by seeing which nodes it can be connected to, and then adding those values to the node\\'s base value of 1 (a path with only itself.) So, the only problem we have to solve is how to make it so all the nodes with larger values are initialized by the time we get to any given node. How do we do this? A heap!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we push every node into a heap, with the largest values first. Then, we iterate through the full queue and follow the above algorithm for calculating node values. It\\'s possible you could maybe skip checking the adjacent nodes for a greater value (if they\\'re initialized they\\'re larger, right?) but we run into problems when nodes have the same values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n log (n))$$, where $$n$$ is the number of elements in the grid (the costliest op is creating the heap.)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, as we only store the grid and a few constant variables.\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        # dp of how many list start from a given node\\n        # init all to 0\\n        # build out from largest node to smallest nodes, node value is 1 + sum of adjacent nodes\\n        # sum over whole grid\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n\\n        prio = []\\n        for i in range(m):\\n            for j in range(n):\\n                heapq.heappush(prio, (-grid[i][j], i, j))\\n        \\n        ret = 0\\n        while prio:\\n            cur = heapq.heappop(prio)\\n            i = cur[1]\\n            j = cur[2]\\n            dp[i][j] = 1\\n            if i > 0 and grid[i - 1][j] > grid[i][j]:\\n                dp[i][j] += dp[i - 1][j]\\n            if i < m - 1 and grid[i + 1][j] > grid[i][j]:\\n                dp[i][j] += dp[i + 1][j]\\n            if j > 0 and grid[i][j - 1] > grid[i][j]:\\n                dp[i][j] += dp[i][j - 1]\\n            if j < n - 1 and grid[i][j + 1] > grid[i][j]:\\n                dp[i][j] += dp[i][j + 1]\\n            ret += dp[i][j]\\n        return ret % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        # dp of how many list start from a given node\\n        # init all to 0\\n        # build out from largest node to smallest nodes, node value is 1 + sum of adjacent nodes\\n        # sum over whole grid\\n        m = len(grid)\\n        n = len(grid[0])\\n        dp = [[0] * n for _ in range(m)]\\n\\n        prio = []\\n        for i in range(m):\\n            for j in range(n):\\n                heapq.heappush(prio, (-grid[i][j], i, j))\\n        \\n        ret = 0\\n        while prio:\\n            cur = heapq.heappop(prio)\\n            i = cur[1]\\n            j = cur[2]\\n            dp[i][j] = 1\\n            if i > 0 and grid[i - 1][j] > grid[i][j]:\\n                dp[i][j] += dp[i - 1][j]\\n            if i < m - 1 and grid[i + 1][j] > grid[i][j]:\\n                dp[i][j] += dp[i + 1][j]\\n            if j > 0 and grid[i][j - 1] > grid[i][j]:\\n                dp[i][j] += dp[i][j - 1]\\n            if j < n - 1 and grid[i][j + 1] > grid[i][j]:\\n                dp[i][j] += dp[i][j + 1]\\n            ret += dp[i][j]\\n        return ret % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650269,
                "title": "python-easy-understand-code-bottom-up-dp-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are caring about how many increasing sequences ending at each grid. The sum of number increasing sequences at each grid is the final answer.\\n\\nStarts from smallest number to the largest in the grid, if all surrounding numbers are larger than grid[i][j], then there\\'s only one increasing sequence ends at grid[i][j], which is grid[i][j] itself. So dp[i][j] = 1.\\n\\nOtherwise, if grid[i][j] is larger than its neighbor, then each increasing sequence ends at its neighbor can append grid[i][j] to its tail. Thus, we add number of increasing sequences ending at grid[i][j]\\'s neighbor to dp[i][j]. The same logic applies to four directions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort values in grid together with their indices\\n2. Initialize dp[i][j] with 0\\n3. Implement the algorithm described above.\\n4. Return sum of values in dp, remember mod 10 ** 9 + 7 \\n\\n# Complexity\\n- Time complexity: O(mn\\\\*log(mn)) sorting m*n entries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        values = sorted([(grid[i][j], i, j) for i in range(len(grid)) for j in range(len(grid[0]))])\\n        dp = [[0] * len(grid[0]) for _ in range(len(grid))]\\n        for v, i, j in values:\\n            up    = dp[i-1][j] if i > 0 and grid[i][j] > grid[i-1][j] else 0\\n            down  = dp[i+1][j] if i < len(grid)-1 and grid[i][j] > grid[i+1][j] else 0\\n            left  = dp[i][j-1] if j > 0 and grid[i][j] > grid[i][j-1] else 0\\n            right = dp[i][j+1] if j < len(grid[0])-1 and grid[i][j] > grid[i][j+1] else 0\\n            dp[i][j] = (up + down + left + right + 1) % (10 ** 9 + 7)\\n        return sum([sum(dp[i]) for i in range(len(dp))]) % (10 ** 9 + 7)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        values = sorted([(grid[i][j], i, j) for i in range(len(grid)) for j in range(len(grid[0]))])\\n        dp = [[0] * len(grid[0]) for _ in range(len(grid))]\\n        for v, i, j in values:\\n            up    = dp[i-1][j] if i > 0 and grid[i][j] > grid[i-1][j] else 0\\n            down  = dp[i+1][j] if i < len(grid)-1 and grid[i][j] > grid[i+1][j] else 0\\n            left  = dp[i][j-1] if j > 0 and grid[i][j] > grid[i][j-1] else 0\\n            right = dp[i][j+1] if j < len(grid[0])-1 and grid[i][j] > grid[i][j+1] else 0\\n            dp[i][j] = (up + down + left + right + 1) % (10 ** 9 + 7)\\n        return sum([sum(dp[i]) for i in range(len(dp))]) % (10 ** 9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650268,
                "title": "easy-c-solution-dfs-dp-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs stated in the problem we have find path with strictly greater\\nWe have to find all the paths with each element grater than the privious one. Should think of dfs for finding path for each element. But simple dfs may give tle So we used dp to store the paths for each element in the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNeed to traverse each element in the grid to find the number of paths originating from this element.\\nApply dfs on the element if the dp[i][j]!=0 means we already had reached this element and number of paths are computed, we directly return the dp[i][j].\\nif the currelement  is not visited then we check for all the four direction neighbour are less than the curr element if true then apply dfs on that element \\nthe value return is added in ans and stored for perticular i,j in dp\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(n*m)**\\nThe complexity may seems more than O(n*m) but as we are using dp vector we need not traverse the entire gird each time\\nEvery element is just visited once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n*m)** for dp vector of size of grid\\n\\n# please upvote if find usefull :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    vector<vector<int>>dp;\\n    int dfs(int i,int j,vector<vector<int>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        long ans=1;\\n        vector<int>row{1,0,-1,0};\\n        vector<int>col{0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int r=i+row[k];\\n            int c=j+col[k];\\n            if(r>=0&&r<n&&c>=0&&c<m){\\n                if(grid[r][c]>grid[i][j]){\\n                    dp[r][c]=dfs(r,c,grid);\\n                    ans=(ans+dp[r][c])%md;\\n                }\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        long ans=0,n=grid.size(),m=grid[0].size();\\n        dp.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans=(ans+dfs(i,j,grid))%md;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int md=1e9+7;\\n    vector<vector<int>>dp;\\n    int dfs(int i,int j,vector<vector<int>>&grid){\\n        int n=grid.size(),m=grid[0].size();\\n        if(dp[i][j]!=0){\\n            return dp[i][j];\\n        }\\n        long ans=1;\\n        vector<int>row{1,0,-1,0};\\n        vector<int>col{0,1,0,-1};\\n        for(int k=0;k<4;k++){\\n            int r=i+row[k];\\n            int c=j+col[k];\\n            if(r>=0&&r<n&&c>=0&&c<m){\\n                if(grid[r][c]>grid[i][j]){\\n                    dp[r][c]=dfs(r,c,grid);\\n                    ans=(ans+dp[r][c])%md;\\n                }\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        long ans=0,n=grid.size(),m=grid[0].size();\\n        dp.resize(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans=(ans+dfs(i,j,grid))%md;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650215,
                "title": "rust-dfs-solution",
                "content": "\\n```\\nimpl Solution {\\n    const MOD: i32 = 1e9 as i32 + 7;\\n    const DIRS: [(i32, i32); 4] = [(-1, 0), (0, 1), (1, 0), (0, -1)];\\n\\n    pub fn count_paths(grid: Vec<Vec<i32>>) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut res = 0;\\n        let mut memo = vec![vec![0; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                res = (res + Self::dfs(&grid, &mut memo, m as i32, n as i32, i as i32, j as i32)) % Self::MOD;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn dfs(grid: &Vec<Vec<i32>>, memo: &mut Vec<Vec<i32>>, m: i32, n: i32, x: i32, y: i32) -> i32 {\\n        if memo[x as usize][y as usize] != 0 {\\n            return memo[x as usize][y as usize];\\n        }\\n\\n        let mut count = 1;\\n\\n        for dir in Self::DIRS {\\n            let (nx, ny) = (dir.0 + x, dir.1 + y);\\n\\n            if nx >= 0 && nx < m && ny >= 0 && ny < n && grid[x as usize][y as usize] < grid[nx as usize][ny as usize] {\\n                count = (count + Self::dfs(grid, memo, m, n, nx, ny)) % Self::MOD;\\n            }\\n        }\\n\\n        memo[x as usize][y as usize] = count;\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    const MOD: i32 = 1e9 as i32 + 7;\\n    const DIRS: [(i32, i32); 4] = [(-1, 0), (0, 1), (1, 0), (0, -1)];\\n\\n    pub fn count_paths(grid: Vec<Vec<i32>>) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut res = 0;\\n        let mut memo = vec![vec![0; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                res = (res + Self::dfs(&grid, &mut memo, m as i32, n as i32, i as i32, j as i32)) % Self::MOD;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn dfs(grid: &Vec<Vec<i32>>, memo: &mut Vec<Vec<i32>>, m: i32, n: i32, x: i32, y: i32) -> i32 {\\n        if memo[x as usize][y as usize] != 0 {\\n            return memo[x as usize][y as usize];\\n        }\\n\\n        let mut count = 1;\\n\\n        for dir in Self::DIRS {\\n            let (nx, ny) = (dir.0 + x, dir.1 + y);\\n\\n            if nx >= 0 && nx < m && ny >= 0 && ny < n && grid[x as usize][y as usize] < grid[nx as usize][ny as usize] {\\n                count = (count + Self::dfs(grid, memo, m, n, nx, ny)) % Self::MOD;\\n            }\\n        }\\n\\n        memo[x as usize][y as usize] = count;\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3637649,
                "title": "dp-intuitive-solution-c",
                "content": "\\n\\n# Code\\n```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    void dfs(vector<long long>& dp,vector<bool>& vis,vector<int> adj[],int src){\\n        vis[src]=true;\\n        dp[src]=1;   //for the node itself\\n        for(auto x:adj[src]){\\n            if(!vis[x]){\\n                dfs(dp,vis,adj,x);   //dp[src] -> number of increasing paths that end at src\\n            }\\n            dp[src] = (dp[src] + dp[x])%mod;\\n        }\\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<int> adj[m*n];\\n        vector<long long> dp(m*n);\\n        vector<bool> vis(m*n,false);\\n        int dr[4]={1,0,-1,0};\\n        int dc[4]={0,1,0,-1};\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int node=n*i+j;\\n                for(int k=0;k<4;k++){  //creating a increasing graph\\n                    int ni=i+dr[k];\\n                    int nj=j+dc[k];\\n                    if(ni>=0 and nj>=0 and ni<m and nj<n){\\n                        int new_node=n*ni+nj;\\n                        if(matrix[ni][nj]>matrix[i][j]){\\n                            adj[node].push_back(new_node);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!vis[i]){\\n                dfs(dp,vis,adj,i);  //DFS traversal\\n            }\\n        }\\n\\n        long long ans = 0;\\n\\n        for(int i=0;i<m*n;i++){\\n            ans = (ans+dp[i])%mod;   //finding the sum\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1e9+7;\\nclass Solution {\\npublic:\\n    void dfs(vector<long long>& dp,vector<bool>& vis,vector<int> adj[],int src){\\n        vis[src]=true;\\n        dp[src]=1;   //for the node itself\\n        for(auto x:adj[src]){\\n            if(!vis[x]){\\n                dfs(dp,vis,adj,x);   //dp[src] -> number of increasing paths that end at src\\n            }\\n            dp[src] = (dp[src] + dp[x])%mod;\\n        }\\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<int> adj[m*n];\\n        vector<long long> dp(m*n);\\n        vector<bool> vis(m*n,false);\\n        int dr[4]={1,0,-1,0};\\n        int dc[4]={0,1,0,-1};\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int node=n*i+j;\\n                for(int k=0;k<4;k++){  //creating a increasing graph\\n                    int ni=i+dr[k];\\n                    int nj=j+dc[k];\\n                    if(ni>=0 and nj>=0 and ni<m and nj<n){\\n                        int new_node=n*ni+nj;\\n                        if(matrix[ni][nj]>matrix[i][j]){\\n                            adj[node].push_back(new_node);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<m*n;i++){\\n            if(!vis[i]){\\n                dfs(dp,vis,adj,i);  //DFS traversal\\n            }\\n        }\\n\\n        long long ans = 0;\\n\\n        for(int i=0;i<m*n;i++){\\n            ans = (ans+dp[i])%mod;   //finding the sum\\n        }\\n\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497321,
                "title": "simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int dfs(pair<int,int>cur,vector<vector<int>>&grid,vector<vector<int>>&dp ,int left)\\n    {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curx=cur.first;\\n        int cury=cur.second;\\n        if(curx<0 || curx>=row || cury<0 || cury>=col || grid[curx][cury]<=left)return 0;\\n        if(dp[curx][cury]!=-1)return dp[curx][cury];\\n        \\n        int c1=dfs({curx-1,cury},grid,dp,grid[curx][cury]);\\n        int c2=dfs({curx+1,cury},grid,dp,grid[curx][cury]);\\n        int c3=dfs({curx,cury-1},grid,dp,grid[curx][cury]);\\n        int c4=dfs({curx,cury+1},grid,dp,grid[curx][cury]);\\n        return dp[curx][cury]=(((1+c1)%mod+(c2+c3)%mod)%mod+c4)%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<vector<int>>dp(row,vector<int>(col,-1));\\n        \\n        int ans=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    dfs({i,j},grid,dp,-1);\\n                }\\n                ans=(ans+dp[i][j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9 + 7;\\n    int dfs(pair<int,int>cur,vector<vector<int>>&grid,vector<vector<int>>&dp ,int left)\\n    {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        int curx=cur.first;\\n        int cury=cur.second;\\n        if(curx<0 || curx>=row || cury<0 || cury>=col || grid[curx][cury]<=left)return 0;\\n        if(dp[curx][cury]!=-1)return dp[curx][cury];\\n        \\n        int c1=dfs({curx-1,cury},grid,dp,grid[curx][cury]);\\n        int c2=dfs({curx+1,cury},grid,dp,grid[curx][cury]);\\n        int c3=dfs({curx,cury-1},grid,dp,grid[curx][cury]);\\n        int c4=dfs({curx,cury+1},grid,dp,grid[curx][cury]);\\n        return dp[curx][cury]=(((1+c1)%mod+(c2+c3)%mod)%mod+c4)%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        vector<vector<int>>dp(row,vector<int>(col,-1));\\n        \\n        int ans=0;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                {\\n                    dfs({i,j},grid,dp,-1);\\n                }\\n                ans=(ans+dp[i][j])%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483586,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\n#define e 1000000007\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint dfs(int **grid,int gridSize,int *gridColSize,int row,int col,int prevval,int *res,int **seen){\\n    if(row<0 || row>=gridSize || col <0 || col>=*gridColSize || grid[row][col]<=prevval){\\n        return 0;\\n    }\\n    \\n    if(seen[row][col]){\\n        return seen[row][col];\\n    }\\n    int temp=1;\\n    temp+=dfs(grid,gridSize,gridColSize,row+1,col,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row-1,col,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row,col+1,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row-1,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row-1,col+1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row+1,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row+1,col+1,grid[row][col],res,seen);\\n    temp=temp%e;\\n \\n    seen[row][col]=temp;\\n    return seen[row][col];\\n}\\nint countPaths(int** grid, int gridSize, int* gridColSize){\\n    int **seen=(int**)malloc(sizeof(int*)*gridSize);\\n    for(int i=0;i<gridSize;i++){\\n        seen[i]=calloc(*gridColSize,sizeof(int));\\n    }\\n    int res=0;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<*gridColSize;j++){\\n            \\n            if(seen[i][j]==0){\\n                seen[i][j]=dfs(grid,gridSize,gridColSize,i,j,-1,&res,seen);\\n            }\\n            \\n            // printf(\"row : %d | col %d | res :%d\\\\n\",i,j,seen[i][j]);\\n            res=(res+seen[i][j])%e;\\n            \\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define e 1000000007\\nint max(int a,int b){\\n    return a>b?a:b;\\n}\\nint dfs(int **grid,int gridSize,int *gridColSize,int row,int col,int prevval,int *res,int **seen){\\n    if(row<0 || row>=gridSize || col <0 || col>=*gridColSize || grid[row][col]<=prevval){\\n        return 0;\\n    }\\n    \\n    if(seen[row][col]){\\n        return seen[row][col];\\n    }\\n    int temp=1;\\n    temp+=dfs(grid,gridSize,gridColSize,row+1,col,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row-1,col,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row,col+1,grid[row][col],res,seen);\\n    temp+=dfs(grid,gridSize,gridColSize,row,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row-1,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row-1,col+1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row+1,col-1,grid[row][col],res,seen);\\n    // temp+=dfs(grid,gridSize,gridColSize,row+1,col+1,grid[row][col],res,seen);\\n    temp=temp%e;\\n \\n    seen[row][col]=temp;\\n    return seen[row][col];\\n}\\nint countPaths(int** grid, int gridSize, int* gridColSize){\\n    int **seen=(int**)malloc(sizeof(int*)*gridSize);\\n    for(int i=0;i<gridSize;i++){\\n        seen[i]=calloc(*gridColSize,sizeof(int));\\n    }\\n    int res=0;\\n    for(int i=0;i<gridSize;i++){\\n        for(int j=0;j<*gridColSize;j++){\\n            \\n            if(seen[i][j]==0){\\n                seen[i][j]=dfs(grid,gridSize,gridColSize,i,j,-1,&res,seen);\\n            }\\n            \\n            // printf(\"row : %d | col %d | res :%d\\\\n\",i,j,seen[i][j]);\\n            res=(res+seen[i][j])%e;\\n            \\n        }\\n    }\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376305,
                "title": "easy-imlementation-dp-memoization-masterstroke-used",
                "content": "# Intuition\\nusing simple dp\\nsome key points\\n\\nwe do not use visited 2d array , as for this problem we can\\'t go back to from where we already visited as because we are looking for increasing and current val is always greater than visited one ,so no stack overflow.\\n\\n# Approach\\nfor index i,j we make dp[i][j]=-1; because we can use previously calculated total no. of increasing seq. from other indexes instead of making each element of dp to -1.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity:\\nfor 1st time recursion takes O(n^2) to compute dp\\nfor rest of time it takes constant time say ~O(1)\\nso it little greater than O(n^2) and less than O(nlogn)\\n\\n- Space complexity:\\n~O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n   \\n    int mod=1e9+7;\\n    long long int ankit(vector<vector<int>>& m,int i,int j){\\n\\n        if(i<0 || j<0 || i>=m.size() || j>=m[0].size() ) return 0;\\n        \\n        long long int a1=0,a2=0,a3=0,a4=0;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n       \\n\\nif(i-1>=0 && j>=0 && i-1<m.size() && j<m[0].size() && m[i][j]<m[i-1][j]) a1=1+ankit(m,i-1,j)%mod;\\nif(i+1>=0 && j>=0 && i+1<m.size() && j<m[0].size() && m[i][j]<m[i+1][j]) a2=1+ankit(m,i+1,j)%mod;\\nif(i>=0 && j+1>=0 && i<m.size() && j+1<m[0].size() && m[i][j]<m[i][j+1]) a3=1+ankit(m,i,j+1)%mod;\\nif(i>=0 && j-1>=0 && i<m.size() && j-1<m[0].size() && m[i][j]<m[i][j-1]) a4=1+ankit(m,i,j-1)%mod;\\n\\n        return dp[i][j]=(a1+a2+a3+a4)%mod;\\n    }\\n\\n\\n    int countPaths(vector<vector<int>>& m) {\\n        memset(dp,-1,sizeof(dp));\\n        cout<<m.size()<<\" \"<<m[0].size()<<endl;\\n        long long int ans=0;\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                // memset(dp,-1,sizeof(dp));\\n              \\n                dp[i][j]=-1;\\n                ans=(ans+ankit(m,i,j)+1)%mod;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1002][1002];\\n   \\n    int mod=1e9+7;\\n    long long int ankit(vector<vector<int>>& m,int i,int j){\\n\\n        if(i<0 || j<0 || i>=m.size() || j>=m[0].size() ) return 0;\\n        \\n        long long int a1=0,a2=0,a3=0,a4=0;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n       \\n\\nif(i-1>=0 && j>=0 && i-1<m.size() && j<m[0].size() && m[i][j]<m[i-1][j]) a1=1+ankit(m,i-1,j)%mod;\\nif(i+1>=0 && j>=0 && i+1<m.size() && j<m[0].size() && m[i][j]<m[i+1][j]) a2=1+ankit(m,i+1,j)%mod;\\nif(i>=0 && j+1>=0 && i<m.size() && j+1<m[0].size() && m[i][j]<m[i][j+1]) a3=1+ankit(m,i,j+1)%mod;\\nif(i>=0 && j-1>=0 && i<m.size() && j-1<m[0].size() && m[i][j]<m[i][j-1]) a4=1+ankit(m,i,j-1)%mod;\\n\\n        return dp[i][j]=(a1+a2+a3+a4)%mod;\\n    }\\n\\n\\n    int countPaths(vector<vector<int>>& m) {\\n        memset(dp,-1,sizeof(dp));\\n        cout<<m.size()<<\" \"<<m[0].size()<<endl;\\n        long long int ans=0;\\n        for(int i=0;i<m.size();i++){\\n            for(int j=0;j<m[0].size();j++){\\n                // memset(dp,-1,sizeof(dp));\\n              \\n                dp[i][j]=-1;\\n                ans=(ans+ankit(m,i,j)+1)%mod;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2879440,
                "title": "simple-solution-by-recursion",
                "content": "*  solution based on the problem Longest Increasing Path in a Matrix\\n# Code\\n```\\nclass Solution {\\n    long long mod=1000000007;\\n    long long solve(int i,int j,int& m,int &n,vector<vector<int>>& grid,vector<vector<int>>& dp,int history){\\n        //base case\\n        if(i>=m or j>=n or i<0 or j<0 or grid[i][j]<=history){\\n            return 0;\\n        }\\n        if(dp[i][j]!=(-1)){return dp[i][j];}\\n        long long ans=0;\\n        ans+=solve(i,j-1,m,n,grid,dp,grid[i][j]); //left\\n        ans=ans%mod;\\n        ans+=solve(i,j+1,m,n,grid,dp,grid[i][j]); //right\\n        ans=ans%mod;\\n        ans+=solve(i-1,j,m,n,grid,dp,grid[i][j]); //top\\n        ans=ans%mod;\\n        ans+=solve(i+1,j,m,n,grid,dp,grid[i][j]);  //bottom\\n        ans=ans%mod;\\n\\n        return dp[i][j]=ans+1;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        long long ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=solve(i,j,m,n,grid,dp,-1);\\n                ans=ans%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# PLEASE UPVOTE\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    long long mod=1000000007;\\n    long long solve(int i,int j,int& m,int &n,vector<vector<int>>& grid,vector<vector<int>>& dp,int history){\\n        //base case\\n        if(i>=m or j>=n or i<0 or j<0 or grid[i][j]<=history){\\n            return 0;\\n        }\\n        if(dp[i][j]!=(-1)){return dp[i][j];}\\n        long long ans=0;\\n        ans+=solve(i,j-1,m,n,grid,dp,grid[i][j]); //left\\n        ans=ans%mod;\\n        ans+=solve(i,j+1,m,n,grid,dp,grid[i][j]); //right\\n        ans=ans%mod;\\n        ans+=solve(i-1,j,m,n,grid,dp,grid[i][j]); //top\\n        ans=ans%mod;\\n        ans+=solve(i+1,j,m,n,grid,dp,grid[i][j]);  //bottom\\n        ans=ans%mod;\\n\\n        return dp[i][j]=ans+1;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        long long ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=solve(i,j,m,n,grid,dp,-1);\\n                ans=ans%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816552,
                "title": "java-easy-solution-dfs-memoization",
                "content": "**Approach:**\\n* For each and every element in the matrix, call & use DFS traversal to find the number of possible increasing paths starting from that index.\\n* DFS Traversal: \\n\\t* In the DFS traversal, we must traverse in 4 directions: left, right, up & down. Store these values found using recursion and r**eturn the final result by adding them and an extra 1 for the current element.**\\n\\t* The base case for the DFS would be same as general, but the only condition to also be added is to **check whether the current element is strictly greater than the previous element** from where we came from.\\n\\nCode:\\n```\\nclass Solution {\\n    int mod = (int)(1e9+7);\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        for(int[] arr: dp){\\n            Arrays.fill(arr, -1);\\n        }\\n        int paths = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                paths = (paths+solve(grid, i, j, -1, dp))%mod;\\n            }\\n        }\\n        \\n        return paths;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int prev, int[][] dp){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int left = solve(grid, i, j-1, grid[i][j], dp);\\n        int right = solve(grid, i, j+1, grid[i][j], dp);\\n        int up = solve(grid, i-1, j, grid[i][j], dp);\\n        int down = solve(grid, i+1, j, grid[i][j], dp);\\n        \\n        return dp[i][j] = (1+left+right+up+down)%mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = (int)(1e9+7);\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dp = new int[n][m];\\n        for(int[] arr: dp){\\n            Arrays.fill(arr, -1);\\n        }\\n        int paths = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                paths = (paths+solve(grid, i, j, -1, dp))%mod;\\n            }\\n        }\\n        \\n        return paths;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int prev, int[][] dp){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]<=prev){\\n            return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int left = solve(grid, i, j-1, grid[i][j], dp);\\n        int right = solve(grid, i, j+1, grid[i][j], dp);\\n        int up = solve(grid, i-1, j, grid[i][j], dp);\\n        int down = solve(grid, i+1, j, grid[i][j], dp);\\n        \\n        return dp[i][j] = (1+left+right+up+down)%mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780376,
                "title": "c-simple-clean-solution-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    vector<pair<int,int>> dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n    vector<vector<int>> memo;\\n    int mod = 1000000007;\\npublic:\\n\\n    int solve(int i, int j, vector<vector<int>>& grid){\\n        if(memo[i][j]) return memo[i][j];\\n\\n        unsigned long long ans = 1;\\n        for(auto d : dir){\\n            int ni = i + d.first;\\n            int nj = j + d.second;\\n            if(ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[i][j] < grid[ni][nj])\\n            {\\n                ans += solve(ni, nj, grid) % mod;\\n            }\\n        }\\n        return memo[i][j] = ans % mod;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        unsigned long long ans = 0;\\n        memo.resize(grid.size(), vector<int>(grid[0].size()));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                ans += (solve(i, j, grid) % mod);\\n            }\\n        }\\n        return ans % mod;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<pair<int,int>> dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n    vector<vector<int>> memo;\\n    int mod = 1000000007;\\npublic:\\n\\n    int solve(int i, int j, vector<vector<int>>& grid){\\n        if(memo[i][j]) return memo[i][j];\\n\\n        unsigned long long ans = 1;\\n        for(auto d : dir){\\n            int ni = i + d.first;\\n            int nj = j + d.second;\\n            if(ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size() && grid[i][j] < grid[ni][nj])\\n            {\\n                ans += solve(ni, nj, grid) % mod;\\n            }\\n        }\\n        return memo[i][j] = ans % mod;\\n    }\\n\\n    int countPaths(vector<vector<int>>& grid) {\\n        unsigned long long ans = 0;\\n        memo.resize(grid.size(), vector<int>(grid[0].size()));\\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                ans += (solve(i, j, grid) % mod);\\n            }\\n        }\\n        return ans % mod;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691127,
                "title": "c-priority-queue-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> xx = {0,0,-1,1};\\n    vector<int> yy = {1,-1,0,0};\\n    int mod = 1000000007;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0,dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                pq.push({grid[i][j],{i,j}});\\n        while(!pq.empty()){\\n            int x = pq.top().second.first, y = pq.top().second.second;\\n            dp[x][y] = 1;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx = x + xx[i],ny = y + yy[i];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && (grid[nx][ny] > grid[x][y]))\\n                    dp[x][y] = (dp[x][y] + dp[nx][ny])%mod;\\n            }\\n            ans = (ans + dp[x][y])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> xx = {0,0,-1,1};\\n    vector<int> yy = {1,-1,0,0};\\n    int mod = 1000000007;\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size(),m = grid[0].size(),ans = 0,dp[n][m];\\n        memset(dp,0,sizeof(dp));\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                pq.push({grid[i][j],{i,j}});\\n        while(!pq.empty()){\\n            int x = pq.top().second.first, y = pq.top().second.second;\\n            dp[x][y] = 1;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx = x + xx[i],ny = y + yy[i];\\n                if(nx>=0 && nx<n && ny>=0 && ny<m && (grid[nx][ny] > grid[x][y]))\\n                    dp[x][y] = (dp[x][y] + dp[nx][ny])%mod;\\n            }\\n            ans = (ans + dp[x][y])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624686,
                "title": "short-easy-solution-c-dp-heap-based-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool check(int i,int j,int m,int n)\\n\\t\\t{\\n\\t\\t\\treturn i>=0 && i<m && j>=0 &&j<n;\\n\\t\\t}\\n\\t\\tint countPaths(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tpriority_queue<pair<int,int>> pq;\\n\\t\\t\\tfor(int i=0;i<m;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint val=i*n+j;\\n\\t\\t\\t\\t\\tpq.push({-grid[i][j],val});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tint mod=1e9 + 7;\\n\\t\\t\\tvector<vector<int>> dp(m,vector<int>(n,1));\\n\\t\\t\\twhile(pq.size()>0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint i=pq.top().second/n;\\n\\t\\t\\t\\tint j=pq.top().second%n;\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tint x[]={1,0,-1,0};\\n\\t\\t\\t\\tint y[]={0,-1,0,1};\\n\\n\\t\\t\\t\\tfor(int l=0;l<4;l++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(check(i+x[l],j+y[l],m,n) && grid[i+x[l]][j+y[l]]<grid[i][j] )\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdp[i][j]+=dp[i+x[l]][j+y[l]];\\n\\t\\t\\t\\t\\t\\tdp[i][j]%=mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans=(ans+dp[i][j])%mod;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool check(int i,int j,int m,int n)\\n\\t\\t{\\n\\t\\t\\treturn i>=0 && i<m && j>=0 &&j<n;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2566560,
                "title": "c-no-tension-simply-apply-plain-dfs-and-do-memoization-100-faster-clean-code",
                "content": "Do not Overthink, this is a plain dfs problem \\nApply simply (DFS + DP)\\n\\n----\\n**1. Simple DFS or Recursion :**\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<int>dir = {-1,0,1,0,-1};\\n    int dfs(int i, int j, vector<vector<int>>&grid, int m, int n)\\n    {\\n        int ans = 1;\\n        for(int k=0;k<4;k++)\\n        {    \\n            int ni = i+dir[k];\\n            int nj = j+dir[k+1];\\n            if(ni>=0 and ni<m and nj>=0 and nj<n and grid[i][j] < grid[ni][nj]){\\n                ans = (ans%mod + dfs(ni, nj, grid, m, n)%mod)%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        long long ans=0;\\n        \\n        // start from every cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                ans = (ans%mod + dfs(i, j, grid, m, n)%mod)%mod;\\n            }\\n        } \\n        return ans; \\n    }\\n};\\n```\\n\\n**2. Recursion + Memo**\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<int>dir = {-1,0,1,0,-1};\\n    int dfs(int i, int j, vector<vector<int>>&grid, int m, int n, vector<vector<int>>&dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans = 1;\\n        for(int k=0;k<4;k++)\\n        {    \\n            int ni = i+dir[k];\\n            int nj = j+dir[k+1];\\n            if(ni>=0 and ni<m and nj>=0 and nj<n and grid[i][j] < grid[ni][nj]){\\n                ans = (ans%mod + dfs(ni, nj, grid, m, n, dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i][j] = ans%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,-1));\\n        long long ans=0;\\n        \\n        // start from every cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                ans = (ans%mod + dfs(i, j, grid, m, n, dp)%mod)%mod;\\n            }\\n        } \\n        return ans; \\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<int>dir = {-1,0,1,0,-1};\\n    int dfs(int i, int j, vector<vector<int>>&grid, int m, int n)\\n    {\\n        int ans = 1;\\n        for(int k=0;k<4;k++)\\n        {    \\n            int ni = i+dir[k];\\n            int nj = j+dir[k+1];\\n            if(ni>=0 and ni<m and nj>=0 and nj<n and grid[i][j] < grid[ni][nj]){\\n                ans = (ans%mod + dfs(ni, nj, grid, m, n)%mod)%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        long long ans=0;\\n        \\n        // start from every cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                ans = (ans%mod + dfs(i, j, grid, m, n)%mod)%mod;\\n            }\\n        } \\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9+7;\\n    vector<int>dir = {-1,0,1,0,-1};\\n    int dfs(int i, int j, vector<vector<int>>&grid, int m, int n, vector<vector<int>>&dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans = 1;\\n        for(int k=0;k<4;k++)\\n        {    \\n            int ni = i+dir[k];\\n            int nj = j+dir[k+1];\\n            if(ni>=0 and ni<m and nj>=0 and nj<n and grid[i][j] < grid[ni][nj]){\\n                ans = (ans%mod + dfs(ni, nj, grid, m, n, dp)%mod)%mod;\\n            }\\n        }\\n        return dp[i][j] = ans%mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n,-1));\\n        long long ans=0;\\n        \\n        // start from every cell\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                ans = (ans%mod + dfs(i, j, grid, m, n, dp)%mod)%mod;\\n            }\\n        } \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485433,
                "title": "java-dp-memoization",
                "content": "**Observation**\\nsimpler case consider a ```1D array a = [1,2,3,4,5,2,1,4,5,6]```\\nwe maintain a ```2D array``` array ```dp``` where ```d[i]``` is the count of all increasing paths starting at ```ith``` index i.e. ```a[i]```. \\nthis becomes a variation of [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/). first lets build the dp array \\n```\\narr = [1,2,3,4,5,2,1,4,5,6]\\ndp =  [1,2,3,4,5,1,1,2,3,4]\\n```\\n```dp[i]``` is the count of all increasing paths starting at ```ith``` index i.e. ```a[i]```.\\nnow we just have to return the sum of all values of the ```dp``` array.\\n\\n****\\n\\n**Approach 1 (Memoization)**\\nThe idea is to use dynamic programming. Maintain the 2D matrix, ```dp```.\\nwhere, dp[i][j] store the count of all the increasing paths that starts at the ```grid[i][j]```. i.e. count of all increasing sequence for submatrix starting from the ```ith``` row and ```jth``` column. \\n\\nLet the count of increasing sub sequence values for ```grid[i+1][j]```, ```grid[i][j+1]```, ```grid[i-1][j]``` and ```grid[i][j-1]``` be known already as ```v1, v2, v3, v4``` respectively. Then the value for ```grid[i][j]``` will be ```v1 + v2 + v3 + v4 + 1``` only if ```grid[i][j] > grid[i-1][j] && grid[i][j+1] && grid[i+1][j] && grid[i][j-1]```.\\n\\ngeneralizing we can say that if ```grid[i][j] < grid[k][l] then dp[i][j] += dp[k][l]```.\\n****\\n* Notice that we will not have any cycle in any increasing path of the grid.\\n****\\n\\n**Algorithm**\\n\\n* Do DFS from every cell\\n* Compare every 4 direction and skip cells that are out of boundary or smaller\\n* Use ```grid[x][y] <= grid[i][j]``` so we don\\'t need a ```visited[m][n]``` array\\n* The key is to cache the distance because it\\'s highly possible to revisit a cell.\\n\\n****\\n**Code**\\n```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int answer = 0;\\n        int[][] memo = new int[n][m];\\n        //  memo[i][j] = count of total paths starting at grid[i][j]\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                answer = (answer + helper(grid, i, j, memo)) % MOD;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};   //  direcition offsets\\n    \\n    public int helper(int[][] grid, int row, int col, int[][] memo) {\\n        if (memo[row][col] != 0) {\\n            return memo[row][col];\\n        }\\n        int answer = 0;\\n        //  iterating on all the neighbors\\n        for (int[] d : dirs) {\\n            int nextRow = row + d[0];\\n            int nextCol = col + d[1];\\n            if (isValid(grid, row, col, nextRow, nextCol)) {\\n                answer = (answer + helper(grid, nextRow, nextCol, memo)) % MOD;\\n            }\\n        }\\n        return memo[row][col] = answer + 1;\\n    }\\n    \\n    public boolean isValid(int[][] grid, int row, int col, int nextRow, int nextCol) {\\n        boolean isInBounds = nextRow >= 0 && nextCol >= 0 && nextRow < grid.length && nextCol < grid[0].length;\\n        boolean validNbr = isInBounds && grid[row][col] < grid[nextRow][nextCol];\\n        return isInBounds && validNbr;\\n    }\\n}\\n```\\n\\n****\\n**Complexity Analysis**\\n\\n*Time Complexity*\\n* Let N and M be the dimensions of the grid we know that we won\\'t have any loops in any increasing path sequence.\\n* Total number of unique states are going to be ```row * col``` so time complexity will be ```O(N*M)```.\\n\\n*Space Complexity*\\n* We are using an aditional ```dp``` array to store the total number of increasing paths that starts at the ```grid[i][j]```. So space Complexity is ```O(N*M)```.",
                "solutionTags": [],
                "code": "```1D array a = [1,2,3,4,5,2,1,4,5,6]```\n```2D array```\n```dp```\n```d[i]```\n```ith```\n```a[i]```\n```\\narr = [1,2,3,4,5,2,1,4,5,6]\\ndp =  [1,2,3,4,5,1,1,2,3,4]\\n```\n```dp[i]```\n```ith```\n```a[i]```\n```dp```\n```dp```\n```grid[i][j]```\n```ith```\n```jth```\n```grid[i+1][j]```\n```grid[i][j+1]```\n```grid[i-1][j]```\n```grid[i][j-1]```\n```v1, v2, v3, v4```\n```grid[i][j]```\n```v1 + v2 + v3 + v4 + 1```\n```grid[i][j] > grid[i-1][j] && grid[i][j+1] && grid[i+1][j] && grid[i][j-1]```\n```grid[i][j] < grid[k][l] then dp[i][j] += dp[k][l]```\n```grid[x][y] <= grid[i][j]```\n```visited[m][n]```\n```\\nclass Solution {\\n    int MOD = 1_000_000_007;\\n    public int countPaths(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int answer = 0;\\n        int[][] memo = new int[n][m];\\n        //  memo[i][j] = count of total paths starting at grid[i][j]\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                answer = (answer + helper(grid, i, j, memo)) % MOD;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};   //  direcition offsets\\n    \\n    public int helper(int[][] grid, int row, int col, int[][] memo) {\\n        if (memo[row][col] != 0) {\\n            return memo[row][col];\\n        }\\n        int answer = 0;\\n        //  iterating on all the neighbors\\n        for (int[] d : dirs) {\\n            int nextRow = row + d[0];\\n            int nextCol = col + d[1];\\n            if (isValid(grid, row, col, nextRow, nextCol)) {\\n                answer = (answer + helper(grid, nextRow, nextCol, memo)) % MOD;\\n            }\\n        }\\n        return memo[row][col] = answer + 1;\\n    }\\n    \\n    public boolean isValid(int[][] grid, int row, int col, int nextRow, int nextCol) {\\n        boolean isInBounds = nextRow >= 0 && nextCol >= 0 && nextRow < grid.length && nextCol < grid[0].length;\\n        boolean validNbr = isInBounds && grid[row][col] < grid[nextRow][nextCol];\\n        return isInBounds && validNbr;\\n    }\\n}\\n```\n```row * col```\n```O(N*M)```\n```dp```\n```grid[i][j]```\n```O(N*M)```",
                "codeTag": "Java"
            },
            {
                "id": 2473518,
                "title": "java-dfs-dp-similar-to-leetcode-329",
                "content": "```\\nclass Solution {\\n     int[][]dir = {{1,0} , {0,1} , {-1,0}, {0,-1}};\\n     int mod = (int)1e9+7;\\n    public int countPaths(int[][] matrix) {\\n       \\n         int n = matrix.length , m = matrix[0].length;\\n        if(matrix==null)return 0;\\n        if(n==0 || m==0)return 0;\\n        int dp[][] = new int[n][m];\\n        int max = 0;\\n        for(int i =0 ; i<n ; i++){\\n            for(int j = 0;j<m;j++){\\n                int val = helper(i , j , matrix , dp , n , m);\\n                max = (max+val)%mod;\\n            }\\n        }\\n        return max%mod;\\n    }\\n    public int helper(int i , int j  , int[][]matrix , int[][]dp , int n , int m){\\n        if(dp[i][j]>0)return dp[i][j];\\n        int curval = 1;\\n        for(int d = 0;d<dir.length ;d++){\\n            int r = i+dir[d][0];\\n            int c = j+dir[d][1];\\n            if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[i][j]){\\n                 curval += helper(r, c, matrix , dp , n,m)%mod;\\n            }\\n        }\\n        dp[i][j] = curval%mod;\\n        return curval;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n     int[][]dir = {{1,0} , {0,1} , {-1,0}, {0,-1}};\\n     int mod = (int)1e9+7;\\n    public int countPaths(int[][] matrix) {\\n       \\n         int n = matrix.length , m = matrix[0].length;\\n        if(matrix==null)return 0;\\n        if(n==0 || m==0)return 0;\\n        int dp[][] = new int[n][m];\\n        int max = 0;\\n        for(int i =0 ; i<n ; i++){\\n            for(int j = 0;j<m;j++){\\n                int val = helper(i , j , matrix , dp , n , m);\\n                max = (max+val)%mod;\\n            }\\n        }\\n        return max%mod;\\n    }\\n    public int helper(int i , int j  , int[][]matrix , int[][]dp , int n , int m){\\n        if(dp[i][j]>0)return dp[i][j];\\n        int curval = 1;\\n        for(int d = 0;d<dir.length ;d++){\\n            int r = i+dir[d][0];\\n            int c = j+dir[d][1];\\n            if(r>=0 && c>=0 && r<n && c<m && matrix[r][c]>matrix[i][j]){\\n                 curval += helper(r, c, matrix , dp , n,m)%mod;\\n            }\\n        }\\n        dp[i][j] = curval%mod;\\n        return curval;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448764,
                "title": "2328-python",
                "content": "\\tclass Solution:\\n\\t\\tdef countPaths(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\tdire = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tdef invalid(i,j):\\n\\t\\t\\t\\treturn i <0 or j <0 or i >= m or j >= n \\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tans = 1\\n\\n\\t\\t\\t\\tfor dx,dy in dire:\\n\\t\\t\\t\\t\\tx= i+dx\\n\\t\\t\\t\\t\\ty = j+dy\\n\\n\\t\\t\\t\\t\\tif invalid(x,y):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif grid[x][y] <= grid[i][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tans += dfs(x,y)%mod\\n\\n\\t\\t\\t\\treturn ans%mod\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tans += dfs(i,j)\\n\\n\\t\\t\\treturn ans%mod\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef countPaths(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\tdire = [(1,0),(0,1),(-1,0),(0,-1)]\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tdef invalid(i,j):\\n\\t\\t\\t\\treturn i <0 or j <0 or i >= m or j >= n \\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tans = 1\\n\\n\\t\\t\\t\\tfor dx,dy in dire:\\n\\t\\t\\t\\t\\tx= i+dx\\n\\t\\t\\t\\t\\ty = j+dy\\n\\n\\t\\t\\t\\t\\tif invalid(x,y):\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tif grid[x][y] <= grid[i][j]:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\tans += dfs(x,y)%mod\\n\\n\\t\\t\\t\\treturn ans%mod\\n\\n\\t\\t\\tans = 0\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tans += dfs(i,j)\\n\\n\\t\\t\\treturn ans%mod\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2409450,
                "title": "c-simple-dp-dfs-memo-solution-with-comments",
                "content": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    // approach:\\n    // total number of possible valid paths starting from nums[i][j]\\n    // = 1 + sum(number of paths starting from neighboring cells if neighbor>nums[i][j])\\n    // (1 is the path [nums[i][j]] itself)\\n    // case: [4,5,6,8,3]\\n    // number of paths from 5 => [5],[5,6],[5,6,8]\\n    // and number of paths from 4 => [4], [4,5], [4,5,6], [4,5,6,8]\\n    ll dp[1001][1001],m,n,mod=pow(10,9)+7;\\n    ll dfs(int i,int j,vector<vector<int>>&nums){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=1; // the path with only [nums[i][j]];\\n        if(i<m-1 && nums[i][j]<nums[i+1][j])\\n            ans+=dfs(i+1,j,nums); \\n        if(i>0 && nums[i][j]<nums[i-1][j])\\n            ans+=dfs(i-1,j,nums);\\n        if(j<n-1 && nums[i][j]<nums[i][j+1])\\n            ans+=dfs(i,j+1,nums);\\n        if(j>0 && nums[i][j]<nums[i][j-1])\\n            ans+=dfs(i,j-1,nums);\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        m=nums.size(),n=nums[0].size();\\n        ll ans=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                ans+=dfs(i,j,nums);\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    // approach:\\n    // total number of possible valid paths starting from nums[i][j]\\n    // = 1 + sum(number of paths starting from neighboring cells if neighbor>nums[i][j])\\n    // (1 is the path [nums[i][j]] itself)\\n    // case: [4,5,6,8,3]\\n    // number of paths from 5 => [5],[5,6],[5,6,8]\\n    // and number of paths from 4 => [4], [4,5], [4,5,6], [4,5,6,8]\\n    ll dp[1001][1001],m,n,mod=pow(10,9)+7;\\n    ll dfs(int i,int j,vector<vector<int>>&nums){\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int ans=1; // the path with only [nums[i][j]];\\n        if(i<m-1 && nums[i][j]<nums[i+1][j])\\n            ans+=dfs(i+1,j,nums); \\n        if(i>0 && nums[i][j]<nums[i-1][j])\\n            ans+=dfs(i-1,j,nums);\\n        if(j<n-1 && nums[i][j]<nums[i][j+1])\\n            ans+=dfs(i,j+1,nums);\\n        if(j>0 && nums[i][j]<nums[i][j-1])\\n            ans+=dfs(i,j-1,nums);\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        m=nums.size(),n=nums[0].size();\\n        ll ans=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                ans+=dfs(i,j,nums);\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359832,
                "title": "c-solution-time-o-m-n-memory-o-m-n-easy-to-understand-recursion-memoization",
                "content": "```C#\\npublic class Solution {\\n    private static int[] _directionsX = new[] { 1, -1, 0, 0 };\\n    private static int[] _directionsY = new[] { 0, 0, 1, -1 };\\n    private static int _mod = 1000000007;\\n    \\n    public int CountPaths(int[][] grid) {\\n        Dictionary<(int Row, int Col), int> memo = new ();\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                count = (count + Solve(i, j)) % _mod;\\n            }\\n        }\\n        \\n        return count;\\n        \\n        int Solve(int row, int col) {\\n            var id = (row, col);\\n            if (memo.TryGetValue(id, out var memoizedResult)) return memoizedResult;\\n            \\n            int ans = 1;\\n            for (int i = 0; i < 4; i++) {\\n                int newRow = row + _directionsX[i], newCol = col + _directionsY[i];\\n                if (newRow >= 0 && newRow < grid.Length && newCol >= 0 && newCol < grid[row].Length && grid[newRow][newCol] > grid[row][col])\\n                    ans = (ans + Solve(newRow, newCol)) % _mod;\\n            }\\n            \\n            memo[id] = ans;\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static int[] _directionsX = new[] { 1, -1, 0, 0 };\\n    private static int[] _directionsY = new[] { 0, 0, 1, -1 };\\n    private static int _mod = 1000000007;\\n    \\n    public int CountPaths(int[][] grid) {\\n        Dictionary<(int Row, int Col), int> memo = new ();\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[i].Length; j++) {\\n                count = (count + Solve(i, j)) % _mod;\\n            }\\n        }\\n        \\n        return count;\\n        \\n        int Solve(int row, int col) {\\n            var id = (row, col);\\n            if (memo.TryGetValue(id, out var memoizedResult)) return memoizedResult;\\n            \\n            int ans = 1;\\n            for (int i = 0; i < 4; i++) {\\n                int newRow = row + _directionsX[i], newCol = col + _directionsY[i];\\n                if (newRow >= 0 && newRow < grid.Length && newCol >= 0 && newCol < grid[row].Length && grid[newRow][newCol] > grid[row][col])\\n                    ans = (ans + Solve(newRow, newCol)) % _mod;\\n            }\\n            \\n            memo[id] = ans;\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331620,
                "title": "c-dp-dfs-simplest-with-comments",
                "content": "First we want to store the Number of Increasing Paths for each grid, this will be simply given by summation of all possible nearest grid\\'s which is greater than this number and storing the number of increasing path...\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int dfs(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp,int mv)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<=mv)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int v1=dfs(grid,i+1,j,dp,grid[i][j]);\\n        int v2=dfs(grid,i,j+1,dp,grid[i][j]);\\n        int v3=dfs(grid,i,j-1,dp,grid[i][j]);\\n        int v4=dfs(grid,i-1,j,dp,grid[i][j]);\\n        long long x=(1+v1+v2+v3+v4)%mod;\\n        return dp[i][j]=x;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                    ans=(ans+dfs(grid,i,j,dp,INT_MIN))%mod;    //we first time passes current value as INT_MIN so that it count itself atleast..\\n                else\\n                    ans=(ans+dp[i][j])%mod;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    int dfs(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp,int mv)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]<=mv)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int v1=dfs(grid,i+1,j,dp,grid[i][j]);\\n        int v2=dfs(grid,i,j+1,dp,grid[i][j]);\\n        int v3=dfs(grid,i,j-1,dp,grid[i][j]);\\n        int v4=dfs(grid,i-1,j,dp,grid[i][j]);\\n        long long x=(1+v1+v2+v3+v4)%mod;\\n        return dp[i][j]=x;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-1)\\n                    ans=(ans+dfs(grid,i,j,dp,INT_MIN))%mod;    //we first time passes current value as INT_MIN so that it count itself atleast..\\n                else\\n                    ans=(ans+dp[i][j])%mod;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329998,
                "title": "c-dfs-dp-number-of-increasing-paths-in-grid",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    int n,m;\\n    const int MOD = 1e9+7;\\n    int dp[1010][1010];\\n    int rec(int x, int y, vector<vector<int>>&g){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 1;\\n        for(int i=0; i<4; i++){\\n            int xx = x+dx[i], yy = y+dy[i];\\n            if(xx<0 || yy<0 || xx>=n || yy>=m || g[xx][yy]<=g[x][y]) continue;\\n            ans = ans + rec(xx,yy,g)%MOD;\\n            ans %= MOD;\\n        }\\n        return dp[x][y]=ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<=m; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = ans + rec(i,j,grid);\\n                ans %= MOD;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    int n,m;\\n    const int MOD = 1e9+7;\\n    int dp[1010][1010];\\n    int rec(int x, int y, vector<vector<int>>&g){\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 1;\\n        for(int i=0; i<4; i++){\\n            int xx = x+dx[i], yy = y+dy[i];\\n            if(xx<0 || yy<0 || xx>=n || yy>=m || g[xx][yy]<=g[x][y]) continue;\\n            ans = ans + rec(xx,yy,g)%MOD;\\n            ans %= MOD;\\n        }\\n        return dp[x][y]=ans;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<=n; i++){\\n            for(int j=0; j<=m; j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans = ans + rec(i,j,grid);\\n                ans %= MOD;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295834,
                "title": "python3-solution-dp-dfs",
                "content": "`Time Complexity` : `O(nm)`\\n`Space Complexity` : `O(nm)`\\n```\\nclass Solution:\\n    def countPaths(self, grid):\\n        n, m, mod = len(grid), len(grid[0]), 10**9 + 7\\n        dp = [[-1] * m for _ in range(n)]\\n        def dfs(i, j):\\n            if dp[i][j] != -1: return dp[i][j]\\n            dp[i][j] = 1\\n            for r,c in ((0,1),(0,-1),(1,0),(-1,0)):\\n                if 0 <= i+r < n and 0 <= j+c < m and grid[i][j] < grid[i+r][j+c]:\\n                    dp[i][j] += dfs(i+r, j+c)\\n            return dp[i][j]\\n        return sum(sum(dfs(i,j) for i in range(n)) % mod for j in range(m)) % mod\\n```\\n**Similar Question** : [Longest Increasing Path in a Matrix](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid):\\n        n, m, mod = len(grid), len(grid[0]), 10**9 + 7\\n        dp = [[-1] * m for _ in range(n)]\\n        def dfs(i, j):\\n            if dp[i][j] != -1: return dp[i][j]\\n            dp[i][j] = 1\\n            for r,c in ((0,1),(0,-1),(1,0),(-1,0)):\\n                if 0 <= i+r < n and 0 <= j+c < m and grid[i][j] < grid[i+r][j+c]:\\n                    dp[i][j] += dfs(i+r, j+c)\\n            return dp[i][j]\\n        return sum(sum(dfs(i,j) for i in range(n)) % mod for j in range(m)) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292133,
                "title": "c-simple-top-down-dp-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int M = 1e9+7;\\n    vector<vector<int>> dirs{{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>>&grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long int res = 1;\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        for(auto x:dirs){\\n            if(i+x[0] >= 0 and i +x[0] < n and j + x[1] >= 0 and j + x[1] < m and grid[i+x[0]][j+x[1]] > grid[i][j]){\\n                res += dfs(i+x[0], j+x[1], grid)%M;\\n            }\\n        }\\n        res = res%M;\\n        return dp[i][j] = (int)res;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size();\\n        dp.resize(n+1, vector<int>(m+1, -1));\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans += (dfs(i, j, grid))%M;\\n            }\\n        }\\n        ans = ans %M;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int M = 1e9+7;\\n    vector<vector<int>> dirs{{0,1}, {1,0}, {0,-1}, {-1,0}};\\n    vector<vector<int>> dp;\\n    int dfs(int i, int j, vector<vector<int>>&grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long int res = 1;\\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        for(auto x:dirs){\\n            if(i+x[0] >= 0 and i +x[0] < n and j + x[1] >= 0 and j + x[1] < m and grid[i+x[0]][j+x[1]] > grid[i][j]){\\n                res += dfs(i+x[0], j+x[1], grid)%M;\\n            }\\n        }\\n        res = res%M;\\n        return dp[i][j] = (int)res;\\n    }\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m= grid[0].size();\\n        dp.resize(n+1, vector<int>(m+1, -1));\\n        long long int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                ans += (dfs(i, j, grid))%M;\\n            }\\n        }\\n        ans = ans %M;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289391,
                "title": "java-solution-and-similar-problems",
                "content": "Traverse through all directions if the direction is valid with element > than previous element return 1+all valid directions from there. We are caching the ans in dp array\\n```\\nclass Solution {\\n    int m,n;\\n    int M = (int)(1e9+7);\\n    Integer dp[][];\\n    int dir[] = new int[]{0,-1,0,1,0};\\n    public int countPaths(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        dp = new Integer[m][n];\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=(ans+dfs(grid,i,j,0))%M;\\n                //System.out.println(ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] g,int i,int j,int prev){\\n        if(i<0 || i>=m || j<0 || j>=n) return 0;\\n        int ans=0;\\n        if(g[i][j]>prev){\\n            if(dp[i][j]!=null) return dp[i][j];\\n            for(int k=0;k<4;k++){\\n                int x = dir[k]+i;\\n                int y = dir[k+1]+j;\\n                ans=(ans+dfs(g,x,y,g[i][j]))%M;\\n            }\\n            return dp[i][j]=1+ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```\\nSimilar Problems : \\n1) https://leetcode.com/problems/out-of-boundary-paths/\\n2) https://leetcode.com/problems/max-area-of-island/ - solve this using dfs(not bfs)\\n3) https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m,n;\\n    int M = (int)(1e9+7);\\n    Integer dp[][];\\n    int dir[] = new int[]{0,-1,0,1,0};\\n    public int countPaths(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        dp = new Integer[m][n];\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=(ans+dfs(grid,i,j,0))%M;\\n                //System.out.println(ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[][] g,int i,int j,int prev){\\n        if(i<0 || i>=m || j<0 || j>=n) return 0;\\n        int ans=0;\\n        if(g[i][j]>prev){\\n            if(dp[i][j]!=null) return dp[i][j];\\n            for(int k=0;k<4;k++){\\n                int x = dir[k]+i;\\n                int y = dir[k+1]+j;\\n                ans=(ans+dfs(g,x,y,g[i][j]))%M;\\n            }\\n            return dp[i][j]=1+ans;\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266152,
                "title": "same-as-longest-increasing-path",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dp[1000][1000];\\n    \\n    int helper(int i, int j,vector<vector<int>>& matrix,int prev) {\\n       \\n        \\n        if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size() ||  matrix[i][j] <= prev) {\\n             return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n    \\n        \\n        int a = helper(i+1,j,matrix,matrix[i][j]);\\n        int b = helper(i-1,j,matrix,matrix[i][j]);\\n        int c = helper(i,j+1,matrix,matrix[i][j]);\\n        int d = helper(i,j-1,matrix,matrix[i][j]);\\n\\n        \\n        return dp[i][j] = (((a+b+c+d)%mod)+1)%mod;\\n        \\n       \\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size(), n = matrix[0].size();\\n        \\n        int ans = 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                ans = (ans+helper(i,j,matrix,-1))%mod;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1000000007;\\n    int dp[1000][1000];\\n    \\n    int helper(int i, int j,vector<vector<int>>& matrix,int prev) {\\n       \\n        \\n        if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size() ||  matrix[i][j] <= prev) {\\n             return 0;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n    \\n        \\n        int a = helper(i+1,j,matrix,matrix[i][j]);\\n        int b = helper(i-1,j,matrix,matrix[i][j]);\\n        int c = helper(i,j+1,matrix,matrix[i][j]);\\n        int d = helper(i,j-1,matrix,matrix[i][j]);\\n\\n        \\n        return dp[i][j] = (((a+b+c+d)%mod)+1)%mod;\\n        \\n       \\n    }\\n    int countPaths(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size(), n = matrix[0].size();\\n        \\n        int ans = 0;\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                ans = (ans+helper(i,j,matrix,-1))%mod;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265479,
                "title": "dp-using-dfs",
                "content": "calling the dfs for every vertex (i,j) in the matrix and adding the values of them . in order to visit every vertex only once , dp array is used where dp[i][j] is the count of number of increasing path starting from that vertex and then for every point we visit, we add its neighbours .\\n```\\n int dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n       \\n       int M=1000000007;\\n        int c=1;\\n        if((i+1)<grid.size()&&grid[i+1][j]>grid[i][j]){\\n            c=c+(dfs(i+1,j,grid,dp)%M);\\n        }\\n        if((i-1)>=0&&grid[i-1][j]>grid[i][j]){\\n            c=c+(dfs(i-1,j,grid,dp)%M);\\n        }\\n        if((j+1)<grid[0].size()&&grid[i][j+1]>grid[i][j]){\\n            c=c+(dfs(i,j+1,grid,dp)%M);\\n        }\\n        if((j-1)>=0&&grid[i][j-1]>grid[i][j]){\\n            \\n            c=c+(dfs(i,j-1,grid,dp)%M);\\n        }\\n       \\n        dp[i][j]=c;\\n        c=c%M;\\n        \\n        return c;\\n        \\n    }\\n   \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        \\n        int i,j;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n      vector<vector<int>> dp(m);\\n        int M=1000000007;\\n        int ans=0;\\n        for(i=0;i<m;i++){\\n            vector<int> v1(n);\\n            for(j=0;j<n;j++){\\n                v1[j]=-1;\\n            }\\n            dp[i]=v1;\\n        }\\n        \\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n          int c=dfs(i,j,grid,dp);\\n                ans=(ans+(c%M))%M;\\n                ans=ans%M;\\n              \\n            }\\n           \\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int dfs(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n       \\n       int M=1000000007;\\n        int c=1;\\n        if((i+1)<grid.size()&&grid[i+1][j]>grid[i][j]){\\n            c=c+(dfs(i+1,j,grid,dp)%M);\\n        }\\n        if((i-1)>=0&&grid[i-1][j]>grid[i][j]){\\n            c=c+(dfs(i-1,j,grid,dp)%M);\\n        }\\n        if((j+1)<grid[0].size()&&grid[i][j+1]>grid[i][j]){\\n            c=c+(dfs(i,j+1,grid,dp)%M);\\n        }\\n        if((j-1)>=0&&grid[i][j-1]>grid[i][j]){\\n            \\n            c=c+(dfs(i,j-1,grid,dp)%M);\\n        }\\n       \\n        dp[i][j]=c;\\n        c=c%M;\\n        \\n        return c;\\n        \\n    }\\n   \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        \\n        int i,j;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n      vector<vector<int>> dp(m);\\n        int M=1000000007;\\n        int ans=0;\\n        for(i=0;i<m;i++){\\n            vector<int> v1(n);\\n            for(j=0;j<n;j++){\\n                v1[j]=-1;\\n            }\\n            dp[i]=v1;\\n        }\\n        \\n        for(i=0;i<m;i++){\\n            for(j=0;j<n;j++){\\n          int c=dfs(i,j,grid,dp);\\n                ans=(ans+(c%M))%M;\\n                ans=ans%M;\\n              \\n            }\\n           \\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256502,
                "title": "easy-dfs-dp-solution-recursive-memoization",
                "content": "1) Start dfs from all index\\n2) For every index traverse in 4 directions and store output for every direction\\n3) At last add answer of all directions, take mode and return\\n4) Add simple memoization (while returning store it in `dp[i][j]`)\\n\\nNote: we are doing `ans += 1 + f(i, j);` because we have to count each element too\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int m = 0, n = 0;\\n    vector<vector<int>> grid;\\n    long long mod = 1000000000 + 7;\\n    \\n    long long dp[1000][1000];\\n    \\n    long long int f(int i, int j){\\n        \\n        if(i < 0 || i >= m || j < 0 || j >= n) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int l = 0, r = 0, u = 0, d = 0;\\n        \\n        if(i+1 < m && grid[i+1][j] > grid[i][j]) d = 1 + f(i+1, j);\\n        if(i-1 >= 0 && grid[i-1][j] > grid[i][j]) u = 1 + f(i-1, j);\\n        if(j+1 < n && grid[i][j+1] > grid[i][j]) r = 1 + f(i, j+1);\\n        if(j-1 >= 0 && grid[i][j-1] > grid[i][j]) l = 1 + f(i, j-1);\\n        \\n        return dp[i][j] = (l+r+d+u)%(this->mod);\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        this->m = grid.size();\\n        this->n = grid[0].size();\\n        this->grid = grid;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        long long int ans = 0;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans += 1 + f(i, j);\\n            }\\n        }\\n        \\n        return ans%(this->mod);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int m = 0, n = 0;\\n    vector<vector<int>> grid;\\n    long long mod = 1000000000 + 7;\\n    \\n    long long dp[1000][1000];\\n    \\n    long long int f(int i, int j){\\n        \\n        if(i < 0 || i >= m || j < 0 || j >= n) return 0;\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int l = 0, r = 0, u = 0, d = 0;\\n        \\n        if(i+1 < m && grid[i+1][j] > grid[i][j]) d = 1 + f(i+1, j);\\n        if(i-1 >= 0 && grid[i-1][j] > grid[i][j]) u = 1 + f(i-1, j);\\n        if(j+1 < n && grid[i][j+1] > grid[i][j]) r = 1 + f(i, j+1);\\n        if(j-1 >= 0 && grid[i][j-1] > grid[i][j]) l = 1 + f(i, j-1);\\n        \\n        return dp[i][j] = (l+r+d+u)%(this->mod);\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        this->m = grid.size();\\n        this->n = grid[0].size();\\n        this->grid = grid;\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        long long int ans = 0;\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                ans += 1 + f(i, j);\\n            }\\n        }\\n        \\n        return ans%(this->mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255543,
                "title": "dynamic-programming-c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    bool val(int i, int j, vector<vector<int>>& grid){\\n        if(i<grid.size() && i>=0 && j<grid[0].size() && j>=0) return true;\\n        return false;\\n    }\\n    int gen(vector<vector<int>>& grid , int i, int j , vector<vector<int>>& dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=0, down=0, right=0, left=0;\\n        \\n        if(val(i+1,j,grid) && grid[i+1][j]>grid[i][j]) up    = gen(grid,i+1,j,dp);\\n        if(val(i-1,j,grid) && grid[i-1][j]>grid[i][j]) down  = gen(grid,i-1,j,dp);\\n        if(val(i,j+1,grid) && grid[i][j+1]>grid[i][j]) left  = gen(grid,i,j+1,dp);\\n        if(val(i,j-1,grid) && grid[i][j-1]>grid[i][j]) right = gen(grid,i,j-1,dp);\\n        \\n        return dp[i][j]=(1+up+down+right+left)%mod;\\n        \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i, j;\\n        int ans=0;\\n        vector<vector<int>> dp(grid.size() , vector<int>(grid[0].size(),-1));\\n        for(i=0 ; i<grid.size() ; i++){\\n            for(j=0 ; j<grid[0].size() ; j++){\\n                ans = (ans + gen(grid,i,j,dp))%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    bool val(int i, int j, vector<vector<int>>& grid){\\n        if(i<grid.size() && i>=0 && j<grid[0].size() && j>=0) return true;\\n        return false;\\n    }\\n    int gen(vector<vector<int>>& grid , int i, int j , vector<vector<int>>& dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=0, down=0, right=0, left=0;\\n        \\n        if(val(i+1,j,grid) && grid[i+1][j]>grid[i][j]) up    = gen(grid,i+1,j,dp);\\n        if(val(i-1,j,grid) && grid[i-1][j]>grid[i][j]) down  = gen(grid,i-1,j,dp);\\n        if(val(i,j+1,grid) && grid[i][j+1]>grid[i][j]) left  = gen(grid,i,j+1,dp);\\n        if(val(i,j-1,grid) && grid[i][j-1]>grid[i][j]) right = gen(grid,i,j-1,dp);\\n        \\n        return dp[i][j]=(1+up+down+right+left)%mod;\\n        \\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int i, j;\\n        int ans=0;\\n        vector<vector<int>> dp(grid.size() , vector<int>(grid[0].size(),-1));\\n        for(i=0 ; i<grid.size() ; i++){\\n            for(j=0 ; j<grid[0].size() ; j++){\\n                ans = (ans + gen(grid,i,j,dp))%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248565,
                "title": "java-dfs-12-lines-of-code-tc-o-mn-sc-o-mn",
                "content": "We can solve this problem by using DFS. However, we need to make sure that we eliminate the repetitive calculations. From each cell in the matrix, we try to find out how many strictly increasing paths exist. This number will be the number of strictly increasing paths of 4 neighbors + 1. 1 is because of the current cell. This many strictly increasing paths exist that start from the current cell. \\nPath[i][j]: How many strictly increasing paths start from grid[i][j]\\nDirections: (x diff,y diff) of 4 different directions up, down, left, right\\n```\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, mod = (int) (1e9 + 7), ans = 0;\\n        Integer[][] path = new Integer[m][n], directions = new Integer[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                ans = (ans + dfs(grid, i, j, -1, path, directions, m, n, mod)) % mod;\\n        return ans;\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j, int pre, Integer[][] path, Integer[][] directions, int m, int n, int mod) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= pre) return 0; // Invalid\\n        if (path[i][j] != null) return path[i][j]; // Already explored\\n        int numPaths = 0;\\n        for (Integer[] dir : directions)\\n            numPaths = (numPaths + dfs(grid, i + dir[0], j + dir[1], grid[i][j], path, directions, m, n, mod)) % mod;\\n        return path[i][j] = (1 + numPaths) % mod; // 1 for the current cell\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    public int countPaths(int[][] grid) {\\n        int m = grid.length, n = grid[0].length, mod = (int) (1e9 + 7), ans = 0;\\n        Integer[][] path = new Integer[m][n], directions = new Integer[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                ans = (ans + dfs(grid, i, j, -1, path, directions, m, n, mod)) % mod;\\n        return ans;\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j, int pre, Integer[][] path, Integer[][] directions, int m, int n, int mod) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] <= pre) return 0; // Invalid\\n        if (path[i][j] != null) return path[i][j]; // Already explored\\n        int numPaths = 0;\\n        for (Integer[] dir : directions)\\n            numPaths = (numPaths + dfs(grid, i + dir[0], j + dir[1], grid[i][j], path, directions, m, n, mod)) % mod;\\n        return path[i][j] = (1 + numPaths) % mod; // 1 for the current cell\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2242988,
                "title": "c-dfs-solution",
                "content": "```\\npublic class Solution {\\n    public int CountPaths(int[][] grid) {\\n        int[][] dp = new int[grid.Length][];\\n        for(int i = 0; i < grid.Length; i++){\\n            dp[i] = new int[grid[0].Length];\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < grid.Length; i++){\\n            for(int j = 0; j < grid[i].Length; j++){\\n                if(dp[i][j] == 0){\\n                    dp[i][j] = dfs(i, j, -1, grid, dp)%1000000007;\\n                }\\n                res = (res+dp[i][j])%1000000007;\\n            }\\n        }        \\n        return res;\\n    }\\n    \\n    private int dfs(int i, int j, int prev, int[][] grid, int[][] dp){\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || prev >= grid[i][j])\\n            return 0;\\n        if(dp[i][j] != 0) return dp[i][j];\\n        return dp[i][j] = (1+dfs(i+1, j, grid[i][j], grid, dp)+\\n                            dfs(i-1, j, grid[i][j], grid, dp)+\\n                            dfs(i, j+1, grid[i][j], grid, dp)+\\n                            dfs(i, j-1, grid[i][j], grid, dp)) % 1000000007;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountPaths(int[][] grid) {\\n        int[][] dp = new int[grid.Length][];\\n        for(int i = 0; i < grid.Length; i++){\\n            dp[i] = new int[grid[0].Length];\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < grid.Length; i++){\\n            for(int j = 0; j < grid[i].Length; j++){\\n                if(dp[i][j] == 0){\\n                    dp[i][j] = dfs(i, j, -1, grid, dp)%1000000007;\\n                }\\n                res = (res+dp[i][j])%1000000007;\\n            }\\n        }        \\n        return res;\\n    }\\n    \\n    private int dfs(int i, int j, int prev, int[][] grid, int[][] dp){\\n        if(i < 0 || i >= grid.Length || j < 0 || j >= grid[0].Length || prev >= grid[i][j])\\n            return 0;\\n        if(dp[i][j] != 0) return dp[i][j];\\n        return dp[i][j] = (1+dfs(i+1, j, grid[i][j], grid, dp)+\\n                            dfs(i-1, j, grid[i][j], grid, dp)+\\n                            dfs(i, j+1, grid[i][j], grid, dp)+\\n                            dfs(i, j-1, grid[i][j], grid, dp)) % 1000000007;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234555,
                "title": "c-dp-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        long ans = 0, mod = 1e9 + 7;\\n        vector<int> dirs = {0, -1, 0, 1, 0};\\n        vector<vector<long>> dp(m, vector<long>(n, 1));\\n        priority_queue<pair<long, pair<int, int>>> q;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                q.push({grid[i][j], {i, j}});\\n        while (!q.empty())\\n        {\\n            long c = q.top().first;\\n            int x = q.top().second.first, y = q.top().second.second;\\n            q.pop();\\n            for (int d = 0; d < 4; d++)\\n            {\\n                int nx = x + dirs[d], ny = y + dirs[d + 1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] >= grid[x][y])\\n                    continue;\\n                dp[nx][ny] = (dp[nx][ny] + dp[x][y]) % mod;\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                ans = (ans + dp[i][j]) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        long ans = 0, mod = 1e9 + 7;\\n        vector<int> dirs = {0, -1, 0, 1, 0};\\n        vector<vector<long>> dp(m, vector<long>(n, 1));\\n        priority_queue<pair<long, pair<int, int>>> q;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                q.push({grid[i][j], {i, j}});\\n        while (!q.empty())\\n        {\\n            long c = q.top().first;\\n            int x = q.top().second.first, y = q.top().second.second;\\n            q.pop();\\n            for (int d = 0; d < 4; d++)\\n            {\\n                int nx = x + dirs[d], ny = y + dirs[d + 1];\\n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] >= grid[x][y])\\n                    continue;\\n                dp[nx][ny] = (dp[nx][ny] + dp[x][y]) % mod;\\n            }\\n        }\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                ans = (ans + dp[i][j]) % mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233068,
                "title": "o-mn-dynamic-programming-topological-sort",
                "content": "We wish to count all possible strictly increasing paths in our `m-by-n` grid.\\n\\n**RECURRENCE RELATION**\\nFor each cell `(i,j)`, let\\'s define `num_ending(i, j)` to be the number of strictly increasing paths ending at cell `(i, j)`. It\\'s clear our final result will be the sum of this function evaluated over all cells in our grid. \\n\\nWe know that we can only get to a cell `(i, j)` from one of it\\'s 4 neighbors if the value at that neighbor is strictly less than the value at `(i, j)`, and every strictly increasing path ending at such a neighbor will be extended to a strictly increasing path ending at `(i, j)`. Thus, we have our recurrence relation for a dynamic programming:\\n```\\nnum_ending(i, j) = 1 + sum_{(ni, nj) in Neighbors(i, j) | grid(ni, nj) < grid(i, j)} num_ending(ni, nj)\\n```\\nwhere the 1 term corresponds to the path of just cell `(i, j)` by itself. So what\\'s our base cases to get our recurrence off the ground?\\n\\n**TOPOLOGICAL SORT**\\nWe see that there is an implicit DAG for our matrix, where we created an edge from cell `(i, j) -> (ni, nj)` if and only if:\\n- `(ni, nj)` is a neighbor of cell `(i, j)`\\n- `grid(ni, nj) < grid(i, j)`\\n\\nTherefore, we know that the base cases for our dynamic programming will correspond to any cells which do not have any incoming edges in the above graph, i.e. have in-degree zero. We then build up the remaning solutions to our dynamic programming from these.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        deltas = [\\n            [0, 1], [0, -1], [1, 0], [-1, 0]\\n        ]\\n        \\n        \\n        def on_grid(row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n\\n        \\n        \\n        # STEP 1: Construct DAG\\n        adjacency = defaultdict(list)\\n        degree = defaultdict(int)\\n        for i in range(m):\\n            for j in range(n):\\n                adjacency[(i,j)] = []\\n                degree[(i,j)] += 0\\n                for d in deltas:\\n                    ni, nj = i + d[0], j + d[1]\\n                    if not on_grid(ni, nj):\\n                        continue\\n                    if grid[ni][nj] > grid[i][j]:\\n                        adjacency[(i,j)].append((ni, nj))\\n                        degree[(ni, nj)] += 1\\n        \\n        # STEP 2: Determine starting nodes in our DAG, with in-degree 0\\n        num_ending = defaultdict(int)\\n        q = deque()\\n        for i in range(m):\\n            for j in range(n):\\n                num_ending[(i, j)] = 1\\n                if degree[(i, j)] != 0:\\n                    continue\\n                q.append((i, j))\\n        \\n        \\n        # STEP 3: Dynamic programming + topological sort\\n        while q:\\n            row, col = q.popleft()\\n            for nrow, ncol in adjacency[(row, col)]:\\n                num_ending[(nrow, ncol)] += num_ending[(row, col)]\\n                degree[(nrow, ncol)] -= 1\\n                if degree[(nrow, ncol)] == 0:\\n                    q.append((nrow, ncol))\\n        \\n        \\n        # STEP 4: Sum up number of paths ending at each cell\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res += num_ending[(i, j)]\\n        \\n        mod = 10 ** 9 + 7\\n        return res % mod\\n```",
                "solutionTags": [],
                "code": "```\\nnum_ending(i, j) = 1 + sum_{(ni, nj) in Neighbors(i, j) | grid(ni, nj) < grid(i, j)} num_ending(ni, nj)\\n```\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        deltas = [\\n            [0, 1], [0, -1], [1, 0], [-1, 0]\\n        ]\\n        \\n        \\n        def on_grid(row: int, col: int) -> bool:\\n            return 0 <= row < m and 0 <= col < n\\n        \\n        \\n        # STEP 1: Construct DAG\\n        adjacency = defaultdict(list)\\n        degree = defaultdict(int)\\n        for i in range(m):\\n            for j in range(n):\\n                adjacency[(i,j)] = []\\n                degree[(i,j)] += 0\\n                for d in deltas:\\n                    ni, nj = i + d[0], j + d[1]\\n                    if not on_grid(ni, nj):\\n                        continue\\n                    if grid[ni][nj] > grid[i][j]:\\n                        adjacency[(i,j)].append((ni, nj))\\n                        degree[(ni, nj)] += 1\\n        \\n        # STEP 2: Determine starting nodes in our DAG, with in-degree 0\\n        num_ending = defaultdict(int)\\n        q = deque()\\n        for i in range(m):\\n            for j in range(n):\\n                num_ending[(i, j)] = 1\\n                if degree[(i, j)] != 0:\\n                    continue\\n                q.append((i, j))\\n        \\n        \\n        # STEP 3: Dynamic programming + topological sort\\n        while q:\\n            row, col = q.popleft()\\n            for nrow, ncol in adjacency[(row, col)]:\\n                num_ending[(nrow, ncol)] += num_ending[(row, col)]\\n                degree[(nrow, ncol)] -= 1\\n                if degree[(nrow, ncol)] == 0:\\n                    q.append((nrow, ncol))\\n        \\n        \\n        # STEP 4: Sum up number of paths ending at each cell\\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                res += num_ending[(i, j)]\\n        \\n        mod = 10 ** 9 + 7\\n        return res % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232591,
                "title": "memoized-dfs",
                "content": "```\\nimport functools\\n\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mod = 10**9+7\\n        ans = 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(r, c):\\n            # every cell starts as 1 increasing path\\n            local_ans = 1\\n            \\n            neighbors = [(1,0), (-1, 0), (0, 1), (0, -1)]\\n            for xr, xc in neighbors:\\n                new_r, new_c = r+xr, c+xc\\n                if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] > grid[r][c]:\\n                    local_ans += dfs(new_r, new_c) % mod\\n            \\n            return local_ans % mod\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c) % mod\\n        \\n        return ans % mod\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport functools\\n\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        mod = 10**9+7\\n        ans = 0\\n        \\n        @functools.lru_cache(None)\\n        def dfs(r, c):\\n            # every cell starts as 1 increasing path\\n            local_ans = 1\\n            \\n            neighbors = [(1,0), (-1, 0), (0, 1), (0, -1)]\\n            for xr, xc in neighbors:\\n                new_r, new_c = r+xr, c+xc\\n                if 0 <= new_r < m and 0 <= new_c < n and grid[new_r][new_c] > grid[r][c]:\\n                    local_ans += dfs(new_r, new_c) % mod\\n            \\n            return local_ans % mod\\n        \\n        for r in range(m):\\n            for c in range(n):\\n                ans += dfs(r, c) % mod\\n        \\n        return ans % mod\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232078,
                "title": "py-dfs-dp-raw-code-no-comments",
                "content": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        visited = set()\\n        m,n = len(grid),len(grid[0])\\n        move = [(0,1),(1,0),(-1,0),(0,-1)]\\n        ans = 0 \\n        def isValid(i,j):\\n            if(i<0 or j<0 or i>=m or j>=n):\\n                return False\\n            return True\\n        dp = dict()\\n        def dfs(i,j):\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            visited.add((i,j))\\n            a = 1\\n            for i_m,j_m in move:\\n                new_i,new_j = i + i_m ,j + j_m\\n                if(isValid(new_i,new_j) and (new_i,new_j) not in visited and grid[i][j]<grid[new_i][new_j]):\\n                    a += dfs(new_i,new_j)\\n            visited.remove((i,j))\\n            dp[(i,j)] = a\\n            return a\\n        for i in range(m):\\n            for j in range(n):\\n                ans += dfs(i,j)\\n        return ans%(10**9 + 7)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        visited = set()\\n        m,n = len(grid),len(grid[0])\\n        move = [(0,1),(1,0),(-1,0),(0,-1)]\\n        ans = 0 \\n        def isValid(i,j):\\n            if(i<0 or j<0 or i>=m or j>=n):\\n                return False\\n            return True\\n        dp = dict()\\n        def dfs(i,j):\\n            if (i,j) in dp:\\n                return dp[(i,j)]\\n            visited.add((i,j))\\n            a = 1\\n            for i_m,j_m in move:\\n                new_i,new_j = i + i_m ,j + j_m\\n                if(isValid(new_i,new_j) and (new_i,new_j) not in visited and grid[i][j]<grid[new_i][new_j]):\\n                    a += dfs(new_i,new_j)\\n            visited.remove((i,j))\\n            dp[(i,j)] = a\\n            return a\\n        for i in range(m):\\n            for j in range(n):\\n                ans += dfs(i,j)\\n        return ans%(10**9 + 7)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231689,
                "title": "python-easy-readable-dp-memoization-similar-to-leetcode-329",
                "content": "This question is very similar to **Leetcode 329 * Longest Increasing Path in a Matrix***.\\nThe answer is almost similar.\\nI highly recommend you to check both the solutions.\\n\\n**Soultion to \\n2328. Number of Increasing Paths in a Grid**\\n```\\n\\nclass Solution:\\n    def countPaths(self, matrix: List[List[int]]) -> int:\\n        \\n        mod=10**9+7\\n        r,c=len(matrix),len(matrix[0])\\n        dict={}\\n        \\n        def dfs(i,j,prev):\\n            if i<0 or i>=r or j<0 or j>=c or matrix[i][j]<=prev:\\n                return 0\\n            \\n            key=(i,j)\\n            if key in dict:\\n                return dict[key]\\n            \\n                        \\n            left=dfs(i-1,j,matrix[i][j])\\n            right=dfs(i+1,j,matrix[i][j])\\n            up=dfs(i,j-1,matrix[i][j])\\n            down=dfs(i,j+1,matrix[i][j])\\n            \\n            total=(up%mod + down%mod + left%mod + right%mod +1)%mod\\n            dict[key]=total\\n            return total\\n        \\n        \\n        ans=0\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                k=dfs(i,j,-1)\\n                ans=(ans+k)%mod\\n        return ans\\n\\n```\\n\\n\\n**Solution to :\\n329.  Longest Increasing Path in a Matrix**\\nLink: https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\\n\\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        r,c=len(matrix),len(matrix[0])\\n        dict={}\\n        def dfs(i,j,prev):\\n            if i<0 or i>=r or j<0 or j>=c or matrix[i][j]<=prev:\\n                return 0\\n            \\n            key=(i,j)\\n            if key in dict:\\n                return dict[key]\\n            \\n            \\n            \\n            left=dfs(i-1,j,matrix[i][j])\\n            right=dfs(i+1,j,matrix[i][j])\\n            up=dfs(i,j-1,matrix[i][j])\\n            down=dfs(i,j+1,matrix[i][j])\\n            \\n            total=max(left,right,up,down)+1\\n            dict[key]=total\\n            return total\\n        \\n        maxx=-10**9\\n        for i in range(r):\\n            for j in range(c):\\n                k=dfs(i,j,-1)\\n                maxx=max(maxx,k)\\n        return maxx\\n        \\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def countPaths(self, matrix: List[List[int]]) -> int:\\n        \\n        mod=10**9+7\\n        r,c=len(matrix),len(matrix[0])\\n        dict={}\\n        \\n        def dfs(i,j,prev):\\n            if i<0 or i>=r or j<0 or j>=c or matrix[i][j]<=prev:\\n                return 0\\n            \\n            key=(i,j)\\n            if key in dict:\\n                return dict[key]\\n            \\n                        \\n            left=dfs(i-1,j,matrix[i][j])\\n            right=dfs(i+1,j,matrix[i][j])\\n            up=dfs(i,j-1,matrix[i][j])\\n            down=dfs(i,j+1,matrix[i][j])\\n            \\n            total=(up%mod + down%mod + left%mod + right%mod +1)%mod\\n            dict[key]=total\\n            return total\\n        \\n        \\n        ans=0\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                k=dfs(i,j,-1)\\n                ans=(ans+k)%mod\\n        return ans\\n\\n```\n```\\nclass Solution:\\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\\n        \\n        r,c=len(matrix),len(matrix[0])\\n        dict={}\\n        def dfs(i,j,prev):\\n            if i<0 or i>=r or j<0 or j>=c or matrix[i][j]<=prev:\\n                return 0\\n            \\n            key=(i,j)\\n            if key in dict:\\n                return dict[key]\\n            \\n            \\n            \\n            left=dfs(i-1,j,matrix[i][j])\\n            right=dfs(i+1,j,matrix[i][j])\\n            up=dfs(i,j-1,matrix[i][j])\\n            down=dfs(i,j+1,matrix[i][j])\\n            \\n            total=max(left,right,up,down)+1\\n            dict[key]=total\\n            return total\\n        \\n        maxx=-10**9\\n        for i in range(r):\\n            for j in range(c):\\n                k=dfs(i,j,-1)\\n                maxx=max(maxx,k)\\n        return maxx\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231155,
                "title": "easy-memoziation-reursion",
                "content": "```\\nclass Solution {\\n    int row; //size of row\\n    int col; //size of col\\n    //directions moves\\n    vector<int>move_row = {0,1,0,-1};\\n    vector<int>move_col = {1,0,-1,0};\\n    long long const m = 1e9+7;\\n    //check boundry conditions\\n    bool const isValidPath(int row,int col){\\n        if(row < this->row && row >= 0 && col < this->col && col >= 0) return true; \\n        return false;\\n    }\\n    \\n    int findIncreasingPath(int currRow,int currCol,vector<vector<int>>& grid){\\n\\t\\t//dont need this condition as we have alredy checked boundry conditions\\n        //if(currRow >= row || currRow < 0 || currCol >= col || currCol < 0) return 0; //if out of Boundry return 0\\n        \\n        if(dp[currRow][currCol] != -1) return dp[currRow][currCol]; //if previos checked for this path then return pre calculated sum\\n        \\n        //store curr addition\\n        int paths = 1;\\n        \\n        //find new paths from all 4 direction\\n        for(int direction = 0; direction < 4; direction++){\\n            int new_row = currRow + move_row[direction];\\n            int new_col = currCol + move_col[direction];\\n            if(isValidPath(new_row,new_col) && grid[currRow][currCol] < grid[new_row][new_col]){\\n                paths += findIncreasingPath(new_row,new_col,grid) % m;\\n                paths %= m;\\n            }\\n        }\\n        //store sum in dp for next use\\n        return dp[currRow][currCol] = paths % m;\\n    }\\npublic:\\n    int dp[1001][1001];\\n    int countPaths(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        row = grid.size();\\n        col = grid[0].size();\\n        int paths = 0;  \\n        //travers and calculate paths from all grid\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col; j++){\\n                paths += findIncreasingPath(i,j,grid) % m;\\n                paths %= m;\\n            }\\n        }\\n        return paths%m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int row; //size of row\\n    int col; //size of col\\n    //directions moves\\n    vector<int>move_row = {0,1,0,-1};\\n    vector<int>move_col = {1,0,-1,0};\\n    long long const m = 1e9+7;\\n    //check boundry conditions\\n    bool const isValidPath(int row,int col){\\n        if(row < this->row && row >= 0 && col < this->col && col >= 0) return true; \\n        return false;\\n    }\\n    \\n    int findIncreasingPath(int currRow,int currCol,vector<vector<int>>& grid){\\n\\t\\t//dont need this condition as we have alredy checked boundry conditions\\n        //if(currRow >= row || currRow < 0 || currCol >= col || currCol < 0) return 0; //if out of Boundry return 0\\n        \\n        if(dp[currRow][currCol] != -1) return dp[currRow][currCol]; //if previos checked for this path then return pre calculated sum\\n        \\n        //store curr addition\\n        int paths = 1;\\n        \\n        //find new paths from all 4 direction\\n        for(int direction = 0; direction < 4; direction++){\\n            int new_row = currRow + move_row[direction];\\n            int new_col = currCol + move_col[direction];\\n            if(isValidPath(new_row,new_col) && grid[currRow][currCol] < grid[new_row][new_col]){\\n                paths += findIncreasingPath(new_row,new_col,grid) % m;\\n                paths %= m;\\n            }\\n        }\\n        //store sum in dp for next use\\n        return dp[currRow][currCol] = paths % m;\\n    }\\npublic:\\n    int dp[1001][1001];\\n    int countPaths(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        row = grid.size();\\n        col = grid[0].size();\\n        int paths = 0;  \\n        //travers and calculate paths from all grid\\n        for(int i = 0 ; i < row; i++){\\n            for(int j = 0 ; j < col; j++){\\n                paths += findIncreasingPath(i,j,grid) % m;\\n                paths %= m;\\n            }\\n        }\\n        return paths%m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231139,
                "title": "c-dfs-memo-clean-code",
                "content": "```\\n   int mod=1e9+7;\\n    bool isSafe(int i,int j,vector<vector<int>> &grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 0;\\n        return 1;\\n    }\\n    int dfs(vector<vector<int>>& matrix,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        int ans=1;\\n        for(int k=0;k<4;k++){\\n            if(isSafe(i+dx[k],j+dy[k],matrix) and matrix[i][j]< matrix[i+dx[k]][j+dy[k]])\\n            {\\n                ans=(ans%mod+dfs(matrix,i+dx[k],j+dy[k],dp))%mod;\\n            }\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n\\tint countPaths(vector<vector<int>>& matrix) {\\n            int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=(ans+dfs(matrix,i,j,dp))%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n   int mod=1e9+7;\\n    bool isSafe(int i,int j,vector<vector<int>> &grid){\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()) return 0;\\n        return 1;\\n    }\\n    int dfs(vector<vector<int>>& matrix,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        int ans=1;\\n        for(int k=0;k<4;k++){\\n            if(isSafe(i+dx[k],j+dy[k],matrix) and matrix[i][j]< matrix[i+dx[k]][j+dy[k]])\\n            {\\n                ans=(ans%mod+dfs(matrix,i+dx[k],j+dy[k],dp))%mod;\\n            }\\n        }\\n        return dp[i][j]=ans%mod;\\n    }\\n\\tint countPaths(vector<vector<int>>& matrix) {\\n            int m=matrix.size(),n=matrix[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans=(ans+dfs(matrix,i,j,dp))%mod;\\n            }\\n        }\\n        return ans%mod;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2231013,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n\\t\\n    int dp[1005][1005];\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int n, int m)\\n    {   \\n\\t    // if already calculated\\n\\t\\t\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int sum = 0;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_row = i + dx[k];\\n            \\n            int new_col = j + dy[k];\\n            \\n            if(new_row >= 0 && new_row < n && new_col >= 0 && new_col < m && grid[new_row][new_col] > grid[i][j])\\n            {\\n                sum = (sum % mod + dfs(grid, new_row, new_col, n, m) % mod) % mod;\\n            }\\n        }\\n        \\n        return dp[i][j] = (1 % mod + sum % mod) % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // count no. of increasing paths\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                count = (count % mod + dfs(grid, i, j, n, m) % mod) % mod;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod = 1e9 + 7;\\n\\t\\n    int dp[1005][1005];\\n    \\n    vector<int> dx = {-1, 0, 1, 0};\\n    \\n    vector<int> dy = {0, 1, 0, -1};\\n    \\n    int dfs(vector<vector<int>>& grid, int i, int j, int n, int m)\\n    {   \\n\\t    // if already calculated\\n\\t\\t\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int sum = 0;\\n        \\n        for(int k = 0; k < 4; k++)\\n        {\\n            int new_row = i + dx[k];\\n            \\n            int new_col = j + dy[k];\\n            \\n            if(new_row >= 0 && new_row < n && new_col >= 0 && new_col < m && grid[new_row][new_col] > grid[i][j])\\n            {\\n                sum = (sum % mod + dfs(grid, new_row, new_col, n, m) % mod) % mod;\\n            }\\n        }\\n        \\n        return dp[i][j] = (1 % mod + sum % mod) % mod;\\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // count no. of increasing paths\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                count = (count % mod + dfs(grid, i, j, n, m) % mod) % mod;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230548,
                "title": "c-dp-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    int ans;\\n    int dp[1001][1001];\\n    int n,m;\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    int dirx[4]={0,1,-1,0};\\n    int diry[4]={1,0,0,-1};\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid,int len){\\n        \\n        if(!valid(i,j))\\n            return;        \\n        if(dp[i][j]!=-1){\\n            return;\\n        }        \\n        dp[i][j] = 1;\\n\\t\\t\\n        for(int ind=0;ind<4;++ind){\\n            int newi=i+dirx[ind],newj=j+diry[ind];\\n            if(valid(newi,newj) and grid[newi][newj]>grid[i][j]){\\n                dfs(newi,newj,grid,len+1);\\n                dp[i][j] += dp[newi][newj];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        for(int i=0;i<1000;++i){\\n            for(int j=0;j<1000;++j){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        ans = 0;\\n        n=grid.size(),m=grid[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                int len = 1;\\n                dfs(i,j,grid,len);\\n                ans = (ans%mod + dp[i][j]%mod)%mod;\\n            }\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    int ans;\\n    int dp[1001][1001];\\n    int n,m;\\n    \\n    bool valid(int i,int j){\\n        return (i>=0 and j>=0 and i<n and j<m);\\n    }\\n    \\n    int dirx[4]={0,1,-1,0};\\n    int diry[4]={1,0,0,-1};\\n    \\n    void dfs(int i,int j,vector<vector<int>>& grid,int len){\\n        \\n        if(!valid(i,j))\\n            return;        \\n        if(dp[i][j]!=-1){\\n            return;\\n        }        \\n        dp[i][j] = 1;\\n\\t\\t\\n        for(int ind=0;ind<4;++ind){\\n            int newi=i+dirx[ind],newj=j+diry[ind];\\n            if(valid(newi,newj) and grid[newi][newj]>grid[i][j]){\\n                dfs(newi,newj,grid,len+1);\\n                dp[i][j] += dp[newi][newj];\\n                dp[i][j] %= mod;\\n            }\\n        }\\n        \\n    }\\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        \\n        for(int i=0;i<1000;++i){\\n            for(int j=0;j<1000;++j){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        ans = 0;\\n        n=grid.size(),m=grid[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                int len = 1;\\n                dfs(i,j,grid,len);\\n                ans = (ans%mod + dp[i][j]%mod)%mod;\\n            }\\n        }\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230448,
                "title": "c-dp-dfs-recursion",
                "content": "```\\nint dp[1005][1005],mod=1e9+7;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,-1,0,1};\\nclass Solution {\\npublic:\\n    int fun(int i,int j,int&m,int&n,vector<vector<int>>&grid){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long long int ans=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]>grid[i][j]){\\n                ans+=fun(x,y,m,n,grid);\\n            }\\n        }\\n        ans++;\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size(),ans;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==-1) ans=fun(i,j,m,n,grid);\\n            }\\n        }\\n        ans=0;\\n        for(int i=0;i<m;i++) for(int j=0;j<n;j++) {ans+=dp[i][j];ans%=mod;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nint dp[1005][1005],mod=1e9+7;\\nint dx[4]={-1,0,1,0};\\nint dy[4]={0,-1,0,1};\\nclass Solution {\\npublic:\\n    int fun(int i,int j,int&m,int&n,vector<vector<int>>&grid){\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        long long int ans=0;\\n        for(int k=0;k<4;k++){\\n            int x=i+dx[k],y=j+dy[k];\\n            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]>grid[i][j]){\\n                ans+=fun(x,y,m,n,grid);\\n            }\\n        }\\n        ans++;\\n        return dp[i][j]=ans%mod;\\n    }\\n    int countPaths(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size(),ans;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(dp[i][j]==-1) ans=fun(i,j,m,n,grid);\\n            }\\n        }\\n        ans=0;\\n        for(int i=0;i<m;i++) for(int j=0;j<n;j++) {ans+=dp[i][j];ans%=mod;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230441,
                "title": "dfs-with-memoisation-java-python",
                "content": "hello! explanations are below\\n\\n**Java** (140+ms)\\n```\\nclass Solution {\\n    private long res;\\n    private int MOD = 1000000007;\\n    private long[][] tracker;\\n    public int countPaths(int[][] grid) {\\n        res = 0;\\n        tracker = new long[grid.length][grid[0].length];\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (tracker[r][c] == 0) tracker[r][c] = dfs(grid, r, c);\\n                res += tracker[r][c] % MOD;\\n            }\\n        }\\n        return (int) (res % MOD);\\n    }\\n    private long dfs(int[][] grid, int row, int col) {\\n        if (tracker[row][col] != 0) return tracker[row][col];\\n        long paths = 1;\\n        int[][] neighbours = new int[][] { {row + 1, col}, {row - 1, col}, {row, col + 1}, {row, col - 1} };\\n        for (int[] neighbour : neighbours) {\\n            int nrow = neighbour[0], ncol = neighbour[1];\\n            if (nrow < 0 || nrow >= grid.length || ncol < 0 || ncol >= grid[0].length || grid[nrow][ncol] <= grid[row][col]) continue;\\n            paths += dfs(grid, nrow, ncol) % MOD;\\n        }\\n        tracker[row][col] = paths;\\n        return paths;\\n    }\\n}\\n```\\n\\n**Python** (2000+ms)\\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        self.res = 0\\n        self.MOD = 10 ** 9 + 7\\n        self.tracker = [[0 for c in range(len(grid[0]))] for r in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if self.tracker[row][col] == 0: self.dfs(grid, row, col)\\n                self.res += self.tracker[row][col] % self.MOD\\n        return self.res % self.MOD\\n    def dfs(self, grid, row, col):\\n        if self.tracker[row][col] != 0: return self.tracker[row][col]\\n        paths = 1\\n        neighbours = [ [row + 1, col], [row - 1, col], [row, col + 1], [row, col - 1] ]\\n        for neighbour in neighbours:\\n            nrow, ncol = neighbour\\n            if nrow < 0 or nrow >= len(grid) or ncol < 0 or ncol >= len(grid[0]) or grid[nrow][ncol] <= grid[row][col]: continue\\n            paths += self.dfs(grid, nrow, ncol) % self.MOD\\n        self.tracker[row][col] = paths\\n        return paths\\n```\\n\\nwe initialise our memo that mirrors the grid. this keeps track of the total paths that lead on from this square. *paths: the number of tiles that are part of any valid paths that start from this tile.* we will perform dfs on any coordinate that has yet to be visited. we know it has not been visited if its number of paths is 0. this is because each tile will definitely have (and hence allocated) a minimum path value of 1 (since it itself is a valid path).\\n\\nin our dfs, if we encounter a tile that has been previously visited, we just return that tile\\'s path value. if not, we search its neighbours. for each valid neighbour, we add the neighbour\\'s path to our path and update the tracker array.\\n\\nto ensure we do not double add to our result, only added to the result at double loop in the main function",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private long res;\\n    private int MOD = 1000000007;\\n    private long[][] tracker;\\n    public int countPaths(int[][] grid) {\\n        res = 0;\\n        tracker = new long[grid.length][grid[0].length];\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (tracker[r][c] == 0) tracker[r][c] = dfs(grid, r, c);\\n                res += tracker[r][c] % MOD;\\n            }\\n        }\\n        return (int) (res % MOD);\\n    }\\n    private long dfs(int[][] grid, int row, int col) {\\n        if (tracker[row][col] != 0) return tracker[row][col];\\n        long paths = 1;\\n        int[][] neighbours = new int[][] { {row + 1, col}, {row - 1, col}, {row, col + 1}, {row, col - 1} };\\n        for (int[] neighbour : neighbours) {\\n            int nrow = neighbour[0], ncol = neighbour[1];\\n            if (nrow < 0 || nrow >= grid.length || ncol < 0 || ncol >= grid[0].length || grid[nrow][ncol] <= grid[row][col]) continue;\\n            paths += dfs(grid, nrow, ncol) % MOD;\\n        }\\n        tracker[row][col] = paths;\\n        return paths;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def countPaths(self, grid: List[List[int]]) -> int:\\n        self.res = 0\\n        self.MOD = 10 ** 9 + 7\\n        self.tracker = [[0 for c in range(len(grid[0]))] for r in range(len(grid))]\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if self.tracker[row][col] == 0: self.dfs(grid, row, col)\\n                self.res += self.tracker[row][col] % self.MOD\\n        return self.res % self.MOD\\n    def dfs(self, grid, row, col):\\n        if self.tracker[row][col] != 0: return self.tracker[row][col]\\n        paths = 1\\n        neighbours = [ [row + 1, col], [row - 1, col], [row, col + 1], [row, col - 1] ]\\n        for neighbour in neighbours:\\n            nrow, ncol = neighbour\\n            if nrow < 0 or nrow >= len(grid) or ncol < 0 or ncol >= len(grid[0]) or grid[nrow][ncol] <= grid[row][col]: continue\\n            paths += self.dfs(grid, nrow, ncol) % self.MOD\\n        self.tracker[row][col] = paths\\n        return paths\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230411,
                "title": "simple-dp-recursion-memoization-c-14-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 7 + 1e9;\\n    vector<vector<int>> dp;\\n    vector<int> dx, dy;\\n    int dfs(vector<vector<int>> &mat, int i, int j)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int smallans = 0;\\n        \\n        for(int z=0; z<4; z++)\\n        {\\n            int ni = i + dx[z];\\n            int nj = j + dy[z];\\n            \\n            if(ni>=0 && ni<=n-1 && nj>=0 && nj<=m-1) \\n             {\\n                if(mat[ni][nj]>mat[i][j])\\n                {\\n                  smallans = (smallans + dfs(mat,ni,nj))%mod;\\n                }\\n             }\\n        }\\n        \\n        return dp[i][j] = smallans + 1;\\n    }\\n    \\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        dx = {-1,1,0,0};\\n        dy = {0,0,-1,1};\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n,vector<int>(m,-1));\\n        int ans = 0;\\n        for(int i =0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dp[i][j]==-1) dfs(grid,i,j);\\n                ans = (ans + dp[i][j])%mod;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 7 + 1e9;\\n    vector<vector<int>> dp;\\n    vector<int> dx, dy;\\n    int dfs(vector<vector<int>> &mat, int i, int j)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        \\n        int smallans = 0;\\n        \\n        for(int z=0; z<4; z++)\\n        {\\n            int ni = i + dx[z];\\n            int nj = j + dy[z];\\n            \\n            if(ni>=0 && ni<=n-1 && nj>=0 && nj<=m-1) \\n             {\\n                if(mat[ni][nj]>mat[i][j])\\n                {\\n                  smallans = (smallans + dfs(mat,ni,nj))%mod;\\n                }\\n             }\\n        }\\n        \\n        return dp[i][j] = smallans + 1;\\n    }\\n    \\npublic:\\n    int countPaths(vector<vector<int>>& grid) {\\n        dx = {-1,1,0,0};\\n        dy = {0,0,-1,1};\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        dp.resize(n,vector<int>(m,-1));\\n        int ans = 0;\\n        for(int i =0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(dp[i][j]==-1) dfs(grid,i,j);\\n                ans = (ans + dp[i][j])%mod;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230350,
                "title": "dfs-dp-easy-solution-with-comments",
                "content": "class Solution {\\npublic:\\n   \\n\\t long long cnt = 0;\\n\\t// this function call the dfs on their childrens\\n    long long  dfs(vector<vector<int>> & grid, int i , int j,vector<vector<long long>>&DP){\\n        if(DP[i][j] != -1){\\n            return DP[i][j];\\n        }\\n        vector<pair<int,int>> V = {{1,0}, {0,1}, {-1, 0}, {0,-1}};\\n        long long ans = 0;\\n        for(auto it : V){\\n            if(isvalid(i + it.first, j + it.second, grid,i,j)){\\n                    ans += dfs(grid,i + it.first,j + it.second,DP)%1000000007;\\n            }\\n        }\\n        return DP[i][j] = (1 + ans)%1000000007;\\n    }\\n\\t// this function check weather next index i,j realtive to i1,j1 is valid or not\\n    bool isvalid(int i, int j ,vector<vector<int>> & grid, int i1, int j1){\\n        int n  = grid.size();\\n        int m = grid[0].size();\\n        if(i < 0 || i >= n || j < 0 || j >= m ||  grid[i][j] <= grid[i1][j1]){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\t\\n\\t\\n    int countPaths(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<bool>> Vis(n, vector<bool>(m , false));\\n        vector<vector<long long>>DP(n , vector<long long>(m , -1));\\n        long long sm = 0;\\n        for(int i=0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n\\t\\t\\t// we are calling dfs on every index of matrix to calculate total number of paths\\n                sm += dfs(grid,i,j,DP)%1000000007;\\n                sm = sm%1000000007;\\n            }\\n        }\\n        return sm%1000000007;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n   \\n\\t long long cnt = 0;\\n\\t// this function call the dfs on their childrens\\n    long long  dfs(vector<vector<int>> & grid, int i , int j,vector<vector<long long>>&DP){\\n        if(DP[i][j] != -1){\\n            return DP[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2230277,
                "title": "dfs-memo-dp-beat-100-runtime-as-well-as-memory-usage-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dp;\\n    int m, n;\\n    \\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        long count = 1;\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n            \\n        int dx[] = {0, 1, 0, -1};\\n        int dy[] = {1, 0, -1, 0};\\n        \\n        for(int i = 0; i < 4; i++){\\n            int x = r + dx[i], y = c + dy[i];\\n            if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[r][c]){\\n                \\n                int t = grid[r][c];\\n                grid[r][c] = 0;\\n                count = (count + dfs(grid, x, y)%mod)%mod;\\n                grid[r][c] = t;\\n            }\\n        }\\n        dp[r][c] = count;\\n        \\n        return count;\\n    }\\n    \\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size(); n = grid[0].size();\\n        int ans = 0;\\n        dp.resize(m, vector<int> (n, -1));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                long res = dfs(grid, i, j);\\n                ans = (ans +  (res%mod)) %mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dp;\\n    int m, n;\\n    \\n    int dfs(vector<vector<int>>& grid, int r, int c){\\n        long count = 1;\\n        if(dp[r][c] != -1)\\n            return dp[r][c];\\n            \\n        int dx[] = {0, 1, 0, -1};\\n        int dy[] = {1, 0, -1, 0};\\n        \\n        for(int i = 0; i < 4; i++){\\n            int x = r + dx[i], y = c + dy[i];\\n            if(x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[r][c]){\\n                \\n                int t = grid[r][c];\\n                grid[r][c] = 0;\\n                count = (count + dfs(grid, x, y)%mod)%mod;\\n                grid[r][c] = t;\\n            }\\n        }\\n        dp[r][c] = count;\\n        \\n        return count;\\n    }\\n    \\n    \\n    int countPaths(vector<vector<int>>& grid) {\\n        m = grid.size(); n = grid[0].size();\\n        int ans = 0;\\n        dp.resize(m, vector<int> (n, -1));\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                long res = dfs(grid, i, j);\\n                ans = (ans +  (res%mod)) %mod;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1933753,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933688,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933708,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933689,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933779,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933705,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933777,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933704,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933697,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933687,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933753,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933688,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933708,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933689,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933779,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933705,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933777,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933704,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933697,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1933687,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "leetcode is preparing us for the war with AI"
                    },
                    {
                        "username": "phuonganhniie",
                        "content": "agree "
                    },
                    {
                        "username": "Nithin281",
                        "content": "Exactly"
                    },
                    {
                        "username": "c4tdog",
                        "content": "the only place on Earth where I need the number `1000000007` is here"
                    },
                    {
                        "username": "hydra324",
                        "content": "lmao"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Can be used as a secret sign, only understandable by the initiates\n\n![cult1e9+7.jpg](https://assets.leetcode.com/users/images/75f95c69-e45c-46fe-811f-d34dd75ae480_1687099184.078845.jpeg)"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "It\\'s really common to see that exact number in other tasks too. I believe the reason for choosing is that it\\'s quite a large prime."
                    },
                    {
                        "username": "im_mercy",
                        "content": "easier than previous 2 problem"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "for sure. this was definitely easier"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "HARD WEEKEND"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one is actually easy, the one from two days ago was hell"
                    },
                    {
                        "username": "JParks1982",
                        "content": "This problem was *considerably* easier than the problem given yesterday. Probably should be medium?"
                    },
                    {
                        "username": "AlexShch",
                        "content": "Easiest hard of my life"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I made a mistake to write like this: ans += dfs(...) % mod, but it should be ans = (ans + dfs(...)) % mod"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "I always write it out for this reason, result = (result + ...) % MOD;"
                    },
                    {
                        "username": "dkochetov",
                        "content": "You can also do\\n```\\nans += dfs(...)\\nans %= mod\\n```"
                    },
                    {
                        "username": "GD18",
                        "content": "did the same mistake lmao, tho this was easier to identify, considering it gave a a run time error of integer overflow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "1000000007 is a prime number. The answer should be modulo this number! Try DFS!!\nDebug for a whole just for \"strictly increasing\""
                    },
                    {
                        "username": "SACD",
                        "content": "wtf why \\u256C\\uFFE3\\u76BF\\uFFE3\\uFF09"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Try DP+BFS, i am just telling this by intuition of a similar problem at the start of the month. And also looking at yesterday\\u2019s problem. ;)"
                    }
                ]
            },
            {
                "id": 1934277,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1935196,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1934918,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1934247,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1933703,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 2010617,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1939315,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1935099,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1934987,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1934881,
                "content": [
                    {
                        "username": "shrishrajgupta",
                        "content": "inner-peace , solving this, after ruining contest."
                    },
                    {
                        "username": "Zefick",
                        "content": "Topological Sort in \"related topics\" is a trap :)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "I cried in morning during contest, now I have crying since then coz of this question"
                    },
                    {
                        "username": "cosmic_saurabh",
                        "content": "Should be **Medium** only... :)"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Don\\'t forget the modulo `10^9 + 7`"
                    },
                    {
                        "username": "Vizxe",
                        "content": "Don\\'t forget it\\'s ^ is a binary operation in some languages though! I first forgot to modulo and then forgot its a binray thing"
                    },
                    {
                        "username": "vikramu9td",
                        "content": "This is medium at best."
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "for those getting memory limit exceeded using memoization, pass the grid by reference, not by value "
                    },
                    {
                        "username": "kenzgf",
                        "content": "definitely a medium lol"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "leetcode daily challenge vs AI"
                    },
                    {
                        "username": "hemankjain17",
                        "content": "this weak is bit harder......\\n"
                    }
                ]
            },
            {
                "id": 1934790,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934724,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934672,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934671,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934653,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934618,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934574,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934562,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934543,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934502,
                "content": [
                    {
                        "username": "sanyam0410",
                        "content": "default dfs template\\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "getting TLE after passing 34/36 tetcaes.\nplease tell me what should I do?\n\n\n    public int countPaths(int[][] grid) {\n        int[] count = {0};\n        boolean[][] arr = new boolean[grid.length][grid[0].length]; //maintaining boolean array and backtracking\n        count[0] = grid.length*grid[0].length;\n        for(int i =0;i<grid.length;i++){    //iterating each elememt\n            for(int j =0;j<grid[0].length;j++){\n                arr[i][j] = true;\n                fun(grid,arr,i,j,count);\n                arr[i][j] = false;\n            }\n        }\n        return count[0];\n    }\n\n    static void fun(int[][] grid,boolean[][] arr,int r,int c,int[] count){\n        int mod = 1000000007;\n        count[0] = count[0] % mod;\n        int n = grid[r][c];\n        \n         if(valid(grid,arr,r+1,c) &&  grid[r+1][c]>n){\n             arr[r+1][c] = true;\n             count[0]++;\n             fun(grid,arr,r+1,c,count);\n             arr[r+1][c] = false;\n         }\n         if(valid(grid,arr,r-1,c) &&  grid[r-1][c]>n){\n              arr[r-1][c] = true;\n              count[0]++;\n              fun(grid,arr,r-1,c,count);\n              arr[r-1][c] = false;\n         }\n         if(valid(grid,arr,r,c+1) &&  grid[r][c+1]>n){\n              arr[r][c+1] = true;\n              count[0]++;\n              fun(grid,arr,r,c+1,count);\n              arr[r][c+1] = false;\n         }\n         if(valid(grid,arr,r,c-1) &&  grid[r][c-1]>n){\n              arr[r][c-1] = true;\n              count[0]++;\n              fun(grid,arr,r,c-1,count);\n              arr[r][c-1] = false;\n         }\n\n    }\n\n    public static boolean valid(int[][] grid,boolean[][] arr,int r,int c){\n        if(r<0 || c<0 || r>=arr.length || c>=arr[0].length || arr[r][c]){\n            return false;\n        }\n\n        return true;\n    }\n"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@anwendeng](/anwendeng) tried removing that still getting TLE"
                    },
                    {
                        "username": "anwendeng",
                        "content": "arr[i][j] = false; is unnecessary\\nyou don\\'t need the backtracking"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@codepiyush1](/codepiyush1)  thanks for reply but I\\'m not getting it."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "Use Dynamic Programing in this. Instead of visited array. DP array will store the value if node is already traversed.\\nRecursive take 4^(m*n) Time complexity.\\n DP take (n*m) Time complexity.\\n\\nPlease Upvote. If you understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973854405/"
                    },
                    {
                        "username": "psionl0",
                        "content": "Not the hardest problem this week but I still needed a couple of hints to get going.\nWhat tricked me was believing that if I ran a dfs once then the dp array would be filled. It turns out that you have to run dfs on every position in the grid (if the dp array is filled in this position then this is a quick exercise)."
                    },
                    {
                        "username": "ashishsutar1210",
                        "content": "Try Solving 329. Longest Increasing Path in a Matrix\\n"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "What is the best possible way to make it 100% beats of this problem?"
                    },
                    {
                        "username": "dinhlockt02",
                        "content": "This should be a medium problem."
                    },
                    {
                        "username": "GD18",
                        "content": "I over complicated the question by overthinking it, my first intuition/Solution was a pretty straight forward dfs+memo, but then the hard tag made me overthink that it couldnt be this straight forward  and  so I got sidetracked pretty hard lol, turns out my first intuition/solution was correct all along, so i just went ahead and tried it and it passed, guess this should be a medium,that hard tag kind of is misleading."
                    },
                    {
                        "username": "Aadil42",
                        "content": "Hey, guys when I\\'m trying to solve the problem without memoization I\\'m getting a wrong answer. I am expecting a time limit exeed error. The logic is the same I\\'m DFSing and counting the paths taking module  correctly. But for some reason the code gives me wrong answer. Here\\'s the link to the failed submission. Please help. \\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/submissions/973868751/"
                    },
                    {
                        "username": "venompool",
                        "content": "Even leetcode is aware of the recession situation hence prepping us harder."
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "leetcode editors can spend their time in giving some useful examples atleast"
                    }
                ]
            },
            {
                "id": 1934480,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934454,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934437,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934409,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934369,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934283,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934256,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934225,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934221,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934191,
                "content": [
                    {
                        "username": "codez93",
                        "content": "strictly decreasing hard [in daily challenge].\\n"
                    },
                    {
                        "username": "Lorins",
                        "content": "-?b7lk"
                    },
                    {
                        "username": "natitati",
                        "content": "Actually a hard I could solve."
                    },
                    {
                        "username": "crudiedo",
                        "content": "start your day with another hard problem "
                    },
                    {
                        "username": "Prince_0204",
                        "content": "Problem is easy if you know DP thoroughly. "
                    },
                    {
                        "username": "Bhupendra_Kandavariya",
                        "content": "It should not be considered in hard."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS+ DP Memoization\\n\\n# Approach\\nStep1: declare and initialize dpwe called vis with -1. of size m*n.\\nStep2: mark all the four direction row and column in a array.\\nStep3: run loop to go to each element of grid and do bfs.\\nStep4: for each element 1 element itself is part of answer. because it is of size 1.\\nStep5: in code dfs we refer it as rec. So if we already compute for that index i and j then return that value.\\nStep6: otherwise run a loop for 4 directions. \\nStep7: check if that direction is valid or not and check the next direction value is greater than the current grid index value.\\nStep8: if Yes. then add 1 and call the dfe for that direction.\\nStep9: after completion take the mod of value and store in dp.\\n\\n# Complexity\\n- Time complexity:\\n**T.C=O(4*m*n)= 2 loop in countPaths function + 1 loop which will be called for 4 iteration in worst case.**\\n\\n- Space complexity:\\n**S.C=O(m*n) +O(m+n). O(m*n) is dpor vis vector. O(m+n) recursive stack space.**\\n\\n--------------------------------\\nPlease Upvote. If You understand the concept..\\nSolution link:\\nhttps://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651229/c-dfs-dp-memoization/"
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "somebody used:\\n\\nprivate int mod = (int) (1e9+7)\\n\\nwhat is the meaning of use (1e9+7) in this program and what is main key to achieve 100% beat time complexity in this program."
                    },
                    {
                        "username": "psionl0",
                        "content": "The answers get really big really quickly. They would certainly overflow the standard 32 bit integer range (probably the 64 bit integer range too). \\nWe give our answers modulo 1e9+7 to avoid this overflow."
                    },
                    {
                        "username": "SMajumder2003",
                        "content": "How to make this program with 100% beats?"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "dfs+memo"
                    }
                ]
            },
            {
                "id": 1934137,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1934125,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933820,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933816,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933809,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933808,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933799,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933781,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933744,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            },
            {
                "id": 1933702,
                "content": [
                    {
                        "username": "shubh_cr7",
                        "content": "This is at maximum medium , just pure and simple DFS with memoization."
                    },
                    {
                        "username": "CODEX47",
                        "content": "Hey did anyone applied bfs + memo to solve this problem? I did tried bfs solution which obviously works with a TLE but I am not able to memoize it. Any ideas anyone?\\n\\n<details>\\n<summary>\\nCode\\n</summary>\\n\\n```\\nclass Solution\\n{\\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}, mod = 1e9 + 7; \\npublic:\\n    int countPaths(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                for (queue<pair<int, int>> q{{{i, j}}}; !q.empty();)\\n                {\\n                    (ans += q.size()) %= mod;\\n                    for (int k = sz; k; k--)\\n                    {\\n                        auto [a, b] = q.front();\\n                        q.pop();\\n                        for (auto [dx, dy] : dirs)\\n                        {\\n                            int x = a + dx, y = b + dy;\\n                            if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] > grid[a][b])\\n                                q.push({x, y});\\n                        }\\n                    }\\n                }\\n        return ans;\\n    }\\n};\\n```\\n\\n</details>"
                    },
                    {
                        "username": "satyam47",
                        "content": "Not so hard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDFS + Memo."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "My only value here is to copy & paste the answer :("
                    },
                    {
                        "username": "xxossoo96",
                        "content": "After I got TLE, I realized that I don't need to traverse all the ways"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Holy moly!"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Here we go again, couldn\\'t do problems from last 2 days. Now another one."
                    },
                    {
                        "username": "ajv97",
                        "content": "Brace yourself, Nightmare hard streak is here."
                    },
                    {
                        "username": "zzjharry",
                        "content": "Three HARDs in a row. \\uD83D\\uDE22\\uD83D\\uDE22\\uD83D\\uDE22"
                    },
                    {
                        "username": "72engineers",
                        "content": "hard again...the hardest June"
                    }
                ]
            }
        ]
    },
    {
        "title": "All the Matches of the League",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1712189,
                "content": [
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect \\n    t1.team_name as home_team, \\n    t2.team_name as away_team\\nfrom teams t1\\njoin teams t2\\non t1.team_name <> t2.team_name;\\n```"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.team_name as home_team, b.team_name as away_team\\nFROM Teams as a, Teams as b\\nWhere a.team_name != b.team_name"
                    }
                ]
            },
            {
                "id": 1885157,
                "content": [
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect \\n    t1.team_name as home_team, \\n    t2.team_name as away_team\\nfrom teams t1\\njoin teams t2\\non t1.team_name <> t2.team_name;\\n```"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a.team_name as home_team, b.team_name as away_team\\nFROM Teams as a, Teams as b\\nWhere a.team_name != b.team_name"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Impossible Sequence of Rolls",
        "question_content": "<p>You are given an integer array <code>rolls</code> of length <code>n</code> and an integer <code>k</code>. You roll a <code>k</code> sided dice numbered from <code>1</code> to <code>k</code>, <code>n</code> times, where the result of the <code>i<sup>th</sup></code> roll is <code>rolls[i]</code>.</p>\n\n<p>Return<em> the length of the <strong>shortest</strong> sequence of rolls that <strong>cannot</strong> be taken from </em><code>rolls</code>.</p>\n\n<p>A <strong>sequence of rolls</strong> of length <code>len</code> is the result of rolling a <code>k</code> sided dice <code>len</code> times.</p>\n\n<p><strong>Note</strong> that the sequence taken does not have to be consecutive as long as it is in order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> rolls = [4,2,1,2,3,3,2,4,1], k = 4\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Every sequence of rolls of length 1, [1], [2], [3], [4], can be taken from rolls.\nEvery sequence of rolls of length 2, [1, 1], [1, 2], ..., [4, 4], can be taken from rolls.\nThe sequence [1, 4, 2] cannot be taken from rolls, so we return 3.\nNote that there are other sequences that cannot be taken from rolls.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> rolls = [1,1,2,2], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Every sequence of rolls of length 1, [1], [2], can be taken from rolls.\nThe sequence [2, 1] cannot be taken from rolls, so we return 2.\nNote that there are other sequences that cannot be taken from rolls but [2, 1] is the shortest.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> rolls = [1,1,3,2,2,2,3,3], k = 4\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The sequence [4] cannot be taken from rolls, so we return 1.\nNote that there are other sequences that cannot be taken from rolls but [4] is the shortest.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == rolls.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i] &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2322280,
                "title": "java-c-python-one-pass-o-k-space",
                "content": "# **Intuition**\\nFor the first number, it could be any number from 1 to k.\\nSo my intuition is to check the first occurrence of all number from 1 to k.\\n<br>\\n\\n# **Explanation**\\nWe check the first occurrences of all number from `A[0]`.\\nAssume `A[i]` is the rightmost one among them,\\nwhich is the first occurrence of a number in `[1,k]`.\\n\\nThat means from `A[0]` to `A[i]`,\\nwe have seen all numbers at least once.\\nIn other words, `A[0]` to `A[i]` forms our first **complete set** including all numbers.\\n\\nThis complete set can satisfy any number from 1 to `k`,\\nas the first number in the sequence.\\n\\nThen we continue this process, to find out the next complete set.\\nWe continue doing this, and assume we can find `x` complete sets in total.\\nThere may ramian some elements, but the rest can not form one more set of all numebr.\\n\\nThen we can take any sequence of length `x`,\\n`x + 1` is the length of the shortest sequence of rolls,\\nthat cannot be taken from rolls.\\n\\nWe simply returns `x + 1`.\\n\\n\\n# **Prove**\\nAssume there are `x` complete sets in the rolls.\\n\\n1) We can take any sequence of length `x`\\nwe can take any number from a complete set\\n\\n2) We can\\'t take all sequence of length `x + 1`\\nWe can contruct one sequence `S` that we can\\'t take.\\n\\n`S[0]` is the last element in the first complet set\\n`S[1]` is the last element in the second complet set\\n...\\n\\n`S[x]` is one element which is not in the incomplete set after `x` complete set\\n\\nWith 1) and 2),\\nwe prove that `x + 1` is the length of the shortest sequence of rolls\\nthat cannot be taken from rolls.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(k)`\\n<br>\\n\\n**Java**\\n```java\\n    public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2322324,
                "title": "c-o-n-simple-to-understand",
                "content": "\\n  It looks like a very heavy Question but believes me It is Not,\\n  It may be difficult for you to understand why it is Working but, DRY RUN for 1-2 times and you will understand,\\n  \\n  LOGIC:\\n    First, I found the number which had the last occurrence in rolls means the first point where all the elements       are visited for once,\\n    so by this, I conclude, that the sequence of length 1 is always possible,\\n    Then I continue doing this and continue to increase my and, as I found the all number from 1 - K\\n    AT last, I return The ANS,\\n\\t\\nSummary :\\nTo make all combinations of length len of k numbers we need to have numbers 1-k atleast appearing len times in the array :\\nExample : for k = 3 len = 2\\nAll possible sequences :\\n=> 1 1, 1 2, 1 3, 2 1, 2 2, 2 3, 3 1, 3 2, 3 3\\nto create all those possibilities of arrangements we need to have 1,2,3,1,2,3 in the array as a subsequence (single 1-k group of numbers can be in any order i.e, we\\ncan also have 3,2,1,3,2,1 or 2,3,1,1,3,2 etc.)\\nwhich is numbers from 1-k must be appearing len times in the array as a subsequence.\\n\\nHAPPY CODING :)\\n***IF YOU LEARN SOMETHING FROM THIS POST, PLEASE UPVOTE IT***\\n\\n\\t```\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        map<int,int> m;\\n        int c=0,ans=0;\\n        for(auto a:rolls){\\n           m[a]++;\\n            if(m[a]==1) c++;\\n            if(c==k){\\n                c=0;\\n                m.clear();\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        map<int,int> m;\\n        int c=0,ans=0;\\n        for(auto a:rolls){\\n           m[a]++;\\n            if(m[a]==1) c++;\\n            if(c==k){\\n                c=0;\\n                m.clear();\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322321,
                "title": "count-subarrays-with-all-dice",
                "content": "\\nFor a sequence of size 1, all `k` dice must appear in `rolls`.\\nFor a sequence of size 2, all `k` dice must appear after all `k` dice appear in `rolls`.\\n... and so on.\\n \\nSo, we go through `rolls` and count unique dice.\\n    \\nWhen we have all `k` dice, we increase the number of sequences `seq` and reset the counter.\\n\\n> Implementation note: instead of resetting the counter, we use the sequence number to check if a dice has appeared for the current sequence.\\n> When we have all dice, we increase `seq`, so all dice must appear again.\\n\\n **Java**\\n ```java\\n public int shortestSequence(int[] rolls, int k) {\\n    int seq = 0, cnt = 0, dice[] = new int[k + 1];\\n    for (var r : rolls)\\n        if (dice[r] == seq) {\\n            dice[r] = seq + 1;\\n            if (++cnt % k == 0)\\n                ++seq;\\n        }\\n    return seq + 1;\\n}\\n ```\\n**C++**\\n```cpp\\nint shortestSequence(vector<int>& rolls, int k) {\\n    int seq = 0, cnt = 0, dice[100001] = {};\\n    for (auto r : rolls)\\n        if (dice[r] == seq) {\\n            dice[r] = seq + 1;\\n            if (++cnt % k == 0)\\n                ++seq;\\n        }\\n    return seq + 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\n public int shortestSequence(int[] rolls, int k) {\\n    int seq = 0, cnt = 0, dice[] = new int[k + 1];\\n    for (var r : rolls)\\n        if (dice[r] == seq) {\\n            dice[r] = seq + 1;\\n            if (++cnt % k == 0)\\n                ++seq;\\n        }\\n    return seq + 1;\\n}\\n ```\n```cpp\\nint shortestSequence(vector<int>& rolls, int k) {\\n    int seq = 0, cnt = 0, dice[100001] = {};\\n    for (auto r : rolls)\\n        if (dice[r] == seq) {\\n            dice[r] = seq + 1;\\n            if (++cnt % k == 0)\\n                ++seq;\\n        }\\n    return seq + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323263,
                "title": "easy-to-understand-java-solution-o-n-with-explanation-with-question-explain",
                "content": "Since i found it difficult to understand the question in the first go, so we will begin from understanding the question.\\n\\n#### Understanding the question:\\n\\nIn our question we are given an **integer array rolls** where **rolls[i] is the result of i\\'th roll**. **We have a dice which has k sides number from 1 to k(inclusive)**.\\n\\nBasically we need to **find the length of shortest sequence that cannot be created using our rolls array**.\\nEg: \\n```\\nInput: rolls = [4,2,1,2,3,3,2,4,1], k = 4\\nOutput: 3\\n```\\nAll sequence of length 1 : [1], [2] , [3] , [4] can be formed since all these are present in our rolls array\\nAll sequence of length 2 : \\n\\t[1,1] : (Pos 3, Pos 9)\\n\\t[1,2] : (Pos 3, Pos 7)\\n\\t[1,3] : (Pos 3, Pos 6)\\n\\t[1,4] : (Pos 3, Pos 8)\\n\\t[2,1] : (Pos 2, Pos 9)\\n\\t[2,2] : (Pos 2, Pos 7)\\n\\t[2,3] : (Pos 2, Pos 6)\\n\\t[2,4] : (Pos 2, Pos 8)\\n\\t.\\n\\t.\\n\\t.\\nAll sequence of length 3:\\n\\t[1,1,1] : (Pos 3, Pos 9, Not Found ) :  **This results in an impossible sequence** .\\n\\t[2,2,2] : (Pos 2, Pos 7, **Not Found** ) : **This results in an impossible sequence**.\\n\\t[1,4,2] : (Pos 3, Pos 8, **Not found**) : **This results in an impossible sequence**.\\n\\t\\nTherefore the **shortest length of imossible sequence is 3**.\\n\\n\\n#### Deriving intution for the solution :\\n\\n**If any of the element in the range [1,k] is not present in our rolls array then the length of shortest impossible sequence will be 1**.\\n\\nEg:\\n```\\nInput: rolls = [1,1,3,2,2,2,3,3], k = 4\\nOutput: 1\\n```\\n\\nSince for this it would be **impossible to find a sequence [4] therefore the answer is 1** .\\n\\n***Thus we can say that if suppose we get an index i upto which we have find all our elements from [1,k] i.e (rolls[0]....rolls[i] contains all the elements from [1,k]) then we can ensure that all the sequences of length 1 are possible, lets mark this index as idx1.***\\n\\n***Now let us suppose we get an index i (i>idx1) upto which we have find all our elemnts from [1,k] i.e (rolls[idx1+1]..........rolls[i] contains all the elements from [1,k]) then we can ensure that all the sequences of length 2 are possible.***\\n\\nHere ***we can surely say that all our sequence of length 2 will be possible because we can surely say that all the integers in the range[0,idx1] contains all our integers from range[1,k] (This subarray will contribute for the first element of our sequence) and all the integers in the range[idx1+1,idx2] again contains all the integers (This subarray will contribute for the second element of our sequence).***\\n\\nLet us consider an example : \\n\\n```\\nInput: rolls = [4,2,1,2,3,3,2,4,1], k = 4\\nOutput: 3\\n\\n```\\n\\n (Digit 1)    (Digit 2)\\n|--------|     |------|\\n4 2 1 2 3    3 2 4 1\\n\\nHere our subarray **(Digit1) can make all the sequences of length 1**.\\n\\nIf we consider taking **first digit from digit1 and second digit from digit2 then all the combinations of length 2 can be created**. Thus all the sequences of **length 2 are also be created and thus possible**.\\n\\nSince we are **unable to find third such subarray which contains all the elements**. Therefore it would be **impossible to create all the sequences of length 3**.\\n\\nThus our ***answer is 3***.\\n\\n### Final Solution\\n\\nBy doing this we can calculate the maximum length upto which all our sequences will be valid and thus our answer will be maximum sequence length + 1;\\n\\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int len = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:rolls)\\n        {\\n            set.add(i);\\n            if(set.size()==k)\\n            {\\n                set = new HashSet<>();\\n                len++;\\n            }\\n        }\\n        return len+1;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n) \\n\\nSpace Complexity : O(k) \\n\\nFeel free to ask any doubts in the comment section.\\n\\n***Hope this helps :)***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInput: rolls = [4,2,1,2,3,3,2,4,1], k = 4\\nOutput: 3\\n```\n```\\nInput: rolls = [1,1,3,2,2,2,3,3], k = 4\\nOutput: 1\\n```\n```\\nInput: rolls = [4,2,1,2,3,3,2,4,1], k = 4\\nOutput: 3\\n\\n```\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int len = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for(int i:rolls)\\n        {\\n            set.add(i);\\n            if(set.size()==k)\\n            {\\n                set = new HashSet<>();\\n                len++;\\n            }\\n        }\\n        return len+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323545,
                "title": "logic-and-catch-behind-that-five-line-code",
                "content": "so basically we have to make sure that of size 1,2,3,4...k and numbers from[1,2,3,4,.....k] we have every possible permutation.so how will we solve that,\\nlet say for size 2 we have to find out for k =3, so what are all the combinations, [1,1],[1,2] ,[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]....since there are 9 cases only here we can check for all but what if k is large like 7 or 8 ,how will we make sure that till what size we are getting every possible combination,so the catch is separate it into sets of size k , let say about out first test case[4,2,1,2,3,3,2,4,1]\\nwe will iterate till our set size is 4 so we will go like\\n4 - set size 1\\n4,2 - set size 2\\n4,2,1 - set size 3\\n4,2,1,2 - set size 3 (set only contains unique elements)\\n4,2,1,2,3 - set size 4 \\nso now we have one pack of set of size 4 \\nso if someone say bro can u make any combination of size 1 - i\\'ll say yes!! i can make because i have all values present from 1 to k in my first pack\\nnow let\\'s start making other pack so,\\n3 - set size 1\\n3,2 - set size 2\\n3,2,4 - set size 3\\n3,2,4,1 - set size 4\\nso now i have two packs of set each of size k\\nso if you will ask for any combination of size two i can make ................why?? \\nbecause i have all elements present in both my pack\\nif you will say make 2 3\\nill take 2 from first and 3 from second pack similarly i can make all. therefore the answer is the number of packs we can  make +1\\nsince we can\\'t 3 packs there always will be one combination of 3 which we can\\'t make, and here goes the code!!!!\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n         \\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    \\n    }\\n};\\n```\\ni hope you get the whole picture around this short code, if you also think that it\\'s too tricky to strike in our mind in live contest , kindly upvote :3",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n         \\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322375,
                "title": "greedy-easy-to-understand-with-approach",
                "content": "**Approach**\\n\\nThe idea is if you\\'re given that you can create a L length array of all permutation of k numbers, with atleast M length of given array used from the begining, then if you do not find all the k numbers after this m length then L + 1 length can not be created.\\n\\n**Let me elaborate**\\nThink of it a bit recurcively, In a Dynamic Programing manner but not exactly DP, rather greedily.\\n\\nYou\\'ve the array rolls, and a number k, which is the number of dice outcome that each roll can consist of, Now if you want to check if you can create all permutation of L length of K numbers, this is, you can create every possible permutation of k numbers with length L for that consider if you know that you can create L - 1 length of permutation with at least m length of the given array that is, it requires at least m length of the given array to create all permutaion of L - 1 length, then to check if you can create a L length array or not is by checking if you can get all the k numbers after m index, in the array so that you can put every number in the L - 1 length permutation to make a L length permutation with every posibility.\\n\\n**Example**\\n\\nrolls = [4,2,1,2,3,3,2,4,1], k = 4\\n\\nNow if I tell you that you can create 1 length permutaion by at least using 5 length of given array, then to check if we can create a 2 length array or not, we have to check if there exist all the 4 numbers in the array or not after 5 length, and in our case there exist all the 4 numbers after 5 ;ength this is in between 6 to 9 length, therefore we can create all the 2 length array, but as it requires atleast 9 length of our given array to make 2 length permutaion, you can not create all the 3 length permutaion as there are not all the numbers to insert after every 2 length permutaion.\\n\\n**Implementation**\\n\\n* Initially consider you can make (len =  1) length permutation subsequence array with starting of the given array.\\n* To hold the above statement true there should be all k numbers to the right.\\n* Make an empty set (data) of numbers.\\n* Iterate untill you make the size of the set equals k this is, you find all the k numbers.\\n* There can be two case\\n1. * If you don\\'t find all the k numbers after iterating all the numbers this means this length permutation can not be created, therefore this is the answer else.\\n2. * If you find all the k numbers before completing the whole iteration, then the current length permutation is fixed that you can create all the permutation of given length, therefore you should make your set empty and increment length by one (len = len + 1) and continue iterating the array with above conditions for incremented length.\\n\\n**Time Complexity**\\n* If you use C++ set then you\\'ll get a time complexity of O(nlogk)\\n\\n**Space Compexity**\\n* O(k) for the set of size k.\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len = 1;\\n        set<int> data ;\\n        \\n        for (int i = 0; i < rolls.size(); i++) {\\n            data.insert(rolls[i]);\\n            \\n            if (data.size() == k) {\\n                len++;\\n                data = set<int>();\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 1\\n        data = set()\\n        \\n        for roll in rolls:\\n            data.add(roll)\\n            \\n            if len(data) == k:\\n                ans += 1\\n                data.clear()\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len = 1;\\n        set<int> data ;\\n        \\n        for (int i = 0; i < rolls.size(); i++) {\\n            data.insert(rolls[i]);\\n            \\n            if (data.size() == k) {\\n                len++;\\n                data = set<int>();\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 1\\n        data = set()\\n        \\n        for roll in rolls:\\n            data.add(roll)\\n            \\n            if len(data) == k:\\n                ans += 1\\n                data.clear()\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326425,
                "title": "c-100-faster-100-less-memory-full-explanation-with-intuition",
                "content": "![image](https://assets.leetcode.com/users/images/2560f211-d287-4002-8434-63c588cab631_1658658926.0119214.png)\\n\\n\\nLet\\'s start by building the intuition around the problem,\\n\\n**Observation:**\\nSo, if we want to build a sequence of size 1. Then all the possible ways are **{1}, {2}, {3}, {4}**.\\nSimilarly, if we want to check for size 2, Then for each of the 1st possible ways i.e({1}, {2}, {3}, {4} )we will have to append all four numbers at the end. i.e\\nFor {1}\\n{1,1} appends 1,\\n{1,2} appends 2,\\n{1,3} appends 3,\\n{1,4} appends 4. \\n\\nSimilarly, for 2 3 4 you can do it yourself.\\n\\nSo we can observe that for making a sequence of size one we needed 1,2,3,4 to occur then we again need 1,2,3,4 for the sequence of size two. \\n\\nFor ex: **3 2 1 4 1 2 3 4** this is the given array then, we can say the first 1,2,3,4 will help us make the sequence of size one and the next 1,2,3,4 will help us make a sequence of size two & so on.\\n\\n**Code Explanation**\\n\\n**Step 1:** Make an unordered set that will help us track the occurrence of distinct numbers.\\n**Step 2:** Loop through the array and insert each element in the set(i.e. unordered_set ).\\n**Step 3:** Count each time the size of the set is == k, and clear the set.\\n**Step 4:** No of counts + 1 is your desired answer.\\n\\n**Practice**\\n* Go and run the test cases on the copy to get the gist of it. \\n* Try now to find examples and make your own, so better understand the logic.\\n\\n**Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        unordered_set<int> s;\\n        int cnt_size = 0;\\n        \\n        for(int i=0 ; i<rolls.size() ; i++){\\n            s.insert(rolls[i]);\\n            if(s.size() == k){\\n                cnt_size++;\\n                s.clear();\\n            }   \\n        }\\n        \\n        return ++cnt_size;\\n    }\\n};\\n```\\n\\n**Happy Leetcoding, please upvote if it helps you.**",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        unordered_set<int> s;\\n        int cnt_size = 0;\\n        \\n        for(int i=0 ; i<rolls.size() ; i++){\\n            s.insert(rolls[i]);\\n            if(s.size() == k){\\n                cnt_size++;\\n                s.clear();\\n            }   \\n        }\\n        \\n        return ++cnt_size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322733,
                "title": "c-easy-to-understand-cpp-code",
                "content": "\\n \\n    int shortestSequence(vector<int> & rolls, int k) {\\n        int n=rolls.size();\\n        set<int> st;\\n        int ans=1;\\n        \\n        for(int i=0;i<n;i++){\\n            st.insert(rolls[i]);\\n            \\n            if(st.size()==k){\\n\\t\\t\\t\\t// we are updating our ans as we our forming all sub-sequence of size ans\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "\\n \\n    int shortestSequence(vector<int> & rolls, int k) {\\n        int n=rolls.size();\\n        set<int> st;\\n        int ans=1;\\n        \\n        for(int i=0;i<n;i++){\\n            st.insert(rolls[i]);\\n            \\n            if(st.size()==k){\\n\\t\\t\\t\\t// we are updating our ans as we our forming all sub-sequence of size ans\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2322380,
                "title": "python-o-n-1-pass-explanation-intuition-code",
                "content": "**Question**\\nWe have to find the smallest length such that there exists at least one subsequence of that length which can not be formed by the given array.\\n\\n**Intuition**\\nLets say **magically** we know that all the subsequence of length x-1 can be formed between index *i->len(rolls)-1* (both inclusive).\\nWe need to check if all elements **exists** between 0->i-1 (both inclusive), \\nto know that we can form all subsequences of length x.\\n\\nThis is true as \\n- We can pick a element from between 0->i-1 \\n- Add it to a subsequence of length x-1, \\n*that we magically know exists between index i->len(rolls)-1 (both inclusive).*\\n\\n**If all elements exists between index j->i-1 (both inclusive),**\\n - **We now are at same subproblem as above** \\n - **We know that all the subsequence of length x can be formed between index *j->len(rolls)-1* (both inclusive).** \\n - **So we just repeat for length x+1 and so on**\\n\\n*We can start by assuming the length x=1 then subsequently increasing it. (As subsequence of length 0 can always be formed, i.e. [])*\\n\\n**For Example**\\n**for array = [4,2,1,2,3,3,2,4,1], k=4**\\n\\n*subsequence length =1,*\\n- at index =5, arr[index]=3. |*Righmost index*\\n- We can form all possible subsequences of length 1 between 5->8(both inclusive), i.e. [1],[2],[3],[4]\\n\\n*subsequence length =2,*\\nAt index=4, arr[index] =3\\n- We already know that all of the subsequences of length = 1 can be formed from index 5.\\n- We can now deduce that all of subsequences of length = 2, starting with *3* can be formed from index 4 onwards.\\ni.e. [3,1],[3,2],[3,3],[3,4]\\n\\nSo Similarly, \\n*subsequence length = 2*\\n- at index = 2, arr[index]=1.\\n- We can form all possible subsequences of length 2, i.e. [1,1],[1,2],[1,3],[1,4]....[4,3],[4,4]. \\n\\n*subsequence length = 3* \\n- Can not be validated at even index = 0, as we still can not form all possible subsequences starting with 1,3.\\n\\n**Explanation**\\n\\nStarting from level = 1 (Assuming all subsequences of level 0 can be formed as [])\\nWe just need to find the rightmost indexes for each level, where we have found all the elements upto k atleast 1 time excluding the previous level.\\n\\nThis works because as soon as we find the rightmost index where all elements have been found at least once for this level, we know we can start from all the elements in this level, without using any of the previous levels. Also we know we can form all the subsequences of level-1 afterwards as we have already formed them in the previous level.\\n\\n**Note : - Same algorithm can be adjusted to work with leftmost indexes.**\\n\\n**Complexity**\\nTime O(n)\\nSpace O(k)\\n\\n**Code**\\n\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        \\n        i=len(rolls)-1\\n        visit=set()\\n        c=1\\n        while i>=0:\\n            visit.add(rolls[i])\\n            if len(visit)==k:\\n                c+=1\\n                visit=set()\\n            i-=1\\n        return c\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        \\n        i=len(rolls)-1\\n        visit=set()\\n        c=1\\n        while i>=0:\\n            visit.add(rolls[i])\\n            if len(visit)==k:\\n                c+=1\\n                visit=set()\\n            i-=1\\n        return c\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332942,
                "title": "c-detailed-and-easy-to-understand-with-diagram",
                "content": "#### 1. Whats being asked?\\nIn simple words the question is asking for what minimum length L, a sequence of possible dice moves of length L is not possible. This also mean that for length < L, all possible dice moves of that length are allowed.\\n\\n#### 2. Brute force approach\\nAfter being clear about what is being asked one can think of the brute force way of doing this.\\nFor each length lets generate all possible dice moves.\\nFor eg: Let rolls = [1, 2, 2, 3, 1] and for L = 2, and k = 3 we generate [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3]\\nWe can then check if each of the generated possible dice moved of length L can be found as a [subsequence](https://en.wikipedia.org/wiki/Subsequence) within the rolls array.\\n\\nNow lets think what will be the time complexity for doing this check for a length L, k sided dice and rolls array of length n.\\n\\nFor generating the possible dice moves of length L we have [(k possibility), (k possibility) ... (k possibility)], i.e  L^k possible dice moves.\\nFor checking if it occurs as a subsequence, N comparisions at max with the rolls array.\\nThus overall it takes for a checking a particular length L is, O(n * L^k) \\n\\nWe can do better than this.\\n\\n#### 3. Some observations\\nFor rolls = [1, 2, 2, 3, 1, 3, 2, 2,1, 1], k = 3\\n![len1](https://assets.leetcode.com/users/images/d746320d-5900-46a3-b65a-16157ca23d6a_1658769532.7746508.jpeg)\\n![len2](https://assets.leetcode.com/users/images/f07d0601-f697-45dc-b7eb-4b1b6d82d7fb_1658769561.2729216.jpeg)\\n\\n\\n#### 4. Solution\\nIf we carefully oberserve all ways for generating the possible dice moves in the brute force and the observations we can see that essentially for being able to generate all possible moves of length L we need to find L non overlapping subarrays such that it they each contains all elements from 1 to k.\\n\\n#### 5. Implementation details\\n1. Keep a variable maxPossibleLength to keep track of number of subarrays found. Initialized to zero.\\n2. Interate over the rolls array and keep a set to track the elements visited.\\n3. Keep on inserting the elements of rolls in the set.\\n4. Once the size of set is equal to k, increment maxPossibleLength and clear the set.\\n5. After finishing the iteration, return maxPossibleLength + 1. We add 1 as all dice moves of this length is not possible.\\n\\n#### 6. Code\\n```\\nclass Solution {\\npublic:\\n\\tint shortestSequence(vector<int>& rolls, int k) {\\n\\t\\tint maxPossibleLength = 0;\\n\\t\\tset<int> st;\\n\\t\\tfor (int& r : rolls) {\\n\\t\\t\\tst.insert(r);\\n\\t\\t\\tif ((int)st.size() == k) {\\n\\t\\t\\t\\tmaxPossibleLength++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxPossibleLength + 1;\\n\\t}\\n};\\n```\\n\\n#### 7. Time and space complexity analysis\\n##### Space Complexity:\\nO(k) (As at max k elements are stored in the set at a point of time)\\n##### Time Complexity:\\n1. When using ordered set: O(nlogk)\\n2. When using unordered set: O(n)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint shortestSequence(vector<int>& rolls, int k) {\\n\\t\\tint maxPossibleLength = 0;\\n\\t\\tset<int> st;\\n\\t\\tfor (int& r : rolls) {\\n\\t\\t\\tst.insert(r);\\n\\t\\t\\tif ((int)st.size() == k) {\\n\\t\\t\\t\\tmaxPossibleLength++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn maxPossibleLength + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322258,
                "title": "c-easy-full-explains",
                "content": "We can look at the examples and find out the algorithm:\\n\\nInput: rolls = [4,2,1,2,3,3,2,4,1], k = 4:\\n\\n![image](https://assets.leetcode.com/users/images/c69abb0c-9780-4e2f-aec0-12798bb84744_1658593127.0967429.png)\\n\\n**Output: 2 , because only 1 level is fully filled**\\n\\n**Algorithm:**\\n* iterate through rolls\\n* every new roll value possibly \"extends\" the set of values of current level\\n* if current level contains all possible roll values {1, ..., k} - current level is fully filled, we can start a new level\\n* the shortest sequence which cannot be taken from rolls is longer by 1 than our count of fully filled levels\\n\\n* **Time complexity** : `O(N)` - linear in rolls size\\n* **Space complexity** : `O(K)` - the curLevelNumbers set can contain up to K numbers.\\n\\n```\\nint shortestSequence(vector<int>& rolls, int k) {\\n    unordered_set<int> curLevelNumbers; // roll values of current level\\n    int fullLevelsCount = 0;\\n    for (int roll : rolls) {\\n        curLevelNumbers.insert(roll);\\n        if (curLevelNumbers.size() == k) {\\n            // If current level is fully filled with `k` numbers {1, ..., k} - start a new level, increment the `fullLevelsCount`:\\n            ++fullLevelsCount;\\n            curLevelNumbers.clear();\\n        }\\n    }\\n    return fullLevelsCount + 1; // the shortest sequence is longer by `1` than the `full levels count`.\\n}\\n```\\n**If you like please upvote **",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint shortestSequence(vector<int>& rolls, int k) {\\n    unordered_set<int> curLevelNumbers; // roll values of current level\\n    int fullLevelsCount = 0;\\n    for (int roll : rolls) {\\n        curLevelNumbers.insert(roll);\\n        if (curLevelNumbers.size() == k) {\\n            // If current level is fully filled with `k` numbers {1, ..., k} - start a new level, increment the `fullLevelsCount`:\\n            ++fullLevelsCount;\\n            curLevelNumbers.clear();\\n        }\\n    }\\n    return fullLevelsCount + 1; // the shortest sequence is longer by `1` than the `full levels count`.\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323291,
                "title": "my-thought-process-during-contest-explained-and-clean-cpp-code-using-map",
                "content": "My intution for this solution was that we will be able to compute permutaion of any particular size when we will have that much basket of number from 1 to k in continous order.\\nex: [1, 2, 3, 4, 1, 2, 3, 4] \\nhere we can generate all permuation of two size because we can pick one element from first basket (index 0 to 3) and another from 2nd basket (index 4 to 7).\\nEx: [1, 2], [4, 4], [3, 2], [2, 3],....\\nNote: in the above example array could be [2, 3, 4, 1, 1, 2, 3, 4] .\\n```\\nint shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int cnt = 0;\\n        map<int, int>mp;\\n        for(auto i: rolls){\\n            mp[i]++;\\n\\t\\t\\t//my basket is having numbers from 1 to k\\n            if(mp.size() == k){\\n                mp.clear();\\n                cnt++;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n\\t```\\n\\tUpvote if u like this :)\\n\\tComment if any doubt.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int cnt = 0;\\n        map<int, int>mp;\\n        for(auto i: rolls){\\n            mp[i]++;\\n\\t\\t\\t//my basket is having numbers from 1 to k\\n            if(mp.size() == k){\\n                mp.clear();\\n                cnt++;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322538,
                "title": "c-easy-short-and-concise",
                "content": "```  \\nint shortestSequence(vector<int>& rolls, int k) {\\n          int ans=0,i;\\n        int n=size(rolls);\\n        unordered_map<int,int>m;\\n        for(i=n-1; i>=0; i--){\\n            m[rolls[i]]++;\\n            if(m.size()==k){\\n                ans++;\\n                m.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n",
                "solutionTags": [],
                "code": "```  \\nint shortestSequence(vector<int>& rolls, int k) {\\n          int ans=0,i;\\n        int n=size(rolls);\\n        unordered_map<int,int>m;\\n        for(i=n-1; i>=0; i--){\\n            m[rolls[i]]++;\\n            if(m.size()==k){\\n                ans++;\\n                m.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2322394,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> st;\\n        int ans=1;\\n        for(int x:rolls){\\n            if(!st.count(x))st.insert(x);\\n            if(st.size()==k){\\n                st.clear();\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> st;\\n        int ans=1;\\n        for(int x:rolls){\\n            if(!st.count(x))st.insert(x);\\n            if(st.size()==k){\\n                st.clear();\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558692,
                "title": "c-set",
                "content": "get no of segment which has all [1..k] element\\'s of array.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int a = 1;\\n        for(auto &i: rolls){\\n            s.insert(i);\\n            if(s.size()==k){\\n                a++;\\n                s.clear();\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int a = 1;\\n        for(auto &i: rolls){\\n            s.insert(i);\\n            if(s.size()==k){\\n                a++;\\n                s.clear();\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329780,
                "title": "c-o-n-intuitive-approach-w-sets",
                "content": "This is agruably one of the Easiest-Hard problem. \\nWe are asked to find the shortest subsequence which can not be formed from the given array, given that the array only contains elements from 1 to k. From this, we can think of the fact that if we have exactly one occurance of each element from 1 to k, then it is possible to form evey possible subsequence of size 1 from the array. Similiarly, if we are asked to form a subsequence of size 2, then we will check if we have atleast two occurences of each element from 1 to k. If we do have alteast 2 occurences, we can form every possible subsequence of size 2, else we willl have atleast one subsequence of size 2 which will not be possible. \\n____________________________________________________________________________________________________________________\\nFor ex.\\n```\\nk = 6\\nnums = [5, 6, 6, 2, 3, 6, 4, 6, 1, 5,  4,  5,  3,  3,  5,  4,  3,  1,  3,  5,  4,  2]\\n\\n      \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\"\\n\\nAnswer will be 2 because [1,6] is not possible.\\n```\\nNow, we can see that the last occurance of 6 is at index 7 and the first occurance of 1 is at index 8. So, subsequence [1,6] is simply not possible. To achieve our goal, i used set, where i keep pushing elements inside set and once i have all the k elements in it, I increase our answer length by 1 because we have atleast one occurance of each element, thus a subsequence of 1 length is unavoidable. In above example, we will see that, at index 8, we will have atleast one occurance of each element, therefore our ans will be incremented by 1 here, but after this index, we will never have all the elements in our set, and therefore, our final answer will be 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set <int> s;\\n        int count = 0;\\n        for(int i = 0; i<rolls.size(); i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                count++;\\n                s.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nk = 6\\nnums = [5, 6, 6, 2, 3, 6, 4, 6, 1, 5,  4,  5,  3,  3,  5,  4,  3,  1,  3,  5,  4,  2]\\n\\n      \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]\"\\n\\nAnswer will be 2 because [1,6] is not possible.\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set <int> s;\\n        int count = 0;\\n        for(int i = 0; i<rolls.size(); i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                count++;\\n                s.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323221,
                "title": "java-using-set",
                "content": "```\\nclass Solution {\\n\\tpublic int shortestSequence(int[] arr, int k) {\\n\\t\\tint res = 1;\\n\\t\\tint index = 0;\\n\\t\\twhile (true) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor (int i = index; i < arr.length; i++) {\\n\\t\\t\\t\\tif (set.contains(arr[i]))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tset.add(arr[i]);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tmax = Math.max(max, i);\\n\\t\\t\\t\\t\\tif (set.size() == k) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count < k) {\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tindex = max + 1;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int shortestSequence(int[] arr, int k) {\\n\\t\\tint res = 1;\\n\\t\\tint index = 0;\\n\\t\\twhile (true) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\t\\tfor (int i = index; i < arr.length; i++) {\\n\\t\\t\\t\\tif (set.contains(arr[i]))\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tset.add(arr[i]);\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tmax = Math.max(max, i);\\n\\t\\t\\t\\t\\tif (set.size() == k) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (count < k) {\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\t\\t\\tindex = max + 1;\\n\\t\\t\\tres++;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323073,
                "title": "c-javascript-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& nums, int k) {\\n        unordered_set<int>s;\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(nums[i]);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n\\n```\\nvar shortestSequence = function(nums, k) {\\n    let ans=0;\\n    let st=new Set();\\n    for(let it of nums){\\n        st.add(it);\\n        if(st.size===k){\\n            ans++;\\n            st=new Set();\\n        }\\n    }\\n    return ans+1;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& nums, int k) {\\n        unordered_set<int>s;\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(nums[i]);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```\\nvar shortestSequence = function(nums, k) {\\n    let ans=0;\\n    let st=new Set();\\n    for(let it of nums){\\n        st.add(it);\\n        if(st.size===k){\\n            ans++;\\n            st=new Set();\\n        }\\n    }\\n    return ans+1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322425,
                "title": "easy-c-one-pass-solution-with-explaination-and-approach",
                "content": "**Intuition and Approach:** Suppose if we can make sequences of length 2 till some index \\nFor eg, if we can make all sequences of length 2({1,1}{1,2}{1,3}{1,4}{2,1}{2,2}{2,3}{2,4}{3,1}{3,2}{3,3}{3,4}{4,1}{4,2}{4,3}{4,4}) till some index m, then to make sequence of length 3 we will need all the numbers to be present after index m\\nFor this purpose, we initialise a set and remove the number whenever we see it in a set and when set becomes empty we increment the ans, in order to avoid initialising the set again we choose other set to copy the values.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n=rolls.size();\\n        int ans=1;\\n        set<int> s1,s2;\\n        for(int i=1;i<=k;i++)\\n            s1.insert(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s1.find(rolls[i])!=s1.end())\\n            {\\n                s1.erase(rolls[i]);   //remove from set s1 and insert in s2\\n                s2.insert(rolls[i]);  \\n            }\\n            if(s1.empty())\\n            {\\n                ans++;   // when s1 is empty increment the ans and initialise it with s2;\\n                s1=s2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n=rolls.size();\\n        int ans=1;\\n        set<int> s1,s2;\\n        for(int i=1;i<=k;i++)\\n            s1.insert(i);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s1.find(rolls[i])!=s1.end())\\n            {\\n                s1.erase(rolls[i]);   //remove from set s1 and insert in s2\\n                s2.insert(rolls[i]);  \\n            }\\n            if(s1.empty())\\n            {\\n                ans++;   // when s1 is empty increment the ans and initialise it with s2;\\n                s1=s2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322363,
                "title": "easy-c-thinking-process",
                "content": "1. Longest increase sub-sequence should start with some number b/w 1 and k\\n2. If there are 2 number and i and j (i < j), if sub-sequence of len x is possible starting with jth element, then it is definitely possible starting with ith but not vice-versa.\\n\\nExample [1,1,4,3,4,2,1,2,3, 4]  k = 4\\nLets take i = 4, j = 5\\nWe see sub-sequence of len(2) are possible starting with jth element [2, 1], [2,2]...\\nThis confirms that sub-sequence of len(2) are possible starting with ith element because with can take take ith element and all len(1) sub-sequences from previous sub-sequences.\\n\\n3. So, for all the possible starting number, if we take the last occurring starting number, it has most chances of having first impossible sub-sequence. \\n\\nExample \\n[1,1,4,3,4,2,1,2,3, 4]\\n\\nWe take first starting index j = 5. \\nNow we have to keep doing same for the remaining array starting from (j+1)\\n```\\n\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        set<int> myset;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            myset.insert(rolls[i]);\\n            if(myset.size() == k){\\n                ans++;\\n                myset.clear();\\n            }\\n        }\\n        return (ans+1);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        set<int> myset;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            myset.insert(rolls[i]);\\n            if(myset.size() == k){\\n                ans++;\\n                myset.clear();\\n            }\\n        }\\n        return (ans+1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593408,
                "title": "simple-logic-greedy-hashing",
                "content": "->if we can make a subarray of length X with all k elements  till index ix ,than the answer will be (X+1) if we can\\'t find at least one of the array element after the index ix\\n->this can be done using set \\n\\n```\\n int n   =  rolls.size();\\n        int cur=  1 ; \\n        set<int>st;\\n        for(int i = 0;i<n;i++){\\n            st.insert(rolls[i]);\\n            if(st.size()==k){\\n                st.clear();//we were able to make all the subarray of size cur so answer will be atleast cur+1\\n                cur++;\\n            }\\n            \\n        }\\n        return cur;\\n        \\n```\\nexample :\\n 1 2 1 1  2 1 1 1 1 1 1 k=2\\n the extra ones don\\'t matter here cause 2 is the bottle neck \\n  set(1 2)  set.clear ->    set(1 2)  set.clear   -> set(1) ->2 is missing \\n1 2 1 1  2 1 1 1 1 1 1 k=3\\n 3 is missing so answer =3",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n int n   =  rolls.size();\\n        int cur=  1 ; \\n        set<int>st;\\n        for(int i = 0;i<n;i++){\\n            st.insert(rolls[i]);\\n            if(st.size()==k){\\n                st.clear();//we were able to make all the subarray of size cur so answer will be atleast cur+1\\n                cur++;\\n            }\\n            \\n        }\\n        return cur;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403346,
                "title": "easy-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int>s;\\n        \\n        int ans=0;\\n        for(auto ele:rolls){\\n            s.insert(ele);\\n            if(s.size()==k){\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int>s;\\n        \\n        int ans=0;\\n        for(auto ele:rolls){\\n            s.insert(ele);\\n            if(s.size()==k){\\n                ans++;\\n                s.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2373457,
                "title": "just-medium-question-just-analyze-for-atleast-10-test-cases",
                "content": "```\\ndef shortestSequence(self, rolls: List[int], k: int) -> int:\\n        #what are thoughts coming in mind?\\n        #lets check for k=5 what are minimum possible values requrie {1,2,3,4,5} for 1st combination\\n        #lets check for k=5 what are minimum possible values require {1,2,3,4,5,1,2,3,4,5} is it make sense \\n        #similarly k=3 we want{1,2,3,4,5,1,2,3,4,5,1,2,3,4,5}\\n        #we get a solution thats fine (count the number of [1:k] values present in rolls in a sequential manner(one after another as i said above))\\n        res=1\\n        s=set()\\n        for i in rolls:\\n            s.add(i)\\n            if len(s)==k:\\n                res+=1\\n                s.clear()\\n        return res",
                "solutionTags": [],
                "code": "```\\ndef shortestSequence(self, rolls: List[int], k: int) -> int:\\n        #what are thoughts coming in mind?\\n        #lets check for k=5 what are minimum possible values requrie {1,2,3,4,5} for 1st combination\\n        #lets check for k=5 what are minimum possible values require {1,2,3,4,5,1,2,3,4,5} is it make sense \\n        #similarly k=3 we want{1,2,3,4,5,1,2,3,4,5,1,2,3,4,5}\\n        #we get a solution thats fine (count the number of [1:k] values present in rolls in a sequential manner(one after another as i said above))\\n        res=1\\n        s=set()\\n        for i in rolls:\\n            s.add(i)\\n            if len(s)==k:\\n                res+=1\\n                s.clear()\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2368563,
                "title": "c-masterpiece-solution-o-n-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nWe are trying to break the list into max number of groups that consist of [1, k] elements. \\nThe length of the group+1 is the combination that is not possible\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size(), ans = 1;\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[rolls[i]]++;\\n            if(um.size() == k)\\n            {\\n                ans++;\\n                um.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nWe are trying to break the list into max number of groups that consist of [1, k] elements. \\nThe length of the group+1 is the combination that is not possible\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size(), ans = 1;\\n        unordered_map<int, int> um;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[rolls[i]]++;\\n            if(um.size() == k)\\n            {\\n                ans++;\\n                um.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334592,
                "title": "cpp-java-solutions-o-n-using-bitset",
                "content": "**CPP Solution**\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        bitset<100005> b;\\n        int res = 0,cnt = 0;\\n        for(int &i: rolls){\\n            if(b[i] == 0){\\n                b[i] = 1;\\n                cnt++;\\n            }\\n             if(cnt== k){\\n                b.reset();\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res+1;\\n    }\\n};\\n```\\n\\n**Java Solution**\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(k)\\n\\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        BitSet b = new BitSet(k+1);\\n        int cnt = 0,res = 1;\\n        for(int i = 0 ; i < rolls.length ;i++){\\n            if(b.get(rolls[i]) == false){\\n                b.set(rolls[i]);\\n                cnt++;\\n            }\\n            if(cnt == k){\\n                res++;\\n                cnt = 0;\\n                b.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        bitset<100005> b;\\n        int res = 0,cnt = 0;\\n        for(int &i: rolls){\\n            if(b[i] == 0){\\n                b[i] = 1;\\n                cnt++;\\n            }\\n             if(cnt== k){\\n                b.reset();\\n                res++;\\n                cnt = 0;\\n            }\\n        }\\n        return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        BitSet b = new BitSet(k+1);\\n        int cnt = 0,res = 1;\\n        for(int i = 0 ; i < rolls.length ;i++){\\n            if(b.get(rolls[i]) == false){\\n                b.set(rolls[i]);\\n                cnt++;\\n            }\\n            if(cnt == k){\\n                res++;\\n                cnt = 0;\\n                b.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323689,
                "title": "c-unordered-set",
                "content": "#  - if we have all k element together we can make sub seq of size 1.\\n#  - so count no. of time all k elements are together.\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> & rolls, int k) {\\n    \\n        unordered_set<int> st;\\n        int ans=1;\\n\\n        for(int i=0;i<rolls.size();i++){\\n            st.insert(rolls[i]);\\n            if(st.size()==k){\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> & rolls, int k) {\\n    \\n        unordered_set<int> st;\\n        int ans=1;\\n\\n        for(int i=0;i<rolls.size();i++){\\n            st.insert(rolls[i]);\\n            if(st.size()==k){\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322650,
                "title": "c-o-n-iterative-solution-using-set",
                "content": "# Algorithm -\\n\\nThe basic idea behind this algorithim is that every sequence of (x) rolls can be obtained be appending every number from 1 to `k` to all sequences of (x-1) rolls \\n\\neg - Let k be 4. Now the possible sequences for two rolls are as follows. If taken a closer look each column is a number from 1 to k added to the possible sequences for 1 roll.\\n<img src=\"https://assets.leetcode.com/users/images/4927b255-9061-4b00-a71b-56b2c77c37f0_1658735150.5346284.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"425\" height=\"350\"/><img src=\"https://assets.leetcode.com/users/images/dd758175-5d56-425c-ad44-7436db91b051_1658735284.9261305.png\" alt=\"closed_paren\" title=\"Closed Parenthesis\" width=\"425\" height=\"340\"/>\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nSo a solution can be formed as follows -\\nWe traverse the vector `rolls` from left to right and keep a count on the numbers found.\\n1. If all numbers from 1 to `k` are not present in `rolls` atleast once, then the answer is 1.\\n2. As soon as all numbers from 1 to `k` have occured atleast once, we can say that answer is = 1 + shortestSequence(of the remaning vector).\\n(this is done because once we find that all k numbers have occured atleast once, then we can append each one to the sequences formed by the numbers ahead)\\n\\nThis gives us a recursive solution.\\n\\nAn iterative approach can also be made as follows -\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ret=1;\\n        unordered_set<int> s;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                ret++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\n\\t\\treturn ret;\\n    }\\n};\\n```\\n\\n# Complexity Analysis -\\n\\nRuntime Complexity - O(n)\\n(Since the vector `rolls` is only traversed once and all set operations inside the loop have an average of O(1) complexity, the overall complexity of the algorithm is O(n), where n is the size of the vector `rolls`)\\n\\nSpace Complexity - O(k)\\n(Since the set is the only componenet occupying space and as it can fill up to a maximum of k elements only, the overall space complexity is O(k), where `k` is the given integer)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ret=1;\\n        unordered_set<int> s;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                ret++;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\n\\t\\treturn ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322588,
                "title": "10lines-c-code-concise-simple-greedy",
                "content": "```\\n  int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> s;\\n        int co=0;\\n        for(auto it:rolls)\\n        {\\n            if(s.find(it)==s.end()) s.insert(it);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                co++;\\n            }\\n        }\\n        return co+1;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n  int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> s;\\n        int co=0;\\n        for(auto it:rolls)\\n        {\\n            if(s.find(it)==s.end()) s.insert(it);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                co++;\\n            }\\n        }\\n        return co+1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322408,
                "title": "very-simple-and-easy-to-understand-c-solution-o-n-time-complexity",
                "content": "<b> Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    //ans is 1 + no. of times 1 to k appers in any sequence\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int m = 1, n = k, ans = 0;\\n        unordered_set<int> st;\\n        for(auto r: rolls){\\n            tst.insert(r);\\n            if(tst.size() == k){\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //ans is 1 + no. of times 1 to k appers in any sequence\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int m = 1, n = k, ans = 0;\\n        unordered_set<int> st;\\n        for(auto r: rolls){\\n            tst.insert(r);\\n            if(tst.size() == k){\\n                ans++;\\n                st.clear();\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800980,
                "title": "javascript-2350-shortest-impossible-sequence-of-rolls",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n```\\nFrom Question\\n  \"sequence taken does not have to be consecutive as long as it is in order.\"\\n    so   order of elements  is important\\n\\nExample 1\\n   when  1,2,3,4    1,2,3,4   occur in sequence\\n   then [1,2,3,4]  [1,2,3,4] groups that has (all 4 elements), are formed\\n     then all possible 2 element sequences are possible\\n      1,1   1,2   1,3   1,4\\n      2,1   2,2   2,3   2,4\\n      3,1   3,2   3,3   3,4\\n      4,1   4,2   4,3   4,4\\n     then some   3 element is not possible    like 1,1,1\\n\\nExample 2\\n   when  1,1,  2,2   3,3,  4,4   occur in sequence\\n   then [1,1,  2,2   3,3,  4]   [4] groups that has (all 4, or, rest of elments) are formed\\n        then some   2 element is not possible    like 2,1\\n\\nConclusion\\n   so number of (all element) groups are important\\n     +1 is answer  ( that is shortest seq not possible - 1,1,1   &  2,1 above)\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nSee above, for explanation\\n\\n```\\nvar shortestSequence = function (a, k) {\\n  let allElementGroups = 0;\\n  let set = new Set()\\n\\n  for (let e of a) {\\n    set.add(e);\\n    if (set.size === k) {\\n      allElementGroups += 1; // all possible distinct elements (1 to k) occured, another group formed, in order\\n      set = new Set(); //       now, reset the set, with no elements to see if another group forms, in order\\n    }\\n  }\\n  return allElementGroups + 1;\\n};\\n```\\n\\nSome tests:\\n```\\n[1,1,2,2,3,3,4,4]\\n4\\n[1,2,3,4,1,2,3,4]\\n4\\n[4,3,2,1,4,3,2,1]\\n4\\n\\n[ 1,2,1,2]\\n2\\n[ 1,1,1,2,2,2,3,3,3,4,4 ]\\n4\\n[ 1,2,3,4                   ]\\n4\\n[ 1,2,3,4,  1,2,3,4         ]\\n4\\n[ 1,1,2,2,3,3,4,4           ]\\n4\\n[ 1,1,2,2,3,3,4,4,  1,2,3   ]\\n4\\n[ 1,1,2,2,3,3,4,4,  3,2,1   ]\\n4\\n\\n[1]\\n1\\n[1,1]\\n1\\n[1,1,1]\\n1\\n[1,1]\\n2\\n[2,2]\\n2\\n[1,2]\\n2\\n[2,1]\\n2\\n[1,1,1]\\n3\\n\\n[1,2,3,4]\\n4\\n[4,3,2,1]\\n4\\n\\n[1]\\n1\\n[1,1]\\n1\\n[1,1,1]\\n1\\n[1,2]\\n2\\n[1,1,2,2]\\n2\\n[1,2,1,2]\\n2\\n[1,2,2,1]\\n2\\n[2,1,1,1]\\n2\\n[2,1,1,1]\\n2\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nFrom Question\\n  \"sequence taken does not have to be consecutive as long as it is in order.\"\\n    so   order of elements  is important\\n\\nExample 1\\n   when  1,2,3,4    1,2,3,4   occur in sequence\\n   then [1,2,3,4]  [1,2,3,4] groups that has (all 4 elements), are formed\\n     then all possible 2 element sequences are possible\\n      1,1   1,2   1,3   1,4\\n      2,1   2,2   2,3   2,4\\n      3,1   3,2   3,3   3,4\\n      4,1   4,2   4,3   4,4\\n     then some   3 element is not possible    like 1,1,1\\n\\nExample 2\\n   when  1,1,  2,2   3,3,  4,4   occur in sequence\\n   then [1,1,  2,2   3,3,  4]   [4] groups that has (all 4, or, rest of elments) are formed\\n        then some   2 element is not possible    like 2,1\\n\\nConclusion\\n   so number of (all element) groups are important\\n     +1 is answer  ( that is shortest seq not possible - 1,1,1   &  2,1 above)\\n```\n```\\nvar shortestSequence = function (a, k) {\\n  let allElementGroups = 0;\\n  let set = new Set()\\n\\n  for (let e of a) {\\n    set.add(e);\\n    if (set.size === k) {\\n      allElementGroups += 1; // all possible distinct elements (1 to k) occured, another group formed, in order\\n      set = new Set(); //       now, reset the set, with no elements to see if another group forms, in order\\n    }\\n  }\\n  return allElementGroups + 1;\\n};\\n```\n```\\n[1,1,2,2,3,3,4,4]\\n4\\n[1,2,3,4,1,2,3,4]\\n4\\n[4,3,2,1,4,3,2,1]\\n4\\n\\n[ 1,2,1,2]\\n2\\n[ 1,1,1,2,2,2,3,3,3,4,4 ]\\n4\\n[ 1,2,3,4                   ]\\n4\\n[ 1,2,3,4,  1,2,3,4         ]\\n4\\n[ 1,1,2,2,3,3,4,4           ]\\n4\\n[ 1,1,2,2,3,3,4,4,  1,2,3   ]\\n4\\n[ 1,1,2,2,3,3,4,4,  3,2,1   ]\\n4\\n\\n[1]\\n1\\n[1,1]\\n1\\n[1,1,1]\\n1\\n[1,1]\\n2\\n[2,2]\\n2\\n[1,2]\\n2\\n[2,1]\\n2\\n[1,1,1]\\n3\\n\\n[1,2,3,4]\\n4\\n[4,3,2,1]\\n4\\n\\n[1]\\n1\\n[1,1]\\n1\\n[1,1,1]\\n1\\n[1,2]\\n2\\n[1,1,2,2]\\n2\\n[1,2,1,2]\\n2\\n[1,2,2,1]\\n2\\n[2,1,1,1]\\n2\\n[2,1,1,1]\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741190,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for (int& a : A) {\\n            s.insert(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351553,
                "title": "100-faster-at-my-time-easy-python3-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8c838bdf-fef0-4bb0-93e4-92c64804a433_1659113245.3133857.png)\\n\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 0 \\n        seen = set()\\n        for x in rolls: \\n            seen.add(x)\\n            if len(seen) == k: \\n                ans += 1\\n                seen.clear()\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 0 \\n        seen = set()\\n        for x in rolls: \\n            seen.add(x)\\n            if len(seen) == k: \\n                ans += 1\\n                seen.clear()\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337773,
                "title": "simplest-detailed-explanation-simple-logic",
                "content": "This problem is actually straightforward.\\nAll we need is a little insight into how we form the sequences\\n\\n**Suppose k=3**\\nLet\\'s search for all **1 length** sequences\\nWe will have the following possible sequences->{1}, {2}, {3}.\\nNow suppose in the rolls array we found these sequences , which means we can\\'t have our answer as 1 because we are able to form all possible sequences for k=3.\\n\\n**Now let\\'s look at all 2 length possible sequences**\\n\\nSuppose we iterated further on the rolls array and we again found the sequences **{1}, {2}, {3}**.\\nWe have already found the the same sequences already then this means:\\nfor {1,2,3}->**found before** and {1,2,3} **found in this iteration,** we can make the following combinations of 2 length sequences->**{1,1},{1,2},{1,3},{2,1},{2,2},{2,3},{3,1},{3,2},{3,3}**\\n\\nTherfore we just realized that we can form all possible sequences of length 2 until now. So our answer cannot be of length 2. Our answer might be of length 3 though.\\n\\nSo we further check if we again find these k number which are {1,2,3} further in the rolls array.\\n\\nIf  we find these k numbers again then we can make all possible 3 length sequences therefore our answer can\\'t be 3. But if we did not found these k number until the end for the 3rd time now therefore there must be some 3 length sequence which is not present in the rolls array.\\n\\nSo we return our answer as 3\\n\\nI used a simple hashset to check whether I am able to find the k numbers uptil now.\\nAs soon as I find the k numbers I increment my possible answer and clear the set.\\n\\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        \\n        int n=rolls.length;\\n        int res=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<n;i++){\\n            set.add(rolls[i]);\\n            if(set.size()==k){\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        \\n        return res+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        \\n        int n=rolls.length;\\n        int res=0;\\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        for(int i=0;i<n;i++){\\n            set.add(rolls[i]);\\n            if(set.size()==k){\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        \\n        return res+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337525,
                "title": "one-pass-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a8b0a6bc-0542-4796-b383-933cf550311c_1658856049.0645862.jpeg)\\nTime : `O(nlogn)`\\nSpace :` O(n)`\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        ll ans = 0;\\n        for(ll i=0;i<rolls.size();i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        ll ans = 0;\\n        for(ll i=0;i<rolls.size();i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331097,
                "title": "c-javascript-tc-o-n",
                "content": "This problem can be easily solved using a clever use of Set data structure and thinking greedily. Other approaches like DP might not yield the desired results and will be slower.\\n\\nThe intution is we need to create sets of complete elements such that all the numbers from 1 to K appear atleast once in such a complete set. The number of complete and sequential sets we are able to form, will give us the length of the largest possible sequence we can make. For eg, in a given case the number of complete sets are 3 that means we can derive any sequence of 3 digits from our array. The answer in that case will be 4 because there exists atleast one sequence of length 4 that cannot be derived from the given array. \\n\\nTo create complete sets we can use the Set available in C++ STL as well as JavaScript. The unique quality of a set is it always contains unique elements. For eg: if an element \\'3\\' is pushed 4 times into a set, it will appear only once in the set and therefore will only occupy one unit of space and any subsequent pushes of the same element doesn\\'t increase the size of our set. Hence sets are useful to keep count of unique elements especially when we know our elements always belong to a particular range.\\n\\nWe start iterating from the first element in our rolls array with an empty set and keep pushing each element into the set. The moment our set reaches a size of k, we increment our answer variable and a complete set is said to have been formed in the process. Then we can clear the set to look for a new complete set. Also since our array consists of numbers in the range 1 to k, we can be sure that a complete set consists of all natural numbers upto k where each element exists atleast once.\\n\\n**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int ans=1;\\n        set<int> s;\\n        \\n        for(auto i:rolls)\\n        {\\n            s.insert(i);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**JavaScript Code:**\\n\\n```\\nvar shortestSequence = function(rolls, k) \\n{\\n    let ans=1;\\n    let sett=new Set();\\n    \\n    for(let i of rolls)\\n        {\\n            sett.add(i);\\n            if(sett.size===k)\\n                {\\n                    ans++;\\n                    sett=new Set();\\n                }\\n        }\\n    return ans;\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int ans=1;\\n        set<int> s;\\n        \\n        for(auto i:rolls)\\n        {\\n            s.insert(i);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nvar shortestSequence = function(rolls, k) \\n{\\n    let ans=1;\\n    let sett=new Set();\\n    \\n    for(let i of rolls)\\n        {\\n            sett.add(i);\\n            if(sett.size===k)\\n                {\\n                    ans++;\\n                    sett=new Set();\\n                }\\n        }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330473,
                "title": "java-easy-small-sliding-window",
                "content": "Runtime: 6 ms, faster than 100.00% of Java online submissions for Shortest Impossible Sequence of Rolls.\\nMemory Usage: 74.8 MB, less than 80.00% of Java online submissions for Shortest Impossible Sequence of Rolls.\\n```\\nclass Solution {\\n  public int shortestSequence(int[] rolls, int k) {\\n    int table[] = new int[k+1], tot = 0, level = 1;\\n    \\n    for(int j = 0; j != rolls.length; j++){\\n      if(table[rolls[j]]++ == 0) tot++;\\n      if(tot == k){\\n        level++;\\n        tot = 0;\\n        Arrays.fill(table, 0);\\n      }\\n    }\\n    \\n    return level;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int shortestSequence(int[] rolls, int k) {\\n    int table[] = new int[k+1], tot = 0, level = 1;\\n    \\n    for(int j = 0; j != rolls.length; j++){\\n      if(table[rolls[j]]++ == 0) tot++;\\n      if(tot == k){\\n        level++;\\n        tot = 0;\\n        Arrays.fill(table, 0);\\n      }\\n    }\\n    \\n    return level;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327331,
                "title": "very-interesting-problem-with-easy-and-logical-solution-cpp",
                "content": "![image](https://assets.leetcode.com/users/images/8eb15079-e913-4bd1-8ea8-e73a2b24e1f7_1658669088.5797994.png)\\n```\\n/// EX:  rolls= [1,2,3,4,  3,2,4,1,  1,1,2,2,4,3,  2,1]\\n//               _______   _______   ___________   ___\\n//                  |         |            |        |\\n//       set =   1,2,3,4   1,2,3,4      1,2,3,4    1,2\\n//              ________   _______      ________   ____\\n//                k=1 \\u2705   k=2\\u2705         k=3\\u2705    k=4\\u274C   // shortest sequence of rolls that cannot be taken from rolls=4\\n\\n\\n/// EX:  rolls= [1,2,3,4,  3,2,4,1,   2,1,1,1,2,2,4,3]  // shortest sequence of rolls that cannot be taken from rolls=4\\n//               _______   _______    _______________  \\n//                  |         |             |\\n//       set =   1,2,3,4   1,2,3,4        1,2,3,4\\n//              ________   _______      __________\\n//                k=1 \\u2705   k=2\\u2705         k=3\\u2705      \\n\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n      set<int>data;\\n      int sz_ans=1;\\n      for(int i=0;i<rolls.size();i++){\\n          data.insert(rolls[i]);  // you need 1,2,3,4 for every k\\n                                // for k=2 means need [1][2][1,2][2,1]\\n          if(data.size()==k){  // we should have rolls array like in set we get k times [1,2][1,2] in any order\\n              sz_ans++;\\n              data.clear();\\n          }\\n      }\\n        return sz_ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/// EX:  rolls= [1,2,3,4,  3,2,4,1,  1,1,2,2,4,3,  2,1]\\n//               _______   _______   ___________   ___\\n//                  |         |            |        |\\n//       set =   1,2,3,4   1,2,3,4      1,2,3,4    1,2\\n//              ________   _______      ________   ____\\n//                k=1 \\u2705   k=2\\u2705         k=3\\u2705    k=4\\u274C   // shortest sequence of rolls that cannot be taken from rolls=4\\n\\n\\n/// EX:  rolls= [1,2,3,4,  3,2,4,1,   2,1,1,1,2,2,4,3]  // shortest sequence of rolls that cannot be taken from rolls=4\\n//               _______   _______    _______________  \\n//                  |         |             |\\n//       set =   1,2,3,4   1,2,3,4        1,2,3,4\\n//              ________   _______      __________\\n//                k=1 \\u2705   k=2\\u2705         k=3\\u2705      \\n\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n      set<int>data;\\n      int sz_ans=1;\\n      for(int i=0;i<rolls.size();i++){\\n          data.insert(rolls[i]);  // you need 1,2,3,4 for every k\\n                                // for k=2 means need [1][2][1,2][2,1]\\n          if(data.size()==k){  // we should have rolls array like in set we get k times [1,2][1,2] in any order\\n              sz_ans++;\\n              data.clear();\\n          }\\n      }\\n        return sz_ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326157,
                "title": "java-python-golang-one-pass",
                "content": "Python\\n```\\nclass Solution:\\n     def shortestSequence(self, rolls, k):\\n        \"\"\"\\n        [4,2,1,2,3,3,2,4,1]\\n        \\n        we first find the index of a complete set\\n        \\n        i= 4 (first occurence of three) \\n        \\n        next we iterate through the i-->len(nums)\\n         finding the next index of complete set that ensures that elemts is resetn atleast two times\\n         \\n        i=8\\n        \\n        Now since we have reached to end we return how completeset was found +1\\n        \"\"\"\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```\\n\\nJava\\n```\\nclass Solution {\\n        public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nGolang\\n```\\nfunc shortestSequence(rolls []int, k int) int {\\n    var s = map[int]bool{}\\n    var curr, res int = 0, 1\\n    for _, a := range rolls {\\n        if !s[a] {\\n            curr ++\\n            s[a] = true\\n        }\\n        // when we\\'ve collected all k nums, ++\\n        if curr == k {\\n            res ++\\n            curr = 0\\n            s = map[int]bool{}\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Go",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n     def shortestSequence(self, rolls, k):\\n        \"\"\"\\n        [4,2,1,2,3,3,2,4,1]\\n        \\n        we first find the index of a complete set\\n        \\n        i= 4 (first occurence of three) \\n        \\n        next we iterate through the i-->len(nums)\\n         finding the next index of complete set that ensures that elemts is resetn atleast two times\\n         \\n        i=8\\n        \\n        Now since we have reached to end we return how completeset was found +1\\n        \"\"\"\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```\n```\\nclass Solution {\\n        public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nfunc shortestSequence(rolls []int, k int) int {\\n    var s = map[int]bool{}\\n    var curr, res int = 0, 1\\n    for _, a := range rolls {\\n        if !s[a] {\\n            curr ++\\n            s[a] = true\\n        }\\n        // when we\\'ve collected all k nums, ++\\n        if curr == k {\\n            res ++\\n            curr = 0\\n            s = map[int]bool{}\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325775,
                "title": "a-simple-interview-style-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/35a28030-4dac-4f11-9288-64074697ae77_1658645886.5772471.png)\\n![image](https://assets.leetcode.com/users/images/89552ebd-ea7b-4078-9f74-6cd8ef800ab9_1658645894.2088807.png)\\n![image](https://assets.leetcode.com/users/images/6940b633-009d-423b-8848-f308fb1262e1_1658645898.3775022.png)\\n![image](https://assets.leetcode.com/users/images/90f81d76-c0c5-45ee-aacb-719bb65a9307_1658645900.897105.png)\\n![image](https://assets.leetcode.com/users/images/ab80b4df-1c1a-4662-859b-ebabeb4d3300_1658645903.6821547.png)\\n![image](https://assets.leetcode.com/users/images/a8961121-7645-4e12-bd04-1e26aae11912_1658645907.109882.png)\\n![image](https://assets.leetcode.com/users/images/58f9ba04-0e14-4e30-9485-f83032d285a3_1658645911.4487305.png)\\n\\nI post solutions like this on LinkedIn, you can follow me there - https://www.linkedin.com/posts/mayank-singh-1004981a4_shortest-impossible-sequence-of-rolls-activity-6956860374616846336-XfzI?utm_source=linkedin_share&utm_medium=member_desktop_web",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/35a28030-4dac-4f11-9288-64074697ae77_1658645886.5772471.png)\\n![image](https://assets.leetcode.com/users/images/89552ebd-ea7b-4078-9f74-6cd8ef800ab9_1658645894.2088807.png)\\n![image](https://assets.leetcode.com/users/images/6940b633-009d-423b-8848-f308fb1262e1_1658645898.3775022.png)\\n![image](https://assets.leetcode.com/users/images/90f81d76-c0c5-45ee-aacb-719bb65a9307_1658645900.897105.png)\\n![image](https://assets.leetcode.com/users/images/ab80b4df-1c1a-4662-859b-ebabeb4d3300_1658645903.6821547.png)\\n![image](https://assets.leetcode.com/users/images/a8961121-7645-4e12-bd04-1e26aae11912_1658645907.109882.png)\\n![image](https://assets.leetcode.com/users/images/58f9ba04-0e14-4e30-9485-f83032d285a3_1658645911.4487305.png)\\n\\nI post solutions like this on LinkedIn, you can follow me there - https://www.linkedin.com/posts/mayank-singh-1004981a4_shortest-impossible-sequence-of-rolls-activity-6956860374616846336-XfzI?utm_source=linkedin_share&utm_medium=member_desktop_web",
                "codeTag": "Unknown"
            },
            {
                "id": 2325603,
                "title": "java-o-n-o-k-3ms",
                "content": "```\\npublic int shortestSequence(int[] rolls, int k) {\\n\\tboolean[] s = new boolean[k+1];\\n\\tint count = k;\\n\\tboolean v = true;\\n\\tint result = 1;\\n\\tfor(int i:rolls){\\n\\t\\tif(s[i]!=v){\\n\\t\\t\\ts[i]=v;\\n\\t\\t\\tcount--;\\n\\t\\t\\tif(count == 0){\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tcount = k;\\n\\t\\t\\t\\tv=!v;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int shortestSequence(int[] rolls, int k) {\\n\\tboolean[] s = new boolean[k+1];\\n\\tint count = k;\\n\\tboolean v = true;\\n\\tint result = 1;\\n\\tfor(int i:rolls){\\n\\t\\tif(s[i]!=v){\\n\\t\\t\\ts[i]=v;\\n\\t\\t\\tcount--;\\n\\t\\t\\tif(count == 0){\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tcount = k;\\n\\t\\t\\t\\tv=!v;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325009,
                "title": "greedy-solution-using-set",
                "content": "Iterate untill you make the size of the set equals k this is, you find all the k numbers.\\n*There can be two case :*\\n->If you don\\'t find all the k numbers after iterating all the numbers \\n->If you find all the k numbers before completing the whole iteration, then the current length permutation is fixed that you can create all the permutation of given length, therefore you should make your set empty and increment length by one (count = count + 1) and continue iterating the array.\\n\\n**CODE:**\\n```   \\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> mp;\\n        int cnt=0;\\n        for(auto it: rolls){\\n            mp.insert(it);\\n            if(mp.size()==k){\\n                cnt++;\\n                mp.clear();\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> mp;\\n        int cnt=0;\\n        for(auto it: rolls){\\n            mp.insert(it);\\n            if(mp.size()==k){\\n                cnt++;\\n                mp.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2324377,
                "title": "python3-hash-set",
                "content": "\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 1\\n        seen = set()\\n        for x in rolls: \\n            seen.add(x)\\n            if len(seen) == k: \\n                ans += 1\\n                seen.clear()\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans = 1\\n        seen = set()\\n        for x in rolls: \\n            seen.add(x)\\n            if len(seen) == k: \\n                ans += 1\\n                seen.clear()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323268,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "Approach : we have to find the shortest impossible sequence that is if dice has all numbers occuring once then the impossible length will be two.\\nif all numbers are occuring twice when we divide the array then the impossible length will be 3.. and so on. \\n\\nwith the code itself you will understand the intution.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int ans = 1;\\n        int n = rolls.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.find(rolls[i]) == st.end()){\\n                st.insert(rolls[i]);\\n                \\n                if(st.size() == k){\\n                    ans++;\\n                    st.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int ans = 1;\\n        int n = rolls.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(st.find(rolls[i]) == st.end()){\\n                st.insert(rolls[i]);\\n                \\n                if(st.size() == k){\\n                    ans++;\\n                    st.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323179,
                "title": "python-solution-linear-time-and-space",
                "content": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        ans = 1\\n        for r in rolls:\\n            s.add(r)\\n            if len(s) == k:\\n                ans += 1\\n                s = set()\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        ans = 1\\n        for r in rolls:\\n            s.add(r)\\n            if len(s) == k:\\n                ans += 1\\n                s = set()\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323178,
                "title": "c-set-explained-with-example-i-will-not-say-it-was-easy-thinking-based-q",
                "content": "```\\n   // Intuition  \\n    \\n    // check for this one -> [4,2,1,2,3,3,2,4,1], k = 4\\n    \\n    // Take the element till it has at least one occurences of distinct k values\\n    \\n    // Take a set , we will start inserting the value in the set which have values  [ 4 , 2 , 1 , 2 , 3] upto \\n    // index 4 , \\n    \\n    // next elements from index = 5 to n-1 , [ 3 , 2 , 4 , 1] has at least one \\n    // occurences  of distinct k values \\n    \\n    //set1 - [ 4 , 2 , 1 , 2 , 3] , set2- [ 3 , 2 , 4 , 1] -> there will exist a sequence \\n    //such that \\n    // u take element e1 from set1 , e2 from set , but there is no set3 \\n    // so a sequence of length 3 will not possible in that case \\n    \\n    // Remember we are not claiming that any sequence of length 3 will not exist .\\n    // There can exist but , there will atleast one sequence of length 3 \\n    // which cannot be formed as no of distinct set is only 2.\\n    int shortestSequence(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<int> st;\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.find(nums[i])==st.end())\\n            {\\n                st.insert(nums[i]);\\n                \\n                if(st.size()==k)\\n                {\\n                    st.clear();\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans+1;;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n   // Intuition  \\n    \\n    // check for this one -> [4,2,1,2,3,3,2,4,1], k = 4\\n    \\n    // Take the element till it has at least one occurences of distinct k values\\n    \\n    // Take a set , we will start inserting the value in the set which have values  [ 4 , 2 , 1 , 2 , 3] upto \\n    // index 4 , \\n    \\n    // next elements from index = 5 to n-1 , [ 3 , 2 , 4 , 1] has at least one \\n    // occurences  of distinct k values \\n    \\n    //set1 - [ 4 , 2 , 1 , 2 , 3] , set2- [ 3 , 2 , 4 , 1] -> there will exist a sequence \\n    //such that \\n    // u take element e1 from set1 , e2 from set , but there is no set3 \\n    // so a sequence of length 3 will not possible in that case \\n    \\n    // Remember we are not claiming that any sequence of length 3 will not exist .\\n    // There can exist but , there will atleast one sequence of length 3 \\n    // which cannot be formed as no of distinct set is only 2.\\n    int shortestSequence(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        \\n        set<int> st;\\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.find(nums[i])==st.end())\\n            {\\n                st.insert(nums[i]);\\n                \\n                if(st.size()==k)\\n                {\\n                    st.clear();\\n                    ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans+1;;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322868,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int ans = 1;\\n        \\n        for(int i : rolls) {\\n            s.insert(i);\\n            if(s.size() == k) s.clear(), ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int ans = 1;\\n        \\n        for(int i : rolls) {\\n            s.insert(i);\\n            if(s.size() == k) s.clear(), ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322822,
                "title": "c-greedy",
                "content": "We Can Notice That for all sequence of length 1 we need all k numbers once,\\nSimilarly for all length 2 sequence we need all k numbers again after we have found them already once because\\nas we have found out all k elements once again, we can pair them up such that they form every length 2 sequence.\\n```\\nSay k=4\\nnums=[1,2,3,4,1,2,3,4]\\nwe find 1,2,3,4 once.  Now after that we again find them all.\\nin the first occurence of k elements 4 is at last position let its index be 3. Now after that we again find all k elements so element at index 3(=4) can pair with all the newly found k elements to form sequence of length 2. Can i Say if i can pair index 3, i can pair all index before it? Answer is Obviously Yes.\\n```\\nSimilarly we need all k numbers again for all length 3 sequence after we are done with length 2 sequence.\\n\\nThis can be easily done using set. first we fill set until we encounter all k numbers, after that once size reaches k we clear set and track for next length sequence of k element. this can be done using multiset also by keeping only one occurence of each element until size is k and then repeating the same process till we reach the end and final answer wold be size/4 ceil value. In our case of set answer would be number of times we hit k size in set+1. Obviously set implementation would be more easier so i did it that way.\\nStill if it is not clear then look at example below\\nExample:\\n```\\nnums=[1,2,3,4,4,3,2,1,1,2] \\nk=4\\nwe first keep a var result=1 supposing we cannot form 1 length sequence.\\nfirst we insert 1,2,3,4, in set and size is now k so we conclude that we can make all 1 length sequence and so we increase result supposing that we cannot form length 2 sequence and clear set. Now again we insert 4,3,2,1 in set now again size is 4 so we again conclude that we can form length 2 sequence and now we again increment result supposing that we can not form 3 length sequence and our elements end up as we insert 1,2 in set and we reach end of array.So, we conclude that we cannot make sequence of length 3, hence our Answer is 3.\\n```\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int ans=1,q=0;\\n        for(int i=0;i<rolls.size();i++){\\n            if(st.find(rolls[i])==st.end())\\n            {\\n                st.insert(rolls[i]);\\n                if(st.size()==k)\\n                {\\n                    ans++;\\n                    st.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nSay k=4\\nnums=[1,2,3,4,1,2,3,4]\\nwe find 1,2,3,4 once.  Now after that we again find them all.\\nin the first occurence of k elements 4 is at last position let its index be 3. Now after that we again find all k elements so element at index 3(=4) can pair with all the newly found k elements to form sequence of length 2. Can i Say if i can pair index 3, i can pair all index before it? Answer is Obviously Yes.\\n```\n```\\nnums=[1,2,3,4,4,3,2,1,1,2] \\nk=4\\nwe first keep a var result=1 supposing we cannot form 1 length sequence.\\nfirst we insert 1,2,3,4, in set and size is now k so we conclude that we can make all 1 length sequence and so we increase result supposing that we cannot form length 2 sequence and clear set. Now again we insert 4,3,2,1 in set now again size is 4 so we again conclude that we can form length 2 sequence and now we again increment result supposing that we can not form 3 length sequence and our elements end up as we insert 1,2 in set and we reach end of array.So, we conclude that we cannot make sequence of length 3, hence our Answer is 3.\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int ans=1,q=0;\\n        for(int i=0;i<rolls.size();i++){\\n            if(st.find(rolls[i])==st.end())\\n            {\\n                st.insert(rolls[i]);\\n                if(st.size()==k)\\n                {\\n                    ans++;\\n                    st.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322799,
                "title": "short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int res=1;\\n        unordered_set<int> s;\\n        for(int &i:rolls) {\\n            s.insert(i);\\n            if(s.size()==k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Please upvote if you liked the solution\\n\\n# \\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int res=1;\\n        unordered_set<int> s;\\n        for(int &i:rolls) {\\n            s.insert(i);\\n            if(s.size()==k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322654,
                "title": "c-one-pass",
                "content": "This solution has been taken from @penguinhacker\\nWorld class solution\\nJust do the dry run and you will understand the logic\\nIf you have any confusion, please comment below\\n\\nTime Complexity :O(n)\\nSpace Complexity : O(k)\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> vis(k+1);\\n        int cnt=0;\\n        int ans=1;\\n        for (int i : rolls) {\\n            if (!vis[i]) {\\n                vis[i]=1;\\n                ++cnt;\\n                if (cnt==k) {\\n                    vis=vector<bool>(k+1);\\n                    ++ans;\\n                    cnt=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> vis(k+1);\\n        int cnt=0;\\n        int ans=1;\\n        for (int i : rolls) {\\n            if (!vis[i]) {\\n                vis[i]=1;\\n                ++cnt;\\n                if (cnt==k) {\\n                    vis=vector<bool>(k+1);\\n                    ++ans;\\n                    cnt=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2322587,
                "title": "c-easy-intutive-contest-solution",
                "content": "\\n* First we store all indices corresponding with the number\\n* Now for len=1 , get minimum indices from (1 to k)\\n* now for len=2 , (1 to k ) should exist before the last length index \\n* now for len=3 , get minimum index from len=2 , and check whether (1 to k ) exist before last index\\n* BUT WHY THIS ??\\n* len =1 {1,2,3,4}\\n* len=2  {  _ _ _ _   1 , 2 , 3 , 4}  empty spaces should contain (1,2,3,4) to achieve (1,1) (1,2)(1,3)(1,4) | (2,1) (2,2)(2,3)(2,4)  | (3,1) (3,2) (3,3) (3,4)  | (4,1) (4,2)(4,3)(4,4) \\n```\\nvector<vector<int>>v(k+1);\\n        for(int i=0;i<rolls.size();i++){\\n            v[rolls[i]].push_back(i);\\n        }\\n        \\n        int last=INT_MAX;\\n        for(int len=1;len<=rolls.size();len++){\\n            int curr=INT_MAX;\\n            for(int i=1;i<=k;i++){\\n                while(v[i].size()>0 and v[i].back()>last) v[i].pop_back();  // get index which exist before last\\n                if(v[i].size()==0) return len;\\n                curr=min(curr,v[i].back());\\n                v[i].pop_back();\\n            }\\n            last=curr;\\n        }\\n        return rolls.size()+1;\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>>v(k+1);\\n        for(int i=0;i<rolls.size();i++){\\n            v[rolls[i]].push_back(i);\\n        }\\n        \\n        int last=INT_MAX;\\n        for(int len=1;len<=rolls.size();len++){\\n            int curr=INT_MAX;\\n            for(int i=1;i<=k;i++){\\n                while(v[i].size()>0 and v[i].back()>last) v[i].pop_back();  // get index which exist before last\\n                if(v[i].size()==0) return len;\\n                curr=min(curr,v[i].back());\\n                v[i].pop_back();\\n            }\\n            last=curr;\\n        }\\n        return rolls.size()+1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322500,
                "title": "python-just-count-complete-sets-of-numbers-1-to-k",
                "content": "What a wonderful problem! You need to recognize that for each \\u201Cposition\\u201D in a sequence of x rolls to be produced, you are going to need to have found at least one each of the numbers from 1 to k (in any order). So, basically, all you have to do is create a set s, and iterate through the items in rolls, keeping a count of the number of times the length of the set becomes equal to k, and at that point begin again with an empty set. The answer is just one more than that count.\\n\\nHere is my code: \\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        count = 0\\n        i = 0\\n        found = set()\\n        while i < len(rolls):\\n            found.add(rolls[i])\\n            if len(found) == k:\\n                count += 1\\n                i += 1\\n                found = set()\\n                continue\\n            i += 1\\n        return count +1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        count = 0\\n        i = 0\\n        found = set()\\n        while i < len(rolls):\\n            found.add(rolls[i])\\n            if len(found) == k:\\n                count += 1\\n                i += 1\\n                found = set()\\n                continue\\n            i += 1\\n        return count +1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322454,
                "title": "easiest-solution-possible-explanation",
                "content": "Explantion:\\n\\nJust go and insert all unique elements in unordered set (Bcoz order is not matter here), After that when set size == k means we can create for one more len i.e., len + 1.\\n     \\nEg:\\n [4,2,1,2,3,3,2,4,1]\\n i=0, set{4};\\ni=1, set{4,2};\\ni=2, set{4,2,1};\\ni=3, set{4,2,1};\\ni=5, set{4,2,1,3};   That\\'s mean we can create one size rolls, increment count by 1 and clear the set.\\ni=6, set{3};\\ni=7, set{3,2};\\ni=8, set{3,2,4};\\ni=9, set{3,2,4,1}; That\\'s mean we again able to form every number in this therefore, we will able to create any rolls with length 2.\\n    \\nEnd of array. That\\'s mean we will not able to form roll of size 3 (atleast one roll).\\n     \\n    \\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size();\\n        int cnt=0;\\n        unordered_set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                cnt++;\\n                s.clear();\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size();\\n        int cnt=0;\\n        unordered_set<int>s;\\n        for(int i=0;i<n;i++){\\n            s.insert(rolls[i]);\\n            if(s.size()==k){\\n                cnt++;\\n                s.clear();\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322381,
                "title": "python-easy-understanding-solution",
                "content": "For example,  k = 3,  rolls = [1, 1, 2, 2, 3, 1]\\nUse a set to record if all possible numbers has appeared at least once.\\nIn this case, when iterate to 3 in [1, 1, 2, 2, **3**, 1], all possible numbers (1-3) has appeared at least once,\\nso you must at least take 1 number from interval [1, 1, 2, 2, 3], in practice, take 3.\\n\\nIn the remain array [1], it cannot fill the set again. It means there exists a number you can take to make the sequence impossible, in this case, take either 2 or 3. So both [3, 2] and [3, 3] are impossible array.\\n\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        res = 0\\n        \\n        for r in rolls:\\n            s.add(r)\\n            if len(s) == k:        # All possible number has appeared once.\\n                res += 1           # So you must \"at least\" use one more place to store it.\\n                s.clear()          # Clear the set.\\n        \\n        \\n        return res + 1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "For example,  k = 3,  rolls = [1, 1, 2, 2, 3, 1]\\nUse a set to record if all possible numbers has appeared at least once.\\nIn this case, when iterate to 3 in [1, 1, 2, 2, **3**, 1], all possible numbers (1-3) has appeared at least once,\\nso you must at least take 1 number from interval [1, 1, 2, 2, 3], in practice, take 3.\\n\\nIn the remain array [1], it cannot fill the set again. It means there exists a number you can take to make the sequence impossible, in this case, take either 2 or 3. So both [3, 2] and [3, 3] are impossible array.\\n\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        res = 0\\n        \\n        for r in rolls:\\n            s.add(r)\\n            if len(s) == k:        # All possible number has appeared once.\\n                res += 1           # So you must \"at least\" use one more place to store it.\\n                s.clear()          # Clear the set.\\n        \\n        \\n        return res + 1",
                "codeTag": "Java"
            },
            {
                "id": 2322355,
                "title": "with-explanation-c-easy-to-understand",
                "content": "**Explanation:-**\\n1. You have to calculate number of subarrays that contains all numbers from 1 to k. \\n2.  Eg;- Let k=5; then for len=1 you need all number from 1 to 5. Now for len=2:-   1...5 numbers need 1...5 numbers again to form all the possible 2 length sequences.\\n3.  You can think that first subarray 1...5 can also contain some 2 len sequences. That is also correct but think of 5 from len 1 .It needs all 1...5 numbers again to form length 2 possible sequences. . If len=3 we need 1...5 1...5 1...5  ... so on for other lengths\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& nums, int k) {\\n        int  sz=nums.size(),ans=1;\\n        unordered_set<int>st;\\n        for(int i=0;i<sz;i++){\\n            st.insert(nums[i]);\\n            if(st.size()==k){\\n                st.clear();\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& nums, int k) {\\n        int  sz=nums.size(),ans=1;\\n        unordered_set<int>st;\\n        for(int i=0;i<sz;i++){\\n            st.insert(nums[i]);\\n            if(st.size()==k){\\n                st.clear();\\n                ans++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322353,
                "title": "o-n-simple-c-approach-observation-based",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        int n = rolls.size(), ans = 1;\\n        for(int i = n-1; i>=0; i--){\\n            s.insert(rolls[i]);\\n            if(s.size() == k){\\n            //sequence of length ans is possible(as we have got all the k numbers), now check for the next length\\n                ans++;\\n                set<int>temp;\\n                swap(s, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        int n = rolls.size(), ans = 1;\\n        for(int i = n-1; i>=0; i--){\\n            s.insert(rolls[i]);\\n            if(s.size() == k){\\n            //sequence of length ans is possible(as we have got all the k numbers), now check for the next length\\n                ans++;\\n                set<int>temp;\\n                swap(s, temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322295,
                "title": "python-greedy-set-o-n",
                "content": "My code is originated from the following idea.\\nMain Idea: to make all the sequences of rolls of length q, the given array rolls should be split into q segments where each segment contains all the numbers from 1 to k.\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        V = set()\\n        res = 1\\n        for roll in rolls:\\n            V.add(roll)\\n            if len(V) == k:\\n                res += 1\\n                V = set()\\n        return res",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "My code is originated from the following idea.\\nMain Idea: to make all the sequences of rolls of length q, the given array rolls should be split into q segments where each segment contains all the numbers from 1 to k.\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        V = set()\\n        res = 1\\n        for roll in rolls:\\n            V.add(roll)\\n            if len(V) == k:\\n                res += 1\\n                V = set()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2322263,
                "title": "c-unordered-set-one-pass-o-n",
                "content": "**Explanation**\\nIf every sequence of rolls of length `len` can be taken from rolls, then the rolls can be divided to `len` group and every groups must contains every number from `1` to `k`.\\nSo we just traverse the rolls and use a set to store number, when meet every number from `1` to `k`, clear the set and `res++`.\\nThe answer is `res` after traversal.\\n\\n**Example**\\nrolls = [4,2,1,2,3,3,2,4,1], k = 4\\n--> <u>4</u>,<u>2</u>,<u>1</u>,2,<u>3</u> | <u>3</u>,<u>2</u>,<u>4</u>,<u>1</u>\\n--> The answer is 3\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for(auto i : A){\\n            s.insert(i);\\n            if(s.size() == k){\\n                s.clear();\\n                res++;\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& A, int k) {\\n        int res = 1;\\n        unordered_set<int> s;\\n        for(auto i : A){\\n            s.insert(i);\\n            if(s.size() == k){\\n                s.clear();\\n                res++;\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020133,
                "title": "simple-javascript-typescript-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst shortestSequence = (rolls: number[], k: number): number => {\\n  const possibleRolls = Array.from({ length: k }, (_el, i) => i + 1);\\n  const needToRoll = new Set(possibleRolls);\\n  let shortest = 1;\\n  for (const roll of rolls) {\\n    needToRoll.delete(roll);\\n    if (needToRoll.size === 0) {\\n      shortest++;\\n      for (const roll of possibleRolls) needToRoll.add(roll);\\n    }\\n  }\\n  return shortest;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Greedy"
                ],
                "code": "```\\nconst shortestSequence = (rolls: number[], k: number): number => {\\n  const possibleRolls = Array.from({ length: k }, (_el, i) => i + 1);\\n  const needToRoll = new Set(possibleRolls);\\n  let shortest = 1;\\n  for (const roll of rolls) {\\n    needToRoll.delete(roll);\\n    if (needToRoll.size === 0) {\\n      shortest++;\\n      for (const roll of possibleRolls) needToRoll.add(roll);\\n    }\\n  }\\n  return shortest;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973364,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int ans=0;\\n        unordered_set<int> s = getSet(k);\\n        for(int i=0; i<n; i++) {\\n            s.erase(rolls[i]);\\n            if(s.size() == 0) {\\n                ans++;\\n                s = getSet(k);\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    unordered_set<int> getSet(int k) {\\n        unordered_set<int> s;\\n        for(int i=1; i<=k; i++) \\n            s.insert(i);\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int ans=0;\\n        unordered_set<int> s = getSet(k);\\n        for(int i=0; i<n; i++) {\\n            s.erase(rolls[i]);\\n            if(s.size() == 0) {\\n                ans++;\\n                s = getSet(k);\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    unordered_set<int> getSet(int k) {\\n        unordered_set<int> s;\\n        for(int i=1; i<=k; i++) \\n            s.insert(i);\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954779,
                "title": "rolling-mex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are looking for a specific failure, we only need to find a single failing sequence. It makes sense that this should occur *later* than other sequences.\\n\\nSecond, observe that making a sequence of length one requires that every number appears. From this, it follows that in order to form a sequence of two beginning with the latest arrival from the numbers 1 to k, you need every other number 1 to k to arrive after the straggler from the previous group. We\\'re then taking a sort of \"rolling mex\", and when it reaches k + 1, we have completed another step in our sequence building, and start again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a rolling set, when the size of the set reaches k, increment the answer, clear the set, and start over.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) (in my case O(nlogn) because I like std::set).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> st;\\n        int ans = 1;\\n        for (const auto& x : rolls) {\\n            st.insert(x);\\n            if (st.size() == k)\\n                st.clear(), ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> st;\\n        int ans = 1;\\n        for (const auto& x : rolls) {\\n            st.insert(x);\\n            if (st.size() == k)\\n                st.clear(), ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942503,
                "title": "javascript-keep-track-how-many-distinct-buckets-of-1-2-k-1-k-exist-in-rolls",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe answer is 1 if rolls doesn\\'t contain all integers between 1 and k.\\nfor the answer >1, you would need [[1-k]] \\nfor the answer >2, you would need [[1-k],[1-k]] \\nfor the answer >3 you would need [[1-k],[1-k],[1-k]] \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function(rolls, k) {\\n    //the answer is 1 if rolls doesn\\'t contain all integers between 1 and k.\\n    //for the answer >2, you would need [[1-k],[1-k]] \\n    //for the answer >3 you would need [[1-k],[1-k],[1-k]] \\n\\n    //have a set that tracks if you get all 1-k elements. If you hit that, increase output by 1.\\n    //reset the set and continue from where you are. \\n\\n    let output = 1;\\n    let missing = generateMissingSet(k);//set of [1,2,3,4] if k=4\\n    for(let i = 0; i < rolls.length; i++) {\\n        missing.delete(rolls[i]);\\n        if(missing.size === 0) {\\n            output += 1;\\n            missing = generateMissingSet(k);\\n        }\\n    }\\n\\n    return output;\\n};\\n\\nfunction generateMissingSet(k) {\\n    const set = new Set();\\n    for(let i = 1; i <= k; i++) {\\n        set.add(i);\\n    }\\n\\n    return set;\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function(rolls, k) {\\n    //the answer is 1 if rolls doesn\\'t contain all integers between 1 and k.\\n    //for the answer >2, you would need [[1-k],[1-k]] \\n    //for the answer >3 you would need [[1-k],[1-k],[1-k]] \\n\\n    //have a set that tracks if you get all 1-k elements. If you hit that, increase output by 1.\\n    //reset the set and continue from where you are. \\n\\n    let output = 1;\\n    let missing = generateMissingSet(k);//set of [1,2,3,4] if k=4\\n    for(let i = 0; i < rolls.length; i++) {\\n        missing.delete(rolls[i]);\\n        if(missing.size === 0) {\\n            output += 1;\\n            missing = generateMissingSet(k);\\n        }\\n    }\\n\\n    return output;\\n};\\n\\nfunction generateMissingSet(k) {\\n    const set = new Set();\\n    for(let i = 1; i <= k; i++) {\\n        set.add(i);\\n    }\\n\\n    return set;\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853053,
                "title": "single-loop-one-pass-o-n-beat-100",
                "content": "# Approach\\nUsed `flag` variable to set current state of the array `b`, to avoid refilling of vector and save time. \\nUsed `count` to count no of integers out of `k` that we have passed so far (unique).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> b(k+1,false);\\n        bool flag = false;\\n        int count = 0,ans = 1;\\n        for (auto i : rolls) {\\n            if (b[i] == flag) b[i] = !flag,count = count + 1;\\n            if (count == k) ans = ans + 1,flag = !flag,count = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> b(k+1,false);\\n        bool flag = false;\\n        int count = 0,ans = 1;\\n        for (auto i : rolls) {\\n            if (b[i] == flag) b[i] = !flag,count = count + 1;\\n            if (count == k) ans = ans + 1,flag = !flag,count = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816022,
                "title": "simple-one-pass-linear-time-space-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuititon is basically the number of groups of 1 till K we can form where each group is a subarray containing all the numbers and its size in minimum. We then count the number of groups we can form. The answer will be one plus the total number of complete group. This is the minimum because we can form any sequence of length smaller than this by taking any element from these groups in required order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI maintained two variables firstly \\'x\\' the count of groups and secondly cnt which denotes the number of elements present in the current group. Each time I encounter an element for the first time in a group I update the cnt variable and the v array so that any further encounter in the same group won\\'t affect my \\'cnt\\'. Whenever my cnt reaches K, I start my next group. See the implementation for better understanding. Try reading multiple times if not clear. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size();\\n        int ans=INT_MAX;\\n        vector<int> v(k+1,0);\\n        int cnt=0,x=1;\\n        for(int i=0;i<n;i++){\\n            if(v[rolls[i]]+1==x){\\n                cnt++;\\n                v[rolls[i]]++;\\n            }else{\\n                continue;\\n            }\\n            if(cnt==k){\\n                x++;\\n                cnt=0;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size();\\n        int ans=INT_MAX;\\n        vector<int> v(k+1,0);\\n        int cnt=0,x=1;\\n        for(int i=0;i<n;i++){\\n            if(v[rolls[i]]+1==x){\\n                cnt++;\\n                v[rolls[i]]++;\\n            }else{\\n                continue;\\n            }\\n            if(cnt==k){\\n                x++;\\n                cnt=0;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792594,
                "title": "simple-greedy-well-explained-set",
                "content": "# Intuition\\nIt is all about understanding the pattern of this question.Take examples start from length 1 and see what should be the condition(each number from 1 to k must appear once.This is simple enough!)\\nThen take 2:here it gets a bit tricky but a few test cases should give you the idea that the entire set of 1 to k must appear twice one after the other.\\nTrust me a make a few required subsets of that size and you will definitely see why this is happening.\\nI am also not that good of a coder yet so I am glad I could solve this in one go :)\\n\\n# Approach\\nSelf explanatory once you understand the logic\\n\\n# Complexity\\n- Time complexity:\\nO(k)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int count=0;\\n        if(rolls.size()==0)\\n            return 0;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                count++;\\n            }\\n        }\\n        if(s.size()==k)\\n            count++;\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int count=0;\\n        if(rolls.size()==0)\\n            return 0;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                s.clear();\\n                count++;\\n            }\\n        }\\n        if(s.size()==k)\\n            count++;\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790961,
                "title": "short-c-solution-beats-100-time-and-90-8-memory",
                "content": "# Intuition\\nSuppose dp(n,i) represents whether or not all sequences of length n exists from 1st roll to i-th roll, in order for dp(n,i) to be true, dp(n-1,j) must be true where j < i and in between j and i, there must be at least one occurence of rolls 1 to k. \\n\\nFor example:\\n[4,2,1,2,3,3,2,4,1], k = 4\\ndp(1,i) is only true at i=4 onwards as the first occurence of rolls 1 to k is only fulfilled at index 4:\\nroll 4 at index 0\\nroll 2 at index 1\\nroll 1 at index 2\\nroll 3 at index 4\\n\\ndp(2,i) is then true at index 8:\\nroll 3 at index 5\\nroll 2 at index 6\\nroll 4 at index 7\\nroll 1 at index 8\\n\\n# Approach\\nHowever, in this approach we do not need to create a 2d dp array. Instead, we can solve this in O(n) time.\\n\\ncount[x] represents the number of roll x that can be effectively used for the sequences during the current iteration i\\n\\nans represents the longest sequence length where all sequence of that length is possible\\n\\ncur represents the current number of rolls from 1 to k that have been rolled since the last time ans increased\\n\\nEverytime cur reaches k, it indicates that there is at least one occurence of rolls from 1 to k, meaning that ans can be increased.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        vector<int> count(k+1);\\n        int cur = 0, ans = 0;\\n        for(int i = 0; i < rolls.size();++i){\\n            if(count[rolls[i]] < ans+1){count[rolls[i]]++;cur++;}\\n            if(cur == k){ans++;cur=0;}\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        vector<int> count(k+1);\\n        int cur = 0, ans = 0;\\n        for(int i = 0; i < rolls.size();++i){\\n            if(count[rolls[i]] < ans+1){count[rolls[i]]++;cur++;}\\n            if(cur == k){ans++;cur=0;}\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765304,
                "title": "python-greedy-o-n-k-k-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif think a bit it will be similar to jump game with different conditions\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:    \\n        # store index of each dice\\n        n_to_indexes = collections.defaultdict(collections.deque)\\n        for i, n in enumerate(rolls):\\n            n_to_indexes[n].append(i)\\n\\n        # add the goal index on each dice\\n        for i in range(1, k + 1):\\n            n_to_indexes[i].append(len(rolls))\\n\\n        # start at 0 and stop at len(rolls)\\n        cur = 0\\n        count = 0\\n\\n        \"\"\"\\n        TC: worst case = O(n / k * k) = O(n)\\n        k = 10\\n        1: [1, 11, 21, 31,...]\\n        2: [2, 12, 22, 32, ..]\\n        3: [3, 13, 23, ...]\\n        ...\\n        \"\"\"\\n        while cur < len(rolls):\\n            farthest = cur\\n            # select the farthest index we can go\\n            for key in n_to_indexes:\\n                farthest = max(farthest, n_to_indexes[key][0])\\n\\n            # remove all index that is less than or equal with farthest index\\n            for key in n_to_indexes:\\n                while n_to_indexes[key] and n_to_indexes[key][0] <= farthest:\\n                    n_to_indexes[key].popleft()\\n\\n            # update farthest and count + 1\\n            cur = farthest\\n            count += 1\\n\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:    \\n        # store index of each dice\\n        n_to_indexes = collections.defaultdict(collections.deque)\\n        for i, n in enumerate(rolls):\\n            n_to_indexes[n].append(i)\\n\\n        # add the goal index on each dice\\n        for i in range(1, k + 1):\\n            n_to_indexes[i].append(len(rolls))\\n\\n        # start at 0 and stop at len(rolls)\\n        cur = 0\\n        count = 0\\n\\n        \"\"\"\\n        TC: worst case = O(n / k * k) = O(n)\\n        k = 10\\n        1: [1, 11, 21, 31,...]\\n        2: [2, 12, 22, 32, ..]\\n        3: [3, 13, 23, ...]\\n        ...\\n        \"\"\"\\n        while cur < len(rolls):\\n            farthest = cur\\n            # select the farthest index we can go\\n            for key in n_to_indexes:\\n                farthest = max(farthest, n_to_indexes[key][0])\\n\\n            # remove all index that is less than or equal with farthest index\\n            for key in n_to_indexes:\\n                while n_to_indexes[key] and n_to_indexes[key][0] <= farthest:\\n                    n_to_indexes[key].popleft()\\n\\n            # update farthest and count + 1\\n            cur = farthest\\n            count += 1\\n\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708641,
                "title": "c-set-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int>s;\\n\\n        int a=1;\\n        for(auto &i:rolls){\\n            s.insert(i);\\n            if(s.size()==k){\\n                a++;\\n                s.clear();\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int>s;\\n\\n        int a=1;\\n        for(auto &i:rolls){\\n            s.insert(i);\\n            if(s.size()==k){\\n                a++;\\n                s.clear();\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647160,
                "title": "greedy-approch-o-n-time",
                "content": "# Intuition\\n- 1 set of all k -> contribute 1 latter in shortest sequence that is not present \\n 1st latter will chose the last occurance of element from 0th index \\n- Becauase : Not present sequce gerate so we have option untill all elements are covered . \\n- when 0 to l index of array : contain all elments 1 to k \\nthen we have alway presetn 1 lenth string . \\n- 1st latter found -> maximum latter of given sequnce is wasted \\n- 2nd latter choise : \\n again we chose last elment from  after index in given sequnce \\nuntill we have choise that elment present we chose this ele \\nBecuase it will destroy inbettween charctor include \\n( shorting the string )\\n\\n\\nminimum len : sequnce present len find \\nand len +1 is ans . \\n\\n\\n- We requeied to only with length so find the  \\n  number of continues complete set present \\n\\n- return num + 1 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n       int res = 1 ;\\n       unordered_set<int> s; \\n\\n       for( auto a : rolls )\\n       {\\n           s.insert(a);\\n\\n           if(s.size()==k)\\n           {\\n                  ++res ; \\n                  s.clear();\\n\\n           }\\n       }\\n        \\n        return res; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n       int res = 1 ;\\n       unordered_set<int> s; \\n\\n       for( auto a : rolls )\\n       {\\n           s.insert(a);\\n\\n           if(s.size()==k)\\n           {\\n                  ++res ; \\n                  s.clear();\\n\\n           }\\n       }\\n        \\n        return res; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589538,
                "title": "python3-easy-greedy-solution-with-o-n-time-and-o-k-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of the solution like this, Let\\'s take k=2 as an example. Assume the squance like this\\n```\\nseq = [1,2,2]\\n```\\nNow as you can see, we have the ability to choose the first value as either 1 or two. But we can\\'t choose 1 as the second number. So there is no possibility to make following sequences,\\n```\\n[1,1] or [2,1]\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe greedily try to complete groups of all K items. Let\\'s say we were able to complete 2 sets of k items, then the result is k+1\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$ (Since we are keeping k items in the dict at a time)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        res = 1\\n        rollMap = set()\\n\\n        for i in rolls:\\n            rollMap.add(i)\\n            if len(rollMap) == k:\\n                res += 1\\n                rollMap = set()\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nseq = [1,2,2]\\n```\n```\\n[1,1] or [2,1]\\n```\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        res = 1\\n        rollMap = set()\\n\\n        for i in rolls:\\n            rollMap.add(i)\\n            if len(rollMap) == k:\\n                res += 1\\n                rollMap = set()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540409,
                "title": "o-n-time-complexity-o-m-space-complexity",
                "content": "\\n# Approach\\nThe problem aims to find the shortest sequence of unique numbers in an array before encountering a specified count k. Here\\'s a brief description of the approach used in the optimized code:\\n\\nInitialize variables:\\n\\nans to keep track of the number of sequences found.\\nmaxRoll to store the maximum value in the rolls array.\\nvisited as a boolean array to keep track of visited numbers.\\ncount to track the current count of unique numbers encountered.\\nIterate through the rolls array:\\n\\nFor each element, check if it has been visited before using visited[rolls[i]].\\nIf it hasn\\'t been visited, mark it as visited by setting visited[rolls[i]] to true.\\nIncrement count by 1.\\nCheck if count equals k:\\n\\nIf count equals k, it means we have found a sequence of k unique numbers.\\nReset the visited array by using Array.Clear(visited, 0, visited.Length).\\nReset count to 0.\\nIncrement ans by 1 to count the found sequence.\\nAfter iterating through the rolls array, return ans + 1 to account for the last sequence found, if any.\\n\\nBy using a boolean array visited to track visited numbers, we avoid adding duplicate numbers to the sequence. This approach allows us to optimize the code by reducing memory usage and eliminating unnecessary HashSet operations.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(M)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestSequence(int[] rolls, int k) {\\n        int ans = 0;\\n        int maxRoll = rolls.Max();\\n        bool[] visited = new bool[maxRoll + 1];\\n        int count = 0;\\n\\n        for (int i = 0; i < rolls.Length; i++) {\\n            if (!visited[rolls[i]]) {\\n                visited[rolls[i]] = true;\\n                count++;\\n\\n                if (count == k) {\\n                    Array.Clear(visited, 0, visited.Length);\\n                    count = 0;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestSequence(int[] rolls, int k) {\\n        int ans = 0;\\n        int maxRoll = rolls.Max();\\n        bool[] visited = new bool[maxRoll + 1];\\n        int count = 0;\\n\\n        for (int i = 0; i < rolls.Length; i++) {\\n            if (!visited[rolls[i]]) {\\n                visited[rolls[i]] = true;\\n                count++;\\n\\n                if (count == k) {\\n                    Array.Clear(visited, 0, visited.Length);\\n                    count = 0;\\n                    ans++;\\n                }\\n            }\\n        }\\n\\n        return ans + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513994,
                "title": "linear-algorithm-in-java-beats-90-of-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem appears to be hard but can be solved with a linear method.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution iterates ```rolls``` in sequence to count the number of sets of complete occurence of all dice numbers. An array ```k``` is used to record the number of \"valid\" occurences of numbers ```0 - k```. An occurence is \"valid\" if it occurred for the first time after ```sequence``` got incremented. Once all numbers occured at least once in order, ```sequence``` is incremented. After iteration of ```rolls``` completes, ```sequence``` is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis solution has linear complexity, O(n), where n = rolls.length\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n = k\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public static int shortestSequence(int[] rolls, int k)\\n    {\\n        int sequence = 1;\\n        int counter = 0;\\n        int[] occurrences = new int[k];\\n\\n        for (int i = 0; i < rolls.length; i++)\\n        {\\n            if (occurrences[rolls[i] - 1] == sequence - 1)\\n            {\\n                occurrences[rolls[i] - 1]++;\\n                counter++;\\n                if (counter % k == 0)\\n                {\\n                    sequence++;\\n                }\\n            }\\n        }\\n        return sequence;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```rolls```\n```k```\n```0 - k```\n```sequence```\n```sequence```\n```rolls```\n```sequence```\n```\\nclass Solution \\n{\\n    public static int shortestSequence(int[] rolls, int k)\\n    {\\n        int sequence = 1;\\n        int counter = 0;\\n        int[] occurrences = new int[k];\\n\\n        for (int i = 0; i < rolls.length; i++)\\n        {\\n            if (occurrences[rolls[i] - 1] == sequence - 1)\\n            {\\n                occurrences[rolls[i] - 1]++;\\n                counter++;\\n                if (counter % k == 0)\\n                {\\n                    sequence++;\\n                }\\n            }\\n        }\\n        return sequence;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474937,
                "title": "go-12-lines-100-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc shortestSequence(rolls []int, k int) int {\\n   ans := 1\\n   m := make(map[int]bool)\\n   for _,r := range rolls{\\n       m[r] = true\\n       if len(m) == k {\\n           ans++\\n           m = make(map[int]bool)\\n       }\\n   }\\n   return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shortestSequence(rolls []int, k int) int {\\n   ans := 1\\n   m := make(map[int]bool)\\n   for _,r := range rolls{\\n       m[r] = true\\n       if len(m) == k {\\n           ans++\\n           m = make(map[int]bool)\\n       }\\n   }\\n   return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459162,
                "title": "one-pass-python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans=1 # by default sequence of 1 may not be possible if any element in i...to..k does not occur even once\\n        temp = set() # we use hashset to check if series of unique numbers is complete \\n        for r in rolls:\\n            temp.add(r)\\n            if len(temp) == k: # if length = k, it means that at least one occurence of all numbers is complete, if a second time occurence is complete it would mean that all pairs in any order exist, if third occurence is complete it would mean that all triplets in any order exist and so on\\n                ans+=1 #for each complete occurence update with + 1\\n                temp.clear() #start with an empty set after each round of unique occurence\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans=1 # by default sequence of 1 may not be possible if any element in i...to..k does not occur even once\\n        temp = set() # we use hashset to check if series of unique numbers is complete \\n        for r in rolls:\\n            temp.add(r)\\n            if len(temp) == k: # if length = k, it means that at least one occurence of all numbers is complete, if a second time occurence is complete it would mean that all pairs in any order exist, if third occurence is complete it would mean that all triplets in any order exist and so on\\n                ans+=1 #for each complete occurence update with + 1\\n                temp.clear() #start with an empty set after each round of unique occurence\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454271,
                "title": "o-1-space-bitmasking",
                "content": "But the time complexity becomes $$O(n*log(k))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        t = d = 1 << k\\n        ans = 1\\n        for n in rolls:\\n            d |= 1 << (n - 1)\\n            if (d & (d + 1)) == 0:\\n                d = t\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        t = d = 1 << k\\n        ans = 1\\n        for n in rolls:\\n            d |= 1 << (n - 1)\\n            if (d & (d + 1)) == 0:\\n                d = t\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437098,
                "title": "c-beats-90-explanation-with-intuition-sliding-window-easy-to-understand-o-n-worst-case",
                "content": "Intuition:- Thing in greedy manner and find the rolls[i] which occurs after all other possible results have occurred \\n\\nexample:- \\nrolls={1,2,2,3,3,1,4,1,2,4,3}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 |\\n\\t\\t\\t\\t\\t\\t\\tk=4 \\n\\t\\t\\t\\t\\t\\t\\t\\n\\nhere 4 have occured after all other outcomes have occurred \\ni.e at index 6 (0-based indexing) so we get our first value and then 3 occurs after all other outcomes have occurred i.e at last index so we get our second number and then we can choose any outcome for third value . \\n\\nTherefore answer will be 3 here i.e [4,3,1] or [4,3,2] etc\\n\\nApproach - Take ans variable and Traverse the array and keep count of total number of unique results (unique rolls[i]) and for that you can use map or vector and when count becomes equal to k then increase and variable by 1 and then make your count equal to 0 and then keep moving forward and increase count when you encounter different rolls[i] and when count becomes equal to k increase ans by 1 , do the same till you traverse the whole array\\n\\nOptimisation:- But here\\'s the catch when first time count becomes equal to k then you have to either clear map or array which will take O(k) time which will make TC-O(n*k) .\\nSo for that what you can do is when count becomes equal to k for first time then  don\\'t make count equal to 0 and don\\'t clea map or array  just keep on increasing it and when your count becomes equal to 2*k (i.e at second time) then increase ans by 1\\nand keep doing \\xA0this till you reach end of rolls array .\\n\\nYou can check out my code for Better understanding if you didn\\'t understand the intuition completely. \\nAnd it\\'s my first time posting solution with approach and if you like it then please upvote it will really motivate me to keep posting such stuff .\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& r, int k) {\\n        vector<int>mp(k,0);\\n       int c=1,s=0,ans=0;\\n   for(int i=0;i<r.size();i++){\\n       if(mp[r[i]-1]<c)mp[r[i]-1]++,s++;\\n       \\n       if(s==k*c)ans++,c++;\\n     }\\n        return ans+1;\\n    }\\n};\\n\\n```\\n\\nTC-O(n)\\nSC-O(k)\\n\\nIn case if you like it then please upvote and if you don\\'t then comment about what you didn\\'t like .",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& r, int k) {\\n        vector<int>mp(k,0);\\n       int c=1,s=0,ans=0;\\n   for(int i=0;i<r.size();i++){\\n       if(mp[r[i]-1]<c)mp[r[i]-1]++,s++;\\n       \\n       if(s==k*c)ans++,c++;\\n     }\\n        return ans+1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372496,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len = 0 ;\\n        unordered_set<int>seen ;\\n        for(int i = 0; i < rolls.size(); i++){\\n            seen.insert(rolls[i]) ;\\n            if(seen.size() == k){\\n                len++ ;\\n                seen.clear() ;\\n            }\\n        }\\n        return len+1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len = 0 ;\\n        unordered_set<int>seen ;\\n        for(int i = 0; i < rolls.size(); i++){\\n            seen.insert(rolls[i]) ;\\n            if(seen.size() == k){\\n                len++ ;\\n                seen.clear() ;\\n            }\\n        }\\n        return len+1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364164,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls, k):\\n        min_val, ans = 0, set()\\n\\n        for i in rolls:\\n            ans.add(i)\\n            if len(ans) == k:\\n                min_val += 1\\n                ans.clear()\\n\\n        return min_val + 1\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls, k):\\n        min_val, ans = 0, set()\\n\\n        for i in rolls:\\n            ans.add(i)\\n            if len(ans) == k:\\n                min_val += 1\\n                ans.clear()\\n\\n        return min_val + 1\\n\\n        \\n\\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328608,
                "title": "try-to-reach-end-as-quickly-as-possible",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    // step 1: suppose we are at pos i, how can we reach to end as fast as possible?\\n    int next_farthest(int i, int n, int k, vector<int>& rolls) {\\n        int target = n;\\n        set<int> s;\\n        for (int j = i + 1; j < n; j++) {\\n            s.insert(rolls[j]);\\n            if (s.size() == k) {\\n                target = j;\\n                break;\\n            }\\n        }\\n        \\n        return target;\\n    }\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int cnt = 0, i = -1;\\n        while (i < n) {\\n            i = next_farthest(i, n, k, rolls);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // step 1: suppose we are at pos i, how can we reach to end as fast as possible?\\n    int next_farthest(int i, int n, int k, vector<int>& rolls) {\\n        int target = n;\\n        set<int> s;\\n        for (int j = i + 1; j < n; j++) {\\n            s.insert(rolls[j]);\\n            if (s.size() == k) {\\n                target = j;\\n                break;\\n            }\\n        }\\n        \\n        return target;\\n    }\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n = rolls.size();\\n        int cnt = 0, i = -1;\\n        while (i < n) {\\n            i = next_farthest(i, n, k, rolls);\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325688,
                "title": "javascript-2350-shortest-impossible-sequence-of-rolls",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar shortestSequence = function (r, k) {\\n    let set = new Set(),\\n        allKSeenCount = 0;\\n    for (let e of r) {\\n        set.add(e);\\n        if (set.size === k) {\\n            allKSeenCount += 1; // all k seen\\n            set = new Set(); // reset\\n        }\\n    }\\n    return allKSeenCount + 1;\\n};\\n```\\n\\n2\\n```\\nvar shortestSequence = function (r, k) {\\n    let a = new Array(k + 1).fill(0),\\n        allKSeenCount = 1,\\n        remaining = k;\\n    for (let e of r)\\n        if (a[e] < allKSeenCount) {\\n            a[e] = allKSeenCount;\\n            remaining -= 1;\\n            if (remaining == 0) {\\n                remaining = k;\\n                allKSeenCount += 1;\\n            }\\n        }\\n    return allKSeenCount;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestSequence = function (r, k) {\\n    let set = new Set(),\\n        allKSeenCount = 0;\\n    for (let e of r) {\\n        set.add(e);\\n        if (set.size === k) {\\n            allKSeenCount += 1; // all k seen\\n            set = new Set(); // reset\\n        }\\n    }\\n    return allKSeenCount + 1;\\n};\\n```\n```\\nvar shortestSequence = function (r, k) {\\n    let a = new Array(k + 1).fill(0),\\n        allKSeenCount = 1,\\n        remaining = k;\\n    for (let e of r)\\n        if (a[e] < allKSeenCount) {\\n            a[e] = allKSeenCount;\\n            remaining -= 1;\\n            if (remaining == 0) {\\n                remaining = k;\\n                allKSeenCount += 1;\\n            }\\n        }\\n    return allKSeenCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227876,
                "title": "simple-c-solution-unordered-set",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> set;\\n        int res = 1; \\n        for(int &i: rolls) {\\n            set.insert(i);\\n            if(set.size() == k) {\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> set;\\n        int res = 1; \\n        for(int &i: rolls) {\\n            set.insert(i);\\n            if(set.size() == k) {\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205865,
                "title": "python3-solution-with-using-greedy-approach",
                "content": "# Intuition\\nk = 2:\\n\\nif we collect set size of 2 => we have all seq of len = size set - 1\\n\\nif we can collect full set size of 2 => we have all seq of len = size set - 1 + 1 => we can use the previous elements to make a consistently large size\\n\\n[1, 2, 2, 1, 1, 2]\\n\\n1. 1 2 -> go to seq of len 2\\n2. 2 1 (we have [1, 1], [1,2], [2,1], [2,2])\\n3. ...\\n\\nat each iteration, we sort of check whether we can use a permutation of elements for a larger sequence size.\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        res = 1\\n        s = set()\\n\\n        for idx in range(len(rolls)):\\n            s.add(rolls[idx])\\n\\n            if len(s) == k:\\n                res += 1\\n                s = set()\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        res = 1\\n        s = set()\\n\\n        for idx in range(len(rolls)):\\n            s.add(rolls[idx])\\n\\n            if len(s) == k:\\n                res += 1\\n                s = set()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103309,
                "title": "c-2-approaches-set-map-easy-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1- Initialize ans=0;\\nStep 2- if we will take map then we only have to store unique value.\\nStep 3- if size of map is equal to k then increase the count and clear the map value.\\n\\nIn case of set it will work as same. Because set always store unique value.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code using map\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n       unordered_map<int,int>mp;\\n        int cnt=0,ans=1;\\n        for(int &i:rolls){\\n            mp[i]++;\\n            if(mp[i]==1) cnt++;\\n            if(cnt==k){\\n                ans++;\\n                mp.clear();\\n               cnt=0;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code using set\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        int ans=1;\\n        for(int &i:rolls){\\n            s.insert(i);\\n            if(s.size()==k){ans++; s.clear();}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n       unordered_map<int,int>mp;\\n        int cnt=0,ans=1;\\n        for(int &i:rolls){\\n            mp[i]++;\\n            if(mp[i]==1) cnt++;\\n            if(cnt==k){\\n                ans++;\\n                mp.clear();\\n               cnt=0;\\n             }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>s;\\n        int ans=1;\\n        for(int &i:rolls){\\n            s.insert(i);\\n            if(s.size()==k){ans++; s.clear();}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098153,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n=rolls.size();\\n        int ans=0;\\n        unordered_set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n=rolls.size();\\n        int ans=0;\\n        unordered_set<int> s;\\n        for(int i=0;i<n;i++)\\n        {\\n            s.insert(rolls[i]);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094231,
                "title": "easy-simple-solution-c-small-code-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int cnt=0, idx=0;\\n        while(1)\\n        {\\n            int t=0;\\n            map<int,bool> map;\\n            while(1)\\n            {\\n               if(map[rolls[idx]]==false)\\n               {\\n                   map[rolls[idx]]=true;\\n                   t++;\\n               }\\n               if(t==k)\\n               {\\n                   cnt++;\\n                   idx++;\\n                   if(idx>=rolls.size())\\n                   return cnt+1;\\n                   break;\\n               }\\n               idx++;\\n               if(idx>=rolls.size())\\n               return cnt+1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int cnt=0, idx=0;\\n        while(1)\\n        {\\n            int t=0;\\n            map<int,bool> map;\\n            while(1)\\n            {\\n               if(map[rolls[idx]]==false)\\n               {\\n                   map[rolls[idx]]=true;\\n                   t++;\\n               }\\n               if(t==k)\\n               {\\n                   cnt++;\\n                   idx++;\\n                   if(idx>=rolls.size())\\n                   return cnt+1;\\n                   break;\\n               }\\n               idx++;\\n               if(idx>=rolls.size())\\n               return cnt+1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941415,
                "title": "java-c-set-hashset-solution-with-intuition-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple obeservation you can make is that to make each possible sequence of any size i you need every 1 to k elements at least i times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example to make each sequence of length 2 you need 1 to 4 2 times at least. (1,2,3,4,....1,2,3,4). So that each letter has occured before for every new occurance of 1,2..4. \\n\\n# Complexity\\n- Time complexity: O(N) one pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) for set\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int cur = 1, n = rolls.length, i = 0;   \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(i < n){\\n            //insert for c++\\n            set.add(rolls[i]);\\n\\n            if(set.size() == k){\\n                cur++;\\n                set.clear();\\n            }\\n            i++;\\n        }\\n\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int cur = 1, n = rolls.length, i = 0;   \\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(i < n){\\n            //insert for c++\\n            set.add(rolls[i]);\\n\\n            if(set.size() == k){\\n                cur++;\\n                set.clear();\\n            }\\n            i++;\\n        }\\n\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895593,
                "title": "python-one-pass-with-set",
                "content": "# Intuition\\nlet\\'s look at the first element of any sequence:\\nthe first occurence of this number in `rolls` will be the first element of the sequence.\\nsince a single _impossible_ sequence is enough, it\\'s sufficient to concentrate on the worst case only.\\nso we can check for all numbers for the first occurence of that number in `rolls` and continue from the last one (worst case start of sequence).\\nthen we repeat the process starting at that position until `rolls` is exhausted.\\n\\nall of the occurence checks can be combined in a single pass.\\n\\n\\n\\n# Approach\\n- create set containing all needed values\\n- for every element in `rolls` remove element from set\\n- if set is empty increment count and refill set\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def shortestSequence(self, rolls, k):\\n        count = 1\\n        missing = set(range(k))\\n\\n        for r in rolls:\\n            missing.discard(r-1)\\n            if len(missing) == 0:\\n                missing = set(range(k))\\n                count += 1\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def shortestSequence(self, rolls, k):\\n        count = 1\\n        missing = set(range(k))\\n\\n        for r in rolls:\\n            missing.discard(r-1)\\n            if len(missing) == 0:\\n                missing = set(range(k))\\n                count += 1\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890037,
                "title": "simple-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> hsh( k ,false);\\n        int ct=0;\\n        int ans=0;\\n\\n        for( int i=0; i< rolls.size(); i++)\\n        {\\n            if( hsh[rolls[i]-1]==false)\\n            {\\n                hsh[rolls[i]-1]=true;\\n                ct++;\\n            }\\n            if( ct==k)\\n\\n            {\\n\\n                for( int j=0; j< k; j++)\\n                {\\n                    hsh[j]=false;\\n                }\\n                ans++;\\n                ct=0;;\\n            }\\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<bool> hsh( k ,false);\\n        int ct=0;\\n        int ans=0;\\n\\n        for( int i=0; i< rolls.size(); i++)\\n        {\\n            if( hsh[rolls[i]-1]==false)\\n            {\\n                hsh[rolls[i]-1]=true;\\n                ct++;\\n            }\\n            if( ct==k)\\n\\n            {\\n\\n                for( int j=0; j< k; j++)\\n                {\\n                    hsh[j]=false;\\n                }\\n                ans++;\\n                ct=0;;\\n            }\\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889582,
                "title": "easiest-python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861980,
                "title": "python-greedy-solution",
                "content": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        indices = collections.defaultdict(list)\\n        for index, roll in enumerate(rolls):\\n            indices[roll].append(index)\\n        ret = 1\\n        furthest = -1\\n        while 1:\\n            current_furthest = furthest\\n            for val in range(1, k + 1):\\n                while indices[val] and indices[val][0] < furthest:\\n                    indices[val].pop(0)\\n                if not indices[val]:\\n                    return ret\\n                else:\\n                    current_furthest = max(current_furthest, indices[val].pop(0))\\n            furthest = current_furthest\\n            ret += 1\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        indices = collections.defaultdict(list)\\n        for index, roll in enumerate(rolls):\\n            indices[roll].append(index)\\n        ret = 1\\n        furthest = -1\\n        while 1:\\n            current_furthest = furthest\\n            for val in range(1, k + 1):\\n                while indices[val] and indices[val][0] < furthest:\\n                    indices[val].pop(0)\\n                if not indices[val]:\\n                    return ret\\n                else:\\n                    current_furthest = max(current_furthest, indices[val].pop(0))\\n            furthest = current_furthest\\n            ret += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2819090,
                "title": "count-the-number-of-splits-containing-k-elements",
                "content": "# Intuition\\nCount how many splits of the input array can have the K elements.\\n\\n# Approach\\nLet\\'s suppose the input array is `[1,2,1,3,4,4,1,2,2,3]` and `K = 4`\\nThis array can have two splits with K elements.\\n\\n```\\nsplit1 = [1,2,1,3,4]\\nsplit2 = [4,1,2,2,3]\\n```\\n\\nWith these two splits you can do any sequence from length 1:\\n`[1], [2], [3], [4] `\\nand length 2:\\n`[1,1], [1,2], [1,3], [1,4], [2,1], [2,2], [2,3], ... [4,4]`\\n\\nFor sequences of length beyond two, you don\\'t have enough elements to create a new split so you can\\'t combine them to form valid sequences of lengths > 2.\\n\\nTo count the splits use a set, whenever its size is equals to K, increment the count, return count + 1 (the sequence length that is not available to be created with elements in the input array) -- reset the set when its size is equal K, so you can count the new split.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nYou have to go over the whole input array\\n\\n- Space complexity:\\n$$O(k)$$\\nK is the maximum size of the Set\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        int count = 0;\\n        for(int r : rolls)\\n        {\\n            set.add(r);\\n            if(set.size() == k)\\n            {\\n                count++;\\n                set.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n \\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsplit1 = [1,2,1,3,4]\\nsplit2 = [4,1,2,2,3]\\n```\n```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        int count = 0;\\n        for(int r : rolls)\\n        {\\n            set.add(r);\\n            if(set.size() == k)\\n            {\\n                count++;\\n                set.clear();\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816233,
                "title": "c-easy-to-understand",
                "content": "->we make widow of 1-k as many widow we can make ,we can able to make that length of all posible sequence.\\n -> return no of window+1,bcz we can all sequence of window size.\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int ans=0;\\n        unordered_set<int> s;\\n        for(auto &x:rolls)\\n        {\\n            s.insert(x);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }\\n        }\\n        return ans+1;\\n        \\n    }\\n};\\n//if you like the solution plz uopvote.",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int ans=0;\\n        unordered_set<int> s;\\n        for(auto &x:rolls)\\n        {\\n            s.insert(x);\\n            if(s.size()==k)\\n            {\\n                ans++;\\n                s.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2779582,
                "title": "javascript-hashset",
                "content": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function (rolls, k) {\\n  let ans = 1;\\n  let set = new Set([]);\\n\\n  for (const roll of rolls) {\\n    set.add(roll);\\n\\n    if (set.size === k) {\\n      ans++;\\n      set = new Set([]);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function (rolls, k) {\\n  let ans = 1;\\n  let set = new Set([]);\\n\\n  for (const roll of rolls) {\\n    set.add(roll);\\n\\n    if (set.size === k) {\\n      ans++;\\n      set = new Set([]);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757347,
                "title": "python-3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n\\n        z = set()\\n        res = 0\\n\\n        for x in rolls:\\n            z.add(x)\\n            if len(z) == k:\\n                res += 1\\n                z.clear()\\n                \\n        return res + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n\\n        z = set()\\n        res = 0\\n\\n        for x in rolls:\\n            z.add(x)\\n            if len(z) == k:\\n                res += 1\\n                z.clear()\\n                \\n        return res + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2740651,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int count = 0;\\n        int res = 1;\\n        unordered_map<int, int> m;\\n        \\n        for(int& roll: rolls) {\\n            if(m[roll] < res) count++, m[roll]++;\\n            if(count == k * res) res++;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int count = 0;\\n        int res = 1;\\n        unordered_map<int, int> m;\\n        \\n        for(int& roll: rolls) {\\n            if(m[roll] < res) count++, m[roll]++;\\n            if(count == k * res) res++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2730446,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function (rolls, k) {\\n  let a = new Set();\\n  let b = 1;\\n\\n  for (const c of rolls) {\\n    a.add(c);\\n    if (a.size === k) {\\n      b++;\\n      a = new Set();\\n    }\\n  }\\n\\n  return b;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} rolls\\n * @param {number} k\\n * @return {number}\\n */\\nvar shortestSequence = function (rolls, k) {\\n  let a = new Set();\\n  let b = 1;\\n\\n  for (const c of rolls) {\\n    a.add(c);\\n    if (a.size === k) {\\n      b++;\\n      a = new Set();\\n    }\\n  }\\n\\n  return b;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2730222,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k)\\n    {\\n        unordered_set<int> st;\\n        \\n        int res = 0;\\n        \\n        for(auto &x: rolls)\\n        {\\n            st.insert(x);\\n            \\n            if(st.size() == k)\\n            {\\n                res++;\\n                \\n                st.clear();\\n            }\\n            \\n        }\\n        \\n        return ++res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k)\\n    {\\n        unordered_set<int> st;\\n        \\n        int res = 0;\\n        \\n        for(auto &x: rolls)\\n        {\\n            st.insert(x);\\n            \\n            if(st.size() == k)\\n            {\\n                res++;\\n                \\n                st.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2699602,
                "title": "c-simple-solution-greedy-90-faster-time",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size(),ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[rolls[i]]++;\\n            if(m.size()==k){\\n                ans++;\\n                m.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int n=rolls.size(),ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[rolls[i]]++;\\n            if(m.size()==k){\\n                ans++;\\n                m.clear();\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681375,
                "title": "very-simple-c-solution-in-single-pass-time-o-n-space-o-k",
                "content": "**FYI: Code is very simple than the explanation**\\n# Idea\\nTo build the understanding let us take few examples\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n1) rolls = [1,2] , k = 2\\nNow the length of the smallest sequence that can\\'t be formed is 2 as we can clearly see that [1,1] , [2,2] and [2,1] are not possible from the given sequence.\\n\\n2) rolls = [1,2,1,2] , k = 2\\nNow the length of the smallest sequence that can\\'t be formed is 3 as we can see that we can\\'t from [1,1,1] , [2,2,2] etc\\n\\nNow if we carefully observe, logic for the solution lies in the above two examples. \\n\\n**Consider the example 2. Rolls = [1,2,1,2] , k=2**\\n->This example supports all the two length sequences because there are two groups of [1,2] numbers in rolls. \\n\\n                                                  first    second\\n\\n->we can select first(variable shown above) either [1,2] from the first group and similarly second (variable shown above )can either be [1,2] from the second group. So this allows us to create all the possible two length sequences. \\n\\n\\nSo basically we need to count the number of [1,2,...k] sequences from rolls. Let this value be cnt. What this signifies is that, we will be able to create all the possible cnt length sequences from the given sequence. So the minimum length of sequence that we can\\'t create will be cnt+1. So our answer will be cnt+1.\\n\\n# Overlapping sequences\\nHere we should not consider overlapping sequece that is, if we start a sequence unless all the digits from (1,2,..k) includes we will not increment the count. It will be clear with an example\\nrolls = [1,1,2,2,3,4,3,4], k=4\\n-> If we observe there are two sequences of (1,2,3,4) one from rolls[0] to rolls[5] and other from rolls[1] to rolls[7]. But if we observe both are overlapping so count should not be considered as 2 but we should consider it as 1. So we have already started counting then until the present sequence of (1,2,3...k) completets we should not begin the next count. So basically we need to count independent groups of (1,2..k) and overlapping groups should not be considered. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n    int cnt=1;\\n    unordered_set<int>s;\\n    for(int i=0;i<rolls.size();i++){\\n        s.insert(rolls[i]);\\n        if(s.size()==k){\\n            cnt++;\\n            s.clear();\\n        }\\n    }\\n    return cnt;  \\n    }\\n};\\n```\\n                        \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n    int cnt=1;\\n    unordered_set<int>s;\\n    for(int i=0;i<rolls.size();i++){\\n        s.insert(rolls[i]);\\n        if(s.size()==k){\\n            cnt++;\\n            s.clear();\\n        }\\n    }\\n    return cnt;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669274,
                "title": "rust-34ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn shortest_sequence(rolls: Vec<i32>, k: i32) -> i32 {\\n        use std::collections::HashSet;\\n        let mut records = HashSet::new();\\n        let mut ret = 1;\\n        for n in rolls.iter() {\\n            records.insert(n);\\n            if records.len() as i33 == k {\\n                ret += 1;\\n                records.clear();\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn shortest_sequence(rolls: Vec<i32>, k: i32) -> i32 {\\n        use std::collections::HashSet;\\n        let mut records = HashSet::new();\\n        let mut ret = 1;\\n        for n in rolls.iter() {\\n            records.insert(n);\\n            if records.len() as i33 == k {\\n                ret += 1;\\n                records.clear();\\n            }\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667319,
                "title": "c-greedy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<int> occur(k+1,0);\\n        int j=0,ans=0,cnt=0,n=rolls.size();\\n        while(j<n){\\n           while(j < n && cnt < k){\\n               if(!occur[rolls[j]])\\n                   cnt++;\\n               occur[rolls[j]]=1;\\n               j++;\\n            }\\n            if(cnt == k)\\n                ans++;\\n            for(int i = 1;i<=k;i++)\\n                occur[i]=0;\\n            cnt = 0;  \\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        vector<int> occur(k+1,0);\\n        int j=0,ans=0,cnt=0,n=rolls.size();\\n        while(j<n){\\n           while(j < n && cnt < k){\\n               if(!occur[rolls[j]])\\n                   cnt++;\\n               occur[rolls[j]]=1;\\n               j++;\\n            }\\n            if(cnt == k)\\n                ans++;\\n            for(int i = 1;i<=k;i++)\\n                occur[i]=0;\\n            cnt = 0;  \\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644799,
                "title": "python-solution-faster-90",
                "content": "class Solution:\\n\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def shortestSequence(self, rolls, k):\\n        res = 1\\n        s = set()\\n        for a in rolls:\\n            s.add(a)\\n            if len(s) == k:\\n                res += 1\\n                s.clear()\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2609604,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int total = 0;\\n        for(int i:rolls){\\n            set.add(i);\\n            if(set.size()==k){\\n                total++;\\n                set.clear();\\n            }\\n        }\\n        return total+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int total = 0;\\n        for(int i:rolls){\\n            set.add(i);\\n            if(set.size()==k){\\n                total++;\\n                set.clear();\\n            }\\n        }\\n        return total+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455906,
                "title": "is-111-is-a-valid-sequence-because-we-have-11-as-well",
                "content": "IS 111 IS A VALID SEQUENCE BECAUSE WE HAVE 11 AS WELL?",
                "solutionTags": [
                    "Java"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2455881,
                "title": "shortest-impossible-sequence-of-rolls-all-the-solution-mentioned-previous-i-have-breaking-case",
                "content": "I WILL DEFER A BIT HERE BECAUSE WE CAN CREATE ALL THE SEQUENCE OF 3\\n{1,2,3,4,1,2,3,4} ==> ALL ONE LENGTH IS POSSIBLE HERE K = 4 N = 8\\nALL LENGTH OF TWO IS POSSIBLE\\nALL THE LENGTH IS POSSIBLE {1,2} {3}, {1,3} {2}, {1,2} {4} {1,3} {4}, {1,4} {2} {1,4} {3}",
                "solutionTags": [
                    "Java"
                ],
                "code": "I WILL DEFER A BIT HERE BECAUSE WE CAN CREATE ALL THE SEQUENCE OF 3\\n{1,2,3,4,1,2,3,4} ==> ALL ONE LENGTH IS POSSIBLE HERE K = 4 N = 8\\nALL LENGTH OF TWO IS POSSIBLE\\nALL THE LENGTH IS POSSIBLE {1,2} {3}, {1,3} {2}, {1,2} {4} {1,3} {4}, {1,4} {2} {1,4} {3}",
                "codeTag": "Unknown"
            },
            {
                "id": 2439166,
                "title": "c-solution-o-n-tc-o-k-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    static int shortestSequence(const vector<int>& rolls, const int k) {\\n        vector<bool> arr(k, false);\\n        int ret = 1;\\n        int c = 0;\\n        for (auto i : rolls)\\n            if (!arr[i - 1]) {\\n                arr[i - 1] = true;\\n                if (++c >= k) {\\n                    c = 0;\\n                    ++ret;\\n                    arr = vector<bool>(k, false);\\n                }\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int shortestSequence(const vector<int>& rolls, const int k) {\\n        vector<bool> arr(k, false);\\n        int ret = 1;\\n        int c = 0;\\n        for (auto i : rolls)\\n            if (!arr[i - 1]) {\\n                arr[i - 1] = true;\\n                if (++c >= k) {\\n                    c = 0;\\n                    ++ret;\\n                    arr = vector<bool>(k, false);\\n                }\\n            }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413273,
                "title": "java-3-ms-faster-than-100-less-than-83-76",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        boolean[] present = new boolean[k+1];\\n        int count = 0;\\n        int len = 0;\\n        for (int roll : rolls) {\\n            if (present[roll]) continue;\\n            present[roll] = true;\\n            if (++count < k) continue;\\n            Arrays.fill(present, false);\\n            count = 0;\\n            len++;\\n        }\\n        return len+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        boolean[] present = new boolean[k+1];\\n        int count = 0;\\n        int len = 0;\\n        for (int roll : rolls) {\\n            if (present[roll]) continue;\\n            present[roll] = true;\\n            if (++count < k) continue;\\n            Arrays.fill(present, false);\\n            count = 0;\\n            len++;\\n        }\\n        return len+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409685,
                "title": "avoiding-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        if(k>rolls.size())return 1;\\n        int n=rolls.size();\\n        int ans=1;\\n        auto st=new unordered_set<int>;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            st->insert(rolls[i]);\\n            if(st->size()==k)\\n            {\\n                \\n                ans++;\\n                st=new unordered_set<int>;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        if(k>rolls.size())return 1;\\n        int n=rolls.size();\\n        int ans=1;\\n        auto st=new unordered_set<int>;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            st->insert(rolls[i]);\\n            if(st->size()==k)\\n            {\\n                \\n                ans++;\\n                st=new unordered_set<int>;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2408260,
                "title": "cpp-soln-with-explanation",
                "content": "We will greedily try to build sequences from end of `rolls` array. Once we succeed in building sequence of size `q`, we reset dp set that keeps track of start elements of built sequences and start building sequnce of size `q+1` , since we already built `q` length sequence.\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int i,j,n=rolls.size(),c=1;\\n        unordered_set<int> dp;\\n        \\n        for(i=n-1;i>=0;i--){\\n            if(dp.size()==k){\\n                c++;\\n                dp.clear();\\n            }\\n            dp.insert(rolls[i]);\\n        }\\n        if(dp.size()==k)c++;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int i,j,n=rolls.size(),c=1;\\n        unordered_set<int> dp;\\n        \\n        for(i=n-1;i>=0;i--){\\n            if(dp.size()==k){\\n                c++;\\n                dp.clear();\\n            }\\n            dp.insert(rolls[i]);\\n        }\\n        if(dp.size()==k)c++;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395896,
                "title": "python-go-c-greedy-w-dp-array-vs-hashset-o-n",
                "content": "*Python* solution w/ DP array\\n\\n```python\\ndef shortestSequence(self, rolls, k):\\n    seq, cnt, dp = 0, 0, [0] * (k + 1)\\n    for x in rolls:\\n        if dp[x] == seq:\\n            dp[x] += 1\\n            cnt += 1\\n            seq = cnt // k\\n    return seq + 1\\n```\\n\\n*Python* solution w/ hashset\\n\\n```python\\ndef shortestSequence(self, rolls, k):\\n    res, seen = 1, set()\\n    for x in rolls:\\n        seen.add(x)\\n        if len(seen) == k:\\n            seen.clear()\\n            res += 1\\n    return res\\n```\\n\\n*Go* solution w/ DP array in 123ms beat 91% :)\\n\\n```go\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tvar (\\n\\t\\tseq int\\n\\t\\tcnt int\\n\\t\\tdp  = make([]int, k+1)\\n\\t)\\n\\tfor _, x := range rolls {\\n\\t\\tif dp[x] == seq {\\n\\t\\t\\tdp[x]++\\n\\t\\t\\tcnt++\\n\\t\\t\\tseq = cnt / k\\n\\t\\t}\\n\\t}\\n\\treturn seq + 1\\n}\\n```\\n\\n*Go* solution w/ hashset\\n\\n```go\\ntype none struct{}\\n\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tres, seen := 1, make(map[int]none)\\n\\tfor _, x := range rolls {\\n\\t\\tseen[x] = none{}\\n\\t\\tif len(seen) == k {\\n\\t\\t\\tseen = make(map[int]none)\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*C++* solution w/ DP array in 154ms beat 98% :)\\n\\n```c++\\nint shortestSequence(vector<int> &rolls, int k) {\\n    int seq = 0, cnt = 0;\\n    vector<int> dp(k + 1, 0);\\n    for (int x : rolls) {\\n        if (dp[x] == seq) {\\n            ++dp[x];\\n            seq = ++cnt / k;\\n        }\\n    }\\n    return seq + 1;\\n}\\n```\\n\\n*C++* solution w/ hashset\\n\\n```c++\\nint shortestSequence(vector<int> &rolls, int k) {\\n    int res = 1;\\n    set<int> seen;\\n    for (int x : rolls) {\\n        seen.insert(x);\\n        if (seen.size() == k) {\\n            seen.clear();\\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef shortestSequence(self, rolls, k):\\n    seq, cnt, dp = 0, 0, [0] * (k + 1)\\n    for x in rolls:\\n        if dp[x] == seq:\\n            dp[x] += 1\\n            cnt += 1\\n            seq = cnt // k\\n    return seq + 1\\n```\n```python\\ndef shortestSequence(self, rolls, k):\\n    res, seen = 1, set()\\n    for x in rolls:\\n        seen.add(x)\\n        if len(seen) == k:\\n            seen.clear()\\n            res += 1\\n    return res\\n```\n```go\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tvar (\\n\\t\\tseq int\\n\\t\\tcnt int\\n\\t\\tdp  = make([]int, k+1)\\n\\t)\\n\\tfor _, x := range rolls {\\n\\t\\tif dp[x] == seq {\\n\\t\\t\\tdp[x]++\\n\\t\\t\\tcnt++\\n\\t\\t\\tseq = cnt / k\\n\\t\\t}\\n\\t}\\n\\treturn seq + 1\\n}\\n```\n```go\\ntype none struct{}\\n\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tres, seen := 1, make(map[int]none)\\n\\tfor _, x := range rolls {\\n\\t\\tseen[x] = none{}\\n\\t\\tif len(seen) == k {\\n\\t\\t\\tseen = make(map[int]none)\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\n```c++\\nint shortestSequence(vector<int> &rolls, int k) {\\n    int seq = 0, cnt = 0;\\n    vector<int> dp(k + 1, 0);\\n    for (int x : rolls) {\\n        if (dp[x] == seq) {\\n            ++dp[x];\\n            seq = ++cnt / k;\\n        }\\n    }\\n    return seq + 1;\\n}\\n```\n```c++\\nint shortestSequence(vector<int> &rolls, int k) {\\n    int res = 1;\\n    set<int> seen;\\n    for (int x : rolls) {\\n        seen.insert(x);\\n        if (seen.size() == k) {\\n            seen.clear();\\n            ++res;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2395880,
                "title": "c-o-n-recursion",
                "content": "```\\nclass Solution {\\npublic:\\nint help(vector<int> &ar,int idx,int k,int cur){\\n    if(idx<0) return 0;\\n    // cur denotes that ar[idx+1]~ar[n-1] has all possible permutations of length cur\\n    set<int> st;\\n    int i=idx;\\n    for(;i>=0 && st.size()<k;i--){\\n        if(!st.count(ar[i])) st.insert(ar[i]);\\n        if(st.size()==k) break;\\n    }\\n    if(st.size()!=k) return cur;\\n    // ar[i]~ar[n-1] contains all permutations of length cur+1\\n    return max(cur+1,help(ar,i-1,k,cur+1));\\n}\\n\\nint shortestSequence(vector<int>& ar, int k) {\\n    return help(ar,ar.size()-1,k,0)+1;\\n}\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint help(vector<int> &ar,int idx,int k,int cur){\\n    if(idx<0) return 0;\\n    // cur denotes that ar[idx+1]~ar[n-1] has all possible permutations of length cur\\n    set<int> st;\\n    int i=idx;\\n    for(;i>=0 && st.size()<k;i--){\\n        if(!st.count(ar[i])) st.insert(ar[i]);\\n        if(st.size()==k) break;\\n    }\\n    if(st.size()!=k) return cur;\\n    // ar[i]~ar[n-1] contains all permutations of length cur+1\\n    return max(cur+1,help(ar,i-1,k,cur+1));\\n}\\n\\nint shortestSequence(vector<int>& ar, int k) {\\n    return help(ar,ar.size()-1,k,0)+1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379745,
                "title": "c-set-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 0;\\n        set<int> st;\\n        for(int &it: rolls) {\\n            st.insert(it);\\n            if(st.size() == k) {\\n                ans += 1;\\n                st.clear();\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 0;\\n        set<int> st;\\n        for(int &it: rolls) {\\n            st.insert(it);\\n            if(st.size() == k) {\\n                ans += 1;\\n                st.clear();\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375400,
                "title": "go-count-complete-ranges-containing-1-k",
                "content": "I wasted some time trying to find a verification in O(n) to combine with binary search before realising that it\\'s a dead end.\\n\\nThe idea is to find ranges within the list of numbers such that each range covers `[1, 2, ..., k]`. \\n\\nOnce two complete ranges are found, we can form any 2-number sequence.\\nWith three complete ranges, we can form any 3-number sequence, etc..\\n\\nFor example with\\n\\n```bash\\n[4,2,1,2,3,3,2,4,1]\\n```\\n\\nThere are two such ranges (s for start, e for end):\\n\\n```bash\\n s       e s     e  \\n[4,2,1,2,3,3,2,4,1]\\n```\\n\\nThe result in the above example is 3, because any 2-sequence can be formed by combining numbers from the two ranges.\\n\\nI use a `bit` and `[]byte` below instead of `bool` and `[]bool` because I don\\'t feel like the `true` `false` semantics make sense.\\nIt\\'s not like the value is seen then unseen - it\\'s just an auxiliary data structure to track progress. YMMV.\\n\\nI also tried a proper uint64 bitmap but there was no noticable change in perf. Leetcode\\'s execution environment seems to be very unreliable at the moment.\\n\\n```go\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tseen := make([]byte, k+1)\\n\\tresult := 1\\n\\tvar bit byte = 1\\n\\tvar count int\\n\\tfor _, x := range rolls {\\n\\t\\tif seen[x]&1 == bit {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tseen[x] ^= 1\\n\\t\\tcount++\\n\\t\\tif count == k {\\n\\t\\t\\tresult++\\n\\t\\t\\tbit ^= 1\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```bash\\n[4,2,1,2,3,3,2,4,1]\\n```\n```bash\\n s       e s     e  \\n[4,2,1,2,3,3,2,4,1]\\n```\n```go\\nfunc shortestSequence(rolls []int, k int) int {\\n\\tseen := make([]byte, k+1)\\n\\tresult := 1\\n\\tvar bit byte = 1\\n\\tvar count int\\n\\tfor _, x := range rolls {\\n\\t\\tif seen[x]&1 == bit {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tseen[x] ^= 1\\n\\t\\tcount++\\n\\t\\tif count == k {\\n\\t\\t\\tresult++\\n\\t\\t\\tbit ^= 1\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354840,
                "title": "java-o-n-tricky-solution",
                "content": "\\n\\n\\n\\n\\n# To make all combinations of length len of k numbers we need to have numbers 1-k atleast appearing len times in the array :\\n**Example**:\\nfor k = 3 len = 2\\nAll possible sequences :\\n=> 1 1, 1 2, 1 3, 2 1, 2 2, 2 3, 3 1, 3 2, 3 3\\n to create all those possibilities of arrangements we need to have 1,2,3,1,2,3 in the array as a subsequence (single 1-k group of numbers can be in any order i.e, we can also have 3,2,1,3,2,1 or 2,3,1,1,3,2 etc.) which is numbers from 1-k must be appearing len times in the array as a subsequence.\\n\\n```\\nclass Solution {\\n   public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n*P.S. : I couldn\\'t solve this in first attempt then I saw discuss and after reading some solutions and comment I  became able to solve this*\\n**Credit to : @lee215 *and* @x21svge**\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int shortestSequence(int[] A, int k) {\\n        int res = 1;\\n        Set<Integer> s = new HashSet<>();\\n        for (int a : A) {\\n            s.add(a);\\n            if (s.size() == k) {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354811,
                "title": "scala-mutable",
                "content": "```scala\\ndef shortestSequence(rolls: Array[Int], k: Int): Int = {\\n  val set = scala.collection.mutable.Set.empty[Int]\\n  var times = 0\\n  rolls.foreach { i =>\\n    set.add(i)\\n    if(set.size == k) {\\n      times += 1\\n      set.clear()\\n    }\\n  }\\n  times + 1\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef shortestSequence(rolls: Array[Int], k: Int): Int = {\\n  val set = scala.collection.mutable.Set.empty[Int]\\n  var times = 0\\n  rolls.foreach { i =>\\n    set.add(i)\\n    if(set.size == k) {\\n      times += 1\\n      set.clear()\\n    }\\n  }\\n  times + 1\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2354198,
                "title": "java-python-greedy-set-explained",
                "content": "If the longest possible length is n, rolls can depart into n parts and each part contains element of 1 to k.\\n\\nJava: \\n\\n```java\\npublic int shortestSequence(int[] rolls, int k) {\\n\\tboolean[] arr=new boolean[k+1];\\n\\tint count = 0;\\n\\tint n=0;\\n\\tfor(int i:rolls){\\n\\t\\tif(!arr[i]){\\n\\t\\t\\tarr[i] = true;\\n\\t\\t\\tcount++;\\n\\t\\t\\tif(count==k){\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t\\tarr = new boolean[k+1];\\n\\t\\t\\t\\tcount=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n+1;\\n}\\n```\\n\\nPython3: \\n\\n```py\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        max = 0\\n        for i in rolls:\\n            s.add(i)\\n            if(len(s)==k):\\n                max += 1\\n                s.clear()\\n        return max+1\\n```\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CgojFnFSV0g\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```java\\npublic int shortestSequence(int[] rolls, int k) {\\n\\tboolean[] arr=new boolean[k+1];\\n\\tint count = 0;\\n\\tint n=0;\\n\\tfor(int i:rolls){\\n\\t\\tif(!arr[i]){\\n\\t\\t\\tarr[i] = true;\\n\\t\\t\\tcount++;\\n\\t\\t\\tif(count==k){\\n\\t\\t\\t\\tn++;\\n\\t\\t\\t\\tarr = new boolean[k+1];\\n\\t\\t\\t\\tcount=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn n+1;\\n}\\n```\n```py\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        s = set()\\n        max = 0\\n        for i in rolls:\\n            s.add(i)\\n            if(len(s)==k):\\n                max += 1\\n                s.clear()\\n        return max+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340069,
                "title": "java-easy-and-short-intuitive-faster-than-80",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for(int i = 0; i < rolls.length; i++){\\n            set.add(rolls[i]);\\n            if(set.size() == k){\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        return res + 1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        int res = 0;\\n        for(int i = 0; i < rolls.length; i++){\\n            set.add(rolls[i]);\\n            if(set.size() == k){\\n                res++;\\n                set.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2337666,
                "title": "c-o-n-logical-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/e4a307f6-fa21-4ef3-a9e6-b78ca0a0af2b_1658857748.8650644.jpeg)\\n\\nLOGIC:\\nFirst, I found the number which had the last occurrence in rolls means the first point where all the elements are visited for once,\\nso by this, I conclude, that the sequence of length 1 is always possible,\\nThen I continue doing this and continue to increase my and, as I found the all number from 1 - K\\nAT last, I return The ANS,\\n\\nSummary :\\nTo make all combinations of length len of k numbers we need to have numbers 1-k atleast appearing len times in the array :\\nExample : for k = 3 len = 2\\nAll possible sequences :\\n=> 1 1, 1 2, 1 3, 2 1, 2 2, 2 3, 3 1, 3 2, 3 3\\nto create all those possibilities of arrangements we need to have 1,2,3,1,2,3 in the array as a subsequence (single 1-k group of numbers can be in any order i.e, we\\ncan also have 3,2,1,3,2,1 or 2,3,1,1,3,2 etc.)\\nwhich is numbers from 1-k must be appearing len times in the array as a subsequence.\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n       int i=0;\\n       int n=rolls.size();\\n        \\n       int ans=1;\\n        \\n       while(i<n)\\n       {\\n           vector<bool>hash(k+1,false);\\n           \\n           int count=0;\\n           \\n           while(i<n && count<k)\\n           {\\n               if(!hash[rolls[i]])\\n               {\\n                   count++;\\n                   hash[rolls[i]]=true;\\n               }\\n               i++;\\n           }\\n           \\n           if(count==k)\\n               ans++;\\n           \\n       }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n       int i=0;\\n       int n=rolls.size();\\n        \\n       int ans=1;\\n        \\n       while(i<n)\\n       {\\n           vector<bool>hash(k+1,false);\\n           \\n           int count=0;\\n           \\n           while(i<n && count<k)\\n           {\\n               if(!hash[rolls[i]])\\n               {\\n                   count++;\\n                   hash[rolls[i]]=true;\\n               }\\n               i++;\\n           }\\n           \\n           if(count==k)\\n               ans++;\\n           \\n       }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336913,
                "title": "expalined-one-pass-o-k-space",
                "content": "**Approach**: we know that we have to check least no of subsequence not possible at a point\\nEx if smallest subsequence is of size 1 means there is  1no no missing from 1 to k in subsequence\\nif smallest subsequences is of size 2 means we have to file (1to k)&(not 1-k)we have 1to k elements 1st time but not  1 to k element for second time\\nif smallest subsequences is of size 3 means we have to file (1to k)&(1tok)&(not 1-k) we have 1to k elements 1st time but not  1 to k element for second time but not 3time\\n```\\n int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int ans=0;\\n        for(auto i:rolls){\\n        s.insert(i);\\n        if(s.size()==k){\\n            ans++;\\n        s.clear();\\n        }\\n        }\\n        return ans+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_set<int> s;\\n        int ans=0;\\n        for(auto i:rolls){\\n        s.insert(i);\\n        if(s.size()==k){\\n            ans++;\\n        s.clear();\\n        }\\n        }\\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334437,
                "title": "simple-c-aproach",
                "content": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len=1;\\n        set<int>s;\\n        for(int i=0;i<rolls.size();i++){\\n            s.insert(rolls[i]);\\n\\t\\t\\t// a set is mainted to find the position of occrance of all elements for ith time\\n                if(s.size()==k){\\n                    len++;\\n                    s.clear();\\n                }\\n        }\\n        return len;\\n    }\\n};\\n\\n/*what you want is to form each and every subsequence of of len k \\nconsider [1,2,3,2,1,3] Here after each number has apeared once, now  for subsequence of len 2 we begin pairing for ie [1,2],[1,3],[2,1],[2,3],[3,1][3,2] etc Now considering that each number already has appeared once(cause this is second occurance) all such pairing are possible. Thus what we are supposed to return is the ith time where all occurances of from 1-k do not exist*/\\n",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int len=1;\\n        set<int>s;\\n        for(int i=0;i<rolls.size();i++){\\n            s.insert(rolls[i]);\\n\\t\\t\\t// a set is mainted to find the position of occrance of all elements for ith time\\n                if(s.size()==k){\\n                    len++;\\n                    s.clear();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2331984,
                "title": "simple-solution-c",
                "content": "This is not hard types of problem if you can understand.\\nJust follow the code once/twice or more.\\nDry run and simulate,\\nthen you can understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 1;\\n        bool vis[k+1];\\n        memset(vis, false, sizeof(vis));\\n        int cnt = 0;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            if(vis[rolls[i]] == false)\\n            {\\n                cnt++;\\n                if(cnt == k)\\n                {\\n                    memset(vis, false, sizeof(vis));\\n                    cnt = 0;\\n                    ans++;\\n                }\\n                else vis[rolls[i]] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 1;\\n        bool vis[k+1];\\n        memset(vis, false, sizeof(vis));\\n        int cnt = 0;\\n        for(int i=0;i<rolls.size();i++)\\n        {\\n            if(vis[rolls[i]] == false)\\n            {\\n                cnt++;\\n                if(cnt == k)\\n                {\\n                    memset(vis, false, sizeof(vis));\\n                    cnt = 0;\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2331906,
                "title": "python-faster-than-100-o-n-time-o-k-space",
                "content": "class Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        \\n\\t\\t#cur is a hashset that stores the unique numbers till now\\n        cur = set()\\n\\t\\t\\n        count = 0\\n        \\n\\t\\ti = len(rolls)-1\\n\\t\\t#Start traversing from the end of array\\n        while i>=0:\\n\\t\\t\\n\\t\\t\\t#if we encounter a new number, add it to hashset\\n            if rolls[i] not in cur:\\n                cur.add(rolls[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t#if there are k unique numbers in hashset, we update count, and reset our hashset\\n            if len(cur) == k:\\n                cur = set()\\n                count+=1\\n                \\n            i-=1\\n            \\n\\t\\t#current count is the maximum POSSIBLE sequence of rolls, so count+1 is the smallest IMPOSSIBLE sequence of rolls\\n        return count+1",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "class Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        \\n\\t\\t#cur is a hashset that stores the unique numbers till now\\n        cur = set()\\n\\t\\t\\n        count = 0\\n        \\n\\t\\ti = len(rolls)-1\\n\\t\\t#Start traversing from the end of array\\n        while i>=0:\\n\\t\\t\\n\\t\\t\\t#if we encounter a new number, add it to hashset\\n            if rolls[i] not in cur:\\n                cur.add(rolls[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t#if there are k unique numbers in hashset, we update count, and reset our hashset\\n            if len(cur) == k:\\n                cur = set()\\n                count+=1\\n                \\n            i-=1\\n            \\n\\t\\t#current count is the maximum POSSIBLE sequence of rolls, so count+1 is the smallest IMPOSSIBLE sequence of rolls\\n        return count+1",
                "codeTag": "Java"
            },
            {
                "id": 2331280,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int n=rolls.size(),res=1;\\n        unordered_set<int>s;\\n        for(auto &x:rolls)\\n        {\\n            s.insert(x);\\n            if(s.size()==k)\\n            {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        int n=rolls.size(),res=1;\\n        unordered_set<int>s;\\n        for(auto &x:rolls)\\n        {\\n            s.insert(x);\\n            if(s.size()==k)\\n            {\\n                res++;\\n                s.clear();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330986,
                "title": "python-o-n-time-and-o-k-space",
                "content": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans, lastv = 1, set()\\n        for v in rolls:\\n            lastv.add(v)\\n            if len(lastv) == k:\\n                lastv = set()\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        ans, lastv = 1, set()\\n        for v in rolls:\\n            lastv.add(v)\\n            if len(lastv) == k:\\n                lastv = set()\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329002,
                "title": "c-easy-to-understand-beats-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n        Solution(){\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n  bool isPossible(vector<int> &v,int size,int &k){\\n        \\n       int count=0;\\n       unordered_set<int> st;\\n       for(auto i:v) {\\n           st.insert(i);\\n           if(st.size()==k){\\n               count++;\\n               st.clear();\\n           }\\n       }\\n      \\n      return count>=size;\\n    }\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n    \\n        \\n        int l=0,h=rolls.size();\\n        while(l<=h){\\n            \\n            int mid=l+(h-l)/2;\\n            if(isPossible(rolls,mid,k)) l=mid+1;\\n            else h=mid-1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        Solution(){\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n    }\\n  bool isPossible(vector<int> &v,int size,int &k){\\n        \\n       int count=0;\\n       unordered_set<int> st;\\n       for(auto i:v) {\\n           st.insert(i);\\n           if(st.size()==k){\\n               count++;\\n               st.clear();\\n           }\\n       }\\n      \\n      return count>=size;\\n    }\\n    \\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n    \\n        \\n        int l=0,h=rolls.size();\\n        while(l<=h){\\n            \\n            int mid=l+(h-l)/2;\\n            if(isPossible(rolls,mid,k)) l=mid+1;\\n            else h=mid-1;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2328850,
                "title": "scala-concise-functional-solution",
                "content": "```\\n  def shortestSequence(rolls: Array[Int], k: Int): Int =\\n    rolls.foldLeft(1, Set.empty[Int]) { \\n      case ((shortest, seen), n) =>\\n        if ((seen + n).size == k) (shortest + 1, Set.empty)\\n        else (shortest, seen + n)\\n      }._1\\n```",
                "solutionTags": [],
                "code": "```\\n  def shortestSequence(rolls: Array[Int], k: Int): Int =\\n    rolls.foldLeft(1, Set.empty[Int]) { \\n      case ((shortest, seen), n) =>\\n        if ((seen + n).size == k) (shortest + 1, Set.empty)\\n        else (shortest, seen + n)\\n      }._1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2328811,
                "title": "c-o-n-dp-solution",
                "content": "Please do upvote if found useful\\n\\'\\'\\'\\n\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int n=rolls.size();\\n        \\n        set<pair<int,int>>dp; //set stores the value as {min_len of sequnece ending at x,x}\\n        unordered_map<int,int>mp;  //map stores value as {x, min_possible length of sequence ending at x}\\n        for(int i=1;i<=k;++i){\\n            dp.insert({0,i});\\n            mp[i] = 0;\\n        }\\n        \\n        //dp[i] states the minimum possible length of the sequence ending at rolls[i]th value.\\n        for(int i=0;i<n;++i){\\n            st.insert(rolls[i]);\\n            if(st.size() == k){\\n                auto it = dp.begin();\\n                int val = it->first;\\n                int old = mp[rolls[i]];\\n                dp.erase({old,rolls[i]});\\n                dp.insert({1+val,rolls[i]});\\n                mp[rolls[i]] = val + 1;\\n            }else{\\n                mp[rolls[i]] = 1;\\n                dp.erase({0,rolls[i]});\\n                dp.insert({1,rolls[i]});\\n            }\\n        }\\n        \\n        auto it = dp.begin();\\n        return it->first + 1; //Returns the length of the first impossible length of sequence\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Please do upvote if found useful\\n\\'\\'\\'\\n\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int>st;\\n        int n=rolls.size();\\n        \\n        set<pair<int,int>>dp; //set stores the value as {min_len of sequnece ending at x,x}\\n        unordered_map<int,int>mp;  //map stores value as {x, min_possible length of sequence ending at x}\\n        for(int i=1;i<=k;++i){\\n            dp.insert({0,i});\\n            mp[i] = 0;\\n        }\\n        \\n        //dp[i] states the minimum possible length of the sequence ending at rolls[i]th value.\\n        for(int i=0;i<n;++i){\\n            st.insert(rolls[i]);\\n            if(st.size() == k){\\n                auto it = dp.begin();\\n                int val = it->first;\\n                int old = mp[rolls[i]];\\n                dp.erase({old,rolls[i]});\\n                dp.insert({1+val,rolls[i]});\\n                mp[rolls[i]] = val + 1;\\n            }else{\\n                mp[rolls[i]] = 1;\\n                dp.erase({0,rolls[i]});\\n                dp.insert({1,rolls[i]});\\n            }\\n        }\\n        \\n        auto it = dp.begin();\\n        return it->first + 1; //Returns the length of the first impossible length of sequence\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2328719,
                "title": "c-shortest-subarrays-with-all-dices",
                "content": "The given `rolls` can be represented as cinsequent subarrays of minimum length each of them contains all possible dice outcomes, and some rest subrray. For intance for `k = 4` and `rolls = 1232444311243` we have\\n\\n```\\n12324443112431134\\n^   ^^    ^^    ^\\n  1st  2nd  rest (doesn\\'t have 2)\\n```\\n\\nTo build the example sequence that\\'s not it `rools` we should take the *last* item of each subarray of all possible outcomes and add the value which is not in the `rest`, our case is **422**\\n\\n```\\n12324443112431134\\n^   ^^    ^^    ^\\n 1st|  2nd| rest (doesn\\'t have 2)\\n    4     2    2 (since rest doesn\\'t have 2)\\n```\\n\\nSo far so good, the *length* of sequence is the number of subarray of minimum length each of which contains all possible dice outcomes + 1.\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    public int ShortestSequence(int[] rolls, int k) {\\n        HashSet<int> hs = new();\\n        \\n        int result = 1;\\n        \\n        foreach (int item in rolls)\\n            if (hs.Add(item) && hs.Count == k) {\\n                result += 1;\\n                    \\n                hs.Clear();\\n            } \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n12324443112431134\\n^   ^^    ^^    ^\\n  1st  2nd  rest (doesn\\'t have 2)\\n```\n```\\n12324443112431134\\n^   ^^    ^^    ^\\n 1st|  2nd| rest (doesn\\'t have 2)\\n    4     2    2 (since rest doesn\\'t have 2)\\n```\n```\\npublic class Solution {\\n    public int ShortestSequence(int[] rolls, int k) {\\n        HashSet<int> hs = new();\\n        \\n        int result = 1;\\n        \\n        foreach (int item in rolls)\\n            if (hs.Add(item) && hs.Count == k) {\\n                result += 1;\\n                    \\n                hs.Clear();\\n            } \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328479,
                "title": "dp-o-nlogn-solution",
                "content": "Let \"SLIS\" = \"shortest length of impossible subsequence\"\\nLet dp[i] = SLIS starting from i\\nThen dp[i] will be one of these:\\n- **2** (if there\\'s a value in 1,2,...k that isnt in A[i+1 : k], bcuz then we can take it and the sequence instantly becomes impossible)\\n- or **min(dp[first index of x after i] for x = 1,2,...,k and x is in A[i+1 : n-1])** if otherwise\\n\\nthe min part of the formula can be rewritten as such:\\n**min(dp[j] for j = i+1,i+2,...,n-1 and A[j] isnt inside A[i+1 : j-1])**\\nexplanation for why the \"isnt inside\" is needed:\\nsay you have an array looks like this: **[..., A[i] , ... , 4, 1, 4, 2]**, say the first **4** has index j1, and the second **4** has index j2\\nto calculate dp[i] based on those two **4**\\'s, we will only want to look at the first **4** (aka dp[j1]). SLIS from the second **4** will be 2 (the subseq could be [4, 1] for example), while that\\'s not true for the first **4**. so we only care about dp[j1], it\\'s more trustworthy than dp[j2]\\n\\nwith some sleight of hand with sets, we can tabulate the dp array in O(nlogn)\\n\\n```\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int shortestSequence(const vector<int>& A, const int& k) {\\n\\t\\tint n = A.size();\\n\\t\\t// dp[i] = shortest length of impossible sequence starting from i\\n        vector<int> dp(n,-1);\\n        dp[n-1] = 2;\\n\\n\\t\\t// elements that dp[i] can end (will be maintained to tabulate dp as i goes from n-2 to 0)\\n        unordered_set<int> curAvailable;\\n        for (int i = 1; i <= k; i++) curAvailable.insert(i);\\n\\t\\t// update for i = n-1\\n        curAvailable.erase(A[n-1]);\\n\\n\\t\\t// last seen idx of A[i] (as i goes from n-2 to 0)\\n        unordered_map<int,int> lastSeenIdx;\\n\\t\\t// update for i = n-1\\n        lastSeenIdx[A[n-1]] = n-1;\\n\\n        // this set stores pairs (dp[i], i) (will be maintained as i goes from n-2 to 1)\\n        set<pair<int,int>> dpSoFar;\\n\\t\\t// update for i=n-1\\n        dpSoFar.insert({dp.back(), n-1});\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n\\t\\t\\t// if dp[i] still have an number it can take\\n\\t\\t\\t// so that it instantly becomes an impossible sequence\\n            if (!curAvailable.empty()) dp[i] = 2;\\n\\t\\t\\t// apply the dp formula (dpSoFar.begin() will get the min value in O(1))\\n            else\\n                dp[i] = 1 + dpSoFar.begin()->first;\\n\\n            if (!lastSeenIdx.count(A[i])) {\\n                lastSeenIdx[A[i]] = i;\\n            }\\n            else {\\n\\t\\t\\t\\t// dp[lastSeenIdx[A[i]]] isn\\'t trustworthy anymore, delete it to make sure we wont meet it again\\n                dpSoFar.erase({dp[lastSeenIdx[A[i]]], lastSeenIdx[A[i]]});\\n                lastSeenIdx[A[i]] = i;\\n            }\\n\\n            dpSoFar.insert({dp[i], i});\\n            curAvailable.erase(A[i]);\\n        }\\n        \\n\\t\\t// if curAvailable isnt empty, it means a number of [1,2,...,k] isnt in array (since at each step in the loop, we erase A[i])\\n\\t\\t// meaning shortest impossible sequence is 1\\n        if (!curAvailable.empty())\\n            return 1;\\n\\n        vector<bool> seen(k+1);\\n        int res = 1e8;\\n        for (int i = 0; i < dp.size(); i++) {\\n\\t\\t\\t// only take values from A[i]\\'s that we first seen, since those that reappear later arent as trustworthy\\n            if (!seen[A[i]]) res = min(res, dp[i]);\\n            seen[A[i]] = true;\\n        }\\n        return res;\\n    }\\n};\\n```\\nFeel free to ask any questions",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int shortestSequence(const vector<int>& A, const int& k) {\\n\\t\\tint n = A.size();\\n\\t\\t// dp[i] = shortest length of impossible sequence starting from i\\n        vector<int> dp(n,-1);\\n        dp[n-1] = 2;\\n\\n\\t\\t// elements that dp[i] can end (will be maintained to tabulate dp as i goes from n-2 to 0)\\n        unordered_set<int> curAvailable;\\n        for (int i = 1; i <= k; i++) curAvailable.insert(i);\\n\\t\\t// update for i = n-1\\n        curAvailable.erase(A[n-1]);\\n\\n\\t\\t// last seen idx of A[i] (as i goes from n-2 to 0)\\n        unordered_map<int,int> lastSeenIdx;\\n\\t\\t// update for i = n-1\\n        lastSeenIdx[A[n-1]] = n-1;\\n\\n        // this set stores pairs (dp[i], i) (will be maintained as i goes from n-2 to 1)\\n        set<pair<int,int>> dpSoFar;\\n\\t\\t// update for i=n-1\\n        dpSoFar.insert({dp.back(), n-1});\\n        \\n        for (int i = n-2; i >= 0; i--) {\\n\\t\\t\\t// if dp[i] still have an number it can take\\n\\t\\t\\t// so that it instantly becomes an impossible sequence\\n            if (!curAvailable.empty()) dp[i] = 2;\\n\\t\\t\\t// apply the dp formula (dpSoFar.begin() will get the min value in O(1))\\n            else\\n                dp[i] = 1 + dpSoFar.begin()->first;\\n\\n            if (!lastSeenIdx.count(A[i])) {\\n                lastSeenIdx[A[i]] = i;\\n            }\\n            else {\\n\\t\\t\\t\\t// dp[lastSeenIdx[A[i]]] isn\\'t trustworthy anymore, delete it to make sure we wont meet it again\\n                dpSoFar.erase({dp[lastSeenIdx[A[i]]], lastSeenIdx[A[i]]});\\n                lastSeenIdx[A[i]] = i;\\n            }\\n\\n            dpSoFar.insert({dp[i], i});\\n            curAvailable.erase(A[i]);\\n        }\\n        \\n\\t\\t// if curAvailable isnt empty, it means a number of [1,2,...,k] isnt in array (since at each step in the loop, we erase A[i])\\n\\t\\t// meaning shortest impossible sequence is 1\\n        if (!curAvailable.empty())\\n            return 1;\\n\\n        vector<bool> seen(k+1);\\n        int res = 1e8;\\n        for (int i = 0; i < dp.size(); i++) {\\n\\t\\t\\t// only take values from A[i]\\'s that we first seen, since those that reappear later arent as trustworthy\\n            if (!seen[A[i]]) res = min(res, dp[i]);\\n            seen[A[i]] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328351,
                "title": "java-one-pass",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        int res = 1;\\n        for(int i: rolls){\\n            set.add(i);\\n            if(set.size()==k){\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        int res = 1;\\n        for(int i: rolls){\\n            set.add(i);\\n            if(set.size()==k){\\n                res++;\\n                set.clear();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328309,
                "title": "c-soln",
                "content": "```\\nint len = 0, prev = 0, i=0;\\n        \\n        while(true){\\n            ++len;\\n            unordered_set<int>st;\\n            for(i=prev;i<rolls.size();i++){\\n                st.insert(rolls[i]);\\n                int flag = 0;\\n                if(st.size() == k){\\n                    flag = 1;\\n                }\\n                if(flag == 1){\\n                    prev = i+1;\\n                    break;\\n                }\\n            }\\n            \\n            if(i == rolls.size())\\n                break;\\n        }\\n        \\n        return len;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint len = 0, prev = 0, i=0;\\n        \\n        while(true){\\n            ++len;\\n            unordered_set<int>st;\\n            for(i=prev;i<rolls.size();i++){\\n                st.insert(rolls[i]);\\n                int flag = 0;\\n                if(st.size() == k){\\n                    flag = 1;\\n                }\\n                if(flag == 1){\\n                    prev = i+1;\\n                    break;\\n                }\\n            }\\n            \\n            if(i == rolls.size())\\n                break;\\n        }\\n        \\n        return len;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2328175,
                "title": "number-of-disjoint-sub-arrays-containing-all-k-values",
                "content": "Let\\nA = [4, 2, 1, 2, 3, 3, 2, 4, 1]\\nthere are exactly two disjoint subarrays which contains all possible value of dice(1, 2, ..., k), \\nA1 = A[0:4] = [4, 2, 1, 2, 3] \\nA2 = A[5:8] = [3, 2, 4, 1]\\nnow, it\\'s possible to roll any sequence of size 1(take any number from A1 or A2)\\nit\\'s also possible to roll any sequence of size 2(take any number from A1 and any number from A2)\\nWhat about a sequence of size 3?\\nit turns out, there\\'s always one (or several) sequence of size three that you can\\'t make.\\n\\n# Proof\\nEach of these disjoint array holds a key property that **atleast one element is present exactly one time**.\\nIn case of A1 there are 1 and 3.\\nIn case of A2, coincidently, all values occure exactly once.\\nhow can I build 1, 4, 4\\nI can\\'t since 4 occured exactly once in A2 and now it doesn\\'t has 4 anymore.\\n\\n```cpp\\nint shortestSequence(vector<int>& rolls, int k) {\\n  int ans = 1;\\n  unordered_set<int> s;\\n  for (int& roll : rolls) {\\n    s.insert(roll);\\n    if (s.size() == k) {\\n      ans++;\\n      s.clear();\\n    }\\n  }\\n  return ans;\\n}\\n```\\nTC: O(rolls.size())\\nSC: O(k)\\nPlease Upvote if this article helps\\uD83D\\uDE07\\uD83D\\uDE07",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```cpp\\nint shortestSequence(vector<int>& rolls, int k) {\\n  int ans = 1;\\n  unordered_set<int> s;\\n  for (int& roll : rolls) {\\n    s.insert(roll);\\n    if (s.size() == k) {\\n      ans++;\\n      s.clear();\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327844,
                "title": "set-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 1;\\n        unordered_set<int> st;\\n        for(auto it : rolls){\\n            st.insert(it);\\n            if(st.size() == k) ans++, st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 1;\\n        unordered_set<int> st;\\n        for(auto it : rolls){\\n            st.insert(it);\\n            if(st.size() == k) ans++, st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327709,
                "title": "rust-one-line-solution",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn shortest_sequence(rolls: Vec<i32>, k: i32) -> i32 {\\n        rolls.iter().fold((1,HashSet::new()), |mut acc, x| {\\n            acc.1.insert(x); \\n            if acc.1.len()==k as usize {(acc.0+1,HashSet::new())} else {acc}\\n        }).0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn shortest_sequence(rolls: Vec<i32>, k: i32) -> i32 {\\n        rolls.iter().fold((1,HashSet::new()), |mut acc, x| {\\n            acc.1.insert(x); \\n            if acc.1.len()==k as usize {(acc.0+1,HashSet::new())} else {acc}\\n        }).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327477,
                "title": "c-single-pass-math-solution-100-time-87ms-100-space-86-3mb",
                "content": "This is a tricky, stimulating one; the key to solve it, is to figure out how to verify if we can have any permutation broken; but a brute force-ish approach would be certainly doomed to fail, given the numbers in the constraints.\\n\\nA better alternative might be to spot if we have all the `1 - k` elements (in any order) grouped in clusters, even with repeated numbers in the middle.\\n\\nSo, for example, if our array looked like this, with `k == 4`:\\n\\n```cpp\\n{1, 4, 4, 3, 1, 2, 2, 3, 1, 1, 1, 4, 3, 2, 1, 2, 2, 4, 1, 2, 2, 1, 3}\\n```\\n\\nThen we would have a situation akin to:\\n```cpp\\n{*first cluster of 1-k*, *second cluster of 1-k*, *third cluster of 1-k*, 1, 2, 2, 1, 3 }\\n// first cluster:  1, 4, 4, 3, 1, 2 \\n// second cluster: 2, 3, 1, 1, 1, 4\\n// third cluster:  3, 2, 1, 2, 2, 4\\n```\\n\\nMeaning we can get every possible permutation up to `3` elements (`{1, 2, 3}`, `{4, 2, 1}`, `{2, 1, 3}`, etc.) by picking each element from each cluster once, but we woul be unable to get every possible permutation of `4` digits, since we do not have a full fourth cluster.\\n\\nNow, time to turn these thoughts into code and to make it run as efficiently as we can \\uD83D\\uDCAA !\\n\\nWe will start with a few support variables:\\n* `res` is our accumulator variable, starting with `1` (we know we will get at least an element in `rolls`, so we can start considering every non empty permutation of just `1` element);\\n* `counter` will be initially set to `1` (since we will work with an increased value of `k` from the next line onwards);\\n* `seen` is an array of booleans, with a size of `k + 1` elements - we will also permanently increase `k` by `1` now (hence the need to set and reset `counter` to `1` instead of `0`), in order to avoid a needless `+ 1` operation every time we have to set or reset `seen`, as down right after its declaration.\\n\\nWe will indeed set all the cells in `seen` to `false` and then start to iterate through each number `n` in `rolls` so that:\\n* if `n` was never part of the current cluster (`!seen[n]`), we will:\\n\\t* flag it is as used (`seen[n] = true`);\\n\\t* increase `counter` by `1`;\\n\\t\\t* if we are done completing a cluster (`counter == k`), we will then:\\n\\t\\t\\t* increase `res` by `1` (ie: we know that all the permutation until the previous value of `res` can be covered);\\n\\t\\t\\t* reset `counter` to be `1`;\\n\\t\\t\\t* reset `seen` to have all its cells turned to `false`.\\n\\nOnce done, we can just `return` `res` and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        int res = 1, counter = 1;\\n        bool seen[++k];\\n        fill(seen, seen + k, false);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (!seen[n]) {\\n                seen[n] = true;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    fill(seen, seen + k, false);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we do better?\\n\\nWell, the most expensive operation is to reset our boolean array `seen`; and we can get a good boost in performance using the builtin `memset` for that:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        bool seen[++k];\\n        int res = 1, counter = 1, fillSize = k * sizeof(bool);\\n        memset(seen, 0, fillSize);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (!seen[n]) {\\n                seen[n] = true;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    memset(seen, 0, fillSize);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI also tried to avoid the `!` bit in the first check of the `for` loop, swapping `seen` to `unused` and its inherent boolean flags from `false` to `true` and the other way around, but I got no meaningful improvement in time (if anything now, it seems to go a bit slower):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        bool unused[++k];\\n        int res = 1, counter = 1, fillSize = k * sizeof(bool);\\n        memset(unused, true, fillSize);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (unused[n]) {\\n                unused[n] = false;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    memset(unused, true, fillSize);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\n{1, 4, 4, 3, 1, 2, 2, 3, 1, 1, 1, 4, 3, 2, 1, 2, 2, 4, 1, 2, 2, 1, 3}\\n```\n```cpp\\n{*first cluster of 1-k*, *second cluster of 1-k*, *third cluster of 1-k*, 1, 2, 2, 1, 3 }\\n// first cluster:  1, 4, 4, 3, 1, 2 \\n// second cluster: 2, 3, 1, 1, 1, 4\\n// third cluster:  3, 2, 1, 2, 2, 4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        int res = 1, counter = 1;\\n        bool seen[++k];\\n        fill(seen, seen + k, false);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (!seen[n]) {\\n                seen[n] = true;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    fill(seen, seen + k, false);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        bool seen[++k];\\n        int res = 1, counter = 1, fillSize = k * sizeof(bool);\\n        memset(seen, 0, fillSize);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (!seen[n]) {\\n                seen[n] = true;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    memset(seen, 0, fillSize);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k) {\\n        // support variables\\n        bool unused[++k];\\n        int res = 1, counter = 1, fillSize = k * sizeof(bool);\\n        memset(unused, true, fillSize);\\n        for (int n: rolls) {\\n            // considering only first appearances in this iteration\\n            if (unused[n]) {\\n                unused[n] = false;\\n                counter++;\\n                // iteration complete\\n                if (counter == k) {\\n                    res++;\\n                    counter = 1;\\n                    memset(unused, true, fillSize);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326998,
                "title": "explanation-c-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> elements;\\n        \\n        //for dice of k side and rolling it for n times \\n        //total number of possible outcome of length n is k^n \\n        //if all of it can be derived from subsequence in rolls then \\n        //rolls should contain set of 1 to k n times in rolls\\n        //eg, k=4, n=2 then rolls should contain \\n        // (1,2,3,4) |( 1 2, 3, 4) i.e 2 times inside these set number can be in shuffle order\\n        int count=0;\\n        for(int i=0;i<rolls.size();i++){\\n            elements.insert(rolls[i]);\\n            if(elements.size()==k){\\n                elements.clear();\\n                count++;\\n            }\\n            \\n        }\\n        \\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> elements;\\n        \\n        //for dice of k side and rolling it for n times \\n        //total number of possible outcome of length n is k^n \\n        //if all of it can be derived from subsequence in rolls then \\n        //rolls should contain set of 1 to k n times in rolls\\n        //eg, k=4, n=2 then rolls should contain \\n        // (1,2,3,4) |( 1 2, 3, 4) i.e 2 times inside these set number can be in shuffle order\\n        int count=0;\\n        for(int i=0;i<rolls.size();i++){\\n            elements.insert(rolls[i]);\\n            if(elements.size()==k){\\n                elements.clear();\\n                count++;\\n            }\\n            \\n        }\\n        \\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326825,
                "title": "c-simplest-solution-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> s;\\n        int count=1;\\n        for(int i=0;i<rolls.size();i++){\\n            \\n            s.insert(rolls[i]);\\n            \\n            if(s.size()==k){\\n                count++;\\n                s.clear();\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        set<int> s;\\n        int count=1;\\n        for(int i=0;i<rolls.size();i++){\\n            \\n            s.insert(rolls[i]);\\n            \\n            if(s.size()==k){\\n                count++;\\n                s.clear();\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326769,
                "title": "java-one-pass",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        return max(rolls,k)+1;\\n    }\\n    \\n    int max(int [] arr,int k){\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        int count = 0;\\n        while(i<arr.length){\\n            if(set.size()==k){\\n                count++;\\n                set.clear();\\n            }\\n            set.add(arr[i]);\\n            i++;\\n        }\\n        if(set.size()==k){\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        return max(rolls,k)+1;\\n    }\\n    \\n    int max(int [] arr,int k){\\n        Set<Integer> set = new HashSet<>();\\n        int i = 0;\\n        int count = 0;\\n        while(i<arr.length){\\n            if(set.size()==k){\\n                count++;\\n                set.clear();\\n            }\\n            set.add(arr[i]);\\n            i++;\\n        }\\n        if(set.size()==k){\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326743,
                "title": "simple-python-solution-with-full-explanation-referenced-explanation-from-codeanzh",
                "content": "Approach\\n\\nThe idea is if you\\'re given that you can create a L length array of all permutation of k numbers, with atleast M length of given array used from the begining, then if you do not find all the k numbers after this m length then L + 1 length can not be created.\\n\\nLet me elaborate\\nThink of it a bit recurcively, In a Dynamic Programing manner but not exactly DP, rather greedily.\\n\\nYou\\'ve the array rolls, and a number k, which is the number of dice outcome that each roll can consist of, Now if you want to check if you can create all permutation of L length of K numbers, this is, you can create every possible permutation of k numbers with length L for that consider if you know that you can create L - 1 length of permutation with at least m length of the given array that is, it requires at least m length of the given array to create all permutaion of L - 1 length, then to check if you can create a L length array or not is by checking if you can get all the k numbers after m index, in the array so that you can put every number in the L - 1 length permutation to make a L length permutation with every posibility.\\n\\nExample\\n\\nrolls = [4,2,1,2,3,3,2,4,1], k = 4\\n\\nNow if I tell you that you can create 1 length permutaion by at least using 5 length of given array, then to check if we can create a 2 length array or not, we have to check if there exist all the 4 numbers in the array or not after 5 length, and in our case there exist all the 4 numbers after 5 ;ength this is in between 6 to 9 length, therefore we can create all the 2 length array, but as it requires atleast 9 length of our given array to make 2 length permutaion, you can not create all the 3 length permutaion as there are not all the numbers to insert after every 2 length permutaion.\\n\\nImplementation\\n\\nInitially consider you can make (len = 1) length permutation subsequence array with starting of the given array.\\nTo hold the above statement true there should be all k numbers to the right.\\nMake an empty set (data) of numbers.\\nIterate untill you make the size of the set equals k this is, you find all the k numbers.\\nThere can be two case\\nIf you don\\'t find all the k numbers after iterating all the numbers this means this length permutation can not be created, therefore this is the answer else.\\nIf you find all the k numbers before completing the whole iteration, then the current length permutation is fixed that you can create all the permutation of given length, therefore you should make your set empty and increment length by one (len = len + 1) and continue iterating the array with above conditions for incremented length.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(k) for the set of size k.\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls, k: int) -> int:\\n        s = set()\\n        ans = 0\\n        for roll in rolls:\\n            s.add(roll)\\n            if(len(s)==k):\\n                ans+=1\\n                s.clear()\\n        return ans+1",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "Approach\\n\\nThe idea is if you\\'re given that you can create a L length array of all permutation of k numbers, with atleast M length of given array used from the begining, then if you do not find all the k numbers after this m length then L + 1 length can not be created.\\n\\nLet me elaborate\\nThink of it a bit recurcively, In a Dynamic Programing manner but not exactly DP, rather greedily.\\n\\nYou\\'ve the array rolls, and a number k, which is the number of dice outcome that each roll can consist of, Now if you want to check if you can create all permutation of L length of K numbers, this is, you can create every possible permutation of k numbers with length L for that consider if you know that you can create L - 1 length of permutation with at least m length of the given array that is, it requires at least m length of the given array to create all permutaion of L - 1 length, then to check if you can create a L length array or not is by checking if you can get all the k numbers after m index, in the array so that you can put every number in the L - 1 length permutation to make a L length permutation with every posibility.\\n\\nExample\\n\\nrolls = [4,2,1,2,3,3,2,4,1], k = 4\\n\\nNow if I tell you that you can create 1 length permutaion by at least using 5 length of given array, then to check if we can create a 2 length array or not, we have to check if there exist all the 4 numbers in the array or not after 5 length, and in our case there exist all the 4 numbers after 5 ;ength this is in between 6 to 9 length, therefore we can create all the 2 length array, but as it requires atleast 9 length of our given array to make 2 length permutaion, you can not create all the 3 length permutaion as there are not all the numbers to insert after every 2 length permutaion.\\n\\nImplementation\\n\\nInitially consider you can make (len = 1) length permutation subsequence array with starting of the given array.\\nTo hold the above statement true there should be all k numbers to the right.\\nMake an empty set (data) of numbers.\\nIterate untill you make the size of the set equals k this is, you find all the k numbers.\\nThere can be two case\\nIf you don\\'t find all the k numbers after iterating all the numbers this means this length permutation can not be created, therefore this is the answer else.\\nIf you find all the k numbers before completing the whole iteration, then the current length permutation is fixed that you can create all the permutation of given length, therefore you should make your set empty and increment length by one (len = len + 1) and continue iterating the array with above conditions for incremented length.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(k) for the set of size k.\\n```\\nclass Solution:\\n    def shortestSequence(self, rolls, k: int) -> int:\\n        s = set()\\n        ans = 0\\n        for roll in rolls:\\n            s.add(roll)\\n            if(len(s)==k):\\n                ans+=1\\n                s.clear()\\n        return ans+1",
                "codeTag": "Java"
            },
            {
                "id": 2326573,
                "title": "fastest-java-solution",
                "content": "```\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        \\n        int cnt=0;\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<rolls.length;i++)\\n        {\\n            hs.add(rolls[i]);\\n            if(hs.size()==k)\\n            {\\n                cnt++;\\n                hs.clear();\\n            }\\n        }\\n        \\n        return cnt+1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        \\n        int cnt=0;\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<rolls.length;i++)\\n        {\\n            hs.add(rolls[i]);\\n            if(hs.size()==k)\\n            {\\n                cnt++;\\n                hs.clear();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2326510,
                "title": "c-fastest-solution-100-memory-and-space",
                "content": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int curr=1;\\n        int comp=0;\\n        int n=rolls.size();\\n       vector<int> vec(k+1,0);\\n        \\n        for(auto x: rolls){\\n            if(vec[x]<curr){\\n                vec[x]++;\\n                comp++;\\n            }\\n            if(comp==k){\\n                comp=0;\\n                curr++;\\n            }\\n        }\\n        return curr;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int curr=1;\\n        int comp=0;\\n        int n=rolls.size();\\n       vector<int> vec(k+1,0);\\n        \\n        for(auto x: rolls){\\n            if(vec[x]<curr){\\n                vec[x]++;\\n                comp++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2326224,
                "title": "c-when-all-k-numbers-are-found",
                "content": "* Reference-> [@votrubac](https://leetcode.com/problems/shortest-impossible-sequence-of-rolls/discuss/2322321/Count-Subarrays-with-All-Dice)\\n\\n* Say k = 4 , when all numbers from 1  to k are found in set `allK` once , then we can form all subseq of `size == 1`  \\n* `[1,2,3,4] -> [1] , [2] , [3] , [4]`\\n\\n* when all numbers from 1 to k are found in set `allK` twice, then we can form all subseq of `size == 2`\\n* `[1,2,3,4] 1time` and `[1,2,3,4] 2nd time`   - > choose any two elements from `1,2,3,4,1,2,3,4` , we will alwaays get all the subseq of size == 2 \\n\\n* similarly we keep checking how many times we can find all numbers K. Let that be ans. Then for `ans + 1` it is impossible to form all subseq.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 0 ;\\n        set<int> allK ;\\n        for(auto &x : rolls){\\n            allK.insert(x) ;\\n            if(allK.size() == k) allK.clear() , ++ans ;\\n        }\\n        return ans + 1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        int ans = 0 ;\\n        set<int> allK ;\\n        for(auto &x : rolls){\\n            allK.insert(x) ;\\n            if(allK.size() == k) allK.clear() , ++ans ;\\n        }\\n        return ans + 1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326145,
                "title": "go-fastest-93-5",
                "content": "```\\n// As there is no library for set in GO. We define our self.\\nvar exists = struct{}{}\\n\\ntype set struct {\\n    m map[int]struct{}\\n}\\n\\nfunc NewSet() *set {\\n    s := &set{}\\n    s.m = make(map[int]struct{})\\n    return s\\n}\\n\\nfunc (s *set) Add(value int) {\\n    s.m[value] = exists\\n}\\n\\nfunc (s *set) clear() {\\n    s.m = make(map[int]struct{})\\n}\\n\\nfunc length(s *set) int {\\n    return len(s.m)\\n}\\n// This methods donesn\\'t required here.....\\n// func (s *set) Remove(value string) {\\n//     delete(s.m, value)\\n// }\\n\\n// func (s *set) Contains(value string) bool {\\n//     _, c := s.m[value]\\n//     return c\\n// }\\n\\nfunc shortestSequence(rolls []int, k int) int {\\n    // to make arbitray length-m sequence, every elm from 1 to k must appear m times\\n    // like if m=2 [{1,2,3,4},{4,1,3,2}] it have all length-2 seq.\\n    res := 1\\n    s := NewSet()\\n    for _,a := range rolls{\\n        s.Add(a)\\n        if length(s) == k{\\n            res += 1\\n            s.clear()\\n        }\\n    }\\n        return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Ordered Set"
                ],
                "code": "```\\n// As there is no library for set in GO. We define our self.\\nvar exists = struct{}{}\\n\\ntype set struct {\\n    m map[int]struct{}\\n}\\n\\nfunc NewSet() *set {\\n    s := &set{}\\n    s.m = make(map[int]struct{})\\n    return s\\n}\\n\\nfunc (s *set) Add(value int) {\\n    s.m[value] = exists\\n}\\n\\nfunc (s *set) clear() {\\n    s.m = make(map[int]struct{})\\n}\\n\\nfunc length(s *set) int {\\n    return len(s.m)\\n}\\n// This methods donesn\\'t required here.....\\n// func (s *set) Remove(value string) {\\n//     delete(s.m, value)\\n// }\\n\\n// func (s *set) Contains(value string) bool {\\n//     _, c := s.m[value]\\n//     return c\\n// }\\n\\nfunc shortestSequence(rolls []int, k int) int {\\n    // to make arbitray length-m sequence, every elm from 1 to k must appear m times\\n    // like if m=2 [{1,2,3,4},{4,1,3,2}] it have all length-2 seq.\\n    res := 1\\n    s := NewSet()\\n    for _,a := range rolls{\\n        s.Add(a)\\n        if length(s) == k{\\n            res += 1\\n            s.clear()\\n        }\\n    }\\n        return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325565,
                "title": "python-o-n-time-o-k-k-space",
                "content": "```\\nclass Solution:\\n \\n    #nice explanation: youtu.be/XMKGP4QlyUY\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        types = {}\\n        cur = 1\\n        \\n        for i in range(-1,-len(rolls)-1,-1):\\n            if cur not in types:\\n                types[cur] = set()\\n            \\n            if len(types[cur]) == k:\\n                cur += 1\\n                types[cur] = set()\\n                \\n            types[cur].add(rolls[i])\\n        \\n        return cur+1 if len(types[cur]) == k else cur\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n \\n    #nice explanation: youtu.be/XMKGP4QlyUY\\n    def shortestSequence(self, rolls: List[int], k: int) -> int:\\n        types = {}\\n        cur = 1\\n        \\n        for i in range(-1,-len(rolls)-1,-1):\\n            if cur not in types:\\n                types[cur] = set()\\n            \\n            if len(types[cur]) == k:\\n                cur += 1\\n                types[cur] = set()\\n                \\n            types[cur].add(rolls[i])\\n        \\n        return cur+1 if len(types[cur]) == k else cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325497,
                "title": "c-hindi-solution-easy-intution-greedy-easy-understanding",
                "content": "The question is very easy once you get the intution. Here is the entire solution and intution explained in both hindi and english. If found useful, then please upvote. \\n\\n**Page 1: **\\n![image](https://assets.leetcode.com/users/images/ac852a9e-317f-43b0-81af-565d0748ccd3_1658642139.756246.jpeg)\\n\\n**Page 2: **\\n![image](https://assets.leetcode.com/users/images/589922af-dc62-456d-a1d5-439c5c342bb9_1658642127.4038103.jpeg)\\n\\n**Page 3: **\\n![image](https://assets.leetcode.com/users/images/eaf86cc5-343b-43c6-b928-3b2b48210f5a_1658642090.1669989.jpeg)\\n\\n**Page 4: **\\n![image](https://assets.leetcode.com/users/images/e9d20d80-5ca9-4900-a4d9-5a9b34af9c54_1658642156.3262725.jpeg)\\n\\n**C++ Code: **\\n```\\nint shortestSequence(vector<int>& rolls, int k) {\\n\\tint res = 1;\\n\\tset<int> s;\\n\\tfor(auto x: rolls){\\n\\t\\ts.insert(x);\\n\\t\\tif(s.size() == k){\\n\\t\\t\\tres++;\\n\\t\\t\\ts.clear();\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\n```\\n\\nPlease, upvote if helpful. \\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nint shortestSequence(vector<int>& rolls, int k) {\\n\\tint res = 1;\\n\\tset<int> s;\\n\\tfor(auto x: rolls){\\n\\t\\ts.insert(x);\\n\\t\\tif(s.size() == k){\\n\\t\\t\\tres++;\\n\\t\\t\\ts.clear();\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324904,
                "title": "easy-java-greedy-solution",
                "content": "```\\n// the idea goes like this \\n// to form all sequences of length 1\\n// we should have all numbers from 1 to k present till some index firstIdx \\n// to form all sequences of length 2 \\n// we should have all numbers from 1 to k present after firstIdx till some index secondIdx\\n// having numbers from 1 to k present after firstIdx \\n// ensures all sequences of length 2 are formed\\n// because all numbers from 1 to k \\n// are present after the last number \\n// which forms a sequence of length 1\\n// similarly , to form sequences of length 3\\n// numbers 1 to k should be present after secondIdx\\n\\n// TC : O(rolls.length)\\n// SC : O(k)\\n\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int shortestSeq = 0;\\n        HashSet<Integer> set = new HashSet();\\n        \\n        for(int num : rolls){\\n            set.add(num);\\n            \\n            if(set.size()==k){\\n                shortestSeq++;\\n                set = new HashSet();\\n            }\\n        }\\n        \\n        return shortestSeq+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n// the idea goes like this \\n// to form all sequences of length 1\\n// we should have all numbers from 1 to k present till some index firstIdx \\n// to form all sequences of length 2 \\n// we should have all numbers from 1 to k present after firstIdx till some index secondIdx\\n// having numbers from 1 to k present after firstIdx \\n// ensures all sequences of length 2 are formed\\n// because all numbers from 1 to k \\n// are present after the last number \\n// which forms a sequence of length 1\\n// similarly , to form sequences of length 3\\n// numbers 1 to k should be present after secondIdx\\n\\n// TC : O(rolls.length)\\n// SC : O(k)\\n\\nclass Solution {\\n    public int shortestSequence(int[] rolls, int k) {\\n        int shortestSeq = 0;\\n        HashSet<Integer> set = new HashSet();\\n        \\n        for(int num : rolls){\\n            set.add(num);\\n            \\n            if(set.size()==k){\\n                shortestSeq++;\\n                set = new HashSet();\\n            }\\n        }\\n        \\n        return shortestSeq+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324623,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<rolls.size();i++){\\n            mp[rolls[i]]++;\\n            if(mp.size()==k){\\n                cnt++;\\n                mp.clear();\\n            }\\n        }\\n        \\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        for(int i=0;i<rolls.size();i++){\\n            mp[rolls[i]]++;\\n            if(mp.size()==k){\\n                cnt++;\\n                mp.clear();\\n            }\\n        }\\n        \\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324499,
                "title": "c-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        unordered_set<int>Set;\\n        int ans=0;\\n        for(auto &x:rolls)\\n        {\\n            Set.insert(x);\\n            if(Set.size()==k)\\n            {\\n                Set.clear();\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) \\n    {\\n        unordered_set<int>Set;\\n        int ans=0;\\n        for(auto &x:rolls)\\n        {\\n            Set.insert(x);\\n            if(Set.size()==k)\\n            {\\n                Set.clear();\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324497,
                "title": "c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k)\\n    {\\n        unordered_set<int> set;\\n        int rv = 0;\\n        for (auto &n : rolls)\\n        {\\n            set.insert(n);\\n            if (set.size() == k)\\n                set.clear(), ++rv;\\n        }\\n        return 1 + rv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int shortestSequence(vector<int> &rolls, int k)\\n    {\\n        unordered_set<int> set;\\n        int rv = 0;\\n        for (auto &n : rolls)\\n        {\\n            set.insert(n);\\n            if (set.size() == k)\\n                set.clear(), ++rv;\\n        }\\n        return 1 + rv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324463,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Set***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(K)***\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n = rolls.size();\\n        \\n        // count store the no. of complete set which contains all the occurance from (1 to k)\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            unordered_set<int> s;\\n            \\n            while(i < n && s.size() < k)\\n            {\\n                s.insert(rolls[i]);\\n                \\n                i++;\\n            }\\n            \\n            // one complete set is found\\n            \\n            if(s.size() == k)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestSequence(vector<int>& rolls, int k) {\\n        \\n        int n = rolls.size();\\n        \\n        // count store the no. of complete set which contains all the occurance from (1 to k)\\n        \\n        int count = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            unordered_set<int> s;\\n            \\n            while(i < n && s.size() < k)\\n            {\\n                s.insert(rolls[i]);\\n                \\n                i++;\\n            }\\n            \\n            // one complete set is found\\n            \\n            if(s.size() == k)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324159,
                "title": "swift-one-liner-also-for-loop-six-liner-fully-explained",
                "content": "Scroll down for solution explanation. \\n\\n**One-Liner Terse** ***(accepted answer)***\\n```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        rolls.reduce(into: (1, Set<Int>())) { if $0.1.insert($1).0 && $0.1.count == k { $0 = ($0.0 + 1, []) }}.0\\n    }\\n}\\n```\\n\\n**One-Liner Annotated** ***(accepted answer)***\\n```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        rolls.reduce(into: (counter: 1, set: Set<Int>()))  { tuple, roll in\\n            if tuple.set.insert(roll).inserted && tuple.set.count == k {\\n                tuple = (counter: tuple.counter + 1, set: [])\\n            }\\n        }.counter\\n    }\\n}\\n```\\n---\\n**For-Loop, Imperative Style** ***(accepted answer)***\\n```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        var counter = 1, set = Set<Int>()          \\n        for roll in rolls where set.insert(roll).inserted && set.count == k  {\\n            set = []\\n            counter += 1\\n        }   \\n        return counter\\n    }\\n}\\n```\\n\\n## **Solution Explanation**\\n\\n**Restate Problem**\\nThe problem is not stated very clearly, which adds complexity. It can be more simply restated:\\n1. We are given a sequence of rolls from a `k-sided` die. \\n\\n2. We want to answer what is the ***largest*** possible subsequence of random rolls from a `k-sided` die that appears *in-order* in the given supersequence, then add one to that answer to return the ***smallest*** impossible sequence.\\n\\n\\n**Solution Approach: One-Pass, Partition Sequence into Full Sets, Return Partition Count**\\n1. Over a single scan of the larger sequence, add each roll, in order, to a set. \\n\\n2. Whenever adding an element to the set causes the set to become full (meaning there are `k` elements in it), we have seen a roll of all sides of the die. This means that a subsequence of one more element is possible. At this point, flush the set and increment a counter.\\n\\n3. At the end of the scan, the counter contains the largest possible subsequence of rolls, increment the counter to change this to be the shortest impossible sequence and return the counter. \\n**Note:** in the implementation above, we start with the counter at 1 to avoid incrementing at end.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        rolls.reduce(into: (1, Set<Int>())) { if $0.1.insert($1).0 && $0.1.count == k { $0 = ($0.0 + 1, []) }}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        rolls.reduce(into: (counter: 1, set: Set<Int>()))  { tuple, roll in\\n            if tuple.set.insert(roll).inserted && tuple.set.count == k {\\n                tuple = (counter: tuple.counter + 1, set: [])\\n            }\\n        }.counter\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func shortestSequence(_ rolls: [Int], _ k: Int) -> Int {\\n        var counter = 1, set = Set<Int>()          \\n        for roll in rolls where set.insert(roll).inserted && set.count == k  {\\n            set = []\\n            counter += 1\\n        }   \\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1867538,
                "content": [
                    {
                        "username": "Adityaxv",
                        "content": "I did not understand the problem statement. Please someone explain it."
                    },
                    {
                        "username": "rhymes17",
                        "content": "we have to use the array to make all possible outcomes of len [1-k] and the smallest len that is impossible to make is our ans.\\n\\nFor e.g.\\n4,3,2,1\\nhere we can make all outcomes of len 1 i.e 1,2,3,4\\nbut we cannot make any outcomes of len 2.\\nthe first outcome of len 2 should have been 1,1. i.e we have two dice and they should form the pair 1,1 but we cannot because in the array 1 is present only once and also it is in the last.\\nHope it makes sense to you."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Sometimes these descriptions are so cryptic...\\n\\n\"cannot be taken from rolls\" - in plain english: there\\'s no such subsequence in rolls.\\n\\n"
                    },
                    {
                        "username": "ANKITsaraf21",
                        "content": "can you explain unexpected indent means"
                    },
                    {
                        "username": "Angel-W10",
                        "content": "try changing the indentation, meaning: try to change the space after a loop or condition. python reads your code based on the indent, so if thats not properly done the code throws an error\\n"
                    }
                ]
            },
            {
                "id": 2052011,
                "content": [
                    {
                        "username": "Adityaxv",
                        "content": "I did not understand the problem statement. Please someone explain it."
                    },
                    {
                        "username": "rhymes17",
                        "content": "we have to use the array to make all possible outcomes of len [1-k] and the smallest len that is impossible to make is our ans.\\n\\nFor e.g.\\n4,3,2,1\\nhere we can make all outcomes of len 1 i.e 1,2,3,4\\nbut we cannot make any outcomes of len 2.\\nthe first outcome of len 2 should have been 1,1. i.e we have two dice and they should form the pair 1,1 but we cannot because in the array 1 is present only once and also it is in the last.\\nHope it makes sense to you."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Sometimes these descriptions are so cryptic...\\n\\n\"cannot be taken from rolls\" - in plain english: there\\'s no such subsequence in rolls.\\n\\n"
                    },
                    {
                        "username": "ANKITsaraf21",
                        "content": "can you explain unexpected indent means"
                    },
                    {
                        "username": "Angel-W10",
                        "content": "try changing the indentation, meaning: try to change the space after a loop or condition. python reads your code based on the indent, so if thats not properly done the code throws an error\\n"
                    }
                ]
            },
            {
                "id": 1654832,
                "content": [
                    {
                        "username": "Adityaxv",
                        "content": "I did not understand the problem statement. Please someone explain it."
                    },
                    {
                        "username": "rhymes17",
                        "content": "we have to use the array to make all possible outcomes of len [1-k] and the smallest len that is impossible to make is our ans.\\n\\nFor e.g.\\n4,3,2,1\\nhere we can make all outcomes of len 1 i.e 1,2,3,4\\nbut we cannot make any outcomes of len 2.\\nthe first outcome of len 2 should have been 1,1. i.e we have two dice and they should form the pair 1,1 but we cannot because in the array 1 is present only once and also it is in the last.\\nHope it makes sense to you."
                    },
                    {
                        "username": "BitBlaster",
                        "content": "Sometimes these descriptions are so cryptic...\\n\\n\"cannot be taken from rolls\" - in plain english: there\\'s no such subsequence in rolls.\\n\\n"
                    },
                    {
                        "username": "ANKITsaraf21",
                        "content": "can you explain unexpected indent means"
                    },
                    {
                        "username": "Angel-W10",
                        "content": "try changing the indentation, meaning: try to change the space after a loop or condition. python reads your code based on the indent, so if thats not properly done the code throws an error\\n"
                    }
                ]
            }
        ]
    }
]