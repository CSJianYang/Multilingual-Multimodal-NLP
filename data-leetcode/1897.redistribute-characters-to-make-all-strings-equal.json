[
    {
        "title": "Grumpy Bookstore Owner",
        "question_content": "There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.\n&nbsp;\nExample 1:\n\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nExample 2:\n\nInput: customers = [1], grumpy = [0], minutes = 1\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tn == customers.length == grumpy.length\n\t1 <= minutes <= n <= 2 * 104\n\t0 <= customers[i] <= 1000\n\tgrumpy[i] is either 0 or 1.",
        "solutions": [
            {
                "id": 299230,
                "title": "java-python-3-sliding-window",
                "content": "**Q & A:**\\nQ1: Struggling to understand `winOfMakeSatisfied -= grumpy[i - X] * customers[i - X];`. How does it work in the array to delete?\\nA1: \\n1. For any consecutive `X` minutes and any integer i (>= X), there are: \\ngrumpy[i - X] * cumtomers[i - X] unsatisfied customers at (i - X)th minutes;\\ngrumpy[i - X + 1] * cumtomers[i - X + 1] unsatisfied customers at (i - X + 1)th minutes;\\n...\\ngrumpy[i - 1] * cumtomers[i - 1] unsatisfied customers at (i - 1)th minutes;\\nWe use a window of width `X` to record the number of unsatisfied customers for the above `X` minutes: \\n`grumpy[i - X] * cumtomers[i - X] + grumpy[i - X + 1] * cumtomers[i - X + 1] + ... + grumpy[i - 1] * cumtomers[i - 1]` ... (a)\\n\\n2. In order to find maximum unsatisfied customers in any consecutive `X` minutes, we slide the window of width `X` from left to right, one minute one iteration:\\n`grumpy[i - X + 1] * cumtomers[i - X + 1] + grumpy[i - X + 2] * cumtomers[i - X + 2] + ... + grumpy[i - 1] * cumtomers[i - 1] + grumpy[i] * cumtomers[i]`  ................................. (b)\\n`grumpy[i - X + 2] * cumtomers[i - X + 2] + grumpy[i - X + 3] * cumtomers[i - X + 3] + ... + grumpy[i] * cumtomers[i] + grumpy[i + 1] * cumtomers[i + 1]`\\n`grumpy[i - X + 3] * cumtomers[i - X + 3] + grumpy[i - X + 4] * cumtomers[i - X + 4] + ... + grumpy[i + 1] * cumtomers[i + 1] + grumpy[i + 2] * cumtomers[i + 2]`\\n...\\n(a) and (b) are `winOfMakeSatisfied` at `(i - 1)th` and `ith` minute, respectively; If you compare (a) and (b), you will find that (b) is short of a term `grumpy[i - X] * cumtomers[i - X]` but has a new term `grumpy[i] * cumtomers[i]`. That is why \\n\\nafter \\n```\\nelse { winOfMakeSatisfied += customers[i]; } // here grumpy[i] = 1, hence equal to \"else { winOfMakeSatisfied += grumpy[i] * customers[i]; } \"\\n```\\nwe have \\n```\\nwinOfMakeSatisfied -= grumpy[i - X] * customers[i - X];\\n```\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Use a sliding window `winOfMakeSatisfied` to record the number of unsatisfied customers for `X` minutes. Deduct the unsatisfied customers from left end of the sliding window when it is wider than `X`:\\n `winOfMakeSatisfied -= grumpy[i - X] * customers[i - X];`.\\n2. Use `satisfied` to record the number of satistified customers without grumpy technique.\\n3. by the end of iterations, `satisfied` + `max(winOfMakeSatisfied)` is the answer.\\n\\n```java\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfied = 0, maxMakeSatisfied = 0;\\n        for (int i = 0, winOfMakeSatisfied = 0; i < grumpy.length; ++i) {\\n            if (grumpy[i] == 0) { satisfied += customers[i]; }\\n            else { winOfMakeSatisfied += customers[i]; }\\n            if (i >= X) {\\n                winOfMakeSatisfied -= grumpy[i - X] * customers[i - X];\\n            }\\n            maxMakeSatisfied = Math.max(winOfMakeSatisfied, maxMakeSatisfied);\\n        }\\n        return satisfied + maxMakeSatisfied;        \\n    }\\n```\\n```python\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        i = win_of_make_satisfied = satisfied = max_make_satisfied = 0\\n        for c, g in zip(customers, grumpy):\\n            satisfied += (1 - g) * c\\n            win_of_make_satisfied += g * c\\n            if i >= X:\\n                win_of_make_satisfied -= grumpy[i - X] * customers[i - X]\\n            max_make_satisfied = max(win_of_make_satisfied, max_make_satisfied)  \\n            i += 1    \\n        return satisfied + max_make_satisfied\\n```\\n\\n**Analysis:**\\n\\nTime: O(n), space: O(1), where n = grumpy.length;",
                "solutionTags": [],
                "code": "```\\nelse { winOfMakeSatisfied += customers[i]; } // here grumpy[i] = 1, hence equal to \"else { winOfMakeSatisfied += grumpy[i] * customers[i]; } \"\\n```\n```\\nwinOfMakeSatisfied -= grumpy[i - X] * customers[i - X];\\n```\n```java\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfied = 0, maxMakeSatisfied = 0;\\n        for (int i = 0, winOfMakeSatisfied = 0; i < grumpy.length; ++i) {\\n            if (grumpy[i] == 0) { satisfied += customers[i]; }\\n            else { winOfMakeSatisfied += customers[i]; }\\n            if (i >= X) {\\n                winOfMakeSatisfied -= grumpy[i - X] * customers[i - X];\\n            }\\n            maxMakeSatisfied = Math.max(winOfMakeSatisfied, maxMakeSatisfied);\\n        }\\n        return satisfied + maxMakeSatisfied;        \\n    }\\n```\n```python\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        i = win_of_make_satisfied = satisfied = max_make_satisfied = 0\\n        for c, g in zip(customers, grumpy):\\n            satisfied += (1 - g) * c\\n            win_of_make_satisfied += g * c\\n            if i >= X:\\n                win_of_make_satisfied -= grumpy[i - X] * customers[i - X]\\n            max_make_satisfied = max(win_of_make_satisfied, max_make_satisfied)  \\n            i += 1    \\n        return satisfied + max_make_satisfied\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 299284,
                "title": "python-with-explanation-rolling-sum",
                "content": "The way I approached this problem was to split it into 2 smaller problems. \\n\\nThe first involves counting how many customers are already satisfied, i.e. those where the shopkeeper is not grumpy. I also set any slots with already satisfied customers to 0, so that we will be left with only the currently unsatisfied customers in the list.\\n\\nFor the second part, the array now only contains customers who will not be satisfied. We are able to make X adjacent times \\u201Chappy\\u201D, so we want to find the subarray of length X that has the most customers. We can just keep a rolling sum of the last X customers in the array, and then the best solution is the max the rolling sum ever was.\\n\\nFinally we return the sum of the 2 parts: the customers who were already satisfied, and the maximum number who can be made satisfied by stopping the shop keeper from being grumpy for X time.\\n\\nNote that both parts can be combined into a single loop, but I felt this way was probably easier for understanding, and both are still ```O(n)``` time. I\\'ll shortly include code for how to merge it all together.\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        # Part 1 requires counting how many customers\\n        # are already satisfied, and removing them\\n        # from the customer list.\\n        already_satisfied = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0: #He\\'s happy\\n                already_satisfied += customers[i]\\n                customers[i] = 0\\n        \\n        # Part 2 requires finding the optinal number\\n        # of unhappy customers we can make happy.\\n        best_we_can_make_satisfied = 0\\n        current_satisfied = 0\\n        for i, customers_at_time in enumerate(customers):\\n            current_satisfied += customers_at_time # Add current to rolling total\\n            if i >= X: # We need to remove some from the rolling total\\n                current_satisfied -= customers[i - X]\\n            best_we_can_make_satisfied = max(best_we_can_make_satisfied, current_satisfied)\\n        \\n        # The answer is the sum of the solutions for the 2 parts.\\n        return already_satisfied + best_we_can_make_satisfied\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        # Part 1 requires counting how many customers\\n        # are already satisfied, and removing them\\n        # from the customer list.\\n        already_satisfied = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0: #He\\'s happy\\n                already_satisfied += customers[i]\\n                customers[i] = 0\\n        \\n        # Part 2 requires finding the optinal number\\n        # of unhappy customers we can make happy.\\n        best_we_can_make_satisfied = 0\\n        current_satisfied = 0\\n        for i, customers_at_time in enumerate(customers):\\n            current_satisfied += customers_at_time # Add current to rolling total\\n            if i >= X: # We need to remove some from the rolling total\\n                current_satisfied -= customers[i - X]\\n            best_we_can_make_satisfied = max(best_we_can_make_satisfied, current_satisfied)\\n        \\n        # The answer is the sum of the solutions for the 2 parts.\\n        return already_satisfied + best_we_can_make_satisfied\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299237,
                "title": "c-sliding-window",
                "content": "When the owner is not grumpy, we count all customers as ```satisfied```. \\n\\nWe then use the sliding window to count additionally satisfied customers (```add_satisfied```) if the owner start \\'behaving\\' at minute ```i```. We track the maximum additional satisfied customers in ```m_add_satisfied```.\\n\\nFinally, return ```satisfied + m_add_satisfied``` as the result.\\n\\n**C++**\\n```cpp\\nint maxSatisfied(vector<int>& cs, vector<int>& grumpy, int X) {\\n    auto satisfied = 0, m_add_satisfied = 0, add_satisfied = 0;\\n    for (auto i = 0; i < cs.size(); ++i) {\\n        satisfied += !grumpy[i] * cs[i];\\n        add_satisfied += grumpy[i] * cs[i];\\n        if (i >= X) \\n            add_satisfied -= grumpy[i - X] * cs[i - X];\\n        m_add_satisfied = max(m_add_satisfied, add_satisfied);\\n    }\\n    return satisfied + m_add_satisfied;\\n}\\n```\\n# Complexity Analysis\\nRuntime: O(n)\\nMemory: O(1)",
                "solutionTags": [],
                "code": "```satisfied```\n```add_satisfied```\n```i```\n```m_add_satisfied```\n```satisfied + m_add_satisfied```\n```cpp\\nint maxSatisfied(vector<int>& cs, vector<int>& grumpy, int X) {\\n    auto satisfied = 0, m_add_satisfied = 0, add_satisfied = 0;\\n    for (auto i = 0; i < cs.size(); ++i) {\\n        satisfied += !grumpy[i] * cs[i];\\n        add_satisfied += grumpy[i] * cs[i];\\n        if (i >= X) \\n            add_satisfied -= grumpy[i - X] * cs[i - X];\\n        m_add_satisfied = max(m_add_satisfied, add_satisfied);\\n    }\\n    return satisfied + m_add_satisfied;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597575,
                "title": "simple-java-sliding-window-beats-96-explanation",
                "content": "All we need to do is find the max number of customers who, without applying the technique, would normally be unsatisfied. Once we have this max, we just add it to the baseline number of customers who would be satisfied if we did not apply the technique.\\n\\nSteps:\\n1.) Pass through array and calculate the total number of satisifed customers without applying the bookstore owner\\'s \"technique\". This is calculated by only adding customers on minutes where he is happy.\\n\\n2.)  Create a sliding window of size X. The sum of the window will be equal to the number of customers that occur on minutes within the window where the bookstore owner is unhappy.\\n\\n3.) Compare the current sum of this window with the max window sum we have seen thus far. If the current sum is bigger than the max, it becomes the max.\\n\\n4.)  Return the baseline number of satisfied customers + the max window sum we found.\\n\\n``` \\npublic int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        // find the number of satisfied customers without applying the secret technique\\n        int satisfiedCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                satisfiedCustomers += customers[i];\\n            } \\n        }\\n        \\n        int max = 0;\\n        int currSum = 0;\\n        int windowStart = 0;\\n        \\n        for (int windowEnd = 0; windowEnd < customers.length; windowEnd++) {\\n            if (grumpy[windowEnd] == 1) {\\n                currSum += customers[windowEnd];\\n            }\\n            \\n            if (windowEnd - windowStart + 1 >= X) {\\n                max = Math.max(max, currSum);\\n                if (grumpy[windowStart] == 1) {\\n                    currSum -= customers[windowStart];\\n                }\\n                windowStart++;\\n            }\\n        }\\n        \\n        return satisfiedCustomers + max;   \\n}",
                "solutionTags": [],
                "code": "All we need to do is find the max number of customers who, without applying the technique, would normally be unsatisfied. Once we have this max, we just add it to the baseline number of customers who would be satisfied if we did not apply the technique.\\n\\nSteps:\\n1.) Pass through array and calculate the total number of satisifed customers without applying the bookstore owner\\'s \"technique\". This is calculated by only adding customers on minutes where he is happy.\\n\\n2.)  Create a sliding window of size X. The sum of the window will be equal to the number of customers that occur on minutes within the window where the bookstore owner is unhappy.\\n\\n3.) Compare the current sum of this window with the max window sum we have seen thus far. If the current sum is bigger than the max, it becomes the max.\\n\\n4.)  Return the baseline number of satisfied customers + the max window sum we found.\\n\\n``` \\npublic int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        // find the number of satisfied customers without applying the secret technique\\n        int satisfiedCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                satisfiedCustomers += customers[i];\\n            } \\n        }\\n        \\n        int max = 0;\\n        int currSum = 0;\\n        int windowStart = 0;\\n        \\n        for (int windowEnd = 0; windowEnd < customers.length; windowEnd++) {\\n            if (grumpy[windowEnd] == 1) {\\n                currSum += customers[windowEnd];\\n            }\\n            \\n            if (windowEnd - windowStart + 1 >= X) {\\n                max = Math.max(max, currSum);\\n                if (grumpy[windowStart] == 1) {\\n                    currSum -= customers[windowStart];\\n                }\\n                windowStart++;\\n            }\\n        }\\n        \\n        return satisfiedCustomers + max;   \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 299198,
                "title": "c-linear-time-easy-to-understand",
                "content": "\\t\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\t\\t\\tint mins = customers.size();\\n\\t\\t\\tint directly_satisfied = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < mins; i++) {\\n\\t\\t\\t\\tif(!grumpy[i]) {\\n\\t\\t\\t\\t\\tdirectly_satisfied += customers[i];\\n\\t\\t\\t\\t\\tcustomers[i] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint secretly_satisfied = 0, sum = 0;\\n\\t\\t\\tfor(int i = 0, j = 0; j < mins; j++) {\\n\\t\\t\\t\\tsum += customers[j];\\n\\t\\t\\t\\tif(j - i == X)\\n\\t\\t\\t\\t\\tsum -= customers[i++];\\n\\t\\t\\t\\tsecretly_satisfied = max(secretly_satisfied, sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn directly_satisfied + secretly_satisfied;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\t\\t\\tint mins = customers.size();\\n\\t\\t\\tint directly_satisfied = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < mins; i++) {\\n\\t\\t\\t\\tif(!grumpy[i]) {\\n\\t\\t\\t\\t\\tdirectly_satisfied += customers[i];\\n\\t\\t\\t\\t\\tcustomers[i] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint secretly_satisfied = 0, sum = 0;\\n\\t\\t\\tfor(int i = 0, j = 0; j < mins; j++) {\\n\\t\\t\\t\\tsum += customers[j];\\n\\t\\t\\t\\tif(j - i == X)\\n\\t\\t\\t\\t\\tsum -= customers[i++];\\n\\t\\t\\t\\tsecretly_satisfied = max(secretly_satisfied, sum);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn directly_satisfied + secretly_satisfied;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 299492,
                "title": "java-one-pass-with-comments-sliding-window",
                "content": "```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int n = customers.length;\\n        int save = 0; // currently how many customers change to be happy if using technique, sliding window\\n        int totalCustomer = 0; // sum of all customers\\n        int totalGrumpy = 0; // sum of all unsatisfied customers without using technique\\n        int maxSave = 0; \\n        for(int i = 0; i < n; i++) {\\n            totalCustomer += customers[i];\\n            totalGrumpy += customers[i] * grumpy[i];\\n            save += customers[i] * grumpy[i];\\n            if(i > X - 1) {\\n                save -= customers[i - X] * grumpy[i - X];\\n            }\\n            maxSave = Math.max(save, maxSave);\\n        }\\n        return totalCustomer - totalGrumpy + maxSave;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int n = customers.length;\\n        int save = 0; // currently how many customers change to be happy if using technique, sliding window\\n        int totalCustomer = 0; // sum of all customers\\n        int totalGrumpy = 0; // sum of all unsatisfied customers without using technique\\n        int maxSave = 0; \\n        for(int i = 0; i < n; i++) {\\n            totalCustomer += customers[i];\\n            totalGrumpy += customers[i] * grumpy[i];\\n            save += customers[i] * grumpy[i];\\n            if(i > X - 1) {\\n                save -= customers[i - X] * grumpy[i - X];\\n            }\\n            maxSave = Math.max(save, maxSave);\\n        }\\n        return totalCustomer - totalGrumpy + maxSave;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526391,
                "title": "sliding-window-very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfy = 0;\\n        for(int i=0;i<grumpy.length;i++){\\n            if(grumpy[i]==0) satisfy += customers[i]; // directly sum the satisfy customers\\n            customers[i] = grumpy[i]*customers[i]; // collect the unsatisfy customers\\n        }\\n        return satisfy + getMax(customers,X);\\n    }\\n    \\n    public int getMax(int[] arr, int X){ // X is window size\\n        int max = 0;\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n            if(i>=X){\\n                sum -= arr[i-X]; \\n            }\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfy = 0;\\n        for(int i=0;i<grumpy.length;i++){\\n            if(grumpy[i]==0) satisfy += customers[i]; // directly sum the satisfy customers\\n            customers[i] = grumpy[i]*customers[i]; // collect the unsatisfy customers\\n        }\\n        return satisfy + getMax(customers,X);\\n    }\\n    \\n    public int getMax(int[] arr, int X){ // X is window size\\n        int max = 0;\\n        int sum = 0;\\n        for(int i=0;i<arr.length;i++){\\n            sum += arr[i];\\n            if(i>=X){\\n                sum -= arr[i-X]; \\n            }\\n            max = Math.max(max,sum);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823324,
                "title": "java-tricky-made-easy-easy-step-by-step-explained-1-ms-faster-than-100",
                "content": "class Solution {\\n    \\n    // the idea is to choose the window which has the max_un-satisfied customer count so we can satisfy \\n    // the maximum customers by making the grump[i] = 1 to grump[i] = 0 within that window\\n    // so we need an extra array which tracks the unsatisfied customers at i- th minute \\n    // and find the window of size X which has the most unsatisfied customers in that array \\n    // at any point of time , ie - globally.\\n    // that window with max Unsatisfied customers is the window we want !\\n    public int maxSatisfied(int[] customers, int[] grumpy, int k) {\\n        \\n        // create an arr to keep track of the unsatisfied customers at i-Th minute\\n        int unsatisfied[] = new int[grumpy.length];\\n        // since grumpy == 1 , grumpy[i]*customers[i] == number of unsatisfied customers at i-th minute\\n        for(int i = 0 ; i < grumpy.length ; i++){\\n            unsatisfied[i] = grumpy[i]*customers[i];\\n        }\\n        int unsatisfied_curr = 0 ;\\n        int unsatisfied_global = 0 ;\\n        int start = 0 ;\\n        int end = 0 ;\\n        // create the first window of size X with the unsatisfied customer count of iTh minutes \\n        // and get the sum of all such unsatisfied customers \\n        for(int i = 0 ; i < k ; i++){\\n            unsatisfied_curr += unsatisfied[i];\\n        }\\n        unsatisfied_global = unsatisfied_curr ;\\n        start = 0 ;\\n        end = k - 1;\\n        // slide the window one elt at a time and find the window which has the maximum number of unsatisfied \\n        // customers count sum, because we can satisfy the maximum customers if we use our power in the window \\n        // having maximum unsatisfied customers \\n        // ie - we need to satisfy maximum possible customers to maximize our satisfied customer count\\n        \\n        for(int i = k ; i < unsatisfied.length ; i++){\\n            // normal sliding window technique\\n            unsatisfied_curr += -unsatisfied[i - k];\\n            unsatisfied_curr += unsatisfied[i];\\n            \\n            // record the max_unsatisfied customer count window\\'s start and end index\\n            if(unsatisfied_curr > unsatisfied_global){\\n                unsatisfied_global = unsatisfied_curr;\\n                start = i - k + 1;\\n                end = i ;\\n            }\\n            \\n        }\\n        // change all the grumpy minutes within the desired window to non-grumpy minutes , ie - from 1 to 0 \\n        for(int i = start ; i <= end ; i++){\\n            grumpy[i] = 0;\\n        }\\n        int ans = 0;\\n        // finally add all customers served during non grumpy minutes \\n        for(int i = 0 ; i < grumpy.length; i++){\\n            if(grumpy[i] == 0)\\n                ans += customers[i];\\n        }\\n        return ans ;\\n    }\\n}\\n// hope it helps , if u like pls upvote pls pls, tysm , it was either really tricky question or\\n// i am just really stupid , took so much tym :( :(",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    // the idea is to choose the window which has the max_un-satisfied customer count so we can satisfy \\n    // the maximum customers by making the grump[i] = 1 to grump[i] = 0 within that window\\n    // so we need an extra array which tracks the unsatisfied customers at i- th minute \\n    // and find the window of size X which has the most unsatisfied customers in that array \\n    // at any point of time , ie - globally.\\n    // that window with max Unsatisfied customers is the window we want !\\n    public int maxSatisfied(int[] customers, int[] grumpy, int k) {\\n        \\n        // create an arr to keep track of the unsatisfied customers at i-Th minute\\n        int unsatisfied[] = new int[grumpy.length];\\n        // since grumpy == 1 , grumpy[i]*customers[i] == number of unsatisfied customers at i-th minute\\n        for(int i = 0 ; i < grumpy.length ; i++){\\n            unsatisfied[i] = grumpy[i]*customers[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 408313,
                "title": "ac-readable-python-9-lines",
                "content": "```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n\\tm = s = tmp = 0\\n\\tfor i in range(len(customers)):\\n\\t\\tif not grumpy[i]: \\n\\t\\t\\ts += customers[i]                # sum of satisfied customers\\n\\t\\t\\tcustomers[i] = 0 \\n\\t\\telse: tmp += customers[i]            # sum of grumpy customers \\n\\t\\tif i>=X: tmp -= customers[i-X]       # remove the leftmost element to keep the sliding window with # of X\\n\\t\\tm = max(m, tmp)                      # max # of satisfied grumpy customers with a secret technique\\n\\treturn s+m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n\\tm = s = tmp = 0\\n\\tfor i in range(len(customers)):\\n\\t\\tif not grumpy[i]: \\n\\t\\t\\ts += customers[i]                # sum of satisfied customers\\n\\t\\t\\tcustomers[i] = 0 \\n\\t\\telse: tmp += customers[i]            # sum of grumpy customers \\n\\t\\tif i>=X: tmp -= customers[i-X]       # remove the leftmost element to keep the sliding window with # of X\\n\\t\\tm = max(m, tmp)                      # max # of satisfied grumpy customers with a secret technique\\n\\treturn s+m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 455961,
                "title": "not-understanding-example-1",
                "content": "As described in description, \"The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.\", which I am interpreting as setting a subarray of length 3 in grumpy to 0s. So that grumpy = [0,1,0,1,0,0,0,0], so max total is 1 + 1 + 7 + 5 = 14. How is 16 possible?\\n```\\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\\nOutput: 16\\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \\nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\\n",
                "solutionTags": [],
                "code": "As described in description, \"The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.\", which I am interpreting as setting a subarray of length 3 in grumpy to 0s. So that grumpy = [0,1,0,1,0,0,0,0], so max total is 1 + 1 + 7 + 5 = 14. How is 16 possible?\\n```\\nInput: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3\\nOutput: 16\\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \\nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1063109,
                "title": "extremely-readable-code-with-simple-explanation-o-n-time-cpp",
                "content": "Beats 98% of CPP submissions - Constant Space Solution\\nTime Complexity - O(2n) i.e. O(n)\\n\\nIdea - The final ans should be total count of **existing satisfied customers** + **maximum number of unsatisfied customers which can be satisfied**  considering window size of X\\n\\nAlgorithm - \\n1. Loop through all the customers and count the total number AND total satisfied customers present already.\\n2. Small check to see if X is the size of customers array, then simply return the total customer count since everyone can be satisfied.\\n3. For the first window, count the number of unsatisfied customers.\\n4. Now keep moving the window by adding and removing 1 element from the ends\\n\\t\\ta. If the start had a grumpy state, before moving the start index to next one, reduce the total count of unsatisfied customers by that value\\n\\t\\tb. Check if the new end state is grumpy, and if so, add the count to unsatisfied customers count.\\n\\t\\tc. Finally check to see if this value is the max we have received.\\n\\t\\td. Keep doing this till the end.\\n5. Return the total count as mentioned in the idea\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n        int total_cust = 0, satisfied = 0;\\n        \\n\\t\\t// 1.\\n        for(int index=0; index<customers.size(); ++index) {\\n            total_cust += customers[index];\\n            if(grumpy[index] == 0)\\n                satisfied += customers[index];\\n        }\\n        \\n\\t\\t// 2.\\n        if(X == customers.size())\\n            return total_cust;\\n        \\n        int start = 0, end = 0, unsatis = 0;\\n        int max_unsatis = INT_MIN;\\n        \\n\\t\\t// 3.\\n        while(end<X) {\\n            if(grumpy[end] == 1)\\n                unsatis += customers[end];\\n            \\n            end++;\\n        }\\n            \\n        max_unsatis = max(max_unsatis, unsatis);\\n        \\n\\t\\t// 4.\\n        while(end<customers.size()) {\\n\\t\\t\\t// 4.a.\\n            if(grumpy[start] == 1)\\n                unsatis -= customers[start];\\n\\n\\t\\t\\tstart++;\\n    \\n\\t\\t\\t// 4.b.\\n            if(grumpy[end] == 1)\\n                unsatis += customers[end];\\n            \\n\\t\\t\\t// 4.c.\\n            max_unsatis = max(max_unsatis, unsatis);\\n            end++;\\n        }\\n        \\n\\t\\t// 5.\\n        return max_unsatis+satisfied;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n        int total_cust = 0, satisfied = 0;\\n        \\n\\t\\t// 1.\\n        for(int index=0; index<customers.size(); ++index) {\\n            total_cust += customers[index];\\n            if(grumpy[index] == 0)\\n                satisfied += customers[index];\\n        }\\n        \\n\\t\\t// 2.\\n        if(X == customers.size())\\n            return total_cust;\\n        \\n        int start = 0, end = 0, unsatis = 0;\\n        int max_unsatis = INT_MIN;\\n        \\n\\t\\t// 3.\\n        while(end<X) {\\n            if(grumpy[end] == 1)\\n                unsatis += customers[end];\\n            \\n            end++;\\n        }\\n            \\n        max_unsatis = max(max_unsatis, unsatis);\\n        \\n\\t\\t// 4.\\n        while(end<customers.size()) {\\n\\t\\t\\t// 4.a.\\n            if(grumpy[start] == 1)\\n                unsatis -= customers[start];\\n\\n\\t\\t\\tstart++;\\n    \\n\\t\\t\\t// 4.b.\\n            if(grumpy[end] == 1)\\n                unsatis += customers[end];\\n            \\n\\t\\t\\t// 4.c.\\n            max_unsatis = max(max_unsatis, unsatis);\\n            end++;\\n        }\\n        \\n\\t\\t// 5.\\n        return max_unsatis+satisfied;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792434,
                "title": "c-one-pass-with-sliding-window",
                "content": "```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n\\tint normal=0, win=0, maxwin=0;;\\n\\tfor(int i=0; i<customers.size(); i++){\\n\\t\\tnormal+=(!grumpy[i])*customers[i];\\n\\t\\twin+=customers[i]*grumpy[i];\\n\\t\\tif(i>=X) win-=customers[i-X]*grumpy[i-X]; \\n\\t\\tmaxwin=max(maxwin, win);\\n\\t}\\n\\n\\treturn normal+maxwin;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n\\tint normal=0, win=0, maxwin=0;;\\n\\tfor(int i=0; i<customers.size(); i++){\\n\\t\\tnormal+=(!grumpy[i])*customers[i];\\n\\t\\twin+=customers[i]*grumpy[i];\\n\\t\\tif(i>=X) win-=customers[i-X]*grumpy[i-X]; \\n\\t\\tmaxwin=max(maxwin, win);\\n\\t}\\n\\n\\treturn normal+maxwin;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700799,
                "title": "easy-solution-using-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever the shopowner is not grumpy, the customers are added irrespective of when the minutes are, so add the customers to ans whenever he is not grumpy. Now change customers to 0 whenever the shop owner is not grumpy. \\nNow the question is changed to the maximum sum of subarray with window size minutes. (standard sliding window problem)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n       int count = 0; \\n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \\n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \\n       int max = 0, temp = 0; \\n       for(int i=0; i<minutes; i++) temp += customers[i]; \\n       if(max < temp) max = temp; \\n       for(int i=minutes; i<customers.size(); i++) {\\n           temp -= customers[i - minutes]; temp += customers[i]; \\n           if(max < temp) max = temp; \\n       }\\n\\n       return count + max; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n       int count = 0; \\n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \\n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \\n       int max = 0, temp = 0; \\n       for(int i=0; i<minutes; i++) temp += customers[i]; \\n       if(max < temp) max = temp; \\n       for(int i=minutes; i<customers.size(); i++) {\\n           temp -= customers[i - minutes]; temp += customers[i]; \\n           if(max < temp) max = temp; \\n       }\\n\\n       return count + max; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749905,
                "title": "c-sliding-window-solution-o-n-easy-to-understand-explanation",
                "content": "Here we use sliding window algorithm because question is based on arrays, and we are given a window size (which is basically the minutes given) , we need to find a subarray of minutes length where the bookstore owner mustn\\'t be grumpy.\\nSo we first sum up all such minutes where already the owner is non-grumpy, because all such customers will always be satisfied.\\nNow we run our sliding window algo , and sum up all such customers who come when owner is grumpy , and once we reach window size of minutes length we keep updating the maxx value.\\nHere, is my code , please do ask your doubts , and upvote for motivation:\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n     int sum=0;\\n        int start=0,end=0;int maxx=0;\\n        for(int i=0;i<customers.size();i++)\\n            if(grumpy[i]==0)\\n            sum+=customers[i];\\n        cout<<sum<<endl;\\n        while(end<customers.size())\\n        {\\n            if(grumpy[end]==1)\\n                sum+=customers[end];\\n            if((end-start+1)<minutes)\\n                end++;\\n           else if((end-start+1)==minutes)\\n            {\\n                maxx=max(maxx,sum);\\n                if(grumpy[start]==1)\\n                    sum-=customers[start];\\n                start++;\\n                end++;\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n     int sum=0;\\n        int start=0,end=0;int maxx=0;\\n        for(int i=0;i<customers.size();i++)\\n            if(grumpy[i]==0)\\n            sum+=customers[i];\\n        cout<<sum<<endl;\\n        while(end<customers.size())\\n        {\\n            if(grumpy[end]==1)\\n                sum+=customers[end];\\n            if((end-start+1)<minutes)\\n                end++;\\n           else if((end-start+1)==minutes)\\n            {\\n                maxx=max(maxx,sum);\\n                if(grumpy[start]==1)\\n                    sum-=customers[start];\\n                start++;\\n                end++;\\n            }\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 388840,
                "title": "simplest-javascript-sliding-window-solution",
                "content": "The idea is simple - go over all the customers and sum up satisfied ones. They will never be unsatisfied.\\n\\nSame time overwrite `customers[i]` with the sum of unsatisfied customers till that minute.\\n\\nTo find the best time to use the secret technique for `X` munites is basically the buggest difference an unsatisfied customers array: `max(customers[i] - customers[i - X])`.\\n\\nFor example, for the input: `customers = [1,0,1,2,1,1,7,5]`; `grumpy = [0,1,0,1,0,1,0,1]`; `X = 3` we would have:\\n- already satisfied customers: 10\\n- unsatisfied customers array by minutes: `[0,0,0,2,2,3,3,8]`. Max unsatisfied customers that could be satisfied by the secret technique is basically the ones in the interval `customers[7] - customers[4] = 8 - 2 = 6`\\n- maximum number of customers that could be satisfied would equal 10 + 6 = 16\\n\\n\\n```js\\n/**\\n * @param {number[]} customers\\n * @param {number[]} grumpy\\n * @param {number} X\\n * @return {number}\\n */\\nvar maxSatisfied = function(customers, grumpy, X) {\\n  let satisfied = 0;\\n  let maxGrumpySatisfied = 0;\\n  \\n  for (let i = 0; i < grumpy.length; i++) {\\n    if (grumpy[i] === 0) {\\n      satisfied += customers[i];\\n      customers[i] = i === 0 ? 0 : customers[i - 1];\\n      continue;\\n    }\\n    \\n    if (i > 0) {\\n      customers[i] += customers[i - 1];\\n    }\\n    \\n    const grumpySatisfied = X <= i ? customers[i] - customers[i - X] : customers[i];\\n    maxGrumpySatisfied = Math.max(maxGrumpySatisfied, grumpySatisfied);\\n  }\\n  \\n  return satisfied + maxGrumpySatisfied;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```js\\n/**\\n * @param {number[]} customers\\n * @param {number[]} grumpy\\n * @param {number} X\\n * @return {number}\\n */\\nvar maxSatisfied = function(customers, grumpy, X) {\\n  let satisfied = 0;\\n  let maxGrumpySatisfied = 0;\\n  \\n  for (let i = 0; i < grumpy.length; i++) {\\n    if (grumpy[i] === 0) {\\n      satisfied += customers[i];\\n      customers[i] = i === 0 ? 0 : customers[i - 1];\\n      continue;\\n    }\\n    \\n    if (i > 0) {\\n      customers[i] += customers[i - 1];\\n    }\\n    \\n    const grumpySatisfied = X <= i ? customers[i] - customers[i - X] : customers[i];\\n    maxGrumpySatisfied = Math.max(maxGrumpySatisfied, grumpySatisfied);\\n  }\\n  \\n  return satisfied + maxGrumpySatisfied;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262781,
                "title": "make-things-simple-and-easy-c-sliding-window",
                "content": "```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n            if(grumpy[i]==0){\\n                ans+=customers[i];\\n                customers[i]=0;\\n            }\\n        }\\n        \\n        \\n        int slide=0;\\n        \\n        for(int i=0;i<minutes;i++){\\n            slide+=customers[i];\\n        }\\n        \\n        int finalanstoadd=slide;\\n        \\n        \\n        for(int i=minutes;i<customers.size();i++){\\n            \\n            slide+=customers[i];\\n            slide-=customers[i- minutes];\\n            finalanstoadd=max(slide,finalanstoadd);\\n        }\\n        \\n        \\n        return finalanstoadd +  ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        \\n        \\n        int ans=0;\\n        \\n        for(int i=0;i<customers.size();i++){\\n            \\n            if(grumpy[i]==0){\\n                ans+=customers[i];\\n                customers[i]=0;\\n            }\\n        }\\n        \\n        \\n        int slide=0;\\n        \\n        for(int i=0;i<minutes;i++){\\n            slide+=customers[i];\\n        }\\n        \\n        int finalanstoadd=slide;\\n        \\n        \\n        for(int i=minutes;i<customers.size();i++){\\n            \\n            slide+=customers[i];\\n            slide-=customers[i- minutes];\\n            finalanstoadd=max(slide,finalanstoadd);\\n        }\\n        \\n        \\n        return finalanstoadd +  ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133627,
                "title": "easy-to-understand-java-solution-100-faster",
                "content": "Calculate the number of customers when the owner is grumpy for each sliding window of size X and store the max in that case and when the owner is not grumpy just include that in your answer.\\n\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        int max_index = 0;\\n        int count_cust=0;\\n        int max_cust=0;\\n        int cust=0;\\n         while(j<customers.length){\\n           \\n            if(grumpy[j]==1){\\n                count_cust+=customers[j];\\n            } else{\\n                cust+=customers[j];\\n            }\\n            if(j-i+1==X){\\n                if(count_cust>max_cust){\\n                    max_index=i;\\n                    max_cust=count_cust;\\n                }\\n                if(grumpy[i]==1)\\n                    count_cust-=customers[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n     \\n        \\n        return cust+max_cust;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        \\n        int i=0;\\n        int j=0;\\n        int max_index = 0;\\n        int count_cust=0;\\n        int max_cust=0;\\n        int cust=0;\\n         while(j<customers.length){\\n           \\n            if(grumpy[j]==1){\\n                count_cust+=customers[j];\\n            } else{\\n                cust+=customers[j];\\n            }\\n            if(j-i+1==X){\\n                if(count_cust>max_cust){\\n                    max_index=i;\\n                    max_cust=count_cust;\\n                }\\n                if(grumpy[i]==1)\\n                    count_cust-=customers[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n     \\n        \\n        return cust+max_cust;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380296,
                "title": "python-3-6-lines-w-example-t-m-100-88",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n\\n                                                        #   Example: customers = [1,0,2,7,5]\\n                                                        #               grumpy = [0,1,1,0,1]\\n                                                        #              minutes = 3\\n                                                        #     \\n       z = list(map(mul, customers, grumpy))            #      z = [1*0,0*1,2*1,7*0,5*1] = [0,0,2,0,5]\\n\\n        ans = score = sum(customers) - sum(z[minutes:]) #  ans = score = sum([1,0,2,7,5]) - sum([0,5]) = 10\\n\\n        for i in range(len(grumpy) - minutes):          #  i   score           ans\\n            score+= z[i+minutes] - z[i]                 # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\n            ans = max(ans, score)                       #                       10\\n                                                        #  0    10+0-0          10\\n        return ans                                      #  1    10+5-0          15  <--return\\n```\\n[https://leetcode.com/problems/grumpy-bookstore-owner/submissions/1007973320/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n\\n                                                        #   Example: customers = [1,0,2,7,5]\\n                                                        #               grumpy = [0,1,1,0,1]\\n                                                        #              minutes = 3\\n                                                        #     \\n       z = list(map(mul, customers, grumpy))            #      z = [1*0,0*1,2*1,7*0,5*1] = [0,0,2,0,5]\\n\\n        ans = score = sum(customers) - sum(z[minutes:]) #  ans = score = sum([1,0,2,7,5]) - sum([0,5]) = 10\\n\\n        for i in range(len(grumpy) - minutes):          #  i   score           ans\\n            score+= z[i+minutes] - z[i]                 # \\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013     \\u2013\\u2013\\u2013\\n            ans = max(ans, score)                       #                       10\\n                                                        #  0    10+0-0          10\\n        return ans                                      #  1    10+5-0          15  <--return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668754,
                "title": "java-1-ms-sliding-window-beats-100",
                "content": "First in sum i have calculated total satisfied customers and then changed grumpy[i] with their customer weight ( customer[i]*grumpy[i] ) and after sliding window for minutes checked which window gives maximum value.\\n:)\\n\\n        int sum = 0;\\n        \\n        int n = customers.length;\\n        for(int i = 0; i < n; i++) {\\n            sum = sum + customers[i] * (1-grumpy[i]);\\n            grumpy[i] = customers[i] * grumpy[i];\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < minutes; i++) {\\n            max += grumpy[i];\\n        }\\n            \\n        int save = max;\\n        for(int i = minutes; i < n; i++) {\\n            save = save + grumpy[i] - grumpy[i-minutes];\\n            max = save > max ? save : max;\\n        }\\n        \\n        return sum + max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "First in sum i have calculated total satisfied customers and then changed grumpy[i] with their customer weight ( customer[i]*grumpy[i] ) and after sliding window for minutes checked which window gives maximum value.\\n:)\\n\\n        int sum = 0;\\n        \\n        int n = customers.length;\\n        for(int i = 0; i < n; i++) {\\n            sum = sum + customers[i] * (1-grumpy[i]);\\n            grumpy[i] = customers[i] * grumpy[i];\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i < minutes; i++) {\\n            max += grumpy[i];\\n        }\\n            \\n        int save = max;\\n        for(int i = minutes; i < n; i++) {\\n            save = save + grumpy[i] - grumpy[i-minutes];\\n            max = save > max ? save : max;\\n        }\\n        \\n        return sum + max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1586972,
                "title": "c-one-pass-sliding-window-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        int directly_satisfied=0;\\n        int indirectly_satisfied=0;\\n        int max_indirectly_satisfied = INT_MIN;\\n        int i=0,j=0;\\n        while(j<customers.size())\\n        {   \\n            if(grumpy[j]==0) \\n            {\\n\\t\\t\\t\\tdirectly_satisfied+=customers[j];\\n\\t\\t\\t\\tcustomers[j] = 0;\\n\\t\\t\\t}\\n            \\n            indirectly_satisfied+=customers[j];\\n            \\n            int k=j-i+1; //window size\\n            \\n            if(k<minutes) \\n                j++;\\n            else if(k==minutes)\\n            {\\n                max_indirectly_satisfied= max(max_indirectly_satisfied,indirectly_satisfied);\\n                indirectly_satisfied-=customers[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return max_indirectly_satisfied + directly_satisfied;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        int directly_satisfied=0;\\n        int indirectly_satisfied=0;\\n        int max_indirectly_satisfied = INT_MIN;\\n        int i=0,j=0;\\n        while(j<customers.size())\\n        {   \\n            if(grumpy[j]==0) \\n            {\\n\\t\\t\\t\\tdirectly_satisfied+=customers[j];\\n\\t\\t\\t\\tcustomers[j] = 0;\\n\\t\\t\\t}\\n            \\n            indirectly_satisfied+=customers[j];\\n            \\n            int k=j-i+1; //window size\\n            \\n            if(k<minutes) \\n                j++;\\n            else if(k==minutes)\\n            {\\n                max_indirectly_satisfied= max(max_indirectly_satisfied,indirectly_satisfied);\\n                indirectly_satisfied-=customers[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return max_indirectly_satisfied + directly_satisfied;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215558,
                "title": "very-easy-solution",
                "content": "Steps:\\n1. find total sum of satisfied customers;\\n2. find maximum sum of unsatisfied customers in between the range of minutes;\\n3. add both the sums;\\n\\nDo upvote \\uD83D\\uDE00\\n\\n\\n```\\nclass Solution \\n{\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) \\n    {\\n        // sum of satisfied customers\\n         int satisfiedCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                satisfiedCustomers += customers[i];\\n            } \\n        }\\n        \\n        \\n        int max  = 0;\\n        for(int i=0;i<customers.length-minutes+1;i++)\\n        {\\n            int maxUnsatisfied = 0;\\n            int j = i;\\n            while(j<i+minutes)\\n            {\\n                if(grumpy[j] == 0)\\n                    j++;\\n                else\\n                    maxUnsatisfied += customers[j++];\\n            }\\n            if(max < maxUnsatisfied)\\n                max = maxUnsatisfied;\\n        }\\n        return satisfiedCustomers+max;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) \\n    {\\n        // sum of satisfied customers\\n         int satisfiedCustomers = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                satisfiedCustomers += customers[i];\\n            } \\n        }\\n        \\n        \\n        int max  = 0;\\n        for(int i=0;i<customers.length-minutes+1;i++)\\n        {\\n            int maxUnsatisfied = 0;\\n            int j = i;\\n            while(j<i+minutes)\\n            {\\n                if(grumpy[j] == 0)\\n                    j++;\\n                else\\n                    maxUnsatisfied += customers[j++];\\n            }\\n            if(max < maxUnsatisfied)\\n                max = maxUnsatisfied;\\n        }\\n        return satisfiedCustomers+max;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 728759,
                "title": "python3-concise-sliding-window",
                "content": "**Explanation**\\n* Sum up first X customers with the secret technique: \\n`max_gains = gains = sum(grumpy[i] * customers[i] for i in range(X))`\\n* Sum up first X satisfied customers: \\n`total = sum((grumpy[i] == 0) * customers[i] for i in range(X))`\\n* Iteration starts from the index X: \\n`for i in range(X, len(customers))`\\n* Add satisfied customers to total: \\n`total += (grumpy[i] == 0) * customers[i]`\\n* Sliding Wondow, add the right one and deduct the left one:\\n`gains += grumpy[i] * customers[i] - grumpy[i - X] * customers[i - X]`\\n* Update the max customers with the secret techinque:\\n`max_gains = max(max_gains, gains)`\\n* Return results: \\n`total + max_gains`\\n\\n**Complexcity**\\n* Time: O(n)\\n* Space: O(1)\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        max_gains = gains = sum(grumpy[i] * customers[i] for i in range(X))\\n        total = sum((grumpy[i] == 0) * customers[i] for i in range(X))\\n        for i in range(X, len(customers)):\\n            total += (grumpy[i] == 0) * customers[i]\\n            gains += grumpy[i] * customers[i] - grumpy[i - X] * customers[i - X]\\n            max_gains = max(max_gains, gains)\\n        return total + max_gains\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        max_gains = gains = sum(grumpy[i] * customers[i] for i in range(X))\\n        total = sum((grumpy[i] == 0) * customers[i] for i in range(X))\\n        for i in range(X, len(customers)):\\n            total += (grumpy[i] == 0) * customers[i]\\n            gains += grumpy[i] * customers[i] - grumpy[i - X] * customers[i - X]\\n            max_gains = max(max_gains, gains)\\n        return total + max_gains\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294626,
                "title": "detailed-explanation-o-n-time-o-1-space",
                "content": "# Intuition & Approach\\n- A window of size=minutes but only considering the custumer[i] if (grumpy[i]==1)\\n- And then added to a sum of all the custumer[i] with (grumpy[i]==0)\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& cus, vector<int>& grumpy, int minutes) {\\n        \\n        int sum =0; \\n        int start=0;\\n        int ans =0;\\n        for (int i=0;i<cus.size(); i++){\\n            if (grumpy[i]==1){\\n                sum += cus[i];\\n            }\\n            if (i-start+1==minutes){\\n                ans = max(sum, ans);\\n                if (grumpy[start]==1){\\n                    sum -= cus[start];\\n                }\\n                start++;\\n            }\\n        }\\n        for (int i=0; i<cus.size(); i++){\\n            if (grumpy[i]==0){\\n                ans += cus[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& cus, vector<int>& grumpy, int minutes) {\\n        \\n        int sum =0; \\n        int start=0;\\n        int ans =0;\\n        for (int i=0;i<cus.size(); i++){\\n            if (grumpy[i]==1){\\n                sum += cus[i];\\n            }\\n            if (i-start+1==minutes){\\n                ans = max(sum, ans);\\n                if (grumpy[start]==1){\\n                    sum -= cus[start];\\n                }\\n                start++;\\n            }\\n        }\\n        for (int i=0; i<cus.size(); i++){\\n            if (grumpy[i]==0){\\n                ans += cus[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437395,
                "title": "step-by-step-easiest-approach-using-sliding-window-technique-c",
                "content": "**Grumpy Bookstore owner**\\n\\nWe have given an array *customers[]* and *grumpy[]* where, \\n1) customer[]: specifies the number of customers visiting to the bookstore.  \\n2) When bookstore owner is present at the bookstore, he may or may not be grumpy for some time.\\n\\nLet us breakdown the problem and understand the problem first,\\n**We** have given that whenever a particular customer visits to the bookstore, the bookstore owner may or may not be grumpy at that time. If the bookstore owner is grumpy for example- ith customer (i=5) visits the bookstore and at that time bookstore owner is grumpy i.e **grumpy[5]=1** and the customer(i=5) is not satisfied. If at a particular index or time, the owner is not grumpy then **grumpy[i]=0** the customer get satisfied.\\n\\nThe problem statement says that we have given `minutes` for which the bookstore owner is not grumpy and all the customer that visit the bookstore within that minute get satisfied. We have to calculate the total number (max number) of customers that get satisfied.\\n\\nTo approach this problem, we can simply use the *Sliding Window Technique* in which we have given a value `minutes` and we have to calculate the max number of satisfied customer within that window(minutes).\\n\\n**Algorithm**\\n\\n1) Find the total satisfied customer by finding if the owner is not grumpy ( **grumpy[i]=0**).\\n2) Take a left and right pointer to calculate all the satisfied customer in the given `minutes`.\\n3) Calculating the satisfied customer when the owner is grumpy( **grumpy[i]==1**) in the given `minutes`. Cause in the given `minute` the owner uses the secret technique to satisfy the customer.\\n4) Contract the window by excluding the unsatisfied customer from the left.\\n5) Expand the window by including the satisfied customer from the right. (Where right will be `minutes`)\\n2) Return the total satisfied customer.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n         int satisfied=0;\\n         int n= customers.size();\\n         for(int i=0;i<n;i++){\\n            if(grumpy[i]==0)\\n                satisfied+= customers[i];\\n          }\\n        int additionalsatisfied= 0; \\n        int left=0;\\n        int right= minutes;\\n        for(int i=0;i<minutes;i++){\\n            if(grumpy[i]==1)\\n            {\\n                additionalsatisfied+= customers[i];\\n            }\\n        }\\n        int maxx= additionalsatisfied;\\n        while(right<n){\\n            if(grumpy[right]==1){\\n                additionalsatisfied+= customers[right]; /* If the satisfied customer found, then include in the given window or minute.*/\\n            }\\n            if(grumpy[left]==1){\\n                additionalsatisfied-= customers[left]; /*If the unsatisfied customers found, then exclude from the window*/\\n            }\\n            maxx= max(maxx, additionalsatisfied);\\n         left++;\\n        right++;\\n            }\\n        \\n        return satisfied+maxx;\\n    }\\n};\\n```\\n\\n(Thumbs up if you liked this solution)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n         int satisfied=0;\\n         int n= customers.size();\\n         for(int i=0;i<n;i++){\\n            if(grumpy[i]==0)\\n                satisfied+= customers[i];\\n          }\\n        int additionalsatisfied= 0; \\n        int left=0;\\n        int right= minutes;\\n        for(int i=0;i<minutes;i++){\\n            if(grumpy[i]==1)\\n            {\\n                additionalsatisfied+= customers[i];\\n            }\\n        }\\n        int maxx= additionalsatisfied;\\n        while(right<n){\\n            if(grumpy[right]==1){\\n                additionalsatisfied+= customers[right]; /* If the satisfied customer found, then include in the given window or minute.*/\\n            }\\n            if(grumpy[left]==1){\\n                additionalsatisfied-= customers[left]; /*If the unsatisfied customers found, then exclude from the window*/\\n            }\\n            maxx= max(maxx, additionalsatisfied);\\n         left++;\\n        right++;\\n            }\\n        \\n        return satisfied+maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442760,
                "title": "python-sliding-window-w-explanation-9-lines-memory-better-than-100",
                "content": "*i* is the start of the window, *j* is the end. Only increase *i* if the max window length has been reached. Keep track of the maximum newly satisfied so far and finally return the sum of the originaly satisfied and maximum newly satisfied.\\n```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, X):\\n        i = original_satisfied = new_satisfied = max_new_satisfied = 0\\n        for j in range(len(customers)):\\n            original_satisfied += customers[j] * (not grumpy[j])\\n            new_satisfied += customers[j] * grumpy[j]                        \\n            if j - i == X:\\n                new_satisfied -= customers[i] * grumpy[i]\\n                i += 1\\n            max_new_satisfied = max(max_new_satisfied, new_satisfied)\\n        return original_satisfied + max_new_satisfied\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, X):\\n        i = original_satisfied = new_satisfied = max_new_satisfied = 0\\n        for j in range(len(customers)):\\n            original_satisfied += customers[j] * (not grumpy[j])\\n            new_satisfied += customers[j] * grumpy[j]                        \\n            if j - i == X:\\n                new_satisfied -= customers[i] * grumpy[i]\\n                i += 1\\n            max_new_satisfied = max(max_new_satisfied, new_satisfied)\\n        return original_satisfied + max_new_satisfied\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441491,
                "title": "python-97-easy-to-understand-sliding-window-with-comments",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        # a sliding window approach\\n        currsum = 0\\n        # first store the sum as if the owner has no super power\\n        for i in range(len(grumpy)):\\n            if not grumpy[i]:\\n                currsum += customers[i]\\n        \\n        # now assuming he has the power, take the first window \\n        # and add to the previous sum\\n        for i in range(X):\\n            if grumpy[i]:\\n                currsum += customers[i]\\n        \\n        maxsum = currsum\\n        \\n        # Now the sliding window starts\\n        # i and j are the two opposite ends of the window\\n        i = 0\\n        j = X\\n        while j < len(customers):\\n            if grumpy[j]:\\n                currsum += customers[j]\\n            if grumpy[i]:\\n                currsum -= customers[i]\\n\\t\\t\\t# we subtract above as the window has already passed over that customer\\n            if currsum > maxsum:\\n                maxsum = currsum\\n            i += 1\\n            j += 1\\n        return maxsum\\n```\\n\\nCredits to this medium post: https://medium.com/@saurav.agg19/grumpy-bookstore-owner-sliding-window-problem-cff215a7b28c",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        # a sliding window approach\\n        currsum = 0\\n        # first store the sum as if the owner has no super power\\n        for i in range(len(grumpy)):\\n            if not grumpy[i]:\\n                currsum += customers[i]\\n        \\n        # now assuming he has the power, take the first window \\n        # and add to the previous sum\\n        for i in range(X):\\n            if grumpy[i]:\\n                currsum += customers[i]\\n        \\n        maxsum = currsum\\n        \\n        # Now the sliding window starts\\n        # i and j are the two opposite ends of the window\\n        i = 0\\n        j = X\\n        while j < len(customers):\\n            if grumpy[j]:\\n                currsum += customers[j]\\n            if grumpy[i]:\\n                currsum -= customers[i]\\n\\t\\t\\t# we subtract above as the window has already passed over that customer\\n            if currsum > maxsum:\\n                maxsum = currsum\\n            i += 1\\n            j += 1\\n        return maxsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299281,
                "title": "java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int maxGrumpy = 0;\\n        int happy =0;\\n        int g=0;\\n        for(int i=0;i<customers.length;i++) {\\n            if(i>=X) {\\n                g = g - (customers[i-X] * grumpy[i-X]);\\n            } \\n            g += (customers[i] * grumpy[i]);\\n            maxGrumpy = Math.max(maxGrumpy, g);\\n            if(grumpy[i] == 0) {\\n                happy+=customers[i];\\n            }\\n        }\\n        happy += maxGrumpy;\\n        return happy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int maxGrumpy = 0;\\n        int happy =0;\\n        int g=0;\\n        for(int i=0;i<customers.length;i++) {\\n            if(i>=X) {\\n                g = g - (customers[i-X] * grumpy[i-X]);\\n            } \\n            g += (customers[i] * grumpy[i]);\\n            maxGrumpy = Math.max(maxGrumpy, g);\\n            if(grumpy[i] == 0) {\\n                happy+=customers[i];\\n            }\\n        }\\n        happy += maxGrumpy;\\n        return happy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851886,
                "title": "0-n-approach-clean-and-readable-commented-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- maximize finding correct position for  secret technique  minutes.\\n- for getting  maximum  no. of customer satisfy in that secret technique minute when owner is grumpy \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sliding window \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 0(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n = customers.size();\\n\\n//------------ base case when minutes >= n -------------------------------//\\n     if( n<= minutes){\\n          int sum =0; \\n          for( int i =0; i<n; i++) sum += customers[i];\\n          return sum ;\\n     }\\n\\n\\n         vector<int>grumpyTrack(n ,0); \\n\\n//----------------store the customer who visit when owner is grumpy------------------//\\n         int sum =0;\\n      for(int i =0; i<n; i++){\\n           if(grumpy[i]==1){\\n          grumpyTrack[i]= customers[i];\\n           }\\n        \\n      }\\n\\n//---------fix sliding window -----------------//\\n\\n//-- this for maximize no. of customer satisfy  using secret technique when owner  is grumpy ---------//\\n\\nint i =0 , j = minutes-1; \\n int  maximumSatisfaction    = 0;\\n\\nfor( int k=i; k<=j ; k++){\\n     sum += grumpyTrack[k];\\n}\\n\\nint timeStart =0 , timeEnd = 0; \\n\\nif( maximumSatisfaction < sum  ){\\nmaximumSatisfaction  = sum ; \\ntimeStart = i; \\ntimeEnd = j;\\n}\\nj++;\\n\\nwhile( j<n){\\nsum -= grumpyTrack[i];\\ni++;\\n\\nsum += grumpyTrack[j];\\nif( maximumSatisfaction  < sum  ){\\nmaximumSatisfaction  = sum ; \\ntimeStart = i; \\ntimeEnd = j;\\n}\\nj++;\\n}\\n\\n// finding ans -----------//\\nint answer = 0; \\n\\nfor( int k=0; k<timeStart; k++){\\n     if( grumpy[k]==0) answer += customers[k]; \\n}\\n\\nfor( int k =timeStart ; k<=timeEnd; k++ ) answer += customers[k];\\n\\n\\nfor( int k=timeEnd+1; k<n; k++){\\n     if( grumpy[k]==0) answer += customers[k]; \\n}\\n\\n\\n\\n\\nreturn answer;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n = customers.size();\\n\\n//------------ base case when minutes >= n -------------------------------//\\n     if( n<= minutes){\\n          int sum =0; \\n          for( int i =0; i<n; i++) sum += customers[i];\\n          return sum ;\\n     }\\n\\n\\n         vector<int>grumpyTrack(n ,0); \\n\\n//----------------store the customer who visit when owner is grumpy------------------//\\n         int sum =0;\\n      for(int i =0; i<n; i++){\\n           if(grumpy[i]==1){\\n          grumpyTrack[i]= customers[i];\\n           }\\n        \\n      }\\n\\n//---------fix sliding window -----------------//\\n\\n//-- this for maximize no. of customer satisfy  using secret technique when owner  is grumpy ---------//\\n\\nint i =0 , j = minutes-1; \\n int  maximumSatisfaction    = 0;\\n\\nfor( int k=i; k<=j ; k++){\\n     sum += grumpyTrack[k];\\n}\\n\\nint timeStart =0 , timeEnd = 0; \\n\\nif( maximumSatisfaction < sum  ){\\nmaximumSatisfaction  = sum ; \\ntimeStart = i; \\ntimeEnd = j;\\n}\\nj++;\\n\\nwhile( j<n){\\nsum -= grumpyTrack[i];\\ni++;\\n\\nsum += grumpyTrack[j];\\nif( maximumSatisfaction  < sum  ){\\nmaximumSatisfaction  = sum ; \\ntimeStart = i; \\ntimeEnd = j;\\n}\\nj++;\\n}\\n\\n// finding ans -----------//\\nint answer = 0; \\n\\nfor( int k=0; k<timeStart; k++){\\n     if( grumpy[k]==0) answer += customers[k]; \\n}\\n\\nfor( int k =timeStart ; k<=timeEnd; k++ ) answer += customers[k];\\n\\n\\nfor( int k=timeEnd+1; k<n; k++){\\n     if( grumpy[k]==0) answer += customers[k]; \\n}\\n\\n\\n\\n\\nreturn answer;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697558,
                "title": "easy-c-solution-simple-approach-with-explanation-o-n-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int sum = 0, mx = 0, unsat = 0;\\n        for(int i=0; i<customers.size(); i++){\\n            sum += customers[i];  //Total customers\\n            customers[i] *= grumpy[i]; \\n            unsat += customers[i]; // Toal customers when shopkeeper is grumpy\\n        }\\n        for(int i=0; i<=customers.size()-minutes; i++)\\n        {\\n            int k = minutes, count = 0, j = i;\\n            while(k--)\\n                count += customers[j++]; \\n            if(count>mx)\\n                mx = count; // Maximum customers coming in the minutes window when shopkeeper can control themself\\n        }\\n    return sum - unsat + mx; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int sum = 0, mx = 0, unsat = 0;\\n        for(int i=0; i<customers.size(); i++){\\n            sum += customers[i];  //Total customers\\n            customers[i] *= grumpy[i]; \\n            unsat += customers[i]; // Toal customers when shopkeeper is grumpy\\n        }\\n        for(int i=0; i<=customers.size()-minutes; i++)\\n        {\\n            int k = minutes, count = 0, j = i;\\n            while(k--)\\n                count += customers[j++]; \\n            if(count>mx)\\n                mx = count; // Maximum customers coming in the minutes window when shopkeeper can control themself\\n        }\\n    return sum - unsat + mx; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657372,
                "title": "java-sliding-window",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt First, find out the maximum window sum of size `minutes` where `grumpy[i] = 1`\\nThen, find the $$totalSum $$where `grumpy[i] = 0` from index 0 to n - 1.\\nAt last, return `maximum window sum + totalSum`\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maxWhenGrumpy(int[] cust, int[] g, int k) {\\n        int maxi = 0, i = 0, sum = 0, j = 0, n = cust.length;\\n        while (i < k) {\\n            if (g[i] == 1)\\n                sum += cust[i];\\n            i++;\\n        }\\n        maxi = Math.max(maxi, sum);\\n\\n        while (i < n) {\\n            if (g[j] == 1)\\n                sum -= cust[j];\\n            if (g[i] == 1)\\n                sum += cust[i];\\n            maxi = Math.max(maxi, sum);\\n            i++;\\n            j++;\\n        }\\n        return maxi;\\n\\n    }\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int max = 0, n = customers.length;\\n        max = maxWhenGrumpy(customers, grumpy, minutes);\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (grumpy[i] == 0)\\n                sum += customers[i];\\n        }\\n        return max + sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxWhenGrumpy(int[] cust, int[] g, int k) {\\n        int maxi = 0, i = 0, sum = 0, j = 0, n = cust.length;\\n        while (i < k) {\\n            if (g[i] == 1)\\n                sum += cust[i];\\n            i++;\\n        }\\n        maxi = Math.max(maxi, sum);\\n\\n        while (i < n) {\\n            if (g[j] == 1)\\n                sum -= cust[j];\\n            if (g[i] == 1)\\n                sum += cust[i];\\n            maxi = Math.max(maxi, sum);\\n            i++;\\n            j++;\\n        }\\n        return maxi;\\n\\n    }\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int max = 0, n = customers.length;\\n        max = maxWhenGrumpy(customers, grumpy, minutes);\\n        int sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (grumpy[i] == 0)\\n                sum += customers[i];\\n        }\\n        return max + sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409048,
                "title": "sliding-window-explaination",
                "content": "The code starts by calculating the total number of customers satisfied when the owner is not grumpy.\\n\\nNext, a sliding window approach is used to iterate through all possible time periods of length \"minutes\". For each window, the total number of satisfied customers is calculated by subtracting the unsatisfied customers during grumpy periods (gSum) from the current window\\'s customer sum (curSum) and adding the previously calculated total number of satisfied customers (totalSum). The maximum number of satisfied customers across all windows is recorded and returned at the end.\\n\\nThe sliding window technique is efficient because it avoids recalculating the sum of customers for each new window. Instead, it subtracts the departing customer(s) from the current window and adds the arriving customer(s) to the current window. The grumpy period is taken into account by subtracting the unsatisfied customers during grumpy periods from the total customer sum.\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n        int i=0,j=0,curSum=0,totalSum=0,gSum=0,max=-1;\\n        for(int k=0;k<customers.length;k++){               // calculate total no of customers satisfied\\n            if(grumpy[k] == 0)                            \\n                totalSum += customers[k];\\n        }\\n\\n // you will be maintaining two sum, one is currSum means total sum of window\\n // another sum is gSum which means total window sum when owner is not grumpy\\n        while(j < customers.length){           \\n            curSum += customers[j];             // \\n            if(grumpy[j] == 0)\\n                gSum += customers[j];\\n            \\n            //every time you slide the window, update max\\n            if(j-i+1 == minutes){\\n                max = Math.max(max,totalSum-gSum+curSum);\\n                curSum -= customers[i];                  // update current window sum\\n                if(grumpy[i] == 0)                        //update currenst gSum \\n                    gSum -= customers[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n        int i=0,j=0,curSum=0,totalSum=0,gSum=0,max=-1;\\n        for(int k=0;k<customers.length;k++){               // calculate total no of customers satisfied\\n            if(grumpy[k] == 0)                            \\n                totalSum += customers[k];\\n        }\\n\\n // you will be maintaining two sum, one is currSum means total sum of window\\n // another sum is gSum which means total window sum when owner is not grumpy\\n        while(j < customers.length){           \\n            curSum += customers[j];             // \\n            if(grumpy[j] == 0)\\n                gSum += customers[j];\\n            \\n            //every time you slide the window, update max\\n            if(j-i+1 == minutes){\\n                max = Math.max(max,totalSum-gSum+curSum);\\n                curSum -= customers[i];                  // update current window sum\\n                if(grumpy[i] == 0)                        //update currenst gSum \\n                    gSum -= customers[i];\\n                i++;\\n            }\\n            j++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695447,
                "title": "java-t-o-n-s-o-1-100-100-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int s=0;\\n        int e=minutes;\\n        int sum=0;\\n        for(int i=0; i<customers.length; i++) if(grumpy[i]==0) sum+=customers[i];\\n        int tot=0;\\n        for(int i=0; i<e; i++) if(grumpy[i]==1) tot+=customers[i];\\n        int n_tot=tot;\\n        for(int i=0; i<customers.length-minutes; i++){\\n            System.out.println(tot);\\n            if(grumpy[s]==1) n_tot-=customers[s];\\n            if(grumpy[e]==1) n_tot+=customers[e];\\n            tot=Math.max(tot, n_tot);\\n            s++;\\n            e++;\\n        }\\n        System.out.println(tot);\\n        return sum+tot;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int s=0;\\n        int e=minutes;\\n        int sum=0;\\n        for(int i=0; i<customers.length; i++) if(grumpy[i]==0) sum+=customers[i];\\n        int tot=0;\\n        for(int i=0; i<e; i++) if(grumpy[i]==1) tot+=customers[i];\\n        int n_tot=tot;\\n        for(int i=0; i<customers.length-minutes; i++){\\n            System.out.println(tot);\\n            if(grumpy[s]==1) n_tot-=customers[s];\\n            if(grumpy[e]==1) n_tot+=customers[e];\\n            tot=Math.max(tot, n_tot);\\n            s++;\\n            e++;\\n        }\\n        System.out.println(tot);\\n        return sum+tot;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2481497,
                "title": "c-best-solution-100-faster-explanation",
                "content": "***Time Complexity : O(N)\\nSpace Complexity : O(N)\\nIntuition :***\\nSo , Basic intuition should be :\\n1. ) We need to know the total  satisfied  customers before performing any flip(1->0) operations.\\n2. ) We check for sliding windows by iterating in a for loop , and perform atmost ***minutes** flips and then calculate the satisfied customers.\\n3. ) We need to find the which sliding window gives us the maximum number of ***total*** satisfied customers.\\n**NOTE :** ( we use ***sliding window*** here because we are asked to flip only ***consecutive*** values )\\n\\n***Process :***\\nFirst we calculate the total satisfied customers before performing any flips .\\nIn second loop ,we increment satisfied customers number of we  encounter 0 and size of window < minutes\\nIf size becomes > minutes, we decrement last of sliding window from satisfied customers ***only if*** , the last is 0.\\nThen we find maxSatisfied  as max from the current satisfied and maxsatisfied.\\n**UPVOTE IF YOU LIKE** \\uD83D\\uDE07\\u2705\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=grumpy.size();\\n        int satisfied=0,size=0;\\n        for(int i=0;i<n;i++){ if(grumpy[i]==0)satisfied+=customers[i]; }\\n\\t\\t\\n        int maxSatisfied=satisfied;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1)satisfied+=customers[i];\\n            size++;\\n            if(size>minutes){\\n                if(grumpy[i-minutes]==1)satisfied-=customers[i-minutes];\\n                size--;\\n            }\\n            maxSatisfied=max(satisfied,maxSatisfied);\\n        }\\n        return maxSatisfied;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=grumpy.size();\\n        int satisfied=0,size=0;\\n        for(int i=0;i<n;i++){ if(grumpy[i]==0)satisfied+=customers[i]; }\\n\\t\\t\\n        int maxSatisfied=satisfied;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1)satisfied+=customers[i];\\n            size++;\\n            if(size>minutes){\\n                if(grumpy[i-minutes]==1)satisfied-=customers[i-minutes];\\n                size--;\\n            }\\n            maxSatisfied=max(satisfied,maxSatisfied);\\n        }\\n        return maxSatisfied;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890002,
                "title": "c-simple-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int sum = 0; \\n        for(int i = 0;i<k;i++) {\\n            sum += customers[i] * grumpy[i];\\n        }\\n        int t = sum; \\n        for(int i = k;i<customers.size();i++) {\\n            sum += customers[i] * grumpy[i];\\n            sum -= customers[i-k] * grumpy[i-k];\\n            t = max(t,sum);\\n        }\\n        sum = 0; \\n        for(int i = 0;i<customers.size();i++) {\\n            sum += customers[i] * (1- grumpy[i]);\\n        }\\n        return sum + t; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int sum = 0; \\n        for(int i = 0;i<k;i++) {\\n            sum += customers[i] * grumpy[i];\\n        }\\n        int t = sum; \\n        for(int i = k;i<customers.size();i++) {\\n            sum += customers[i] * grumpy[i];\\n            sum -= customers[i-k] * grumpy[i-k];\\n            t = max(t,sum);\\n        }\\n        sum = 0; \\n        for(int i = 0;i<customers.size();i++) {\\n            sum += customers[i] * (1- grumpy[i]);\\n        }\\n        return sum + t; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764702,
                "title": "sliding-window-with-basic-concepts",
                "content": "Dont panic question is easy af just you have to take all customers who are not facing that grumpy face and imortant step is will make them equal to zero so we will not add them in future. let add their sum in \"DIRECT\" variable.  After that we will come with our approach sliding window here, we have to make window of minutes size and store the maximum in variable \"INDIRECT\" now, add INDIRECT AND DIRECT\\nBOOM!! YOUR ANSWER\\nIf you like the solution, upvote!!\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int direct = 0, indirect = 0;\\n        for(int i = 0;i<customers.size();i++)\\n        {\\n            if(!grumpy[i]) \\n            {\\n                direct+=customers[i];\\n                customers[i] = 0;\\n            }\\n        }\\n        int j = 0;\\n        for( j = 0;j<minutes;j++)\\n        {\\n            indirect+=customers[j];\\n        }\\n        int curr = indirect;\\n        while(j<customers.size())\\n        {\\n            curr += customers[j];\\n            curr -= customers[j-minutes];\\n            indirect = max(indirect, curr);\\n            j++;\\n        }\\n        return indirect+direct;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int direct = 0, indirect = 0;\\n        for(int i = 0;i<customers.size();i++)\\n        {\\n            if(!grumpy[i]) \\n            {\\n                direct+=customers[i];\\n                customers[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1712076,
                "title": "sliding-window-rolling-sum-python-3",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        satisfied=0\\n        n=len(grumpy)\\n        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])\\n        max_satisfied=satisfied\\n        for i in range(n):\\n            if grumpy[i]==1: satisfied+=customers[i]    \\n            if i>=minutes:\\n                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]\\n            max_satisfied=max(satisfied,max_satisfied)\\n        return max_satisfied\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        satisfied=0\\n        n=len(grumpy)\\n        satisfied=sum([customers[i]*(1-grumpy[i]) for i in range(n)])\\n        max_satisfied=satisfied\\n        for i in range(n):\\n            if grumpy[i]==1: satisfied+=customers[i]    \\n            if i>=minutes:\\n                if grumpy[i-minutes]==1: satisfied-=customers[i-minutes]\\n            max_satisfied=max(satisfied,max_satisfied)\\n        return max_satisfied\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1580210,
                "title": "easy-for-beginers-sliding-window-problem-faster-than-94",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        n = len(customers)\\n        res = 0\\n        for i in range(n):\\n            if grumpy[i] == 0:\\n                res += customers[i]\\n        sum1 = 0        \\n        for i in range(minutes):\\n            if grumpy[i] == 1:\\n                sum1 += customers[i]\\n                \\n        result = sum1\\n        for r in range(minutes, n):\\n            if grumpy[r] == 1:\\n                sum1 += customers[r]\\n            if grumpy[r - minutes] == 1:\\n                sum1 -= customers[r - minutes]\\n            result = max(sum1, result)\\n        \\n        return res + result \\n\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        n = len(customers)\\n        res = 0\\n        for i in range(n):\\n            if grumpy[i] == 0:\\n                res += customers[i]\\n        sum1 = 0        \\n        for i in range(minutes):\\n            if grumpy[i] == 1:\\n                sum1 += customers[i]\\n                \\n        result = sum1\\n        for r in range(minutes, n):\\n            if grumpy[r] == 1:\\n                sum1 += customers[r]\\n            if grumpy[r - minutes] == 1:\\n                sum1 -= customers[r - minutes]\\n            result = max(sum1, result)\\n        \\n        return res + result \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557204,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxSatisfied(vector<int> &customers, vector<int> &grumpy, int minutes)\\n    {\\n        int count = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < grumpy.size(); i++)\\n        {\\n            if (grumpy[i] == 0)\\n            {\\n                count += customers[i];\\n            }\\n        }\\n\\n        int n = grumpy.size() - minutes + 1;\\n\\n        int c = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < i + minutes - 1; j++)\\n            {\\n                if (grumpy[j] == 1)\\n                {\\n                    c += customers[j];\\n                }\\n            }\\n            maxi = max(maxi, c);\\n            c = 0;\\n        }\\n\\n        return count + maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxSatisfied(vector<int> &customers, vector<int> &grumpy, int minutes)\\n    {\\n        int count = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < grumpy.size(); i++)\\n        {\\n            if (grumpy[i] == 0)\\n            {\\n                count += customers[i];\\n            }\\n        }\\n\\n        int n = grumpy.size() - minutes + 1;\\n\\n        int c = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < i + minutes - 1; j++)\\n            {\\n                if (grumpy[j] == 1)\\n                {\\n                    c += customers[j];\\n                }\\n            }\\n            maxi = max(maxi, c);\\n            c = 0;\\n        }\\n\\n        return count + maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081923,
                "title": "java-sliding-window-beats-98-60-2ms-o-x-customers-length",
                "content": "\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int si = 0, ei = X - 1, ans = 0, max = 0, temp = 0, len = customers.length, msi = 0, mei = X - 1;\\n\\t\\tfor (int i = 0; i < X; i++) {\\n\\t\\t\\tif (grumpy[i] == 1)\\n\\t\\t\\t\\ttemp += customers[i];\\n\\t\\t}\\n\\t\\tmax = temp;\\n\\n\\t\\twhile (si < len - X) {\\n\\t\\t\\ttemp = temp - ((grumpy[si] == 1) ? customers[si] : 0);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei++;\\n\\t\\t\\ttemp = temp + ((grumpy[ei] == 1) ? customers[ei] : 0);\\n\\t\\t\\tif (temp > max) {\\n\\t\\t\\t\\tmax = temp;\\n\\t\\t\\t\\tmsi = si;\\n\\t\\t\\t\\tmei = ei;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = msi; i <= mei; i++)\\n\\t\\t\\tans += customers[i];\\n        \\n\\t\\tfor (int i = 0; i < msi; i++)\\n\\t\\t\\tans = ans + ((grumpy[i] == 0) ? customers[i] : 0);\\n        \\n\\t\\tfor (int i = mei + 1; i < len; i++)\\n\\t\\t\\tans = ans + ((grumpy[i] == 0) ? customers[i] : 0);\\n\\n\\t\\treturn ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int si = 0, ei = X - 1, ans = 0, max = 0, temp = 0, len = customers.length, msi = 0, mei = X - 1;\\n\\t\\tfor (int i = 0; i < X; i++) {\\n\\t\\t\\tif (grumpy[i] == 1)\\n\\t\\t\\t\\ttemp += customers[i];\\n\\t\\t}\\n\\t\\tmax = temp;\\n\\n\\t\\twhile (si < len - X) {\\n\\t\\t\\ttemp = temp - ((grumpy[si] == 1) ? customers[si] : 0);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei++;\\n\\t\\t\\ttemp = temp + ((grumpy[ei] == 1) ? customers[ei] : 0);\\n\\t\\t\\tif (temp > max) {\\n\\t\\t\\t\\tmax = temp;\\n\\t\\t\\t\\tmsi = si;\\n\\t\\t\\t\\tmei = ei;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = msi; i <= mei; i++)\\n\\t\\t\\tans += customers[i];\\n        \\n\\t\\tfor (int i = 0; i < msi; i++)\\n\\t\\t\\tans = ans + ((grumpy[i] == 0) ? customers[i] : 0);\\n        \\n\\t\\tfor (int i = mei + 1; i < len; i++)\\n\\t\\t\\tans = ans + ((grumpy[i] == 0) ? customers[i] : 0);\\n\\n\\t\\treturn ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1073984,
                "title": "java-solution-3-ms-using-sliding-window",
                "content": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n\\n        int satisfiedCustomer = 0;\\n\\n        int l = 0;\\n        int maxUnSatisfiedCustomer = 0;\\n        int unSatisfiedCustomer = 0;\\n        \\n        \\n        for(int r = 0; r < grumpy.length; r++){\\n            \\n            if(grumpy[r] == 1){\\n                unSatisfiedCustomer += customers[r];\\n            }else {\\n                satisfiedCustomer += customers[r];\\n            }\\n            \\n            if(r - l + 1 > X){\\n                if(grumpy[l] == 1){\\n                     unSatisfiedCustomer -= customers[l];\\n                 }\\n                l++;\\n            }\\n            \\n            maxUnSatisfiedCustomer = Math.max(maxUnSatisfiedCustomer, unSatisfiedCustomer);\\n        }\\n        \\n        \\n       return satisfiedCustomer + maxUnSatisfiedCustomer;\\n    }\\n    \\n\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n\\n        int satisfiedCustomer = 0;\\n\\n        int l = 0;\\n        int maxUnSatisfiedCustomer = 0;\\n        int unSatisfiedCustomer = 0;\\n        \\n        \\n        for(int r = 0; r < grumpy.length; r++){\\n            \\n            if(grumpy[r] == 1){\\n                unSatisfiedCustomer += customers[r];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1028693,
                "title": "java-sliding-window-with-explaination",
                "content": "```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int[] window = new int[X];\\n        // find max customer satis faction without considering the X minutes of secret technique\\n        // sum all customers when owner is not grumpy\\n        int totalCustomerWithNoGrumpyOwner = 0;\\n        for(int i=0;i<customers.length;i++) {\\n            if(grumpy[i] ==0) {\\n                totalCustomerWithNoGrumpyOwner += customers[i];\\n            }\\n        }\\n        // now we use sliding window technique to find total customer satisfaction in each of the X minutes window\\n        // also we find total customer satisfied outside of the window, \\n        // we sum the 2 numbers that gives total customer satisfied with the given window and we find max as we do so.\\n        int windowCustomer = 0;\\n        int windowCusomterWithNoGrumpyOwner = 0;\\n        int left=0;\\n        int maxSatisfiedCustomer =0;\\n        for(int right=0;right<customers.length;right++) {\\n            if(grumpy[right] == 0) {\\n                windowCusomterWithNoGrumpyOwner += customers[right];\\n            }\\n            windowCustomer += customers[right];\\n            if(right >= X-1) {\\n                int customerSatisfiedOutsideWindow = totalCustomerWithNoGrumpyOwner - windowCusomterWithNoGrumpyOwner;\\n                // total satisfied = customer satisfied with X window and customer satisfied with non grumpy owner outside the window\\n                maxSatisfiedCustomer = Math.max(maxSatisfiedCustomer, windowCustomer + customerSatisfiedOutsideWindow);\\n                // as window moves right ward we remove customers from left side of the window\\n                windowCustomer -= customers[left];\\n                if(grumpy[left] ==0) {\\n                    windowCusomterWithNoGrumpyOwner -= customers[left];\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        return maxSatisfiedCustomer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int[] window = new int[X];\\n        // find max customer satis faction without considering the X minutes of secret technique\\n        // sum all customers when owner is not grumpy\\n        int totalCustomerWithNoGrumpyOwner = 0;\\n        for(int i=0;i<customers.length;i++) {\\n            if(grumpy[i] ==0) {\\n                totalCustomerWithNoGrumpyOwner += customers[i];\\n            }\\n        }\\n        // now we use sliding window technique to find total customer satisfaction in each of the X minutes window\\n        // also we find total customer satisfied outside of the window, \\n        // we sum the 2 numbers that gives total customer satisfied with the given window and we find max as we do so.\\n        int windowCustomer = 0;\\n        int windowCusomterWithNoGrumpyOwner = 0;\\n        int left=0;\\n        int maxSatisfiedCustomer =0;\\n        for(int right=0;right<customers.length;right++) {\\n            if(grumpy[right] == 0) {\\n                windowCusomterWithNoGrumpyOwner += customers[right];\\n            }\\n            windowCustomer += customers[right];\\n            if(right >= X-1) {\\n                int customerSatisfiedOutsideWindow = totalCustomerWithNoGrumpyOwner - windowCusomterWithNoGrumpyOwner;\\n                // total satisfied = customer satisfied with X window and customer satisfied with non grumpy owner outside the window\\n                maxSatisfiedCustomer = Math.max(maxSatisfiedCustomer, windowCustomer + customerSatisfiedOutsideWindow);\\n                // as window moves right ward we remove customers from left side of the window\\n                windowCustomer -= customers[left];\\n                if(grumpy[left] ==0) {\\n                    windowCusomterWithNoGrumpyOwner -= customers[left];\\n                }\\n                left++;\\n            }\\n            \\n        }\\n        return maxSatisfiedCustomer;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951750,
                "title": "resolving-bud-property-explanation-brute-force-sliding-window",
                "content": "### Approach 1:- Brute Force\\n**P.S. -- I love to find BUD property in every problem :)**\\n```\\nclass Solution {\\npublic:\\n\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\n\\t\\tint result = -1;\\n\\t\\tint n = grumpy.size();\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < min(n, i + X) ; j++) {  // bottle neck (wanting here to do all work at one go) --- sliding window\\n\\n\\t\\t\\t\\tint save = 0;\\n\\t\\t\\t\\tfor (int k = i; k <= j; k++) {   // duplicate (again again sub array(window)) --- sliding window\\n\\t\\t\\t\\t\\tsave += customers[k];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int it = 0; it < n; it++) {   //unnecessary work (non-grumpy calculate) --- pre-calculate/prefix\\n\\t\\t\\t\\t\\tif (it >= i && it <= j) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (grumpy[it] == 0) {\\n\\t\\t\\t\\t\\t\\tsave += customers[it];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult = max(save, result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```\\n\\n### Approach 2: After checking BUD, Sliding Window\\n***P.S. -- I have taken the naming in very effective way. Hope it adds more to your thinking***\\n```\\nclass Solution {\\npublic:\\n\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\t\\tauto totalGrumpySum = 0, windowNonGrumpySum = 0, result = 0;\\n\\n\\t\\tfor (int i = 0; i < customers.size(); i++) {\\n\\n\\t\\t\\ttotalGrumpySum +=  grumpy[i] ? 0 : customers[i];\\n\\t\\t\\twindowNonGrumpySum += grumpy[i] ? customers[i] : 0;\\n\\n\\t\\t\\tif (i >= X) {\\n\\t\\t\\t\\twindowNonGrumpySum -= grumpy[i - X] ? customers[i - X] : 0;\\n\\t\\t\\t}\\n\\t\\t\\tresult = max(result, windowNonGrumpySum);\\n\\t\\t}\\n\\n\\t\\treturn totalGrumpySum + result;\\n\\t}\\n};\\n```\\n**If anything from here helps you, UpVote this so others can also get somethign from this...**",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\n\\t\\tint result = -1;\\n\\t\\tint n = grumpy.size();\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tfor (int j = i; j < min(n, i + X) ; j++) {  // bottle neck (wanting here to do all work at one go) --- sliding window\\n\\n\\t\\t\\t\\tint save = 0;\\n\\t\\t\\t\\tfor (int k = i; k <= j; k++) {   // duplicate (again again sub array(window)) --- sliding window\\n\\t\\t\\t\\t\\tsave += customers[k];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int it = 0; it < n; it++) {   //unnecessary work (non-grumpy calculate) --- pre-calculate/prefix\\n\\t\\t\\t\\t\\tif (it >= i && it <= j) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (grumpy[it] == 0) {\\n\\t\\t\\t\\t\\t\\tsave += customers[it];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult = max(save, result);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n\\t\\tauto totalGrumpySum = 0, windowNonGrumpySum = 0, result = 0;\\n\\n\\t\\tfor (int i = 0; i < customers.size(); i++) {\\n\\n\\t\\t\\ttotalGrumpySum +=  grumpy[i] ? 0 : customers[i];\\n\\t\\t\\twindowNonGrumpySum += grumpy[i] ? customers[i] : 0;\\n\\n\\t\\t\\tif (i >= X) {\\n\\t\\t\\t\\twindowNonGrumpySum -= grumpy[i - X] ? customers[i - X] : 0;\\n\\t\\t\\t}\\n\\t\\t\\tresult = max(result, windowNonGrumpySum);\\n\\t\\t}\\n\\n\\t\\treturn totalGrumpySum + result;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854470,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < customers.length ; i++)\\n            if(grumpy[i] == 0) count += customers[i];\\n        for(int i = 0 ; i < X ; i++)\\n            if(grumpy[i] == 1) count += customers[i];\\n        ans = count;\\n        for(int i = X ; i < customers.length ; i++){\\n            if(grumpy[i - X] == 1) count -= customers[i - X];\\n            if(grumpy[i] == 1) count += customers[i];\\n            ans = Math.max(ans,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int ans = 0;\\n        int count = 0;\\n        for(int i = 0 ; i < customers.length ; i++)\\n            if(grumpy[i] == 0) count += customers[i];\\n        for(int i = 0 ; i < X ; i++)\\n            if(grumpy[i] == 1) count += customers[i];\\n        ans = count;\\n        for(int i = X ; i < customers.length ; i++){\\n            if(grumpy[i - X] == 1) count -= customers[i - X];\\n            if(grumpy[i] == 1) count += customers[i];\\n            ans = Math.max(ans,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650196,
                "title": "java-sliding-window-beats-97-5",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int sum = 0;\\n        for (int i =0;i<customers.length;i++){\\n            if (grumpy[i] == 0)\\n                sum += customers[i];\\n        }\\n        int maxsum = 0;\\n        maxsum = sum;\\n        for(int i =0;i<X;i++){\\n            if (grumpy[i] == 1)\\n                sum += customers[i];\\n        }\\n        if (sum > maxsum)\\n            maxsum = sum;\\n        int j = X;\\n        int i = 0;\\n        while (j< customers.length){\\n            if(grumpy[j] == 1)\\n                sum += customers[j];\\n            if(grumpy[i] == 1)\\n                sum -= customers[i];\\n            if (sum > maxsum)\\n                maxsum = sum;\\n            i++;\\n            j++;\\n        }\\n        return maxsum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int sum = 0;\\n        for (int i =0;i<customers.length;i++){\\n            if (grumpy[i] == 0)\\n                sum += customers[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 542740,
                "title": "c-prefix-sum-with-sliding-window-91-speed-100-memory",
                "content": "Get current total of satisfied customers--this won\\'t change. Populate a prefix sum array of currently unsatisfied customers to facilitate sliding window calculations. Use sliding window analysis with the prefix sum to find the maximum amount of unsatisfied customers within a range of length X, add to total satisfied customers and return.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n        //Get the current total of satisfied customers\\n        int satisfied = 0;\\n        for (int i = 0; i < customers.size(); i++){\\n            if (grumpy[i] == 0){\\n                satisfied += customers[i];\\n            }\\n        }\\n        \\n        //Cumulative sum of grumpy customers at each position in customers array\\n        vector<int>prefix (customers.size()+1,0);\\n        for (int i = 1; i <= customers.size(); i++){\\n            if (grumpy[i-1] == 1){\\n                prefix[i] = customers[i-1]+prefix[i-1];\\n            } else {\\n                prefix[i] = prefix[i-1];   \\n            }\\n        }\\n        \\n        //get the maximum possible capture of grumpy customers in a subarray of length X\\n        int maxchange = 0;\\n        for (int i = X; i < prefix.size(); i++){\\n            maxchange = max(maxchange,prefix[i]-prefix[i-X]); \\n        }\\n        \\n        return satisfied+maxchange;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        \\n        //Get the current total of satisfied customers\\n        int satisfied = 0;\\n        for (int i = 0; i < customers.size(); i++){\\n            if (grumpy[i] == 0){\\n                satisfied += customers[i];\\n            }\\n        }\\n        \\n        //Cumulative sum of grumpy customers at each position in customers array\\n        vector<int>prefix (customers.size()+1,0);\\n        for (int i = 1; i <= customers.size(); i++){\\n            if (grumpy[i-1] == 1){\\n                prefix[i] = customers[i-1]+prefix[i-1];\\n            } else {\\n                prefix[i] = prefix[i-1];   \\n            }\\n        }\\n        \\n        //get the maximum possible capture of grumpy customers in a subarray of length X\\n        int maxchange = 0;\\n        for (int i = X; i < prefix.size(); i++){\\n            maxchange = max(maxchange,prefix[i]-prefix[i-X]); \\n        }\\n        \\n        return satisfied+maxchange;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519190,
                "title": "java-99-solution",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        //we have a sliding window for X, l is left index, r is right index\\n        int l = 0;\\n        int r = X-1;\\n        int num = 0;\\n        \\n        //first put the window to the most left\\n        for(int i = 0 ; i < customers.length ; i++){\\n            if(i < X || grumpy[i] == 0)\\n                num += customers[i];\\n        }\\n        \\n        int max = num;\\n        \\n        //slide the window to the right and update the happy number\\n        for(r = r + 1 ;r < customers.length ; r++,l++){\\n            //gain\\n            if(grumpy[r] == 1){\\n                num += customers[r]; \\n            }\\n            //lose\\n            if(grumpy[l] == 1){\\n                num -= customers[l];\\n            }\\n            max = Math.max(max, num);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        //we have a sliding window for X, l is left index, r is right index\\n        int l = 0;\\n        int r = X-1;\\n        int num = 0;\\n        \\n        //first put the window to the most left\\n        for(int i = 0 ; i < customers.length ; i++){\\n            if(i < X || grumpy[i] == 0)\\n                num += customers[i];\\n        }\\n        \\n        int max = num;\\n        \\n        //slide the window to the right and update the happy number\\n        for(r = r + 1 ;r < customers.length ; r++,l++){\\n            //gain\\n            if(grumpy[r] == 1){\\n                num += customers[r]; \\n            }\\n            //lose\\n            if(grumpy[l] == 1){\\n                num -= customers[l];\\n            }\\n            max = Math.max(max, num);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513632,
                "title": "python3-sliding-window",
                "content": "1. Iterate through customers. Account for the already satisfied customer and store the total satisfaction in \"temp\". Modify the customers array by setting  already satisfied customers\\' value to 0, so that you don\\'t double count satisfaction the next step\\n2. Do a sliding window of size X on the modified customers array. Find which window added to \"temp\" is the maximum\\n\\nAsk questions in comments. I\\'ll do my best to answer\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        temp=0\\n        n=len(customers)\\n        \\n        for i in range(n):\\n            if grumpy[i]==0:\\n                temp+=customers[i]\\n                customers[i]=0\\n        \\n        left=0\\n        right=0\\n        res=0\\n        \\n        while right<n:\\n            while right-left<X and right<n:\\n                temp+=customers[right]\\n                right+=1\\n            res=max(res,temp)\\n            temp-=customers[left]\\n            left+=1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        temp=0\\n        n=len(customers)\\n        \\n        for i in range(n):\\n            if grumpy[i]==0:\\n                temp+=customers[i]\\n                customers[i]=0\\n        \\n        left=0\\n        right=0\\n        res=0\\n        \\n        while right<n:\\n            while right-left<X and right<n:\\n                temp+=customers[right]\\n                right+=1\\n            res=max(res,temp)\\n            temp-=customers[left]\\n            left+=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367798,
                "title": "javascript-sliding-window",
                "content": "Javascript sliding window \\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\n\\n``` javascript\\n/**\\n * @param {number[]} customers\\n * @param {number[]} grumpy\\n * @param {number} X\\n * @return {number}\\n */\\nvar maxSatisfied = function(customers, grumpy, X) {\\n\\n    // Get base satisfaction assuming X === 0\\n    let totalSatisfaction = 0;\\n    for (let i = 0; i < customers.length; i++) if (!grumpy[i]) totalSatisfaction += customers[i];\\n    \\n    \\n    // Handle some easy edge cases\\n    if (X === 0) return totalSatisfaction;\\n    if (customers.length < X) return customers.reduce((acc, current) => acc + current, 0);\\n    \\n    \\n    // Use a sliding window of size X including customers that\\n    // would have been previously exluded when they were grumpy\\n    \\n    let slidingWindowSum = totalSatisfaction;\\n    let maxSum = totalSatisfaction;\\n    let currentEndPosition = -1;\\n    \\n    while (currentEndPosition < customers.length - 1) {\\n        currentEndPosition += 1;\\n        const previousStartPosition = currentEndPosition - X;\\n        \\n        if (previousStartPosition >= 0 && grumpy[previousStartPosition]) slidingWindowSum -= customers[previousStartPosition];\\n        if (grumpy[currentEndPosition]) slidingWindowSum += customers[currentEndPosition];\\n        \\n        maxSum = Math.max(slidingWindowSum, maxSum);\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} customers\\n * @param {number[]} grumpy\\n * @param {number} X\\n * @return {number}\\n */\\nvar maxSatisfied = function(customers, grumpy, X) {\\n\\n    // Get base satisfaction assuming X === 0\\n    let totalSatisfaction = 0;\\n    for (let i = 0; i < customers.length; i++) if (!grumpy[i]) totalSatisfaction += customers[i];\\n    \\n    \\n    // Handle some easy edge cases\\n    if (X === 0) return totalSatisfaction;\\n    if (customers.length < X) return customers.reduce((acc, current) => acc + current, 0);\\n    \\n    \\n    // Use a sliding window of size X including customers that\\n    // would have been previously exluded when they were grumpy\\n    \\n    let slidingWindowSum = totalSatisfaction;\\n    let maxSum = totalSatisfaction;\\n    let currentEndPosition = -1;\\n    \\n    while (currentEndPosition < customers.length - 1) {\\n        currentEndPosition += 1;\\n        const previousStartPosition = currentEndPosition - X;\\n        \\n        if (previousStartPosition >= 0 && grumpy[previousStartPosition]) slidingWindowSum -= customers[previousStartPosition];\\n        if (grumpy[currentEndPosition]) slidingWindowSum += customers[currentEndPosition];\\n        \\n        maxSum = Math.max(slidingWindowSum, maxSum);\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299363,
                "title": "python-one-pass-sliding-window-100-with-explanations",
                "content": "One pass iteration for two tasks:\\n1. Accumulate the count of customers satified without the \"happy pill\". The variable \"total_sat\" below keeps track of it.\\n2. Since the happy pill last for \\'X\\' days. Maintain a sliding window of size \\'X\\', keep track of how many customers who were turned from unhappy to happy with the pill. Variable \\'gains\\' keeps track of the number of \\'high\\' customers within the window. \\'max_gains\\' is the global running max.\\n\\nResult obviously shall be the number of customers who are otherwise happy anyway plus the max number of people who got \\'high\\' on the happy pill.\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        total_sat, max_gains, gains = 0, 0, 0\\n        i = 0\\n        for j, (c, g) in enumerate(zip(customers, grumpy)):\\n            if j - X == i:\\n                gains -= customers[i] * (grumpy[i]==1)\\n                i += 1 \\n            total_sat += c * (g==0)\\n            gains += c * (g==1)\\n            max_gains = max(max_gains, gains)\\n            \\n        return total_sat + max_gains\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        total_sat, max_gains, gains = 0, 0, 0\\n        i = 0\\n        for j, (c, g) in enumerate(zip(customers, grumpy)):\\n            if j - X == i:\\n                gains -= customers[i] * (grumpy[i]==1)\\n                i += 1 \\n            total_sat += c * (g==0)\\n            gains += c * (g==1)\\n            max_gains = max(max_gains, gains)\\n            \\n        return total_sat + max_gains\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938203,
                "title": "easy-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0,j=0,n=customers.size();\\n        int satisfies=0;\\n        int g_sat=0,count=0,res=0;\\n        while(j<n){\\n           if(grumpy[j]==0)satisfies+=customers[j];\\n           if(grumpy[j]==1)\\n               g_sat+=customers[j];\\n              \\n        \\n        if(j-i+1==minutes){\\n            res=max(res,g_sat);\\n             if(grumpy[i]==1){\\n                 g_sat-=customers[i];\\n             \\n             }\\n             i++;\\n        }\\n        j++;\\n    }\\n    return (satisfies+res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0,j=0,n=customers.size();\\n        int satisfies=0;\\n        int g_sat=0,count=0,res=0;\\n        while(j<n){\\n           if(grumpy[j]==0)satisfies+=customers[j];\\n           if(grumpy[j]==1)\\n               g_sat+=customers[j];\\n              \\n        \\n        if(j-i+1==minutes){\\n            res=max(res,g_sat);\\n             if(grumpy[i]==1){\\n                 g_sat-=customers[i];\\n             \\n             }\\n             i++;\\n        }\\n        j++;\\n    }\\n    return (satisfies+res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534920,
                "title": "sliding-window",
                "content": "\\n\\n# Complexity\\n- Time complexity:o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int ans=0;\\n        int s=0;\\n        int w=0;\\n        for(int i=0;i<grumpy.size();i++)\\n        {\\n            if(grumpy[i]==1)\\n            {w+=customers[i];}\\n            else\\n            {\\n                ans+=customers[i];\\n            }\\n\\n            if(i>=minutes && grumpy[i-minutes]==1)\\n               w-=customers[i-minutes];\\n               s=max(s,w);\\n               \\n        }\\n        return(ans+s);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int ans=0;\\n        int s=0;\\n        int w=0;\\n        for(int i=0;i<grumpy.size();i++)\\n        {\\n            if(grumpy[i]==1)\\n            {w+=customers[i];}\\n            else\\n            {\\n                ans+=customers[i];\\n            }\\n\\n            if(i>=minutes && grumpy[i-minutes]==1)\\n               w-=customers[i-minutes];\\n               s=max(s,w);\\n               \\n        }\\n        return(ans+s);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456728,
                "title": "sliding-window-aditya-verma-ka-student",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0,j=0,ans=0,sum=0;\\n        while(j<customers.size())\\n        {\\n            if(grumpy[j]==1)\\n            sum+=customers[j];\\n            if(j-i+1!=minutes)\\n            j++;\\n\\n            else if(j-i+1==minutes)\\n            {\\n                ans=max(sum,ans);\\n                if(grumpy[i]==1)\\n                sum-=customers [i];\\n                i++;\\n                j++;\\n            } \\n        }\\n\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(grumpy[i]==0)\\n            ans+=customers[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\nUPVOTE for KARMA\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0,j=0,ans=0,sum=0;\\n        while(j<customers.size())\\n        {\\n            if(grumpy[j]==1)\\n            sum+=customers[j];\\n            if(j-i+1!=minutes)\\n            j++;\\n\\n            else if(j-i+1==minutes)\\n            {\\n                ans=max(sum,ans);\\n                if(grumpy[i]==1)\\n                sum-=customers [i];\\n                i++;\\n                j++;\\n            } \\n        }\\n\\n        for(int i=0;i<customers.size();i++)\\n        {\\n            if(grumpy[i]==0)\\n            ans+=customers[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\nUPVOTE for KARMA\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443324,
                "title": "easy-c-soltuion-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& nums, vector<int>& ans, int k) {\\n       int sum =0,sum1=0,res=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[i]==0)\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            if(ans[j]==1)\\n            {\\n                sum1+=nums[j];\\n            }\\n            if((j-i+1)<k)\\n            {\\n                j++;\\n            }\\n            else if((j-i+1)==k)\\n            {\\n                res = max(res,sum1);\\n                if(ans[i]==1)\\n                {\\n                    sum1-=nums[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return sum+res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& nums, vector<int>& ans, int k) {\\n       int sum =0,sum1=0,res=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(ans[i]==0)\\n            {\\n                sum+=nums[i];\\n            }\\n        }\\n        int i=0,j=0;\\n        while(j<nums.size())\\n        {\\n            if(ans[j]==1)\\n            {\\n                sum1+=nums[j];\\n            }\\n            if((j-i+1)<k)\\n            {\\n                j++;\\n            }\\n            else if((j-i+1)==k)\\n            {\\n                res = max(res,sum1);\\n                if(ans[i]==1)\\n                {\\n                    sum1-=nums[i];\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return sum+res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342331,
                "title": "left-mid-right-easy-to-understand",
                "content": "# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int min) \\n    {\\n        //we will make the ans in three parts\\n        //before the window\\n        //in the window\\n        //after the window\\n\\n        //making the customers prefix vector or array\\n         vector<long long int>customers;\\n         for(int i=0;i<c.size();i++)\\n         {\\n             if(customers.size() == 0)\\n             {\\n                 customers.push_back(c[i]);\\n             }\\n             else\\n             {\\n                 long long int val = 0LL + customers.back() + c[i];\\n                 customers.push_back(val);\\n             }\\n         }\\n\\n         //making the grumpy prefix vector or array\\n         vector<long long int>grumpy;\\n         for(int i=0;i<g.size();i++)\\n         {\\n             if(grumpy.size() == 0)\\n             {\\n                 grumpy.push_back(g[i]);\\n             }\\n             else\\n             {\\n                 long long int val = 0LL + grumpy.back() + g[i];\\n                 grumpy.push_back(val);\\n             }\\n         }\\n        \\n        //till index i how many customers can be satisfied\\n        vector<long long int>v(c.size(),0);\\n        if(g[0] == 0) v[0] = c[0];\\n        else if(g[0] == 1) v[0] = 0;\\n\\n        for(int i=1;i<c.size();i++)\\n        {\\n            if(g[i] == 1)\\n            {\\n                v[i] = v[i-1];\\n            }\\n            else if(g[i] != -1)\\n            {\\n               v[i] = c[i] + v[i-1]; \\n            }\\n        }\\n\\n        int start = 0;\\n        int end = min-1;\\n        long long int ans = 0;\\n\\n        while(end < c.size())\\n        {\\n            long long int left = 0;\\n            long long int mid  = 0;\\n            long long int right = 0;\\n            \\n            if(start > 0)\\n            {\\n                 left = v[start -1];\\n            }\\n     \\n            long long int customer_count = customers[end];\\n            if(start > 0) customer_count = customer_count - customers[start-1];\\n            mid = customer_count;\\n \\n            if(right < c.size()-1)\\n            {\\n                right = v[v.size()-1] - v[end];\\n            }\\n\\n            long long int val = left + mid + right;\\n            if(val > ans)\\n            ans = val;\\n\\n            start++;\\n            end++;\\n        }\\n        //print(v);\\n        return ans;\\n    }\\n    void print(vector<long long int>&v)\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            cout<<v[i]<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int min) \\n    {\\n        //we will make the ans in three parts\\n        //before the window\\n        //in the window\\n        //after the window\\n\\n        //making the customers prefix vector or array\\n         vector<long long int>customers;\\n         for(int i=0;i<c.size();i++)\\n         {\\n             if(customers.size() == 0)\\n             {\\n                 customers.push_back(c[i]);\\n             }\\n             else\\n             {\\n                 long long int val = 0LL + customers.back() + c[i];\\n                 customers.push_back(val);\\n             }\\n         }\\n\\n         //making the grumpy prefix vector or array\\n         vector<long long int>grumpy;\\n         for(int i=0;i<g.size();i++)\\n         {\\n             if(grumpy.size() == 0)\\n             {\\n                 grumpy.push_back(g[i]);\\n             }\\n             else\\n             {\\n                 long long int val = 0LL + grumpy.back() + g[i];\\n                 grumpy.push_back(val);\\n             }\\n         }\\n        \\n        //till index i how many customers can be satisfied\\n        vector<long long int>v(c.size(),0);\\n        if(g[0] == 0) v[0] = c[0];\\n        else if(g[0] == 1) v[0] = 0;\\n\\n        for(int i=1;i<c.size();i++)\\n        {\\n            if(g[i] == 1)\\n            {\\n                v[i] = v[i-1];\\n            }\\n            else if(g[i] != -1)\\n            {\\n               v[i] = c[i] + v[i-1]; \\n            }\\n        }\\n\\n        int start = 0;\\n        int end = min-1;\\n        long long int ans = 0;\\n\\n        while(end < c.size())\\n        {\\n            long long int left = 0;\\n            long long int mid  = 0;\\n            long long int right = 0;\\n            \\n            if(start > 0)\\n            {\\n                 left = v[start -1];\\n            }\\n     \\n            long long int customer_count = customers[end];\\n            if(start > 0) customer_count = customer_count - customers[start-1];\\n            mid = customer_count;\\n \\n            if(right < c.size()-1)\\n            {\\n                right = v[v.size()-1] - v[end];\\n            }\\n\\n            long long int val = left + mid + right;\\n            if(val > ans)\\n            ans = val;\\n\\n            start++;\\n            end++;\\n        }\\n        //print(v);\\n        return ans;\\n    }\\n    void print(vector<long long int>&v)\\n    {\\n        for(int i=0;i<v.size();i++)\\n        {\\n            cout<<v[i]<<\" \";\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3253044,
                "title": "c-sliding-window-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        int n = size(customers),techniqueSum = 0, j = 0, maxTechniqueSum = 0, sumOfNotGrumpy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(grumpy[i] == 0)sumOfNotGrumpy += customers[i];\\n            else techniqueSum += customers[i];\\n            \\n            if(i-j+1 == minutes) {\\n                \\n                maxTechniqueSum = max(maxTechniqueSum, techniqueSum);\\n                if(grumpy[j] == 1)techniqueSum -= customers[j];\\n                j++;\\n            }\\n        }\\n        \\n        return maxTechniqueSum + sumOfNotGrumpy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        int n = size(customers),techniqueSum = 0, j = 0, maxTechniqueSum = 0, sumOfNotGrumpy = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(grumpy[i] == 0)sumOfNotGrumpy += customers[i];\\n            else techniqueSum += customers[i];\\n            \\n            if(i-j+1 == minutes) {\\n                \\n                maxTechniqueSum = max(maxTechniqueSum, techniqueSum);\\n                if(grumpy[j] == 1)techniqueSum -= customers[j];\\n                j++;\\n            }\\n        }\\n        \\n        return maxTechniqueSum + sumOfNotGrumpy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230091,
                "title": "sliding-window-c-seperately-seperately-taken-out-satisifed-and-not-satisfied",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid grumpyDummyPerm(int arr[],int startIndex,int endIndex){\\n    for(int i=startIndex;i<endIndex;i++){\\n        arr[i] = 0;\\n    }\\n}\\n   /* int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int grumpySize = grumpy.size();\\n        int arr[grumpySize];\\n\\n        if(minutes ==3109){\\n            return 5787621;\\n        }\\n\\n        for(int i=0;i<grumpy.size();i++){\\n            arr[i] = grumpy[i];\\n        }\\n\\n        int maxVal = INT_MIN;\\n\\n        for(int i=0;i<grumpy.size();i++){\\n            if(i+minutes<=grumpy.size()){\\n                int sum = 0;\\n                grumpyDummyPerm(arr,i,i+minutes);\\n                for(int i=0;i<grumpy.size();i++){\\n                    if(arr[i] == 0){\\n                        sum+=customers[i];\\n                    }\\n                }\\n                maxVal = max(sum,maxVal);\\n                for(int i=0;i<grumpy.size();i++){\\n                arr[i] = grumpy[i];\\n\\n                }\\n          \\n           }\\n        }\\n    return maxVal;\\n    }*/\\n     int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n\\n         int maxWin = INT_MIN;\\n         int sum = 0;\\n         int ans = 0;\\n         for(int i=0;i<minutes;i++){\\n             if(grumpy[i] == 1)\\n             sum+= customers[i];\\n         }\\n         int maxWindIndexStart = -1;\\n         maxWin = sum;\\n         for(int i=0;i<(grumpy.size()-minutes);i++){\\n             if(grumpy[i] == 1){\\n                sum = sum - customers[i];\\n             }\\n            if(grumpy[i+minutes] == 1){\\n                sum = sum + customers[i+minutes];\\n            }\\n            \\n            if(sum>maxWin){\\n                maxWin = sum;\\n                maxWindIndexStart = i+1;\\n            }\\n         }\\n        for(int i=0;i<grumpy.size();i++){\\n            if(grumpy[i] == 0)\\n            ans+=customers[i];\\n        }\\n        if(maxWin == INT_MIN){\\n            return ans;\\n        }\\n        return ans+maxWin;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid grumpyDummyPerm(int arr[],int startIndex,int endIndex){\\n    for(int i=startIndex;i<endIndex;i++){\\n        arr[i] = 0;\\n    }\\n}\\n   /* int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int grumpySize = grumpy.size();\\n        int arr[grumpySize];\\n\\n        if(minutes ==3109){\\n            return 5787621;\\n        }\\n\\n        for(int i=0;i<grumpy.size();i++){\\n            arr[i] = grumpy[i];\\n        }\\n\\n        int maxVal = INT_MIN;\\n\\n        for(int i=0;i<grumpy.size();i++){\\n            if(i+minutes<=grumpy.size()){\\n                int sum = 0;\\n                grumpyDummyPerm(arr,i,i+minutes);\\n                for(int i=0;i<grumpy.size();i++){\\n                    if(arr[i] == 0){\\n                        sum+=customers[i];\\n                    }\\n                }\\n                maxVal = max(sum,maxVal);\\n                for(int i=0;i<grumpy.size();i++){\\n                arr[i] = grumpy[i];\\n\\n                }\\n          \\n           }\\n        }\\n    return maxVal;\\n    }*/\\n     int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n\\n         int maxWin = INT_MIN;\\n         int sum = 0;\\n         int ans = 0;\\n         for(int i=0;i<minutes;i++){\\n             if(grumpy[i] == 1)\\n             sum+= customers[i];\\n         }\\n         int maxWindIndexStart = -1;\\n         maxWin = sum;\\n         for(int i=0;i<(grumpy.size()-minutes);i++){\\n             if(grumpy[i] == 1){\\n                sum = sum - customers[i];\\n             }\\n            if(grumpy[i+minutes] == 1){\\n                sum = sum + customers[i+minutes];\\n            }\\n            \\n            if(sum>maxWin){\\n                maxWin = sum;\\n                maxWindIndexStart = i+1;\\n            }\\n         }\\n        for(int i=0;i<grumpy.size();i++){\\n            if(grumpy[i] == 0)\\n            ans+=customers[i];\\n        }\\n        if(maxWin == INT_MIN){\\n            return ans;\\n        }\\n        return ans+maxWin;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117642,
                "title": "crisp-n-clear-o-n-javascript-runtime-100-meaningful-vars",
                "content": "# Intuition\\n\\n# Approach\\nwithGrumpyInitSum\\nwithOutGrumpyInitSum\\nmaxDifference\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n\\tlet fromInitIndex = 0;\\n\\tlet toInitIndex = minutes - 1;\\n\\tlet withOutGrumpyInitSum = customers.slice(0, minutes).reduce((acc, current) => current + acc);\\n\\tlet withGrumpyInitSum = customers\\n\\t\\t.slice(0, minutes)\\n\\t\\t.reduce((acc, current, index) => (grumpy[index] ? acc : current + acc), 0);\\n\\tlet maxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\n\\tfor (let index = minutes; index < customers.length; index++) {\\n\\t\\twithOutGrumpyInitSum += customers[index] - customers[index - minutes];\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum + customers[index];\\n\\t\\t}\\n\\t\\tif (!grumpy[index - minutes]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum - customers[index - minutes];\\n\\t\\t}\\n\\t\\tif (maxDifference < withOutGrumpyInitSum - withGrumpyInitSum) {\\n\\t\\t\\tmaxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\t\\t\\tfromInitIndex = index - minutes + 1;\\n\\t\\t\\ttoInitIndex = index;\\n\\t\\t}\\n\\t}\\n\\n\\tlet sum = 0;\\n\\tfor (let index = 0; index < customers.length; index++) {\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t} else if (index >= fromInitIndex && index <= toInitIndex) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n};\\n\\n![image.png](https://assets.leetcode.com/users/images/854f058c-091f-4bf5-9e53-0b608d451a71_1675075841.1080902.png)\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n\\tlet fromInitIndex = 0;\\n\\tlet toInitIndex = minutes - 1;\\n\\tlet withOutGrumpyInitSum = customers.slice(0, minutes).reduce((acc, current) => current + acc);\\n\\tlet withGrumpyInitSum = customers\\n\\t\\t.slice(0, minutes)\\n\\t\\t.reduce((acc, current, index) => (grumpy[index] ? acc : current + acc), 0);\\n\\tlet maxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\n\\tfor (let index = minutes; index < customers.length; index++) {\\n\\t\\twithOutGrumpyInitSum += customers[index] - customers[index - minutes];\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum + customers[index];\\n\\t\\t}\\n\\t\\tif (!grumpy[index - minutes]) {\\n\\t\\t\\twithGrumpyInitSum = withGrumpyInitSum - customers[index - minutes];\\n\\t\\t}\\n\\t\\tif (maxDifference < withOutGrumpyInitSum - withGrumpyInitSum) {\\n\\t\\t\\tmaxDifference = withOutGrumpyInitSum - withGrumpyInitSum;\\n\\t\\t\\tfromInitIndex = index - minutes + 1;\\n\\t\\t\\ttoInitIndex = index;\\n\\t\\t}\\n\\t}\\n\\n\\tlet sum = 0;\\n\\tfor (let index = 0; index < customers.length; index++) {\\n\\t\\tif (!grumpy[index]) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t} else if (index >= fromInitIndex && index <= toInitIndex) {\\n\\t\\t\\tsum += customers[index];\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n};\\n\\n![image.png](https://assets.leetcode.com/users/images/854f058c-091f-4bf5-9e53-0b608d451a71_1675075841.1080902.png)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2824370,
                "title": "sliding-window-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n\\n        int s=0;\\n        for(int i=0;i<customers.size();i++){\\n            if(grumpy[i]==0)s+=customers[i]; //when the seller is not grumpy the customers will be satisfied so let\\'s add it to our result\\n        }\\n        \\n        int temp=s,t=s;\\n\\n        for(int i=0;i<=customers.size()-minutes;i++){\\n            temp=t; //temp stores the original value of satisfied customers when we didn\\'t didn\\'t check the grumpy vector. \\n            for(int j=i;j<i+minutes;j++){ //sliding window\\n                if(grumpy[j]==1){  //during this period the seller can stop being grumpy\\n                    temp+=customers[j]; //satisfied customers count increases\\n                }\\n            }\\n            s=max(s,temp); //temp contains the count of satisfied customers if the seller wasn\\'t grumpy at that sliding window period\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n\\n        int s=0;\\n        for(int i=0;i<customers.size();i++){\\n            if(grumpy[i]==0)s+=customers[i]; //when the seller is not grumpy the customers will be satisfied so let\\'s add it to our result\\n        }\\n        \\n        int temp=s,t=s;\\n\\n        for(int i=0;i<=customers.size()-minutes;i++){\\n            temp=t; //temp stores the original value of satisfied customers when we didn\\'t didn\\'t check the grumpy vector. \\n            for(int j=i;j<i+minutes;j++){ //sliding window\\n                if(grumpy[j]==1){  //during this period the seller can stop being grumpy\\n                    temp+=customers[j]; //satisfied customers count increases\\n                }\\n            }\\n            s=max(s,temp); //temp contains the count of satisfied customers if the seller wasn\\'t grumpy at that sliding window period\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708759,
                "title": "java-solution-sliding-window-o-n-time-o-1-space",
                "content": "```java \\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int Csum=0;\\n        int total=0;\\n        int max=0;\\n        for(int i=0;i<minutes;i++)\\n        {\\n            if(grumpy[i]==1){\\n                Csum+=customers[i];\\n            }\\n            else{\\n                total+=customers[i];\\n            }\\n        }\\n         if(Csum>max)\\n             max=Csum;\\n        for(int i=minutes;i<grumpy.length;i++)\\n        {\\n            if(grumpy[i]==1){\\n                Csum+=customers[i];\\n            }\\n            else{\\n                total+=customers[i];\\n            }\\n            if(grumpy[i-minutes]==1)\\n                Csum-=customers[i-minutes];\\n            if(Csum>max){\\n                max=Csum;\\n            }\\n        }\\n        return total+max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int Csum=0;\\n        int total=0;\\n        int max=0;\\n        for(int i=0;i<minutes;i++)\\n        {\\n            if(grumpy[i]==1){\\n                Csum+=customers[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2427796,
                "title": "c-easiest-fixed-sliding-window-approach",
                "content": "\\'\\'\\'\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int s=0, e=0, n=customers.size();\\n        int sum_satisfied=0, result=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(grumpy[i]==0)\\n                sum_satisfied+=customers[i];\\n        }\\n        \\n        while(e<n)\\n        {\\n            \\n            if(grumpy[e]==1)\\n                sum_satisfied+=customers[e];\\n            if(e-s+1<minutes)\\n            {\\n                e++;\\n            }\\n            else if(e-s+1==minutes)\\n            {\\n                result=max(result, sum_satisfied);\\n                e++;\\n                if(grumpy[s]==1)\\n                    sum_satisfied-=customers[s];\\n                s++;\\n          }\\n    \\n     }\\n        return  result;\\n    }\\n\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int s=0, e=0, n=customers.size();\\n        int sum_satisfied=0, result=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(grumpy[i]==0)\\n                sum_satisfied+=customers[i];\\n        }\\n        \\n        while(e<n)\\n        {\\n            \\n            if(grumpy[e]==1)\\n                sum_satisfied+=customers[e];\\n            if(e-s+1<minutes)\\n            {\\n                e++;\\n            }\\n            else if(e-s+1==minutes)\\n            {\\n                result=max(result, sum_satisfied);\\n                e++;\\n                if(grumpy[s]==1)\\n                    sum_satisfied-=customers[s];\\n                s++;\\n          }\\n    \\n     }\\n        return  result;\\n    }\\n\\n\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2330386,
                "title": "c-simple-sliding-window-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/grumpy-bookstore-owner/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Looking at the problem, main thing to find is the window where the minutes should\\n    be used so that the owner is not grumpy and max customers in that window can be satisifed.\\n    \\n    Find the window with most no. of satisfied customers given the owner was originally grumpy but\\n    now has become not grumpy.\\n    Since the owner can only be not grumpy for minutes duration, this sets our window size as well.\\n    So with \\'minutes\\' window size, find the max window.\\n    \\n    Then add the max window value with the normal satisfied customers.\\n*/\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        // Tracks the max window where being not grumpy will add most customers and current grumpy window customers\\n        int max_grumpy_window = 0, grumpy_window = 0;\\n        int curr = 0, n = customers.size();\\n        // Total satisifed customers when owner is not grumpy\\n        int satisfied_cx = 0;\\n        // net effective duration of not being grumpy\\n        minutes = min(minutes, n);\\n        \\n        // process the 1st window\\n        while(curr < minutes) {\\n            satisfied_cx += (!grumpy[curr] ? customers[curr] : 0);\\n            grumpy_window += (grumpy[curr] ? customers[curr] : 0);\\n            ++curr;\\n        }\\n        \\n        max_grumpy_window = max(max_grumpy_window, grumpy_window);\\n        // process the remaining windows\\n        while(curr < n) {\\n            // Remove the 1st element of last window\\n            grumpy_window -= (grumpy[curr - minutes] ? customers[curr - minutes] : 0);\\n            // Add the latest element of current window\\n            grumpy_window += (grumpy[curr] ? customers[curr] : 0);\\n            max_grumpy_window = max(max_grumpy_window, grumpy_window);\\n            \\n            satisfied_cx += (!grumpy[curr] ? customers[curr] : 0);\\n            ++curr;\\n        }\\n        \\n        return satisfied_cx + max_grumpy_window;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/grumpy-bookstore-owner/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n    \\n    Looking at the problem, main thing to find is the window where the minutes should\\n    be used so that the owner is not grumpy and max customers in that window can be satisifed.\\n    \\n    Find the window with most no. of satisfied customers given the owner was originally grumpy but\\n    now has become not grumpy.\\n    Since the owner can only be not grumpy for minutes duration, this sets our window size as well.\\n    So with \\'minutes\\' window size, find the max window.\\n    \\n    Then add the max window value with the normal satisfied customers.\\n*/\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        // Tracks the max window where being not grumpy will add most customers and current grumpy window customers\\n        int max_grumpy_window = 0, grumpy_window = 0;\\n        int curr = 0, n = customers.size();\\n        // Total satisifed customers when owner is not grumpy\\n        int satisfied_cx = 0;\\n        // net effective duration of not being grumpy\\n        minutes = min(minutes, n);\\n        \\n        // process the 1st window\\n        while(curr < minutes) {\\n            satisfied_cx += (!grumpy[curr] ? customers[curr] : 0);\\n            grumpy_window += (grumpy[curr] ? customers[curr] : 0);\\n            ++curr;\\n        }\\n        \\n        max_grumpy_window = max(max_grumpy_window, grumpy_window);\\n        // process the remaining windows\\n        while(curr < n) {\\n            // Remove the 1st element of last window\\n            grumpy_window -= (grumpy[curr - minutes] ? customers[curr - minutes] : 0);\\n            // Add the latest element of current window\\n            grumpy_window += (grumpy[curr] ? customers[curr] : 0);\\n            max_grumpy_window = max(max_grumpy_window, grumpy_window);\\n            \\n            satisfied_cx += (!grumpy[curr] ? customers[curr] : 0);\\n            ++curr;\\n        }\\n        \\n        return satisfied_cx + max_grumpy_window;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309669,
                "title": "python3-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        #sliding window technique!\\n        #first, linearly traverse customers array and see number of customers that are \\n        #gauranteed to be satisfied regardless of store owner\\'s powerup!\\n        \\n        #then, use sliding window and maximize the number of customers that can be converted \\n        #to satisfied by using minutes amount of power up !\\n        \\n        #If we let len(customers)=n and len(grumpy) = m,\\n        #Time: O(2n) -> O(n)\\n        #Space: O(1)\\n        \\n        \\n        #add these 2 results and that is the answer!\\n        #Step 1\\n        ans = 0\\n        for a in range(len(customers)):\\n            if(grumpy[a] == 0):\\n                ans += customers[a]\\n        #step 2: sliding window!\\n        \\n        L, R = 0, 0\\n        converted = 0\\n        maximum = 0\\n        length = 0\\n        while R < len(customers):\\n            #process right element\\n            if(grumpy[R] == 1):\\n                converted += customers[R]\\n            length += 1\\n            #stopping condition: if length ever reaches minutes\\n            while length == minutes:\\n                #process current sliding window!\\n                maximum = max(maximum, converted)\\n                #shrink the sliding window!\\n                #check if left minute is the minutes store owner is grumpy!\\n                if(grumpy[L] == 1):\\n                    converted -= customers[L]\\n                length -= 1\\n                L += 1\\n            #keep expanding sliding window\\n            R += 1\\n        return maximum + ans",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        #sliding window technique!\\n        #first, linearly traverse customers array and see number of customers that are \\n        #gauranteed to be satisfied regardless of store owner\\'s powerup!\\n        \\n        #then, use sliding window and maximize the number of customers that can be converted \\n        #to satisfied by using minutes amount of power up !\\n        \\n        #If we let len(customers)=n and len(grumpy) = m,\\n        #Time: O(2n) -> O(n)\\n        #Space: O(1)\\n        \\n        \\n        #add these 2 results and that is the answer!\\n        #Step 1\\n        ans = 0\\n        for a in range(len(customers)):\\n            if(grumpy[a] == 0):\\n                ans += customers[a]\\n        #step 2: sliding window!\\n        \\n        L, R = 0, 0\\n        converted = 0\\n        maximum = 0\\n        length = 0\\n        while R < len(customers):\\n            #process right element\\n            if(grumpy[R] == 1):\\n                converted += customers[R]\\n            length += 1\\n            #stopping condition: if length ever reaches minutes\\n            while length == minutes:\\n                #process current sliding window!\\n                maximum = max(maximum, converted)\\n                #shrink the sliding window!\\n                #check if left minute is the minutes store owner is grumpy!\\n                if(grumpy[L] == 1):\\n                    converted -= customers[L]\\n                length -= 1\\n                L += 1\\n            #keep expanding sliding window\\n            R += 1\\n        return maximum + ans",
                "codeTag": "Java"
            },
            {
                "id": 2289861,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int j=0;\\n        int i=0;\\n        int sum=0;\\n        int maxm=0;\\n        int totalsum=0;\\n        while(j<n){\\n            if(grumpy[j]==0) totalsum+=customers[j];\\n            if(grumpy[j]==1) sum=sum+customers[j];\\n            int min=j-i+1;\\n            if(min>minutes){\\n                if(grumpy[i]==1) sum-=customers[i];\\n                i++;\\n            }\\n            j++;\\n            maxm=max(maxm,sum);\\n          \\n        }\\n        return maxm+totalsum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int j=0;\\n        int i=0;\\n        int sum=0;\\n        int maxm=0;\\n        int totalsum=0;\\n        while(j<n){\\n            if(grumpy[j]==0) totalsum+=customers[j];\\n            if(grumpy[j]==1) sum=sum+customers[j];\\n            int min=j-i+1;\\n            if(min>minutes){\\n                if(grumpy[i]==1) sum-=customers[i];\\n                i++;\\n            }\\n            j++;\\n            maxm=max(maxm,sum);\\n          \\n        }\\n        return maxm+totalsum;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2252223,
                "title": "well-commented-easy-sliding-window-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n = grumpy.size();\\n        \\n        int sum = 0, maxi = 0;\\n        \\n        // we will only store those value in which owner will be grumpy\\n        for(int i=0; i<minutes; i++){\\n            if(grumpy[i] == 1) sum += customers[i];\\n        }\\n        \\n        // basic fixed sliding window technique, also we are storing the index of the max valued window\\n        maxi = sum;\\n        int i=0, j=minutes;\\n        int ii = 0, jj = minutes-1;\\n        \\n        while(j<n){\\n            if(grumpy[j] == 1) sum += customers[j];\\n            if(grumpy[i] == 1) sum -= customers[i];\\n            \\n            if(sum > maxi){\\n                maxi = sum;\\n                ii = i+1; jj = j;\\n            }\\n            \\n            i++; j++;\\n        }\\n        \\n        \\n        // now we will store all the satisfied customers in ans vector and will handle specially for the max value window part\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(i >= ii && i <= jj){\\n                ans += customers[i];\\n                continue;\\n            }\\n            \\n            if(grumpy[i] == 0) ans += customers[i];\\n        }\\n        // cout<< ii <<\" \" << jj <<endl; // debug stuff (ignore)\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n = grumpy.size();\\n        \\n        int sum = 0, maxi = 0;\\n        \\n        // we will only store those value in which owner will be grumpy\\n        for(int i=0; i<minutes; i++){\\n            if(grumpy[i] == 1) sum += customers[i];\\n        }\\n        \\n        // basic fixed sliding window technique, also we are storing the index of the max valued window\\n        maxi = sum;\\n        int i=0, j=minutes;\\n        int ii = 0, jj = minutes-1;\\n        \\n        while(j<n){\\n            if(grumpy[j] == 1) sum += customers[j];\\n            if(grumpy[i] == 1) sum -= customers[i];\\n            \\n            if(sum > maxi){\\n                maxi = sum;\\n                ii = i+1; jj = j;\\n            }\\n            \\n            i++; j++;\\n        }\\n        \\n        \\n        // now we will store all the satisfied customers in ans vector and will handle specially for the max value window part\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            if(i >= ii && i <= jj){\\n                ans += customers[i];\\n                continue;\\n            }\\n            \\n            if(grumpy[i] == 0) ans += customers[i];\\n        }\\n        // cout<< ii <<\" \" << jj <<endl; // debug stuff (ignore)\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2224458,
                "title": "sliding-window-c-o-n-easy-to-understand",
                "content": "Like and upvote if you find it useful :)\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int s = 0,e = n-1;//window (of size minutes) where maximum loss happening\\n        int maxloss=0;\\n        int loss = 0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1) loss+=customers[i];\\n            if(i >= minutes-1){\\n                maxloss = max(maxloss,loss);\\n                if(loss == maxloss){\\n                    s = i-minutes+1;\\n                    e = i;\\n                }\\n                loss-= grumpy[i-minutes+1]==1?customers[i-minutes+1] : 0;\\n            }\\n        }\\n        int res = 0;\\n        for(int k=0;k<n;k++){\\n            if(k>=s && k<=e){\\n                res+=customers[k];\\n            }else if(grumpy[k] == 0){\\n                res+=customers[k];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int s = 0,e = n-1;//window (of size minutes) where maximum loss happening\\n        int maxloss=0;\\n        int loss = 0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1) loss+=customers[i];\\n            if(i >= minutes-1){\\n                maxloss = max(maxloss,loss);\\n                if(loss == maxloss){\\n                    s = i-minutes+1;\\n                    e = i;\\n                }\\n                loss-= grumpy[i-minutes+1]==1?customers[i-minutes+1] : 0;\\n            }\\n        }\\n        int res = 0;\\n        for(int k=0;k<n;k++){\\n            if(k>=s && k<=e){\\n                res+=customers[k];\\n            }else if(grumpy[k] == 0){\\n                res+=customers[k];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177405,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        \\n        int n = customers.size();\\n        \\n        // curr_sum store the no of satisfied customer at every point of time\\n        \\n        int curr_sum = 0;\\n        \\n        // max_sum store the max no of satisfied customer at every point of time\\n        \\n        int max_sum = 0;\\n        \\n        // add all the elements to the curr_sum when is not grumpy\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(grumpy[i] == 0)\\n            {\\n                curr_sum += customers[i];\\n            }\\n        }\\n        \\n        // apply sliding window to maximise the no of satisfied customer \\n        \\n        // size of sliding window will be k\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < k)   // window size less than k\\n            {\\n                if(grumpy[i])   // when he is grumpy\\n                {\\n                    curr_sum += customers[i];\\n                }\\n            }\\n            else   // window size == k\\n            {\\n                // update the result\\n                \\n                max_sum = max(max_sum, curr_sum);\\n                \\n                // if he is currently grumpy then add to curr_sum\\n                \\n                if(grumpy[i])\\n                {\\n                    curr_sum += customers[i];\\n                }\\n                \\n                // remove the first element of window\\n                \\n                if(grumpy[i - k])\\n                {\\n                    curr_sum -= customers[i - k];\\n                }\\n            }\\n        }\\n        \\n        max_sum = max(max_sum, curr_sum);\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        \\n        int n = customers.size();\\n        \\n        // curr_sum store the no of satisfied customer at every point of time\\n        \\n        int curr_sum = 0;\\n        \\n        // max_sum store the max no of satisfied customer at every point of time\\n        \\n        int max_sum = 0;\\n        \\n        // add all the elements to the curr_sum when is not grumpy\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(grumpy[i] == 0)\\n            {\\n                curr_sum += customers[i];\\n            }\\n        }\\n        \\n        // apply sliding window to maximise the no of satisfied customer \\n        \\n        // size of sliding window will be k\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < k)   // window size less than k\\n            {\\n                if(grumpy[i])   // when he is grumpy\\n                {\\n                    curr_sum += customers[i];\\n                }\\n            }\\n            else   // window size == k\\n            {\\n                // update the result\\n                \\n                max_sum = max(max_sum, curr_sum);\\n                \\n                // if he is currently grumpy then add to curr_sum\\n                \\n                if(grumpy[i])\\n                {\\n                    curr_sum += customers[i];\\n                }\\n                \\n                // remove the first element of window\\n                \\n                if(grumpy[i - k])\\n                {\\n                    curr_sum -= customers[i - k];\\n                }\\n            }\\n        }\\n        \\n        max_sum = max(max_sum, curr_sum);\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093866,
                "title": "sliding-window-easy-technique",
                "content": "```\\n\\nclass Solution {\\n    \\n    //T = O(n), S = O(1)\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int maxUnsatifiedCustomers = 0;\\n\\t\\t//Maximmum unsatified customers in m minutes window\\n        for(int i=0; i<minutes; i++) {\\n            if(grumpy[i] == 1)  {\\n                maxUnsatifiedCustomers+= customers[i];\\n            }\\n        }\\n        \\n        int maxU = maxUnsatifiedCustomers;\\n        \\n\\t\\t//rest of the window by the end of it get maximum unsatified customers in m minutes window\\n        for(int i=minutes; i<grumpy.length; i++) {\\n            if(grumpy[i] == 1) {\\n                maxU+= customers[i];\\n            }\\n            if(grumpy[i-minutes] == 1) {\\n                    maxU-=  customers[i-minutes];\\n            }\\n            maxUnsatifiedCustomers = Math.max(maxUnsatifiedCustomers, maxU);\\n        }\\n        \\n        //Intially total satified customer\\n        int totalSatifiedCustomers = 0;\\n        for(int i=0; i<grumpy.length; i++) {\\n            if(grumpy[i] == 0) {\\n                totalSatifiedCustomers+=customers[i];\\n            }\\n        }\\n\\t\\t//think about it\\n\\t\\t// our answer is totalSatified + (m minutes window maximum unsatified)\\n        return totalSatifiedCustomers+maxUnsatifiedCustomers;\\n    }\\n}\\n```\\n\\nPlease do upvote if you like the solution.",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    //T = O(n), S = O(1)\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int maxUnsatifiedCustomers = 0;\\n\\t\\t//Maximmum unsatified customers in m minutes window\\n        for(int i=0; i<minutes; i++) {\\n            if(grumpy[i] == 1)  {\\n                maxUnsatifiedCustomers+= customers[i];\\n            }\\n        }\\n        \\n        int maxU = maxUnsatifiedCustomers;\\n        \\n\\t\\t//rest of the window by the end of it get maximum unsatified customers in m minutes window\\n        for(int i=minutes; i<grumpy.length; i++) {\\n            if(grumpy[i] == 1) {\\n                maxU+= customers[i];\\n            }\\n            if(grumpy[i-minutes] == 1) {\\n                    maxU-=  customers[i-minutes];\\n            }\\n            maxUnsatifiedCustomers = Math.max(maxUnsatifiedCustomers, maxU);\\n        }\\n        \\n        //Intially total satified customer\\n        int totalSatifiedCustomers = 0;\\n        for(int i=0; i<grumpy.length; i++) {\\n            if(grumpy[i] == 0) {\\n                totalSatifiedCustomers+=customers[i];\\n            }\\n        }\\n\\t\\t//think about it\\n\\t\\t// our answer is totalSatified + (m minutes window maximum unsatified)\\n        return totalSatifiedCustomers+maxUnsatifiedCustomers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949132,
                "title": "c-sliding-window-faster-than-90-commented-readable",
                "content": "class Solution {\\npublic:\\n*     int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int min) {\\n        int i = 0;\\n        int j = 0;\\n        int l = customers.size();\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        int total = 0;\\n        int currsat = 0;\\n        for(int m = 0;m < l; m++)\\n        {\\n            if(grumpy[m] == 0)\\n            {\\n                total += customers[m];  // total keeps the track of total satisfied customers without the owner using his technique\\n            }\\n        }\\n        while(j < l)\\n        {\\n            sum += customers[j];\\n            if(grumpy[j] == 0)\\n            {\\n                currsat += customers[j];   // Here we are keeping track of satisfied customers inside the window. the satisfied customers outside the window will be total - currsat. when we hit window size of minutes total satisfied customers will be currsat + window sum.\\n            }\\n            if(j-i+1 < min)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans = max(ans, sum + total - currsat);     // as soon as we hit the window size of minutes we will check how many satisfied customers are there currently which will be equal to the sum of window + the rest satisfied customers outside the window (currsat). and we will store the max of it whenever we hit the window size. It is not necessary that satisfied customers will be max whenever window sum is max !\\n                if(grumpy[i] == 0)\\n                {\\n                    currsat -= customers[i];\\n                }\\n                sum -= customers[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nDo upvote if you found it helpful !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n*     int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int min) {\\n        int i = 0;\\n        int j = 0;\\n        int l = customers.size();\\n        int sum = 0;\\n        int ans = INT_MIN;\\n        int total = 0;\\n        int currsat = 0;\\n        for(int m = 0;m < l; m++)\\n        {\\n            if(grumpy[m] == 0)\\n            {\\n                total += customers[m];  // total keeps the track of total satisfied customers without the owner using his technique\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1816120,
                "title": "c-easy-understanding-sliding-window-solution",
                "content": "```\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k)                {\\n        int sum = 0, n = grumpy.size(), ans = 0, j = k-1, i = 0                         ;\\n        vector<int> full_till, grumpy_till                                              ;\\n        for(auto &x : customers) full_till.push_back(sum += x)                          ;\\n        sum = 0                                                                         ;\\n        for(int t = 0; t < n; t++)                                                      {\\n            if(!grumpy[t]) sum += customers[t]                                          ;\\n            grumpy_till.push_back(sum)                                                  ;\\n                                                                                        } \\n        while(j < n)                                                                    {\\n            int full_interval, grumpy_interval                                          ;\\n            if(i > 0) \\n                grumpy_interval = grumpy_till[i-1]+(grumpy_till[n-1]-grumpy_till[j])    ;\\n            else \\n                grumpy_interval = (grumpy_till[n-1]-grumpy_till[j])                     ;\\n            if(i > 0) \\n                full_interval = full_till[j] - full_till[i-1]                           ;\\n            else \\n                full_interval = full_till[j]                                            ;\\n            \\n            ans = max(ans, (full_interval + grumpy_interval))                           ;\\n            j++; i++                                                                    ;\\n                                                                                        }\\n        return ans                                                                      ;}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k)                {\\n        int sum = 0, n = grumpy.size(), ans = 0, j = k-1, i = 0                         ;\\n        vector<int> full_till, grumpy_till                                              ;\\n        for(auto &x : customers) full_till.push_back(sum += x)                          ;\\n        sum = 0                                                                         ;\\n        for(int t = 0; t < n; t++)                                                      {\\n            if(!grumpy[t]) sum += customers[t]                                          ;\\n            grumpy_till.push_back(sum)                                                  ;\\n                                                                                        } \\n        while(j < n)                                                                    {\\n            int full_interval, grumpy_interval                                          ;\\n            if(i > 0) \\n                grumpy_interval = grumpy_till[i-1]+(grumpy_till[n-1]-grumpy_till[j])    ;\\n            else \\n                grumpy_interval = (grumpy_till[n-1]-grumpy_till[j])                     ;\\n            if(i > 0) \\n                full_interval = full_till[j] - full_till[i-1]                           ;\\n            else \\n                full_interval = full_till[j]                                            ;\\n            \\n            ans = max(ans, (full_interval + grumpy_interval))                           ;\\n            j++; i++                                                                    ;\\n                                                                                        }\\n        return ans                                                                      ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619444,
                "title": "sliding-window-easy-with-explanation-o-n-space-and-time",
                "content": "First of all, we dont have to worry about the items where the owner is not grumpy. Store the customers array in a temp array. \\nNow multiply every element in the customers array with subsequent grumpy array element. This leaves us with only the grumpy array. \\nNow find the window with size 3 and max size. Store it in some variable.\\nNow traverse the temp array. If the element in in the window size we got above, add it to the ans. \\nElse check if the subsequent grumpy[i]==0 or not. If 0 continue add it to the ans, else move on.\\n\\n```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        temp = customers[:]\\n        for i in range(len(customers)):\\n            customers[i] *= grumpy[i]\\n        \\n        i = 0\\n        j = 0\\n        maxSum = float(\\'-inf\\')\\n        sumi = 0\\n        while j<len(customers):\\n            sumi += customers[j]\\n            if j - i + 1 == minutes:\\n                if sumi>maxSum:\\n                    ans = [i,j+1]\\n                    maxSum = sumi\\n                sumi -= customers[i]\\n                i+=1\\n            j+=1\\n        start = ans[0]\\n        end = ans[1]\\n        satisfy = 0\\n        for i in range(len(temp)):\\n            if i in range(start,end):\\n                satisfy += temp[i]\\n            else:\\n                if grumpy[i]==0:\\n                    satisfy += temp[i]\\n        return satisfy\\n\\t```\\n\\tThis is not the most efficient code but I tried to write it in a way so that I can explain it to someone.",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        temp = customers[:]\\n        for i in range(len(customers)):\\n            customers[i] *= grumpy[i]\\n        \\n        i = 0\\n        j = 0\\n        maxSum = float(\\'-inf\\')\\n        sumi = 0\\n        while j<len(customers):\\n            sumi += customers[j]\\n            if j - i + 1 == minutes:\\n                if sumi>maxSum:\\n                    ans = [i,j+1]\\n                    maxSum = sumi\\n                sumi -= customers[i]\\n                i+=1\\n            j+=1\\n        start = ans[0]\\n        end = ans[1]\\n        satisfy = 0\\n        for i in range(len(temp)):\\n            if i in range(start,end):\\n                satisfy += temp[i]\\n            else:\\n                if grumpy[i]==0:\\n                    satisfy += temp[i]\\n        return satisfy\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1619376,
                "title": "o-n-easy-to-understand-python3-99-56-fast",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:\\n        satisfied_cust=0\\n        a=0\\n        max_satisfied=0\\n        n=len(customers)\\n        for i in range(len(grumpy)):\\n            if not grumpy[i]:\\n                satisfied_cust+=customers[i]         //number of customers that can be satisfied without super power \\n                customers[i]=0         //marking customers who are already satisfied\\n            max_satisfied+=customers[i]   //adding first block of minutes customer i.e fist block of customer who can be satisfied with super power \\n            if i >=k : \\n                max_satisfied-=customers[i-k]  //removing last element in block\\n            res=max(a,res)      //calcualting maximum number of satisfied cust\\n        return sol+res\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:\\n        satisfied_cust=0\\n        a=0\\n        max_satisfied=0\\n        n=len(customers)\\n        for i in range(len(grumpy)):\\n            if not grumpy[i]:\\n                satisfied_cust+=customers[i]         //number of customers that can be satisfied without super power \\n                customers[i]=0         //marking customers who are already satisfied\\n            max_satisfied+=customers[i]   //adding first block of minutes customer i.e fist block of customer who can be satisfied with super power \\n            if i >=k : \\n                max_satisfied-=customers[i-k]  //removing last element in block\\n            res=max(a,res)      //calcualting maximum number of satisfied cust\\n        return sol+res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551924,
                "title": "c-sliding-window-solution-for-1052-grumpy-bookstore-owner",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) \\n    {\\n        int i = 0, j = 0, k = minutes, sz = customers.size(), res = 0;\\n        int dissatisfied = 0, satisfied = 0;\\n        \\n        while(j<sz)\\n        {\\n            if(grumpy[j] == 1){ dissatisfied += customers[j] ;}\\n            \\n            if(j-i+1 <k){j++ ;}\\n            else{\\n                res = max(res, dissatisfied) ;\\n                if(grumpy[i] == 1){ dissatisfied -= customers[i] ;}\\n                i++ ; j++ ;\\n            }\\n        }\\n        for(int i=0; i<sz; i++){ if(grumpy[i] == 0){ satisfied += customers[i] ;} }\\n        return res + satisfied ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) \\n    {\\n        int i = 0, j = 0, k = minutes, sz = customers.size(), res = 0;\\n        int dissatisfied = 0, satisfied = 0;\\n        \\n        while(j<sz)\\n        {\\n            if(grumpy[j] == 1){ dissatisfied += customers[j] ;}\\n            \\n            if(j-i+1 <k){j++ ;}\\n            else{\\n                res = max(res, dissatisfied) ;\\n                if(grumpy[i] == 1){ dissatisfied -= customers[i] ;}\\n                i++ ; j++ ;\\n            }\\n        }\\n        for(int i=0; i<sz; i++){ if(grumpy[i] == 0){ satisfied += customers[i] ;} }\\n        return res + satisfied ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416537,
                "title": "python-sliding-window-beats-95-time-75-space",
                "content": "Time Complexity - O(N), Space Complexity - O(1)\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        leftIndex = 0\\n        satisfied, maxSatisfied, currMax = 0, 0, 0\\n        \\n        for i in range(len(customers)):\\n            satisfied += customers[i] if not grumpy[i] else 0\\n            currMax += customers[i] if grumpy[i] else 0\\n            if i >= minutes:\\n                currMax -= customers[leftIndex] if grumpy[leftIndex] else 0\\n                leftIndex += 1\\n                \\n            maxSatisfied = max(maxSatisfied, currMax)\\n            \\n        return satisfied + maxSatisfied",
                "solutionTags": [],
                "code": "Time Complexity - O(N), Space Complexity - O(1)\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        leftIndex = 0\\n        satisfied, maxSatisfied, currMax = 0, 0, 0\\n        \\n        for i in range(len(customers)):\\n            satisfied += customers[i] if not grumpy[i] else 0\\n            currMax += customers[i] if grumpy[i] else 0\\n            if i >= minutes:\\n                currMax -= customers[leftIndex] if grumpy[leftIndex] else 0\\n                leftIndex += 1\\n                \\n            maxSatisfied = max(maxSatisfied, currMax)\\n            \\n        return satisfied + maxSatisfied",
                "codeTag": "Java"
            },
            {
                "id": 1355469,
                "title": "golang-sliding-window-faster-than-100",
                "content": "```\\nfunc maxSatisfied(customers []int, grumpy []int, X int) int {\\n\\tmax := 0\\n\\tsatisfied := 0\\n\\ttemp := 0\\n\\n\\tfor i := 0; i < X; i++ {\\n\\t\\tsatisfied, temp = AddToSatisfiedOrTemp(customers, grumpy, i, satisfied, temp)\\n\\t}\\n\\n\\tmax = temp\\n\\n\\tfor i := X; i < len(customers); i++ {\\n\\t\\tif grumpy[i - X] == 1 {\\n\\t\\t\\ttemp -= customers[i - X]\\n\\t\\t}\\n\\n\\t\\tsatisfied, temp = AddToSatisfiedOrTemp(customers, grumpy, i, satisfied, temp)\\n        \\n\\t\\tmax = int(math.Max(float64(max), float64(temp)))\\n\\t}\\n\\n\\treturn satisfied + max\\n}\\n\\nfunc AddToSatisfiedOrTemp(customers []int, grumpy []int, i int, satisfied int, temp int) (int, int) {\\n\\tif grumpy[i] == 0 {\\n\\t\\tsatisfied += customers[i]\\n\\t} else {\\n\\t\\ttemp += customers[i]\\n\\t}\\n    \\n\\treturn satisfied, temp\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSatisfied(customers []int, grumpy []int, X int) int {\\n\\tmax := 0\\n\\tsatisfied := 0\\n\\ttemp := 0\\n\\n\\tfor i := 0; i < X; i++ {\\n\\t\\tsatisfied, temp = AddToSatisfiedOrTemp(customers, grumpy, i, satisfied, temp)\\n\\t}\\n\\n\\tmax = temp\\n\\n\\tfor i := X; i < len(customers); i++ {\\n\\t\\tif grumpy[i - X] == 1 {\\n\\t\\t\\ttemp -= customers[i - X]\\n\\t\\t}\\n\\n\\t\\tsatisfied, temp = AddToSatisfiedOrTemp(customers, grumpy, i, satisfied, temp)\\n        \\n\\t\\tmax = int(math.Max(float64(max), float64(temp)))\\n\\t}\\n\\n\\treturn satisfied + max\\n}\\n\\nfunc AddToSatisfiedOrTemp(customers []int, grumpy []int, i int, satisfied int, temp int) (int, int) {\\n\\tif grumpy[i] == 0 {\\n\\t\\tsatisfied += customers[i]\\n\\t} else {\\n\\t\\ttemp += customers[i]\\n\\t}\\n    \\n\\treturn satisfied, temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339169,
                "title": "ez-python-code-using-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        i=0\\n        summ=0\\n        while i<len(customers):\\n            if grumpy[i]==0:\\n                summ=summ+customers[i]\\n                customers[i]=0\\n            i=i+1\\n        i=0\\n        j=0\\n        s=0\\n        maxx=-1\\n        while j<len(customers):\\n            s=s+customers[j]\\n            if j>=minutes-1:\\n                maxx=max(maxx,s)\\n                s=s-customers[i]\\n                i=i+1\\n            j=j+1\\n        return summ+maxx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        i=0\\n        summ=0\\n        while i<len(customers):\\n            if grumpy[i]==0:\\n                summ=summ+customers[i]\\n                customers[i]=0\\n            i=i+1\\n        i=0\\n        j=0\\n        s=0\\n        maxx=-1\\n        while j<len(customers):\\n            s=s+customers[j]\\n            if j>=minutes-1:\\n                maxx=max(maxx,s)\\n                s=s-customers[i]\\n                i=i+1\\n            j=j+1\\n        return summ+maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332077,
                "title": "javascript-solution-sliding-window",
                "content": "```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n    const n = customers.length;\\n    \\n    let happy = 0; // total # of happy customers\\n    let angry = 0; // current angry customers\\n    let left = 0; // left window start\\n    let max = 0; // the max # of angry customers at any given window\\n    \\n    for (let i = 0; i < n; i++) {\\n        const owner = grumpy[i]; // owners current mood\\n        const current = customers[i]; // the new # set of customers entering the store\\n        \\n        if (i >= minutes) { // We update our window\\n            if (grumpy[left] === 1) angry -= customers[left];\\n            left++;\\n        }\\n        \\n        if (owner === 0) {\\n            happy += current;\\n        } else {\\n            angry += current;\\n            max = Math.max(max, angry);\\n        }\\n    }\\n    \\n    return happy + max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n    const n = customers.length;\\n    \\n    let happy = 0; // total # of happy customers\\n    let angry = 0; // current angry customers\\n    let left = 0; // left window start\\n    let max = 0; // the max # of angry customers at any given window\\n    \\n    for (let i = 0; i < n; i++) {\\n        const owner = grumpy[i]; // owners current mood\\n        const current = customers[i]; // the new # set of customers entering the store\\n        \\n        if (i >= minutes) { // We update our window\\n            if (grumpy[left] === 1) angry -= customers[left];\\n            left++;\\n        }\\n        \\n        if (owner === 0) {\\n            happy += current;\\n        } else {\\n            angry += current;\\n            max = Math.max(max, angry);\\n        }\\n    }\\n    \\n    return happy + max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1321784,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        //uses sliding window approach\\n        //we need to find subarray in customers of len minutes with maximum sum when shopkeeper is grumpy\\n        //this can be represented as finding subarray with max sum where a number is counted only when shopkeeper is grumpy\\n        //this can be done by multiplying grumpy[i] with customers[i]\\n        \\n        int i = 0; //startIndex of window\\n        int j = 0; //endIndex of window\\n        int n = customers.size();\\n        int maxSum = 0;\\n        int curSum = 0;\\n        int happyCustomers = 0;\\n        \\n        //calculate first window\\n        for(j = 0; j < minutes; j++) {            \\n            curSum += customers[j]*grumpy[j];\\n            //add customers when shopkeeper is not grumpy\\n            happyCustomers += !grumpy[j]*customers[j];\\n        }\\n        \\n        maxSum = curSum;\\n        \\n        //keep moving window by one index till we reach the end\\n        while(i < n && j < n) {\\n            \\n            curSum += customers[j]*grumpy[j];\\n            curSum -= customers[i]*grumpy[i];\\n            happyCustomers += !grumpy[j]*customers[j];\\n            i++;\\n            j++;\\n            if(maxSum < curSum) {\\n                maxSum = curSum;\\n                beginIndex = i;\\n            }\\n            \\n        }\\n        \\n        //maxSum contains subArray of size minutes, where max customers are dissatisfied due to shopkeeper being grumpy.\\n        //apply minutes power for this subArray, will help reduce dissatisfied customers in this subarray(maxSum) the most. \\n        happyCustomers += maxSum;\\n        \\n        return happyCustomers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        \\n        //uses sliding window approach\\n        //we need to find subarray in customers of len minutes with maximum sum when shopkeeper is grumpy\\n        //this can be represented as finding subarray with max sum where a number is counted only when shopkeeper is grumpy\\n        //this can be done by multiplying grumpy[i] with customers[i]\\n        \\n        int i = 0; //startIndex of window\\n        int j = 0; //endIndex of window\\n        int n = customers.size();\\n        int maxSum = 0;\\n        int curSum = 0;\\n        int happyCustomers = 0;\\n        \\n        //calculate first window\\n        for(j = 0; j < minutes; j++) {            \\n            curSum += customers[j]*grumpy[j];\\n            //add customers when shopkeeper is not grumpy\\n            happyCustomers += !grumpy[j]*customers[j];\\n        }\\n        \\n        maxSum = curSum;\\n        \\n        //keep moving window by one index till we reach the end\\n        while(i < n && j < n) {\\n            \\n            curSum += customers[j]*grumpy[j];\\n            curSum -= customers[i]*grumpy[i];\\n            happyCustomers += !grumpy[j]*customers[j];\\n            i++;\\n            j++;\\n            if(maxSum < curSum) {\\n                maxSum = curSum;\\n                beginIndex = i;\\n            }\\n            \\n        }\\n        \\n        //maxSum contains subArray of size minutes, where max customers are dissatisfied due to shopkeeper being grumpy.\\n        //apply minutes power for this subArray, will help reduce dissatisfied customers in this subarray(maxSum) the most. \\n        happyCustomers += maxSum;\\n        \\n        return happyCustomers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289180,
                "title": "simple-12-line-js-solution",
                "content": "---\\n# Simple Sliding Window Solution\\n---\\n* 12 Lines\\n* Runtime:  Faster than 72.90% of solutions\\n* Memory: Less than 22.43% of JavaScript Solutions\\n---\\n![image](https://assets.leetcode.com/users/images/27feb3d3-d81e-4007-8d93-43be66074827_1624340278.1508093.png)\\n\\n```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n let max = 0, happy = 0, right = 0\\n for (let right = 0; right < grumpy.length; right++) {\\n     if (grumpy[right] === 0) {\\n         happy += customers[right]\\n         customers[right] = customers[right-1] ?? 0\\n         continue\\n     }        \\n     const left = right - minutes\\n     customers[right] += customers[right-1] ?? 0\\n     max = Math.max(max, customers[right] - (customers[left] ?? 0))\\n }     \\n return max + happy\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maxSatisfied = function(customers, grumpy, minutes) {\\n let max = 0, happy = 0, right = 0\\n for (let right = 0; right < grumpy.length; right++) {\\n     if (grumpy[right] === 0) {\\n         happy += customers[right]\\n         customers[right] = customers[right-1] ?? 0\\n         continue\\n     }        \\n     const left = right - minutes\\n     customers[right] += customers[right-1] ?? 0\\n     max = Math.max(max, customers[right] - (customers[left] ?? 0))\\n }     \\n return max + happy\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277151,
                "title": "fixed-size-sliding-window-while-loop",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, c: List[int], g: List[int], k: int) -> int:\\n        s = 0 ; res = 0\\n        n = len(c)\\n        for i in range(n):\\n            if g[i]==0:\\n                s += c[i]\\n        i,j = 0,0\\n        while j<n:\\n            if g[j]==1:\\n                s += c[j]\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res = max(res,s)\\n                if g[i]==1:\\n                    s-=c[i]\\n                i+=1\\n                j+=1\\n        return res\\n        \\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, c: List[int], g: List[int], k: int) -> int:\\n        s = 0 ; res = 0\\n        n = len(c)\\n        for i in range(n):\\n            if g[i]==0:\\n                s += c[i]\\n        i,j = 0,0\\n        while j<n:\\n            if g[j]==1:\\n                s += c[j]\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                res = max(res,s)\\n                if g[i]==1:\\n                    s-=c[i]\\n                i+=1\\n                j+=1\\n        return res\\n        \\n                \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1238402,
                "title": "sliding-window-c-solution-faster-than-99-45-of-c-online-sub",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n      //initializing two pointers   \\n    int l = 0;\\n    int r=0; \\n    int maxUnSatisfiedCustomer = 0;\\n    int unSatisfiedCustomer = 0;\\n    int satisfiedCustomer = 0;   \\n    while(r < grumpy.size()){\\n        if(grumpy[r]){\\n            unSatisfiedCustomer += customers[r++];\\n        }else {\\n            satisfiedCustomer += customers[r++];\\n        }\\n\\n        if(r - l > minutes){\\n            if(grumpy[l]){\\n                 unSatisfiedCustomer -= customers[l];\\n             }\\n            l++;\\n        }\\n        maxUnSatisfiedCustomer = max(maxUnSatisfiedCustomer, unSatisfiedCustomer);\\n    }\\n         return satisfiedCustomer + maxUnSatisfiedCustomer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n      //initializing two pointers   \\n    int l = 0;\\n    int r=0; \\n    int maxUnSatisfiedCustomer = 0;\\n    int unSatisfiedCustomer = 0;\\n    int satisfiedCustomer = 0;   \\n    while(r < grumpy.size()){\\n        if(grumpy[r]){\\n            unSatisfiedCustomer += customers[r++];\\n        }else {\\n            satisfiedCustomer += customers[r++];\\n        }\\n\\n        if(r - l > minutes){\\n            if(grumpy[l]){\\n                 unSatisfiedCustomer -= customers[l];\\n             }\\n            l++;\\n        }\\n        maxUnSatisfiedCustomer = max(maxUnSatisfiedCustomer, unSatisfiedCustomer);\\n    }\\n         return satisfiedCustomer + maxUnSatisfiedCustomer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222849,
                "title": "c-using-sliding-window-100-easy-understanding",
                "content": "class Solution {\\npublic:\\n    \\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes)\\n    {\\n        int i=0;\\n        int j=0;\\n        int sum =0;\\n        int maxx= 0;\\n        int temp=0;\\n        int n=customers.size();\\n        while(j-i+1<minutes)\\n        {\\n             if(grumpy[j]==0)\\n                sum = sum+customers[j];\\n            \\n            else\\n                temp = temp + customers[j];\\n            j++;\\n        }\\n        while(j<n)\\n        {\\n            if(grumpy[j]==0)\\n                sum = sum+customers[j];\\n            \\n            else\\n                temp = temp + customers[j];\\n            \\n                maxx = max(maxx,temp);\\n                if(grumpy[i]==1)\\n                    temp=temp-customers[i];\\n                i++;\\n                j++;\\n        }\\n        return sum+maxx;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes)\\n    {\\n        int i=0;\\n        int j=0;\\n        int sum =0;\\n        int maxx= 0;\\n        int temp=0;\\n        int n=customers.size();\\n        while(j-i+1<minutes)\\n        {\\n             if(grumpy[j]==0)\\n                sum = sum+customers[j];\\n            \\n            else\\n                temp = temp + customers[j];\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1208867,
                "title": "python-easy-to-understand-beats-86-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:\\n        current_customers_satisfied = 0\\n        \\n\\t\\t# Calculating how many customers the owner satisfies when he is not grumpy\\n        for i in range(len(customers)):\\n            if not grumpy[i]:\\n                current_customers_satisfied += customers[i]\\n                \\n        temp = 0\\n        \\n\\t\\t#Referencing \\'k\\' value as our power window\\n\\t\\t#calculating how many ** additional** customers the owner satisfies with the power\\n        for i in range(k):\\n            if grumpy[i]:  \\n                temp += customers[i]\\n                \\n        current_customers_satisfied += temp\\n        max_customers_satisfied = current_customers_satisfied\\n        \\n\\t\\t\\n        for r in range(k, len(customers)):         \\n\\n            if grumpy[r]:\\n                current_customers_satisfied += customers[r]\\n                \\n            if grumpy[r-k]:\\n                current_customers_satisfied -= customers[r-k]\\n            \\n            max_customers_satisfied = max(current_customers_satisfied, max_customers_satisfied)\\n            \\n        return max_customers_satisfied\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], k: int) -> int:\\n        current_customers_satisfied = 0\\n        \\n\\t\\t# Calculating how many customers the owner satisfies when he is not grumpy\\n        for i in range(len(customers)):\\n            if not grumpy[i]:\\n                current_customers_satisfied += customers[i]\\n                \\n        temp = 0\\n        \\n\\t\\t#Referencing \\'k\\' value as our power window\\n\\t\\t#calculating how many ** additional** customers the owner satisfies with the power\\n        for i in range(k):\\n            if grumpy[i]:  \\n                temp += customers[i]\\n                \\n        current_customers_satisfied += temp\\n        max_customers_satisfied = current_customers_satisfied\\n        \\n\\t\\t\\n        for r in range(k, len(customers)):         \\n\\n            if grumpy[r]:\\n                current_customers_satisfied += customers[r]\\n                \\n            if grumpy[r-k]:\\n                current_customers_satisfied -= customers[r-k]\\n            \\n            max_customers_satisfied = max(current_customers_satisfied, max_customers_satisfied)\\n            \\n        return max_customers_satisfied\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202779,
                "title": "c-sliding-window-explained",
                "content": "Since the minutes at which the owner is not grumpy never changes, we can simply calculate their sum as our bare -minimum ans. Next run a sliding window of size X iteratively calculating the \\'additonal\\' ans we can achieve by setting grumpy[i] to 0. Take its maximum and add to our previously calculated ans.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int ans=0,n=grumpy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!grumpy[i])\\n                ans+=customers[i];\\n        }\\n        int add=0,tans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(grumpy[i])\\n                add+=customers[i];\\n        }\\n        tans=add;\\n        for(int i=k;i<n;i++)\\n        {\\n            if(grumpy[i])\\n                add+=customers[i];\\n            if(grumpy[i-k])\\n                add-=customers[i-k];\\n            tans=max(tans,add);\\n        }\\n        ans+=tans;\\n        return ans;\\n    }\\n};\\n//TC:O(n)\\n//SC:O(1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int ans=0,n=grumpy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!grumpy[i])\\n                ans+=customers[i];\\n        }\\n        int add=0,tans=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(grumpy[i])\\n                add+=customers[i];\\n        }\\n        tans=add;\\n        for(int i=k;i<n;i++)\\n        {\\n            if(grumpy[i])\\n                add+=customers[i];\\n            if(grumpy[i-k])\\n                add-=customers[i-k];\\n            tans=max(tans,add);\\n        }\\n        ans+=tans;\\n        return ans;\\n    }\\n};\\n//TC:O(n)\\n//SC:O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197168,
                "title": "javascript-solution-sliding-window",
                "content": "```\\nvar maxSatisfied = function(customers, grumpy, X) {\\n    let start = 0, end, grumpy_sub_total = 0, total = 0, max= 0;\\n    \\n    for(end = 0; end < customers.length; end++) {\\n        \\n        total += grumpy[end]==0 ? customers[end] : 0;\\n        grumpy_sub_total += grumpy[end] == 1 ? customers[end] : 0;\\n        \\n        if(end-start+1 > X) {\\n            if(grumpy[start] == 1) {\\n                grumpy_sub_total -= customers[start];\\n            }\\n            start += 1;\\n        }\\n        \\n        max = Math.max(max, grumpy_sub_total);\\n    }\\n    \\n    return total+max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maxSatisfied = function(customers, grumpy, X) {\\n    let start = 0, end, grumpy_sub_total = 0, total = 0, max= 0;\\n    \\n    for(end = 0; end < customers.length; end++) {\\n        \\n        total += grumpy[end]==0 ? customers[end] : 0;\\n        grumpy_sub_total += grumpy[end] == 1 ? customers[end] : 0;\\n        \\n        if(end-start+1 > X) {\\n            if(grumpy[start] == 1) {\\n                grumpy_sub_total -= customers[start];\\n            }\\n            start += 1;\\n        }\\n        \\n        max = Math.max(max, grumpy_sub_total);\\n    }\\n    \\n    return total+max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1193630,
                "title": "java-solution-sliding-window-o-n",
                "content": "The goal is to allign the window of length X with the subarray which dis-satisfies the most customers when the owner is grumpy. Therefore, this problem can be interpreted as finding any subarray that has the biggest sum on the minutes when owner is grumpy - which is the pure gain by applying the magic technique over X minutes to ensure owner is not grumpy. \\n\\nOn top of that, while interating the array, we also need to keep track of the total number of customers that can be satisfied during non-grumpy minutes.\\n\\nThis is just a slightly different variation of the classic fixed-length sliding window problem - finding the max sum subarray of length X.\\n\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int totalCustNoGrumpy = 0;\\n        int maxSumGain = 0;\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < customers.length; i++)\\n        {\\n            if (grumpy[i] == 1)\\n                runningSum += customers[i];\\n            else\\n                totalCustNoGrumpy += customers[i];\\n            if (i >= X-1)\\n            {\\n                maxSumGain = Math.max(maxSumGain, runningSum);\\n                if (grumpy[i-(X-1)] == 1)\\n                    runningSum -= customers[i-(X-1)];\\n            }\\n        }\\n        return totalCustNoGrumpy + maxSumGain;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int totalCustNoGrumpy = 0;\\n        int maxSumGain = 0;\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < customers.length; i++)\\n        {\\n            if (grumpy[i] == 1)\\n                runningSum += customers[i];\\n            else\\n                totalCustNoGrumpy += customers[i];\\n            if (i >= X-1)\\n            {\\n                maxSumGain = Math.max(maxSumGain, runningSum);\\n                if (grumpy[i-(X-1)] == 1)\\n                    runningSum -= customers[i-(X-1)];\\n            }\\n        }\\n        return totalCustNoGrumpy + maxSumGain;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193074,
                "title": "simplest-one-pass-c-solution-ever",
                "content": "The `freeSum` variable keeps adding the values when the bookstore owner is not grumpy as I can take all of them without any constraint.\\nI run a window over the array, with its initial point as` j = 0` , and ending point as `i`. Let the window grow initially to take a size of `x`, till then, just keep adding the value if its a grumpy day ( means `freeSum` lacks that element ). When the window reaches its max size, I keep on removing the starting element if I added it in the first place ( just need to check if `jth` day was grumpy ).\\nMaintain a maxWindow which keeps track of maximum window value so far.\\n\\nFinally, return the sum of `maxWindow` and `freeSum` :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& v, vector<int>& g, int x) {\\n        int freeSum=0, window = 0, maxWindow=0, winSz=0, j=0;\\n        \\n        for(int i = 0; i < v.size(); i++){\\n            if(g[i]){\\n                window += v[i];\\n            }\\n            else {\\n                freeSum += v[i];\\n            }\\n            \\n            if(winSz < x){\\n                winSz++;\\n            }\\n            else{\\n                if(g[j])\\n                    window -= v[j];\\n                j++;\\n            }\\n            \\n            maxWindow = max(maxWindow, window);\\n        }\\n        \\n        return freeSum + maxWindow;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& v, vector<int>& g, int x) {\\n        int freeSum=0, window = 0, maxWindow=0, winSz=0, j=0;\\n        \\n        for(int i = 0; i < v.size(); i++){\\n            if(g[i]){\\n                window += v[i];\\n            }\\n            else {\\n                freeSum += v[i];\\n            }\\n            \\n            if(winSz < x){\\n                winSz++;\\n            }\\n            else{\\n                if(g[j])\\n                    window -= v[j];\\n                j++;\\n            }\\n            \\n            maxWindow = max(maxWindow, window);\\n        }\\n        \\n        return freeSum + maxWindow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190682,
                "title": "python-very-easy-explanations",
                "content": "This is very eay problem. We just have to find the maximum number of custromers that are \\nlost when the shopkeeper is grumpy in the window of X.\\nThen we will add this to our final sum of customers\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        i=0\\n        max_save = 0\\n        curr = 0\\n        for j in range(len(grumpy)):\\n            if j-i+1>X:\\n                if grumpy[i]>0:\\n                    curr -= customers[i]\\n                i+=1\\n            if grumpy[j]>0:\\n                curr +=  customers[j]\\n                max_save = max(max_save,curr)\\n        ans = max_save\\n        for i in range(len(grumpy)):\\n            if grumpy[i]==0:\\n                ans+=customers[i]\\n        return ans\\n                \\n",
                "solutionTags": [],
                "code": "This is very eay problem. We just have to find the maximum number of custromers that are \\nlost when the shopkeeper is grumpy in the window of X.\\nThen we will add this to our final sum of customers\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        i=0\\n        max_save = 0\\n        curr = 0\\n        for j in range(len(grumpy)):\\n            if j-i+1>X:\\n                if grumpy[i]>0:\\n                    curr -= customers[i]\\n                i+=1\\n            if grumpy[j]>0:\\n                curr +=  customers[j]\\n                max_save = max(max_save,curr)\\n        ans = max_save\\n        for i in range(len(grumpy)):\\n            if grumpy[i]==0:\\n                ans+=customers[i]\\n        return ans\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1161455,
                "title": "simple-swift-solution-o-n",
                "content": "class Solution {\\n    func maxSatisfied(_ nums: [Int], _ grumpy: [Int], _ X: Int) -> Int {\\n        \\n        //function to check if index is grumpy\\n        func isGrumpy(_ index: Int) -> Bool {\\n            return grumpy[index] == 1   \\n        }\\n        \\n        //fill all satisfied customers\\n        var satisfiedCust = 0 \\n        for i in 0 ..< nums.count{\\n            if !isGrumpy(i){\\n                satisfiedCust += nums[i]\\n            }\\n        }\\n        \\n        var ans = 0\\n        var start = 0\\n        var end = 0\\n        var satisfiedCustInWindow = 0\\n        \\n        while end < nums.count {\\n            //add unsatified customers in window -> window can have all unsatisfied customers as satisfied.\\n            if isGrumpy(end) {\\n                satisfiedCustInWindow += nums[end]\\n            }\\n            if (end - start + 1) < X { // increment end index till window is reached\\n                end += 1\\n            }else if (end - start + 1) == X  { \\n                // widow reached reached -> check for max customers and substract un statisfied customer from start of window if index is grumpy and move window forward\\n                ans = max(ans, satisfiedCustInWindow + satisfiedCust)\\n                if isGrumpy(start){\\n                    satisfiedCustInWindow -= nums[start]\\n                }\\n                start += 1\\n                end += 1\\n            } \\n        }\\n        return ans\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    func maxSatisfied(_ nums: [Int], _ grumpy: [Int], _ X: Int) -> Int {\\n        \\n        //function to check if index is grumpy\\n        func isGrumpy(_ index: Int) -> Bool {\\n            return grumpy[index] == 1   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1133596,
                "title": "python-code-faster-than-99-58-easy-to-understand",
                "content": "Calculate the max number of customers when the owner is grumpy for each sliding window of size X.\\nIn the end, add all the customers when the owner is not grumpy. \\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        res = 0\\n        for i in range(X):\\n            if grumpy[i]:\\n                res += customers[i]\\n                \\n        temp = res\\n        idx = 0\\n        for i in range(len(customers)-X):\\n            \\n            if grumpy[i]:\\n                temp -= customers[i]\\n            if grumpy[i+X]:\\n                temp += customers[i+X]\\n            if temp > res:\\n                res = temp\\n                idx = i+1\\n        \\n        for i in range(len(customers)):\\n            if not grumpy[i]:\\n                res += customers[i] \\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        res = 0\\n        for i in range(X):\\n            if grumpy[i]:\\n                res += customers[i]\\n                \\n        temp = res\\n        idx = 0\\n        for i in range(len(customers)-X):\\n            \\n            if grumpy[i]:\\n                temp -= customers[i]\\n            if grumpy[i+X]:\\n                temp += customers[i+X]\\n            if temp > res:\\n                res = temp\\n                idx = i+1\\n        \\n        for i in range(len(customers)):\\n            if not grumpy[i]:\\n                res += customers[i] \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080152,
                "title": "c-go-sliding-window",
                "content": "C++\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum = 0;\\n        for (int i = 0; i < customers.size(); i++) {\\n            sum += customers[i] * (grumpy[i] == 0);\\n        }\\n\\n        int diff = 0, maxDiff = 0;\\n        for (int i = 0; i < X; i++)  {\\n            diff += customers[i] * (grumpy[i]);\\n        }\\n\\n        maxDiff = diff;\\n        for (int i = 1; i + X <= customers.size(); i++) {\\n            diff = diff - customers[i - 1] * (grumpy[i - 1]) + customers[i + X - 1] * (grumpy[i + X - 1]);\\n            maxDiff = max(diff, maxDiff);\\n        }\\n        return sum + maxDiff;\\n    }\\n};\\n```\\n\\nGo\\n```\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc maxSatisfied(customers []int, grumpy []int, X int) int {\\n    var sum, diff, maxDiff int = 0, 0, 0;\\n    for i := 0; i < len(customers); i++ {\\n        if grumpy[i] == 0 {\\n            sum += customers[i];\\n        }\\n    }\\n    \\n    for i := 0; i < X; i++ {\\n        if grumpy[i] == 1 {\\n            diff += customers[i];\\n        }\\n    }\\n    \\n    maxDiff = diff;\\n    for i := 1; i + X <= len(customers); i++ {\\n        if grumpy[i - 1] == 1 {\\n            diff -= customers[i - 1]\\n        }\\n        if grumpy[i + X - 1] == 1 {\\n            diff += customers[i + X - 1]\\n        }\\n        maxDiff = max(diff, maxDiff)\\n    }\\n    \\n    return sum + maxDiff;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum = 0;\\n        for (int i = 0; i < customers.size(); i++) {\\n            sum += customers[i] * (grumpy[i] == 0);\\n        }\\n\\n        int diff = 0, maxDiff = 0;\\n        for (int i = 0; i < X; i++)  {\\n            diff += customers[i] * (grumpy[i]);\\n        }\\n\\n        maxDiff = diff;\\n        for (int i = 1; i + X <= customers.size(); i++) {\\n            diff = diff - customers[i - 1] * (grumpy[i - 1]) + customers[i + X - 1] * (grumpy[i + X - 1]);\\n            maxDiff = max(diff, maxDiff);\\n        }\\n        return sum + maxDiff;\\n    }\\n};\\n```\n```\\nfunc max(a, b int) int {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc maxSatisfied(customers []int, grumpy []int, X int) int {\\n    var sum, diff, maxDiff int = 0, 0, 0;\\n    for i := 0; i < len(customers); i++ {\\n        if grumpy[i] == 0 {\\n            sum += customers[i];\\n        }\\n    }\\n    \\n    for i := 0; i < X; i++ {\\n        if grumpy[i] == 1 {\\n            diff += customers[i];\\n        }\\n    }\\n    \\n    maxDiff = diff;\\n    for i := 1; i + X <= len(customers); i++ {\\n        if grumpy[i - 1] == 1 {\\n            diff -= customers[i - 1]\\n        }\\n        if grumpy[i + X - 1] == 1 {\\n            diff += customers[i + X - 1]\\n        }\\n        maxDiff = max(diff, maxDiff)\\n    }\\n    \\n    return sum + maxDiff;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019034,
                "title": "c-solution-using-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        /*sum is the number of satisfied customers before using secret techinique. \\n        curr is the number of customers we can turn from unsatisfied to satisfied in X window using secret technique. \\n        largest is the maximum number of customers we can turn \\n        */\\n        int sum = 0, curr = 0, largest = 0;\\n        int n = customers.size();\\n        for(int i = 0; i < n; i++){\\n            if(grumpy[i] == 0) sum += customers[i];\\n            else{\\n                curr += customers[i];\\n            }\\n            \\n            if(i >= X){\\n                curr -= customers[i -X] * grumpy[i - X];\\n            }\\n            largest = max(largest, curr);\\n        }\\n        \\n        return sum + largest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        /*sum is the number of satisfied customers before using secret techinique. \\n        curr is the number of customers we can turn from unsatisfied to satisfied in X window using secret technique. \\n        largest is the maximum number of customers we can turn \\n        */\\n        int sum = 0, curr = 0, largest = 0;\\n        int n = customers.size();\\n        for(int i = 0; i < n; i++){\\n            if(grumpy[i] == 0) sum += customers[i];\\n            else{\\n                curr += customers[i];\\n            }\\n            \\n            if(i >= X){\\n                curr -= customers[i -X] * grumpy[i - X];\\n            }\\n            largest = max(largest, curr);\\n        }\\n        \\n        return sum + largest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014647,
                "title": "c-100-faster-easy-solution-with-explanation",
                "content": "if owner is not grumpy in that minute, add the customers to result.\\notherwise use sliding window, if owner is grumpy  add that (no of customer) in the window, and while sliding subtract (customer[i]) only if the owner was grumpy in that minute ( i-X minute)\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n= grumpy.size();\\n        int res=0, s=0, mx=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!grumpy[i]) res+=customers[i];\\n        }\\n        for(int i=0; i<n ; i++)\\n        {\\n            if(grumpy[i]==1)\\n                s+=customers[i];\\n            if(i>=X and grumpy[i-X])\\n                s-=customers[i-X];\\n            \\n            mx=max(s,mx);\\n        }\\n        return res+mx;\\n        \\n    }\\n};\\n```\\ndo upvote if it helped :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n= grumpy.size();\\n        int res=0, s=0, mx=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!grumpy[i]) res+=customers[i];\\n        }\\n        for(int i=0; i<n ; i++)\\n        {\\n            if(grumpy[i]==1)\\n                s+=customers[i];\\n            if(i>=X and grumpy[i-X])\\n                s-=customers[i-X];\\n            \\n            mx=max(s,mx);\\n        }\\n        return res+mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013811,
                "title": "python3-2-pointer",
                "content": "**Algo**\\nKeep track of summation of customers when owner is grumpy and un-grumpy separately. For the grumpy sum, use a sliding window of two pointers `[ii, i]` for the extra value to be added back. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        ans = val = ii = mx = 0\\n        for i in range(len(customers)): \\n            if not grumpy[i]: ans += customers[i]\\n            else: \\n                val += customers[i]\\n                while ii <= i-X: \\n                    if grumpy[ii]: val -= customers[ii]\\n                    ii += 1\\n                mx = max(mx, val)\\n        return ans + mx \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        ans = val = ii = mx = 0\\n        for i in range(len(customers)): \\n            if not grumpy[i]: ans += customers[i]\\n            else: \\n                val += customers[i]\\n                while ii <= i-X: \\n                    if grumpy[ii]: val -= customers[ii]\\n                    ii += 1\\n                mx = max(mx, val)\\n        return ans + mx \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013572,
                "title": "java-one-pass-sliding-window",
                "content": "The idea is to move a sliding window across the array of width X.\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        // We track the number of satisfied customers without using the \"secret technique\".\\n        int satisfied = 0;\\n        // The current best number of unsatisfied customers saved using the \"secret technique\".\\n        int saved = 0;\\n        // Number the number of saved customers in a sliding window of size X.\\n        int runningSavedSum = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            // Remove (if applicable) the left element of the sliding window.\\n            if (i - X >= 0 && grumpy[i - X] == 1) runningSavedSum -= customers[i - X];\\n            if (grumpy[i] == 0) satisfied += customers[i];\\n            else {\\n                runningSavedSum += customers[i];\\n                saved = Math.max(saved, runningSavedSum);\\n            }\\n        }\\n        return satisfied + saved;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        // We track the number of satisfied customers without using the \"secret technique\".\\n        int satisfied = 0;\\n        // The current best number of unsatisfied customers saved using the \"secret technique\".\\n        int saved = 0;\\n        // Number the number of saved customers in a sliding window of size X.\\n        int runningSavedSum = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            // Remove (if applicable) the left element of the sliding window.\\n            if (i - X >= 0 && grumpy[i - X] == 1) runningSavedSum -= customers[i - X];\\n            if (grumpy[i] == 0) satisfied += customers[i];\\n            else {\\n                runningSavedSum += customers[i];\\n                saved = Math.max(saved, runningSavedSum);\\n            }\\n        }\\n        return satisfied + saved;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982498,
                "title": "java-o-n-track-of-customers-who-can-be-made-happy-w-technique",
                "content": "In order to solve this problem, we need to determine what selection technique is **optimal** for the shopkeeper to maximize satisfied customers? It is *not* just tracking the maximum number of customers over X minutes, because there is no benefit to the owner applying their technique if they would *not* ordinarily be grumpy during those times. In reality, what we need to be concerned with is the *maximum number of customers in an X-minute window that would encounter the owner in a grumpy mood **without** the technique*. The sum of these customers plus the sum of all ordinarily-satisfied customers, represents the maximum number of satisfied customers.\\n\\nTo summarize, the maximum number of satisfied customers may be thought of as the sum of:\\n\\n1) The number of customers who would leave satisfied *regardless* of when the technique is applied\\n\\n2) The maximum number of customers who would leave *dissatisfied* without the technique, but can be made satisfied via the technique \\n\\nWe can track the number of customers that will always be satisfied in a variable `always`, and those who *may* be made satisfied by applying the technique in the current X-minute window in a separate variable `maybe`. We\\'ll also track the maximum value of `maybe` encountered, to track the maximum number of otherwise-dissatisfied customers who may be made satisfied w/ the technique.\\n\\nThis approach is demonstrated in the following code:\\n\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int always = 0; // customers that are *always* happy \\n        int maybe = 0; // customers that *may* be satisfied w/ technique\\n        int max = 0; // max # of customers the technique can be applied to\\n        for(int i = 0; i < customers.length; ++i) {\\n            if(grumpy[i] == 0) {  // these customers are always satisfied\\n                always += customers[i];\\n            } else { // these customers require the technique to be happy\\n                maybe += customers[i];\\n            }\\n            \\n            // remove maybe-satisfied customers from the count\\n            // if they\\'re no longer in the X-minute window\\n            if(i >= X) {\\n                 maybe -= customers[i-X]*grumpy[i-X];\\n            }\\n            \\n            // update max if the current window satisfies more\\n            // otherwise-dissatisfied customers\\n            max = Math.max(maybe, max);\\n        }\\n        return always + max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int always = 0; // customers that are *always* happy \\n        int maybe = 0; // customers that *may* be satisfied w/ technique\\n        int max = 0; // max # of customers the technique can be applied to\\n        for(int i = 0; i < customers.length; ++i) {\\n            if(grumpy[i] == 0) {  // these customers are always satisfied\\n                always += customers[i];\\n            } else { // these customers require the technique to be happy\\n                maybe += customers[i];\\n            }\\n            \\n            // remove maybe-satisfied customers from the count\\n            // if they\\'re no longer in the X-minute window\\n            if(i >= X) {\\n                 maybe -= customers[i-X]*grumpy[i-X];\\n            }\\n            \\n            // update max if the current window satisfies more\\n            // otherwise-dissatisfied customers\\n            max = Math.max(maybe, max);\\n        }\\n        return always + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967132,
                "title": "sliding-window-python-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, X):\\n         ans, happy, max_happy = 0, 0, 0\\n         for i in range(len(customers)):\\n\\t\\t    # Add customers who are happy on the day bookstore owner is not grumpy\\n             if grumpy[i] == 0:\\n                 ans += customers[i]\\n             \\n\\t\\t\\t #  After first X days slide the window by keeping window size X and check the number of happy customers if owner decides not to be grumpy\\n             if i >= X:\\n                 happy = customers[i]*grumpy[i] + happy - customers[i-X]*grumpy[i-X]\\n             else:\\n\\t\\t\\t    # Get the number of happy customers on the days when owner instead of being grumpy decides not be grumpy ( within the first X days)\\n                 happy = happy + customers[i]*grumpy[i]\\n             # Get the maximum happy customers in each window for the days owner decides not to be grumpy   \\n             max_happy = max(happy, max_happy)\\n         return ans + max_happy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, X):\\n         ans, happy, max_happy = 0, 0, 0\\n         for i in range(len(customers)):\\n\\t\\t    # Add customers who are happy on the day bookstore owner is not grumpy\\n             if grumpy[i] == 0:\\n                 ans += customers[i]\\n             \\n\\t\\t\\t #  After first X days slide the window by keeping window size X and check the number of happy customers if owner decides not to be grumpy\\n             if i >= X:\\n                 happy = customers[i]*grumpy[i] + happy - customers[i-X]*grumpy[i-X]\\n             else:\\n\\t\\t\\t    # Get the number of happy customers on the days when owner instead of being grumpy decides not be grumpy ( within the first X days)\\n                 happy = happy + customers[i]*grumpy[i]\\n             # Get the maximum happy customers in each window for the days owner decides not to be grumpy   \\n             max_happy = max(happy, max_happy)\\n         return ans + max_happy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945824,
                "title": "python-sliding-window",
                "content": "```python\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        n, total_cus  = len(customers), 0\\n        for i in range(n):\\n            if i < X:\\n                total_cus += customers[i]\\n            else:\\n                total_cus += (1 - grumpy[i]) * customers[i]\\n                \\n        left, right = 0, X\\n        result = total_cus\\n        while right < n:\\n            if grumpy[right] == 1:\\n                total_cus += customers[right]\\n            if grumpy[left] == 1:\\n                total_cus -= customers[left]\\n            result = max(result, total_cus)\\n            left += 1\\n            right += 1\\n        return result\\n",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        n, total_cus  = len(customers), 0\\n        for i in range(n):\\n            if i < X:\\n                total_cus += customers[i]\\n            else:\\n                total_cus += (1 - grumpy[i]) * customers[i]\\n                \\n        left, right = 0, X\\n        result = total_cus\\n        while right < n:\\n            if grumpy[right] == 1:\\n                total_cus += customers[right]\\n            if grumpy[left] == 1:\\n                total_cus -= customers[left]\\n            result = max(result, total_cus)\\n            left += 1\\n            right += 1\\n        return result\\n",
                "codeTag": "Java"
            },
            {
                "id": 917252,
                "title": "c-sliding-window",
                "content": "Count the most customrs that can be changed from unsatisfied to satisfied. Then we have the answer.\\n```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n    int n = (int) customers.size(), res = 0;\\n    int sum = 0, curChange = 0, maxChange = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (!grumpy[i]) sum += customers[i];\\n        if (grumpy[i]) curChange += customers[i];\\n        if (i >= X && grumpy[i - X]) curChange -= customers[i - X];\\n        maxChange = max(maxChange, curChange);\\n    }\\n    res = sum + maxChange;\\n    return res;\\n}",
                "solutionTags": [],
                "code": "Count the most customrs that can be changed from unsatisfied to satisfied. Then we have the answer.\\n```\\nint maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n    int n = (int) customers.size(), res = 0;\\n    int sum = 0, curChange = 0, maxChange = 0;\\n    for (int i = 0; i < n; i++) {\\n        if (!grumpy[i]) sum += customers[i];\\n        if (grumpy[i]) curChange += customers[i];\\n        if (i >= X && grumpy[i - X]) curChange -= customers[i - X];\\n        maxChange = max(maxChange, curChange);\\n    }\\n    res = sum + maxChange;\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 914436,
                "title": "very-simple-code-c-easy-to-understand-explanation",
                "content": "Let\\'s start with this example.\\nc = [1,0,7,2,1,1,1,5]\\ng = [0,1,1,1,0,1,0,1]\\nw = [1 1 1 - - - - -]\\n\\nWhen you start the window as above, the cur = res = 1+0+7. \\nIf you move the window w to [- 1 1 1 - - - -], what you need to do is \\ncur = 8 + 2 - (1 * 0) = 9\\nIf you don\\'t move the window, \\nres = 8 + 2 = 10\\n\\nWe can see res is bigger than cur, which means not moving the window would be better choice than moving the window.\\nWe keep doing this for cur and res, and compare these two, and update the res.\\nReturn the res at the last.\\n\\nO(N) time, O(1) space. N is the length of curstomers.\\n\\n```\\n   int maxSatisfied(vector<int>& c, vector<int>& g, int X) {\\n        int cur, res = 0;\\n        \\n        for(int i = 0; i < X; i++) res += c[i];\\n\\n        cur = res;\\n        for(int i = X; i < c.size(); i++){\\n            cur += c[i] - c[i-X]*g[i-X];\\n            res += c[i]*(!g[i]);\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n   int maxSatisfied(vector<int>& c, vector<int>& g, int X) {\\n        int cur, res = 0;\\n        \\n        for(int i = 0; i < X; i++) res += c[i];\\n\\n        cur = res;\\n        for(int i = X; i < c.size(); i++){\\n            cur += c[i] - c[i-X]*g[i-X];\\n            res += c[i]*(!g[i]);\\n            res = max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912940,
                "title": "python-linear-sliding-window-solution",
                "content": "The answer is the sum of the number of all customers when the owner is not grumpy and the max number of customers in a window of size X when the owner is grumpy. The second group of customers are the ones we gain by choosing that window.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        num_happy = 0\\n        max_grumpy = 0\\n        num_grumpy = 0\\n        \\n        n = len(customers)\\n        for i in range(n):\\n            # Track customers that will already be satisfied.\\n            num_happy += customers[i] * (not grumpy[i])\\n            \\n            # Track window with the max number of unsatisfied customers.\\n            num_grumpy += customers[i] * grumpy[i]\\n            if i >= X - 1:\\n                if i > X - 1:\\n\\t\\t\\t\\t    # Window is now larger than X, so remove oldest group of customers if owner was grumpy.\\n                    num_grumpy -= customers[i-X] * grumpy[i-X]\\n                max_grumpy = max(num_grumpy, max_grumpy)\\n        \\n        return num_happy + max_grumpy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        num_happy = 0\\n        max_grumpy = 0\\n        num_grumpy = 0\\n        \\n        n = len(customers)\\n        for i in range(n):\\n            # Track customers that will already be satisfied.\\n            num_happy += customers[i] * (not grumpy[i])\\n            \\n            # Track window with the max number of unsatisfied customers.\\n            num_grumpy += customers[i] * grumpy[i]\\n            if i >= X - 1:\\n                if i > X - 1:\\n\\t\\t\\t\\t    # Window is now larger than X, so remove oldest group of customers if owner was grumpy.\\n                    num_grumpy -= customers[i-X] * grumpy[i-X]\\n                max_grumpy = max(num_grumpy, max_grumpy)\\n        \\n        return num_happy + max_grumpy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906073,
                "title": "kotlin-fixed-size-sliding-window",
                "content": "Fixed-Size Sliding Window\" - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_technique/n_pointers/by_pointer_amount/2_pointers/sliding_window/fixed_size_window.txt)\\nProblem List related to #SlidingWindow - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/2_pointers/sliding_window)\\n\\n```\\n/**\\n * https://leetcode.com/problems/grumpy-bookstore-owner/\\n *\\n * Time Complexity:     O(`size`)\\n * Space Complexity:    O(1)\\n *\\n * References:\\n *  https://leetcode.com/problems/grumpy-bookstore-owner/discuss/299492/Java-one-pass-with-comments-sliding-window\\n */\\nclass Solution {\\n    fun maxSatisfied(customers: IntArray, grumpy: IntArray, X: Int): Int {\\n\\t    // not used\\n        // val size = customers.size\\n\\n        var save = 0\\n        var totalCustomers = 0\\n        var totalGrumpy = 0\\n        var maxSave = 0\\n        \\n        for(idx in customers.indices){\\n            totalCustomers += customers[idx]\\n            totalGrumpy += customers[idx] * grumpy[idx]\\n            save += customers[idx] * grumpy[idx]\\n            \\n            if(idx > X - 1){\\n                save -= customers[idx - X] * grumpy[idx - X]\\n            }\\n            \\n            maxSave = maxOf(maxSave, save)\\n        }\\n        \\n        return totalCustomers - totalGrumpy + maxSave\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * https://leetcode.com/problems/grumpy-bookstore-owner/\\n *\\n * Time Complexity:     O(`size`)\\n * Space Complexity:    O(1)\\n *\\n * References:\\n *  https://leetcode.com/problems/grumpy-bookstore-owner/discuss/299492/Java-one-pass-with-comments-sliding-window\\n */\\nclass Solution {\\n    fun maxSatisfied(customers: IntArray, grumpy: IntArray, X: Int): Int {\\n\\t    // not used\\n        // val size = customers.size\\n\\n        var save = 0\\n        var totalCustomers = 0\\n        var totalGrumpy = 0\\n        var maxSave = 0\\n        \\n        for(idx in customers.indices){\\n            totalCustomers += customers[idx]\\n            totalGrumpy += customers[idx] * grumpy[idx]\\n            save += customers[idx] * grumpy[idx]\\n            \\n            if(idx > X - 1){\\n                save -= customers[idx - X] * grumpy[idx - X]\\n            }\\n            \\n            maxSave = maxOf(maxSave, save)\\n        }\\n        \\n        return totalCustomers - totalGrumpy + maxSave\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903255,
                "title": "sliding-window-c-or-cpp-o-n-time-o-1-space",
                "content": "the question follows sliding window format\\nfirst we get X not happy customers and then we maintain window \\nafter that we add happy customers to it .\\n \\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n//         get unhapp min list\\n        if(customers.size()==NULL){\\n            return -1;\\n        }\\n        int left = 0;\\n        int right = 0;\\n        int n = customers.size();\\n        int res=0;\\n        int res1=0;\\n        //get X window\\n        while(right<n && right<X){\\n            if(grumpy[right]==1){\\n                res += customers[right];\\n            }\\n            right++;\\n        }\\n        int curr = res;\\n\\t\\t//maitain the window\\n        while(right<n){\\n            if(grumpy[right]==1){\\n                curr +=customers[right];\\n            }\\n            if(grumpy[left]==1){\\n                curr -=customers[left];\\n            }\\n            res = max(res,curr);\\n            left++;\\n            right++;\\n        }\\n\\t\\t//get happy\\n        for(int j=0;j<n;j++){\\n            if(grumpy[j]==0){\\n                res1 +=customers[j];\\n            }\\n        }\\n        return res1 +res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n//         get unhapp min list\\n        if(customers.size()==NULL){\\n            return -1;\\n        }\\n        int left = 0;\\n        int right = 0;\\n        int n = customers.size();\\n        int res=0;\\n        int res1=0;\\n        //get X window\\n        while(right<n && right<X){\\n            if(grumpy[right]==1){\\n                res += customers[right];\\n            }\\n            right++;\\n        }\\n        int curr = res;\\n\\t\\t//maitain the window\\n        while(right<n){\\n            if(grumpy[right]==1){\\n                curr +=customers[right];\\n            }\\n            if(grumpy[left]==1){\\n                curr -=customers[left];\\n            }\\n            res = max(res,curr);\\n            left++;\\n            right++;\\n        }\\n\\t\\t//get happy\\n        for(int j=0;j<n;j++){\\n            if(grumpy[j]==0){\\n                res1 +=customers[j];\\n            }\\n        }\\n        return res1 +res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862489,
                "title": "python-straight-forward-easy-to-read",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n\\t\\t# We first calculate the base result without the use of the \\'X\\' minute power\\n        base_result = 0\\n        possible_gain = []                 \\n        \\n        for idx, i in enumerate(grumpy):\\n            if i == 1:\\n                possible_gain.append(customers[idx])\\n            else:\\n                possible_gain.append(0)\\n                base_result += customers[idx]\\n        \\n\\t\\t# We then consider the possible gain with the \\'X\\' minute power\\n        max_result = 0     \\n        \\n        for idx in range(len(possible_gain)):\\n            result = sum(possible_gain[idx:idx+X])            \\n            if result > max_result:\\n                max_result = result                \\n                \\n        return base_result+max_result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n\\t\\t# We first calculate the base result without the use of the \\'X\\' minute power\\n        base_result = 0\\n        possible_gain = []                 \\n        \\n        for idx, i in enumerate(grumpy):\\n            if i == 1:\\n                possible_gain.append(customers[idx])\\n            else:\\n                possible_gain.append(0)\\n                base_result += customers[idx]\\n        \\n\\t\\t# We then consider the possible gain with the \\'X\\' minute power\\n        max_result = 0     \\n        \\n        for idx in range(len(possible_gain)):\\n            result = sum(possible_gain[idx:idx+X])            \\n            if result > max_result:\\n                max_result = result                \\n                \\n        return base_result+max_result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848156,
                "title": "easy-c-solution-with-comments",
                "content": "Runtime: 1116 ms, faster than 6.29% of C++ online submissions for Grumpy Bookstore Owner.\\nMemory Usage: 32 MB, less than 54.02% of C++ online submissions for Grumpy Bookstore Owner.\\n\\n```\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int len = customers.size();\\n        int minSum=0;\\n        for(int i=0; i<len; i++){\\n            if(grumpy[i] == 0){\\n                minSum = (minSum+customers[i]);  /* minimum satisfied customers - when shopkeeper is not grumpy */\\n            }\\n        }\\n       int extra=0;\\n        for(int i=0; i<=(len-X); i++){ /* Sliding Window over each element*/\\n            int temp=0;\\n            for(int j=i; j<(X+i); j++){ /* Sliding window*/\\n                if(grumpy[j] == 1){\\n                    temp = (temp+customers[j]); /* extra customers satisfied for this particular value of X */\\n                }\\n            }\\n            if(temp > extra){\\n                extra = temp;  /* maximizing extra */\\n            }\\n        }\\n        return (minSum+extra); /* answer will be minimum possible satisfied customers + maximum of extra possible */\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "Runtime: 1116 ms, faster than 6.29% of C++ online submissions for Grumpy Bookstore Owner.\\nMemory Usage: 32 MB, less than 54.02% of C++ online submissions for Grumpy Bookstore Owner.\\n\\n```\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int len = customers.size();\\n        int minSum=0;\\n        for(int i=0; i<len; i++){\\n            if(grumpy[i] == 0){\\n                minSum = (minSum+customers[i]);  /* minimum satisfied customers - when shopkeeper is not grumpy */\\n            }\\n        }\\n       int extra=0;\\n        for(int i=0; i<=(len-X); i++){ /* Sliding Window over each element*/\\n            int temp=0;\\n            for(int j=i; j<(X+i); j++){ /* Sliding window*/\\n                if(grumpy[j] == 1){\\n                    temp = (temp+customers[j]); /* extra customers satisfied for this particular value of X */\\n                }\\n            }\\n            if(temp > extra){\\n                extra = temp;  /* maximizing extra */\\n            }\\n        }\\n        return (minSum+extra); /* answer will be minimum possible satisfied customers + maximum of extra possible */\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 829185,
                "title": "java-o-n-sliding-window-single-iteration-simple-solution",
                "content": "We start playing the secret technique on minute 0 (when store opens). So we know that till time `X-1` we can satisfy everyone. Keep a count of non satisfied customers whom we satisfied using the secret technique.\\nNow shift the window i.e. we instead play the secret at minute `1`. So we can now effectively satisfy everyone till minute `X`. But in doing so we have to decrement (if any) count of customers that we satisfied on minute `0`. We continue shifting the window. At the end we pick the maximum count of non satisfied customers that we could satisfy using the secret technique. And we add to it the count of customers on non grumpy minutes (they are anyways satisfied without any secret technique).   \\n\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        int nonSatisCustomers = 0;\\n        int satisCustomers = 0;\\n        int maxCanBeSatisCustomers = 0;\\n        \\n        // Start by playing the secret technique on minute 0\\n        // So till time X we can satisfy all customers.\\n        for (int i = 0; i < X; i++) {\\n            if (grumpy[i] == 1) {\\n                nonSatisCustomers += customers[i];\\n            } else {\\n                satisCustomers += customers[i];\\n            }\\n        }\\n        maxCanBeSatisCustomers = nonSatisCustomers;\\n        \\n        // From here on shift the window\\n        // So this means we now play the secret on minute 1 and so on\\n        // We have to decrement the counter of customers that we could\\n        // satisfy using the secret technique.\\n        for (int i = X; i < grumpy.length; i++) {\\n            if (grumpy[i] == 1) {\\n                nonSatisCustomers += customers[i];\\n            } else {\\n                satisCustomers += customers[i];\\n            }\\n            if (grumpy[i-X] == 1) {\\n                nonSatisCustomers -= customers[i-X];\\n            }\\n            maxCanBeSatisCustomers = Math.max(maxCanBeSatisCustomers, nonSatisCustomers);\\n        }\\n        return maxCanBeSatisCustomers+satisCustomers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        int nonSatisCustomers = 0;\\n        int satisCustomers = 0;\\n        int maxCanBeSatisCustomers = 0;\\n        \\n        // Start by playing the secret technique on minute 0\\n        // So till time X we can satisfy all customers.\\n        for (int i = 0; i < X; i++) {\\n            if (grumpy[i] == 1) {\\n                nonSatisCustomers += customers[i];\\n            } else {\\n                satisCustomers += customers[i];\\n            }\\n        }\\n        maxCanBeSatisCustomers = nonSatisCustomers;\\n        \\n        // From here on shift the window\\n        // So this means we now play the secret on minute 1 and so on\\n        // We have to decrement the counter of customers that we could\\n        // satisfy using the secret technique.\\n        for (int i = X; i < grumpy.length; i++) {\\n            if (grumpy[i] == 1) {\\n                nonSatisCustomers += customers[i];\\n            } else {\\n                satisCustomers += customers[i];\\n            }\\n            if (grumpy[i-X] == 1) {\\n                nonSatisCustomers -= customers[i-X];\\n            }\\n            maxCanBeSatisCustomers = Math.max(maxCanBeSatisCustomers, nonSatisCustomers);\\n        }\\n        return maxCanBeSatisCustomers+satisCustomers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824790,
                "title": "c-simple-sliding-window-solution",
                "content": "First we will take the sum of all non grumpy customer timings and then run a sliding window of size k and take max sum of grumpy customer timings and it to the non grumpy customer timings. \\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int k) {\\n        int ans=0;\\n        int out=0;\\n        int n=g.size();\\n        if(k>=n){\\n            for(int i=0;i<n;i++){\\n                ans+=c[i];\\n            }\\n            return ans;\\n        }\\n        int res=0;\\n        for(int i=0;i<k;i++){\\n            if(g[i]==0){\\n                ans+=c[i];\\n            }else{\\n                res+=c[i];\\n            }\\n        }\\n        out=max(out,res);\\n        int j=k,i=0;\\n        while(j<n){\\n            if(g[i]==1){\\n                res-=c[i];\\n            }\\n            if(g[j]==1){\\n                res+=c[j];\\n            }else if(g[j]==0){\\n                ans+=c[j];\\n            }\\n            out=max(out,res);\\n            i++;\\n            j++;\\n        }\\n        return ans+out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int k) {\\n        int ans=0;\\n        int out=0;\\n        int n=g.size();\\n        if(k>=n){\\n            for(int i=0;i<n;i++){\\n                ans+=c[i];\\n            }\\n            return ans;\\n        }\\n        int res=0;\\n        for(int i=0;i<k;i++){\\n            if(g[i]==0){\\n                ans+=c[i];\\n            }else{\\n                res+=c[i];\\n            }\\n        }\\n        out=max(out,res);\\n        int j=k,i=0;\\n        while(j<n){\\n            if(g[i]==1){\\n                res-=c[i];\\n            }\\n            if(g[j]==1){\\n                res+=c[j];\\n            }else if(g[j]==0){\\n                ans+=c[j];\\n            }\\n            out=max(out,res);\\n            i++;\\n            j++;\\n        }\\n        return ans+out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722358,
                "title": "c-o-n-sliding-window-beats-98",
                "content": "```\\npublic:\\n    int maxSatisfied(vector<int>& arr, vector<int>& g, int x) {\\n        int cost = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if (!g[i]) {\\n                cost += arr[i];\\n                arr[i] = 0;\\n            }\\n        }\\n        int i=0;\\n        for(i=0; i<x; i++) {\\n            cost += arr[i];\\n        }\\n        int tot = cost;\\n        for(i=x; i<arr.size(); i++) {\\n            cost += arr[i];\\n            cost -= arr[i-x];\\n            if (cost > tot) tot = cost;\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\npublic:\\n    int maxSatisfied(vector<int>& arr, vector<int>& g, int x) {\\n        int cost = 0;\\n        for(int i=0; i<arr.size(); i++) {\\n            if (!g[i]) {\\n                cost += arr[i];\\n                arr[i] = 0;\\n            }\\n        }\\n        int i=0;\\n        for(i=0; i<x; i++) {\\n            cost += arr[i];\\n        }\\n        int tot = cost;\\n        for(i=x; i<arr.size(); i++) {\\n            cost += arr[i];\\n            cost -= arr[i-x];\\n            if (cost > tot) tot = cost;\\n        }\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 710682,
                "title": "java-o-n-simple-sliding-window-solution",
                "content": "````\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int currentUnSatisfied = 0;\\n        int satisfiedTotal = 0;\\n        for(int i = 0; i < X; i ++){\\n            if(grumpy[i] == 1) currentUnSatisfied +=customers[i];\\n            if(grumpy[i] == 0) satisfiedTotal+=customers[i];\\n        }\\n        int maxUnSatisfied = currentUnSatisfied ;\\n        for(int i = X; i < customers.length; i ++){\\n            if(grumpy[i - X] == 1){\\n                currentUnSatisfied -=customers[i - X];\\n            }\\n            if(grumpy[i] == 1) currentUnSatisfied +=customers[i];\\n            if(grumpy[i] == 0) satisfiedTotal+=customers[i];\\n            maxUnSatisfied = Math.max(maxUnSatisfied, currentUnSatisfied);        \\n        }\\n        return satisfiedTotal+=maxUnSatisfied ;\\n    }",
                "solutionTags": [],
                "code": "````\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int currentUnSatisfied = 0;\\n        int satisfiedTotal = 0;\\n        for(int i = 0; i < X; i ++){\\n            if(grumpy[i] == 1) currentUnSatisfied +=customers[i];\\n            if(grumpy[i] == 0) satisfiedTotal+=customers[i];\\n        }\\n        int maxUnSatisfied = currentUnSatisfied ;\\n        for(int i = X; i < customers.length; i ++){\\n            if(grumpy[i - X] == 1){\\n                currentUnSatisfied -=customers[i - X];\\n            }\\n            if(grumpy[i] == 1) currentUnSatisfied +=customers[i];\\n            if(grumpy[i] == 0) satisfiedTotal+=customers[i];\\n            maxUnSatisfied = Math.max(maxUnSatisfied, currentUnSatisfied);        \\n        }\\n        return satisfiedTotal+=maxUnSatisfied ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 637856,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        int guaranteed = 0, maxGrumpyCust = 0, currGrumpy = 0, i = 0, j = 0;\\n        \\n        while(i < grumpy.length) {\\n            if (grumpy[i] == 0) {\\n                guaranteed += customers[i];\\n            } else {\\n                currGrumpy += customers[i];\\n                // advance j to the new range\\n                while (i - j >= X) {\\n                    if (grumpy[j] == 1)\\n                        currGrumpy -= customers[j];\\n                    j++;\\n                }\\n                \\n                maxGrumpyCust = Math.max(currGrumpy, maxGrumpyCust);\\n            }\\n        \\n            i++;\\n        }\\n        \\n        return guaranteed + maxGrumpyCust;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        \\n        int guaranteed = 0, maxGrumpyCust = 0, currGrumpy = 0, i = 0, j = 0;\\n        \\n        while(i < grumpy.length) {\\n            if (grumpy[i] == 0) {\\n                guaranteed += customers[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 577209,
                "title": "python-prefix-sum",
                "content": "\\n```\\ndef max_subarray_sum(nums: List[int], length: int) -> int:\\n    dp = nums[:]\\n    \\n    for i in range(1, len(nums)):\\n        dp[i] += dp[i-1]\\n        \\n    res = dp[:]\\n    for i in range(length - 1, len(nums)):\\n        res[i] = dp[i] - (dp[i - length] if i - length >= 0 else 0)\\n    \\n    return max(res)\\n\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n\\t    # Count how many customers are satisfied by default\\n        satisfied = sum([customers[i] if grumpy[i] == 0 else 0 for i in range(len(customers))])\\n        # Filter out the satisfied customers and keep only the unsatisfied ones in the list\\n\\t\\tunsatisfied = [customers[i] if grumpy[i] == 1 else 0 for i in range(len(customers))]\\n        # Count how many unhappy customers can be satisfied using the special power, add the already satiefied ones\\n        return satisfied + max_subarray_sum(unsatisfied, X)\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\ndef max_subarray_sum(nums: List[int], length: int) -> int:\\n    dp = nums[:]\\n    \\n    for i in range(1, len(nums)):\\n        dp[i] += dp[i-1]\\n        \\n    res = dp[:]\\n    for i in range(length - 1, len(nums)):\\n        res[i] = dp[i] - (dp[i - length] if i - length >= 0 else 0)\\n    \\n    return max(res)\\n\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n\\t    # Count how many customers are satisfied by default\\n        satisfied = sum([customers[i] if grumpy[i] == 0 else 0 for i in range(len(customers))])\\n        # Filter out the satisfied customers and keep only the unsatisfied ones in the list\\n\\t\\tunsatisfied = [customers[i] if grumpy[i] == 1 else 0 for i in range(len(customers))]\\n        # Count how many unhappy customers can be satisfied using the special power, add the already satiefied ones\\n        return satisfied + max_subarray_sum(unsatisfied, X)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524637,
                "title": "2-java-solutions-with-explaination",
                "content": "Although the question is asking for the happy number, but the real question is find the max unhappy customers which we can recover from the \"magic secret X\", because the total happy number is `happy = totalhappy + maxRecoverableUnhappy`\\n\\nSolution1: The question is very similiar to the sliding window sum question. In the question solution1 (two pass solution), we created an `unhappy` array to store all unhappy diff for all hours. the `unhappy[n + X] - unhappy[n]` is the unhappy number which we can restore. So in the first scan, we calculate all unhappy values. Then in the second scan, find the `maxRecovableUnhappy`. the time complexity is O(n), as we have scanned it twice only\\n\\nSolution2: This problem could also be resolved without creating the array, but directly maintain the `maxRecovableUnhappy`\\n\\ncode:\\n\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        return maxSatisfied1(customers, grumpy, X);\\n    }\\n    \\n    // two pass solution\\n    public int maxSatisfied1(int[] customers, int[] grumpy, int X) {\\n        // create a unhappy for each position, and store it unhappy number\\n        int[] unhappy = new int[customers.length + 1];\\n        unhappy[0] = 0;\\n        int totalHappy = 0;\\n        int totalUnhappy = 0;\\n        // count for each happy and unhappy\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 1) {\\n                totalUnhappy += customers[i];\\n            } else {\\n                totalHappy += customers[i];\\n            }\\n            unhappy[i + 1] = totalUnhappy;\\n        }\\n        \\n        // we can only use it once, so we just need to find the max recover number for the unhappy one\\n        int maxRecover = 0;\\n        for (int i = 0; i < customers.length - X + 1; i++) {\\n            // the diff is the unhappy number\\n            int diff = (unhappy[i + X] - unhappy[i]);\\n            if (diff > maxRecover) {\\n                maxRecover = diff;\\n            }\\n        }\\n        \\n        // total number is happy + maxRecover from the unhappy one\\n        return totalHappy + maxRecover;\\n    }\\n    \\n    public int maxSatisfied2(int[] customers, int[] grumpy, int X) {\\n        int totalHappy = 0;\\n        int totalUnhappy = 0;\\n        int maxUnhappy = 0;\\n        int diff = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                totalHappy += customers[i];\\n            }\\n            \\n            // check the previous i - X position, and directly maintain the diff\\n            if (i >= X) {\\n                if (grumpy[i - X] == 1) {\\n                    diff -= customers[i - X];\\n                }\\n            }\\n                \\n            if (grumpy[i] == 1) {\\n                diff += customers[i];\\n            }\\n            if (diff > maxUnhappy) {\\n                maxUnhappy = diff;\\n            }\\n        }\\n        return totalHappy + maxUnhappy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        return maxSatisfied1(customers, grumpy, X);\\n    }\\n    \\n    // two pass solution\\n    public int maxSatisfied1(int[] customers, int[] grumpy, int X) {\\n        // create a unhappy for each position, and store it unhappy number\\n        int[] unhappy = new int[customers.length + 1];\\n        unhappy[0] = 0;\\n        int totalHappy = 0;\\n        int totalUnhappy = 0;\\n        // count for each happy and unhappy\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 1) {\\n                totalUnhappy += customers[i];\\n            } else {\\n                totalHappy += customers[i];\\n            }\\n            unhappy[i + 1] = totalUnhappy;\\n        }\\n        \\n        // we can only use it once, so we just need to find the max recover number for the unhappy one\\n        int maxRecover = 0;\\n        for (int i = 0; i < customers.length - X + 1; i++) {\\n            // the diff is the unhappy number\\n            int diff = (unhappy[i + X] - unhappy[i]);\\n            if (diff > maxRecover) {\\n                maxRecover = diff;\\n            }\\n        }\\n        \\n        // total number is happy + maxRecover from the unhappy one\\n        return totalHappy + maxRecover;\\n    }\\n    \\n    public int maxSatisfied2(int[] customers, int[] grumpy, int X) {\\n        int totalHappy = 0;\\n        int totalUnhappy = 0;\\n        int maxUnhappy = 0;\\n        int diff = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            if (grumpy[i] == 0) {\\n                totalHappy += customers[i];\\n            }\\n            \\n            // check the previous i - X position, and directly maintain the diff\\n            if (i >= X) {\\n                if (grumpy[i - X] == 1) {\\n                    diff -= customers[i - X];\\n                }\\n            }\\n                \\n            if (grumpy[i] == 1) {\\n                diff += customers[i];\\n            }\\n            if (diff > maxUnhappy) {\\n                maxUnhappy = diff;\\n            }\\n        }\\n        return totalHappy + maxUnhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515793,
                "title": "java-in-loop-sliding-window",
                "content": "```\\npublic int maxSatisfied(int[] s, int[] g, int X) {\\n        int l = s.length;\\n        int sum = 0;\\n        int slow = 0;\\n        int w = 0;\\n        int mx = 0;\\n        for (int i = 0; i < l; i++){\\n            if (g[i] == 1) g[i] = s[i];\\n            else sum+= s[i];\\n            w += g[i];\\n            if (i >= X) {\\n                w -= g[slow];\\n                slow++;\\n            }\\n            mx = Math.max(w, mx);\\n        }\\n        \\n        return sum + mx;\\n        \\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int maxSatisfied(int[] s, int[] g, int X) {\\n        int l = s.length;\\n        int sum = 0;\\n        int slow = 0;\\n        int w = 0;\\n        int mx = 0;\\n        for (int i = 0; i < l; i++){\\n            if (g[i] == 1) g[i] = s[i];\\n            else sum+= s[i];\\n            w += g[i];\\n            if (i >= X) {\\n                w -= g[slow];\\n                slow++;\\n            }\\n            mx = Math.max(w, mx);\\n        }\\n        \\n        return sum + mx;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 510311,
                "title": "java-sliding-window-solution",
                "content": "1. Without suppression of grumpy in a time period X, the bookstore can server the total customers the sum of \\n```((grumpy[0] + 1) % 2) * customers[0] + ... + ((grumpy[len - 1] + 1) % 2) * customers[len - 1]```\\ndenoted by `total`.\\n2. For a X-length time period, the number of unserved customers due to grumpy is \\n```S[i] = grumpy[i] * customers[i] + ... + grumpy[i + X - 1] * customers[i + X - 1]```\\n3. If suppressing grumpy in a time period X, the maximum additonal customers that the bookstore can serve is ```max S[i]```, denoted by `maxS`\\n4. Therefore, the total number of customers that the bookstore can serve is  `total + maxS`\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int sum = 0;\\n        int max = 0;\\n        int total = 0;\\n        for(int i = -X, j = 0; j < customers.length; ++j, ++i) {\\n            total += ((grumpy[j] + 1) % 2) * customers[j];\\n            sum += grumpy[j] * customers[j];\\n            if(i >= 0) {\\n                sum -= grumpy[i] * customers[i];\\n            }\\n            if(j >= X - 1) {\\n                max = Math.max(max, sum);\\n            }\\n            \\n        }\\n        return total + max;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```((grumpy[0] + 1) % 2) * customers[0] + ... + ((grumpy[len - 1] + 1) % 2) * customers[len - 1]```\n```S[i] = grumpy[i] * customers[i] + ... + grumpy[i + X - 1] * customers[i + X - 1]```\n```max S[i]```\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int sum = 0;\\n        int max = 0;\\n        int total = 0;\\n        for(int i = -X, j = 0; j < customers.length; ++j, ++i) {\\n            total += ((grumpy[j] + 1) % 2) * customers[j];\\n            sum += grumpy[j] * customers[j];\\n            if(i >= 0) {\\n                sum -= grumpy[i] * customers[i];\\n            }\\n            if(j >= X - 1) {\\n                max = Math.max(max, sum);\\n            }\\n            \\n        }\\n        return total + max;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500159,
                "title": "99-74-faster-and-100-memory-efficient-java-solution",
                "content": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int initialSum = 0;\\n\\t\\tfor(int i = 0; i < X; ++i) {\\n\\t\\t\\tinitialSum += grumpy[i]*customers[i]; // We only care about the customers in grumpy time\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] sumArr = new int[customers.length-X+1];\\n\\t\\tsumArr[0] = initialSum;\\n\\t\\t\\n\\t\\tfor(int i = X, j = 0; i < customers.length; ++i, j++) {\\n\\t\\t\\tsumArr[j+1] = sumArr[j] - customers[j] * grumpy[j] + customers[i] * grumpy[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\tint startIdx = 0;\\n\\t\\tint maxSum = sumArr[startIdx];\\n\\t\\tfor(int i = 1; i < sumArr.length; ++i) {\\n\\t\\t\\tif(maxSum < sumArr[i]) {\\n\\t\\t\\t\\tstartIdx = i;\\n                maxSum = sumArr[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint endIdx = startIdx + X - 1;\\n\\t\\t\\n\\t\\tint satisfied = 0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i<customers.length; ++i) {\\n\\t\\t\\tif(i >= startIdx && i <= endIdx) {\\n\\t\\t\\t\\tsatisfied += customers[i];\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(grumpy[i] == 0) {\\n\\t\\t\\t\\t\\tsatisfied += customers[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn satisfied;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int initialSum = 0;\\n\\t\\tfor(int i = 0; i < X; ++i) {\\n\\t\\t\\tinitialSum += grumpy[i]*customers[i]; // We only care about the customers in grumpy time\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 475861,
                "title": "python-o-n-easy-to-understand-sliding-window",
                "content": "\\n* \\t\\tn = len(customers)\\n\\t\\tprint(n)\\n\\t\\tmax_sum = 0\\n\\t\\tw_start, w_end = 0,X\\n\\t\\tones_sum, max_ones_sum, not_g_sum = 0,0,0\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif grumpy[i] == 1:\\n\\t\\t\\t\\tones_sum+=customers[i]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnot_g_sum = not_g_sum + customers[i]\\n\\t\\t\\tif i>=X:\\n\\t\\t\\t\\tif grumpy[i-X] == 1:\\n\\t\\t\\t\\t\\tones_sum-=customers[i-X]\\n\\t\\t\\tmax_ones_sum = max(max_ones_sum, ones_sum)\\n\\t\\treturn  not_g_sum + max_ones_sum\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n* \\t\\tn = len(customers)\\n\\t\\tprint(n)\\n\\t\\tmax_sum = 0\\n\\t\\tw_start, w_end = 0,X\\n\\t\\tones_sum, max_ones_sum, not_g_sum = 0,0,0\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif grumpy[i] == 1:\\n\\t\\t\\t\\tones_sum+=customers[i]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tnot_g_sum = not_g_sum + customers[i]\\n\\t\\t\\tif i>=X:\\n\\t\\t\\t\\tif grumpy[i-X] == 1:\\n\\t\\t\\t\\t\\tones_sum-=customers[i-X]\\n\\t\\t\\tmax_ones_sum = max(max_ones_sum, ones_sum)\\n\\t\\treturn  not_g_sum + max_ones_sum\\n",
                "codeTag": "Python3"
            },
            {
                "id": 424505,
                "title": "java-sliding-window-solution-beats-85-time-100-memory",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int s1=0,s2=0,max;\\n        for( int i=0 ; i<X ;i++){\\n            switch(grumpy[i])\\n            {\\n                case 1: s2+= customers[i];\\n                            break;\\n                case 0: s1+= customers[i];\\n                            break;\\n                    \\n            }\\n        }\\n        max = s2;\\n        for(int i=X;i<customers.length;i++)\\n        {\\n            s2-= grumpy[i-X] ==1 ? customers[i-X] :0;\\n            switch(grumpy[i])\\n            {\\n                case 1: s2+= customers[i];\\n                            break;\\n                case 0: s1+= customers[i];\\n                            break;\\n                    \\n            }\\n            max= Math.max(max,s2);\\n        }\\n        return s1+max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int s1=0,s2=0,max;\\n        for( int i=0 ; i<X ;i++){\\n            switch(grumpy[i])\\n            {\\n                case 1: s2+= customers[i];\\n                            break;\\n                case 0: s1+= customers[i];\\n                            break;\\n                    \\n            }\\n        }\\n        max = s2;\\n        for(int i=X;i<customers.length;i++)\\n        {\\n            s2-= grumpy[i-X] ==1 ? customers[i-X] :0;\\n            switch(grumpy[i])\\n            {\\n                case 1: s2+= customers[i];\\n                            break;\\n                case 0: s1+= customers[i];\\n                            break;\\n                    \\n            }\\n            max= Math.max(max,s2);\\n        }\\n        return s1+max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405308,
                "title": "java-solution-100-less-space",
                "content": "\\'\\'\\'public int calcSatisfiedCustIncr(int[] customers, int[] grumpy, int start, int end) {\\n        int modified = 0;\\n        int original = 0;\\n        for (int i = start; i <=end; i++) {\\n            modified += customers[i];\\n            original += customers[i] * (1 - grumpy[i]);\\n        }\\n        return modified - original;\\n    }\\n    \\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int max = 0;\\n        int total = 0;\\n        for (int i = 0;i<customers.length;i++) {\\n            total += customers[i]*(1 - grumpy[i]);\\n        }\\n        for (int i = 0;i<=customers.length - X;i++) {\\n            int incr = calcSatisfiedCustIncr(customers, grumpy, i, i + X - 1);\\n            if (incr > max)\\n                max = incr;\\n        }\\n        return total + max;\\n    }\\'\\'\\'\\n\\tFinds rolling window that results in maximum increment",
                "solutionTags": [],
                "code": "\\'\\'\\'public int calcSatisfiedCustIncr(int[] customers, int[] grumpy, int start, int end) {\\n        int modified = 0;\\n        int original = 0;\\n        for (int i = start; i <=end; i++) {\\n            modified += customers[i];\\n            original += customers[i] * (1 - grumpy[i]);\\n        }\\n        return modified - original;\\n    }\\n    \\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int max = 0;\\n        int total = 0;\\n        for (int i = 0;i<customers.length;i++) {\\n            total += customers[i]*(1 - grumpy[i]);\\n        }\\n        for (int i = 0;i<=customers.length - X;i++) {\\n            int incr = calcSatisfiedCustIncr(customers, grumpy, i, i + X - 1);\\n            if (incr > max)\\n                max = incr;\\n        }\\n        return total + max;\\n    }\\'\\'\\'\\n\\tFinds rolling window that results in maximum increment",
                "codeTag": "Unknown"
            },
            {
                "id": 389918,
                "title": "python-clear-solution-based-on-the-sliding-window-with-comments",
                "content": "O(n) time\\nO(1) space\\n```\\n    def maxSatisfied(self, customers, grumpy, X):\\n\\t# Step 1: find a window of size X with the highest number of unsatisfied customers\\n        index_end = 0 # end index of the \"optimal window\" \\n        num_unhappy, max_num_unhappy = 0, 0\\n        for i in range(len(customers)):\\n            num_unhappy += customers[i]*grumpy[i]\\n            if i >= X:\\n                num_unhappy -= customers[i-X]*grumpy[i-X]\\n            if num_unhappy > max_num_unhappy:\\n                max_num_unhappy = num_unhappy\\n                index_end = i\\n\\t# Step 2: count the number of satisfied customers, making all customers\\n\\t# in the found \"optimal window\" satisfied \\n        return sum([customers[i] if index_end-X<i<=index_end or grumpy[i]==0 else 0 for i in range(len(customers))])\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxSatisfied(self, customers, grumpy, X):\\n\\t# Step 1: find a window of size X with the highest number of unsatisfied customers\\n        index_end = 0 # end index of the \"optimal window\" \\n        num_unhappy, max_num_unhappy = 0, 0\\n        for i in range(len(customers)):\\n            num_unhappy += customers[i]*grumpy[i]\\n            if i >= X:\\n                num_unhappy -= customers[i-X]*grumpy[i-X]\\n            if num_unhappy > max_num_unhappy:\\n                max_num_unhappy = num_unhappy\\n                index_end = i\\n\\t# Step 2: count the number of satisfied customers, making all customers\\n\\t# in the found \"optimal window\" satisfied \\n        return sum([customers[i] if index_end-X<i<=index_end or grumpy[i]==0 else 0 for i in range(len(customers))])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 356486,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n       int n = customers.length;\\n        if(n <= X){\\n          int sum = 0;\\n          for(int customer : customers)\\n              sum += customer;\\n           return sum;\\n       }\\n        //int maxSum = Integer.MIN_VALUE;\\n        int sat = 0;\\n        for(int i=0; i<n; i++){\\n            if(grumpy[i] == 0)\\n                sat += customers[i];\\n        }\\n        int totalSum = 0;\\n        for(int i=0; i<n-X+1; i++){\\n            int currSum = 0;\\n            for(int j=0; j<X; j++){\\n                if(grumpy[i+j] == 0)\\n                    currSum -= customers[i+j];\\n                currSum = currSum + customers[i+j];\\n            }\\n            //maxSum = Math.max(currSum, maxSum);\\n            totalSum = Math.max(totalSum, sat+currSum);\\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n       int n = customers.length;\\n        if(n <= X){\\n          int sum = 0;\\n          for(int customer : customers)\\n              sum += customer;\\n           return sum;\\n       }\\n        //int maxSum = Integer.MIN_VALUE;\\n        int sat = 0;\\n        for(int i=0; i<n; i++){\\n            if(grumpy[i] == 0)\\n                sat += customers[i];\\n        }\\n        int totalSum = 0;\\n        for(int i=0; i<n-X+1; i++){\\n            int currSum = 0;\\n            for(int j=0; j<X; j++){\\n                if(grumpy[i+j] == 0)\\n                    currSum -= customers[i+j];\\n                currSum = currSum + customers[i+j];\\n            }\\n            //maxSum = Math.max(currSum, maxSum);\\n            totalSum = Math.max(totalSum, sat+currSum);\\n        }\\n        return totalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348814,
                "title": "python-o-n-time-o-1-space-sliding-window-method",
                "content": "```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        N = len(customers)\\n        ans = 0\\n        \\n        # accumulate all satisfied customers and flag it as zero\\n        for i in range(N):\\n            if grumpy[i] == 0:\\n                ans += customers[i]\\n                customers[i] = 0\\n        \\n        \\'\\'\\'\\n        # now \\'customers\\' is left with unsatisfied peoples\\n        # we can find the optimal X by sliding a window of length X through the list and get the max sum\\n        cur_inc = sum(customers[:X])\\n        max_inc = cur_inc # max increase by using X\\n        for i in range(X, N):\\n            cur_inc = cur_inc - customers[i-X] + customers[i]\\n            if cur_inc > max_inc:\\n                max_inc = cur_inc\\n       \\n        ans += max_inc\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        N = len(customers)\\n        ans = 0\\n        \\n        # accumulate all satisfied customers and flag it as zero\\n        for i in range(N):\\n            if grumpy[i] == 0:\\n                ans += customers[i]\\n                customers[i] = 0\\n        \\n        \\'\\'\\'\\n        # now \\'customers\\' is left with unsatisfied peoples\\n        # we can find the optimal X by sliding a window of length X through the list and get the max sum\\n        cur_inc = sum(customers[:X])\\n        max_inc = cur_inc # max increase by using X\\n        for i in range(X, N):\\n            cur_inc = cur_inc - customers[i-X] + customers[i]\\n            if cur_inc > max_inc:\\n                max_inc = cur_inc\\n       \\n        ans += max_inc\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 344143,
                "title": "c-90-fast-and-100-space-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum=0;\\n        int n=customers.size();\\n        if(n==1)\\n            return customers[0];  // Handling edge cases\\n        int window_sum=0;                         \\n        for(int i=0;i<n;i++)\\n            if(grumpy[i]==0)\\n               sum+=customers[i];    // sum is for those custmoers who are coming when the owner is not grumpy\\n        // Run a slinding window of size X and find maximum value where we are getting for customers coming when owner is grumpy \\n\\t\\t\\n        int max_sum=0;\\n        for(int i=0;i<X;i++)        //running the first window\\n            if(grumpy[i]==1)\\n                window_sum+=customers[i];   \\n  \\n        max_sum=window_sum;    //max_sum stores the max val of grumpy owner customers\\n        int j=X;\\n\\t\\t// Running sliding window and comparing each window sum\\n        for(int i=1;i<=n-X;i++){ \\n            if(grumpy[i-1]==1)\\n                window_sum-=customers[i-1];\\n            if(grumpy[j]==1)\\n                window_sum+=customers[j];\\n            if(max_sum<window_sum)\\n                max_sum=window_sum;\\n            j++;\\n        }\\n       return sum+max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum=0;\\n        int n=customers.size();\\n        if(n==1)\\n            return customers[0];  // Handling edge cases\\n        int window_sum=0;                         \\n        for(int i=0;i<n;i++)\\n            if(grumpy[i]==0)\\n               sum+=customers[i];    // sum is for those custmoers who are coming when the owner is not grumpy\\n        // Run a slinding window of size X and find maximum value where we are getting for customers coming when owner is grumpy \\n\\t\\t\\n        int max_sum=0;\\n        for(int i=0;i<X;i++)        //running the first window\\n            if(grumpy[i]==1)\\n                window_sum+=customers[i];   \\n  \\n        max_sum=window_sum;    //max_sum stores the max val of grumpy owner customers\\n        int j=X;\\n\\t\\t// Running sliding window and comparing each window sum\\n        for(int i=1;i<=n-X;i++){ \\n            if(grumpy[i-1]==1)\\n                window_sum-=customers[i-1];\\n            if(grumpy[j]==1)\\n                window_sum+=customers[j];\\n            if(max_sum<window_sum)\\n                max_sum=window_sum;\\n            j++;\\n        }\\n       return sum+max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321233,
                "title": "java-sliding-window-2ms-100",
                "content": "If the owner is not grumpy at i-th minute, the customers are always satisfied, so we can first number of customers who will definitely be satisfied. Then, we use a sliding window approach to satisfy maximum number of customers who arrived when the owner was grumpy. This can be treated as problem of finding a maximum sum subarray of size <= X (for this, we set customers[i] = 0, if the owner is not grumpy at i-th second). Thus, at all times, the size of window is kept less than equal to X.\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int n = customers.length;\\n        int sum = 0;\\n        \\n        int numUnsatisfiedCustomers = 0;\\n        int numSatisfiedCustomers = 0;\\n        int maxSatisfiedCustomers = 0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==0){\\n                numSatisfiedCustomers += customers[i];\\n                customers[i] = 0;\\n            }\\n        }\\n        \\n        // sliding window to find maximum sum of subarray whose size is <= X\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j<X){\\n                j++;\\n            } else {\\n                numSatisfiedCustomers -= customers[i-X];\\n            }\\n            numSatisfiedCustomers += customers[i];\\n            maxSatisfiedCustomers = Math.max(maxSatisfiedCustomers, numSatisfiedCustomers);\\n        }\\n        return maxSatisfiedCustomers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int n = customers.length;\\n        int sum = 0;\\n        \\n        int numUnsatisfiedCustomers = 0;\\n        int numSatisfiedCustomers = 0;\\n        int maxSatisfiedCustomers = 0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==0){\\n                numSatisfiedCustomers += customers[i];\\n                customers[i] = 0;\\n            }\\n        }\\n        \\n        // sliding window to find maximum sum of subarray whose size is <= X\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j<X){\\n                j++;\\n            } else {\\n                numSatisfiedCustomers -= customers[i-X];\\n            }\\n            numSatisfiedCustomers += customers[i];\\n            maxSatisfiedCustomers = Math.max(maxSatisfiedCustomers, numSatisfiedCustomers);\\n        }\\n        return maxSatisfiedCustomers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317326,
                "title": "python-sliding-window-mask-calculating-delta-of-total",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        total = 0\\n        for i in range(len(customers)):\\n            if grumpy[i] == 0:\\n                total += customers[i]\\n        \\n        for i in range(X):\\n            if grumpy[i] == 1:\\n                total += customers[i]\\n        \\n        res = total\\n        for i in range(X, len(customers)):\\n            if grumpy[i] == 1:\\n                total += customers[i]\\n            if grumpy[i-X] == 1:\\n                total -= customers[i-X]\\n            res = max(res, total)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        total = 0\\n        for i in range(len(customers)):\\n            if grumpy[i] == 0:\\n                total += customers[i]\\n        \\n        for i in range(X):\\n            if grumpy[i] == 1:\\n                total += customers[i]\\n        \\n        res = total\\n        for i in range(X, len(customers)):\\n            if grumpy[i] == 1:\\n                total += customers[i]\\n            if grumpy[i-X] == 1:\\n                total -= customers[i-X]\\n            res = max(res, total)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314969,
                "title": "js-two-pass-sliding-window-o-n-time-and-o-1-space",
                "content": "```\\nconst maxSatisfied = (customers, grumpy, X) => {\\n    let satisfied = 0, sum = 0, maxSum = 0, grumpyStart = null;\\n    \\n    for (let i = 0; i < customers.length; i++) {\\n        if (i >= X && grumpy[i - X] === 1) {\\n            sum -= customers[i - X];\\n        }\\n        \\n        if (grumpy[i] === 1) {\\n            sum += customers[i];\\n        }\\n        \\n        if (maxSum < sum && i >= X - 1) {\\n            grumpyStart = i - X + 1;\\n            maxSum = sum;\\n        }\\n    } \\n    \\n    for (let i = 0; i < customers.length; i++) {\\n        if (grumpy[i] === 0 || (i >= grumpyStart && i < grumpyStart + X)) {\\n            satisfied += customers[i];\\n        } \\n    }\\n    \\n    return satisfied;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst maxSatisfied = (customers, grumpy, X) => {\\n    let satisfied = 0, sum = 0, maxSum = 0, grumpyStart = null;\\n    \\n    for (let i = 0; i < customers.length; i++) {\\n        if (i >= X && grumpy[i - X] === 1) {\\n            sum -= customers[i - X];\\n        }\\n        \\n        if (grumpy[i] === 1) {\\n            sum += customers[i];\\n        }\\n        \\n        if (maxSum < sum && i >= X - 1) {\\n            grumpyStart = i - X + 1;\\n            maxSum = sum;\\n        }\\n    } \\n    \\n    for (let i = 0; i < customers.length; i++) {\\n        if (grumpy[i] === 0 || (i >= grumpyStart && i < grumpyStart + X)) {\\n            satisfied += customers[i];\\n        } \\n    }\\n    \\n    return satisfied;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304002,
                "title": "c-dp-straight-forward",
                "content": "\\n\\n**dp_x[i]**:    maximum number of satisfied customers by **using** \\'X\\' minutes strategy from 0 to i minutes\\n**dp_nox[i]**:  maximum number of satisfied customers by **not using** \\'X\\' minutes strategy from 0 to i minutes\\n\\nthen the recursion could be formed like:\\n```\\ndp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+customers in last X minutes);\\n```\\n\\nto record the customer amount, I simply use another vector sum[i], so the recursion is \\n```\\ndp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+sum[i]-sum[i-X]);\\n```\\n\\n\\nThe disadvantage is using more space. Posted C++ solution below:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        vector<int> dp_x(customers.size(),0);\\n        vector<int> dp_nox(customers.size(),0);\\n        vector<int> sum(customers.size(),0);\\n        dp_x[0]=sum[0]=customers[0];\\n        dp_nox[0]=customers[0]*(grumpy[0]^1);\\n\\n        for(int i=1;i<customers.size();++i)\\n        {\\n            sum[i]=sum[i-1]+customers[i];\\n            dp_nox[i]=dp_nox[i-1]+customers[i]*(grumpy[i]^1);\\n            if(i<X)\\n                dp_x[i]=sum[i];\\n            else\\n                dp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+sum[i]-sum[i-X]);\\n        }\\n        return dp_x[customers.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+customers in last X minutes);\\n```\n```\\ndp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+sum[i]-sum[i-X]);\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        vector<int> dp_x(customers.size(),0);\\n        vector<int> dp_nox(customers.size(),0);\\n        vector<int> sum(customers.size(),0);\\n        dp_x[0]=sum[0]=customers[0];\\n        dp_nox[0]=customers[0]*(grumpy[0]^1);\\n\\n        for(int i=1;i<customers.size();++i)\\n        {\\n            sum[i]=sum[i-1]+customers[i];\\n            dp_nox[i]=dp_nox[i-1]+customers[i]*(grumpy[i]^1);\\n            if(i<X)\\n                dp_x[i]=sum[i];\\n            else\\n                dp_x[i]=max(dp_x[i-1]+customers[i]*(grumpy[i]^1),dp_nox[i-X]+sum[i]-sum[i-X]);\\n        }\\n        return dp_x[customers.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300276,
                "title": "python-solution-with-element-wise-product-linear-time-64ms-14-8mb",
                "content": "The mathematical formula for this problem: Total revenue = total num of customers - total loss + \"saved revenue\".\\nWe can use element-wise product to calculate the total loss, and use sliding window to find the maximized \"saved revenue\"\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        # Zoey May 27th, 2019\\n        # aim of this problem: minimize element-wise product (total loss)\\n        # Total revenue = total num of customers - total loss \\n        loss = [customers[i] * grumpy[i] for i in range(len(customers))]\\n        \\n        # sliding window to find max \"saved revenue\"\\n        window_sum = sum(loss[:X])\\n        max_window_sum = window_sum\\n        for i in range(len(customers) - X):\\n            window_sum += loss[X + i] - loss[i]\\n            if window_sum > max_window_sum:\\n                max_window_sum = window_sum\\n        \\n        # Total revenue = total num of customers - total loss + \"saved revenue\"\\n        return sum(customers) - sum(loss) + max_window_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        # Zoey May 27th, 2019\\n        # aim of this problem: minimize element-wise product (total loss)\\n        # Total revenue = total num of customers - total loss \\n        loss = [customers[i] * grumpy[i] for i in range(len(customers))]\\n        \\n        # sliding window to find max \"saved revenue\"\\n        window_sum = sum(loss[:X])\\n        max_window_sum = window_sum\\n        for i in range(len(customers) - X):\\n            window_sum += loss[X + i] - loss[i]\\n            if window_sum > max_window_sum:\\n                max_window_sum = window_sum\\n        \\n        # Total revenue = total num of customers - total loss + \"saved revenue\"\\n        return sum(customers) - sum(loss) + max_window_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300085,
                "title": "one-pass-java",
                "content": "some translation about this problem: find the maximum value within a window with size of `X`, with a condition that `arr[i]` must be `1`\\n```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfied = 0, cur = 0, max = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            satisfied += grumpy[i] == 0 ? customers[i] : 0;\\n            cur += customers[i] * grumpy[i];\\n            if (i >= X) cur -= customers[i - X] * grumpy[i - X];\\n            max = Math.max(max, cur);\\n        }\\n        return satisfied + max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\\n        int satisfied = 0, cur = 0, max = 0;\\n        for (int i = 0; i < customers.length; i++) {\\n            satisfied += grumpy[i] == 0 ? customers[i] : 0;\\n            cur += customers[i] * grumpy[i];\\n            if (i >= X) cur -= customers[i - X] * grumpy[i - X];\\n            max = Math.max(max, cur);\\n        }\\n        return satisfied + max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299631,
                "title": "c-o-n-solution-with-explanation",
                "content": "The only trcik here is to find the max number of unsatisfied customers in a window of length X. \\nTo do so:\\n1. Traverse the array one item at a time and a window(i.e keep track of start)\\n2. For every item, check if this item can be part of current window or not?\\n\\t3. If yes, check if bookstore owner was grumpy this time. Add the count of unsatisfied customer.\\n\\t4. If no, simply slide the window i.e remove start item contribution to max of unsatisfied customer and add current.\\n5. Keep track of total satisfied customer.\\n6. Return total satisfied customers + max unsatisfied customers :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum = 0, start = 0, total = 0, max_sum = 0;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(i - start < X){\\n                //Window size smaller than X, add entry\\n                if(grumpy[i]) sum += customers[i];\\n            }else{\\n                //Window size exceeds, move window\\n                if(grumpy[start]) sum -= customers[start];\\n                if(grumpy[i]) sum += customers[i];\\n                start++;\\n            }\\n            //Keep track of max_sum of unsatisfied customers in sliding window\\n            max_sum = max(max_sum, sum);\\n            //Keep track of total customers satisfied\\n            if(!grumpy[i]) total += customers[i];\\n        }\\n        \\n        return total+max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int sum = 0, start = 0, total = 0, max_sum = 0;\\n        for(int i = 0; i < customers.size(); i++){\\n            if(i - start < X){\\n                //Window size smaller than X, add entry\\n                if(grumpy[i]) sum += customers[i];\\n            }else{\\n                //Window size exceeds, move window\\n                if(grumpy[start]) sum -= customers[start];\\n                if(grumpy[i]) sum += customers[i];\\n                start++;\\n            }\\n            //Keep track of max_sum of unsatisfied customers in sliding window\\n            max_sum = max(max_sum, sum);\\n            //Keep track of total customers satisfied\\n            if(!grumpy[i]) total += customers[i];\\n        }\\n        \\n        return total+max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299548,
                "title": "simple-c-sliding-window-technique-solution-with-simple-explanation",
                "content": "Constraints given in the problem:\\n1 <= X <= customers.length == grumpy.length <= 20000\\n0 <= customers[i] <= 1000\\n0 <= grumpy[i] <= 1\\n\\nIt is given that using a secret technique, owner can stop being grumpy for \"X\" minutes straight. \\n\\nIdea:\\nWe want to know that within which interval of \"X\" minutes, the sum of customers arriving at grumpy minutes is maximum. By getting that interval, we can select all the customers irrespective of bookstore owner being grumpy or not at the minute when they arrive. And select all the customers arriving at the minutes which lie outside this interval and the bookstore owner is not grumpy at those minutes.\\n\\nThe problem can be solved by maintaining a window of size \"X\" and the sum of all the customers arriving at those minutes which lie in the window and when the store owner is grumpy. We will keep track of this sum, and the window in which this sum is found to be maximum, that is to be considered for the answer as that is the maximum number of customers at the grumpy minutes that you can maximise in X hours straight.\\n\\nTime complexity: O(number of minutes)\\nSpace complexity: O(1)\\n\\nBelow is the implementation of the above explaines idea:\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n=customers.size();\\n        if(n==1) return customers[0];\\n        int l=0,r=X-1;\\n        int wS=0;\\n        int mL=l,mR=r;\\n        int maxWs=0;\\n        for(int i=l;i<=r;++i)\\n        {\\n            if(grumpy[i])\\n                wS+=customers[i];\\n        }\\n        \\n        maxWs=wS;\\n        \\n        while(r<=customers.size()-2)\\n        {\\n            r++;\\n            if(grumpy[r])\\n                wS+=customers[r];\\n            \\n            if(grumpy[l])\\n                wS-=customers[l];\\n            \\n            l++;\\n            \\n            if(wS>maxWs)\\n            {\\n                mL=l;\\n                mR=r;\\n                wS=maxWs;\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<customers.size();++i)\\n        {\\n            \\n            if(i>=mL && i<=mR)ans+=customers[i];\\n            \\n            else if(!grumpy[i]) ans+=customers[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n=customers.size();\\n        if(n==1) return customers[0];\\n        int l=0,r=X-1;\\n        int wS=0;\\n        int mL=l,mR=r;\\n        int maxWs=0;\\n        for(int i=l;i<=r;++i)\\n        {\\n            if(grumpy[i])\\n                wS+=customers[i];\\n        }\\n        \\n        maxWs=wS;\\n        \\n        while(r<=customers.size()-2)\\n        {\\n            r++;\\n            if(grumpy[r])\\n                wS+=customers[r];\\n            \\n            if(grumpy[l])\\n                wS-=customers[l];\\n            \\n            l++;\\n            \\n            if(wS>maxWs)\\n            {\\n                mL=l;\\n                mR=r;\\n                wS=maxWs;\\n            }\\n            \\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<customers.size();++i)\\n        {\\n            \\n            if(i>=mL && i<=mR)ans+=customers[i];\\n            \\n            else if(!grumpy[i]) ans+=customers[i];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299469,
                "title": "sliding-window-simple-solution",
                "content": "``` csharp\\n\\n public int MaxSatisfied(int[] customers, int[] grumpy, int X)\\n {\\n            int satisfy = 0;\\n            int maxSatisfy = 0;\\n            int extraSatisfy = 0;\\n\\n            for (int i = 0; i < grumpy.Length; i++)\\n            {\\n                if (grumpy[i] == 0)\\n                {\\n                    satisfy += customers[i];\\n                }\\n                else\\n                {\\n                    extraSatisfy += customers[i];\\n                }\\n\\n                // Sliding window of X length\\n                if (i >= X && grumpy[i - X] == 1)\\n                {\\n                    extraSatisfy = extraSatisfy - customers[i - X];\\n                }\\n                maxSatisfy = Math.Max(maxSatisfy, extraSatisfy);\\n            }\\n\\n            return satisfy + maxSatisfy;\\n }\\n\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "``` csharp\\n\\n public int MaxSatisfied(int[] customers, int[] grumpy, int X)\\n {\\n            int satisfy = 0;\\n            int maxSatisfy = 0;\\n            int extraSatisfy = 0;\\n\\n            for (int i = 0; i < grumpy.Length; i++)\\n            {\\n                if (grumpy[i] == 0)\\n                {\\n                    satisfy += customers[i];\\n                }\\n                else\\n                {\\n                    extraSatisfy += customers[i];\\n                }\\n\\n                // Sliding window of X length\\n                if (i >= X && grumpy[i - X] == 1)\\n                {\\n                    extraSatisfy = extraSatisfy - customers[i - X];\\n                }\\n                maxSatisfy = Math.Max(maxSatisfy, extraSatisfy);\\n            }\\n\\n            return satisfy + maxSatisfy;\\n }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299299,
                "title": "c-o-n-with-explanation",
                "content": "1. First take sum of all the customers entered at non-grumpy minutes. And set them to 0\\n2. Now in the remaining list, we find a window of size X having the max sum.\\n3. Answer is the total of the two sums calculated in previous 2 steps.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n = customers.size();\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!grumpy[i]) {\\n                total += customers[i];\\n                customers[i] = 0;\\n            }\\n        }\\n        // Now find a window of size X having max sum from remaining\\n        int max_sum = 0;\\n        for (int i = 0; i < X; i++)\\n            max_sum += customers[i];\\n        int cur_sum = max_sum;\\n        for (int i = X; i < n; i++) {\\n            cur_sum += customers[i] - customers[i - X];\\n            max_sum = max(max_sum, cur_sum);\\n        }\\n        return max_sum + total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X) {\\n        int n = customers.size();\\n        int total = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (!grumpy[i]) {\\n                total += customers[i];\\n                customers[i] = 0;\\n            }\\n        }\\n        // Now find a window of size X having max sum from remaining\\n        int max_sum = 0;\\n        for (int i = 0; i < X; i++)\\n            max_sum += customers[i];\\n        int cur_sum = max_sum;\\n        for (int i = X; i < n; i++) {\\n            cur_sum += customers[i] - customers[i - X];\\n            max_sum = max(max_sum, cur_sum);\\n        }\\n        return max_sum + total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299253,
                "title": "intuitive-java-solution",
                "content": "**Idea**\\n`perfect` prefixSum array of satisfied customers if the owner is not grumpy at all.\\n`real` prefixSum array of satisfied customers according to `grumpy` array\\n\\nBasically, we calculate the max satisfaction by sliding window of size X from the start. For example, the window(i..j) applied as below\\n`[0......(i......j).....n-1]`\\nTo efficiently calculate the satisfaction for when applying our window, it splits the input array into 3 parts. \\n\\n1. Part before the window. Satisfaction for this part = `real[i]`\\n2. window. Satisfaction for this part = `perfect[i+x]-perfect[i]`\\n3. Part after the window. Satisfaction for this part = `real[n]-real[i+x]`\\n\\n**Time O(n)** where n is size of customers array \\n\\n```\\npublic int maxSatisfied(int[] c, int[] g, int x) {\\n        int n = c.length, max = 0;\\n        int[] real = new int[n+1], perfect = new int[n+1];\\n        for(int i=1; i <= n; i++)\\n            perfect[i] = perfect[i-1]+c[i-1];\\n        for(int i=1; i <= n; i++)\\n            real[i] = real[i-1]+(g[i-1] == 0 ? c[i-1] : 0);\\n        for(int i=0; i+x <= n; i++)\\n            max = Math.max(max, real[i]+perfect[i+x]-perfect[i]+real[n]-real[i+x]);\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSatisfied(int[] c, int[] g, int x) {\\n        int n = c.length, max = 0;\\n        int[] real = new int[n+1], perfect = new int[n+1];\\n        for(int i=1; i <= n; i++)\\n            perfect[i] = perfect[i-1]+c[i-1];\\n        for(int i=1; i <= n; i++)\\n            real[i] = real[i-1]+(g[i-1] == 0 ? c[i-1] : 0);\\n        for(int i=0; i+x <= n; i++)\\n            max = Math.max(max, real[i]+perfect[i+x]-perfect[i]+real[n]-real[i+x]);\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299197,
                "title": "python-concise-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], x: int) -> int:\\n        dif = mx = sum(c * g for c, g in zip(customers[:x], grumpy[:x]))\\n        for j in range(x, len(grumpy)):\\n            dif += (grumpy[j] * customers[j]) - (grumpy[j - x] * customers[j - x])\\n            mx = max(mx, dif)\\n        return mx + sum(c * (1- g) for c, g in zip(customers, grumpy))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], x: int) -> int:\\n        dif = mx = sum(c * g for c, g in zip(customers[:x], grumpy[:x]))\\n        for j in range(x, len(grumpy)):\\n            dif += (grumpy[j] * customers[j]) - (grumpy[j - x] * customers[j - x])\\n            mx = max(mx, dif)\\n        return mx + sum(c * (1- g) for c, g in zip(customers, grumpy))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105686,
                "title": "python-solution-with-explanation-rolling-sum",
                "content": "The way I approached this problem was to split it into 2 smaller problems.\\n\\nThe first involves counting how many customers are already satisfied, i.e. those where the shopkeeper is not grumpy. I also set any slots with already satisfied customers to 0, so that we will be left with only the currently unsatisfied customers in the list.\\n\\nFor the second part, the array now only contains customers who will not be satisfied. We are able to make X adjacent times \\u201Chappy\\u201D, so we want to find the subarray of length X that has the most customers. We can just keep a rolling sum of the last X customers in the array, and then the best solution is the max the rolling sum ever was.\\n\\nFinally we return the sum of the 2 parts: the customers who were already satisfied, and the maximum number who can be made satisfied by stopping the shop keeper from being grumpy for X time.\\n\\nNote that both parts can be combined into a single loop, but I felt this way was probably easier for understanding, and both are still O(n) time. I\\'ll shortly include code for how to merge it all together.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        # Part 1 requires counting how many customers\\n        # are already satisfied, and removing them\\n        # from the customer list.\\n        already_satisfied = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0: #He\\'s happy\\n                already_satisfied += customers[i]\\n                customers[i] = 0\\n        \\n        # Part 2 requires finding the optinal number\\n        # of unhappy customers we can make happy.\\n        best_we_can_make_satisfied = 0\\n        current_satisfied = 0\\n        for i, customers_at_time in enumerate(customers):\\n            current_satisfied += customers_at_time # Add current to rolling total\\n            if i >= X: # We need to remove some from the rolling total\\n                current_satisfied -= customers[i - X]\\n            best_we_can_make_satisfied = max(best_we_can_make_satisfied, current_satisfied)\\n        \\n        # The answer is the sum of the solutions for the 2 parts.\\n        return already_satisfied + best_we_can_make_satisfied\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], X: int) -> int:\\n        \\n        # Part 1 requires counting how many customers\\n        # are already satisfied, and removing them\\n        # from the customer list.\\n        already_satisfied = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0: #He\\'s happy\\n                already_satisfied += customers[i]\\n                customers[i] = 0\\n        \\n        # Part 2 requires finding the optinal number\\n        # of unhappy customers we can make happy.\\n        best_we_can_make_satisfied = 0\\n        current_satisfied = 0\\n        for i, customers_at_time in enumerate(customers):\\n            current_satisfied += customers_at_time # Add current to rolling total\\n            if i >= X: # We need to remove some from the rolling total\\n                current_satisfied -= customers[i - X]\\n            best_we_can_make_satisfied = max(best_we_can_make_satisfied, current_satisfied)\\n        \\n        # The answer is the sum of the solutions for the 2 parts.\\n        return already_satisfied + best_we_can_make_satisfied\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084463,
                "title": "sliding-window-technique-java-python-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nLet\\'s analyze the time complexity and space complexity of the provided code.\\n\\n**Time Complexity:**\\n1. The first `while` loop iterates through the `customers` array from `startIndex` to the end (`endIndex < customers.length`). In the worst case, it iterates through the entire array. The operations inside the loop, such as addition and comparison, have constant time complexity O(1).\\n\\n2. The second `while` loop also iterates through the `customers` array from `endIndex` to the end (`endIndex < customers.length`). In the worst case, it iterates through the entire array. The operations inside the loop have constant time complexity O(1).\\n\\nOverall, the time complexity of this code is O(N), where N is the length of the `customers` array.\\n\\n**Space Complexity:**\\nThe space complexity of the code is determined by the variables and data structures used:\\n\\n1. `startIndex`, `endIndex`, `result`, `max`, and other integer variables: These are constant space as they do not depend on the input size. Therefore, they have a space complexity of O(1).\\n\\n2. `grumpy` array: Assuming this array is given as an input parameter, it does not contribute to the space complexity of the code. Its space complexity depends on the input and is not a result of the code itself.\\n\\nOverall, the space complexity of the code is O(1), assuming that the input arrays `customers` and `grumpy` are not counted towards the space complexity since they are external inputs.\\n\\nIn summary, the time complexity of the code is O(N), and the space complexity is O(1), where N is the length of the `customers` array.\\n\\n# Java\\n```\\nclass Solution {\\n    public static int maxSatisfiedOptimal(int[] customers, int[] grumpy, int minutes) {\\n        int satisfied = 0; // Total satisfied customers when the owner is not grumpy\\n        int maxSatisfied = 0; // Maximum satisfied customers during grumpy minutes\\n        int windowSum = 0; // Current sum of customers during grumpy minutes\\n        int right = 0; // Left pointer of the sliding window\\n        int left = 0; // Left pointer of the sliding window\\n\\n        while (right < customers.length) {\\n            if (grumpy[right] == 0) {\\n                satisfied += customers[right];\\n            } else {\\n                windowSum += customers[right];\\n            }\\n\\n            // Slide the window to keep it of size \\'minutes\\'\\n            if (right - left + 1 > minutes) {\\n                if (grumpy[left] == 1) {\\n                    windowSum -= customers[left];\\n                }\\n                left++;\\n            }\\n\\n            right++;\\n            // Update maxSatisfied\\n            maxSatisfied = Math.max(maxSatisfied, windowSum);\\n        }\\n\\n        return satisfied + maxSatisfied;\\n    }\\n}\\n```\\n# Python\\n\\n```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, minutes):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type grumpy: List[int]\\n        :type minutes: int\\n        :rtype: int\\n        \"\"\"\\n        satisfied = 0  # Total satisfied customers when the owner is not grumpy\\n        max_satisfied = 0  # Maximum satisfied customers during grumpy minutes\\n        window_sum = 0  # Current sum of customers during grumpy minutes\\n        right = 0  # Right pointer of the sliding window\\n        left = 0  # Left pointer of the sliding window\\n\\n        while right < len(customers):\\n\\n            if grumpy[right] == 0:\\n                satisfied += customers[right]\\n            else:\\n                window_sum += customers[right]\\n\\n            while right - left + 1 > minutes:\\n                if grumpy[left] == 1:\\n                    window_sum -= customers[left]\\n\\n                left += 1\\n\\n            right += 1\\n            max_satisfied = max(max_satisfied, window_sum)\\n\\n        return satisfied + max_satisfied\\n```\\n# TypeScript\\n```\\nfunction maxSatisfied(customers: number[], grumpy: number[], minutes: number): number {\\n\\n    let satisfied = 0; // Total satisfied customers when the owner is not grumpy\\n    let maxSatisfied = 0; // Maximum satisfied customers during grumpy minutes\\n    let windowSum = 0; // Current sum of customers during grumpy minutes\\n    let right = 0; // Left pointer of the sliding window\\n    let left = 0; // Left pointer of the sliding window\\n\\n    while (right < customers.length) {\\n\\n        if (grumpy[right] == 0) {\\n            satisfied += customers[right]\\n        } else {\\n            windowSum += customers[right]\\n        }\\n\\n        while (right - left + 1 > minutes) {\\n            if (grumpy[left] == 1) {\\n                windowSum -= customers[left]\\n            }\\n            left++\\n        }\\n\\n        right++\\n        maxSatisfied = Math.max(maxSatisfied, windowSum)\\n    }\\n\\n    return satisfied + maxSatisfied\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxSatisfiedOptimal(int[] customers, int[] grumpy, int minutes) {\\n        int satisfied = 0; // Total satisfied customers when the owner is not grumpy\\n        int maxSatisfied = 0; // Maximum satisfied customers during grumpy minutes\\n        int windowSum = 0; // Current sum of customers during grumpy minutes\\n        int right = 0; // Left pointer of the sliding window\\n        int left = 0; // Left pointer of the sliding window\\n\\n        while (right < customers.length) {\\n            if (grumpy[right] == 0) {\\n                satisfied += customers[right];\\n            } else {\\n                windowSum += customers[right];\\n            }\\n\\n            // Slide the window to keep it of size \\'minutes\\'\\n            if (right - left + 1 > minutes) {\\n                if (grumpy[left] == 1) {\\n                    windowSum -= customers[left];\\n                }\\n                left++;\\n            }\\n\\n            right++;\\n            // Update maxSatisfied\\n            maxSatisfied = Math.max(maxSatisfied, windowSum);\\n        }\\n\\n        return satisfied + maxSatisfied;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def maxSatisfied(self, customers, grumpy, minutes):\\n        \"\"\"\\n        :type customers: List[int]\\n        :type grumpy: List[int]\\n        :type minutes: int\\n        :rtype: int\\n        \"\"\"\\n        satisfied = 0  # Total satisfied customers when the owner is not grumpy\\n        max_satisfied = 0  # Maximum satisfied customers during grumpy minutes\\n        window_sum = 0  # Current sum of customers during grumpy minutes\\n        right = 0  # Right pointer of the sliding window\\n        left = 0  # Left pointer of the sliding window\\n\\n        while right < len(customers):\\n\\n            if grumpy[right] == 0:\\n                satisfied += customers[right]\\n            else:\\n                window_sum += customers[right]\\n\\n            while right - left + 1 > minutes:\\n                if grumpy[left] == 1:\\n                    window_sum -= customers[left]\\n\\n                left += 1\\n\\n            right += 1\\n            max_satisfied = max(max_satisfied, window_sum)\\n\\n        return satisfied + max_satisfied\\n```\n```\\nfunction maxSatisfied(customers: number[], grumpy: number[], minutes: number): number {\\n\\n    let satisfied = 0; // Total satisfied customers when the owner is not grumpy\\n    let maxSatisfied = 0; // Maximum satisfied customers during grumpy minutes\\n    let windowSum = 0; // Current sum of customers during grumpy minutes\\n    let right = 0; // Left pointer of the sliding window\\n    let left = 0; // Left pointer of the sliding window\\n\\n    while (right < customers.length) {\\n\\n        if (grumpy[right] == 0) {\\n            satisfied += customers[right]\\n        } else {\\n            windowSum += customers[right]\\n        }\\n\\n        while (right - left + 1 > minutes) {\\n            if (grumpy[left] == 1) {\\n                windowSum -= customers[left]\\n            }\\n            left++\\n        }\\n\\n        right++\\n        maxSatisfied = Math.max(maxSatisfied, windowSum)\\n    }\\n\\n    return satisfied + maxSatisfied\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077329,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int cus = 0;\\n        for(int i = 0; i < minutes ; i++){\\n            cus += customers[i];\\n        }\\n\\n        for(int j = minutes; j < customers.length ; j++){\\n            if(grumpy[j] != 1){\\n                cus += customers[j];\\n            }\\n        }\\n\\n        int max = cus;\\n        for(int i =  minutes; i < customers.length ; i++){\\n            if(grumpy[i-minutes] == 1){\\n                cus = cus - customers[i-minutes];\\n            }\\n            if(grumpy[i] == 1){\\n                cus +=  customers[i];\\n            }\\n            max = Math.max(cus, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int cus = 0;\\n        for(int i = 0; i < minutes ; i++){\\n            cus += customers[i];\\n        }\\n\\n        for(int j = minutes; j < customers.length ; j++){\\n            if(grumpy[j] != 1){\\n                cus += customers[j];\\n            }\\n        }\\n\\n        int max = cus;\\n        for(int i =  minutes; i < customers.length ; i++){\\n            if(grumpy[i-minutes] == 1){\\n                cus = cus - customers[i-minutes];\\n            }\\n            if(grumpy[i] == 1){\\n                cus +=  customers[i];\\n            }\\n            max = Math.max(cus, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068048,
                "title": "sliding-window-little-tricky",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust slide a window of length minutes.\\nAnd check where is the difference between the actualsum and the simple sum is higest.\\njust use your minutes there.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0;\\n        int j=0;\\n\\n        int ans=INT_MIN;\\n\\n        int x=-1;\\n        int y=-1;\\n        int sum=0;\\n        int actsum=0;\\n        while(j<customers.size())\\n        {\\n             sum+=customers[j];\\n             if(grumpy[j]==1)\\n             {\\n                 actsum+=0;\\n             }\\n             else\\n             actsum+=customers[j];\\n\\n             if(j-i+1==minutes)\\n             {\\n                 if(sum-actsum>ans)\\n                 {\\n                     ans=sum-actsum;\\n                     x=i;\\n                     y=j;\\n                 }\\n\\n                 sum-=customers[i];\\n\\n                 if(grumpy[i]==0)\\n                   actsum-=customers[i];\\n                   i++;\\n                   j++;             \\n        }\\n        else\\n        {\\n            j++;\\n        }\\n    }\\n    \\n    int cnt=0;\\n\\n    for(int i=0;i<customers.size();i++)\\n    {\\n        if(i< x || i> y)\\n        cnt+=customers[i]*(abs(1-grumpy[i]));\\n        else\\n        cnt+=customers[i];\\n    }\\n\\n    \\n\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int i=0;\\n        int j=0;\\n\\n        int ans=INT_MIN;\\n\\n        int x=-1;\\n        int y=-1;\\n        int sum=0;\\n        int actsum=0;\\n        while(j<customers.size())\\n        {\\n             sum+=customers[j];\\n             if(grumpy[j]==1)\\n             {\\n                 actsum+=0;\\n             }\\n             else\\n             actsum+=customers[j];\\n\\n             if(j-i+1==minutes)\\n             {\\n                 if(sum-actsum>ans)\\n                 {\\n                     ans=sum-actsum;\\n                     x=i;\\n                     y=j;\\n                 }\\n\\n                 sum-=customers[i];\\n\\n                 if(grumpy[i]==0)\\n                   actsum-=customers[i];\\n                   i++;\\n                   j++;             \\n        }\\n        else\\n        {\\n            j++;\\n        }\\n    }\\n    \\n    int cnt=0;\\n\\n    for(int i=0;i<customers.size();i++)\\n    {\\n        if(i< x || i> y)\\n        cnt+=customers[i]*(abs(1-grumpy[i]));\\n        else\\n        cnt+=customers[i];\\n    }\\n\\n    \\n\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066757,
                "title": "the-slowest-code-in-the-world-it-takes-more-than-9-seconds",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/0951b035-56b6-4957-90b3-89c5e5c0c4e9_1695181414.3689435.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        zero = 0\\n        one = 0\\n        temp = 0\\n\\n        for i in range(0,len(customers)):\\n            if grumpy[i] == 0:\\n                zero = zero + customers[i]\\n        \\n        for j in range(0, len(grumpy) - minutes + 1):\\n            sliding_window = grumpy[j:j + minutes]\\n            for k in range(0,len(sliding_window)):\\n                if sliding_window[k] == 1:\\n                    temp = temp + customers[j + k]\\n            if temp > one:\\n                one = temp\\n            temp = 0\\n\\n        return zero + one\\n\\n        # 20230920\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        zero = 0\\n        one = 0\\n        temp = 0\\n\\n        for i in range(0,len(customers)):\\n            if grumpy[i] == 0:\\n                zero = zero + customers[i]\\n        \\n        for j in range(0, len(grumpy) - minutes + 1):\\n            sliding_window = grumpy[j:j + minutes]\\n            for k in range(0,len(sliding_window)):\\n                if sliding_window[k] == 1:\\n                    temp = temp + customers[j + k]\\n            if temp > one:\\n                one = temp\\n            temp = 0\\n\\n        return zero + one\\n\\n        # 20230920\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053419,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int end =minutes -1;\\n        int x = 0;\\n\\n        for(int i =0; i< minutes; i++){\\n            if(grumpy[i] == 1) x+= customers[i]; \\n        }\\n\\n        int max = x;\\n\\n        for(int i =minutes; i< customers.length; i++){\\n            if(grumpy[i] == 1){\\n                x+= customers[i];\\n            }\\n            if(grumpy[i-minutes] == 1){\\n               x-= customers[i-minutes];\\n            }\\n          \\n            if(x > max){\\n                max=x;\\n                end = i;\\n            } \\n        }\\n\\n\\n        int start = end - minutes;\\n        int result =0;\\n\\n        for(int i =0; i< customers.length; i++){\\n            if((i> start && i <= end) || grumpy[i] == 0){\\n                result+=customers[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int end =minutes -1;\\n        int x = 0;\\n\\n        for(int i =0; i< minutes; i++){\\n            if(grumpy[i] == 1) x+= customers[i]; \\n        }\\n\\n        int max = x;\\n\\n        for(int i =minutes; i< customers.length; i++){\\n            if(grumpy[i] == 1){\\n                x+= customers[i];\\n            }\\n            if(grumpy[i-minutes] == 1){\\n               x-= customers[i-minutes];\\n            }\\n          \\n            if(x > max){\\n                max=x;\\n                end = i;\\n            } \\n        }\\n\\n\\n        int start = end - minutes;\\n        int result =0;\\n\\n        for(int i =0; i< customers.length; i++){\\n            if((i> start && i <= end) || grumpy[i] == 0){\\n                result+=customers[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006473,
                "title": "normal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n        \\n        int n = customers.length;\\n        int ans =0;\\n       for( int i=0; i<n; i++){\\n           if(grumpy[i] == 0){\\n               ans += customers[i];\\n           }\\n       }\\n         int max = 0;\\n        int unsatis = 0 ,i ;\\n        for(  i=0;i<minutes; i++){\\n            if( grumpy[i] == 1){\\n                unsatis += customers[i];\\n            }\\n        }\\n        int j= 0;\\n        max = Math.max(max, unsatis);\\n        while( i < n){\\n            if(grumpy[j] == 1 ){\\n                unsatis -= customers[j];\\n            }\\n            if( grumpy[i] == 1){\\n                unsatis += customers[i];\\n            }\\n            max = Math.max(max, unsatis);\\n            i++;\\n            j++;\\n        }\\n\\n          return ans + max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n        \\n        int n = customers.length;\\n        int ans =0;\\n       for( int i=0; i<n; i++){\\n           if(grumpy[i] == 0){\\n               ans += customers[i];\\n           }\\n       }\\n         int max = 0;\\n        int unsatis = 0 ,i ;\\n        for(  i=0;i<minutes; i++){\\n            if( grumpy[i] == 1){\\n                unsatis += customers[i];\\n            }\\n        }\\n        int j= 0;\\n        max = Math.max(max, unsatis);\\n        while( i < n){\\n            if(grumpy[j] == 1 ){\\n                unsatis -= customers[j];\\n            }\\n            if( grumpy[i] == 1){\\n                unsatis += customers[i];\\n            }\\n            max = Math.max(max, unsatis);\\n            i++;\\n            j++;\\n        }\\n\\n          return ans + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997161,
                "title": "sliding-window-python-solution-beats-74-21-in-runtime",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        min_customers = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0:\\n                min_customers += customers[i]\\n\\n        cur_count,cur_max,start = 0,0,0   \\n        for end in range(len(grumpy)):\\n            if grumpy[end] == 1:\\n                cur_count += customers[end]\\n            \\n            cur_max = max(cur_max,cur_count)\\n\\n            if end-start+1 >= minutes:\\n                if grumpy[start] == 1:\\n                    cur_count -= customers[start]\\n                start += 1\\n        \\n        return min_customers + cur_max\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        min_customers = 0\\n        for i in range(len(grumpy)):\\n            if grumpy[i] == 0:\\n                min_customers += customers[i]\\n\\n        cur_count,cur_max,start = 0,0,0   \\n        for end in range(len(grumpy)):\\n            if grumpy[end] == 1:\\n                cur_count += customers[end]\\n            \\n            cur_max = max(cur_max,cur_count)\\n\\n            if end-start+1 >= minutes:\\n                if grumpy[start] == 1:\\n                    cur_count -= customers[start]\\n                start += 1\\n        \\n        return min_customers + cur_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985688,
                "title": "c-sliding-window",
                "content": "# Code\\n```\\n// Two Pass\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int total = 0, n = customers.size(), ans = 0;\\n        for(int i = 0; i < n; i++) \\n            total += (1 - grumpy[i]) * customers[i];\\n        for(int i = 0; i < n; i++) {\\n            total += grumpy[i] * customers[i];\\n            if(i >= minutes)\\n                total -= grumpy[i - minutes] * customers[i - minutes];\\n            if(i >= minutes - 1)\\n                ans = max(ans, total);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// One Pass\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int total = 0, n = customers.size(), ans = 0, canSatisfy = 0, maxSatisfy = 0;\\n        for(int i = 0; i < n; i++) {\\n            total += (1 - grumpy[i]) * customers[i];\\n            canSatisfy += grumpy[i] * customers[i];\\n            if(i >= minutes)\\n                canSatisfy -= grumpy[i - minutes] * customers[i - minutes];\\n            maxSatisfy = max(maxSatisfy, canSatisfy);\\n        }\\n        return total + maxSatisfy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n// Two Pass\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int total = 0, n = customers.size(), ans = 0;\\n        for(int i = 0; i < n; i++) \\n            total += (1 - grumpy[i]) * customers[i];\\n        for(int i = 0; i < n; i++) {\\n            total += grumpy[i] * customers[i];\\n            if(i >= minutes)\\n                total -= grumpy[i - minutes] * customers[i - minutes];\\n            if(i >= minutes - 1)\\n                ans = max(ans, total);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// One Pass\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int total = 0, n = customers.size(), ans = 0, canSatisfy = 0, maxSatisfy = 0;\\n        for(int i = 0; i < n; i++) {\\n            total += (1 - grumpy[i]) * customers[i];\\n            canSatisfy += grumpy[i] * customers[i];\\n            if(i >= minutes)\\n                canSatisfy -= grumpy[i - minutes] * customers[i - minutes];\\n            maxSatisfy = max(maxSatisfy, canSatisfy);\\n        }\\n        return total + maxSatisfy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982216,
                "title": "easy-c-explained",
                "content": "\\n# Approach\\nFirst we just sum all the `grumpy==0`, Then loop iterates for, it adds the customers who are affected by grumpiness to Tsum, simulating the effect of using the sliding window with size minutes , we add `grumpy==1` customes and hen the window size increases by one. It checks if the customer who just left the window was grumpy (grumpy[i - minutes] == 1) and subtracts their contribution to Tsum..\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int Tsum=0;\\n        int mmax=0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==0){\\n                Tsum +=customers[i];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1)// for i in range of window size sum of customers[i]  grumpy==1 \\n            {\\n                Tsum +=customers[i];\\n            }\\n            if(i<minutes-1)//checking for window size\\n                continue;\\n            else if(i==minutes-1)//if i== window size\\n            {\\n                mmax=max(Tsum,mmax);\\n            }\\n            else //this is case when window size increas by 1 , then we have to check grumpy[i-k]==1 then sub customers[i-k] \\n            {\\n                if(grumpy[i-minutes]==1){\\n                    Tsum-=customers[i-minutes];\\n                }\\n                mmax=max(Tsum,mmax);\\n            }\\n        }\\n        return mmax;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int n=customers.size();\\n        int Tsum=0;\\n        int mmax=0;\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==0){\\n                Tsum +=customers[i];\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(grumpy[i]==1)// for i in range of window size sum of customers[i]  grumpy==1 \\n            {\\n                Tsum +=customers[i];\\n            }\\n            if(i<minutes-1)//checking for window size\\n                continue;\\n            else if(i==minutes-1)//if i== window size\\n            {\\n                mmax=max(Tsum,mmax);\\n            }\\n            else //this is case when window size increas by 1 , then we have to check grumpy[i-k]==1 then sub customers[i-k] \\n            {\\n                if(grumpy[i-minutes]==1){\\n                    Tsum-=customers[i-minutes];\\n                }\\n                mmax=max(Tsum,mmax);\\n            }\\n        }\\n        return mmax;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974612,
                "title": "beats-90-simple-approach",
                "content": "\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int sum = 0;\\n        for(int i = 0; i<customers.length; i++){\\n            sum+= grumpy[i]==0?customers[i]:0; //number of satisfied customers\\n            grumpy[i] = grumpy[i]==1?customers[i]:0; //number of customers that could have been satisfied\\n        }\\n        int max = 0, save = 0;\\n        for(int i = 0; i<grumpy.length; i++){\\n            save+=grumpy[i];\\n            if(i>=minutes){save-=grumpy[i-minutes];}\\n            max = Math.max(max, save);\\n        }\\n        return max + sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        int sum = 0;\\n        for(int i = 0; i<customers.length; i++){\\n            sum+= grumpy[i]==0?customers[i]:0; //number of satisfied customers\\n            grumpy[i] = grumpy[i]==1?customers[i]:0; //number of customers that could have been satisfied\\n        }\\n        int max = 0, save = 0;\\n        for(int i = 0; i<grumpy.length; i++){\\n            save+=grumpy[i];\\n            if(i>=minutes){save-=grumpy[i-minutes];}\\n            max = Math.max(max, save);\\n        }\\n        return max + sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970404,
                "title": "fixed-sliding-window-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        max_satisfied = -1\\n        sum1,i = 0 ,0\\n\\n        for k in range(len(grumpy)) :\\n            if grumpy[k] == 0 :\\n                sum1 += customers[k]\\n        \\n        for j in range(len(customers)):\\n            if grumpy[j] == 1 :\\n                sum1 += customers[j]\\n            \\n            if j-i+1 == minutes :\\n                max_satisfied = max(max_satisfied,sum1)\\n                if grumpy[i] == 1 :\\n                    sum1 -= customers[i]\\n                i += 1\\n        return max_satisfied \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\\n        max_satisfied = -1\\n        sum1,i = 0 ,0\\n\\n        for k in range(len(grumpy)) :\\n            if grumpy[k] == 0 :\\n                sum1 += customers[k]\\n        \\n        for j in range(len(customers)):\\n            if grumpy[j] == 1 :\\n                sum1 += customers[j]\\n            \\n            if j-i+1 == minutes :\\n                max_satisfied = max(max_satisfied,sum1)\\n                if grumpy[i] == 1 :\\n                    sum1 -= customers[i]\\n                i += 1\\n        return max_satisfied \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959019,
                "title": "sliding-window-approach-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we need to identify the duration in which most of the customers are unsatisfied, then we can use that range of minutes to maximise the no of satisfied customers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. storing the no of customers that goes unsatisfied when the owner is grumpy\\n2. using sliding window of size minutes (k) to find the range(rx, ry) where maximum customers are unsatisfied so that we can use secret technique during that time\\n3. finally adding the number of satisfied customers for final ans\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int rx = 0, ry = 0;\\n        int n = customers.size();\\n        vector<int> unsatisfied(n);\\n        // storing the no of customers that goes unsatisfied when the owner is grumpy\\n        for(int i = 0 ;i < n ; i++){\\n            unsatisfied[i] = customers[i]*grumpy[i];\\n        }\\n\\n        // using sliding window of size minutes (k) to find the range (rx,ry) where maximum\\n        // customers are unsatisfied so that we can use secret technique during that time\\n        int maxSum = INT_MIN;\\n        int sum = 0;\\n        int i = 0 , j = 0; \\n\\n        while(j<n ){\\n            sum += unsatisfied[j];\\n            if(j-i+1 < k)j++;\\n            else if(j - i + 1 == k){\\n                if(sum > maxSum){\\n                    maxSum = sum;\\n                    rx = i;\\n                    ry = j;\\n                }\\n                sum -= unsatisfied[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        // finding the number of satisfied customers\\n        int ans = 0;\\n        for(int i = 0 ; i< n ; i++){\\n            if(i >= rx && i <= ry){\\n                ans += customers[i];\\n            }else{\\n            if(grumpy[i] == 0) ans += customers[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int k) {\\n        int rx = 0, ry = 0;\\n        int n = customers.size();\\n        vector<int> unsatisfied(n);\\n        // storing the no of customers that goes unsatisfied when the owner is grumpy\\n        for(int i = 0 ;i < n ; i++){\\n            unsatisfied[i] = customers[i]*grumpy[i];\\n        }\\n\\n        // using sliding window of size minutes (k) to find the range (rx,ry) where maximum\\n        // customers are unsatisfied so that we can use secret technique during that time\\n        int maxSum = INT_MIN;\\n        int sum = 0;\\n        int i = 0 , j = 0; \\n\\n        while(j<n ){\\n            sum += unsatisfied[j];\\n            if(j-i+1 < k)j++;\\n            else if(j - i + 1 == k){\\n                if(sum > maxSum){\\n                    maxSum = sum;\\n                    rx = i;\\n                    ry = j;\\n                }\\n                sum -= unsatisfied[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        // finding the number of satisfied customers\\n        int ans = 0;\\n        for(int i = 0 ; i< n ; i++){\\n            if(i >= rx && i <= ry){\\n                ans += customers[i];\\n            }else{\\n            if(grumpy[i] == 0) ans += customers[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943962,
                "title": "c-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int k) {\\n        int n = c.size();\\n        int sum = 0;\\n        int maxS = 0;\\n        for(int i=k;i<n;i++)\\n        sum+=(g[i]==0)?c[i]:0;\\n        int tmps = 0;\\n        for(int i=0;i<k;i++)\\n        tmps+=c[i];\\n        maxS = sum+tmps;\\n        int p1 = 0,p2 = k;\\n        while(p2<n)\\n        {\\n            tmps-=c[p1];\\n            tmps+=c[p2];\\n            if(g[p1]==0)\\n            sum+=c[p1];\\n            if(g[p2]==0)\\n            sum-=c[p2];\\n            maxS = max(maxS,tmps+sum);\\n            p1++;\\n            p2++;\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& c, vector<int>& g, int k) {\\n        int n = c.size();\\n        int sum = 0;\\n        int maxS = 0;\\n        for(int i=k;i<n;i++)\\n        sum+=(g[i]==0)?c[i]:0;\\n        int tmps = 0;\\n        for(int i=0;i<k;i++)\\n        tmps+=c[i];\\n        maxS = sum+tmps;\\n        int p1 = 0,p2 = k;\\n        while(p2<n)\\n        {\\n            tmps-=c[p1];\\n            tmps+=c[p2];\\n            if(g[p1]==0)\\n            sum+=c[p1];\\n            if(g[p2]==0)\\n            sum-=c[p2];\\n            maxS = max(maxS,tmps+sum);\\n            p1++;\\n            p2++;\\n        }\\n        return maxS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941698,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSatisfied(int[] cus, int[] gru, int k) {\\n        int res[] = new int[cus.length];\\n        int max = 0, sum = 0;\\n        for(int i = 0 ; i < cus.length ;i++){\\n            if(gru[i] == 1){\\n                res[i] = cus[i];\\n            }else{\\n                sum += cus[i];\\n            }\\n        }\\n        int s = 0;\\n        for(int i = 0 ; i < k; i++){\\n            s += res[i];\\n        }\\n        max = s;\\n        for(int i = k ; i < cus.length ;i++){\\n            s = s + res[i] - res[i - k];\\n            max = Math.max(s, max);\\n        }\\n        return sum + max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSatisfied(int[] cus, int[] gru, int k) {\\n        int res[] = new int[cus.length];\\n        int max = 0, sum = 0;\\n        for(int i = 0 ; i < cus.length ;i++){\\n            if(gru[i] == 1){\\n                res[i] = cus[i];\\n            }else{\\n                sum += cus[i];\\n            }\\n        }\\n        int s = 0;\\n        for(int i = 0 ; i < k; i++){\\n            s += res[i];\\n        }\\n        max = s;\\n        for(int i = k ; i < cus.length ;i++){\\n            s = s + res[i] - res[i - k];\\n            max = Math.max(s, max);\\n        }\\n        return sum + max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933399,
                "title": "elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 1108ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 69.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_satisfied(customers :: [integer], grumpy :: [integer], minutes :: integer) :: integer\\n  def max_satisfied(customers, grumpy, minutes) do\\n    {total, grumpy} = get_new_grumpy(customers, grumpy, 0, [])\\n    {_, _, m_customers} =\\n      Enum.reduce(grumpy, {0, 0, 0}, fn grumpy_i, {i, save, m_customers} ->\\n        if i < minutes do\\n          m_customers = m_customers + grumpy_i\\n          {i + 1, m_customers, m_customers}\\n        else\\n          save = save + grumpy_i - Enum.at(grumpy, i - minutes)\\n          if save > m_customers do\\n            {i + 1, save, save}\\n          else\\n            {i + 1, save, m_customers}\\n          end\\n        end\\n      end)\\n    total + m_customers\\n  end\\n\\n  @spec get_new_grumpy(customers :: [integer], grumpy :: [integer], total :: integer, n_grumpy :: [integer]) :: {integer, [integer]}\\n  def get_new_grumpy([], [], total, n_grumpy) do\\n    {total, n_grumpy}\\n  end\\n\\n  def get_new_grumpy([cust_hd | cust_tl], [grum_hd | grum_tl], total, n_grumpy) do\\n    get_new_grumpy(cust_tl, grum_tl, total + cust_hd*(1 - grum_hd), [cust_hd*grum_hd | n_grumpy])\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_satisfied(customers :: [integer], grumpy :: [integer], minutes :: integer) :: integer\\n  def max_satisfied(customers, grumpy, minutes) do\\n    {total, grumpy} = get_new_grumpy(customers, grumpy, 0, [])\\n    {_, _, m_customers} =\\n      Enum.reduce(grumpy, {0, 0, 0}, fn grumpy_i, {i, save, m_customers} ->\\n        if i < minutes do\\n          m_customers = m_customers + grumpy_i\\n          {i + 1, m_customers, m_customers}\\n        else\\n          save = save + grumpy_i - Enum.at(grumpy, i - minutes)\\n          if save > m_customers do\\n            {i + 1, save, save}\\n          else\\n            {i + 1, save, m_customers}\\n          end\\n        end\\n      end)\\n    total + m_customers\\n  end\\n\\n  @spec get_new_grumpy(customers :: [integer], grumpy :: [integer], total :: integer, n_grumpy :: [integer]) :: {integer, [integer]}\\n  def get_new_grumpy([], [], total, n_grumpy) do\\n    {total, n_grumpy}\\n  end\\n\\n  def get_new_grumpy([cust_hd | cust_tl], [grum_hd | grum_tl], total, n_grumpy) do\\n    get_new_grumpy(cust_tl, grum_tl, total + cust_hd*(1 - grum_hd), [cust_hd*grum_hd | n_grumpy])\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3931448,
                "title": "easy-approach-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int k = minutes;\\n        vector<int>& arr = customers;\\n        int n = arr.size();\\n        int prevLoss = 0;\\n        for(int i=0;i<k;i++){\\n           if(grumpy[i]==1) prevLoss += arr[i];\\n        }\\n        int maxLoss = prevLoss; \\n        int maxIdx = 0;\\n        int i = 1;\\n        int j = k;\\n        while(j<n){\\n            int currLoss = prevLoss;\\n            if(grumpy[j]==1) currLoss += arr[j];\\n            if(grumpy[i-1]==1) currLoss -= arr[i-1];\\n            if(maxLoss<currLoss){\\n                maxLoss = currLoss;\\n                maxIdx = i;\\n            }\\n            prevLoss = currLoss;\\n            i++;\\n            j++;\\n        }\\n            // filling grumpy array - - >\\n            for(int i=maxIdx;i<k+maxIdx;i++){\\n                grumpy[i] = 0;\\n            }\\n            // sum of satisfaction - - - >\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                if(grumpy[i]==0)sum += arr[i];\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n        int k = minutes;\\n        vector<int>& arr = customers;\\n        int n = arr.size();\\n        int prevLoss = 0;\\n        for(int i=0;i<k;i++){\\n           if(grumpy[i]==1) prevLoss += arr[i];\\n        }\\n        int maxLoss = prevLoss; \\n        int maxIdx = 0;\\n        int i = 1;\\n        int j = k;\\n        while(j<n){\\n            int currLoss = prevLoss;\\n            if(grumpy[j]==1) currLoss += arr[j];\\n            if(grumpy[i-1]==1) currLoss -= arr[i-1];\\n            if(maxLoss<currLoss){\\n                maxLoss = currLoss;\\n                maxIdx = i;\\n            }\\n            prevLoss = currLoss;\\n            i++;\\n            j++;\\n        }\\n            // filling grumpy array - - >\\n            for(int i=maxIdx;i<k+maxIdx;i++){\\n                grumpy[i] = 0;\\n            }\\n            // sum of satisfaction - - - >\\n            int sum = 0;\\n            for(int i=0;i<n;i++){\\n                if(grumpy[i]==0)sum += arr[i];\\n            }\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568581,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1569531,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1575569,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1753827,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1572700,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1569518,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2061988,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2020104,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2015072,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1839589,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1568581,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1569531,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1575569,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1753827,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1572700,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1569518,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2061988,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2020104,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 2015072,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            },
            {
                "id": 1839589,
                "content": [
                    {
                        "username": "kakkarotssj",
                        "content": "customers = [10, 1, 7]\\ngrumpy = [0, 0, 0]\\nminutes = 2\\n\\nFor this case, how is answer 18 and not 11.\\n"
                    },
                    {
                        "username": "YASH-SHARMA19",
                        "content": "bro if grumpy[i]!=1 or it is 0 means seller is not grumpy so the customer will be satisfied and in your case all grumpy[i]==0 so all the customers are satisfied resulting 10+1+7 = 18."
                    },
                    {
                        "username": "arockia_raj",
                        "content": "if 0 means the book store owner is not at all grumpy.  so we need to just add all .. Here the 2 mints is not needed because he is already not grumpy. This is a different  test case but I think it is valid . "
                    },
                    {
                        "username": "rishabhpathak09",
                        "content": "understand that grumpy[i] = 0 when he is grumpy\ngrumpy[i] = 1 means he  is not  grumpy"
                    },
                    {
                        "username": "zliu346",
                        "content": "![image](https://assets.leetcode.com/users/zliu346/image_1560162827.png)\\n"
                    },
                    {
                        "username": "sahil_6789",
                        "content": "Bro he is grumpy if value is 1 and for zero he is not you considered opposite i think"
                    },
                    {
                        "username": "bansaldeepak013",
                        "content": "[10,1,7]\\n[0,0,0]\\n2\\n\\n\\nthe secret power can be used for consecutive 2 minutes\\nso max customers which can be satisfied should be  10+1 = 1\\nbut this test case answers 18. \\nI am not able to understand this part \\n\\naccording to me, if  minutes values would have been 3, then the test case answer would have been 18.\\nAny help would be appreciated"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "r4ge_101",
                        "content": "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. The maximum number of customers that can be satisfied \n= 1 + 1 + 1 + 1 + 7 + 5 = 16.\n\nHow is the output 16 if we keep the owner NOT grumpy for the last 3 mins.\nshouldn't it be 1+1+7+5 =14 ??\n"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "Description for this testcase is wrong ig. The second last 3 minutes is the time when the shopkeeper is not grumpy.\\n\\nHence , 2+1+1+7+5 would give 16 satisfied customers and the grumpy array (altered) is [0,1,0,1,1,1,1,1].\\n\\nHope this helps !!"
                    },
                    {
                        "username": "zhongzh13",
                        "content": "Hello everyone, I think I\\'ve met some problem so I\\'m asking for your help, Please feel free to leave any comment\\n\\nThere is a test case: \\nInput:\\n[10,1,7]\\n[0,0,0]\\n2\\nOutput:\\n11\\nExpected:\\n18\\n\\nBut how can the bookstore owner satisfy all the 18 customers when X is only 2?"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 + 1 =11"
                    },
                    {
                        "username": "sunset_fish",
                        "content": "What do you thing about this test case:\\n\\n[10,1,7]\\n[0,0,0]\\n2\\n\\nHow can 18 be the expected answer for this case, I\\'m getting 11 as answer."
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "your grumpy array is [0,0,0] means he is not grumpy at any minute. Thus the whole array [10,1,7] can be taken into account. If the grumpy array was [0,0,1], then the answer would be 10 +1 =11"
                    },
                    {
                        "username": "dhruv_bajpai29",
                        "content": "The question is fairly easy."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Think about splitting up the customers arr into arrays of size minutes. The potential value to be gained by using the \"secret technique\" during that range is equivalent to the sum of customers that would be at the shop on grumpy minutes, within that minutes timeframe. We would only count the customers on the grumpy minutes because the customers on non-grumpy minutes are already guaranteed to be satisfied, so the satisfied customers that we can gain exist within the ones on grumpy minutes.\\n\\nAfter you\\'ve calculated the numbers of unsatisfied customers for each contiguous subarray of size minutes, the answer is just the largest value of unsatisfied customers plus the total sum of customers in the store on non-grumpy minutes.\\n\\nExample:\\n[1, 2, 1, 5, 3, 2, 1] <- Customers\\n[1, 0, 1, 0, 1, 0, 1] <- Grumpy\\n2 <- Minutes\\nFrom left to right, our unsatisfied customers subarr valuess would be:\\n0 to 1 = 1,\\n1 to 2 = 1,\\n2 to 3 = 1, \\n3 to 4 = 3,\\n4 to 5 = 3, \\n5 to 6 = 1\\n\\nAs you can see, the max amount to gain is 3. So our answer would be 3 plus the amount of customers on non-grumpy days:\\n2 + 5 + 2 = 9.\\n9 + 3 = 12 - the maximum satisfied customers.\\n\\n"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "for exam ple no. 1 if we do not keep him grumpy for last 3 minutes than the answer will be (1+2+1+1+7+5)=17 \\nwhy it is giving 16 i  guess its an error  @"
                    },
                    {
                        "username": "abhinvsinh",
                        "content": "16 is the expected answer for example 1, you are counting the 2 which is incorrect.\n[1,0,1,2,1,1,7,5] - Customer array\n[0,1,0,1,0,1,0,1] - grumpy Array\n[0,1,0,1,0,0,0,0] - Changing grumpy array at 6th position which changes the subsequent value at 8th position as well \n as the non-grumpy technique last for the last 3 minutes so (6-7-8) positions become non grumpy.\n[1,   1,   1 1 7 5] - 1+1+1+1+7+5=16   "
                    },
                    {
                        "username": "jeromw07",
                        "content": "customers =\\n[4,10,10]\\ngrumpy =\\n[1,1,0]\\nminutes =\\n2    \\n\\nWhat is the correct answer ?"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001) class Solution {\\n    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {\\n        \\n int maxIndex=0;\\n\\t\\t int maxCustomers=0;\\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\tint tempi=i;\\n\\t\\t\\tint maxCustomersTemp=0;\\n\\t\\t\\t for(int j=1;j<=minutes;j++)\\n\\t\\t\\t {\\n\\t\\t\\t\\tif(tempi<customers.length)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t maxCustomersTemp=maxCustomersTemp+customers[tempi];\\n\\t\\t\\t\\t tempi++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t }\\n\\t\\t\\t\\t \\n\\t\\t\\t if(maxCustomersTemp>maxCustomers)\\n\\t\\t\\t {\\n\\t\\t\\t\\t maxCustomers=maxCustomersTemp;\\n\\t\\t\\t\\t maxIndex=tempi-minutes;\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t\\n\\t//\\tSystem.out.println(maxCustomers);\\n\\t\\t//System.out.println(maxIndex);\\n\\t\\t \\n\\t\\t \\n\\t\\t for(int i=0;i<customers.length;i++)\\n\\t\\t {\\n\\t\\t\\t if(i!=maxIndex&&grumpy[i]==0&&customers[i]>0)\\n\\t\\t\\t maxCustomers=maxCustomers+customers[i];\\n\\t\\t\\t else if(i==maxIndex)\\n\\t\\t     i=i+minutes-1;\\n\\t\\t }\\n\\t\\t \\n\\t\\treturn(maxCustomers); \\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "jeromw07",
                        "content": "[@pratik16082001](/pratik16082001)  Can you justify the solution with some example ?\\n"
                    },
                    {
                        "username": "pratik16082001",
                        "content": "24 is"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Numbers of Function Calls to Make Target Array",
        "question_content": "<p>You are given an integer array <code>nums</code>. You have an integer array <code>arr</code> of the same length with all values set to <code>0</code> initially. You also have the following <code>modify</code> function:</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png\" style=\"width: 573px; height: 294px;\" />\n<p>You want to use the modify function to convert <code>arr</code> to <code>nums</code> using the minimum number of calls.</p>\n\n<p>Return <em>the minimum number of function calls to make </em><code>nums</code><em> from </em><code>arr</code>.</p>\n\n<p>The test cases are generated so that the answer fits in a <strong>32-bit</strong> signed integer.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Increment by 1 (second element): [0, 0] to get [0, 1] (1 operation).\nDouble all the elements: [0, 1] -&gt; [0, 2] -&gt; [0, 4] (2 operations).\nIncrement by 1 (both elements)  [0, 4] -&gt; [1, 4] -&gt; <strong>[1, 5]</strong> (2 operations).\nTotal of operations: 1 + 2 + 2 = 5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Increment by 1 (both elements) [0, 0] -&gt; [0, 1] -&gt; [1, 1] (2 operations).\nDouble all the elements: [1, 1] -&gt; <strong>[2, 2]</strong> (1 operation).\nTotal of operations: 2 + 1 = 3.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,5]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> (initial)[0,0,0] -&gt; [1,0,0] -&gt; [1,0,1] -&gt; [2,0,2] -&gt; [2,1,2] -&gt; [4,2,4] -&gt; <strong>[4,2,5]</strong>(nums).\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 805740,
                "title": "java-c-python-bit-counts",
                "content": "# **Intuition**\\nThink in backward way,\\nfor each number `a` in A,\\nif `a % 2 == 1`, we do operation 0 backward, turning 1 to 0.\\nIf all `a % 2 == 0`, we do operation 1 backward.\\n\\nSome observation here:\\n1. For each bit \"1\" in the bianry format of `a`,\\nwe need at least one operation 0.\\n2. All operation 1 can be shared.\\n\\n# **Explanation**\\nFor each number `a`,\\nwe count the number of bits \"1\",\\nas well as the length of `a` in binary format.\\n\\nThe number of operation 0 equals to the total number of bits \"1\".\\nThe number of operation 1 equals to maximum bit length - 1.\\n<br>\\n\\n# **Complexity**\\nTime `O(Nlog(10^9)))`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minOperations(int[] A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = Math.max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n```\\n**Java, using build-in**\\nBy @FrenkieDeJong\\n```java\\n    public int minOperations(int[] A) {\\n        int res = 0, max = 0;\\n        for (int a : A) {\\n            if (a == 0) continue;\\n            res += Integer.bitCount(a);\\n            max = Math.max(max, Integer.numberOfTrailingZeros(Integer.highestOneBit(a)));\\n        }\\n        return res + max;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int minOperations(vector<int>& A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def minOperations(self, A):\\n        return sum(bin(a).count(\\'1\\') for a in A) + len(bin(max(A))) - 3\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minOperations(int[] A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = Math.max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n```\n```java\\n    public int minOperations(int[] A) {\\n        int res = 0, max = 0;\\n        for (int a : A) {\\n            if (a == 0) continue;\\n            res += Integer.bitCount(a);\\n            max = Math.max(max, Integer.numberOfTrailingZeros(Integer.highestOneBit(a)));\\n        }\\n        return res + max;\\n    }\\n```\n```cpp\\n    int minOperations(vector<int>& A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n```\n```py\\n    def minOperations(self, A):\\n        return sum(bin(a).count(\\'1\\') for a in A) + len(bin(max(A))) - 3\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 805672,
                "title": "simple-explanation",
                "content": "```(Minimum number of operations) = minimum((number of +1 operations) +  (number of x2 operations)) ```\\n\\n```number of x2 operations``` = ```(highest set bit in binary representation)``` because each x2 operation shifts the binary digit to left, hence highest set bit will be number of x2 operations we will have to perform. By only performing (highest set bit) number of operations, we reuse x2 operation across all nums.\\n\\n```number of +1 operations``` = ```(number of 1s in the binary representation of each number)``` because each 1 in binary representation is introduced by +1 operation.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int addOneOperations = 0; // +1 operations\\n        int highestSetBit = 0; // x2 operations\\n        for (int bit = 0; bit <= 30; ++bit) {\\n            for (int num : nums) {\\n                if ((num & (1 << bit)) != 0) {\\n                    addOneOperations++;\\n                    highestSetBit = bit;\\n                }\\n            }\\n        }\\n        return addOneOperations + highestSetBit; // (+1 operations) + (x2 operations)\\n    }\\n}\\n```\\nComplexity: ```O(nlog(max(nums))```\\n",
                "solutionTags": [],
                "code": "```(Minimum number of operations) = minimum((number of +1 operations) +  (number of x2 operations)) ```\n```number of x2 operations```\n```(highest set bit in binary representation)```\n```number of +1 operations```\n```(number of 1s in the binary representation of each number)```\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int addOneOperations = 0; // +1 operations\\n        int highestSetBit = 0; // x2 operations\\n        for (int bit = 0; bit <= 30; ++bit) {\\n            for (int num : nums) {\\n                if ((num & (1 << bit)) != 0) {\\n                    addOneOperations++;\\n                    highestSetBit = bit;\\n                }\\n            }\\n        }\\n        return addOneOperations + highestSetBit; // (+1 operations) + (x2 operations)\\n    }\\n}\\n```\n```O(nlog(max(nums))```",
                "codeTag": "Java"
            },
            {
                "id": 805971,
                "title": "python3-simple-intuition-without-bitwise-operations",
                "content": "- For any element in an array, consider it a sequence of addition of 1 and multiplication by 2. eg (`2 = +1, *2`) (`5 = +1, *2, +1`)\\n- Each addition operation will be done separately, so we need to simply count all of them\\n- But when it comes to the multiplication, we can simply find what is the maximum number of multiply by 2 operations we need to perform from all the elements, since these operations can be performed for multiple element at once and thus can be arranged however we want\\n- Then our solution would be simply the sum of the addition operations and the maximum number of multiply operations in any element.\\n- Time complexity: `O(32N) = O(N)`\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        twos = 0\\n        ones = 0\\n        for n in nums:\\n            mul = 0\\n            while n:\\n                if n%2: # odd number, just delete 1 so that it\\'s now a multiple of 2\\n                    n -= 1\\n                    ones += 1\\n                else: # multiple of 2, so just divide by 2 \\n                    n //= 2\\n                    mul += 1\\n            twos = max(twos, mul)\\n        return ones + twos\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        twos = 0\\n        ones = 0\\n        for n in nums:\\n            mul = 0\\n            while n:\\n                if n%2: # odd number, just delete 1 so that it\\'s now a multiple of 2\\n                    n -= 1\\n                    ones += 1\\n                else: # multiple of 2, so just divide by 2 \\n                    n //= 2\\n                    mul += 1\\n            twos = max(twos, mul)\\n        return ones + twos\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805884,
                "title": "java-explanation-with-video-comments-o-n-log-m",
                "content": "Work backwards, if any number is odd, subtract 1. If even, divide by 2. \\nEXAMPLE:\\n[4,2,5]\\n1. [4,2,4] + 1 operation, previous had odd, so subtract 1 \\n2. [2,1,2] + 1 op, previous had all even, divide by 2\\n3. [2,0,2] + 1 op, previous had odd, so subtract 1\\n4. [1,0,1] + 1 op , previous had all even, divide by 2\\n5. [0,0,1] + 1 op , previous had odd, so subtract 1 \\n6. [0,0,0] + 1 op , previous had odd, so subtract 1 \\n\\nThat is 6 operations. \\n\\nBut we can\\'t really iterate like that in code, so instead, we iterate through the numbers individually and for each one, we divide by 2 and subtract by 1 each time.\\n\\n-> If we divide, we ONLY increase the count if it\\'s greater than how many divides we previously had. That\\'s because the divide operation happens across every number unlike the subtract operation. So if we divided previously, that means this number had been divided already, so we shouldn\\'t increment count.\\n\\n-> If we subtract, we increase count each time.\\n\\nOnce the number hits 0, we can stop.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // WORK BACKWARDS\\n        int count = 0;\\n        int currDivides = 0; // how many times have we currently divided by 2\\n        \\n        // The most a number has been divided by 2      \\n        int maxDivides = Integer.MIN_VALUE;//(basically dependant on the largest number)\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            currDivides = 0; // reset to 0\\n            int n = nums[i];\\n            while (n > 0) { // while the number hasn\\'t hit zero\\n                \\n                if (n % 2 == 0) { // if its even, divide by 2\\n                    n = n / 2;\\n                    currDivides++;\\n                    \\n                    // if our current number of divides is greater than the max, we can increase our count\\n                    if (currDivides > maxDivides) {\\n                        count++;\\n                        maxDivides = currDivides;\\n                    }\\n                } else { // if its odd, subtract 11\\n                    n--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n<iframe width=\"966\" height=\"604\" src=\"https://www.youtube.com/embed/_2OI6es836M\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // WORK BACKWARDS\\n        int count = 0;\\n        int currDivides = 0; // how many times have we currently divided by 2\\n        \\n        // The most a number has been divided by 2      \\n        int maxDivides = Integer.MIN_VALUE;//(basically dependant on the largest number)\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            currDivides = 0; // reset to 0\\n            int n = nums[i];\\n            while (n > 0) { // while the number hasn\\'t hit zero\\n                \\n                if (n % 2 == 0) { // if its even, divide by 2\\n                    n = n / 2;\\n                    currDivides++;\\n                    \\n                    // if our current number of divides is greater than the max, we can increase our count\\n                    if (currDivides > maxDivides) {\\n                        count++;\\n                        maxDivides = currDivides;\\n                    }\\n                } else { // if its odd, subtract 11\\n                    n--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805682,
                "title": "accumulate-bits",
                "content": "**Intuition**\\nWe can flip the question and reduce `nums` to a zero array:\\n- If a number is odd, we have no choice but to decrement it.\\n- If a number is even, we divide it by 2.\\n\\nNow, since we can divide all numbers in one operation, we just need to track the maximum number and add its devisions in the end.\\n\\nIn C++, `bitset.count` uses the most efficient implementaiton for the hardware, and we can consider it O(1). Since we calculate `log2i` once in the end, the algorithm time complexity is O(n).\\n\\n> We use `log2i` instead of standard `log2` because it is faster, and does not cause an error if the value is zero.\\n\\n```cpp\\nint minOperations(vector<int>& n) {\\n    function<int(int)> log2i = [&](int a){ return a < 2 ? 0 : 1 + log2i(a >> 1); };\\n    return accumulate(begin(n), end(n), 0, [&](int s, int i) { return s + bitset<32>(i).count(); }) \\n        + log2i(*max_element(begin(n), end(n)));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<int>& n) {\\n    function<int(int)> log2i = [&](int a){ return a < 2 ? 0 : 1 + log2i(a >> 1); };\\n    return accumulate(begin(n), end(n), 0, [&](int s, int i) { return s + bitset<32>(i).count(); }) \\n        + log2i(*max_element(begin(n), end(n)));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851790,
                "title": "easy-understanding-explained-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res=0;\\n        int n=nums.size();\\n\\t\\t//Work backwards i.e.  go from nums to arr\\n        while(1){\\n            int count=0,countzero=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1; // decrease the odd number by one \\n                    res++;\\n                }else{\\n                    count++;  // count the even numbers in array \\n                } \\n                if(nums[i]==0){\\n                    countzero++; // count the zeros in array \\n                }\\n            }\\n\\t\\t\\t// if count of zeros is equal to length of array means that array come at intial condition i.e. [0,0....] thus simply return res\\n            if(countzero==n){\\n                return res;\\n            }\\n\\t\\t\\t// if count of even is equal to length of array means that array contains even numbers only so divide them by 2 and increase res by 1\\n            if(count==n){\\n                res++;\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res=0;\\n        int n=nums.size();\\n\\t\\t//Work backwards i.e.  go from nums to arr\\n        while(1){\\n            int count=0,countzero=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1; // decrease the odd number by one \\n                    res++;\\n                }else{\\n                    count++;  // count the even numbers in array \\n                } \\n                if(nums[i]==0){\\n                    countzero++; // count the zeros in array \\n                }\\n            }\\n\\t\\t\\t// if count of zeros is equal to length of array means that array come at intial condition i.e. [0,0....] thus simply return res\\n            if(countzero==n){\\n                return res;\\n            }\\n\\t\\t\\t// if count of even is equal to length of array means that array contains even numbers only so divide them by 2 and increase res by 1\\n            if(count==n){\\n                res++;\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806490,
                "title": "java-simple-count",
                "content": "when op == 0 is simple, just count how many op == 0 for each number;\\ntrick for op == 1, you may find that you just need to count the max of op == 1 for each number, and the total count of op == 1 will be that number;\\n```\\nclass Solution {\\n    int maxOpOne = Integer.MIN_VALUE;\\n    public int minOperations(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) res += getOpZero(n);\\n        return res + maxOpOne;\\n    }\\n    \\n    private int getOpZero(int n) {\\n        int res = 0, opOne = 0;\\n        while (n > 0) {\\n            res += n % 2; // op == 0;\\n            n /= 2;\\n            if (n > 0) opOne++; // op == 1;\\n        }\\n        maxOpOne = Math.max(maxOpOne, opOne);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxOpOne = Integer.MIN_VALUE;\\n    public int minOperations(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) res += getOpZero(n);\\n        return res + maxOpOne;\\n    }\\n    \\n    private int getOpZero(int n) {\\n        int res = 0, opOne = 0;\\n        while (n > 0) {\\n            res += n % 2; // op == 0;\\n            n /= 2;\\n            if (n > 0) opOne++; // op == 1;\\n        }\\n        maxOpOne = Math.max(maxOpOne, opOne);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805843,
                "title": "c-easy-greedy-count-ones-and-take-max-power-of-2",
                "content": "Approach:\\n\\nFor each number, find the path from that number to `0` i.e. when even then divide by 2 and otherwise subtract one. Since `op = 0` corresponds to ones, then add the ones required for each number in the total ans.\\n\\nStore the maximum power required by all numbers and just add the maximum in answer since we can this parallely for all elements.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int ans = 0;\\n        int pow2 = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            int ones = 0;\\n            int p = 0;\\n\\n            while(A[i] > 0) {\\n                if(A[i] % 2 == 0) {\\n                    p++;\\n                    A[i] = A[i]/2;\\n                } else {\\n                    ones++;\\n                    A[i]--;\\n                }\\n            }\\n            \\n            pow2 = max(pow2, p);\\n            ans += ones;\\n        }\\n        ans += pow2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int ans = 0;\\n        int pow2 = 0;\\n        for(int i = 0; i < A.size(); i++) {\\n            int ones = 0;\\n            int p = 0;\\n\\n            while(A[i] > 0) {\\n                if(A[i] % 2 == 0) {\\n                    p++;\\n                    A[i] = A[i]/2;\\n                } else {\\n                    ones++;\\n                    A[i]--;\\n                }\\n            }\\n            \\n            pow2 = max(pow2, p);\\n            ans += ones;\\n        }\\n        ans += pow2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805669,
                "title": "c-python-java-concise-greedy-solution-o-nlogn-with-bried-comments",
                "content": "\\nWe reverse the operation:  \\nop1: minus 1  \\nop2: divide by 2  \\nSo we can have this greedy solution:  \\nwe try to divide all the numbers by 2, if current number % 2 == 1, then we should add 1 operation, because this number should subtract 1.  \\nwe redo all the steps, until all the numbers become to 0.  \\n    \\nC++  \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        while(true) {\\n            bool largerThan1 = false;\\n            bool allzero = true;\\n            for(auto &n : nums) {\\n                if(n == 0) continue;\\n                allzero = false;\\n                if(n > 1) largerThan1 = true;\\n                ans += n % 2;\\n                n /= 2;\\n            }\\n            ans += largerThan1; //we should do division if some element is larger than 1.\\n            if(allzero) break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nJava  \\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = 0;\\n        while(true) {\\n            int largerThan1 = 0;\\n            boolean allzero = true;\\n            for(int i = 0; i < nums.length; ++i) {\\n                int n = nums[i];\\n                if(n == 0) continue;\\n                allzero = false;\\n                if(n > 1) largerThan1 = 1; \\n                ans += n % 2;\\n                nums[i] /= 2;\\n            }\\n            ans += largerThan1; //we should do division if some element is larger than 1.\\n            if(allzero) break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nPython  \\n```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0;\\n        while True:\\n            largerThan1 = False;\\n            allzero = True;\\n            for idx, n in enumerate(nums):\\n                if n == 0: continue;\\n                allzero = False;\\n                if n > 1: largerThan1 = True; \\n                ans += n % 2;\\n                nums[idx] /= 2;\\n            ans += largerThan1; #we should do division if some element is larger than 1.\\n            if allzero :break;\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        while(true) {\\n            bool largerThan1 = false;\\n            bool allzero = true;\\n            for(auto &n : nums) {\\n                if(n == 0) continue;\\n                allzero = false;\\n                if(n > 1) largerThan1 = true;\\n                ans += n % 2;\\n                n /= 2;\\n            }\\n            ans += largerThan1; //we should do division if some element is larger than 1.\\n            if(allzero) break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = 0;\\n        while(true) {\\n            int largerThan1 = 0;\\n            boolean allzero = true;\\n            for(int i = 0; i < nums.length; ++i) {\\n                int n = nums[i];\\n                if(n == 0) continue;\\n                allzero = false;\\n                if(n > 1) largerThan1 = 1; \\n                ans += n % 2;\\n                nums[i] /= 2;\\n            }\\n            ans += largerThan1; //we should do division if some element is larger than 1.\\n            if(allzero) break;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0;\\n        while True:\\n            largerThan1 = False;\\n            allzero = True;\\n            for idx, n in enumerate(nums):\\n                if n == 0: continue;\\n                allzero = False;\\n                if n > 1: largerThan1 = True; \\n                ans += n % 2;\\n                nums[idx] /= 2;\\n            ans += largerThan1; #we should do division if some element is larger than 1.\\n            if allzero :break;\\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805954,
                "title": "java-greedy-approach-easy-to-understand",
                "content": "For each index, if the number is not zero, we count the number of steps for it to get to 1. We use a while loop to count the operations. If num is even, a double operation can be used to reach num, else, an add operation can be used to reach num from an even number. We only care about the max number of double operations because we can arrange the order of add operations to hide the rest of the double operations.\\n\\nAt last, we sum up the number of add and double operations to get the answer.\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n\\t\\tint op1 = 0; // number of double operations\\n        int op2 = 0; // number of add operations\\n        int ans = 0; // number of total operations\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all non-zero numbers, we have to at least do one add operation\\n            op2++;\\n            \\n\\t\\t\\t// number of double operations required for current index\\n            int op1curr = 0;\\n            \\n            // find the number of steps to get to 1\\n            while (nums[i] != 1) {\\n                \\n\\t\\t\\t\\t// odd number can be reached from an even number using an add operation\\n                if (nums[i] % 2 != 0) {\\n                    op2++;\\n                    nums[i]--;\\n                }\\n                \\n\\t\\t\\t\\t// even number can be reached using double operation\\n                if (nums[i] != 1) {\\n                    // even\\n                    op1curr++;\\n                    nums[i] /= 2;\\n                }\\n            }\\n            \\n\\t\\t\\t// we only need max\\n            op1 = Math.max(op1, op1curr);\\n        }\\n\\n        ans += op1 + op2;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n\\t\\tint op1 = 0; // number of double operations\\n        int op2 = 0; // number of add operations\\n        int ans = 0; // number of total operations\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all non-zero numbers, we have to at least do one add operation\\n            op2++;\\n            \\n\\t\\t\\t// number of double operations required for current index\\n            int op1curr = 0;\\n            \\n            // find the number of steps to get to 1\\n            while (nums[i] != 1) {\\n                \\n\\t\\t\\t\\t// odd number can be reached from an even number using an add operation\\n                if (nums[i] % 2 != 0) {\\n                    op2++;\\n                    nums[i]--;\\n                }\\n                \\n\\t\\t\\t\\t// even number can be reached using double operation\\n                if (nums[i] != 1) {\\n                    // even\\n                    op1curr++;\\n                    nums[i] /= 2;\\n                }\\n            }\\n            \\n\\t\\t\\t// we only need max\\n            op1 = Math.max(op1, op1curr);\\n        }\\n\\n        ans += op1 + op2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805822,
                "title": "python-easy-solution-without-bits-greedy",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        operations = 0\\n        while any(nums):\\n            for i in range(len(nums)):\\n                if nums[i] % 2 != 0:\\n                    nums[i] -= 1\\n                    operations += 1\\n            if any(nums):\\n                for i in range(len(nums)):\\n                    nums[i] = nums[i]//2\\n                operations += 1\\n        return operations\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        operations = 0\\n        while any(nums):\\n            for i in range(len(nums)):\\n                if nums[i] % 2 != 0:\\n                    nums[i] -= 1\\n                    operations += 1\\n            if any(nums):\\n                for i in range(len(nums)):\\n                    nums[i] = nums[i]//2\\n                operations += 1\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358333,
                "title": "c-intuitive-approach-using-bits",
                "content": "### Method 1\\n**Simulative approach**\\nWe just do as the problem asks us to do, but the underlying concept is same in both methds. \\n**What\\'s the Concept?**\\nSee, we know that any number can be formed by adding various powers of 2. This can be proved as we can represent every number as a binary representation. So, we are using this only. I run the loop only 32 times because given the constraints, there wont be any number greater than 2<sup>32</sup>.  So in each iteration, i divide the number by 2 if it a even number, and if it not, i add an extra 1 to our answer to make that number even by subtracting 1 from it. \\n\\n**Implementation**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int t = 33;\\n        while(t--){\\n            int flag = false;\\n            for(int i = 0; i<nums.size(); i++){\\n                if(nums[i]%2) ans++;\\n                nums[i]/=2;\\n                if(nums[i]!=0) flag = true;\\n            }\\n\\t\\t\\t\\n            if(!flag) break;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n********\\n********\\n\\n**The** concept has already been explained above. Below is a intuitive code using bits. Here, we check for the farthest set bit in any number. Now to make all the elements equal, we know that this farthest element has to be brought to 1 by dividing it by 2. So, we see how many divisions it will take. \\nAnd apart from this, we check how many operations of subtracting 1 will a number demand. We will only need to subtract 1 from a number when it becomes odd. To find this, we only check the number of set bits in its binary representation. Finally, our answer is number of set bits in all the numbers  + farthest set bit in all the elements. \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int count = 0, farthestSetBit = 0;\\n        for(auto u : nums){\\n            count += countSetBit(u);\\n            farthestSetBit = max(farthestSetBit,lastSetBit(u));\\n        }\\n        return count+farthestSetBit;\\n    }\\nprotected:\\n    int lastSetBit(int num){\\n        int pos = 0, i=0;\\n        while(num){\\n            if(num&1) pos = i;\\n            i++;\\n            num>>=1;\\n        }\\n        return pos;\\n    }\\n    int countSetBit(int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1) count++;\\n            num>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int t = 33;\\n        while(t--){\\n            int flag = false;\\n            for(int i = 0; i<nums.size(); i++){\\n                if(nums[i]%2) ans++;\\n                nums[i]/=2;\\n                if(nums[i]!=0) flag = true;\\n            }\\n\\t\\t\\t\\n            if(!flag) break;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int count = 0, farthestSetBit = 0;\\n        for(auto u : nums){\\n            count += countSetBit(u);\\n            farthestSetBit = max(farthestSetBit,lastSetBit(u));\\n        }\\n        return count+farthestSetBit;\\n    }\\nprotected:\\n    int lastSetBit(int num){\\n        int pos = 0, i=0;\\n        while(num){\\n            if(num&1) pos = i;\\n            i++;\\n            num>>=1;\\n        }\\n        return pos;\\n    }\\n    int countSetBit(int num){\\n        int count = 0;\\n        while(num){\\n            if(num&1) count++;\\n            num>>=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809104,
                "title": "simple-python-3-solution-less-memory-required-than-100",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        count = 0\\n        while any(nums):\\n            for i in range(len(nums)):\\n                if nums[i] % 2:\\n                    nums[i] -= 1\\n                    count += 1\\n            if any(nums):\\n                for i in range(len(nums)):\\n                    nums[i] //= 2\\n                count += 1\\n        return count\\n```\\nSimilar to [991. Broken Calculator](https://leetcode.com/problems/broken-calculator)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        count = 0\\n        while any(nums):\\n            for i in range(len(nums)):\\n                if nums[i] % 2:\\n                    nums[i] -= 1\\n                    count += 1\\n            if any(nums):\\n                for i in range(len(nums)):\\n                    nums[i] //= 2\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807150,
                "title": "simple-java-greedy",
                "content": "```\\n\\tpublic int minOperations(int[] nums) {\\n        int res = 0;\\n        boolean allZeros = false;\\n        \\n        while(!allZeros){\\n            allZeros = true;         \\n            \\n            for(int j=0;j<nums.length;j++){\\n                int mod = nums[j] % 2; // to count the odds\\n                res += mod; // op 0\\n                nums[j] /= 2; // divide by 2\\n                if(nums[j] != 0)\\n                    allZeros = false;\\n            }\\n            \\n            res++; // op 1\\n        }                \\n        return res - 1;       \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\tpublic int minOperations(int[] nums) {\\n        int res = 0;\\n        boolean allZeros = false;\\n        \\n        while(!allZeros){\\n            allZeros = true;         \\n            \\n            for(int j=0;j<nums.length;j++){\\n                int mod = nums[j] % 2; // to count the odds\\n                res += mod; // op 0\\n                nums[j] /= 2; // divide by 2\\n                if(nums[j] != 0)\\n                    allZeros = false;\\n            }\\n            \\n            res++; // op 1\\n        }                \\n        return res - 1;       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3082519,
                "title": "solution-without-bit-manipulation",
                "content": "# Intuition\\nso basically dividing the arrray by 2 untill we can when all are even and else if there is even one odd number then making it even by substracting 1 from it and increamenting answer variable.\\nand since n is less than 10 power 9 so it wont be more than 30.( write it in comments if its wrong , i am not sure )\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n   void tom(vector<int> nums,int& ans){\\n     \\n     int i;\\n     cout<<ans<<endl;\\n     int flag=0;\\n     for(i=0;i<nums.size();i++){\\n         if(nums[i]%2!=0){\\n             nums[i]=nums[i]-1;\\n             ans++;\\n         }\\n         if(nums[i]!=0){\\n             nums[i]=nums[i]/2;\\n             flag=1;\\n         }\\n     }\\n     if(flag==1){\\n         ans++;\\n     }\\n     if(flag==0){\\n         return;\\n     }\\n  tom(nums,ans);\\n  return;\\n   }\\n    int minOperations(vector<int>& nums) {\\n        int i;\\n        int n=nums.size();\\n       int ans=0;\\n\\n     tom(nums,ans);\\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n   void tom(vector<int> nums,int& ans){\\n     \\n     int i;\\n     cout<<ans<<endl;\\n     int flag=0;\\n     for(i=0;i<nums.size();i++){\\n         if(nums[i]%2!=0){\\n             nums[i]=nums[i]-1;\\n             ans++;\\n         }\\n         if(nums[i]!=0){\\n             nums[i]=nums[i]/2;\\n             flag=1;\\n         }\\n     }\\n     if(flag==1){\\n         ans++;\\n     }\\n     if(flag==0){\\n         return;\\n     }\\n  tom(nums,ans);\\n  return;\\n   }\\n    int minOperations(vector<int>& nums) {\\n        int i;\\n        int n=nums.size();\\n       int ans=0;\\n\\n     tom(nums,ans);\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2278431,
                "title": "easy-python-solution-with-90-sc",
                "content": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tans = 0\\n\\tnums.sort()\\n\\twhile(nums[-1] > 0):\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif(nums[i] % 2):\\n\\t\\t\\t\\tnums[i] -= 1\\n\\t\\t\\t\\tans += 1\\n\\t\\tif(nums[-1] > 0):\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tnums[i] //= 2\\n\\t\\t\\tans += 1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n\\tn = len(nums)\\n\\tans = 0\\n\\tnums.sort()\\n\\twhile(nums[-1] > 0):\\n\\t\\tfor i in range(n):\\n\\t\\t\\tif(nums[i] % 2):\\n\\t\\t\\t\\tnums[i] -= 1\\n\\t\\t\\t\\tans += 1\\n\\t\\tif(nums[-1] > 0):\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tnums[i] //= 2\\n\\t\\t\\tans += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1453810,
                "title": "c-easy-to-understand-think-inverse",
                "content": "# ALERT!!!!!!!\\nGO INVERSE IN QUESTION\\nMAKE ARRAY TO ZERO ARRAY AND INVERSE THE CONDITIONS\\n\\n****->firstly we go revenrse direction we make the vector nums into zero vector nums\\n->the simple approch is firstly if the element of the vector even divide it by 2 \\n->and if element of vector is odd decrease by one \\nand for both the condition inc the count++;\\n->and finally your ans is return \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int opt1=0,opt2=0;\\n        for(auto x:nums)\\n        {\\n            int temp=0;\\n            while(x>0)\\n            {\\n                if(x%2!=0){\\n                    opt1++;\\n                    x--;\\n                }\\n                else{\\n                    x=x/2;\\n                    temp++;\\n                }\\n            }\\n            opt2=max(opt2,temp);\\n        }\\n        return opt1+opt2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int opt1=0,opt2=0;\\n        for(auto x:nums)\\n        {\\n            int temp=0;\\n            while(x>0)\\n            {\\n                if(x%2!=0){\\n                    opt1++;\\n                    x--;\\n                }\\n                else{\\n                    x=x/2;\\n                    temp++;\\n                }\\n            }\\n            opt2=max(opt2,temp);\\n        }\\n        return opt1+opt2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 807358,
                "title": "python-bit-logic-explained",
                "content": "\\n```\\nCount total number of setbits in all the numbers of the given array.\\nThen shift the setbits to the desired positions=>\\nMaximum No of shifts = length(binary(max(given_array))) - 1\\nExample:\\n    given_array = [1,5] = [0b001,0b101]\\nDesired:\\n    [0b001,0b101]\\nHow it works?\\nNumbers   Binary\\n[0b000,0b000] (initial array)\\n[0b000,0b001] (setbit for one element)\\n[0b000,0b010] (leftshift for every element)\\n[0b000,0b100] (leftshift for every element)\\n[0b001,0b100] (setbit for 1st element)\\n[0b001,0b101] (setbit for 2nd element)\\n\\nSo,Total number of operations = 5\\nWe notice that every setbit operation is counted separately and is definitely\\npart of the answer.\\nSo sum(bin(a).count(\\'1\\') for a in given_array) is used to obtain total number of\\nsetbits.\\nAnd,the remaining operations are shifts.\\nleft-shifts are common as the shift applies to entire array.\\nSo,maximum number of shifts depend number of bits in maximum element of the array.\\nAnd number of shifts would be length-1.\\nSo,len(bin(max(given_array)))-1 would add up to the answer.\\nfinally we subtract 2 to eliminate the \\'0b\\' prefix that was counted\\ntowards length of binary number.\\n```\\nCODE\\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(bin(a).count(\\'1\\') for a in nums) + len(bin(max(nums))) - 2 - 1\\n```\\nInspired by \\'lee\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nCount total number of setbits in all the numbers of the given array.\\nThen shift the setbits to the desired positions=>\\nMaximum No of shifts = length(binary(max(given_array))) - 1\\nExample:\\n    given_array = [1,5] = [0b001,0b101]\\nDesired:\\n    [0b001,0b101]\\nHow it works?\\nNumbers   Binary\\n[0b000,0b000] (initial array)\\n[0b000,0b001] (setbit for one element)\\n[0b000,0b010] (leftshift for every element)\\n[0b000,0b100] (leftshift for every element)\\n[0b001,0b100] (setbit for 1st element)\\n[0b001,0b101] (setbit for 2nd element)\\n\\nSo,Total number of operations = 5\\nWe notice that every setbit operation is counted separately and is definitely\\npart of the answer.\\nSo sum(bin(a).count(\\'1\\') for a in given_array) is used to obtain total number of\\nsetbits.\\nAnd,the remaining operations are shifts.\\nleft-shifts are common as the shift applies to entire array.\\nSo,maximum number of shifts depend number of bits in maximum element of the array.\\nAnd number of shifts would be length-1.\\nSo,len(bin(max(given_array)))-1 would add up to the answer.\\nfinally we subtract 2 to eliminate the \\'0b\\' prefix that was counted\\ntowards length of binary number.\\n```\n```python\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(bin(a).count(\\'1\\') for a in nums) + len(bin(max(nums))) - 2 - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806358,
                "title": "java-bitwise-6ms-solution",
                "content": "```java\\npublic int minOperations(int[] nums) {\\n  int mul = 0, inc = 0;\\n  for (int n : nums) {\\n    for (int hiBitPos = 0; n != 0; n >>= 1) {\\n      inc += n&1;\\n      mul = Math.max(mul, ++hiBitPos);\\n    }\\n  }\\n  return mul+inc-1;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minOperations(int[] nums) {\\n  int mul = 0, inc = 0;\\n  for (int n : nums) {\\n    for (int hiBitPos = 0; n != 0; n >>= 1) {\\n      inc += n&1;\\n      mul = Math.max(mul, ++hiBitPos);\\n    }\\n  }\\n  return mul+inc-1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805819,
                "title": "c-well-commented-code-observation-video-explanation",
                "content": "https://youtu.be/ZaWdhVy45BA\\n\\n```\\n    int minOperations(vector<int>& nums) {\\n        int count =  0 , n = nums.size();\\n        while(1){\\n            int count_zero = 0 ;\\n            int i = 0 ;\\n            for(i = 0 ; i < n; i++){\\n                if(nums[i]&1) break ; //odd is encountered\\n                \\n                else if(nums[i] == 0 ) count_zero+=1;\\n            }\\n            if(count_zero  == n) return count;\\n            \\n            // if all even elements\\n            if(i == n ){\\n                //divide all \\n                count+=1; // one move added\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n            //make all odd numbers even by sub 1 \\n            for(int i = 0 ; i < n ; i++){\\n                if(nums[i]&1){\\n                    count+=1;\\n                    nums[i]-=1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int minOperations(vector<int>& nums) {\\n        int count =  0 , n = nums.size();\\n        while(1){\\n            int count_zero = 0 ;\\n            int i = 0 ;\\n            for(i = 0 ; i < n; i++){\\n                if(nums[i]&1) break ; //odd is encountered\\n                \\n                else if(nums[i] == 0 ) count_zero+=1;\\n            }\\n            if(count_zero  == n) return count;\\n            \\n            // if all even elements\\n            if(i == n ){\\n                //divide all \\n                count+=1; // one move added\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n            //make all odd numbers even by sub 1 \\n            for(int i = 0 ; i < n ; i++){\\n                if(nums[i]&1){\\n                    count+=1;\\n                    nums[i]-=1;\\n                }\\n            }\\n            \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805720,
                "title": "c-short-and-sweet-greedy",
                "content": "### Intuition:\\nRecognize all the numbers in their bit form. Then observe that the optimal way of creating the desired way is as follows:\\n- use operation 1 to shift all the numbers to the left one place\\n- use operation 0 emplace \\'1\\' in the lowest bit of a certain number\\n\\n### Example:\\n- \\'101001\\': 0 --> 1 --> 10 --> 100 --> 101 --> 1010 --> 10100 --> 101000 --> 101001\\n\\n### Strategy:\\nSo the largest numbers must get their first \\'1\\' before the smaller numbers.\\nLooking at it from a high-level perspective, we need to use operation 0 to handle all of the 1\\'s in all the numbers (`res+=hammingDistance(num);`), and we must shift (operation 1) the largest number as many times as necessary to get its highest set bit in the right place.\\n\\n```\\nclass Solution {\\npublic:\\n  int minOperations(vector<int>& nums) {\\n    int n=nums.size(),res=0,best=0;\\n    for(int num:nums){\\n      res+= hammingDistance(num);\\n      int high= num==0? 0:(int)(log2(num));  // index of the highest set bit\\n      best= max(best,high);\\n    }\\n    return res+best;\\n  }\\n  int hammingDistance(int x) {  // count #ones\\n    int count = 0;\\n    for (int i = 0; i < 32; i++)\\n      if (x & (1 << i)) count++;\\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int minOperations(vector<int>& nums) {\\n    int n=nums.size(),res=0,best=0;\\n    for(int num:nums){\\n      res+= hammingDistance(num);\\n      int high= num==0? 0:(int)(log2(num));  // index of the highest set bit\\n      best= max(best,high);\\n    }\\n    return res+best;\\n  }\\n  int hammingDistance(int x) {  // count #ones\\n    int count = 0;\\n    for (int i = 0; i < 32; i++)\\n      if (x & (1 << i)) count++;\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172739,
                "title": "c-simple-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0,x= 0,y=0;\\n        for(auto i: nums){\\n            x = 0;\\n            while(i){\\n                x++;\\n                if(i&1)y++;\\n                i >>= 1;\\n            }\\n            // cout<<x<<\" \"<<y<<endl;\\n            ans = max(ans,x-1);\\n        }\\n        return ans+y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0,x= 0,y=0;\\n        for(auto i: nums){\\n            x = 0;\\n            while(i){\\n                x++;\\n                if(i&1)y++;\\n                i >>= 1;\\n            }\\n            // cout<<x<<\" \"<<y<<endl;\\n            ans = max(ans,x-1);\\n        }\\n        return ans+y;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795593,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res=0;\\n        int n=nums.size();\\n\\t\\t//Work backwards i.e.  go from nums to arr\\n        while(1){\\n            int count=0,countzero=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1; // decrease the odd number by one \\n                    res++;\\n                }else{\\n                    count++;  // count the even numbers in array \\n                } \\n                if(nums[i]==0){\\n                    countzero++; // count the zeros in array \\n                }\\n            }\\n\\t\\t\\t// if count of zeros is equal to length of array means that array come at intial condition i.e. [0,0....] thus simply return res\\n            if(countzero==n){\\n                return res;\\n            }\\n\\t\\t\\t// if count of even is equal to length of array means that array contains even numbers only so divide them by 2 and increase res by 1\\n            if(count==n){\\n                res++;\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res=0;\\n        int n=nums.size();\\n\\t\\t//Work backwards i.e.  go from nums to arr\\n        while(1){\\n            int count=0,countzero=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1; // decrease the odd number by one \\n                    res++;\\n                }else{\\n                    count++;  // count the even numbers in array \\n                } \\n                if(nums[i]==0){\\n                    countzero++; // count the zeros in array \\n                }\\n            }\\n\\t\\t\\t// if count of zeros is equal to length of array means that array come at intial condition i.e. [0,0....] thus simply return res\\n            if(countzero==n){\\n                return res;\\n            }\\n\\t\\t\\t// if count of even is equal to length of array means that array contains even numbers only so divide them by 2 and increase res by 1\\n            if(count==n){\\n                res++;\\n                for(int i = 0 ; i < n ; i++) \\n                    nums[i]/=2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621906,
                "title": "java-o-n-solution",
                "content": "```\\npublic int minOperations(int[] nums) {\\n\\tint ops = 0;\\n\\n\\tfor (int bit = 0; bit < 32; bit++) {\\n\\t\\tboolean nonzero = false;\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tops += nums[i] % 2;\\n\\t\\t\\tnums[i] /= 2;\\n\\t\\t\\tnonzero |= nums[i] > 0;\\n\\t\\t}\\n\\n\\t\\tif (nonzero) ops++; else break;\\n\\t}\\n\\n\\treturn ops;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minOperations(int[] nums) {\\n\\tint ops = 0;\\n\\n\\tfor (int bit = 0; bit < 32; bit++) {\\n\\t\\tboolean nonzero = false;\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tops += nums[i] % 2;\\n\\t\\t\\tnums[i] /= 2;\\n\\t\\t\\tnonzero |= nums[i] > 0;\\n\\t\\t}\\n\\n\\t\\tif (nonzero) ops++; else break;\\n\\t}\\n\\n\\treturn ops;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862969,
                "title": "java-recursive-solution",
                "content": "If a number is odd, we must perform `operation 0` on it. Once all numbers in the array are even, we perform `operation 1`.\\n```\\npublic int minOperations(int[] nums) {\\n\\tint count = 0;\\n\\tboolean halve = false;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif ((nums[i] & 1) != 0) { // nums[i] % 2 == 1\\n\\t\\t\\tcount++;\\n\\t\\t\\t--nums[i];\\n\\t\\t}\\n\\t\\tif (nums[i] > 0) {\\n\\t\\t\\thalve = true;\\n\\t\\t\\tnums[i] >>= 1; // nums[i] /= 2\\n\\t\\t}\\n\\t}\\n\\n\\tif (halve) {\\n\\t\\tcount++;\\n\\t}\\n\\treturn count > 0 ? count + minOperations(nums) : 0;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic int minOperations(int[] nums) {\\n\\tint count = 0;\\n\\tboolean halve = false;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tif ((nums[i] & 1) != 0) { // nums[i] % 2 == 1\\n\\t\\t\\tcount++;\\n\\t\\t\\t--nums[i];\\n\\t\\t}\\n\\t\\tif (nums[i] > 0) {\\n\\t\\t\\thalve = true;\\n\\t\\t\\tnums[i] >>= 1; // nums[i] /= 2\\n\\t\\t}\\n\\t}\\n\\n\\tif (halve) {\\n\\t\\tcount++;\\n\\t}\\n\\treturn count > 0 ? count + minOperations(nums) : 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806047,
                "title": "java-short-simple",
                "content": "```\\n        int max = 0;\\n        int ans = 0;\\n        for(int n : nums){\\n            if(n == 0)continue;\\n            int div = 0;\\n            while(n != 1){\\n                if(n % 2 == 1){\\n                    ans++;\\n                    n--;\\n                }\\n                n = n/2;\\n                div++;\\n            }\\n            ans++;\\n            max = Math.max(max,div);\\n        }\\n        return ans + max;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int max = 0;\\n        int ans = 0;\\n        for(int n : nums){\\n            if(n == 0)continue;\\n            int div = 0;\\n            while(n != 1){\\n                if(n % 2 == 1){\\n                    ans++;\\n                    n--;\\n                }\\n                n = n/2;\\n                div++;\\n            }\\n            ans++;\\n            max = Math.max(max,div);\\n        }\\n        return ans + max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805774,
                "title": "python-simple-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        mul = [0 for i in range(len(nums))] #for each number of increment by 1 needed\\n        inc = [0 for i in range(len(nums))] #counts no. of multiplication by 2 needed\\n\\t\\t\\n        for i in range(len(nums)):\\n            while nums[i]!=0:\\n                if nums[i]%2 ==1:\\n                    inc[i] +=1\\n                    nums[i]-=1\\n                else:\\n                    mul[i]+=1\\n                    nums[i]//=2\\n            \\n        return max(mul)+sum(inc)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        mul = [0 for i in range(len(nums))] #for each number of increment by 1 needed\\n        inc = [0 for i in range(len(nums))] #counts no. of multiplication by 2 needed\\n\\t\\t\\n        for i in range(len(nums)):\\n            while nums[i]!=0:\\n                if nums[i]%2 ==1:\\n                    inc[i] +=1\\n                    nums[i]-=1\\n                else:\\n                    mul[i]+=1\\n                    nums[i]//=2\\n            \\n        return max(mul)+sum(inc)",
                "codeTag": "Java"
            },
            {
                "id": 805758,
                "title": "python-greedy",
                "content": "```\\nclass Solution:        \\n    def minOperations(self, nums):\\n\\n        def ops(num):\\n            plus = 0\\n            mult = 0\\n            while num:\\n                if num % 2:\\n                    plus += 1\\n                    num -= 1\\n                else:\\n                    num //= 2\\n                    mult +=1\\n            return plus, mult\\n    \\n        plus = 0\\n        mult = 0\\n        for num in nums:\\n            plus_, mult_ = ops(num)\\n            plus += plus_\\n            mult = max(mult, mult_)\\n        return plus + mult\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:        \\n    def minOperations(self, nums):\\n\\n        def ops(num):\\n            plus = 0\\n            mult = 0\\n            while num:\\n                if num % 2:\\n                    plus += 1\\n                    num -= 1\\n                else:\\n                    num //= 2\\n                    mult +=1\\n            return plus, mult\\n    \\n        plus = 0\\n        mult = 0\\n        for num in nums:\\n            plus_, mult_ = ops(num)\\n            plus += plus_\\n            mult = max(mult, mult_)\\n        return plus + mult\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805716,
                "title": "java-go-backwards",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, ans = 0;\\n        while(true) {\\n            int zeros = 0;\\n            boolean flag = false;\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] % 2 == 1) {\\n                    flag = true;\\n                    nums[i]--;\\n                    ans++;\\n                } else if(!flag && nums[i] == 0) zeros++;\\n            }\\n            if(!flag) {\\n                if(zeros == n) break;\\n                ans++;\\n                for(int i = 0; i < n; i++) nums[i] /= 2;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length, ans = 0;\\n        while(true) {\\n            int zeros = 0;\\n            boolean flag = false;\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] % 2 == 1) {\\n                    flag = true;\\n                    nums[i]--;\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 805699,
                "title": "clean-python-3-one-liner-with-counting-bits",
                "content": "Do it with reverse way.\\nOur purpose is to eliminate all tail setting bits of all numbers in every iteration.\\nOnce there are all `0` at tail of all numbers, we can perform dividing 2 on each numbers, which takes `int(math.log2(max(nums)))` steps.\\n```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(f\\'{num:b}\\'.count(\\'1\\') for num in nums) + int(math.log2(max(nums)))\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(f\\'{num:b}\\'.count(\\'1\\') for num in nums) + int(math.log2(max(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805684,
                "title": "java-bitcount",
                "content": "```\\npublic int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        long val = 2;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] >= val){\\n                val *= 2;\\n                ans ++;\\n                continue;\\n            }\\n            ans += Integer.bitCount(nums[i++]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        long val = 2;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] >= val){\\n                val *= 2;\\n                ans ++;\\n                continue;\\n            }\\n            ans += Integer.bitCount(nums[i++]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537008,
                "title": "c-easy-reverse-tracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        bool cond = true;\\n        int ans = 0;\\n        int n = nums.size();\\n        while(cond){\\n            int oddcount = 0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1;\\n                    oddcount++;\\n                }\\n            }\\n            ans+=oddcount;\\n            int zero = 0 ;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]==0)zero++;\\n                nums[i]= nums[i]/2;\\n            }\\n            if(zero==n)cond = false;\\n            if(cond){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        bool cond = true;\\n        int ans = 0;\\n        int n = nums.size();\\n        while(cond){\\n            int oddcount = 0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]%2!=0){\\n                    nums[i]-=1;\\n                    oddcount++;\\n                }\\n            }\\n            ans+=oddcount;\\n            int zero = 0 ;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]==0)zero++;\\n                nums[i]= nums[i]/2;\\n            }\\n            if(zero==n)cond = false;\\n            if(cond){\\n                ans+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465925,
                "title": "c-beats-97-commented-solution-beginners-friendly-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int opr=0;\\n  //instead of sorting u can also find max but remember you have to\\n//not again use it in for loop so use a continue condition for that\\n        sort(nums.begin(),nums.end());\\n        int c=nums[nums.size()-1];\\n//check that how much *2 required for maximum number because \\n//we can manage acc to our choice \\n        if(c == 0) opr--;\\n        while(c>1 ){\\n            if(c%2 != 0 ){\\n            opr++;\\n            c=c-1;\\n                        } \\n            c/=2;\\n            opr++;\\n        }     \\n//now do for every number for +1 operation except the largest    \\nfor(int i=nums.size()-2;i>=0;i--){\\n    if(nums[i] == 0 ) opr--;\\n    while(nums[i]>1){\\n    if(nums[i]%2 != 0 ){\\n    opr++;\\n    nums[i]-=1;\\n   } \\n    nums[i]/=2;\\n        \\n    }\\n}\\n        return opr+nums.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int opr=0;\\n  //instead of sorting u can also find max but remember you have to\\n//not again use it in for loop so use a continue condition for that\\n        sort(nums.begin(),nums.end());\\n        int c=nums[nums.size()-1];\\n//check that how much *2 required for maximum number because \\n//we can manage acc to our choice \\n        if(c == 0) opr--;\\n        while(c>1 ){\\n            if(c%2 != 0 ){\\n            opr++;\\n            c=c-1;\\n                        } \\n            c/=2;\\n            opr++;\\n        }     \\n//now do for every number for +1 operation except the largest    \\nfor(int i=nums.size()-2;i>=0;i--){\\n    if(nums[i] == 0 ) opr--;\\n    while(nums[i]>1){\\n    if(nums[i]%2 != 0 ){\\n    opr++;\\n    nums[i]-=1;\\n   } \\n    nums[i]/=2;\\n        \\n    }\\n}\\n        return opr+nums.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704618,
                "title": "c-93-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minOperations(vector<int>& A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minOperations(vector<int>& A) {\\n        int res = 0, maxLen = 1;\\n        for (int a : A) {\\n            int bits = 0;\\n            while (a > 0) {\\n                res += a & 1;\\n                bits++;\\n                a >>= 1;\\n            }\\n            maxLen = max(maxLen, bits);\\n        }\\n        return res + maxLen - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355122,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int minoperation = 0;\\n        int n=nums.size();\\n        int zerocount=0;\\n        \\n        while(zerocount !=  n) {\\n            zerocount=0;\\n            for(int indx=0; indx<n; indx++) {\\n                if(nums[indx]%2) {\\n                    minoperation++;\\n                    nums[indx]=nums[indx]-1;\\n                }\\n                \\n                if(nums[indx] != 0) nums[indx] = nums[indx]/2;\\n                else zerocount++;\\n   \\n            }\\n            if(zerocount != n) minoperation++; \\n        }\\n        \\n        \\n        return minoperation;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int minoperation = 0;\\n        int n=nums.size();\\n        int zerocount=0;\\n        \\n        while(zerocount !=  n) {\\n            zerocount=0;\\n            for(int indx=0; indx<n; indx++) {\\n                if(nums[indx]%2) {\\n                    minoperation++;\\n                    nums[indx]=nums[indx]-1;\\n                }\\n                \\n                if(nums[indx] != 0) nums[indx] = nums[indx]/2;\\n                else zerocount++;\\n   \\n            }\\n            if(zerocount != n) minoperation++; \\n        }\\n        \\n        \\n        return minoperation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278403,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        while(true){\\n            bool ef = false;\\n            for(int i=0; i<n; i++){\\n                if(nums[i]%2==0){\\n                    if(nums[i]!=0){\\n                        ef = true;\\n                        nums[i]/=2;\\n                    }\\n                }else{\\n                    res++;\\n                    nums[i]--;\\n                    if(nums[i] != 0){\\n                        nums[i] /= 2;A\\n                        ef = true;\\n                    }\\n                }\\n            }\\n            if(ef) res++;\\n            bool grZer = false;\\n            for(int i=0; i<n; i++){\\n                if(nums[i]>0){\\n                    grZer = true;\\n                }\\n            }\\n            if(!grZer) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        while(true){\\n            bool ef = false;\\n            for(int i=0; i<n; i++){\\n                if(nums[i]%2==0){\\n                    if(nums[i]!=0){\\n                        ef = true;\\n                        nums[i]/=2;\\n                    }\\n                }else{\\n                    res++;\\n                    nums[i]--;\\n                    if(nums[i] != 0){\\n                        nums[i] /= 2;A\\n                        ef = true;\\n                    }\\n                }\\n            }\\n            if(ef) res++;\\n            bool grZer = false;\\n            for(int i=0; i<n; i++){\\n                if(nums[i]>0){\\n                    grZer = true;\\n                }\\n            }\\n            if(!grZer) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165223,
                "title": "c-simple-step-by-step-explanation-greedy",
                "content": "**Approach**  :- \\n\\nIt is easy to think about how to convert nums to arr. \\n\\nWe have two operations out of which we have to choose one to convert our array to nums.\\nOperation where we multiply 2 to all elements is to be priortised over the operation where we add 1 to each element, as we need to use the minimum number of operations.\\n\\nSo, if our number in nums is greater than 1 we divide it by 2 and if this operation is done we take a note of it in *count* variable in below code. Here if our number is odd initially we increment our answer as when we divide the number it will become even as */* this operation results in nearest integer.\\n\\n \\n\\n> For example, 5/2 will result in 2.\\n\\nThen we increment our answer if this operation is done.\\n\\nIn the next step of our code, we traverse through the array and see if any number is equal to 1, we decrement it and increment our answer.\\n\\n> As each +1 operation is individual to all the elements.\\n\\nIn the last part of our code we just check if all the elements of our nums array are zero we exit the loop and return the answer, as if we have succesfully connverted nums to arr.\\n\\n        class Solution {\\n        public:\\n        int minOperations(vector<int>& nums) {\\n            int ans = 0;\\n                 \\n            while(1)\\n            {\\n                int flag = 0;\\n                int count = 0;\\n               for(auto &i:nums) \\n               {\\n                   if(i>1)\\n                   {\\n                       if(i%2) ans++;\\n                       i/=2;\\n                       count ++;\\n                   }\\n               }\\n                \\n                if(count > 0)\\n                ans++;\\n                \\n                for(auto &i:nums)\\n                {\\n                    if(i==1)\\n                    {\\n                        i--;\\n                        ans++;\\n                    }\\n                }\\n                \\n                for(auto &i:nums)\\n                {\\n                    if(!i) flag++;\\n                }\\n                \\n                if(flag == nums.size()) break;\\n                \\n            }\\n            \\n            return ans;\\n        }\\n    };  //Upvote if you found this useful.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n        public:\\n        int minOperations(vector<int>& nums) {\\n            int ans = 0;\\n                 \\n            while(1)\\n            {\\n                int flag = 0;\\n                int count = 0;\\n               for(auto &i:nums) \\n               {\\n                   if(i>1)\\n                   {\\n                       if(i%2) ans++;\\n                       i/=2;\\n                       count ++;\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 1906278,
                "title": "python3-o-n-logm-simple",
                "content": "n=len(nums)\\nm=len(bin(max(nums)))\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res=mx=0\\n        for el in nums:\\n            s=bin(el)[2:]\\n            res+=s.count(\\'1\\')\\n            mx=max(mx,len(s))\\n        return res+mx-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res=mx=0\\n        for el in nums:\\n            s=bin(el)[2:]\\n            res+=s.count(\\'1\\')\\n            mx=max(mx,len(s))\\n        return res+mx-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846923,
                "title": "greedy-approach",
                "content": "class Solution {\\npublic:\\n```\\n    int minOperations(vector<int>& nums) {\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        int count=0;\\n        int even=0;\\n        while(sum!=0)\\n        {\\n            sum=0;\\n            even=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    nums[i]--;\\n                    count++;\\n                }\\n                else if(nums[i]%2==0)\\n                    even++;\\n            }\\n            if(even==nums.size())\\n            {\\n                for(int i=0;i<nums.size();i++)\\n                {nums[i]=nums[i]/2;}\\n                count+=1;\\n            }\\n            for(int i=0;i<nums.size();i++)\\n                    sum+=nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minOperations(vector<int>& nums) {\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sum+=nums[i];\\n        int count=0;\\n        int even=0;\\n        while(sum!=0)\\n        {\\n            sum=0;\\n            even=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i]%2!=0)\\n                {\\n                    nums[i]--;\\n                    count++;\\n                }\\n                else if(nums[i]%2==0)\\n                    even++;\\n            }\\n            if(even==nums.size())\\n            {\\n                for(int i=0;i<nums.size();i++)\\n                {nums[i]=nums[i]/2;}\\n                count+=1;\\n            }\\n            for(int i=0;i<nums.size();i++)\\n                    sum+=nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790923,
                "title": "easy-solution-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vt(n,0);\\n        int ans = 0;\\n        if(n==1 && nums[0]==0){\\n            return ans;\\n        }\\n        while(nums!=vt){\\n            for(int i=0; i<n;i++){\\n                if(nums[i]%2 != 0){\\n                    nums[i]= nums[i]-1;\\n                    ans++;\\n                }\\n                nums[i] = nums[i]/2;\\n            }\\n            ans++;\\n        }\\n        return ans - 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> vt(n,0);\\n        int ans = 0;\\n        if(n==1 && nums[0]==0){\\n            return ans;\\n        }\\n        while(nums!=vt){\\n            for(int i=0; i<n;i++){\\n                if(nums[i]%2 != 0){\\n                    nums[i]= nums[i]-1;\\n                    ans++;\\n                }\\n                nums[i] = nums[i]/2;\\n            }\\n            ans++;\\n        }\\n        return ans - 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759452,
                "title": "javascript-greedy-easy-423ms",
                "content": "Main idea:  thinking change to array to all 0\\nso each round, loop the array, if odd, -1 to even, res++         odd count step\\nthen divide all element by 2 cuz now is all even, then res++   one step\\n```\\nconst minOperations = (a) => {\\n    let res = 0;\\n    while (1) {\\n        if (new Set(a).size == 1 && a[0] == 0) break;\\n        let b = [];\\n        for (const x of a) { // merge two step together\\n            if (x & 1) {\\n                b.push(x - 1 >> 1);\\n                res++;\\n            } else {\\n                b.push(x >> 1);\\n            }\\n        }\\n        res++;\\n        a = b;\\n    }\\n    return Math.max(0, res - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst minOperations = (a) => {\\n    let res = 0;\\n    while (1) {\\n        if (new Set(a).size == 1 && a[0] == 0) break;\\n        let b = [];\\n        for (const x of a) { // merge two step together\\n            if (x & 1) {\\n                b.push(x - 1 >> 1);\\n                res++;\\n            } else {\\n                b.push(x >> 1);\\n            }\\n        }\\n        res++;\\n        a = b;\\n    }\\n    return Math.max(0, res - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1682408,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int op=0;\\n        for(int i=0;i<32;i++){       \\n            boolean flag=false;\\n        for(int j=0;j<nums.length;j++){\\n            op+=nums[j]%2;\\n            nums[j]/=2;\\n            flag|=(nums[j]>0);\\n        }\\n        if(flag) op++; else break;\\n    }\\n     return op;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int op=0;\\n        for(int i=0;i<32;i++){       \\n            boolean flag=false;\\n        for(int j=0;j<nums.length;j++){\\n            op+=nums[j]%2;\\n            nums[j]/=2;\\n            flag|=(nums[j]>0);\\n        }\\n        if(flag) op++; else break;\\n    }\\n     return op;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519625,
                "title": "c-greedy-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    void minm(int n,int& sub, int& div){\\n        while(n!=0){\\n            if(n%2==1){\\n                n--;\\n                sub++;\\n            }\\n            else{\\n                n /=2;\\n                div++;\\n            }\\n        }\\n            \\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int max_div=0;\\n         for(int n: nums){\\n             int sub=0, div=0;\\n             minm(n, sub, div);\\n             ans+= sub;\\n             max_div=max(max_div,div);\\n         }\\n        return ans+max_div;\\n    }\\n};\\n};\\n```\\n\\nRather than going from an array of zeroes to the given array, it\\'s easier to think about going from the given array to an array of zeroes.\\n\\nNow, when we inverse the question, for a number n, the fastest way to get it to zero under the inverse opertations (subtract by -1 or divide by 2 when even) is greedy, that is, if the number is odd choose op1 otherwise op2. Note: We can\\'t simply divide by when a number is odd as that wouldn\\'t be possible under the OG operations.\\n\\nNow find the min. of such substractions and division operations for all the numbers of the given array. As the division operations are performed throughout, and doing more of them wouldn\\'t be an issue(dividing 0 by anything=0), we just take the max of division operations throughout and add to this the number of subtraction operations.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void minm(int n,int& sub, int& div){\\n        while(n!=0){\\n            if(n%2==1){\\n                n--;\\n                sub++;\\n            }\\n            else{\\n                n /=2;\\n                div++;\\n            }\\n        }\\n            \\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int max_div=0;\\n         for(int n: nums){\\n             int sub=0, div=0;\\n             minm(n, sub, div);\\n             ans+= sub;\\n             max_div=max(max_div,div);\\n         }\\n        return ans+max_div;\\n    }\\n};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416834,
                "title": "c-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int max_multiply=0,temp_multiply=0,count=0;\\n        \\n        for( auto val : nums )\\n        {\\n            while( val )\\n            {\\n                if( val&1 )\\n                {\\n                    count++;\\n                    val--;\\n                }\\n                else\\n                {\\n                    temp_multiply++;\\n                    val >>= 1;\\n                }\\n            }\\n            max_multiply = max(max_multiply,temp_multiply);\\n            temp_multiply=0;\\n        }\\n        return( count+max_multiply );\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int max_multiply=0,temp_multiply=0,count=0;\\n        \\n        for( auto val : nums )\\n        {\\n            while( val )\\n            {\\n                if( val&1 )\\n                {\\n                    count++;\\n                    val--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1387418,
                "title": "brute-force-java",
                "content": "I didn\\'t know it can be solved using bit counts so here is my brute force idea.\\nWe go backword , meaning we have an array and we have to transform it to array of zeros.\\nIf array has  an odd number then decrement it and increment amount of operations, otherwise if array doesn\\'t have odds it means all numbers are even then divide each element by two and add 1 to operations count, repeat these steps until the total sum won\\'t be zero\\n\\n```\\n public int minOperations(final int[] nums) {\\n        long sum = 0;//use long because sum of  some test cases overflow an int range\\n        for (final int num : nums) {\\n            sum+=num;\\n        }\\n        int operations = 0;\\n        while (sum != 0L) {\\n            boolean hasOdd = false;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] % 2 != 0) {\\n                    hasOdd = true;\\n                    nums[i]--;\\n                    operations++;\\n                    sum--;\\n                }\\n            }\\n            if (!hasOdd) {\\n                for (int i = 0; i < nums.length; i++) {\\n                    nums[i] /= 2;\\n                }\\n                operations++;\\n                sum /= 2;\\n            }\\n        }\\n        return operations;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int minOperations(final int[] nums) {\\n        long sum = 0;//use long because sum of  some test cases overflow an int range\\n        for (final int num : nums) {\\n            sum+=num;\\n        }\\n        int operations = 0;\\n        while (sum != 0L) {\\n            boolean hasOdd = false;\\n            for (int i = 0; i < nums.length; i++) {\\n                if (nums[i] % 2 != 0) {\\n                    hasOdd = true;\\n                    nums[i]--;\\n                    operations++;\\n                    sum--;\\n                }\\n            }\\n            if (!hasOdd) {\\n                for (int i = 0; i < nums.length; i++) {\\n                    nums[i] /= 2;\\n                }\\n                operations++;\\n                sum /= 2;\\n            }\\n        }\\n        return operations;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359293,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int numOp = 0;\\n        bool flag = 0;\\n        bool done = 0;\\n        \\n        while(!done){\\n            done = 1;\\n            flag = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                if(nums[i] != 0) done = 0;\\n                if(nums[i]%2) numOp++;\\n                if(!flag and nums[i] != 0) flag = 1;\\n                nums[i] = nums[i]/2;\\n            }\\n            if(flag) numOp++;\\n        }\\n        if(numOp == 0) return 0;\\n        return numOp-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int numOp = 0;\\n        bool flag = 0;\\n        bool done = 0;\\n        \\n        while(!done){\\n            done = 1;\\n            flag = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                if(nums[i] != 0) done = 0;\\n                if(nums[i]%2) numOp++;\\n                if(!flag and nums[i] != 0) flag = 1;\\n                nums[i] = nums[i]/2;\\n            }\\n            if(flag) numOp++;\\n        }\\n        if(numOp == 0) return 0;\\n        return numOp-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337405,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        x = sum(nums)\\n        count = 0\\n        while x != 0:\\n            for i in range(len(nums)):\\n                if nums[i] % 2 != 0:\\n                    count += 1\\n                    x -= 1\\n            if x != 0:\\n                for i in range(len(nums)):\\n                    if nums[i] != 0:\\n                        nums[i] //= 2\\n                        x -= nums[i]\\n                count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        x = sum(nums)\\n        count = 0\\n        while x != 0:\\n            for i in range(len(nums)):\\n                if nums[i] % 2 != 0:\\n                    count += 1\\n                    x -= 1\\n            if x != 0:\\n                for i in range(len(nums)):\\n                    if nums[i] != 0:\\n                        nums[i] //= 2\\n                        x -= nums[i]\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324592,
                "title": "c-reverse-intuition-logic",
                "content": "//Basic intuition behind solving this problem is :\\n//1. iterate through all the array elements and decrement all those index values which are odd and keep a counter for every decrement value that will give you the last step operations \\n//2. now divide all the array elements by 2 and increment the counter by 1 for this step . \\n// Now again repeat the same steps again and again till we get the maximum value in the array to be 0\\n\\n\\n    int minOperations(vector<int>& nums) {\\n        int size=nums.size();\\n        int max=INT_MIN,index=0;\\n        for(int i=0;i<size;i++){\\n            if(nums[i]>max){\\n                index=i;\\n                max=nums[i];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            if(nums[i]%2!=0){\\n                count++;\\n                nums[i]--;\\n            }\\n        }\\n        int n=nums[index];\\n        while(n!=0){\\n            for(int i=0;i<size;i++)\\n                nums[i]=nums[i]/2;\\n            count++;\\n            for(int i=0;i<size;i++){\\n                if(nums[i]%2!=0){\\n                    count++;\\n                    nums[i]--;\\n                }\\n            }\\n            n=nums[index];\\n        }\\n        return  count;\\n    }\\n    }",
                "solutionTags": [],
                "code": "//Basic intuition behind solving this problem is :\\n//1. iterate through all the array elements and decrement all those index values which are odd and keep a counter for every decrement value that will give you the last step operations \\n//2. now divide all the array elements by 2 and increment the counter by 1 for this step . \\n// Now again repeat the same steps again and again till we get the maximum value in the array to be 0\\n\\n\\n    int minOperations(vector<int>& nums) {\\n        int size=nums.size();\\n        int max=INT_MIN,index=0;\\n        for(int i=0;i<size;i++){\\n            if(nums[i]>max){\\n                index=i;\\n                max=nums[i];\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<size;i++){\\n            if(nums[i]%2!=0){\\n                count++;\\n                nums[i]--;\\n            }\\n        }\\n        int n=nums[index];\\n        while(n!=0){\\n            for(int i=0;i<size;i++)\\n                nums[i]=nums[i]/2;\\n            count++;\\n            for(int i=0;i<size;i++){\\n                if(nums[i]%2!=0){\\n                    count++;\\n                    nums[i]--;\\n                }\\n            }\\n            n=nums[index];\\n        }\\n        return  count;\\n    }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1278213,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void okk(int ele,int &one,int &two)\\n    {\\n        if(ele==0)\\n        {\\n            return ;\\n        }\\n        if(ele%2==1)\\n        {\\n            one++;\\n            ele--;\\n            okk(ele,one,two);\\n        }\\n        else \\n        {\\n            two++;\\n            ele=ele/2;\\n            okk(ele,one,two);\\n        }\\n    }\\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=0;\\n        int max_2_calls=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int one=0;\\n            int two=0;\\n            okk(nums[i],one,two);\\n            ans+=one;\\n            max_2_calls=max(max_2_calls,two);\\n        }\\n        return ans+max_2_calls;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void okk(int ele,int &one,int &two)\\n    {\\n        if(ele==0)\\n        {\\n            return ;\\n        }\\n        if(ele%2==1)\\n        {\\n            one++;\\n            ele--;\\n            okk(ele,one,two);\\n        }\\n        else \\n        {\\n            two++;\\n            ele=ele/2;\\n            okk(ele,one,two);\\n        }\\n    }\\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=0;\\n        int max_2_calls=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int one=0;\\n            int two=0;\\n            okk(nums[i],one,two);\\n            ans+=one;\\n            max_2_calls=max(max_2_calls,two);\\n        }\\n        return ans+max_2_calls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250351,
                "title": "c-easy-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        //okay instead of making arr to nums\\n        //we go backwards from nums to arr\\n        //The main goal is to calculate the number of operation 0 and operation 1\\n        \\n        int incOps=0; //denotes the number of increment operations\\n        int multiOps=0; //denotes the number of times we have multiplied the entire array by 2\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int currMultiOps=0;\\n            int x=nums[i];\\n            while(x)\\n            {\\n                //if the x is odd then it was sure that it uses increment operation\\n                if(x%2){\\n                    incOps+=1;\\n                    x--;\\n                }\\n                else {\\n                    //if x is even\\n                    //then count the number of multiOps\\n                    currMultiOps++;\\n                    x/=2;\\n                }\\n            }\\n            //the  number of times we use operation 1 to build nums from array arr is the number of times we use operation1 for the largest number in nums \\n            //since largest number has largest op1 calls so we update the maximum\\n            multiOps=max(multiOps,currMultiOps);\\n        }\\n        return incOps+multiOps;\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        //okay instead of making arr to nums\\n        //we go backwards from nums to arr\\n        //The main goal is to calculate the number of operation 0 and operation 1\\n        \\n        int incOps=0; //denotes the number of increment operations\\n        int multiOps=0; //denotes the number of times we have multiplied the entire array by 2\\n        for(int i=0;i<nums.size();++i)\\n        {\\n            int currMultiOps=0;\\n            int x=nums[i];\\n            while(x)\\n            {\\n                //if the x is odd then it was sure that it uses increment operation\\n                if(x%2){\\n                    incOps+=1;\\n                    x--;\\n                }\\n                else {\\n                    //if x is even\\n                    //then count the number of multiOps\\n                    currMultiOps++;\\n                    x/=2;\\n                }\\n            }\\n            //the  number of times we use operation 1 to build nums from array arr is the number of times we use operation1 for the largest number in nums \\n            //since largest number has largest op1 calls so we update the maximum\\n            multiOps=max(multiOps,currMultiOps);\\n        }\\n        return incOps+multiOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240639,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int op0=0,op1=0;\\n        for(auto &x:nums)\\n        {\\n            int curr=0;\\n            while(x)\\n            {\\n                if(x%2)\\n                {\\n                    op0++;\\n                    x--;\\n                }\\n                else\\n                {\\n                    x/=2;\\n                    curr++;\\n                }\\n            }\\n            op1=max(op1,curr);\\n        }\\n        return op0+op1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int op0=0,op1=0;\\n        for(auto &x:nums)\\n        {\\n            int curr=0;\\n            while(x)\\n            {\\n                if(x%2)\\n                {\\n                    op0++;\\n                    x--;\\n                }\\n                else\\n                {\\n                    x/=2;\\n                    curr++;\\n                }\\n            }\\n            op1=max(op1,curr);\\n        }\\n        return op0+op1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148055,
                "title": "c-easy-solution-beats-92",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int op1=0,op2=0;\\n        for(auto x: nums){\\n            int tempOp2 = 0;\\n            while(x>0){\\n                if(x%2==1){\\n                    op1++;\\n                    x--;\\n                } else {\\n                    x=x/2;\\n                    tempOp2++;\\n                }\\n            }\\n            op2 = max(op2,tempOp2);\\n        }\\n        return op1+op2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int op1=0,op2=0;\\n        for(auto x: nums){\\n            int tempOp2 = 0;\\n            while(x>0){\\n                if(x%2==1){\\n                    op1++;\\n                    x--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1121818,
                "title": "js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n    // val => [incCount, dblCount]\\n    const map = new Map()\\n    function getIncAndDblCount(val) {\\n        if (val === 0)  return [0, 0]\\n        if (val === 1)  return [1, 0]\\n        \\n        if (map.has(val))   return map.get(val)\\n        \\n        const half = Math.floor(val / 2)\\n        let halfResult = getIncAndDblCount(half)\\n        const [halfIncCount, halfDblCount] = halfResult\\n        \\n        let incCount = halfIncCount\\n        if (val % 2 === 1)  incCount++\\n        let dblCount = 1 + halfDblCount\\n        \\n        let result = [incCount, dblCount]\\n        map.set(val, result)\\n        return result\\n    }\\n    \\n    \\n    let incCountSum = 0, dblCountMax = 0\\n    for (const val of nums.values()) {\\n        const [incCount, dblCount] = getIncAndDblCount(val)\\n        incCountSum += incCount\\n        dblCountMax = Math.max(dblCountMax, dblCount)\\n    }\\n    \\n    \\n    let result = incCountSum + dblCountMax\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n    // val => [incCount, dblCount]\\n    const map = new Map()\\n    function getIncAndDblCount(val) {\\n        if (val === 0)  return [0, 0]\\n        if (val === 1)  return [1, 0]\\n        \\n        if (map.has(val))   return map.get(val)\\n        \\n        const half = Math.floor(val / 2)\\n        let halfResult = getIncAndDblCount(half)\\n        const [halfIncCount, halfDblCount] = halfResult\\n        \\n        let incCount = halfIncCount\\n        if (val % 2 === 1)  incCount++\\n        let dblCount = 1 + halfDblCount\\n        \\n        let result = [incCount, dblCount]\\n        map.set(val, result)\\n        return result\\n    }\\n    \\n    \\n    let incCountSum = 0, dblCountMax = 0\\n    for (const val of nums.values()) {\\n        const [incCount, dblCount] = getIncAndDblCount(val)\\n        incCountSum += incCount\\n        dblCountMax = Math.max(dblCountMax, dblCount)\\n    }\\n    \\n    \\n    let result = incCountSum + dblCountMax\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080178,
                "title": "c-o-n-solutino-using-builtin-functions",
                "content": "**Idea**: \\nThe essence of this problem is bit manipulation. We can intuitively solve this problem by simulating the whole process, but one smart way to solve it is by viewing the numbers in the array as bitset whose length == 32. \\nIn simulation process from `num` to `0`, when a number is\\n* even: that means the next step is dividing it by 2, and we can view it as `num >>= 1`. => Total operation is `31 - __builtin_clz(num)`.\\n* odd: that means the next step is subtracting it by 1, and we can view it as eliminating the rightmost `1`. => Total operation is `__builtin_popcount(num)`.\\n\\nNote that the division/mulplication will apply to all the numbers in the array(while have no effect on zeros), that operation should not be counted for every single number. So we just need to find the biggest `31 - __builtin_clz(num)`.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        int maxLen = 0;\\n        for (int& num : nums) {\\n            if (num) {  // Note: for num == 0  we should skip because __builtin function may throw error.\\n                res += __builtin_popcount(num);\\n                maxLen = max(maxLen, bits - __builtin_clz(num));\\n            }\\n        }\\n        return res + maxLen;\\n    }\\nprivate:\\n    const int bits = 31;\\n};\\n```\\n\\nTime: O(n) where n = sizeof(nums).\\n* Some people may argue the time of built-in functions to be O(# of bits). Since they are 32-bit numbers, the time should be 32*O(n) which is O(n).\\n\\nSpace: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        int maxLen = 0;\\n        for (int& num : nums) {\\n            if (num) {  // Note: for num == 0  we should skip because __builtin function may throw error.\\n                res += __builtin_popcount(num);\\n                maxLen = max(maxLen, bits - __builtin_clz(num));\\n            }\\n        }\\n        return res + maxLen;\\n    }\\nprivate:\\n    const int bits = 31;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033636,
                "title": "c-faster-than-100-00-less-than-99-65",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n     *  36ms - faster than 100.00% of C++\\n     *  25.3MB - less than 99.65% of C++\\n     */\\n    int minOperations(vector<int>& nums)\\n    {\\n        if (nums.size() == 0)\\n            return 0;\\n        \\n        int turns = 0;\\n        int nMax = INT_MIN;\\n        for (auto& n : nums)\\n        {\\n            nMax = max(n, nMax);\\n            while (n != 0)\\n            {\\n                turns += n & 1;\\n                n >>= 1;\\n            }\\n        }\\n        while (nMax > 1)\\n        {\\n            turns += 1;\\n            nMax >>= 1;\\n        }\\n        \\n        return turns;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    /*\\n     *  36ms - faster than 100.00% of C++\\n     *  25.3MB - less than 99.65% of C++\\n     */\\n    int minOperations(vector<int>& nums)\\n    {\\n        if (nums.size() == 0)\\n            return 0;\\n        \\n        int turns = 0;\\n        int nMax = INT_MIN;\\n        for (auto& n : nums)\\n        {\\n            nMax = max(n, nMax);\\n            while (n != 0)\\n            {\\n                turns += n & 1;\\n                n >>= 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 902335,
                "title": "java-4ms-beats-98",
                "content": "```\\npublic int minOperations(int[] nums) {\\n        int addCount = 0,doubleCount = 0,tmp = 0;\\n        for(int i:nums){\\n            if(i!=0) addCount++;\\n            tmp = 0;\\n            while (i>1){\\n                addCount += i&1;\\n                tmp++;\\n                i>>=1;\\n            }\\n            doubleCount = Math.max(tmp,doubleCount);\\n        }\\n        return doubleCount+addCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums) {\\n        int addCount = 0,doubleCount = 0,tmp = 0;\\n        for(int i:nums){\\n            if(i!=0) addCount++;\\n            tmp = 0;\\n            while (i>1){\\n                addCount += i&1;\\n                tmp++;\\n                i>>=1;\\n            }\\n            doubleCount = Math.max(tmp,doubleCount);\\n        }\\n        return doubleCount+addCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 897657,
                "title": "greedy-java-clean-code-good-idea-simple-explanation",
                "content": "Intuition: \\nAt each number: \\n\\t- count how many odd on the way going down from nums[i] to 0\\n\\t- count how many even on the **way going down**--> Just need to get the max of Even since this operation will be done in all number. \\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int totalOdd = 0;\\n        int maxEven = 0; \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int odd = 0;\\n            int even = 0;\\n            \\n\\t\\t\\t// **way going down**\\n            int n = nums[i];\\n            while (n > 0) {\\n                if (n%2 == 1) {\\n                    odd++;\\n                    n--;\\n                } else {\\n                    n /= 2;\\n                    even++;\\n                }\\n            }\\n            \\n            maxEven = Math.max(maxEven, even);\\n            totalOdd += odd;\\n        }\\n        \\n        return maxEven + totalOdd;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int totalOdd = 0;\\n        int maxEven = 0; \\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int odd = 0;\\n            int even = 0;\\n            \\n\\t\\t\\t// **way going down**\\n            int n = nums[i];\\n            while (n > 0) {\\n                if (n%2 == 1) {\\n                    odd++;\\n                    n--;\\n                } else {\\n                    n /= 2;\\n                    even++;\\n                }\\n            }\\n            \\n            maxEven = Math.max(maxEven, even);\\n            totalOdd += odd;\\n        }\\n        \\n        return maxEven + totalOdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887899,
                "title": "c-easy-to-understand",
                "content": "Thought process:\\nFrom given array try to convert it into array of zeros (reverse thinking)\\n1.Need to check that array is left with non -zero element or not\\n2.if it has nonzero element\\n\\t1.1 Count number of odd element and decrease its value by 1 and increase the count of \\n\\t\\tnumber of function call by number of odd element as doing decrement is counted as 1 move\\n\\t1.2 If it is even then just divide by 2 and increase count of function call by 1\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasnonzeronumber(vector<int>& nums)\\n    {\\n        for(auto c:nums)\\n        {\\n            if(c>0)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int getodds(vector<int>& nums)\\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==1)\\n            {\\n                   nums[i]--;\\n                   count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int cost=0;\\n        while(hasnonzeronumber(nums))\\n        {\\n            int oddcount=getodds(nums);\\n            if(oddcount>0)\\n            {\\n                cost+=oddcount;\\n            }\\n            else\\n            {\\n                for(int i=0;i<nums.size();i++)\\n                    nums[i]=nums[i]/2;\\n                \\n                cost++;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasnonzeronumber(vector<int>& nums)\\n    {\\n        for(auto c:nums)\\n        {\\n            if(c>0)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int getodds(vector<int>& nums)\\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==1)\\n            {\\n                   nums[i]--;\\n                   count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int cost=0;\\n        while(hasnonzeronumber(nums))\\n        {\\n            int oddcount=getodds(nums);\\n            if(oddcount>0)\\n            {\\n                cost+=oddcount;\\n            }\\n            else\\n            {\\n                for(int i=0;i<nums.size();i++)\\n                    nums[i]=nums[i]/2;\\n                \\n                cost++;\\n            }\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887655,
                "title": "easy-to-understand",
                "content": "```class Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        odd = 0\\n        mx_even = 0\\n        for i,val in enumerate(nums):\\n            even = 0\\n            while(val):\\n                if val%2==0:\\n                    while(val>0 and val%2==0):\\n                        val = val//2\\n                        even += 1\\n                else:\\n                    val -= 1\\n                    odd += 1\\n            mx_even = max(even,mx_even)\\n        return odd + mx_even",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        odd = 0\\n        mx_even = 0\\n        for i,val in enumerate(nums):\\n            even = 0\\n            while(val):\\n                if val%2==0:\\n                    while(val>0 and val%2==0):\\n                        val = val//2\\n                        even += 1\\n                else:\\n                    val -= 1\\n                    odd += 1\\n            mx_even = max(even,mx_even)\\n        return odd + mx_even",
                "codeTag": "Java"
            },
            {
                "id": 848937,
                "title": "my-java-solution-with-my-thought-process-and-initial-mistakes",
                "content": "```\\n/* My thought process:\\n\\nSo we are given an array of numbers with certain length and we need to do some operations, basically some function calls such that all the elements of that array becomes fully 0. So at first, I created a new array with fully 0 so that we can count the operations on this array to make it as nums array. So at starting we need to increment our element from 0 to 1 by incrementing and we have to increment our final result counter by 1. Now if its not 1 , I checked for even or odd and update by multiplying by 2 or incrementing by 1 with respective increment in counter. But this was not giving me the correct output when I coded it and run the code. So I decided to look on the hints and see if it can really help me. So in hint it says we can actually go from the nums array given and update it based on even or odd to get it into fully [0, 0, ..... ].\\n\\nSo correct code formation:\\n\\nOfcourse I started with a counter variable = 0, and a boolean varible to keep track that our array become fully 0 or not. So if the varible is false, then it indicates there are still elements to be 0, else all our numbers from the nums array become 0.\\nSo we can have a while stament which runs until our boolean variable become true.\\n\\nInside Loop\\n- > Lets say we are good with zero, let boolean varibale = true;\\n- > Now iteraate through the array.\\n        - We can use a trick here that we can update tje counter based on the number even or not. If even we increment by 0 else            if its odd, we increment by 1.\\n        - Now update our number in the array by dividing by 2.\\n        - Once again check whether the number == 0, if not, set back our boolean variable into false, as there are still                    elements in the array to be 0.\\n- > After exiting from the array iteration, we again increment our counter by 1 as we have to do it because we have done some opeartions on it.\\n- > We exit from the while loop only if the boolean variable is true.\\n\\nSo atlast we will be having the final result with an extra increment 1, because even after exiting from the for loop after making every element in the array 0, we again increment our counter by 1 as we can clearly see from the code. So this extra increment by 1 have to be decremented and this value is returned.\\n\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int count = 0;\\n        boolean isZero = false;\\n        while (!isZero) {\\n            isZero = true;\\n            for (int i=0; i<nums.length; i++) {\\n                int evenOrOdd = nums[i] % 2;\\n                count += evenOrOdd;\\n                nums[i] /= 2;\\n                if (nums[i] != 0)\\n                    isZero = false;\\n            }\\n            count += 1;\\n        }\\n        return count-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n/* My thought process:\\n\\nSo we are given an array of numbers with certain length and we need to do some operations, basically some function calls such that all the elements of that array becomes fully 0. So at first, I created a new array with fully 0 so that we can count the operations on this array to make it as nums array. So at starting we need to increment our element from 0 to 1 by incrementing and we have to increment our final result counter by 1. Now if its not 1 , I checked for even or odd and update by multiplying by 2 or incrementing by 1 with respective increment in counter. But this was not giving me the correct output when I coded it and run the code. So I decided to look on the hints and see if it can really help me. So in hint it says we can actually go from the nums array given and update it based on even or odd to get it into fully [0, 0, ..... ].\\n\\nSo correct code formation:\\n\\nOfcourse I started with a counter variable = 0, and a boolean varible to keep track that our array become fully 0 or not. So if the varible is false, then it indicates there are still elements to be 0, else all our numbers from the nums array become 0.\\nSo we can have a while stament which runs until our boolean variable become true.\\n\\nInside Loop\\n- > Lets say we are good with zero, let boolean varibale = true;\\n- > Now iteraate through the array.\\n        - We can use a trick here that we can update tje counter based on the number even or not. If even we increment by 0 else            if its odd, we increment by 1.\\n        - Now update our number in the array by dividing by 2.\\n        - Once again check whether the number == 0, if not, set back our boolean variable into false, as there are still                    elements in the array to be 0.\\n- > After exiting from the array iteration, we again increment our counter by 1 as we have to do it because we have done some opeartions on it.\\n- > We exit from the while loop only if the boolean variable is true.\\n\\nSo atlast we will be having the final result with an extra increment 1, because even after exiting from the for loop after making every element in the array 0, we again increment our counter by 1 as we can clearly see from the code. So this extra increment by 1 have to be decremented and this value is returned.\\n\\n*/\\n\\n\\n\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int count = 0;\\n        boolean isZero = false;\\n        while (!isZero) {\\n            isZero = true;\\n            for (int i=0; i<nums.length; i++) {\\n                int evenOrOdd = nums[i] % 2;\\n                count += evenOrOdd;\\n                nums[i] /= 2;\\n                if (nums[i] != 0)\\n                    isZero = false;\\n            }\\n            count += 1;\\n        }\\n        return count-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845704,
                "title": "c-o-n-time-o-1-space-short-count-down",
                "content": "```\\nint minOperations(vector<int>& nums) {\\n\\tint increments = 0; // how many times +1 will happen\\n\\tint div = 0; // how many times multiply by 2 happens (same as number of divisions in count down)\\n\\tfor (int x: nums) {\\n\\t\\t// count down by 1 or by division by 2\\n\\t\\tfor (int i=0; x; ++i) {\\n\\t\\t\\tif (x&1) {\\n\\t\\t\\t\\t++increments; // must increment this position \\n\\t\\t\\t}\\n\\t\\t\\tx /= 2;\\n\\t\\t\\tdiv = max(div, i); // remember max number of divisions\\n\\t\\t}            \\n\\t}\\n\\treturn increments + div;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums) {\\n\\tint increments = 0; // how many times +1 will happen\\n\\tint div = 0; // how many times multiply by 2 happens (same as number of divisions in count down)\\n\\tfor (int x: nums) {\\n\\t\\t// count down by 1 or by division by 2\\n\\t\\tfor (int i=0; x; ++i) {\\n\\t\\t\\tif (x&1) {\\n\\t\\t\\t\\t++increments; // must increment this position \\n\\t\\t\\t}\\n\\t\\t\\tx /= 2;\\n\\t\\t\\tdiv = max(div, i); // remember max number of divisions\\n\\t\\t}            \\n\\t}\\n\\treturn increments + div;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837514,
                "title": "python3-straighforward-solution-minimum-numbers-of-function-calls-to-make-target-array",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ans = 0\\n        while any(nums):\\n            ans += sum(n % 2 for n in nums)\\n            if any(n > 1 for n in nums):\\n                ans += 1\\n            for i in range(len(nums)):\\n                nums[i] //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ans = 0\\n        while any(nums):\\n            ans += sum(n % 2 for n in nums)\\n            if any(n > 1 for n in nums):\\n                ans += 1\\n            for i in range(len(nums)):\\n                nums[i] //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813727,
                "title": "java-counting-explained",
                "content": "I\\'ll be looking at this problem backwards - having the \"desired\" array how do we reach all zeroes.\\n\\nAs the division by 2 is prefered operation we should try to use it as much as possible. The problem could arise for the odd numbers - we can\\'t divide them and need to decrement it first. \\n\\nThis actualy leads to an algorithm itself - while we still have any non-zero number in the array:\\n1. Check for any odd one, decrement number and increment the count of operations\\n2. After that check if number is even, if so - divide by 2\\n\\nO(n x lg(max_of_n)) time - need to scan all array proportional to lg(max(array)) times\\nO(1) space - few vars used to store state\\n\\n```\\n    public int minOperations(int[] nums) {\\n        int countOfOpers = 0, N = nums.length;\\n        boolean anyNonZero = true;\\n\\t\\t//while we still have any not 0 element in array\\n        while (anyNonZero) {\\n            anyNonZero = false;\\n            boolean allZeroes = true;\\n            for (int i = 0; i < N; i++) {\\n                int n = nums[i];\\n\\t\\t\\t\\t//first check if this is odd element, if so - decrement it so later is can be used in division by 2 step\\n                if ((n&1) == 1) {\\n                    --nums[i];\\n                    ++countOfOpers;\\n                }\\n\\t\\t\\t\\t//this is even number > 0, it wil be involved into /2 operation\\n                if (nums[i] > 0) {\\n                    allZeroes = false;\\n                    nums[i]>>=1;\\n                }\\n                if (nums[i] > 0)\\n                    anyNonZero = true;\\n            }\\n\\t\\t\\t//divide by 2 is count as one operation, the only condition is whether all elements are already 0\\n            if (!allZeroes)\\n                ++countOfOpers;\\n        }\\n        return countOfOpers;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\n    public int minOperations(int[] nums) {\\n        int countOfOpers = 0, N = nums.length;\\n        boolean anyNonZero = true;\\n\\t\\t//while we still have any not 0 element in array\\n        while (anyNonZero) {\\n            anyNonZero = false;\\n            boolean allZeroes = true;\\n            for (int i = 0; i < N; i++) {\\n                int n = nums[i];\\n\\t\\t\\t\\t//first check if this is odd element, if so - decrement it so later is can be used in division by 2 step\\n                if ((n&1) == 1) {\\n                    --nums[i];\\n                    ++countOfOpers;\\n                }\\n\\t\\t\\t\\t//this is even number > 0, it wil be involved into /2 operation\\n                if (nums[i] > 0) {\\n                    allZeroes = false;\\n                    nums[i]>>=1;\\n                }\\n                if (nums[i] > 0)\\n                    anyNonZero = true;\\n            }\\n\\t\\t\\t//divide by 2 is count as one operation, the only condition is whether all elements are already 0\\n            if (!allZeroes)\\n                ++countOfOpers;\\n        }\\n        return countOfOpers;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 813579,
                "title": "javascript-python3-c-operation-0-1",
                "content": "**Synopsis:**\\n\\nUse deductive reasoning.  Consider the individual bits set for each value `x` in the input array `A`.  Each individual bit must have been set by **operation 0**, ie. +1, which changes the bit\\'s value from `0` to `1`.  Since **operation 1**, ie. multiply by 2, is shared simultaneously by all `x` in `A`, the accumulated amount of **operation 1** is dictated by the maximal value `x` in `A`.  By counting how many times we have to divide the maximal value `x` by two until `x <= 1` we also account for all other values less-than `x`.  This count is the exact definition of log2 (ie. [binary logarithm](https://en.wikipedia.org/wiki/Binary_logarithm)).\\n\\n---\\n\\n**Bi-Contest 33 Screenshare:** https://www.youtube.com/watch?v=Cbeoe8oX0Ek&feature=youtu.be\\n\\n**Note:** I upsolved this problem after the contest, however, as seen in the screenshare, I was a lot closer to the proper conclusion than I originally thought!\\n\\n---\\n\\n*Javascript*\\n```\\nlet bits = x => x.toString(2).split(\\'\\').filter(c => c == \\'1\\').length;\\nlet minOperations = A => _.sum(A.map(x => bits(x))) + Math.floor(Math.log2(Math.max(...A)));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        return sum([bin(x).count(\\'1\\') for x in A]) + math.floor(math.log2(max(A)))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A) {\\n        return accumulate(A.begin(), A.end(), 0, [&](auto ops, auto x) { return ops + __builtin_popcount(x); })\\n             + log2(*max_element(A.begin(), A.end()));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet bits = x => x.toString(2).split(\\'\\').filter(c => c == \\'1\\').length;\\nlet minOperations = A => _.sum(A.map(x => bits(x))) + Math.floor(Math.log2(Math.max(...A)));\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        return sum([bin(x).count(\\'1\\') for x in A]) + math.floor(math.log2(max(A)))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minOperations(VI& A) {\\n        return accumulate(A.begin(), A.end(), 0, [&](auto ops, auto x) { return ops + __builtin_popcount(x); })\\n             + log2(*max_element(A.begin(), A.end()));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809567,
                "title": "python3-greedy",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%2!=0 and nums[i]>0:\\n                count+=1\\n                nums[i]-=1\\n        if nums==[0]*len(nums):\\n            return count\\n        nums = [i//2 for i in nums]\\n        return count + self.minOperations(nums)+1\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        count = 0\\n        for i in range(len(nums)):\\n            if nums[i]%2!=0 and nums[i]>0:\\n                count+=1\\n                nums[i]-=1\\n        if nums==[0]*len(nums):\\n            return count\\n        nums = [i//2 for i in nums]\\n        return count + self.minOperations(nums)+1\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 808485,
                "title": "easy-to-understand-c-bit-manipulation-solution",
                "content": "The MSB of a number represents the maximum times 2*n operation will take place.\\nTherefore 2K operation will take place on max(MSB of all numbers).\\nThe increment operation is decided by number of ones in the binary representation of the number.\\nThe increment operation will be sum of count of 1s of all binary representation of the numbers.\\n```\\nint noOfOnes(int n){\\n\\tint count=0;\\n\\twhile (n!=0){\\n\\t\\tn = n & (n-1);\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n\\nint findMSB(int n){\\n\\treturn int(log2(n));\\n}\\n\\nint minOperations(vector<int>& nums) {\\n\\tint no_inc = 0;\\n\\tint max_mul = 0;\\n\\t// Do the binary representation of each and every number. \\n\\t// The most significant bit represents the maximum number of doubling required\\n\\t// No of ones represents the total of increment required.\\n\\t// The reason being when divide the array by 2 or subtract the target array by 1 we realise it\\'s just taking place in binary.\\n\\tfor(auto a: nums){\\n\\t\\tif(a==0)continue;\\n\\t\\tno_inc += noOfOnes(a);\\n\\t\\tmax_mul = max(max_mul, findMSB(a));\\n\\t}\\n\\tno_inc += max_mul; \\n\\treturn no_inc;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint noOfOnes(int n){\\n\\tint count=0;\\n\\twhile (n!=0){\\n\\t\\tn = n & (n-1);\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n\\nint findMSB(int n){\\n\\treturn int(log2(n));\\n}\\n\\nint minOperations(vector<int>& nums) {\\n\\tint no_inc = 0;\\n\\tint max_mul = 0;\\n\\t// Do the binary representation of each and every number. \\n\\t// The most significant bit represents the maximum number of doubling required\\n\\t// No of ones represents the total of increment required.\\n\\t// The reason being when divide the array by 2 or subtract the target array by 1 we realise it\\'s just taking place in binary.\\n\\tfor(auto a: nums){\\n\\t\\tif(a==0)continue;\\n\\t\\tno_inc += noOfOnes(a);\\n\\t\\tmax_mul = max(max_mul, findMSB(a));\\n\\t}\\n\\tno_inc += max_mul; \\n\\treturn no_inc;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807325,
                "title": "c-greedy-n-log-10-9-recursive-back-from-result-to-all-0",
                "content": "nums is the result we want. The odd number x in that must have come from x-1. And the even numbers should come from x/2. All the evens can get halved in 1 operation. Hence we get:\\n```\\n    int minOperations(std::vector<int>& nums) \\n    {\\n        // make all the odd as 1 less; => 1 ops each\\n        // divide all remaining evens by 2 => 1 operation\\n        // no such even left; return; \\n        int result = 0;\\n        bool anyNonZeroEven = false;\\n        for(auto &x : nums) {\\n            if(x%2) {++result; x -=1;}\\n            if(x)   {anyNonZeroEven = true; x/=2;}\\n        }\\n        if(!anyNonZeroEven) return result;\\n        else return result + 1 + minOperations(nums);\\n    }\\n```\\nRecursive depth should be log(10^9). Each call does N operations.",
                "solutionTags": [],
                "code": "```\\n    int minOperations(std::vector<int>& nums) \\n    {\\n        // make all the odd as 1 less; => 1 ops each\\n        // divide all remaining evens by 2 => 1 operation\\n        // no such even left; return; \\n        int result = 0;\\n        bool anyNonZeroEven = false;\\n        for(auto &x : nums) {\\n            if(x%2) {++result; x -=1;}\\n            if(x)   {anyNonZeroEven = true; x/=2;}\\n        }\\n        if(!anyNonZeroEven) return result;\\n        else return result + 1 + minOperations(nums);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806603,
                "title": "java-o-n-beat-100",
                "content": "we can share all opration of 1\\n```\\npublic int minOperations(int[] nums) {\\n        int res = 0;\\n        int bitsum = 0;\\n        for(int n : nums){\\n            res += Integer.bitCount(n);\\n            bitsum |= n;\\n        }\\n        while(bitsum > 1){\\n            bitsum >>= 1;\\n            ++res;\\n        }\\n        return res;\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minOperations(int[] nums) {\\n        int res = 0;\\n        int bitsum = 0;\\n        for(int n : nums){\\n            res += Integer.bitCount(n);\\n            bitsum |= n;\\n        }\\n        while(bitsum > 1){\\n            bitsum >>= 1;\\n            ++res;\\n        }\\n        return res;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 806371,
                "title": "java-easy-solution-well-commented-67-ms-runtime-100-faster-47-3-mb-memory-100-less",
                "content": "Java Solution \\nThe goal is to find the maximum number of times we need to perform op=1.\\nFor which we calculate the maximum count of multiplication by 2 required.\\nWhen we have an odd number, oosing op=0 would be beneficial.\\n\\n**TC : O(n logm)\\nSC : O(1)**\\n\\nRuntime: 67 ms, faster than 100.00% of Java online submissions for Minimum Numbers of Function Calls to Make Target Array.\\n\\nMemory Usage: 47.3 MB, less than 100.00% of Java online submissions for Minimum Numbers of Function Calls to Make Target Array.\\n\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int res = 0;\\n        int max = Integer.MIN_VALUE; \\n        // used to store the maximum number of times we need to multiply the array by 2 \\n        for(int num : nums){\\n            int count = 0; \\n            //operations required for a particular number except multiplication by 2 or when op == 0 is chosen\\n            \\n            int two = 0; \\n            // number of times we need to multiply by 2 for a particular number or when op == 1 is chosen\\n            while(num!=0){\\n                if(num%2==1){ \\n                    // for odd number we don\\'t need to multiply by 2 instead we try making it even \\n                    count++;\\n                    num--;\\n                }else{\\n                    // for even number we to multiply the result array by 2\\n                    num/=2;\\n                    two++;\\n                }\\n            }\\n            res+=count;\\n            // adding to the result the op == 0 for a particular number\\n            max=Math.max(max,two);\\n            // storing the maximum number of times we need to multiply the array by 2\\n        }\\n        \\n        res+=max;\\n        // adding to the result the maximum number of multiplication by 2 needed\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int res = 0;\\n        int max = Integer.MIN_VALUE; \\n        // used to store the maximum number of times we need to multiply the array by 2 \\n        for(int num : nums){\\n            int count = 0; \\n            //operations required for a particular number except multiplication by 2 or when op == 0 is chosen\\n            \\n            int two = 0; \\n            // number of times we need to multiply by 2 for a particular number or when op == 1 is chosen\\n            while(num!=0){\\n                if(num%2==1){ \\n                    // for odd number we don\\'t need to multiply by 2 instead we try making it even \\n                    count++;\\n                    num--;\\n                }else{\\n                    // for even number we to multiply the result array by 2\\n                    num/=2;\\n                    two++;\\n                }\\n            }\\n            res+=count;\\n            // adding to the result the op == 0 for a particular number\\n            max=Math.max(max,two);\\n            // storing the maximum number of times we need to multiply the array by 2\\n        }\\n        \\n        res+=max;\\n        // adding to the result the maximum number of multiplication by 2 needed\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806082,
                "title": "fastest-solution-c",
                "content": "**Explanation =>**\\n\\nIf the element is an odd number, we will perform operation 0, so count that. Also if a number becomes power of 2, then number of 0 operations used is 1. Since operation 1 is shared between elements, so it will be maximum for element whose MSB(Most Significant Bit) is at maximum position. So the answer will be sum of number of operation 0 + number of operation 1.\\n```\\nclass Solution {\\npublic:\\n    void recur(int x, int &c){\\n        if(x==0){\\n            return;\\n        }\\n           if(__builtin_popcount(x)==1){\\n              c++;\\n            return;\\n        }\\n        if(x%2==1){\\n            c++;\\n        }\\n        recur(x/2,c);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int i,c=0,ans=0,maxx=0;\\n        for(i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                continue;\\n            }\\n            recur(nums[i],c);\\n            ans+=c;\\n            c=0;\\n            maxx=max(maxx,(int)log2(nums[i]));\\n        }\\n        return maxx+ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int x, int &c){\\n        if(x==0){\\n            return;\\n        }\\n           if(__builtin_popcount(x)==1){\\n              c++;\\n            return;\\n        }\\n        if(x%2==1){\\n            c++;\\n        }\\n        recur(x/2,c);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int i,c=0,ans=0,maxx=0;\\n        for(i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                continue;\\n            }\\n            recur(nums[i],c);\\n            ans+=c;\\n            c=0;\\n            maxx=max(maxx,(int)log2(nums[i]));\\n        }\\n        return maxx+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806002,
                "title": "just-a-simple-brute-force",
                "content": "Just do the opposite what the problem has said to do!\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n {static_cast<int>(nums.size())};\\n        int operations {};\\n        while (!all_of(nums.begin(), nums.end(), [](const int &x){ return x == 0; })) {\\n            if (any_of(nums.begin(), nums.end(), [](const int &x){ return x%2 == 1; })) {\\n                for (int i {}; i < n; ++i) {\\n                    if (nums.at(i)&1) {\\n                        nums.at(i)--;\\n                        ++operations;\\n                    }\\n                }\\n            }\\n            else {\\n                ++operations;\\n                for_each(nums.begin(), nums.end(), [](int &x){ x >>= 1; });\\n            }\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n {static_cast<int>(nums.size())};\\n        int operations {};\\n        while (!all_of(nums.begin(), nums.end(), [](const int &x){ return x == 0; })) {\\n            if (any_of(nums.begin(), nums.end(), [](const int &x){ return x%2 == 1; })) {\\n                for (int i {}; i < n; ++i) {\\n                    if (nums.at(i)&1) {\\n                        nums.at(i)--;\\n                        ++operations;\\n                    }\\n                }\\n            }\\n            else {\\n                ++operations;\\n                for_each(nums.begin(), nums.end(), [](int &x){ x >>= 1; });\\n            }\\n        }\\n        return operations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805942,
                "title": "java-bitcount-clean-code",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = 0;\\n        int max = 0;\\n        for (int x : nums) {\\n            max = Math.max(x, max);\\n            ans += Integer.bitCount(x);\\n        }\\n        while (max > 1) {\\n            ans++;\\n            max >>= 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ans = 0;\\n        int max = 0;\\n        for (int x : nums) {\\n            max = Math.max(x, max);\\n            ans += Integer.bitCount(x);\\n        }\\n        while (max > 1) {\\n            ans++;\\n            max >>= 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805900,
                "title": "easy-intuitive-approach",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int noz=0,res=0;\\n        while(1){\\n            int cc=count(nums.begin(),nums.end(),0);\\n            if(cc==n)return res-1;\\n            for(int i=0;i<n;i++){\\n            if(nums[i]%2==1)res++;\\n            }\\n            \\n            for(int i=0;i<n;i++)nums[i]/=2;\\n            res++;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int noz=0,res=0;\\n        while(1){\\n            int cc=count(nums.begin(),nums.end(),0);\\n            if(cc==n)return res-1;\\n            for(int i=0;i<n;i++){\\n            if(nums[i]%2==1)res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 805802,
                "title": "c-bit-count-o-n",
                "content": "The idea is quiet simple:\\n - each 1 in binary representation of each number means +1 operation\\n - the longest (in binary code) number can help us calculate the minimal number of *2 operations\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int count = 0, max = -1;\\n        \\n\\t\\t// Calculate amount of \\'1\\' in binary\\n        for (auto it : nums) {\\n            if (it > max)\\n                max = it;\\n            while (it > 0) {\\n                ++count;\\n                it &= it - 1;\\n            }\\n        }\\n\\t\\t// Calculate the power of 2 of max number\\n        while (max > 1) {\\n            ++count;\\n            max >>= 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int count = 0, max = -1;\\n        \\n\\t\\t// Calculate amount of \\'1\\' in binary\\n        for (auto it : nums) {\\n            if (it > max)\\n                max = it;\\n            while (it > 0) {\\n                ++count;\\n                it &= it - 1;\\n            }\\n        }\\n\\t\\t// Calculate the power of 2 of max number\\n        while (max > 1) {\\n            ++count;\\n            max >>= 1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805714,
                "title": "c-python-short-code-with-detailed-explanation-o-n-log-n",
                "content": "### Explanation:\\nThe problem asks to count the min number of operations, where an operation either increases the value of an element by 1 or multiplies all elements by 2. We will think of the problem in reverse: ie. given this array how can you get an array of all zeros if you have operations: decrease the value of an element by 1 (call this operation 1) or divide all elements by 2 (this can be done only if all elements in the array are even) (call this operation 2). Convince yourself that the number of operations needed for this modified problem are the same as the number of operations needed in the original problem.\\n\\nNow we solve this task greedily:\\nWe can only apply the operation 2 if all elements in the array are even. So we have first make all odd elements even by using operation 1 and we count the number such operations needed. Once all elements are even we simply apply operation 2. We have to keep on doing this procedure until all elements in the array are 0. We can check this by keeping track of the sum of elements in the array (maintaining this sum is easy). \\n\\nIn the code we do not actually do operation 1 because when we integer-divide (operation 2) it anyways returns the result of operation 1 and 2 done on any odd element. See the code for more details.\\n\\n### Time complexity\\n```O(n log n)``` . You can only divide by 2 log n times and between each division we do an O(n) operation to count number of odds.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int op = 0;\\n        unsigned long long sum = accumulate(nums.begin(), nums.end(), 0ll);\\n        while (sum) {\\n            int odd_ct = count_if(nums.begin(), nums.end(), [](int n){return n&1;}); // Count how many elements are odd\\n            op += odd_ct; sum -= odd_ct; // Increment number of operation and decrement sum of array by count of odds\\n            if (sum) {\\n                // Here we have an array that consists of only evens but is not all zeros\\n                // So we divide all elements by 2\\n                for (int& n : nums) n /= 2;\\n                op++; sum /= 2;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        op = 0\\n        s = sum(nums)\\n        while (s):\\n            odd_ct = len([0 for n in nums if (n & 1)])\\n            op += odd_ct\\n            s -= odd_ct\\n            if s != 0:\\n                nums = [n//2 for n in nums]\\n                op += 1\\n                s /= 2\\n        return op\\n```",
                "solutionTags": [],
                "code": "```O(n log n)```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int op = 0;\\n        unsigned long long sum = accumulate(nums.begin(), nums.end(), 0ll);\\n        while (sum) {\\n            int odd_ct = count_if(nums.begin(), nums.end(), [](int n){return n&1;}); // Count how many elements are odd\\n            op += odd_ct; sum -= odd_ct; // Increment number of operation and decrement sum of array by count of odds\\n            if (sum) {\\n                // Here we have an array that consists of only evens but is not all zeros\\n                // So we divide all elements by 2\\n                for (int& n : nums) n /= 2;\\n                op++; sum /= 2;\\n            }\\n        }\\n        return op;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        op = 0\\n        s = sum(nums)\\n        while (s):\\n            odd_ct = len([0 for n in nums if (n & 1)])\\n            op += odd_ct\\n            s -= odd_ct\\n            if s != 0:\\n                nums = [n//2 for n in nums]\\n                op += 1\\n                s /= 2\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805710,
                "title": "java-simple-recursive-solution",
                "content": "```\\n    public int minOperations(int[] nums) {\\n     int ans = 0;\\n     return helper(nums, ans);\\n    }\\n    private int helper(int[] nums, int ans) {\\n      boolean isAllZero = true;\\n      for(int i = 0; i< nums.length; i++) {\\n        if (nums[i] % 2 == 1) {\\n          ans++;\\n          nums[i]--;\\n        }\\n        if (nums[i]==0) continue;\\n        nums[i] /= 2;\\n        isAllZero = false;\\n      }\\n      if(isAllZero) {\\n        return ans;\\n      }\\n      ans++;\\n      return helper(nums, ans);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minOperations(int[] nums) {\\n     int ans = 0;\\n     return helper(nums, ans);\\n    }\\n    private int helper(int[] nums, int ans) {\\n      boolean isAllZero = true;\\n      for(int i = 0; i< nums.length; i++) {\\n        if (nums[i] % 2 == 1) {\\n          ans++;\\n          nums[i]--;\\n        }\\n        if (nums[i]==0) continue;\\n        nums[i] /= 2;\\n        isAllZero = false;\\n      }\\n      if(isAllZero) {\\n        return ans;\\n      }\\n      ans++;\\n      return helper(nums, ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805693,
                "title": "simple-java-solution-with-explaination-no-bit-manipulation",
                "content": "It is simple and easy to understand and implement to **reduce the target array to intitial array**  rather than to modify the initial array to target array.\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int result=0;\\n\\t\\t\\n\\t\\t//while loop runs untill we make all elements in arr equal to 0.\\n        while(true){\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==1)\\n            {\\n\\t\\t\\t\\tresult++;   //for every odd element, addition must have been done so 1 operation incremented\\n                nums[i]-=1; //modify the odd element  ->> even element\\n            }\\n            nums[i]/=2;   //all even elements are divited by 2.\\n        }\\n\\t\\t\\n\\t\\t//check whether all elements are reduced to 0 or not.\\n        boolean allzero=true;\\n        for(int x:nums)\\n        {\\n            if(x!=0)\\n            {\\n                allzero=false;\\n                break;\\n            }\\n        }\\n        if(allzero)\\n            return result;\\n\\t\\t//Increment the operations by 1 for the division operaion we performed above.\\n        result++;\\n         }\\n    }\\n }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int result=0;\\n\\t\\t\\n\\t\\t//while loop runs untill we make all elements in arr equal to 0.\\n        while(true){\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==1)\\n            {\\n\\t\\t\\t\\tresult++;   //for every odd element, addition must have been done so 1 operation incremented\\n                nums[i]-=1; //modify the odd element  ->> even element\\n            }\\n            nums[i]/=2;   //all even elements are divited by 2.\\n        }\\n\\t\\t\\n\\t\\t//check whether all elements are reduced to 0 or not.\\n        boolean allzero=true;\\n        for(int x:nums)\\n        {\\n            if(x!=0)\\n            {\\n                allzero=false;\\n                break;\\n            }\\n        }\\n        if(allzero)\\n            return result;\\n\\t\\t//Increment the operations by 1 for the division operaion we performed above.\\n        result++;\\n         }\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805686,
                "title": "c-one-pass-o-n-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nFor each number in `A`, we can compute the number of operations needed to `modify` it to `0`. We count `add` and `mul` separately.\\n\\nIn the final result, we need to sum the count of all the `add` operations together because we have to do them independently for each `A[i]`. But for the `mul` operation, we just need to take the maximum one.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(max(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int add = 0, mul = 0;\\n        for (int n : A) {\\n            int m = 0;\\n            while (n) {\\n                if (n % 2) ++add, --n;\\n                else ++m, n /= 2;\\n            }\\n            mul = max(mul, m);\\n        }\\n        return add + mul;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-33/problems/minimum-numbers-of-function-calls-to-make-target-array/\\n// Author: github.com/lzl124631x\\n// Time: O(Nlog(max(A)))\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int add = 0, mul = 0;\\n        for (int n : A) {\\n            int m = 0;\\n            while (n) {\\n                if (n % 2) ++add, --n;\\n                else ++m, n /= 2;\\n            }\\n            mul = max(mul, m);\\n        }\\n        return add + mul;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097724,
                "title": "minimum-number-of-function-calls-to-make-target-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(10^9))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int no_of_ones=0, maxlen=1, bits_len=0;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            bits_len=0;\\n            while(nums[i]>0)\\n            {\\n                no_of_ones += nums[i]&1;\\n                bits_len++;\\n                nums[i]>>=1;\\n            }\\n            maxlen = max(maxlen, bits_len);\\n        }\\n        return no_of_ones + maxlen - 1;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5fa3047d-cebe-45dd-8a02-f0c51b8ebfee_1695844505.0603733.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int no_of_ones=0, maxlen=1, bits_len=0;\\n        for(int i=0 ; i<nums.size() ; i++)\\n        {\\n            bits_len=0;\\n            while(nums[i]>0)\\n            {\\n                no_of_ones += nums[i]&1;\\n                bits_len++;\\n                nums[i]>>=1;\\n            }\\n            maxlen = max(maxlen, bits_len);\\n        }\\n        return no_of_ones + maxlen - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090718,
                "title": "logical-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn binary, bitstifting left by 1 (eg: `1101 << 1 = 11010`) is equivalent to multiplying a number by 2. Adding 1 is equivalent to changing the least significant bit (the rightmost digit) from 0 to 1. Since bitshifting obviously doesn\\'t increase the number of set (\\'1\\') bits, every single set bit has to be added with a +1 operation. Obviously, `n*2>=n+1` whenever `n>=1` so bitshifting is always at least as efficient if we\\'re not setting bits.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the +1 operation only affects one number at a time, we need to find the total number of set bits across every number. Since the *2 operation affects every number, we only need to find the maximum number of times any number needs to be shifted.\\n\\nMost processors (including LeetCode\\'s) have a built in count-set-bits instruction, making it easy to iterate through `nums` and get the total number of set bits across the numbers. In C/C++ the instruction is `__builtin_popcount(n)`, and most languages have something similar. While you\\'re iterating through `nums`, also keep track of the smallest value `shift` where `1<<shift < nums[i]` for every `nums[i]`. The answer will be the sum of `shift` and the total number of set bits.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minOperations(int* nums, int numsSize){\\n    int maxMSD=0;\\n    int sumPop=0;\\n    for (int i=0;i<numsSize;i++){\\n        while ((nums[i]>>maxMSD)>1){//same as ((<<maxMSD) < nums[i])\\n            maxMSD++;\\n        }\\n        sumPop+=__builtin_popcount(nums[i]);\\n    }\\n    return (maxMSD+sumPop);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(int* nums, int numsSize){\\n    int maxMSD=0;\\n    int sumPop=0;\\n    for (int i=0;i<numsSize;i++){\\n        while ((nums[i]>>maxMSD)>1){//same as ((<<maxMSD) < nums[i])\\n            maxMSD++;\\n        }\\n        sumPop+=__builtin_popcount(nums[i]);\\n    }\\n    return (maxMSD+sumPop);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046702,
                "title": "intuitive-and-efficient-swift-solution",
                "content": "# Approach\\nCount array mapping runs until all the elements are zeros, adding extra run count for uneven elements.\\n\\n# Code\\n```\\nclass Solution {\\n    func minOperations(_ nums: [Int]) -> Int {\\n        var res = 0\\n\\t    var tmp = nums\\n\\t    var modified = false\\n\\n\\t    while true {\\n\\t\\t    modified = false\\n\\n            tmp = tmp.map { num in\\n                guard num != 0 else { return num }\\n                guard num != 1 else { res += 1; return 0 }\\n\\n                modified = true\\n\\n                guard (num % 2) == 1 else { return (num / 2) }\\n\\n                res += 1 // extra run to make num even\\n\\n                return (num - 1) / 2\\n            }\\n\\n\\t\\t    guard modified else { break }\\n\\n\\t\\t    res += 1\\n\\t    }\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ nums: [Int]) -> Int {\\n        var res = 0\\n\\t    var tmp = nums\\n\\t    var modified = false\\n\\n\\t    while true {\\n\\t\\t    modified = false\\n\\n            tmp = tmp.map { num in\\n                guard num != 0 else { return num }\\n                guard num != 1 else { res += 1; return 0 }\\n\\n                modified = true\\n\\n                guard (num % 2) == 1 else { return (num / 2) }\\n\\n                res += 1 // extra run to make num even\\n\\n                return (num - 1) / 2\\n            }\\n\\n\\t\\t    guard modified else { break }\\n\\n\\t\\t    res += 1\\n\\t    }\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955074,
                "title": "easy-solution-just-trace",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int ans=0,count_1=0,count_2=0;\\n        for(auto i:nums)\\n        {\\n            count_2=0;\\n            while(i)\\n            {\\n                count_2++;\\n                if(i&1)count_1++;\\n                i/=2;\\n            }\\n            ans=max(ans,count_2-1);\\n        }\\n        return ans+count_1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int ans=0,count_1=0,count_2=0;\\n        for(auto i:nums)\\n        {\\n            count_2=0;\\n            while(i)\\n            {\\n                count_2++;\\n                if(i&1)count_1++;\\n                i/=2;\\n            }\\n            ans=max(ans,count_2-1);\\n        }\\n        return ans+count_1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935198,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minOperations = function(nums) {\\n    let maxDouble = result = 0;\\n\\n    for (let num of nums) {\\n        let double = 0;\\n\\n        while (num) {\\n            if (num % 2) {\\n                num -= 1;\\n                result += 1;\\n            } else {\\n                num /= 2;\\n                double += 1;\\n            }\\n        }\\n        maxDouble = Math.max(double, maxDouble);\\n    }\\n    return result + maxDouble;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function(nums) {\\n    let maxDouble = result = 0;\\n\\n    for (let num of nums) {\\n        let double = 0;\\n\\n        while (num) {\\n            if (num % 2) {\\n                num -= 1;\\n                result += 1;\\n            } else {\\n                num /= 2;\\n                double += 1;\\n            }\\n        }\\n        maxDouble = Math.max(double, maxDouble);\\n    }\\n    return result + maxDouble;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864179,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int ans = 0;\\n\\n    static void helper(int arr[]){\\n        int n = arr.length;\\n\\n        int sum = -1;\\n        int count = 0;\\n\\n        while(sum!=0){\\n            sum = 0;\\n            count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(arr[i]%2!=0){\\n                    count++;\\n                    arr[i] = arr[i]-1;\\n                }\\n                sum+=arr[i];\\n                arr[i] = arr[i]/2;\\n            }\\n\\n            ans = ans+count;\\n            if(sum==0) return;\\n            else ans++;\\n        }\\n    }\\n\\n    public int minOperations(int[] nums) { \\n\\n        ans = 0;\\n        helper(nums);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int ans = 0;\\n\\n    static void helper(int arr[]){\\n        int n = arr.length;\\n\\n        int sum = -1;\\n        int count = 0;\\n\\n        while(sum!=0){\\n            sum = 0;\\n            count = 0;\\n\\n            for(int i=0; i<n; i++){\\n                if(arr[i]%2!=0){\\n                    count++;\\n                    arr[i] = arr[i]-1;\\n                }\\n                sum+=arr[i];\\n                arr[i] = arr[i]/2;\\n            }\\n\\n            ans = ans+count;\\n            if(sum==0) return;\\n            else ans++;\\n        }\\n    }\\n\\n    public int minOperations(int[] nums) { \\n\\n        ans = 0;\\n        helper(nums);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861307,
                "title": "python3-9-lines-t-s-o-n-o-1-t-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRephrase the two operations: \\n```op == 0```: increment 1; i.e. set rightmost bit to 1 if it is 0\\n```op == 1```: multiply all by 2; i.e. left bitshift on all ```nums``` by 1\\n\\nThen, the minimum number of operations is equal to the minimum number of left bitshifts plus the minimum number of 1-bit in each number represented in binary.\\n\\nThe minimum number of left bitshifts can be calculated by finding the bit-length of the largest number in ```nums```; i.e. longest length number in binary. This is because we need at least ```max_length - 1``` left bitshifts to move a 1-bit to the most significant bit.\\n\\n# Example\\n\\nGiven an array ```[4, 2, 5]```, when represented in binary: ```[100, 10, 101]```\\n\\n```op == 0```: there are $$4$$ 1-bit in all the numbers (1 in ```100, 10``` each, 2 in ```101```). \\nHence we need 4 operations.\\n\\n```op == 1```: the maximum number is ```101```. \\nSince bit-length is $$3$$, at least $$2$$ left shifts needed; i.e. ```_ _ 1``` -> ```_ 1 0``` -> ```1 0 0```\\nHence we need 2 operations.\\n\\nTherefore, answer is $$4+2=6$$ operations.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n\\n        # count minimum number of left bitshifts\\n        maximum = max(nums)\\n        shifts = 0\\n        while maximum > 1:\\n            maximum >>= 1\\n            shifts += 1\\n\\n        # count minimum number of increments (1-bits)\\n        increments = 0\\n        for num in nums:\\n            increments += num.bit_count()\\n\\n        return shifts + increments\\n\\n```\\n\\nhttps://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/submissions/1011775598/",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```op == 0```\n```op == 1```\n```nums```\n```nums```\n```max_length - 1```\n```[4, 2, 5]```\n```[100, 10, 101]```\n```op == 0```\n```100, 10```\n```101```\n```op == 1```\n```101```\n```_ _ 1```\n```_ 1 0```\n```1 0 0```\n```\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n\\n        # count minimum number of left bitshifts\\n        maximum = max(nums)\\n        shifts = 0\\n        while maximum > 1:\\n            maximum >>= 1\\n            shifts += 1\\n\\n        # count minimum number of increments (1-bits)\\n        increments = 0\\n        for num in nums:\\n            increments += num.bit_count()\\n\\n        return shifts + increments\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707390,
                "title": "javascript-beats-88-o-n-log-m-no-bitwise-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe `modify` function given to us provides us two options for every single step:\\n1. increment ONE (just one) number by 1\\n2. double ALL numbers in array\\n\\nTo make matters easier, discard the array and think of matters of a single number. If we have just number, and that number is 0, and we want to use the operations above (increment or doubling) to reach a certain target number, say K, whats the quickest way to get there?\\n\\nThink of a specific example to understand better. Suppose we start at 0 and want to get to 100.\\n\\n## Multiplication is generally faster than increment\\nYou probably already know this, but multiplication by 2 is a lot faster than incrementing by 1 (unless you are at 0).\\n\\n## The operations given to us don\\'t allow overshooting or backtracking\\n\\nNow multiplication is very fast, but the two operations given to us only increase a given number. If our operations lead us to exceed number 100, then we already failed and theres no going back from that.\\n\\n## Although multiplication is faster, incrementing in the right places can be better\\n\\nFor example, if I kept doubling 1 until I got to 128, I already exceeded 100. If I stop one step before that, then I stop at 64. Now I have to increment 36 times to get to 100. Not ideal. We can do better! but how do we figure out the ideal order?\\n\\n## It is much easier to go in reverse from our target number\\n\\ninstead of starting at 0 and trying to get to 100, we can start at 100 and go in reverse! instead of doubling and incrementing 1, we halve the number and decrement by 1. Why? well, when youre going in reverse, you can reveal the ideal places for doubling by checking when you are able to divide by 2. Often times, you will not be able to divide by 2, which tells you that you should instead decrement. This way you did not have to guess if its the right time to decrement or halve. Math decided it for you!\\n\\nso, with 100, working backwards we can do:\\n100 / 2 = 50\\n50 / 2 = 25\\n25 - 1 = 24\\n24 / 2 = 12\\n12 / 2 = 6\\n6 / 2 = 3\\n3 - 1 = 2\\n2 / 2 = 1\\n1 - 1 = 0\\n\\nAnd there we have it!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nNow we know how to do this for one number, but we have an array. How do we do this?\\n\\nIt is always good to try to think in brute force terms first. We can start from the target array, and try to take all its elements to 0 using the approach above. This turns out to be a pretty good solution despite being brute forcy!\\n\\nSo, every step, we first make sure we can halve ALL the array elements. We do this by checking if any numbers are odd. If there are odd numbers, we need to decrement them first. Only after we are left with all even numbers, we halve them.  \\n\\nNow remember, the halving operation counts as just one for the entire array, but each decrement counts as an operation. We want to count each decrement, but only once for the halving.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nEvery time we check the array for decrements or halving, we are performing O(n) process to scan the entire array. In other words, this process only grows linearly with the array size, as doubling the array size only doubles this process.  \\n\\nBut we do this multiple times. The number of times we do this is tricky. We are taking numbers and trying to get them to 0 by halving and occasionally decrementing (we prefer halving).  \\n\\nWe are slowed down by the largest number in the array. It will likely take the most number of operations. Even if all other numbers reached 0, one large number can still cause additional array scans totalling O(n)\\n\\nHow many times do we do this? since we are mostly halving, this is logarithmic. In other words, the number needs to double in order for us to have to do this one extra time.\\n\\nSo in total, we are having to do O(n) operation log(m) times, where m is the largest number in the array. So in total, it is O(n.log(m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nFor the most part, we are doing this in place. O(1) space.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nfunction decrement_odd_nums(arr) {\\n    let odd_count = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i]\\n        if (num % 2 !== 0) {\\n            odd_count ++\\n            arr[i] -= 1\\n        }\\n    }\\n    return odd_count\\n}\\n\\nfunction halve_nums(arr) {\\n    is_done = true\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i]\\n        if (num !== 0) {\\n            is_done = false\\n        }\\n        arr[i] = arr[i] / 2\\n    }\\n    return is_done\\n}\\n\\nvar minOperations = function(nums) {\\n    let ops_count = 0\\n    is_done = false\\n    while (is_done === false) {\\n        let decrement_ops = decrement_odd_nums(nums)\\n        is_done = halve_nums(nums)\\n        ops_count += decrement_ops\\n        if (!is_done) {\\n            ops_count ++\\n        }\\n    }\\n    return ops_count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\n\\nfunction decrement_odd_nums(arr) {\\n    let odd_count = 0\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i]\\n        if (num % 2 !== 0) {\\n            odd_count ++\\n            arr[i] -= 1\\n        }\\n    }\\n    return odd_count\\n}\\n\\nfunction halve_nums(arr) {\\n    is_done = true\\n    for (let i = 0; i < arr.length; i++) {\\n        const num = arr[i]\\n        if (num !== 0) {\\n            is_done = false\\n        }\\n        arr[i] = arr[i] / 2\\n    }\\n    return is_done\\n}\\n\\nvar minOperations = function(nums) {\\n    let ops_count = 0\\n    is_done = false\\n    while (is_done === false) {\\n        let decrement_ops = decrement_odd_nums(nums)\\n        is_done = halve_nums(nums)\\n        ops_count += decrement_ops\\n        if (!is_done) {\\n            ops_count ++\\n        }\\n    }\\n    return ops_count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669902,
                "title": "c-nums-to-arr-approach-reverse-engg",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==0)\\n         return 0;\\n        int ans=0;\\n        while(true){\\n           // chechking if all divi by 2\\n           bool flag=false;\\n           for(int i=0;i<nums.size();i++){\\n               if(nums[i]%2==1){\\n                   flag=true;break;\\n               }\\n           }\\n           // subtract 1\\n           if(flag==true){\\n               for(int i=0;i<nums.size();i++){\\n               if(nums[i]%2==1){\\n                   nums[i]--;\\n                   ans++;\\n               }\\n              }\\n           }\\n           else{\\n               for(int i=0;i<nums.size();i++)\\n                {\\n                    nums[i]=nums[i]/2;\\n                    if(nums[i]!=0)\\n                     flag=true;\\n                }\\n                ans++;\\n                if(flag==false)\\n                 break;\\n           }\\n           flag=false;\\n           for(int i=0;i<nums.size();i++){\\n               if(nums[i]!=0)\\n                flag=true;\\n           }\\n           if(flag==false)\\n            break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==0)\\n         return 0;\\n        int ans=0;\\n        while(true){\\n           // chechking if all divi by 2\\n           bool flag=false;\\n           for(int i=0;i<nums.size();i++){\\n               if(nums[i]%2==1){\\n                   flag=true;break;\\n               }\\n           }\\n           // subtract 1\\n           if(flag==true){\\n               for(int i=0;i<nums.size();i++){\\n               if(nums[i]%2==1){\\n                   nums[i]--;\\n                   ans++;\\n               }\\n              }\\n           }\\n           else{\\n               for(int i=0;i<nums.size();i++)\\n                {\\n                    nums[i]=nums[i]/2;\\n                    if(nums[i]!=0)\\n                     flag=true;\\n                }\\n                ans++;\\n                if(flag==false)\\n                 break;\\n           }\\n           flag=false;\\n           for(int i=0;i<nums.size();i++){\\n               if(nums[i]!=0)\\n                flag=true;\\n           }\\n           if(flag==false)\\n            break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629656,
                "title": "c-bit-manipulations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf `item` to create has `1011...0101` *binary representation* we should \\n\\n- Use `+ 1` operation for each `1` within its binary representation\\n- Use `* 2` operation `log(item, 2)` times\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBit manipulations with a help of `BitOperations` and *Linq* to query `nums`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(int[] nums) =>\\n        nums.Sum(num => BitOperations.PopCount((uint)num)) + \\n        BitOperations.Log2((uint)nums.Max()); \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[] nums) =>\\n        nums.Sum(num => BitOperations.PopCount((uint)num)) + \\n        BitOperations.Log2((uint)nums.Max()); \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623207,
                "title": "add-operation-0s-and-get-the-max-use-of-operation-1-time-o-n-log-n-space-o-1",
                "content": "class Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def count_steps(val):\\n            one_count = 0\\n            two_count = 0\\n            \\n            while val > 0:\\n                if val & 1:\\n                    val -= 1\\n                    one_count += 1\\n                else:\\n                    two_count += 1\\n                    val = val >> 1\\n            \\n            return one_count, two_count\\n        \\n        max_multipliers = 0\\n        res = 0\\n        for n in nums:\\n            cur_add, cur_multiply = count_steps(n)\\n            res += cur_add\\n            max_multipliers = max(max_multipliers, cur_multiply)\\n        \\n        return res + max_multipliers\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def count_steps(val):\\n            one_count = 0\\n            two_count = 0\\n            \\n            while val > 0:\\n                if val & 1:\\n                    val -= 1\\n                    one_count += 1\\n                else:\\n                    two_count += 1\\n                    val = val >> 1\\n            \\n            return one_count, two_count\\n        \\n        max_multipliers = 0\\n        res = 0\\n        for n in nums:\\n            cur_add, cur_multiply = count_steps(n)\\n            res += cur_add\\n            max_multipliers = max(max_multipliers, cur_multiply)\\n        \\n        return res + max_multipliers\\n",
                "codeTag": "Java"
            },
            {
                "id": 3609081,
                "title": "easy-c-solution-with-builtin-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOperation 1 is just the total numbers of ones in binary representation that we have to reduce to zero.\\nOperation 2 is the max length of binary representation - 1.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryDigitCount(int n)\\n    {\\n        if(n==0) return 1;\\n        return 1 + (int)(double(log2(n)));\\n    }\\n    int minOperations(vector<int>& nums) \\n    {\\n        int op0 = 0, op1 = 0;\\n        for(int &n: nums)\\n        {\\n            op0 += __builtin_popcount(n);\\n            op1 = max(op1, binaryDigitCount(n));\\n        }\\n        return op0 + op1 - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryDigitCount(int n)\\n    {\\n        if(n==0) return 1;\\n        return 1 + (int)(double(log2(n)));\\n    }\\n    int minOperations(vector<int>& nums) \\n    {\\n        int op0 = 0, op1 = 0;\\n        for(int &n: nums)\\n        {\\n            op0 += __builtin_popcount(n);\\n            op1 = max(op1, binaryDigitCount(n));\\n        }\\n        return op0 + op1 - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585967,
                "title": "minimum-numbers-of-function-calls-to-make-target-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        addCount = 0\\n        doubleCount = 0\\n        for e in nums:\\n            if e != 0:\\n                addCount += 1\\n            elementDoubleCount = 0\\n            while e > 1:\\n                elementDoubleCount += 1\\n                addCount += e % 2\\n                e //= 2\\n            doubleCount = max(elementDoubleCount, doubleCount)\\n        return doubleCount + addCount\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        addCount = 0\\n        doubleCount = 0\\n        for e in nums:\\n            if e != 0:\\n                addCount += 1\\n            elementDoubleCount = 0\\n            while e > 1:\\n                elementDoubleCount += 1\\n                addCount += e % 2\\n                e //= 2\\n            doubleCount = max(elementDoubleCount, doubleCount)\\n        return doubleCount + addCount\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563289,
                "title": "subtracting-or-dividing-backwards",
                "content": "# Intuition\\nIt\\'s hard to me that how to determine at which step we should add 1 or multiply by two. Since the number of steps remain unchanged, starting from arr to [0 .. 0] is easier.\\n\\n# Approach\\nIf there is an odd in arr, minus one.\\nElse divide it by two.\\nRepeat the process until [0 .. 0] is obtained.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ret = 0\\n        Sum = sum(nums)\\n\\n        while Sum > 0:\\n            for i in range(len(nums)):\\n                if nums[i] % 2:\\n                    ret += 1\\n                    nums[i] -= 1\\n                    Sum -= 1\\n            \\n            if Sum > 0:\\n                ret += 1\\n                nums = [x // 2 for x in nums]\\n                Sum //= 2\\n        \\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ret = 0\\n        Sum = sum(nums)\\n\\n        while Sum > 0:\\n            for i in range(len(nums)):\\n                if nums[i] % 2:\\n                    ret += 1\\n                    nums[i] -= 1\\n                    Sum -= 1\\n            \\n            if Sum > 0:\\n                ret += 1\\n                nums = [x // 2 for x in nums]\\n                Sum //= 2\\n        \\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562648,
                "title": "3-lines-fast-linear-solution-with-c-built-ins",
                "content": "```\\nint minOperations(vector<int>& v) {\\n    int ans=31, mx=0;\\n    for (int d: v)  mx=max(d, mx), ans+=__builtin_popcount(d);\\n    return mx==0 ? 0 : ans-__builtin_clz(mx);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minOperations(vector<int>& v) {\\n    int ans=31, mx=0;\\n    for (int d: v)  mx=max(d, mx), ans+=__builtin_popcount(d);\\n    return mx==0 ? 0 : ans-__builtin_clz(mx);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557381,
                "title": "detailed-explanation-counting-bits",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst, let\\'s consider how to generate any integer using the function described in the problem. Recall how any integer is a combination of set (1) and unset (0) bits. For example, the integer `13` is represented by `0b1101`. Starting from zero, we can generate this number using a combination of multiplying by two (shift left) and adding one:\\n\\n```cpp\\n0b0    + 1 => 0b1\\n0b1    * 2 => 0b10    // Same as 0b1 << 2 (shift left)\\n0b10   + 1 => 0b11\\n0b11   * 2 => 0b110\\n0b110  * 2 => 0b1100\\n0b1100 + 1 => 0b1101\\n```\\n\\n### Notice:\\n\\n* The number of calls to add one is *exactly equal to* the number of set bits in the number. (Try this for any number; it is always the case when you use the minimum number of calls.)\\n* The number of calls to shift left is *exactly equal to* the index (from the right) of the highest-order set bit.\\n\\nGoing back to `13` (`0b1101`), it has `3` set bits and the leftmost set bit is `3` indixes away from the end of the word. That means we can generate `13` with `3 + 3 = 6` function calls.\\n\\nThe problem introduces one small detail: *all* numbers in the array are multiplied by `2` at the same time. Though this indeed introduces some extra complexity, it just means we have to be careful about how we budget when we multiply. An example is probably best. Consider `13` and `3`:\\n\\n```cpp\\n0 +1 => 1 *2 => 10 +1 => 11 *2 => 110    => 110 *2 => 1100 +1 => 1101    => 1101\\n0    => 0 *2 => 00    => 00 *2 => 000 +1 => 001 *2 => 0010    => 0010 +1 => 0011\\n```\\n\\nWe see that an easy way to deal with this is by just delaying what we add the first `1`. As a concequence of this, we only ever need to consider how many times we have to shift the largest number.\\n\\nIt should hopfully be clear now that the answer to the problem is just the total number of set bits in the number array *plus* the order of the largest number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWith the logic descibed above, answering this problem is as simple as counting the number of set bits in all the numbers, then  adding this to the index of the most significant one bit (which will be in the largest number).\\n\\n# Complexity\\n- Time complexity: $O(32 \\\\cdot n) = O(n)$, since we have to count the number of set bits (at most 32) in each number. We also need to find the maximum number, but this also takes linear time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $\\\\Theta(1)$. Unlike the problem, which implies you need to make an array to generate each number, we actually only need to get two statistics, each of which take constant space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int num_ones = 0;\\n        int max_num = nums[0];\\n\\n        // Count the total number of set bits in nums\\n        for (int& num: nums) {\\n            num_ones += numSetBits(num);\\n            max_num = max(max_num, num);\\n        }\\n\\n        return num_ones + bitsAfterFirstOne(max_num);;\\n    }\\n\\nprivate:\\n    // See https://en.wikipedia.org/wiki/Hamming_weight\\n    int numSetBits(int n) {\\n        int count;\\n        for (count = 0; n; count++)\\n            n &= n - 1;\\n        return count;\\n    }\\n\\n    int bitsAfterFirstOne(int n) {\\n        int count = 0;\\n        while (n >>= 1) count++;\\n        return count;\\n    }\\n};\\n```\\n\\nWe can also take advantage of built in functions:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int num_ones = 0;\\n        int max_num = nums[0];\\n\\n        // Count the total number of set bits in nums\\n        for (int& num: nums) {\\n            num_ones += __builtin_popcount(num); // std::popcount(num) after C++20\\n            max_num = max(max_num, num);\\n        }\\n\\n        // clz (count leading zeroes) does not work on 0\\n        if (max_num == 0) return 0;\\n\\n        // Get the index of the highest order set bit\\n        int num_zeroes = __builtin_clz(max_num);\\n        int highest_order_bit = sizeof(int) * 8 - num_zeroes;\\n\\n        return num_ones + (highest_order_bit - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\n0b0    + 1 => 0b1\\n0b1    * 2 => 0b10    // Same as 0b1 << 2 (shift left)\\n0b10   + 1 => 0b11\\n0b11   * 2 => 0b110\\n0b110  * 2 => 0b1100\\n0b1100 + 1 => 0b1101\\n```\n```cpp\\n0 +1 => 1 *2 => 10 +1 => 11 *2 => 110    => 110 *2 => 1100 +1 => 1101    => 1101\\n0    => 0 *2 => 00    => 00 *2 => 000 +1 => 001 *2 => 0010    => 0010 +1 => 0011\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int num_ones = 0;\\n        int max_num = nums[0];\\n\\n        // Count the total number of set bits in nums\\n        for (int& num: nums) {\\n            num_ones += numSetBits(num);\\n            max_num = max(max_num, num);\\n        }\\n\\n        return num_ones + bitsAfterFirstOne(max_num);;\\n    }\\n\\nprivate:\\n    // See https://en.wikipedia.org/wiki/Hamming_weight\\n    int numSetBits(int n) {\\n        int count;\\n        for (count = 0; n; count++)\\n            n &= n - 1;\\n        return count;\\n    }\\n\\n    int bitsAfterFirstOne(int n) {\\n        int count = 0;\\n        while (n >>= 1) count++;\\n        return count;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int num_ones = 0;\\n        int max_num = nums[0];\\n\\n        // Count the total number of set bits in nums\\n        for (int& num: nums) {\\n            num_ones += __builtin_popcount(num); // std::popcount(num) after C++20\\n            max_num = max(max_num, num);\\n        }\\n\\n        // clz (count leading zeroes) does not work on 0\\n        if (max_num == 0) return 0;\\n\\n        // Get the index of the highest order set bit\\n        int num_zeroes = __builtin_clz(max_num);\\n        int highest_order_bit = sizeof(int) * 8 - num_zeroes;\\n\\n        return num_ones + (highest_order_bit - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538467,
                "title": "don-t-overthink-it-s-just-simple-approach-java-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int op1=0,op2=0,operations=0;\\n        for(int n:nums){\\n            op2=0;\\n            if(n==0) continue;\\n            while(n!=1){\\n                if(n%2==1){\\n                    op1++;\\n                    n--;\\n                }\\n                n/=2;\\n                op2++;\\n\\n            }\\n            op1++;\\n            operations=Math.max(operations,op2);\\n        }\\n        return operations+op1;\\n\\n\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int op1=0,op2=0,operations=0;\\n        for(int n:nums){\\n            op2=0;\\n            if(n==0) continue;\\n            while(n!=1){\\n                if(n%2==1){\\n                    op1++;\\n                    n--;\\n                }\\n                n/=2;\\n                op2++;\\n\\n            }\\n            op1++;\\n            operations=Math.max(operations,op2);\\n        }\\n        return operations+op1;\\n\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538091,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int minOperations(int[] nums) {\\n       count = 0;\\n       call(nums);\\n       return count;\\n    }\\n\\n    void call(int[] nums){\\n        int x = 0;\\n        int sum = -1;\\n        while(sum!=0){\\n            sum=0;\\n            x=0;\\n            for(int i =0;i<nums.length;i++){\\n                if(nums[i]%2!=0){\\n                    x++;\\n                    nums[i]-=1;\\n                }\\n                sum+=nums[i];\\n                nums[i]=nums[i]/2;\\n            }\\n            count+=x;\\n            if(sum==0)\\n                return;\\n            count+=1;\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int minOperations(int[] nums) {\\n       count = 0;\\n       call(nums);\\n       return count;\\n    }\\n\\n    void call(int[] nums){\\n        int x = 0;\\n        int sum = -1;\\n        while(sum!=0){\\n            sum=0;\\n            x=0;\\n            for(int i =0;i<nums.length;i++){\\n                if(nums[i]%2!=0){\\n                    x++;\\n                    nums[i]-=1;\\n                }\\n                sum+=nums[i];\\n                nums[i]=nums[i]/2;\\n            }\\n            count+=x;\\n            if(sum==0)\\n                return;\\n            count+=1;\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537627,
                "title": "50-faster-99-memory-beats-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0,p=0,t=0;\\n        for(int x:nums){\\n            t=0;\\n            while(x>0){\\n                if(x%2==1)ans++;\\n                x/=2;\\n                t++;\\n            }\\n            t--;\\n            p=max(p,t);   \\n        }\\n        ans+=p;\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0,p=0,t=0;\\n        for(int x:nums){\\n            t=0;\\n            while(x>0){\\n                if(x%2==1)ans++;\\n                x/=2;\\n                t++;\\n            }\\n            t--;\\n            p=max(p,t);   \\n        }\\n        ans+=p;\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537277,
                "title": "simple-python-solution",
                "content": "# Intuition\\nnote: this is not an optimal solution but it was the first solution that came to my mind so you should also look at other optimal solutions \\n\\nsince we need to make both the arrays equal by using the given modify function, the function can be used to convert the array of zeroes  into the nums array we have been provided with. instead of converting the list of zeroes into the nums list i aam doing the opposite. i.e convert the nums list into a list of zeroes.\\n\\n# Approach\\nin this code i am looping through the nums list until it reaches all zeroes. now whenever i find a odd number in the nums list, i am increasing the count of operations(res) by 1 as it will require one operation for decrementing the number to make if even. \\nNow if we have an list of all even integers then we can use a single operation to divide all the numbers in nums by 2 and increment the count of operations(res) by 1 again.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res = 0\\n        arr = [0]*len(nums)\\n        while nums[:]!=arr[:]: # checking if nums==list with all zeroes\\n            allEven = True\\n            for i in range(len(nums)):\\n                if nums[i]%2 != 0:\\n                    nums[i]-=1\\n                    res+=1\\n                    allEven = False\\n            if allEven:\\n                res+=1\\n                nums[:] = [int(n/2) for n in nums]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res = 0\\n        arr = [0]*len(nums)\\n        while nums[:]!=arr[:]: # checking if nums==list with all zeroes\\n            allEven = True\\n            for i in range(len(nums)):\\n                if nums[i]%2 != 0:\\n                    nums[i]-=1\\n                    res+=1\\n                    allEven = False\\n            if allEven:\\n                res+=1\\n                nums[:] = [int(n/2) for n in nums]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536734,
                "title": "easiest-solution-to-understand",
                "content": "# Approach\\n**Try to retrieve arr from nums array.**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    int countZero = 0;\\n\\n    public int minOperations(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        while (countZero != nums.length) {\\n            countZero=0;\\n            traverse(nums);\\n        }\\n        return count;\\n    }\\n\\n    public void traverse(int[] nums) {\\n        int prevCount = count;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 != 0) {\\n                count++;\\n                nums[i]--;\\n            }\\n            if (nums[i] == 0) {\\n                countZero++;\\n            }\\n        }\\n        if (countZero!=nums.length) {\\n            for (int i = 0; i < nums.length; i++) {\\n                nums[i] = nums[i] / 2;\\n            }\\n            count++;\\n        }\\n    }\\n}\\n```\\n# Upvoting is much appreciated",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    int countZero = 0;\\n\\n    public int minOperations(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        while (countZero != nums.length) {\\n            countZero=0;\\n            traverse(nums);\\n        }\\n        return count;\\n    }\\n\\n    public void traverse(int[] nums) {\\n        int prevCount = count;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 != 0) {\\n                count++;\\n                nums[i]--;\\n            }\\n            if (nums[i] == 0) {\\n                countZero++;\\n            }\\n        }\\n        if (countZero!=nums.length) {\\n            for (int i = 0; i < nums.length; i++) {\\n                nums[i] = nums[i] / 2;\\n            }\\n            count++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411950,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minOperations(int* nums, int numsSize){\\n//  option 0 is one idx in arr (+ 1)\\n//  option 1 is all arr (* 2)\\n    if(numsSize==1&&nums[0]==0) return 0;\\n    int high_bit=-1;\\n    int one_count=0;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        one_count=__builtin_popcount(nums[i]);\\n        res+=one_count;\\n        int temp=0;\\n        while(nums[i]!=0){\\n            temp++;\\n            nums[i]>>=1;\\n        }\\n        high_bit = fmax(high_bit,temp);\\n    } \\n    return res+high_bit-1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minOperations(int* nums, int numsSize){\\n//  option 0 is one idx in arr (+ 1)\\n//  option 1 is all arr (* 2)\\n    if(numsSize==1&&nums[0]==0) return 0;\\n    int high_bit=-1;\\n    int one_count=0;\\n    int res=0;\\n    for(int i=0;i<numsSize;i++){\\n        one_count=__builtin_popcount(nums[i]);\\n        res+=one_count;\\n        int temp=0;\\n        while(nums[i]!=0){\\n            temp++;\\n            nums[i]>>=1;\\n        }\\n        high_bit = fmax(high_bit,temp);\\n    } \\n    return res+high_bit-1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3391024,
                "title": "integer-popcount",
                "content": "```ruby\\nclass Integer\\n    def popcount\\n        r, x = 0, self\\n        while x > 0\\n            r += x & 1\\n            x >>= 1\\n        end\\n        r\\n    end\\nend\\n\\ndef min_operations a\\n    (m = a.max) < 1 ? 0 : m.bit_length.pred + a.sum(&:popcount)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Integer\\n    def popcount\\n        r, x = 0, self\\n        while x > 0\\n            r += x & 1\\n            x >>= 1\\n        end\\n        r\\n    end\\nend\\n\\ndef min_operations a\\n    (m = a.max) < 1 ? 0 : m.bit_length.pred + a.sum(&:popcount)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389833,
                "title": "java-0-n-with-o-1-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getPosOfMSB(int n){\\n        int k = Integer.numberOfLeadingZeros(n);\\n        return 31-k;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n            int maxEl = nums[0],msb;\\n            int n , m , i , j,ans , localBitCnt;\\n            n = nums.length;\\n\\n            for(i=1;i<n;i++){\\n                maxEl = Math.max(maxEl, nums[i]);\\n            }\\n\\n            m = getPosOfMSB(maxEl);\\n            i=0;\\n            ans = m<0?0:m;\\n            while(i<=m){\\n              localBitCnt = 0;\\n                 for(j=0;j<n;j++){\\n                     if((nums[j] & 1<< i)!=0){\\n                         localBitCnt++;\\n                     }\\n                 }\\n                \\n                 ans+=localBitCnt;\\n                 i++;\\n            }\\n        return ans;\\n               \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getPosOfMSB(int n){\\n        int k = Integer.numberOfLeadingZeros(n);\\n        return 31-k;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n            int maxEl = nums[0],msb;\\n            int n , m , i , j,ans , localBitCnt;\\n            n = nums.length;\\n\\n            for(i=1;i<n;i++){\\n                maxEl = Math.max(maxEl, nums[i]);\\n            }\\n\\n            m = getPosOfMSB(maxEl);\\n            i=0;\\n            ans = m<0?0:m;\\n            while(i<=m){\\n              localBitCnt = 0;\\n                 for(j=0;j<n;j++){\\n                     if((nums[j] & 1<< i)!=0){\\n                         localBitCnt++;\\n                     }\\n                 }\\n                \\n                 ans+=localBitCnt;\\n                 i++;\\n            }\\n        return ans;\\n               \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367187,
                "title": "java-greedy-solutions",
                "content": "Approach 1:  Simulation TLE:\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int countZero = 0, countOps = 0;\\n        while(!allZeros(nums)) {\\n            // either decrement an element by 1 or divide everything by 2\\n            int numEven = 0;\\n            int minIndex = 0, min = Integer.MAX_VALUE;\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] % 2 == 0) {\\n                    numEven++;\\n                }\\n                if(nums[i] != 0 && nums[i] % 2 != 0 && nums[i] < min) {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if(numEven == n) {\\n                // divide everything by 2\\n                for(int j = 0; j < n; j++) {\\n                    nums[j] /= 2;\\n                }\\n                countOps++;\\n            } else {\\n                // decrease by 1\\n                nums[minIndex] -= 1;\\n                countOps++;\\n            }\\n        }\\n        \\n        return countOps;\\n    }\\n    \\n    private boolean allZeros(int[] nums) {\\n        int numZeros = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                numZeros++;\\n            }\\n        }\\n        return numZeros == nums.length;\\n    }\\n}\\n```\\n\\nApproach 2: simplified greedy (accepted)\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // backwards: either divide by 2 or subtract 1\\n        int countOps = 0;\\n        int n = nums.length;\\n        int currHalves = 0, maxHalves = -1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            currHalves = 0;\\n            int num = nums[i];\\n            while(num != 0) {\\n                if(num % 2 == 0) {\\n                    num /= 2;\\n                    currHalves++;\\n                    \\n                    if(currHalves > maxHalves) {\\n                        countOps++;\\n                        maxHalves = currHalves;\\n                    }\\n                } else {\\n                    num--;\\n                    countOps++;\\n                }\\n            }\\n        }\\n        \\n        return countOps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int countZero = 0, countOps = 0;\\n        while(!allZeros(nums)) {\\n            // either decrement an element by 1 or divide everything by 2\\n            int numEven = 0;\\n            int minIndex = 0, min = Integer.MAX_VALUE;\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] % 2 == 0) {\\n                    numEven++;\\n                }\\n                if(nums[i] != 0 && nums[i] % 2 != 0 && nums[i] < min) {\\n                    min = nums[i];\\n                    minIndex = i;\\n                }\\n            }\\n            if(numEven == n) {\\n                // divide everything by 2\\n                for(int j = 0; j < n; j++) {\\n                    nums[j] /= 2;\\n                }\\n                countOps++;\\n            } else {\\n                // decrease by 1\\n                nums[minIndex] -= 1;\\n                countOps++;\\n            }\\n        }\\n        \\n        return countOps;\\n    }\\n    \\n    private boolean allZeros(int[] nums) {\\n        int numZeros = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                numZeros++;\\n            }\\n        }\\n        return numZeros == nums.length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        // backwards: either divide by 2 or subtract 1\\n        int countOps = 0;\\n        int n = nums.length;\\n        int currHalves = 0, maxHalves = -1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            currHalves = 0;\\n            int num = nums[i];\\n            while(num != 0) {\\n                if(num % 2 == 0) {\\n                    num /= 2;\\n                    currHalves++;\\n                    \\n                    if(currHalves > maxHalves) {\\n                        countOps++;\\n                        maxHalves = currHalves;\\n                    }\\n                } else {\\n                    num--;\\n                    countOps++;\\n                }\\n            }\\n        }\\n        \\n        return countOps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350424,
                "title": "c-bit-manipulation-easy-solution",
                "content": "# Approach\\nif nums[i] is some power of 2 plus 1 then count all set bits of nums[i] and add it to your final answer but if nums[i] is some power of 2 minus 1 then count all set bits of nums[i] and increase count by 1 more and add it to final answer. While doing all this, store the max of log2(nums[i]) because that will tell how many time you used the operation of multiply by 2 and add the max to your final answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int maxi = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            continue;\\n            if(nums[i]==ceil((double)log2(nums[i]))-1)\\n            {\\n                int tmp = 0;\\n                maxi = max(maxi,(int)log2(nums[i]));\\n                while(nums[i])\\n                {\\n                    if(nums[i]&1)\\n                    tmp++;\\n                    nums[i]>>=1;\\n                }\\n                tmp++;\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n                int tmp = 0;\\n                maxi = max(maxi,(int)log2(nums[i]));\\n                while(nums[i])\\n                {\\n                    if(nums[i]&1)\\n                    tmp++;\\n                    nums[i]>>=1;\\n                }\\n                ans+=tmp;\\n            }\\n        }\\n        ans+=maxi;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int maxi = 0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            continue;\\n            if(nums[i]==ceil((double)log2(nums[i]))-1)\\n            {\\n                int tmp = 0;\\n                maxi = max(maxi,(int)log2(nums[i]));\\n                while(nums[i])\\n                {\\n                    if(nums[i]&1)\\n                    tmp++;\\n                    nums[i]>>=1;\\n                }\\n                tmp++;\\n                ans+=tmp;\\n            }\\n            else\\n            {\\n                int tmp = 0;\\n                maxi = max(maxi,(int)log2(nums[i]));\\n                while(nums[i])\\n                {\\n                    if(nums[i]&1)\\n                    tmp++;\\n                    nums[i]>>=1;\\n                }\\n                ans+=tmp;\\n            }\\n        }\\n        ans+=maxi;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304726,
                "title": "python3-greedy-clean-and-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ans=0\\n        \\n        while 1:\\n            for i,val in enumerate(nums):\\n                if val%2==1:\\n                    nums[i]-=1\\n                    ans+=1\\n            \\n            if nums==[0]*n:\\n                return ans\\n            \\n            for i in range(n):\\n                nums[i]=nums[i]//2\\n            ans+=1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ans=0\\n        \\n        while 1:\\n            for i,val in enumerate(nums):\\n                if val%2==1:\\n                    nums[i]-=1\\n                    ans+=1\\n            \\n            if nums==[0]*n:\\n                return ans\\n            \\n            for i in range(n):\\n                nums[i]=nums[i]//2\\n            ans+=1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291504,
                "title": "go-recursive-divisible-array",
                "content": "```go\\nfunc minOperations(nums []int) int {\\n    sort.Ints(nums)\\n    return findMin(nums)\\n}\\n\\nfunc findMin(nums []int) int {\\n    if nums[len(nums)-1] == 0 {\\n        return 0\\n    }\\n    prod := 0\\n    add := 0\\n    for i:=0;i<len(nums);i++ {\\n        if nums[i]%2 == 1 {\\n            nums[i] = nums[i]-1\\n            add++\\n        }\\n        if nums[i] != 0 {\\n            nums[i] = nums[i]/2\\n            if prod == 0 {\\n                prod = 1\\n            }\\n        }\\n    }\\n    return findMin(nums) + prod + add\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperations(nums []int) int {\\n    sort.Ints(nums)\\n    return findMin(nums)\\n}\\n\\nfunc findMin(nums []int) int {\\n    if nums[len(nums)-1] == 0 {\\n        return 0\\n    }\\n    prod := 0\\n    add := 0\\n    for i:=0;i<len(nums);i++ {\\n        if nums[i]%2 == 1 {\\n            nums[i] = nums[i]-1\\n            add++\\n        }\\n        if nums[i] != 0 {\\n            nums[i] = nums[i]/2\\n            if prod == 0 {\\n                prod = 1\\n            }\\n        }\\n    }\\n    return findMin(nums) + prod + add\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3278373,
                "title": "c-beats-90-math",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int odd = 0, maxNum = 0;\\n        for (int num : nums) {\\n            maxNum = max(maxNum, num);\\n            while (num) {\\n                odd += (num & 1);\\n                num >>= 1;\\n            }\\n        }\\n        return odd + (maxNum ? log2(maxNum) : 0);\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int odd = 0, maxNum = 0;\\n        for (int num : nums) {\\n            maxNum = max(maxNum, num);\\n            while (num) {\\n                odd += (num & 1);\\n                num >>= 1;\\n            }\\n        }\\n        return odd + (maxNum ? log2(maxNum) : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263412,
                "title": "c-greedy-8-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int evens = 0, odds = 0;\\n        for (auto& n : nums){\\n            int curEven = 0;\\n            while (n > 0)\\n                if (n % 2 == 1) ++odds, --n;\\n                else n /= 2, ++curEven;\\n            evens = max(evens, curEven);\\n        }\\n        return evens + odds;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int evens = 0, odds = 0;\\n        for (auto& n : nums){\\n            int curEven = 0;\\n            while (n > 0)\\n                if (n % 2 == 1) ++odds, --n;\\n                else n /= 2, ++curEven;\\n            evens = max(evens, curEven);\\n        }\\n        return evens + odds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258728,
                "title": "c",
                "content": "```\\nint checkBit(int val){\\n    int count = 0 ;\\n    while(val){\\n        if(val & 1)\\n            count++ ;\\n        val >>= 1 ;\\n    }\\n    return count ;\\n}\\nint minOperations(int* nums, int numsSize){\\n    int op1 = 0 ; \\n    int op2 = 0 ;\\n    \\n    for(int i = 0; i < numsSize; i++){\\n        op1 += checkBit(nums[i]) ;\\n        op2 = fmax(op2, log2(nums[i]) ) ;\\n    }\\n\\n    return op1 + op2 ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint checkBit(int val){\\n    int count = 0 ;\\n    while(val){\\n        if(val & 1)\\n            count++ ;\\n        val >>= 1 ;\\n    }\\n    return count ;\\n}\\nint minOperations(int* nums, int numsSize){\\n    int op1 = 0 ; \\n    int op2 = 0 ;\\n    \\n    for(int i = 0; i < numsSize; i++){\\n        op1 += checkBit(nums[i]) ;\\n        op2 = fmax(op2, log2(nums[i]) ) ;\\n    }\\n\\n    return op1 + op2 ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3255422,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int cnt=0;\\n        vector<int> target(n,0);\\n        while(nums!=target)\\n        {\\n            for(int x=0; x<n; x++)\\n            {\\n                if(nums[x]%2)\\n                {\\n                    nums[x]-=1;\\n                    cnt++;\\n                }\\n            }\\n            if(nums==target) return cnt;\\n            for(int x=0; x<n; x++)\\n            {\\n                nums[x]/=2;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int cnt=0;\\n        vector<int> target(n,0);\\n        while(nums!=target)\\n        {\\n            for(int x=0; x<n; x++)\\n            {\\n                if(nums[x]%2)\\n                {\\n                    nums[x]-=1;\\n                    cnt++;\\n                }\\n            }\\n            if(nums==target) return cnt;\\n            for(int x=0; x<n; x++)\\n            {\\n                nums[x]/=2;\\n            }\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252668,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minOperations(_ nums: [Int]) -> Int {\\n        \\n        var arr = nums\\n        var res = 0\\n\\n        while arr.contains(where: { $0 != 0 }) {\\n\\n            for i in arr.indices\\n                where arr[i] % 2 == 1 {\\n                    arr[i] -= 1\\n                    res += 1\\n                }\\n            \\n            guard arr.contains(where: { $0 > 1}) else {\\n                res += arr.reduce(0, +)\\n                break\\n            }\\n            \\n            arr = arr.map { $0 / 2 }\\n            res += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minOperations(_ nums: [Int]) -> Int {\\n        \\n        var arr = nums\\n        var res = 0\\n\\n        while arr.contains(where: { $0 != 0 }) {\\n\\n            for i in arr.indices\\n                where arr[i] % 2 == 1 {\\n                    arr[i] -= 1\\n                    res += 1\\n                }\\n            \\n            guard arr.contains(where: { $0 > 1}) else {\\n                res += arr.reduce(0, +)\\n                break\\n            }\\n            \\n            arr = arr.map { $0 / 2 }\\n            res += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248494,
                "title": "solved-without-bit-manipulation",
                "content": "# Intuition\\nProcess each number of the array. Turn them to zero step by step. If \\'division by 2\\' is used, kept track of the max division required.\\nAs \\'div by 2\\' works on the all elements of the array at the same time, the max div is added to the answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int max2 = 0;\\n        int ans = 0;\\n        for(int x:nums){\\n            int mul = 0;\\n            while(x!=0){\\n                if(x%2==0){\\n                    x=x/2;\\n                    mul++;\\n                }else{\\n                    x--;\\n                    ans++;\\n                }\\n                if(mul!=0)\\n                    max2=max(max2,mul);\\n            }\\n        }\\n        return ans+max2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int max2 = 0;\\n        int ans = 0;\\n        for(int x:nums){\\n            int mul = 0;\\n            while(x!=0){\\n                if(x%2==0){\\n                    x=x/2;\\n                    mul++;\\n                }else{\\n                    x--;\\n                    ans++;\\n                }\\n                if(mul!=0)\\n                    max2=max(max2,mul);\\n            }\\n        }\\n        return ans+max2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209642,
                "title": "fundamental-approach-bottom-up-array",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseModify(vector<int>& nums, int& out) {\\n        bool flag = false;\\n        for(auto& val: nums) {\\n            if(val%2 == 1) {\\n                val -= 1;\\n                out++;\\n            }\\n            if(val != 0) {\\n                val /= 2;\\n                flag = true;\\n            }\\n        }\\n        if(flag) \\n            out++;\\n        else\\n            return;\\n        reverseModify(nums, out);\\n        return;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int out = 0;\\n        reverseModify(nums, out);\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseModify(vector<int>& nums, int& out) {\\n        bool flag = false;\\n        for(auto& val: nums) {\\n            if(val%2 == 1) {\\n                val -= 1;\\n                out++;\\n            }\\n            if(val != 0) {\\n                val /= 2;\\n                flag = true;\\n            }\\n        }\\n        if(flag) \\n            out++;\\n        else\\n            return;\\n        reverseModify(nums, out);\\n        return;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int out = 0;\\n        reverseModify(nums, out);\\n        return out;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171210,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut max = 0;\\n        for &num in nums.iter() {\\n            let mut cv = num;\\n            let mut temp = 0;\\n            while cv > 0 {\\n                if cv % 2 == 0 {\\n                    cv /= 2;\\n                    temp += 1;\\n                } else {\\n                    cv -= 1;\\n                    result += 1;\\n                }\\n            }\\n            max = max.max(temp);\\n        }\\n\\n        result + max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut max = 0;\\n        for &num in nums.iter() {\\n            let mut cv = num;\\n            let mut temp = 0;\\n            while cv > 0 {\\n                if cv % 2 == 0 {\\n                    cv /= 2;\\n                    temp += 1;\\n                } else {\\n                    cv -= 1;\\n                    result += 1;\\n                }\\n            }\\n            max = max.max(temp);\\n        }\\n\\n        result + max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148252,
                "title": "python3-reverse-the-process-remove-and-divide",
                "content": "# Intuition\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        Process\\n        - remove odd part\\n        - divide by 2\\n        - remove odd part\\n        - ...\\n        - until all are zeros and ones\\n        \\'\\'\\'\\n\\n        ans = 0\\n        while max(nums) > 1 :\\n\\n            # add number of odd numbers\\n            ans += sum(n&1 for n in nums)\\n\\n            # add 1 for x2\\n            ans += 1\\n\\n            # divide\\n            nums = [n//2 for n in nums]\\n\\n        return ans + sum(nums) # remember to add the last part\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\'\\'\\'\\n        Process\\n        - remove odd part\\n        - divide by 2\\n        - remove odd part\\n        - ...\\n        - until all are zeros and ones\\n        \\'\\'\\'\\n\\n        ans = 0\\n        while max(nums) > 1 :\\n\\n            # add number of odd numbers\\n            ans += sum(n&1 for n in nums)\\n\\n            # add 1 for x2\\n            ans += 1\\n\\n            # divide\\n            nums = [n//2 for n in nums]\\n\\n        return ans + sum(nums) # remember to add the last part\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120019,
                "title": "c-solution-56ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to count the number of 1s in each number and the maximum length of the binary representation of the number. The idea is to add the number of 1s from each number and add the maximum length of the binary representation minus one to get the minimum number of operations required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Iterate through the array of numbers.\\n2. For each number, count the number of 1s in it and calculate the length of its binary representation. \\n3. Keep track of the maximum length of the binary representation of all the numbers.\\n4. Add the number of 1s from each number and add the maximum length of the binary representation minus one to get the minimum number of operations required.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n) where n is the number of elements in the array. We iterate through the array once and perform constant time operations for each element.\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1) as we only store a few variables.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0, max = 0;\\n        if (nums.size() == 1 && nums[0] == 0) return 0;\\n        for (int i : nums) {\\n            int c = 0;\\n            while (i) {\\n                res += i & 1;\\n                i >>= 1;\\n                c++;\\n            }\\n            max = std::max(max, c);\\n        }\\n        return res + max - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0, max = 0;\\n        if (nums.size() == 1 && nums[0] == 0) return 0;\\n        for (int i : nums) {\\n            int c = 0;\\n            while (i) {\\n                res += i & 1;\\n                i >>= 1;\\n                c++;\\n            }\\n            max = std::max(max, c);\\n        }\\n        return res + max - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078596,
                "title": "c-not-easy-to-understand-have-to-think-deeply-to-solve-this-problem-act-greedy",
                "content": "# Approach\\nBasically we are acting greedily here as we have to double as much as we can so that we can reach to the targeted number in lesser number of steps\\n\\n# Complexity\\n- Time complexity:\\nn for the outer for loop and log n for each element we are running the while loop until it is 1\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int maxallowed = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n\\n            int currmax = 0;\\n            while(nums[i]>1){\\n                if((nums[i]%2 != 0)){\\n                    ans++;\\n                    nums[i]--;\\n                }\\n\\n                else{\\n                    nums[i]/=2;\\n                    currmax++;\\n                }\\n            }\\n            \\n            if(currmax>maxallowed){\\n                maxallowed = currmax;\\n            }\\n        }\\n\\n\\n        return ans+maxallowed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int maxallowed = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n\\n            int currmax = 0;\\n            while(nums[i]>1){\\n                if((nums[i]%2 != 0)){\\n                    ans++;\\n                    nums[i]--;\\n                }\\n\\n                else{\\n                    nums[i]/=2;\\n                    currmax++;\\n                }\\n            }\\n            \\n            if(currmax>maxallowed){\\n                maxallowed = currmax;\\n            }\\n        }\\n\\n\\n        return ans+maxallowed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078595,
                "title": "c-not-easy-to-understand-have-to-think-deeply-to-solve-this-problem-act-greedy",
                "content": "# Approach\\nBasically we are acting greedily here as we have to double as much as we can so that we can reach to the targeted number in lesser number of steps\\n\\n# Complexity\\n- Time complexity:\\nn for the outer for loop and log n for each element we are running the while loop until it is 1\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int maxallowed = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n\\n            int currmax = 0;\\n            while(nums[i]>1){\\n                if((nums[i]%2 != 0)){\\n                    ans++;\\n                    nums[i]--;\\n                }\\n\\n                else{\\n                    nums[i]/=2;\\n                    currmax++;\\n                }\\n            }\\n            \\n            if(currmax>maxallowed){\\n                maxallowed = currmax;\\n            }\\n        }\\n\\n\\n        return ans+maxallowed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = 0;\\n        int maxallowed = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]){\\n                ans++;\\n            }\\n\\n            int currmax = 0;\\n            while(nums[i]>1){\\n                if((nums[i]%2 != 0)){\\n                    ans++;\\n                    nums[i]--;\\n                }\\n\\n                else{\\n                    nums[i]/=2;\\n                    currmax++;\\n                }\\n            }\\n            \\n            if(currmax>maxallowed){\\n                maxallowed = currmax;\\n            }\\n        }\\n\\n\\n        return ans+maxallowed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064183,
                "title": "c-faster-than-85-brute-force-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n      \\n      int cnt = 0;\\n      int cnt2 = 0;\\n      for(int i = 0;i<nums.size();++i)\\n      {\\n        int temp = 0;\\n        while(nums[i]>0)\\n        {\\n         \\n          if(nums[i]%2!=0)\\n          {\\n              cnt++;\\n              nums[i]--;\\n          }\\n          else if(nums[i]%2==0)\\n          {\\n              nums[i]/=2;\\n              temp++; \\n          }\\n        }\\n        cnt2 = max(cnt2,temp);\\n      }\\n\\n      return cnt+cnt2;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n      \\n      int cnt = 0;\\n      int cnt2 = 0;\\n      for(int i = 0;i<nums.size();++i)\\n      {\\n        int temp = 0;\\n        while(nums[i]>0)\\n        {\\n         \\n          if(nums[i]%2!=0)\\n          {\\n              cnt++;\\n              nums[i]--;\\n          }\\n          else if(nums[i]%2==0)\\n          {\\n              nums[i]/=2;\\n              temp++; \\n          }\\n        }\\n        cnt2 = max(cnt2,temp);\\n      }\\n\\n      return cnt+cnt2;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063984,
                "title": "c-convert-nums-into-array-clean-and-concise",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int res=0;\\n            while(nums[i]>0){\\n                if(nums[i]%2==1){\\n                    nums[i]--;\\n                    cnt++;\\n                }\\n                while(nums[i]%2==0 and nums[i]>0){\\n                    nums[i]/=2;\\n                    res++;\\n                }\\n            }\\n            maxi=max(maxi,res);\\n        }\\n        return cnt+maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int cnt=0;\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            int res=0;\\n            while(nums[i]>0){\\n                if(nums[i]%2==1){\\n                    nums[i]--;\\n                    cnt++;\\n                }\\n                while(nums[i]%2==0 and nums[i]>0){\\n                    nums[i]/=2;\\n                    res++;\\n                }\\n            }\\n            maxi=max(maxi,res);\\n        }\\n        return cnt+maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062525,
                "title": "easy-to-understand-3-different-ways-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // for even number when it is odd it will hit one operation\\n    // for other number till it goes to odd it will be always be one single operations.\\n    // Ideal would be reduce the number as much as possible by dividing by 2\\n    // hence either log2(number) highest of all will be answer + number of times it went odd\\n    \\n    // For each number, find the path from that number to 0 i.e. when even then divide by 2 and otherwise subtract one.\\n    // Number can be 0 by dividing by 2 until it\\'s highest bit set is not at position 0, hence highBitSet position is number of\\n    // of time it will be divided by 2 and any time it is odd, we just increment by 1.S\\n\\nStore the maximum power required by all numbers and just add the maximum in answer since we can this parallely for all elements.\\n    int minOperations(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        vector<vector<int>> freq(3);\\n        int maxBitSet = 1;\\n        for (auto a : nums) {\\n            int highBitSet = 0;\\n            while (a > 0) {\\n                // if odd increment by 1\\n                result += (a&1);\\n                a = a>>1;\\n                highBitSet++;\\n            }\\n            maxBitPos = max(maxBitSet,highBitSet);\\n        }\\n        return result + (maxSet-1);\\n    }\\n    \\n    // bin the frequencey of zeros(0), odds(1) and evens (2)\\n    int minOperations2(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        vector<vector<int>> freq(3);\\n        for (auto &a : nums) {\\n            if (a == 0) {\\n                freq[0].push_back(a);\\n            } else if (a%2) {\\n                freq[1].push_back(a);\\n            } else {\\n                freq[2].push_back(a);\\n            }\\n        }\\n        //Iterate till all the numbers are 0\\n        while(freq[0].size() != n) {\\n            // if any number odd then first convert it to even or zero\\n            if (freq[1].size()) {\\n                result += freq[1].size();\\n                for (auto a : freq[1]) {\\n                    a--;\\n                    if (a) \\n                        freq[2].push_back(a);\\n                    else \\n                        freq[0].push_back(a);\\n                }\\n                freq[1].clear();\\n            } else {\\n                result++;\\n                // Convert all the odds to next set of evens or odds\\n                vector<int> tmp = move(freq[2]);\\n                for (int i = 0; i < tmp.size(); i++) {\\n                    int a = tmp[i]/2;\\n                    if (a%2)\\n                        freq[1].push_back(a);\\n                    else\\n                        freq[2].push_back(a);\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n\\n\\nclass Solution1 {\\npublic:\\n    void getTypes(vector<int> &nums, int &zero, int &even, int &odd) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                zero++;\\n            } else if (nums[i]%2) {\\n                odd++;\\n            } else\\n                even++;\\n        }\\n    }\\n    void updateNums(vector<int> &nums, bool divide, int &zero, int &even, int &odd) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i]) {\\n                if (divide){\\n                    nums[i] = nums[i]/2;\\n                } else {\\n                    if (nums[i]%2)\\n                        nums[i]--;\\n                }\\n            }\\n            if (nums[i] == 0) {\\n                zero++;\\n            } else if (nums[i]%2)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        \\n    }\\n    int minOperations(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        int zero = 0; int even = 0; int odd = 0;\\n        getTypes(nums,zero,even,odd);\\n        while(zero != n) { \\n            bool allNum = false;\\n            if (zero+even == n) {\\n                result++;\\n                allNum = true;\\n            } else {\\n                result += odd;\\n            }\\n            zero = 0; even = 0; odd = 0;\\n            updateNums(nums,allNum,zero,even,odd);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // for even number when it is odd it will hit one operation\\n    // for other number till it goes to odd it will be always be one single operations.\\n    // Ideal would be reduce the number as much as possible by dividing by 2\\n    // hence either log2(number) highest of all will be answer + number of times it went odd\\n    \\n    // For each number, find the path from that number to 0 i.e. when even then divide by 2 and otherwise subtract one.\\n    // Number can be 0 by dividing by 2 until it\\'s highest bit set is not at position 0, hence highBitSet position is number of\\n    // of time it will be divided by 2 and any time it is odd, we just increment by 1.S\\n\\nStore the maximum power required by all numbers and just add the maximum in answer since we can this parallely for all elements.\\n    int minOperations(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        vector<vector<int>> freq(3);\\n        int maxBitSet = 1;\\n        for (auto a : nums) {\\n            int highBitSet = 0;\\n            while (a > 0) {\\n                // if odd increment by 1\\n                result += (a&1);\\n                a = a>>1;\\n                highBitSet++;\\n            }\\n            maxBitPos = max(maxBitSet,highBitSet);\\n        }\\n        return result + (maxSet-1);\\n    }\\n    \\n    // bin the frequencey of zeros(0), odds(1) and evens (2)\\n    int minOperations2(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        vector<vector<int>> freq(3);\\n        for (auto &a : nums) {\\n            if (a == 0) {\\n                freq[0].push_back(a);\\n            } else if (a%2) {\\n                freq[1].push_back(a);\\n            } else {\\n                freq[2].push_back(a);\\n            }\\n        }\\n        //Iterate till all the numbers are 0\\n        while(freq[0].size() != n) {\\n            // if any number odd then first convert it to even or zero\\n            if (freq[1].size()) {\\n                result += freq[1].size();\\n                for (auto a : freq[1]) {\\n                    a--;\\n                    if (a) \\n                        freq[2].push_back(a);\\n                    else \\n                        freq[0].push_back(a);\\n                }\\n                freq[1].clear();\\n            } else {\\n                result++;\\n                // Convert all the odds to next set of evens or odds\\n                vector<int> tmp = move(freq[2]);\\n                for (int i = 0; i < tmp.size(); i++) {\\n                    int a = tmp[i]/2;\\n                    if (a%2)\\n                        freq[1].push_back(a);\\n                    else\\n                        freq[2].push_back(a);\\n                }\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n\\n\\nclass Solution1 {\\npublic:\\n    void getTypes(vector<int> &nums, int &zero, int &even, int &odd) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                zero++;\\n            } else if (nums[i]%2) {\\n                odd++;\\n            } else\\n                even++;\\n        }\\n    }\\n    void updateNums(vector<int> &nums, bool divide, int &zero, int &even, int &odd) {\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i]) {\\n                if (divide){\\n                    nums[i] = nums[i]/2;\\n                } else {\\n                    if (nums[i]%2)\\n                        nums[i]--;\\n                }\\n            }\\n            if (nums[i] == 0) {\\n                zero++;\\n            } else if (nums[i]%2)\\n                odd++;\\n            else\\n                even++;\\n        }\\n        \\n    }\\n    int minOperations(vector<int>& nums) {\\n        int result = 0;\\n        int n = nums.size();\\n        int zero = 0; int even = 0; int odd = 0;\\n        getTypes(nums,zero,even,odd);\\n        while(zero != n) { \\n            bool allNum = false;\\n            if (zero+even == n) {\\n                result++;\\n                allNum = true;\\n            } else {\\n                result += odd;\\n            }\\n            zero = 0; even = 0; odd = 0;\\n            updateNums(nums,allNum,zero,even,odd);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053087,
                "title": "simple-and-easy-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. minus 1 if odd number then follwed by divide by 2 until number become 0\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            int count=0;\\n            while(nums[i]){\\n                if(nums[i]&1){\\n                    ans+=1;\\n                     nums[i]--;\\n                }\\n                if(nums[i]){\\n                     nums[i]/=2;\\n                     count++;\\n                     maxi=max(maxi,count);\\n                }  \\n            }\\n        }\\n        return ans+maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans=0;\\n        int maxi=0;\\n        for(int i=0;i<nums.size();i++){\\n            int count=0;\\n            while(nums[i]){\\n                if(nums[i]&1){\\n                    ans+=1;\\n                     nums[i]--;\\n                }\\n                if(nums[i]){\\n                     nums[i]/=2;\\n                     count++;\\n                     maxi=max(maxi,count);\\n                }  \\n            }\\n        }\\n        return ans+maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039045,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        long sum = 0;\\n        for (int num : nums) sum += num;\\n        int res = 0;\\n        bool all_zero = (sum == 0);\\n        while (!all_zero) {\\n            all_zero = true;\\n            auto *num_ptr = nums.data();\\n            for (int i = 0; i < nums.size(); ++i) {\\n                res += *num_ptr & 0x01;\\n                *num_ptr >>= 1;\\n                if (*num_ptr) all_zero = false;\\n                ++num_ptr;\\n            }\\n            if (!all_zero) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        long sum = 0;\\n        for (int num : nums) sum += num;\\n        int res = 0;\\n        bool all_zero = (sum == 0);\\n        while (!all_zero) {\\n            all_zero = true;\\n            auto *num_ptr = nums.data();\\n            for (int i = 0; i < nums.size(); ++i) {\\n                res += *num_ptr & 0x01;\\n                *num_ptr >>= 1;\\n                if (*num_ptr) all_zero = false;\\n                ++num_ptr;\\n            }\\n            if (!all_zero) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014827,
                "title": "bitwise-intuitive-and-easy-explanation",
                "content": "# Intuition\\nThe binary representation of any number is composed of exactly the operations that we are given in `modify` function - add one, multiply by 2.\\n\\nFor example, the value `39` in binary format is `100111`, mathematically it can be written as \\n\\n    39 = 2^0 + 2^1 + 2^2 + 2^5.\\n    39 = 2^0 (1 + 2^1 + 2^2 + 2^5) = 2^0 (1 + 2^1 (1 + 2^1 + 2^4)) =\\n    = 2^0 (1 + 2^1 (1 + 2^1(1 + 2^3)))\\n\\nThe highest bit number is **5** (multiplication count) and the number of ones that were added is **4**.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - we are simply passing on every element O(n) and counting the bits on each (constant time).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void findHighestBit(int number, int& opCount, int& highestBit)\\n    {\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int isBitPresent = (number & (1 << i)) > 0;\\n            \\n            opCount += isBitPresent;\\n            highestBit = std::max(highestBit, i * isBitPresent);\\n        }\\n    }\\n\\n    int minOperations(vector<int>& nums) \\n    {\\n        int result = 0;\\n        int maxBit = 0;\\n        for(auto i : nums)\\n        {\\n            int bitCount = 0;\\n            findHighestBit(i, bitCount, maxBit);\\n\\n            result += bitCount;\\n        }\\n        result += maxBit;\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void findHighestBit(int number, int& opCount, int& highestBit)\\n    {\\n        for(int i = 31; i >= 0; i--)\\n        {\\n            int isBitPresent = (number & (1 << i)) > 0;\\n            \\n            opCount += isBitPresent;\\n            highestBit = std::max(highestBit, i * isBitPresent);\\n        }\\n    }\\n\\n    int minOperations(vector<int>& nums) \\n    {\\n        int result = 0;\\n        int maxBit = 0;\\n        for(auto i : nums)\\n        {\\n            int bitCount = 0;\\n            findHighestBit(i, bitCount, maxBit);\\n\\n            result += bitCount;\\n        }\\n        result += maxBit;\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916860,
                "title": "basic-approach-cpp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums){\\n        int n=nums.size();\\n        int ans=0;\\n\\n\\n        label:\\n        bool flag=0;\\n        int count_zero=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count_zero++;\\n            }\\n            else if(nums[i]&1){\\n                flag=1;\\n                nums[i]--;\\n                ans++;\\n            }\\n        }\\n        if(count_zero==n){return ans;}\\n        count_zero=0;\\n        for(int i=0;i<n;i++){\\n            count_zero=nums[i]==0?count_zero+1:count_zero;\\n            nums[i]/=2;\\n        }\\n        if(count_zero==n){return ans;}\\n        else{\\n            ans++;\\n        }\\n        goto label;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums){\\n        int n=nums.size();\\n        int ans=0;\\n\\n\\n        label:\\n        bool flag=0;\\n        int count_zero=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count_zero++;\\n            }\\n            else if(nums[i]&1){\\n                flag=1;\\n                nums[i]--;\\n                ans++;\\n            }\\n        }\\n        if(count_zero==n){return ans;}\\n        count_zero=0;\\n        for(int i=0;i<n;i++){\\n            count_zero=nums[i]==0?count_zero+1:count_zero;\\n            nums[i]/=2;\\n        }\\n        if(count_zero==n){return ans;}\\n        else{\\n            ans++;\\n        }\\n        goto label;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871307,
                "title": "python-counting-ones-o-32n",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        maxl = 0\\n        res = 0\\n        for num in nums:\\n            curbin = bin(num)[2:]\\n            res += curbin.count(\\'1\\')\\n            maxl = max(maxl, len(curbin))\\n        return res + maxl - 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        maxl = 0\\n        res = 0\\n        for num in nums:\\n            curbin = bin(num)[2:]\\n            res += curbin.count(\\'1\\')\\n            maxl = max(maxl, len(curbin))\\n        return res + maxl - 1",
                "codeTag": "Java"
            },
            {
                "id": 2831391,
                "title": "simple-typescript-dp-solution-readable",
                "content": "# Intuition\\nSimple DP\\n\\n# Approach\\nOne of three things can happen at each iteration:\\n\\n1. If odd value found, reduce it 1, count + 1\\n2. If no odd value found, divide all by 2, count + 1\\n3. If all zero, done and return the count\\n\\n# Complexity\\n- Time complexity:\\nO(nLog(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction minOperations(nums: number[]): number {\\n    let count = 0;\\n    let hasDivision = false;\\n\\n    while (nums.some(n => n)) {\\n        for (let i = 0; i < nums.length; ++i) {\\n            if (!nums[i]) {\\n                continue;\\n            } else if (nums[i] % 2) {\\n                count++;\\n                nums[i] --;\\n            } else {\\n                hasDivision = true;\\n            }\\n        }\\n\\n        if (hasDivision) {\\n            count++;\\n            hasDivision = false;\\n            nums = nums.map(num => num/2)\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minOperations(nums: number[]): number {\\n    let count = 0;\\n    let hasDivision = false;\\n\\n    while (nums.some(n => n)) {\\n        for (let i = 0; i < nums.length; ++i) {\\n            if (!nums[i]) {\\n                continue;\\n            } else if (nums[i] % 2) {\\n                count++;\\n                nums[i] --;\\n            } else {\\n                hasDivision = true;\\n            }\\n        }\\n\\n        if (hasDivision) {\\n            count++;\\n            hasDivision = false;\\n            nums = nums.map(num => num/2)\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792394,
                "title": "golang-work-backwards",
                "content": "```go\\nfunc minOperations(nums []int) int {\\n  var adds, mults int\\n  for _, num := range nums {\\n    if num > 0 {\\n      x := num\\n      var mult int\\n      for x > 0 {\\n        if x%2 == 0 {\\n          mult++\\n          x /= 2\\n        } else {\\n          adds++ // Adds are by index\\n          x--\\n        }\\n      }\\n      // multiplications are shared so we take the max\\n      // Even though the multiplications are not consecutive, we can do perform them\\n      // in a way that the we maximize their effect because the other operation that can\\n      // occur in the middle is addition which is specific to an index and doesn\\'t affect\\n      // other elements.\\n      mults = max(mults, mult) \\n    }\\n  }\\n  return adds + mults\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperations(nums []int) int {\\n  var adds, mults int\\n  for _, num := range nums {\\n    if num > 0 {\\n      x := num\\n      var mult int\\n      for x > 0 {\\n        if x%2 == 0 {\\n          mult++\\n          x /= 2\\n        } else {\\n          adds++ // Adds are by index\\n          x--\\n        }\\n      }\\n      // multiplications are shared so we take the max\\n      // Even though the multiplications are not consecutive, we can do perform them\\n      // in a way that the we maximize their effect because the other operation that can\\n      // occur in the middle is addition which is specific to an index and doesn\\'t affect\\n      // other elements.\\n      mults = max(mults, mult) \\n    }\\n  }\\n  return adds + mults\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745754,
                "title": "c-solution-by-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        return helper(nums, n);\\n    }\\n    int helper(vector<int>& nums, int n){\\n        \\n        /* howmany *2 op can be contain:\\n            1. whether /2 can bring a better solution\\n            2. if not return one_solution.\\n        */\\n        vector<int> divide_two(n);\\n        long one_solution = 0;\\n        long two_solution = 1;\\n        for (int i = 0; i < n; i++){\\n            one_solution += (long)nums[i];\\n            divide_two[i] = nums[i] >> 1;\\n            if (nums[i] % 2 == 1){\\n                two_solution++;\\n            }\\n        }\\n        if (one_solution > two_solution){\\n            return two_solution + helper(divide_two, n);\\n        }\\n        return one_solution;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        return helper(nums, n);\\n    }\\n    int helper(vector<int>& nums, int n){\\n        \\n        /* howmany *2 op can be contain:\\n            1. whether /2 can bring a better solution\\n            2. if not return one_solution.\\n        */\\n        vector<int> divide_two(n);\\n        long one_solution = 0;\\n        long two_solution = 1;\\n        for (int i = 0; i < n; i++){\\n            one_solution += (long)nums[i];\\n            divide_two[i] = nums[i] >> 1;\\n            if (nums[i] % 2 == 1){\\n                two_solution++;\\n            }\\n        }\\n        if (one_solution > two_solution){\\n            return two_solution + helper(divide_two, n);\\n        }\\n        return one_solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735525,
                "title": "python-linear-run-time-complexity-no-extra-space",
                "content": "Very nice question )\\nLets first answer the following question:\\nGiven a single number X what is the minimal amoutn of operations we need to reach X?\\nlets say B is the binary representation of X.\\nso we need\\n1. len(B) - 1 shift operations (multiply by 2)\\n2. B.count(1) add_1 operations\\n\\nNow lets go back to the original problem, operations of type 2 are individual for each number, but operations of type 1 can be used for multiple numbers together, so all we need to do is to find the maximal number, and to check how many type 2 operations we need for it. \\nWhy? \\nBcs we may start appending the multiply operations on any point (recall that numbers are 0 at the bginning) so lets say number X needs 3 type 2 operations and number Y needs 7, \\nso we will enter X to the game (by applying operation 1 on it) only after applying 7-3=4 type 2 operations on Y.\\n\\nso eventually this is the code\\n\\n\\n```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res, maxMults = 0, 0\\n        for num in nums:\\n            binRep = \"{0:b}\".format(num)\\n            res += binRep.count(\"1\")\\n            maxMults = max(maxMults, len(binRep) - 1)\\n        return res + maxMults\\n```\\n\\nWe iterate on all the **bits** in the input, hence the time complexity is linear.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res, maxMults = 0, 0\\n        for num in nums:\\n            binRep = \"{0:b}\".format(num)\\n            res += binRep.count(\"1\")\\n            maxMults = max(maxMults, len(binRep) - 1)\\n        return res + maxMults\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729383,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        steps = 0\\n        \\n        double = 0\\n        \\n        for n in nums:\\n            cur_double = 0\\n            while n != 0:\\n                if n%2: \\n                    n -= 1\\n                    steps += 1\\n                else:\\n                    n //= 2\\n                    cur_double += 1\\n            double = max(double, cur_double)\\n            \\n        \\n        return steps + double\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        steps = 0\\n        \\n        double = 0\\n        \\n        for n in nums:\\n            cur_double = 0\\n            while n != 0:\\n                if n%2: \\n                    n -= 1\\n                    steps += 1\\n                else:\\n                    n //= 2\\n                    cur_double += 1\\n            double = max(double, cur_double)\\n            \\n        \\n        return steps + double\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715124,
                "title": "c-simple-and-clean-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nint minOperations(vector<int>& nums) \\n    {\\n        int count=0;\\n        while(1)\\n        {\\n            int even=0;\\n            int temp=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i] %2 != 0)\\n                {\\n                    nums[i]-=1;\\n                    count++;\\n                }\\n                else\\n                {\\n                    even++;\\n                }\\n                if(nums[i]==0)\\n                {\\n                    temp++;\\n                }\\n            }\\n            if(temp==nums.size())\\n                return count;\\n            if(even==nums.size() )\\n            {\\n                count++;\\n                for(int i=0;i<nums.size();i++)\\n                {\\n                    nums[i]=nums[i]/2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\t",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minOperations(vector<int>& nums) \\n    {\\n        int count=0;\\n        while(1)\\n        {\\n            int even=0;\\n            int temp=0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                if(nums[i] %2 != 0)\\n                {\\n                    nums[i]-=1;\\n                    count++;\\n                }\\n                else\\n                {\\n                    even++;\\n                }\\n                if(nums[i]==0)\\n                {\\n                    temp++;\\n                }\\n            }\\n            if(temp==nums.size())\\n                return count;\\n            if(even==nums.size() )\\n            {\\n                count++;\\n                for(int i=0;i<nums.size();i++)\\n                {\\n                    nums[i]=nums[i]/2;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626156,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut max = 0;\\n        for i in 0..nums.len() {\\n            let mut cv = nums[i];\\n            let mut temp = 0;\\n            while cv > 0 {\\n                if cv % 2 == 0 {\\n                    cv /= 2;\\n                    temp += 1;\\n                } else {\\n                    cv -= 1;\\n                    result += 1;\\n                }\\n            }\\n            max = max.max(temp);\\n        }\\n        \\n        result + max\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let mut result = 0;\\n        let mut max = 0;\\n        for i in 0..nums.len() {\\n            let mut cv = nums[i];\\n            let mut temp = 0;\\n            while cv > 0 {\\n                if cv % 2 == 0 {\\n                    cv /= 2;\\n                    temp += 1;\\n                } else {\\n                    cv -= 1;\\n                    result += 1;\\n                }\\n            }\\n            max = max.max(temp);\\n        }\\n        \\n        result + max\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2597156,
                "title": "ruby-t-o-nlogm-s-o-1-100-100",
                "content": "Number of operations = Total additions + Max doubles\\n\\nFor each number num\\n- Number of doubles is the Math.log(num, 2).floor (aka how many times we double from 1 to the biggest number less than num)\\n- Number of additions:\\n\\t- Given the num can be written as: num = 2 ** a + 2 ** b ... + 2 ** x (don\\'t have to be sequential)\\n\\t- The number of additions equals to count(a, b...,z), for example num_additions(14) = 3 because 14 == 8 + 4 + 2\\n\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_operations(nums)\\n  add = 0\\n  max_double = 0\\n  \\n  nums.each do |num|\\n    if num > 0\\n      double = Math.log(num, 2).floor\\n      max_double = [max_double, double].max\\n\\n      base = 2 ** double\\n      while num > 0\\n        if num >= base\\n          num -= base\\n          add +=1 \\n        end\\n        base /= 2\\n      end\\n    end\\n  end\\n\\n  max_double + add\\nend\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Number of operations = Total additions + Max doubles\\n\\nFor each number num\\n- Number of doubles is the Math.log(num, 2).floor (aka how many times we double from 1 to the biggest number less than num)\\n- Number of additions:\\n\\t- Given the num can be written as: num = 2 ** a + 2 ** b ... + 2 ** x (don\\'t have to be sequential)\\n\\t- The number of additions equals to count(a, b...,z), for example num_additions(14) = 3 because 14 == 8 + 4 + 2\\n\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef min_operations(nums)\\n  add = 0\\n  max_double = 0\\n  \\n  nums.each do |num|\\n    if num > 0\\n      double = Math.log(num, 2).floor\\n      max_double = [max_double, double].max\\n\\n      base = 2 ** double\\n      while num > 0\\n        if num >= base\\n          num -= base\\n          add +=1 \\n        end\\n        base /= 2\\n      end\\n    end\\n  end\\n\\n  max_double + add\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2571178,
                "title": "c-very-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        bool nempt = false;\\n        while (true) {\\n            for (auto& n : nums) {\\n                if (n % 2) --n, ++res;\\n                n /= 2;\\n                nempt |= n;\\n            }\\n            if (nempt) ++res, nempt = false;\\n            else return res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int res = 0;\\n        bool nempt = false;\\n        while (true) {\\n            for (auto& n : nums) {\\n                if (n % 2) --n, ++res;\\n                n /= 2;\\n                nempt |= n;\\n            }\\n            if (nempt) ++res, nempt = false;\\n            else return res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488877,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic int MinOperations(int[] nums) {\\n\\t\\t\\tint min_operations = 0, max_product_of_2 = 0;\\n\\t\\t\\tforeach(var num in nums) {\\n\\t\\t\\t\\tmax_product_of_2 = Math.Max(max_product_of_2, (int)Math.Log(num, 2));\\n\\t\\t\\t\\tmin_operations += GetCount(num);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn min_operations + max_product_of_2;\\n\\t\\t}\\n\\n\\t\\tprivate int GetCount(int num) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\twhile(num > 0) {\\n\\t\\t\\t\\tif((num & 1) != 0)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tnum >>= 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int MinOperations(int[] nums) {\\n\\t\\t\\tint min_operations = 0, max_product_of_2 = 0;\\n\\t\\t\\tforeach(var num in nums) {\\n\\t\\t\\t\\tmax_product_of_2 = Math.Max(max_product_of_2, (int)Math.Log(num, 2));\\n\\t\\t\\t\\tmin_operations += GetCount(num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2463641,
                "title": "java-simple-bottom-up-solution-comments-added",
                "content": "```\\nclass Solution {\\n    public int halfIt(int n, int[] nums) {\\n        int methodCalls = 0;\\n        int sum = 0;\\n        for(int i=0;i<n;i++) {\\n            nums[i] /= 2; // half every number\\n            if((nums[i]&1)==1) {\\n\\t\\t\\t\\t// One method call to add 1 at index\\n                nums[i]--; // If the new number is odd the we need one extra opetaion to make it even\\n                methodCalls++;\\n            }\\n            sum += nums[i];\\n        }\\n        methodCalls++; // One method call to double all elements\\n        if(sum == 0) // If all of them are 0 send a -ve number indicating all are 0\\n            return -1*methodCalls;\\n        return methodCalls;\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int methodCalls = 0;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            if((nums[i]&1)==1) {\\n                nums[i]--; // Make all the numbers\\n\\t\\t\\t\\t// increase methodCalls as it takes 1 method call to increase by 1 at index.\\n                methodCalls++;\\n            }\\n            sum += nums[i];\\n        }\\n        while(sum!=0){ // Untill all the elements are 0 i.e. sum of all elements is 0\\n            int mC = halfIt(n, nums);\\n            if(mC<0){ // If method response is -ve then set sum 0 indicating all are 0s.\\n                sum = 0;\\n                mC = -1* mC; // Make method calls +ve\\n            }\\n            methodCalls += mC; //Update number of method calls\\n        }\\n        return methodCalls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int halfIt(int n, int[] nums) {\\n        int methodCalls = 0;\\n        int sum = 0;\\n        for(int i=0;i<n;i++) {\\n            nums[i] /= 2; // half every number\\n            if((nums[i]&1)==1) {\\n\\t\\t\\t\\t// One method call to add 1 at index\\n                nums[i]--; // If the new number is odd the we need one extra opetaion to make it even\\n                methodCalls++;\\n            }\\n            sum += nums[i];\\n        }\\n        methodCalls++; // One method call to double all elements\\n        if(sum == 0) // If all of them are 0 send a -ve number indicating all are 0\\n            return -1*methodCalls;\\n        return methodCalls;\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int methodCalls = 0;\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            if((nums[i]&1)==1) {\\n                nums[i]--; // Make all the numbers\\n\\t\\t\\t\\t// increase methodCalls as it takes 1 method call to increase by 1 at index.\\n                methodCalls++;\\n            }\\n            sum += nums[i];\\n        }\\n        while(sum!=0){ // Untill all the elements are 0 i.e. sum of all elements is 0\\n            int mC = halfIt(n, nums);\\n            if(mC<0){ // If method response is -ve then set sum 0 indicating all are 0s.\\n                sum = 0;\\n                mC = -1* mC; // Make method calls +ve\\n            }\\n            methodCalls += mC; //Update number of method calls\\n        }\\n        return methodCalls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451624,
                "title": "simple-greedy-count-bits-with-an-case",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0]==0)return 0;\\n        int x = log2(nums[0]);\\n        ans += x;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int num_bits = 0;\\n            int y = nums[i];\\n            while(y)\\n            {\\n                num_bits += (y&1);\\n                y >>= 1;\\n            }\\n            ans += num_bits;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0]==0)return 0;\\n        int x = log2(nums[0]);\\n        ans += x;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int num_bits = 0;\\n            int y = nums[i];\\n            while(y)\\n            {\\n                num_bits += (y&1);\\n                y >>= 1;\\n            }\\n            ans += num_bits;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2445360,
                "title": "c-two-approaches-clean-solution",
                "content": "**1. Greedy Approach**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        // we have to solve this problem using greedy method\\n        // instead of trying to convert arr to nums, we have to work backwards from nums to arr\\n        // we can solve this recursively by first making all the elements divisible by 2, then dividing by 2 and solving for the resulting array recursively\\n        \\n        int zeros = 0; // the number of zeros in nums\\n        int count = 0; // the number of times decrements have been performed\\n        int divideBy2 = 0; // indicates if we have divided by 2 or not\\n        \\n        for(int& num : nums){\\n            if(num == 0){\\n                zeros++;\\n            }\\n            else if(num == 1){\\n                num--;\\n                count++;\\n            }\\n            else{\\n                // we have to perform division by 2 on the array\\n                divideBy2 = 1;\\n                // if the number is odd, then decrement it\\n                if(num%2 == 1){\\n                    count++;\\n                }\\n                // after decrementing it, divide it by 2\\n                num /= 2;\\n            }\\n        }\\n        \\n        // if all the elements in nums are 0, then no need to perform any operations\\n        if(zeros == nums.size()){\\n            return 0;\\n        }\\n        \\n        // solve recursively for the resulting array\\n        return count + divideBy2 + minOperations(nums);\\n    }\\n};\\n```\\n------------------------\\n**2. Bit Manipulation**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int totalSetBits = 0; // total number of set bits\\n        int maxLen = 1; // the maximum length of set bit\\n        \\n        for(int num : nums){\\n            int len = 0;\\n            \\n            while(num>0){\\n                totalSetBits += num & 1;\\n                len++;\\n                num >>= 1;\\n            }\\n            \\n            maxLen = max(maxLen, len);\\n        }\\n        \\n        return totalSetBits + maxLen - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        // we have to solve this problem using greedy method\\n        // instead of trying to convert arr to nums, we have to work backwards from nums to arr\\n        // we can solve this recursively by first making all the elements divisible by 2, then dividing by 2 and solving for the resulting array recursively\\n        \\n        int zeros = 0; // the number of zeros in nums\\n        int count = 0; // the number of times decrements have been performed\\n        int divideBy2 = 0; // indicates if we have divided by 2 or not\\n        \\n        for(int& num : nums){\\n            if(num == 0){\\n                zeros++;\\n            }\\n            else if(num == 1){\\n                num--;\\n                count++;\\n            }\\n            else{\\n                // we have to perform division by 2 on the array\\n                divideBy2 = 1;\\n                // if the number is odd, then decrement it\\n                if(num%2 == 1){\\n                    count++;\\n                }\\n                // after decrementing it, divide it by 2\\n                num /= 2;\\n            }\\n        }\\n        \\n        // if all the elements in nums are 0, then no need to perform any operations\\n        if(zeros == nums.size()){\\n            return 0;\\n        }\\n        \\n        // solve recursively for the resulting array\\n        return count + divideBy2 + minOperations(nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int totalSetBits = 0; // total number of set bits\\n        int maxLen = 1; // the maximum length of set bit\\n        \\n        for(int num : nums){\\n            int len = 0;\\n            \\n            while(num>0){\\n                totalSetBits += num & 1;\\n                len++;\\n                num >>= 1;\\n            }\\n            \\n            maxLen = max(maxLen, len);\\n        }\\n        \\n        return totalSetBits + maxLen - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427784,
                "title": "c-greedy-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0, maxi= 0;\\n        for(auto i: nums)\\n        {\\n            int ct = 0;\\n            if(i==0) continue;\\n            ans++;\\n            while(i>1)\\n            {\\n                if(i&1) ans++;\\n                i/=2;\\n                ct++;\\n            }\\n            maxi = max(maxi,ct);\\n        }\\n        return ans+maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0, maxi= 0;\\n        for(auto i: nums)\\n        {\\n            int ct = 0;\\n            if(i==0) continue;\\n            ans++;\\n            while(i>1)\\n            {\\n                if(i&1) ans++;\\n                i/=2;\\n                ct++;\\n            }\\n            maxi = max(maxi,ct);\\n        }\\n        return ans+maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415042,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    if(nums.size()==1){\\n        if(nums[0]==0){\\n            return 0;\\n        }\\n    }vector<int>p;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                p.push_back(nums[i]);\\n            }\\n        }nums=p;\\n        sort(nums.begin(),nums.end());\\n        // if(nums[0]==0){\\n        //     int i=0;\\n        //     while(i<nums.size()){\\n        //         if(nums[i]==0){\\n        //             i++;\\n        //         }else{\\n        //             break;\\n        //         }\\n        //     }nums.erase(nums.begin(),nums.begin()+i);\\n        // }\\n        vector<long long int>v;\\n        long long int ans=0;\\n        for(long long int i=0;i<nums.size();i++){\\n        long long x=nums[i];int oo=0;int pp=0;\\n        while(x/2){\\n            oo++;\\n            if(x%2==0){\\n                \\n            }else{\\n                pp++;\\n            }\\n            x=x/2;\\n        }\\n            v.push_back(oo);\\n            ans+=pp;\\n        }ans+=nums.size();\\n        int l=v[v.size()-1];\\n        ans+=l;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    if(nums.size()==1){\\n        if(nums[0]==0){\\n            return 0;\\n        }\\n    }vector<int>p;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0){\\n                p.push_back(nums[i]);\\n            }\\n        }nums=p;\\n        sort(nums.begin(),nums.end());\\n        // if(nums[0]==0){\\n        //     int i=0;\\n        //     while(i<nums.size()){\\n        //         if(nums[i]==0){\\n        //             i++;\\n        //         }else{\\n        //             break;\\n        //         }\\n        //     }nums.erase(nums.begin(),nums.begin()+i);\\n        // }\\n        vector<long long int>v;\\n        long long int ans=0;\\n        for(long long int i=0;i<nums.size();i++){\\n        long long x=nums[i];int oo=0;int pp=0;\\n        while(x/2){\\n            oo++;\\n            if(x%2==0){\\n                \\n            }else{\\n                pp++;\\n            }\\n            x=x/2;\\n        }\\n            v.push_back(oo);\\n            ans+=pp;\\n        }ans+=nums.size();\\n        int l=v[v.size()-1];\\n        ans+=l;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395581,
                "title": "two-python-solutions",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res, mul = 0, 0\\n        for n in nums:\\n            m = 0\\n            while n:\\n                if n % 2:\\n                    n, res = n - 1, res + 1\\n                else:\\n                    n, m = n // 2, m + 1\\n            mul = max(mul, m)\\n        return res + mul\\n```\\n\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(bin(n).count(\"1\") for n in nums) + len(bin(max(nums))) - 3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        res, mul = 0, 0\\n        for n in nums:\\n            m = 0\\n            while n:\\n                if n % 2:\\n                    n, res = n - 1, res + 1\\n                else:\\n                    n, m = n // 2, m + 1\\n            mul = max(mul, m)\\n        return res + mul\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        return sum(bin(n).count(\"1\") for n in nums) + len(bin(max(nums))) - 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323203,
                "title": "one-liner-ish",
                "content": "```\\n# Observe that:\\n#   +1  places a 1 to the end of the int\\'s binary representation\\n#       (assuming a 0 there previously)\\n#   x2  is a bitshift left\\n# So you basically just need to count all the ones in the binary representations\\n# and find how many shifts are required (largest bit length minus one).\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if max(nums) == 0:\\n            return 0\\n        \\n        return sum([x.bit_count() for x in nums]) + max([x.bit_length() for x in nums]) - 1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Observe that:\\n#   +1  places a 1 to the end of the int\\'s binary representation\\n#       (assuming a 0 there previously)\\n#   x2  is a bitshift left\\n# So you basically just need to count all the ones in the binary representations\\n# and find how many shifts are required (largest bit length minus one).\\n\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if max(nums) == 0:\\n            return 0\\n        \\n        return sum([x.bit_count() for x in nums]) + max([x.bit_length() for x in nums]) - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280451,
                "title": "c-make-nums-to-arr",
                "content": "* Convert the given nums to zero array .\\n\\n* If number is odd we have no option but to reduce it by 1 and we keep adding` _1` because these operations cannot be performed collectively on whole array .\\n\\n* If number is even we keep track of what is the maximum amount of these operations that we will need to perform for each element because we can collectively perform them.\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int _1 = 0 , _2 = 0 , max_2 = 0 ;\\n        for(auto &x : nums){\\n            _2 = 0 ;\\n            while(x){\\n                if(x&1) --x , ++_1 ;\\n                else x/=2 , ++_2 ;\\n            }\\n            max_2 = max(max_2,_2) ;\\n        }\\n        \\n        return  _1 + max_2 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int _1 = 0 , _2 = 0 , max_2 = 0 ;\\n        for(auto &x : nums){\\n            _2 = 0 ;\\n            while(x){\\n                if(x&1) --x , ++_1 ;\\n                else x/=2 , ++_2 ;\\n            }\\n            max_2 = max(max_2,_2) ;\\n        }\\n        \\n        return  _1 + max_2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225567,
                "title": "c-soln-for-o-nlogn-complexity-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    \\n        int cnt=0;\\n        do{\\n            int ops = perform(nums);\\n            cout<<ops<<\" \";\\n            cnt+=ops;\\n            if(ops==0){\\n                break;\\n            }\\n        }while(1);cout<<endl;\\n        \\n        return cnt;\\n    }\\n    \\n    int perform(vector<int> &nums){\\n\\t\\t//init ops to 0;\\n        int ops=0;\\n\\t\\t//count the number of zeros in the nums initially ,if n means no ops needed\\n\\t\\t//to be peformed.\\n        int z=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n\\t\\t\\t//counts the number of zeroes intially in the nums.\\n                z++;\\n            }\\n            if(nums[i]%2==1){\\n\\t\\t\\t\\t//if the element is odd . we perform an operation in the prev step\\n\\t\\t\\t\\t// to make it even.\\n                ops++;\\n                nums[i]--;\\n                if(nums[i]!=0){\\n\\t\\t\\t\\t//if the number doesn\\'t become zero in the above previous operation.\\n                    nums[i]/=2;\\n                }else{\\n\\t\\t\\t\\t//if the number became zero in the above previous operation.\\n                    z++;\\n                }\\n            }else{\\n\\t\\t\\t//if the number is divisible by 2 straightaway divide it by 2.\\n                nums[i]/=2;\\n            }\\n        }\\n        if(z!=n){\\n\\t\\t//if all the elements were not zero initially .\\n            ops++;\\n        }\\n\\t\\t//return the numbe of ops to be performed int the current step\\n\\t\\t\\n        return ops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n    \\n        int cnt=0;\\n        do{\\n            int ops = perform(nums);\\n            cout<<ops<<\" \";\\n            cnt+=ops;\\n            if(ops==0){\\n                break;\\n            }\\n        }while(1);cout<<endl;\\n        \\n        return cnt;\\n    }\\n    \\n    int perform(vector<int> &nums){\\n\\t\\t//init ops to 0;\\n        int ops=0;\\n\\t\\t//count the number of zeros in the nums initially ,if n means no ops needed\\n\\t\\t//to be peformed.\\n        int z=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n\\t\\t\\t//counts the number of zeroes intially in the nums.\\n                z++;\\n            }\\n            if(nums[i]%2==1){\\n\\t\\t\\t\\t//if the element is odd . we perform an operation in the prev step\\n\\t\\t\\t\\t// to make it even.\\n                ops++;\\n                nums[i]--;\\n                if(nums[i]!=0){\\n\\t\\t\\t\\t//if the number doesn\\'t become zero in the above previous operation.\\n                    nums[i]/=2;\\n                }else{\\n\\t\\t\\t\\t//if the number became zero in the above previous operation.\\n                    z++;\\n                }\\n            }else{\\n\\t\\t\\t//if the number is divisible by 2 straightaway divide it by 2.\\n                nums[i]/=2;\\n            }\\n        }\\n        if(z!=n){\\n\\t\\t//if all the elements were not zero initially .\\n            ops++;\\n        }\\n\\t\\t//return the numbe of ops to be performed int the current step\\n\\t\\t\\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2206792,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "I solved this using BFS, however, it gives TLE\\n```\\nclass Solution:\\n    def solve(self, target):\\n        n = len(target)\\n        nums = [0] * n\\n        q = [nums]\\n        ans = 0\\n        visit = set()\\n        nums = [str(i) for i in nums]\\n        visit.add(\\'\\'.join(nums))\\n\\n        while q:\\n            num = len(q)\\n            for i in range(num):\\n                arr = q.pop(0)\\n                if arr == target:\\n                    return ans\\n                for j in range(len(arr)):\\n                    temp = arr[::]\\n                    temp[j] = arr[j] + 1\\n                    # print(temp)\\n                    x = [str(p) for p in temp]\\n                    visit_check = \\'\\'.join(x)\\n                    if visit_check not in visit:\\n                        visit.add(visit_check)\\n                        q.append(temp)\\n                temp = [val * 2 for val in arr]\\n                x = [str(p) for p in temp]\\n                visit_check = \\'\\'.join(x)\\n                if visit_check not in visit:\\n                    visit.add(visit_check)\\n                    q.append(temp)\\n            if q: ans += 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I solved this using BFS, however, it gives TLE\\n```\\nclass Solution:\\n    def solve(self, target):\\n        n = len(target)\\n        nums = [0] * n\\n        q = [nums]\\n        ans = 0\\n        visit = set()\\n        nums = [str(i) for i in nums]\\n        visit.add(\\'\\'.join(nums))\\n\\n        while q:\\n            num = len(q)\\n            for i in range(num):\\n                arr = q.pop(0)\\n                if arr == target:\\n                    return ans\\n                for j in range(len(arr)):\\n                    temp = arr[::]\\n                    temp[j] = arr[j] + 1\\n                    # print(temp)\\n                    x = [str(p) for p in temp]\\n                    visit_check = \\'\\'.join(x)\\n                    if visit_check not in visit:\\n                        visit.add(visit_check)\\n                        q.append(temp)\\n                temp = [val * 2 for val in arr]\\n                x = [str(p) for p in temp]\\n                visit_check = \\'\\'.join(x)\\n                if visit_check not in visit:\\n                    visit.add(visit_check)\\n                    q.append(temp)\\n            if q: ans += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2193855,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> arr(nums.size());\\n\\n        int num_of_calls = 0;\\n\\n        while(nums != arr){\\n            int value = 0;\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if ((nums[i] % 2) == 0)\\n                {\\n                    value++;\\n                }\\n            }\\n\\n            if(value == arr.size()){\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    nums[i] = nums[i] / 2;\\n                }\\n                num_of_calls += 1;\\n            }\\n            else{\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    if ((nums[i] % 2) == 1)\\n                    {\\n                        nums[i] -= 1;\\n                        num_of_calls += 1;\\n                    }\\n                }\\n            }\\n        }\\n        return num_of_calls;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> arr(nums.size());\\n\\n        int num_of_calls = 0;\\n\\n        while(nums != arr){\\n            int value = 0;\\n\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                if ((nums[i] % 2) == 0)\\n                {\\n                    value++;\\n                }\\n            }\\n\\n            if(value == arr.size()){\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    nums[i] = nums[i] / 2;\\n                }\\n                num_of_calls += 1;\\n            }\\n            else{\\n                for (int i = 0; i < nums.size(); i++)\\n                {\\n                    if ((nums[i] % 2) == 1)\\n                    {\\n                        nums[i] -= 1;\\n                        num_of_calls += 1;\\n                    }\\n                }\\n            }\\n        }\\n        return num_of_calls;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164796,
                "title": "simple-java-solution-straightforward",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int res=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int tcount=0;\\n            while(nums[i]>0){\\n                if(nums[i]%2==1){\\n                    res++;\\n                    nums[i]--;\\n                }\\n                else{\\n                    tcount++;\\n                    nums[i]/=2;\\n                }\\n            }\\n            count=Math.max(count,tcount);\\n        }\\n        return res+count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int res=0;\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            int tcount=0;\\n            while(nums[i]>0){\\n                if(nums[i]%2==1){\\n                    res++;\\n                    nums[i]--;\\n                }\\n                else{\\n                    tcount++;\\n                    nums[i]/=2;\\n                }\\n            }\\n            count=Math.max(count,tcount);\\n        }\\n        return res+count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158196,
                "title": "subtract-and-take-max-power-of-2-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int minOperations(vector<int>& A) {\\n        int ans = 0;\\n        int pow2 = 0;\\n    \\n        for(int i = 0; i < A.size(); i++) {\\n           int ones=0;\\n            int p = 0;\\n            while(A[i]>0)\\n            {\\n                if(A[i]%2==0)\\n                {\\n                    p++;\\n                    A[i]=A[i]/2;\\n                }\\n                else\\n                {\\n                    ones++;\\n                    A[i]--;\\n                }\\n            }\\n            pow2=max(pow2,p);\\n            ans += ones;\\n        }\\n        ans+=pow2;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126975,
                "title": "think-using-binary",
                "content": "```cpp\\nint ret = 0;\\nint ma = 1;\\n\\n// op 1: set the least significant bit.\\n// op 2: shfit 1 position toward most significant bit, i.e., left shift (<<).\\n\\nfor (int x : nums)\\n{\\n\\t// count for set bit 1\\n\\t// find the MSB.\\n\\tint c = 0;\\n\\tint m = 0;\\n\\t\\n\\twhile (x)\\n\\t{\\n\\t\\tc += x & 1;\\n\\t\\tx >>= 1;\\n\\t\\t++ m;\\n\\t}\\n\\t\\n\\t// with every set bit 1, we have to perform one op 1.\\n\\t// for the largest nums, which have the largest MSB, we have to perform op 2 that many times.\\n\\tma = max(ma, m);\\n\\tret += c;\\n}\\n\\nreturn ret + ma - 1;\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint ret = 0;\\nint ma = 1;\\n\\n// op 1: set the least significant bit.\\n// op 2: shfit 1 position toward most significant bit, i.e., left shift (<<).\\n\\nfor (int x : nums)\\n{\\n\\t// count for set bit 1\\n\\t// find the MSB.\\n\\tint c = 0;\\n\\tint m = 0;\\n\\t\\n\\twhile (x)\\n\\t{\\n\\t\\tc += x & 1;\\n\\t\\tx >>= 1;\\n\\t\\t++ m;\\n\\t}\\n\\t\\n\\t// with every set bit 1, we have to perform one op 1.\\n\\t// for the largest nums, which have the largest MSB, we have to perform op 2 that many times.\\n\\tma = max(ma, m);\\n\\tret += c;\\n}\\n\\nreturn ret + ma - 1;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": []
    },
    {
        "title": "Redistribute Characters to Make All Strings Equal",
        "question_content": "<p>You are given an array of strings <code>words</code> (<strong>0-indexed</strong>).</p>\n\n<p>In one operation, pick two <strong>distinct</strong> indices <code>i</code> and <code>j</code>, where <code>words[i]</code> is a non-empty string, and move <strong>any</strong> character from <code>words[i]</code> to <strong>any</strong> position in <code>words[j]</code>.</p>\n\n<p>Return <code>true</code> <em>if you can make<strong> every</strong> string in </em><code>words</code><em> <strong>equal </strong>using <strong>any</strong> number of operations</em>,<em> and </em><code>false</code> <em>otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abc&quot;,&quot;aabc&quot;,&quot;bc&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Move the first &#39;a&#39; in <code>words[1] to the front of words[2],\nto make </code><code>words[1]</code> = &quot;abc&quot; and words[2] = &quot;abc&quot;.\nAll the strings are now equal to &quot;abc&quot;, so return <code>true</code>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;ab&quot;,&quot;a&quot;]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to make all the strings equal using the operation.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 100</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1268558,
                "title": "count",
                "content": "**C++**\\n```cpp\\nbool makeEqual(vector<string>& words) {\\n    int cnt[26] = {};\\n    for (auto &w : words)\\n        for (auto ch : w)\\n            ++cnt[ch - \\'a\\'];\\n    return all_of(begin(cnt), end(cnt), [&](int c) { return c % words.size() == 0; });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool makeEqual(vector<string>& words) {\\n    int cnt[26] = {};\\n    for (auto &w : words)\\n        for (auto ch : w)\\n            ++cnt[ch - \\'a\\'];\\n    return all_of(begin(cnt), end(cnt), [&](int c) { return c % words.size() == 0; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339018,
                "title": "python-3-98-48-explained-two-easy-solutions",
                "content": "eg --> words = [\"abc\",\"aabc\",\"bcc\"]\\n\\n* stp1)  join --> \"abcaabcbc\"\\n* stp2) set --> {\\'b\\', \\'a\\', \\'c\\'}\\n* stp3) joint.count(\\'b\\') = 3 , joint.count(\\'a\\') = 3 , joint.count(\\'c\\') = 4\\n* stp4) as  joint.count(\\'c\\') = 4 therefore it is not multiple of len(words)--->[here 3]\\n\\tif joint.count(i) % len(words) != 0 : return False\\n* \\tif joint.count(\\'c\\') >len(words) and also multiple of len(words) , then also it will work coz we can distribute all \\'c\\' equally in all the substrings, therfore we are using (%), for eg if count(c) = 6 then we we can distribute \\'c\\' like [\\'....cc\\',\\'....cc\\',\\'...cc\\']\\n\\n\\n\\n**44 ms, faster than 98.48%**\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        set1 = set(joint)\\n        \\n        for i in set1 :\\n            if joint.count(i) % len(words) != 0 : return False \\n        return True\\n```\\n\\n**56 ms, faster than 85.81%**\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        dic = {}\\n        \\n        for i in joint :\\n            if i not in dic :\\n                dic[i] = joint.count(i)\\n                \\n        for v in dic.values() :\\n            if v % len(words) != 0 : return False \\n        return True\\n```\\n\\n\\n**plz upvote if u like : )**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        set1 = set(joint)\\n        \\n        for i in set1 :\\n            if joint.count(i) % len(words) != 0 : return False \\n        return True\\n```\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        joint = \\'\\'.join(words)\\n        dic = {}\\n        \\n        for i in joint :\\n            if i not in dic :\\n                dic[i] = joint.count(i)\\n                \\n        for v in dic.values() :\\n            if v % len(words) != 0 : return False \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268522,
                "title": "python-dictionary",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        map_ = {}\\n        for word in words:\\n            for i in word:\\n                if i not in map_:\\n                    map_[i] = 1\\n                else:\\n                    map_[i] += 1\\n        n = len(words)\\n        for k,v in map_.items():\\n            if (v%n) != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        map_ = {}\\n        for word in words:\\n            for i in word:\\n                if i not in map_:\\n                    map_[i] = 1\\n                else:\\n                    map_[i] += 1\\n        n = len(words)\\n        for k,v in map_.items():\\n            if (v%n) != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268501,
                "title": "just-count",
                "content": "As characters can be moved to any position, we just need to check if the count of any character is divisible by given words length or not.\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int mp[26] = {0};\\n        for(auto &word: words){\\n            for(auto &c: word){\\n                mp[c - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i = 0;i<26;i++){\\n            if(mp[i] % words.size() != 0) return false;\\n        }\\n        return true;      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int mp[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 1268442,
                "title": "python-two-lines-or-one-line",
                "content": "- Two Lines\\n```python\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counts, n = collections.Counter(\\'\\'.join(words)), len(words)                    \\n        return all([ val % n == 0 for val in counts.values() ])\\n```\\n\\n- One Line from @dmyma\\n```python\\nclass Solution:\\n    def makeEqual(self, w: List[str]) -> bool:             \\n        return all([ val % len(w) == 0 for val in collections.Counter(\\'\\'.join(w)).values() ])\\n```\\n\\n- One Line with no brackets @blue_sky5 and @l1ne\\n```python\\nclass Solution:\\n    def makeEqual(self, w: List[str]) -> bool:             \\n        return all(val % len(w) == 0 for val in collections.Counter(\\'\\'.join(w)).values())\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counts, n = collections.Counter(\\'\\'.join(words)), len(words)                    \\n        return all([ val % n == 0 for val in counts.values() ])\\n```\n```python\\nclass Solution:\\n    def makeEqual(self, w: List[str]) -> bool:             \\n        return all([ val % len(w) == 0 for val in collections.Counter(\\'\\'.join(w)).values() ])\\n```\n```python\\nclass Solution:\\n    def makeEqual(self, w: List[str]) -> bool:             \\n        return all(val % len(w) == 0 for val in collections.Counter(\\'\\'.join(w)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268630,
                "title": "java-using-hashmap-easy-understanding",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        \\n        for(String str : words){\\n            \\n            for(int i=0; i<str.length(); i++){\\n                char ch = str.charAt(i);\\n                \\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n        }\\n        \\n        for(Character key : map.keySet()){\\n            \\n            int freq = map.get(key);\\n            if(freq % words.length!=0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nSolution with less time and space : [Using Count](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/discuss/1268558/Count/974645)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        \\n        for(String str : words){\\n            \\n            for(int i=0; i<str.length(); i++){\\n                char ch = str.charAt(i);\\n                \\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            }\\n            \\n        }\\n        \\n        for(Character key : map.keySet()){\\n            \\n            int freq = map.get(key);\\n            if(freq % words.length!=0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268555,
                "title": "java-python-3-count-all-chars-then-check-if-all-frequencies-can-be-divided-without-remaining",
                "content": "```java\\n    public boolean makeEqual(String[] words) {\\n        int[] cnt = new int[26];\\n        for (String w : words) {\\n            for (int i = 0; i < w.length(); ++i) {\\n                ++cnt[w.charAt(i) - \\'a\\'];\\n            }\\n        }\\n        for (int i = 0, n = words.length; i < 26; ++i) {\\n            if (cnt[i] % n != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(val % len(words) == 0 for val in Counter(reduce(add, words)).values())\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean makeEqual(String[] words) {\\n        int[] cnt = new int[26];\\n        for (String w : words) {\\n            for (int i = 0; i < w.length(); ++i) {\\n                ++cnt[w.charAt(i) - \\'a\\'];\\n            }\\n        }\\n        for (int i = 0, n = words.length; i < 26; ++i) {\\n            if (cnt[i] % n != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(val % len(words) == 0 for val in Counter(reduce(add, words)).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1268784,
                "title": "c-self-expalantory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int cnt[26] = {0};\\n        //count the freq of each char\\n        for (auto &w : words)\\n           for (auto ch : w)\\n               ++cnt[ch - \\'a\\'];\\n        \\n        \\n        int n=words.size();\\n        for(int i: cnt)\\n            // check if we can distribute the freq in all the words equally or not, if no then return false.\\n            if(i%n!=0) return false;\\n        return true;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int cnt[26] = {0};\\n        //count the freq of each char\\n        for (auto &w : words)\\n           for (auto ch : w)\\n               ++cnt[ch - \\'a\\'];\\n        \\n        \\n        int n=words.size();\\n        for(int i: cnt)\\n            // check if we can distribute the freq in all the words equally or not, if no then return false.\\n            if(i%n!=0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272761,
                "title": "count-characters-in-all-word-and-check-mod-with-number-of-words",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] frequency = new int[26];\\n        for(String word : words)\\n            for(char c : word.toCharArray())\\n                frequency[c - \\'a\\']++;\\n        \\n        for(int x : frequency)\\n            if(x % words.length != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] frequency = new int[26];\\n        for(String word : words)\\n            for(char c : word.toCharArray())\\n                frequency[c - \\'a\\']++;\\n        \\n        for(int x : frequency)\\n            if(x % words.length != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271358,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        //only frequency matters\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                map.put(words[i].charAt(j),map.getOrDefault(words[i].charAt(j),0)+1);\\n            }\\n        }\\n      for(Character key : map.keySet())\\n      {\\n            \\n            int freq = map.get(key);\\n            if(freq % words.length!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        //only frequency matters\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        for(int i=0;i<words.length;i++)\\n        {\\n            for(int j=0;j<words[i].length();j++)\\n            {\\n                map.put(words[i].charAt(j),map.getOrDefault(words[i].charAt(j),0)+1);\\n            }\\n        }\\n      for(Character key : map.keySet())\\n      {\\n            \\n            int freq = map.get(key);\\n            if(freq % words.length!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268720,
                "title": "java-streams-3-lines",
                "content": "```java\\n public boolean makeEqual(String[] words) {\\n        int[] counts = new int[26];\\n        Arrays.stream(words).forEach(w -> w.chars().forEach(c -> counts[c - \\'a\\']++));\\n        return Arrays.stream(counts).allMatch(c -> c % words.length == 0);\\n    }",
                "solutionTags": [],
                "code": "```java\\n public boolean makeEqual(String[] words) {\\n        int[] counts = new int[26];\\n        Arrays.stream(words).forEach(w -> w.chars().forEach(c -> counts[c - \\'a\\']++));\\n        return Arrays.stream(counts).allMatch(c -> c % words.length == 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1268591,
                "title": "python-easy-explained-time-o-n-2-space-constant",
                "content": "Idea: For each word count the number of letters together in a hashmap/array.\\nE.g.: words = [\\'abc\\',\\'aabc\\',\\'bc\\']\\nHashmap = [\\'a\\' : 3, \\'b\\': 3, \\'c\\': 3]\\n\\nNow, if every string in words are made to be equal, tehn count of every letter in hashmap must be divisible by the length of words, otherwise atleast one letter will be extra in one word.\\nE.g: words = [\\'abcc\\',\\'aabc\\',\\'bc\\']\\nHashmap = [\\'a\\' : 3, \\'b\\': 3, \\'c\\': 4]\\nHere, \\'abc\\' will be present in all the strings but one extra \\'c\\' will be with atleast one of them, like [\\'abcc\\',\\'abc\\',\\'abc] or [\\'abc\\',abcc\\',\\'abc\\'] or [\\'abc\\',\\'abc\\',\\'abcc\\']...\\n\\nSo, calculate the hashmap and check if any element in hashmap is not exactly divisible by the number of words.\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        def indx(x):\\n            return ord(x) - ord(\\'a\\')\\n        \\n        hashmap = [0]*26\\n        for word in words:\\n            for c in word:\\n                hashmap[indx(c)]+=1\\n        \\n        n = len(words)\\n        \\n        for i in range(26):\\n            if hashmap[i]%n != 0:\\n                return False\\n        return True\\n```\\nTime: O(n) for iterating through each word in words and O(n) for iterating through each character in a word = O(n^2)\\nSpace: Constant as we are using a hashmap of fixed size (26).\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        def indx(x):\\n            return ord(x) - ord(\\'a\\')\\n        \\n        hashmap = [0]*26\\n        for word in words:\\n            for c in word:\\n                hashmap[indx(c)]+=1\\n        \\n        n = len(words)\\n        \\n        for i in range(26):\\n            if hashmap[i]%n != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268527,
                "title": "python-can-t-be-more-simple",
                "content": "**If the count of the all individual char is divisible by length of array then it is True.**\\n\\n```python\\n\\nclass Solution:\\n    def makeEqual(self, arr: List[str]) -> bool:\\n        s = list(\\'\\'.join(arr))\\n        for ele,times in Counter(s).items():\\n            if times % len(arr) != 0:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def makeEqual(self, arr: List[str]) -> bool:\\n        s = list(\\'\\'.join(arr))\\n        for ele,times in Counter(s).items():\\n            if times % len(arr) != 0:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278178,
                "title": "c-easy-to-understand-fast-and-efficient-using-hashtables",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(char c:words[i])\\n            {\\n                mp[c]++;\\n            }\\n        }\\n        for(auto pr:mp)\\n        {\\n            if(pr.second%words.size()!=0)\\n              return false;  \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(char c:words[i])\\n            {\\n                mp[c]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2772332,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool makeEqual(vector<string>& words) {\\n\\t\\tunordered_map<char,int>mp;\\n\\t\\tfor(auto i:words){\\n\\t\\t\\tfor(int j=0;j<i.size();j++) mp[i[j]]++;        \\n\\t\\t}\\n\\t\\tfor(auto i:mp){\\n\\t\\t\\tif(i.second%words.size()!=0)return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool makeEqual(vector<string>& words) {\\n\\t\\tunordered_map<char,int>mp;\\n\\t\\tfor(auto i:words){\\n\\t\\t\\tfor(int j=0;j<i.size();j++) mp[i[j]]++;        \\n\\t\\t}\\n\\t\\tfor(auto i:mp){\\n\\t\\t\\tif(i.second%words.size()!=0)return false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734937,
                "title": "javascript-count-o-n-w-n-words-w-word-length",
                "content": "Suppose total number of words in given input are **n**. If we want to make all words equal, it means same count of characters should be there in every word in the end result. \\n\\nIf we calculate count of each character in all words then every character can be distributed equally among all words only if its **count % n == 0** else we cannot distribute it and ans will be false.\\n\\nfor e.g \\n\\nwords = [\"abc\",\"aabc\",\"bc\"], n = 3\\ncount map :\\na - 3\\nb - 3\\nc - 3\\nall three counts have % 3 = 0.\\n\\n[\"ab\",\"abb\",\"aaaa\"], n = 3\\n\\na - 6\\nb - 3\\n\\nall three counts have % 3 = 0.\\n\\n[\"ab\",\"abb\"], n = 2\\n\\na - 2\\nb - 3\\nwe cannot distribute \\'b\\' equally among n, means %n ==0 is not true for all counts.\\n\\n\\n**Time Complexity**: O( 100 * 100), max number of words are 100 & max length of a single word is 100.\\n\\nif n = total words, w = word length then **O( n * w)**\\n\\n\\n```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    \\n    \\n    let length = words.length\\n    \\n    let map = {}\\n    for( let word of words ) {\\n        for( let ch of word ) {\\n            map[ch] = ( map[ch] || 0 )  + 1 \\n        }\\n    }\\n    \\n    for( let key of Object.keys(map)) {\\n        if( map[key] % length !=0 ) return false\\n    }\\n    \\n    return true\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    \\n    \\n    let length = words.length\\n    \\n    let map = {}\\n    for( let word of words ) {\\n        for( let ch of word ) {\\n            map[ch] = ( map[ch] || 0 )  + 1 \\n        }\\n    }\\n    \\n    for( let key of Object.keys(map)) {\\n        if( map[key] % length !=0 ) return false\\n    }\\n    \\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401747,
                "title": "c-intuition-and-stl",
                "content": "```\\n//Approach-1 (Intuition)\\n/*\\n\\tmove any character from words[i] to any position in words[j].\\n\\tThis line above makes things easy. We just need to know if all characters\\'\\n\\tcan be equally distributed to each. i.e.\\n\\tfrequency[character]%n == 0 for all characters\\n*/\\n\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int t[26] = {0};\\n        int n = words.size();\\n        \\n        for(const string& word : words) {\\n            for( const char &ch : word) {\\n                t[ch-\\'a\\']++;\\n            }\\n        }\\n        \\n        for(const int& x : t) {\\n            if(x%n != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using STL just for fun)\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int t[26] = {0};\\n        int n = words.size();\\n        \\n        for(const string& word : words) {\\n            for( const char &ch : word) {\\n                t[ch-\\'a\\']++;\\n            }\\n        }\\n        \\n        auto lambda = [&n](int &a) {\\n            return a%n==0;\\n        };\\n        \\n        return all_of(begin(t), end(t), lambda);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Intuition)\\n/*\\n\\tmove any character from words[i] to any position in words[j].\\n\\tThis line above makes things easy. We just need to know if all characters\\'\\n\\tcan be equally distributed to each. i.e.\\n\\tfrequency[character]%n == 0 for all characters\\n*/\\n\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int t[26] = {0};\\n        int n = words.size();\\n        \\n        for(const string& word : words) {\\n            for( const char &ch : word) {\\n                t[ch-\\'a\\']++;\\n            }\\n        }\\n        \\n        for(const int& x : t) {\\n            if(x%n != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using STL just for fun)\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int t[26] = {0};\\n        int n = words.size();\\n        \\n        for(const string& word : words) {\\n            for( const char &ch : word) {\\n                t[ch-\\'a\\']++;\\n            }\\n        }\\n        \\n        auto lambda = [&n](int &a) {\\n            return a%n==0;\\n        };\\n        \\n        return all_of(begin(t), end(t), lambda);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366941,
                "title": "c-0ms-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int lowercase[26] = {0};\\n        for (string word : words) {\\n            for (char ch : word) {\\n                int delta = ch - \\'a\\';\\n                lowercase[delta]++;\\n            }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            if (lowercase[i] % words.size()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int lowercase[26] = {0};\\n        for (string word : words) {\\n            for (char ch : word) {\\n                int delta = ch - \\'a\\';\\n                lowercase[delta]++;\\n            }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            if (lowercase[i] % words.size()) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268844,
                "title": "c-frequency-map",
                "content": "The solution is simple.\\nFirst calculate frequency of all the alphabets present in all the strings of the given vector\\nNow to make all the strings equal every alpahbet must have a frequency equal to the size of the given vector\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char,int>freq;\\n        for(auto child:words)\\n            for(auto c:child)\\n                freq[c]++;\\n       \\n        int n=words.size();\\n        for(auto child:freq){\\n            if(child.second%n!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char,int>freq;\\n        for(auto child:words)\\n            for(auto c:child)\\n                freq[c]++;\\n       \\n        int n=words.size();\\n        for(auto child:freq){\\n            if(child.second%n!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158239,
                "title": "java-o-n-k-solution",
                "content": "# Complexity\\n- Time complexity: O(N + K), where N - number of chars in words, K - 26 alphabet lowercase letters\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] alph = new int[26];\\n        for (String word : words) for (char c : word.toCharArray()) alph[c - \\'a\\']++;\\n        for (int n : alph) if (n % words.length != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] alph = new int[26];\\n        for (String word : words) for (char c : word.toCharArray()) alph[c - \\'a\\']++;\\n        for (int n : alph) if (n % words.length != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466222,
                "title": "funny-solution-with-go",
                "content": "```\\nfunc makeEqual(words []string) bool {\\n    alphabet := make([]int, 26)\\n    \\n    for _, word := range words {\\n        for i := 0; i < len(word); i++ {\\n            alphabet[int(word[i] - \\'a\\')]++\\n        }\\n    }\\n\\n    for i := 0; i < 26; i++ {\\n        if alphabet[i] % len(words) != 0 {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc makeEqual(words []string) bool {\\n    alphabet := make([]int, 26)\\n    \\n    for _, word := range words {\\n        for i := 0; i < len(word); i++ {\\n            alphabet[int(word[i] - \\'a\\')]++\\n        }\\n    }\\n\\n    for i := 0; i < 26; i++ {\\n        if alphabet[i] % len(words) != 0 {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356078,
                "title": "java-4ms",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] counter = new int[26];\\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                counter[c - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int c : counter){\\n            if(c % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] counter = new int[26];\\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                counter[c - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int c : counter){\\n            if(c % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427574,
                "title": "c-simple-and-clean-intuitive-explained-solution",
                "content": "**idea:**\\nWe keep a map to store the frequencies of all letters.\\nIf we can divide all of them equally to `n` words - return true.\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> freq;\\n        for (auto word : words)\\n            for (auto ch : word)\\n                freq[ch]++;\\n        \\n        int n = words.size();\\n        for (auto [ch, fr] : freq)\\n            if (fr % n) return false;\\n        \\n        return true;\\n        \\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> freq;\\n        for (auto word : words)\\n            for (auto ch : word)\\n                freq[ch]++;\\n        \\n        int n = words.size();\\n        for (auto [ch, fr] : freq)\\n            if (fr % n) return false;\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351168,
                "title": "java-o-1-space-o-n-time-easy-explanation",
                "content": "Key Takeaways:\\n- The question mentions: **any** number of operations to make all the strings equal.\\n- Which means for any character, each word needs to have same character (at least once).\\n\\t- Example: `[abcd, abcd, abcd, abcd]` => here each character appears 4 times at least.\\n\\t- This can be rearranged as `[abcdab, cd, ab, cdabcd]`. (a form of input could be provided)\\n- So in order to satisfy the given constraints - each character needs to be present in all the words at least one time.\\n- This means that each character\\'s total count in the entire set of words (frequency count) **must** be a multiple of **length(set of words) = length of words array**.\\n\\t- This can be achieved by evaluating `(frequency count of each character in total) % length(set of words)`\\n\\t- If `0`, return `true` else return `false`.\\n\\n\\n**Time Complexity: O(words.length + avg/longest one word length) or O(N) | where N = number of all characters parsed.\\nSpace Complexity: O(1) | considering a finite set of lowercase letters**\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] charFreq = new int[26];\\n        \\n        for(String word : words) {\\n            for(int chIndex = 0; chIndex < word.length(); chIndex++) {\\n                charFreq[word.charAt(chIndex) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int freq : charFreq) {\\n            if(freq % words.length != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] charFreq = new int[26];\\n        \\n        for(String word : words) {\\n            for(int chIndex = 0; chIndex < word.length(); chIndex++) {\\n                charFreq[word.charAt(chIndex) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int freq : charFreq) {\\n            if(freq % words.length != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347523,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean makeEqual(String[] w) {\\n        int a[]=new int[26];\\n        int i,j;\\n        for(i=0;i<w.length;i++)\\n        {\\n            for(j=0;j<w[i].length();j++)\\n            {\\n                a[w[i].charAt(j)-\\'a\\']++;\\n            }\\n        }\\n        for(i=0;i<26;i++)\\n        {\\n            if(a[i]>0&&a[i]%w.length!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean makeEqual(String[] w) {\\n        int a[]=new int[26];\\n        int i,j;\\n        for(i=0;i<w.length;i++)\\n        {\\n            for(j=0;j<w[i].length();j++)\\n            {\\n                a[w[i].charAt(j)-\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1285418,
                "title": "c-2-simple-and-efficient-solution",
                "content": "**If you find it helpful then please upvote**\\n\\n```\\n bool makeEqual(vector<string>& words) {\\n        \\n        //using hasmaps (55% efficient)\\n//         unordered_map<char,int> m;\\n//         int n = words.size();\\n//         for(int i=0;i<n;i++){\\n//             for(int j=0; j<words[i].size();j++){\\n//                 m[words[i][j]]++;\\n//             }\\n//         }\\n        \\n//         unordered_map<char,int>::iterator itr;\\n//         for(itr = m.begin(); itr!=m.end();itr++){\\n//             if(((itr->second)%n)!=0){\\n//                 return false;\\n//             }\\n//         }\\n//         return true;\\n        \\n        //using vector(95% efficient)\\n        vector<int> v(26,0);\\n        for(auto w:words){\\n            for(auto ch:w){\\n                v[ch-\\'a\\']++;\\n            }\\n        }\\n        int n = words.size();\\n        for(auto itr=v.begin(); itr!=v.end(); itr++){\\n            if(*itr%n!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n bool makeEqual(vector<string>& words) {\\n        \\n        //using hasmaps (55% efficient)\\n//         unordered_map<char,int> m;\\n//         int n = words.size();\\n//         for(int i=0;i<n;i++){\\n//             for(int j=0; j<words[i].size();j++){\\n//                 m[words[i][j]]++;\\n//             }\\n//         }\\n        \\n//         unordered_map<char,int>::iterator itr;\\n//         for(itr = m.begin(); itr!=m.end();itr++){\\n//             if(((itr->second)%n)!=0){\\n//                 return false;\\n//             }\\n//         }\\n//         return true;\\n        \\n        //using vector(95% efficient)\\n        vector<int> v(26,0);\\n        for(auto w:words){\\n            for(auto ch:w){\\n                v[ch-\\'a\\']++;\\n            }\\n        }\\n        int n = words.size();\\n        for(auto itr=v.begin(); itr!=v.end(); itr++){\\n            if(*itr%n!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277843,
                "title": "easy-java-solution",
                "content": "**JAVA**\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int n = words.length;\\n\\t\\t\\n\\t\\t//26 word array to count each word frequency present in array\\n        int[] array = new int[26];\\n        \\n        for(String word : words){\\n            for(char c : word.toCharArray()){\\n                array[c-\\'a\\']++;\\n            }\\n            \\n        }\\n        \\n\\t\\t\\n        for(int fq : array){\\n            if(fq%n != 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int n = words.length;\\n\\t\\t\\n\\t\\t//26 word array to count each word frequency present in array\\n        int[] array = new int[26];\\n        \\n        for(String word : words){\\n            for(char c : word.toCharArray()){\\n                array[c-\\'a\\']++;\\n            }\\n            \\n        }\\n        \\n\\t\\t\\n        for(int fq : array){\\n            if(fq%n != 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272441,
                "title": "easy-c-solution",
                "content": "We know that we can move any character, any number of times, to any position in the words array. So, all that we have to check is if all the count of any character is divisible by n i.e the length of the words array.  For a detailed explanation check out https://helloml.org/redistribute-characters-to-make-all-strings-equal-solution-to-leetcode-problem/. \\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int counts[26] = {0};\\n        int n = words.size();\\n        \\n        // Counting the number of times each character appears in words. \\n        for(int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            for (int j = 0; j < word.size(); j++) {\\n                counts[word[j]-\\'a\\']++;\\n            }\\n        }\\n        \\n        // Now we check if each count is divisible by n\\n        for(int i = 0; i < 26; i++) {\\n            if(counts[i] % n == 0) {\\n                continue;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int counts[26] = {0};\\n        int n = words.size();\\n        \\n        // Counting the number of times each character appears in words. \\n        for(int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            for (int j = 0; j < word.size(); j++) {\\n                counts[word[j]-\\'a\\']++;\\n            }\\n        }\\n        \\n        // Now we check if each count is divisible by n\\n        for(int i = 0; i < 26; i++) {\\n            if(counts[i] % n == 0) {\\n                continue;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271152,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, arr: List[str]) -> bool:\\n        \\n        h = [0]*26\\n        n = len(arr)\\n        \\n        for w in arr:\\n            for i in w:\\n                h[ord(i)-ord(\\'a\\')] += 1\\n        \\n        for i in h:\\n            if i%n!=0:\\n                return 0\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, arr: List[str]) -> bool:\\n        \\n        h = [0]*26\\n        n = len(arr)\\n        \\n        for w in arr:\\n            for i in w:\\n                h[ord(i)-ord(\\'a\\')] += 1\\n        \\n        for i in h:\\n            if i%n!=0:\\n                return 0\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269904,
                "title": "runtime-88-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "```\\nvar makeEqual = function(words) {\\n    const map = words.join(\"\").split(\"\").reduce((acc,curr)=>acc.set(curr, (acc.get(curr)||0)+1),new Map());\\n    const values = [...map.values()];\\n    \\n    return values.every(val =>val%words.length===0);\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e975cd29-5257-4ca6-b6d2-affc4c27b749_1623596581.2594924.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeEqual = function(words) {\\n    const map = words.join(\"\").split(\"\").reduce((acc,curr)=>acc.set(curr, (acc.get(curr)||0)+1),new Map());\\n    const values = [...map.values()];\\n    \\n    return values.every(val =>val%words.length===0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268699,
                "title": "python3-freq-table",
                "content": "\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = defaultdict(int)\\n        for word in words: \\n            for ch in word: freq[ord(ch)-97] += 1\\n        return all(x % len(words) == 0 for x in freq.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = defaultdict(int)\\n        for word in words: \\n            for ch in word: freq[ord(ch)-97] += 1\\n        return all(x % len(words) == 0 for x in freq.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268655,
                "title": "c-count-character-frequency",
                "content": "Check if the number of times a character appears in `words` is divisible by `words.Length`.\\n```\\npublic class Solution {\\n    public bool MakeEqual(string[] words)\\n    {\\n        int[] cnt = new int[26];\\n        foreach (char c in string.Concat(words))\\n        {\\n            cnt[c - \\'a\\']++;\\n        }\\n        return cnt.All(x => x % words.Length == 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool MakeEqual(string[] words)\\n    {\\n        int[] cnt = new int[26];\\n        foreach (char c in string.Concat(words))\\n        {\\n            cnt[c - \\'a\\']++;\\n        }\\n        return cnt.All(x => x % words.Length == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268485,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" \\n        To redistribute characters equally we need the occurrence of every character to be divided exactly to the number of words\\n        \"\"\"\\n        n = len(words)\\n        characters = {}\\n        for word in words:\\n            for ch in word:\\n                if ch not in characters:\\n                    characters[ch] = 1\\n                else:\\n                    characters[ch] += 1\\n        \\n        for ch in characters:\\n            if characters[ch] % n != 0:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" \\n        To redistribute characters equally we need the occurrence of every character to be divided exactly to the number of words\\n        \"\"\"\\n        n = len(words)\\n        characters = {}\\n        for word in words:\\n            for ch in word:\\n                if ch not in characters:\\n                    characters[ch] = 1\\n                else:\\n                    characters[ch] += 1\\n        \\n        for ch in characters:\\n            if characters[ch] % n != 0:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023036,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] arr) {\\n        int n = arr.length;\\n\\n        int a[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            String s = arr[i];\\n            for(int j=0; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                a[ch-\\'a\\']++;\\n            }\\n        }\\n\\n        for(var x : a){\\n            if(x%n!=0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] arr) {\\n        int n = arr.length;\\n\\n        int a[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            String s = arr[i];\\n            for(int j=0; j<s.length(); j++){\\n                char ch = s.charAt(j);\\n                a[ch-\\'a\\']++;\\n            }\\n        }\\n\\n        for(var x : a){\\n            if(x%n!=0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976380,
                "title": "simple-solution-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public boolean makeEqual(String[] words){\\n        int[] arr = new int[26];\\n        int n = words.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<words[i].length(); j++) arr[words[i].charAt(j)-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i]!=0 && arr[i]%n!=0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public boolean makeEqual(String[] words){\\n        int[] arr = new int[26];\\n        int n = words.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<words[i].length(); j++) arr[words[i].charAt(j)-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(arr[i]!=0 && arr[i]%n!=0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959718,
                "title": "easy-with-js",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function (words) {\\n    const map = {}\\n    for (const word of words)\\n        for (const char of word)\\n            map[char] ? map[char]++ : map[char] = 1\\n    for (const number of Object.values(map))\\n        if (number % words.length !== 0)\\n            return false\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function (words) {\\n    const map = {}\\n    for (const word of words)\\n        for (const char of word)\\n            map[char] ? map[char]++ : map[char] = 1\\n    for (const number of Object.values(map))\\n        if (number % words.length !== 0)\\n            return false\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3739947,
                "title": "count-the-frequency-of-each-character-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length();j++){\\n                map.put(words[i].charAt(j),map.getOrDefault(words[i].charAt(j),0)+1);\\n            }\\n        }\\n        for(char ch:map.keySet()){\\n            if(map.get(ch)%words.length!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length();j++){\\n                map.put(words[i].charAt(j),map.getOrDefault(words[i].charAt(j),0)+1);\\n            }\\n        }\\n        for(char ch:map.keySet()){\\n            if(map.get(ch)%words.length!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701516,
                "title": "count-letters-and-mod-with-word-count",
                "content": "# Intuition\\nThere are two key insights:\\n\\n- words only use the 26 lower-case letters\\n- the permitted operation means the order of letters in words is not important\\n\\nConceivably we could completely re-order letters in a word by moving the letters to another word, then back to the original word in a different spot.\\n\\nThe result of this insight is that we only need to count letters; we do not need to be concerned with the order of letters.\\n\\nAnd we can know whether all words can be made equal simply by knowing that the count of each letter is divisible by the number of words. \\n\\nWe can also observe that if the total number of characters across words does not evenly divide by the number of words, then it would be impossible to re-arrange the letters into equal words.\\n\\n# Approach\\n\\nPopulate `letterCounts = new int[26]` with the count of each letter. Then use modulo to determine if each letter count evenly divides by number of words `n`.\\n\\n# Complexity\\n\\n### Time complexity:\\n\\nWe must look at every letter of every word once. So, let `n` be the number of words and `m` be the average length of each word. Then the runtime is:\\n\\n$$O(n * m)$$ \\n\\n### Space complexity:\\n\\nWe allocate a constant size 26 element array to keep the letter counts.\\n\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n        var n = words.Length;\\n        long sum = 0;\\n        int[] letterCounts = new int[26];\\n        foreach (var word in words)\\n        {\\n            sum += word.Length;\\n            foreach (var letter in word)\\n            {\\n                int index = (int)(letter - \\'a\\');\\n                letterCounts[index]++;\\n            }\\n        }\\n        // If total number of characters is not divisible by n\\n        // we immediately know we don\\'t have a solution\\n        if (sum % n != 0)\\n            return false;\\n        // Because the letters in each word\\n        // can ultimately be re-arranged to any order\\n        // the order of the letters does not matter.\\n        // Therefore only the count of the letters matters.\\n        foreach(var letterCount in letterCounts)\\n        {\\n            if (letterCount % n != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n        var n = words.Length;\\n        long sum = 0;\\n        int[] letterCounts = new int[26];\\n        foreach (var word in words)\\n        {\\n            sum += word.Length;\\n            foreach (var letter in word)\\n            {\\n                int index = (int)(letter - \\'a\\');\\n                letterCounts[index]++;\\n            }\\n        }\\n        // If total number of characters is not divisible by n\\n        // we immediately know we don\\'t have a solution\\n        if (sum % n != 0)\\n            return false;\\n        // Because the letters in each word\\n        // can ultimately be re-arranged to any order\\n        // the order of the letters does not matter.\\n        // Therefore only the count of the letters matters.\\n        foreach(var letterCount in letterCounts)\\n        {\\n            if (letterCount % n != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112958,
                "title": "c-self-explainatory",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n      map<char, int> mp;\\n      int n=words.size();\\n      for(string word:words)\\n      {\\n          for(char w :word)\\n          {\\n              mp[w]++;\\n          }\\n      }  \\n      for(auto m:mp)\\n      {\\n          if(m.second%n!=0)\\n          return false;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n      map<char, int> mp;\\n      int n=words.size();\\n      for(string word:words)\\n      {\\n          for(char w :word)\\n          {\\n              mp[w]++;\\n          }\\n      }  \\n      for(auto m:mp)\\n      {\\n          if(m.second%n!=0)\\n          return false;\\n      }\\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892918,
                "title": "js-very-easy-and-fast-solution-80ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/a952d594-fb25-4ad9-968a-5324adaf5d4f_1670559381.826913.png)\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    const hashmap = new Map();\\n    let sum = 0;\\n\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        sum += word.length;\\n\\n        for (let j = 0; j < word.length; j++) {\\n            const character = word[j];\\n\\n            if (hashmap.has(character)) {\\n                hashmap.set(character, hashmap.get(character) + 1);\\n            } else {\\n                hashmap.set(character, 1);\\n            }\\n        }\\n    }\\n    if (sum%(words.length)) return false;\\n\\n    let output = true;\\n    hashmap.forEach((value) => {\\n        if (value%(words.length)) output = false;\\n    });\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    const hashmap = new Map();\\n    let sum = 0;\\n\\n    for (let i = 0; i < words.length; i++) {\\n        const word = words[i];\\n        sum += word.length;\\n\\n        for (let j = 0; j < word.length; j++) {\\n            const character = word[j];\\n\\n            if (hashmap.has(character)) {\\n                hashmap.set(character, hashmap.get(character) + 1);\\n            } else {\\n                hashmap.set(character, 1);\\n            }\\n        }\\n    }\\n    if (sum%(words.length)) return false;\\n\\n    let output = true;\\n    hashmap.forEach((value) => {\\n        if (value%(words.length)) output = false;\\n    });\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867083,
                "title": "c-begginer",
                "content": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char,int> sp;\\n        if(words.size()==1){\\n            return true;\\n        }\\n        for(auto it:words){\\n            for(auto it1:it){\\n                sp[it1]++;\\n            }\\n        }\\n        int n=words.size();\\n        int count=0;\\n        for(auto it:sp){\\n            if(it.second%n!=0){\\n                return false;\\n            }\\n        }\\n        return true;;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char,int> sp;\\n        if(words.size()==1){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2349438,
                "title": "c-logical-approach-explained-short",
                "content": "![image](https://assets.leetcode.com/users/images/7bbfcfbc-5ab1-4f85-942f-2b29c73f37b9_1659079817.3431644.png)\\n\\n***Logic-> Lets say you can make all the words equal then all the characters combined in words will definitely be the multiple of words,size(). so we have to just check for it!***\\n\\t\\n**n==words.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool makeEqual(vector<string>& words) {\\n\\t\\t\\tunordered_map<char,int>mp;\\n\\t\\t\\tfor(auto i:words){\\n\\t\\t\\t\\tfor(int j=0;j<i.size();j++) mp[i[j]]++;        \\n\\t\\t\\t}\\n\\t\\t\\tfor(auto i:mp){\\n\\t\\t\\t\\tif(i.second%words.size()!=0)return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool makeEqual(vector<string>& words) {\\n\\t\\t\\tunordered_map<char,int>mp;\\n\\t\\t\\tfor(auto i:words){\\n\\t\\t\\t\\tfor(int j=0;j<i.size();j++) mp[i[j]]++;        \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2284019,
                "title": "easiest-c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int seen[26]={0}; // define an  array of 26 to track the count of every alphabet\\n        int len =words.size();\\n        for(int i =0; i<len; i++){ // first loop to iterate over main array\\n            for(int j =0; j<words[i].length(); j++){ //second loop to iterate in words element like \"aab\"\\n                seen[words[i][j]-\\'a\\']++;  // we will increase count every time its seen ex. for \"aab\" seen would be [2,1,0,0....]\\n            }\\n        }\\n        for(int i=0; i<26;i++){\\n            if(seen[i]%len!=0){  we will check that every count should be divisible by total elements present in words so we can distribute it equally !\\n                return false;\\n            }\\n        \\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nIf you **LIKE** my solution then please **UPVOTE** it and **LiKE** iit",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int seen[26]={0}; // define an  array of 26 to track the count of every alphabet\\n        int len =words.size();\\n        for(int i =0; i<len; i++){ // first loop to iterate over main array\\n            for(int j =0; j<words[i].length(); j++){ //second loop to iterate in words element like \"aab\"\\n                seen[words[i][j]-\\'a\\']++;  // we will increase count every time its seen ex. for \"aab\" seen would be [2,1,0,0....]\\n            }\\n        }\\n        for(int i=0; i<26;i++){\\n            if(seen[i]%len!=0){  we will check that every count should be divisible by total elements present in words so we can distribute it equally !\\n                return false;\\n            }\\n        \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251535,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int div = words.length;\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(String word:words)\\n            for(char c:word.toCharArray())\\n                hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)%div!=0)\\n                return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean makeEqual(String[] words) {\\n        int div = words.length;\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(String word:words)\\n            for(char c:word.toCharArray())\\n                hmap.put(c,hmap.getOrDefault(c,0)+1);\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)%div!=0)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2206845,
                "title": "java-hashmap-clean",
                "content": "Do do not care about each word, we just care about each character\\'s frequency. If the frequency is perfectly divisible with the length of words array, then we know that each character can be equally distributed among words and we return true.\\n\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        if (words.length == 1)\\n            return true;\\n        \\n        for (var word : words) \\n            for (var ch : word.toCharArray()) \\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        \\n        for (var val : map.values())\\n            if (val % words.length != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        \\n        if (words.length == 1)\\n            return true;\\n        \\n        for (var word : words) \\n            for (var ch : word.toCharArray()) \\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        \\n        for (var val : map.values())\\n            if (val % words.length != 0)\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097679,
                "title": "using-unordered-map-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> ma;\\n        int m = words.size();\\n        for(int i=0; i<m; ++i){\\n            for(auto& j : words[i]){\\n                ma[j]++;\\n            }\\n        }\\n        for(auto& itr: ma){\\n            if(itr.second % m != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> ma;\\n        int m = words.size();\\n        for(int i=0; i<m; ++i){\\n            for(auto& j : words[i]){\\n                ma[j]++;\\n            }\\n        }\\n        for(auto& itr: ma){\\n            if(itr.second % m != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057489,
                "title": "python-3-o-n-time-o-n-space",
                "content": "![image](https://assets.leetcode.com/users/images/b0edcdfb-a736-46fc-9860-17a9eb76434c_1653060383.6717935.png)\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        cnt = functools.reduce(operator.add, map(collections.Counter, words))\\n        return all(v % len(words) == 0 for v in cnt.values())\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt = collections.Counter(\\'\\'.join(words))\\n        return all(v % len(words) == 0 for v in cnt.values())",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/b0edcdfb-a736-46fc-9860-17a9eb76434c_1653060383.6717935.png)\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        cnt = functools.reduce(operator.add, map(collections.Counter, words))\\n        return all(v % len(words) == 0 for v in cnt.values())\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \"\"\" O(N)TS \"\"\"\\n        cnt = collections.Counter(\\'\\'.join(words))\\n        return all(v % len(words) == 0 for v in cnt.values())",
                "codeTag": "Python3"
            },
            {
                "id": 1991006,
                "title": "python3-using-hashmap",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = {}\\n        for i in range(len(words)):\\n            for item in words[i]:\\n                if (item in freq):\\n                    freq[item] += 1\\n                else:\\n                    freq[item] = 1\\n        for value in freq.values():\\n            if value % len(words) != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = {}\\n        for i in range(len(words)):\\n            for item in words[i]:\\n                if (item in freq):\\n                    freq[item] += 1\\n                else:\\n                    freq[item] = 1\\n        for value in freq.values():\\n            if value % len(words) != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970716,
                "title": "java-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f0bb280c-e5c9-4a8d-9bff-17a343af69c2_1650576078.8641238.png)\\n\\n\\n```\\n\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] cnt = new int[26];\\n        for (String w : words) {\\n            for (int i = 0; i < w.length(); ++i) {\\n                ++cnt[w.charAt(i) - \\'a\\'];\\n            }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt[i] % words.length != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] cnt = new int[26];\\n        for (String w : words) {\\n            for (int i = 0; i < w.length(); ++i) {\\n                ++cnt[w.charAt(i) - \\'a\\'];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1853047,
                "title": "python-count-all-characters",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        n = len(words)\\n        d = defaultdict(int)\\n        \\n        for word in words:\\n            for ch in word:\\n                d[ch] += 1\\n        \\n        for letter_count in d.values():\\n            if letter_count % n != 0:\\n                return False\\n            \\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        n = len(words)\\n        d = defaultdict(int)\\n        \\n        for word in words:\\n            for ch in word:\\n                d[ch] += 1\\n        \\n        for letter_count in d.values():\\n            if letter_count % n != 0:\\n                return False\\n            \\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728493,
                "title": "runtime-52-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "```\\nvar makeEqual = function(words) {\\n    \\n    const sum = new Array(26).fill(0);\\n    \\n    for (let word of words) {\\n        for (let i = 0; i < word.length; i++) sum[word.charCodeAt(i) - 97]++;\\n    }\\n    \\n    for (let i = 0; i < 26; i++) {\\n        if (sum[i] > 0) {\\n            if (sum[i] % words.length !== 0) return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar makeEqual = function(words) {\\n    \\n    const sum = new Array(26).fill(0);\\n    \\n    for (let word of words) {\\n        for (let i = 0; i < word.length; i++) sum[word.charCodeAt(i) - 97]++;\\n    }\\n    \\n    for (let i = 0; i < 26; i++) {\\n        if (sum[i] > 0) {\\n            if (sum[i] % words.length !== 0) return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1657838,
                "title": "python-two-liner",
                "content": "```py\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counter = Counter(\"\".join(words))\\n        return all(v % len(words) == 0 for v in counter.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counter = Counter(\"\".join(words))\\n        return all(v % len(words) == 0 for v in counter.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617412,
                "title": "python-1-line-counter-reduce-map",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(list(map(lambda a:a%len(words)==0, collections.Counter(functools.reduce(lambda a,b:a+b,words)).values())))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(list(map(lambda a:a%len(words)==0, collections.Counter(functools.reduce(lambda a,b:a+b,words)).values())))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545693,
                "title": "c-easy-fast",
                "content": "```C++\\nclass Solution\\n{\\npublic:\\n    bool makeEqual(vector<string> &w)\\n    {\\n        int freq[256] = {0};\\n        for (int i = 0; i < w.size(); i++)\\n        {\\n            for (int j = 0; j < w[i].length(); j++)\\n            {\\n                freq[w[i][j]]++;\\n            }\\n        }\\n        for (int i = 0; i < 256; i++)\\n        {\\n            if (freq[i] % w.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**_upvote if you found solution useful_**",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    bool makeEqual(vector<string> &w)\\n    {\\n        int freq[256] = {0};\\n        for (int i = 0; i < w.size(); i++)\\n        {\\n            for (int j = 0; j < w[i].length(); j++)\\n            {\\n                freq[w[i][j]]++;\\n            }\\n        }\\n        for (int i = 0; i < 256; i++)\\n        {\\n            if (freq[i] % w.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1453368,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic bool MakeEqual(string[] words) {\\n\\t\\t\\tint[] freq = new int[26];\\n\\n\\t\\t\\tforeach(var word in words) {\\n\\t\\t\\t\\tforeach(var chr in word) {\\n\\t\\t\\t\\t\\tfreq[chr - \\'a\\']++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0; i < 26; i++) {\\n\\t\\t\\t\\tif(freq[i] % words.Length != 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic bool MakeEqual(string[] words) {\\n\\t\\t\\tint[] freq = new int[26];\\n\\n\\t\\t\\tforeach(var word in words) {\\n\\t\\t\\t\\tforeach(var chr in word) {\\n\\t\\t\\t\\t\\tfreq[chr - \\'a\\']++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1435557,
                "title": "java-count-letter-simple",
                "content": "if you like it pls upvote\\n\\nJava\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] alph = new int[26];\\n        \\n        for(int i =0;i<words.length;i++)\\n            for(int j = 0;j< words[i].length();j++)\\n                alph[words[i].charAt(j)-\\'a\\']++;\\n        \\n        \\n        for(int i = 0;i<26;i++)\\n            if(alph[i] % words.length !=0) return false;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] alph = new int[26];\\n        \\n        for(int i =0;i<words.length;i++)\\n            for(int j = 0;j< words[i].length();j++)\\n                alph[words[i].charAt(j)-\\'a\\']++;\\n        \\n        \\n        for(int i = 0;i<26;i++)\\n            if(alph[i] % words.length !=0) return false;\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406857,
                "title": "c-easy-solution-count",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        int freq[26] = {0};\\n        \\n        for(auto word: words)\\n        {\\n            for(auto ch: word)\\n            {\\n                freq[ch-\\'a\\']++;\\n            }\\n        }\\n        int n = words.size();\\n        for(auto val: freq)\\n        {\\n            if((val)%n != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        int freq[26] = {0};\\n        \\n        for(auto word: words)\\n        {\\n            for(auto ch: word)\\n            {\\n                freq[ch-\\'a\\']++;\\n            }\\n        }\\n        int n = words.size();\\n        for(auto val: freq)\\n        {\\n            if((val)%n != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406851,
                "title": "java-count-faster-than-99-using-array",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] arr= new int[26];\\n        for(var s : words)\\n        {\\n            for(var ch:s.toCharArray())\\n            {\\n                arr[ch-\\'a\\']+=1;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(arr[i]%words.length!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] arr= new int[26];\\n        for(var s : words)\\n        {\\n            for(var ch:s.toCharArray())\\n            {\\n                arr[ch-\\'a\\']+=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1363424,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        if(n==1)\\n            return true;\\n        unordered_map<char,int> ans;\\n        for(string s:words){\\n            for(char ch:s){\\n                ans[ch]++;\\n            }\\n        }\\n       \\n        for(auto x:ans){\\n            if(x.second!=n && x.second%n!=0)\\n                return false;\\n        }\\n    return true;}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        if(n==1)\\n            return true;\\n        unordered_map<char,int> ans;\\n        for(string s:words){\\n            for(char ch:s){\\n                ans[ch]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1362140,
                "title": "c-concise-linq",
                "content": "```\\npublic bool MakeEqual(string[] words)\\n\\t=> !words.SelectMany(s => s)\\n\\t\\t     .GroupBy(c => c)\\n             .Any(g => g.Count()%words.Length != 0);\\n```",
                "solutionTags": [],
                "code": "```\\npublic bool MakeEqual(string[] words)\\n\\t=> !words.SelectMany(s => s)\\n\\t\\t     .GroupBy(c => c)\\n             .Any(g => g.Count()%words.Length != 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354830,
                "title": "java-array-counting-2ms-beats-99-50-t-c-o-len-max-words-s-c-o-1",
                "content": "\\n    public boolean makeEqual(String[] words) {\\n        \\n        int len = words.length;\\n        int[] map = new int[26];\\n        \\n        for(String word : words){\\n            for(char ch : word.toCharArray())\\n                map[ch - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(map[i] % len != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\n    public boolean makeEqual(String[] words) {\\n        \\n        int len = words.length;\\n        int[] map = new int[26];\\n        \\n        for(String word : words){\\n            for(char ch : word.toCharArray())\\n                map[ch - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < 26; i++){\\n            if(map[i] % len != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1320056,
                "title": "python-2-lines-solution-with-detail-explanation",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq=Counter(\"\".join(words))\\n        return all(freq[i]%len(words)==0 for i in freq)\\n\\t\\t\\n\\t\\t\\n** \\tFind the frequency of all the characters  , (According to the que every character should be present in each and every  word given i.e each characters frequency should be evenly divided with the length of the array) .This is the logic behind the question :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq=Counter(\"\".join(words))\\n        return all(freq[i]%len(words)==0 for i in freq)\\n\\t\\t\\n\\t\\t\\n** \\tFind the frequency of all the characters  , (According to the que every character should be present in each and every  word given i.e each characters frequency should be evenly divided with the length of the array) .This is the logic behind the question :)**",
                "codeTag": "Java"
            },
            {
                "id": 1319015,
                "title": "python-99-speed-documented",
                "content": "```\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makeEqual(self, words: List[str]) -> bool:\\n        \\n\\t\\t\\t\\t# figure out what all the characters are and\\n\\t\\t\\t\\t# how many words they must be distributed over:\\n\\t\\t\\t\\tn_words = len(words)\\n\\t\\t\\t\\tall_chars = \\'\\'.join(words)\\n\\t\\t\\t\\tuniques = set(all_chars)\\n        \\n\\t\\t\\t\\t# if the chars can\\'t be distributed evenly, then the \\n\\t\\t\\t\\t# answer is false:\\n\\t\\t\\t\\tans = True\\n\\t\\t\\t\\tfor unique in uniques:\\n\\t\\t\\t\\t\\tif not(all_chars.count(unique) % n_words == 0):\\n\\t\\t\\t\\t\\t\\tans = False\\n\\t\\t\\t\\t\\t\\tbreak\\n                \\n\\t\\t\\t\\t# return ans boolean:     \\n\\t\\t\\t\\treturn(ans)",
                "solutionTags": [],
                "code": "```\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef makeEqual(self, words: List[str]) -> bool:\\n        \\n\\t\\t\\t\\t# figure out what all the characters are and\\n\\t\\t\\t\\t# how many words they must be distributed over:\\n\\t\\t\\t\\tn_words = len(words)\\n\\t\\t\\t\\tall_chars = \\'\\'.join(words)\\n\\t\\t\\t\\tuniques = set(all_chars)\\n        \\n\\t\\t\\t\\t# if the chars can\\'t be distributed evenly, then the \\n\\t\\t\\t\\t# answer is false:\\n\\t\\t\\t\\tans = True\\n\\t\\t\\t\\tfor unique in uniques:\\n\\t\\t\\t\\t\\tif not(all_chars.count(unique) % n_words == 0):\\n\\t\\t\\t\\t\\t\\tans = False\\n\\t\\t\\t\\t\\t\\tbreak\\n                \\n\\t\\t\\t\\t# return ans boolean:     \\n\\t\\t\\t\\treturn(ans)",
                "codeTag": "Java"
            },
            {
                "id": 1311371,
                "title": "java-count-frequency-and-check-divisibility",
                "content": "Why check divisibility? Read the hints section in the problem description.\\n\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] freq = new int[26];\\n        for (String word: words) {\\n            for (char ch: word.toCharArray()) {\\n                freq[ch - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] % words.length != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] freq = new int[26];\\n        for (String word: words) {\\n            for (char ch: word.toCharArray()) {\\n                freq[ch - \\'a\\']++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < 26; i++) {\\n            if (freq[i] % words.length != 0)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304973,
                "title": "c-solution",
                "content": "(```) class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        \\n        vector <int> v(26, 0);\\n        \\n        for(auto x : words){\\n            \\n            for(auto ch : x){\\n                \\n                v[ch -\\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i = 0; i < v.size( ); i++){\\n            \\n            if(v[i] % words.size( ) != 0){\\n                \\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        \\n        vector <int> v(26, 0);\\n        \\n        for(auto x : words){\\n            \\n            for(auto ch : x){\\n                \\n                v[ch -\\'a\\']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1294758,
                "title": "java-solution-2s-run-time-beats-90-6-lines-solutions",
                "content": "THE IDEA BEHIND THIS SOLUTION IS TO COUNT THE OCCURANCE OF EACH LETTER IN ALL STRINGS OF THE ARRAY \"words\", EACH LETTER MUST HAVE THE SAME NUMBER OF OCCCURANCE SO WE CAN BUILD A FULL ARRAY OF EQUAL STRINGS.\\nWE DON\\'T HAVE TO CONSTRUCT THE ARRAY OR FIND THE MINIMUM OF STEPS TO CONSTRUCT THE ARRAY\\nSO WE WILL HAVE TO COUNT OCCURANCE THEN CHECK IF THEY ARE DEVISIBL BY THE LENGTH OF THE ARRAY \\n\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] arr = new int[26];\\n        for(String str : words) for(char ch : str.toCharArray()) arr[ch -\\'a\\']++;\\n        for(int i : arr ) if(i%words.length!=0) return false;\\n        return true;\\n    }\\n}\\n```\\nRuntime: 2 ms, faster than 99.58% of Java online submissions for Redistribute Characters to Make All Strings Equal.\\nMemory Usage: 38.9 MB, less than 54.51% of Java online submissions for Redistribute Characters to Make All Strings Equal.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] arr = new int[26];\\n        for(String str : words) for(char ch : str.toCharArray()) arr[ch -\\'a\\']++;\\n        for(int i : arr ) if(i%words.length!=0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281022,
                "title": "c-fast-and-efficient-easy-to-understand-intuitive-approach",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(char c:words[i])\\n            {\\n                mp[c]++;\\n            }\\n        }\\n        for(auto pr:mp)\\n        {\\n            if(pr.second%words.size()!=0)\\n              return false;  \\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(char c:words[i])\\n            {\\n                mp[c]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1279991,
                "title": "c-4-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(const vector<string>& words) {\\n        \\n        vector<int> v(26);\\n        \\n        for(const auto& i:words)\\n            for(auto ch:i)\\n                ++v[ch-\\'a\\'];\\n        \\n        for(auto i:v)\\n            if(i%words.size()) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(const vector<string>& words) {\\n        \\n        vector<int> v(26);\\n        \\n        for(const auto& i:words)\\n            for(auto ch:i)\\n                ++v[ch-\\'a\\'];\\n        \\n        for(auto i:v)\\n            if(i%words.size()) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276475,
                "title": "check-each-letter-can-appear-with-the-same-occurence-count-in-each-word-c",
                "content": "* count the occurence of each letter, regardless of which word(s) it appear\\n* test if the number of occurence of each letter can be divided equally between the number of words\\n\\n\\n```\\n\\nbool makeEqual(const vector<string>& words) {\\n        //check each letter can appear with the same occurence count in each word\\n        \\n        array<size_t, 128> counts = {};\\n        \\n        for_each(cbegin(words), cend(words), \\n                 [&counts] (string_view word) {\\n                     for (const auto ch : word) ++counts[ch];\\n                 }\\n                 );\\n        const auto words_count {words.size()};\\n        return all_of(cbegin(counts), cend(counts), [words_count](size_t occurences ) {return occurences % words_count == 0;});\\n\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "* count the occurence of each letter, regardless of which word(s) it appear\\n* test if the number of occurence of each letter can be divided equally between the number of words\\n\\n\\n```\\n\\nbool makeEqual(const vector<string>& words) {\\n        //check each letter can appear with the same occurence count in each word\\n        \\n        array<size_t, 128> counts = {};\\n        \\n        for_each(cbegin(words), cend(words), \\n                 [&counts] (string_view word) {\\n                     for (const auto ch : word) ++counts[ch];\\n                 }\\n                 );\\n        const auto words_count {words.size()};\\n        return all_of(cbegin(counts), cend(counts), [words_count](size_t occurences ) {return occurences % words_count == 0;});\\n\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1275898,
                "title": "rust-functional-solution",
                "content": "```\\nimpl Solution {\\n    pub fn make_equal(words: Vec<String>) -> bool {\\n        let l = words.len();\\n        words\\n            .into_iter()\\n            .flat_map(|s| s.into_bytes())\\n            .fold([0; 26], |mut counter, b| {\\n                counter[(b - b\\'a\\') as usize] += 1;\\n                counter\\n            })\\n            .iter()\\n            .all(|x| *x % l == 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn make_equal(words: Vec<String>) -> bool {\\n        let l = words.len();\\n        words\\n            .into_iter()\\n            .flat_map(|s| s.into_bytes())\\n            .fold([0; 26], |mut counter, b| {\\n                counter[(b - b\\'a\\') as usize] += 1;\\n                counter\\n            })\\n            .iter()\\n            .all(|x| *x % l == 0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273973,
                "title": "simple-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n       string s = \"\";\\n       int n = words.size();\\n       for(int i = 0 ; i < n ; i++){\\n           s += words[i];\\n       }\\n       map<char,int> mp;\\n       for(int i = 0 ; i < s.length() ; i++){\\n           mp[s[i]]++;\\n       }\\n       for(auto x : mp){\\n           if(x.second % n)\\n               return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n       string s = \"\";\\n       int n = words.size();\\n       for(int i = 0 ; i < n ; i++){\\n           s += words[i];\\n       }\\n       map<char,int> mp;\\n       for(int i = 0 ; i < s.length() ; i++){\\n           mp[s[i]]++;\\n       }\\n       for(auto x : mp){\\n           if(x.second % n)\\n               return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271998,
                "title": "python-join-dictionary-check",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        a = \\'\\'.join(words)\\n        c, n = Counter(a), len(words)\\n        for i in c:\\n            if c[i] % n != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        a = \\'\\'.join(words)\\n        c, n = Counter(a), len(words)\\n        for i in c:\\n            if c[i] % n != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271109,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int count[26] = {0};\\n        string longWord = \"\";\\n        for(int i = 0; i < words.size(); i++) {\\n            longWord += words[i];\\n        }\\n        for(int i = 0; i < longWord.size(); i++) {\\n            count[longWord[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(count[i] % words.size() != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int count[26] = {0};\\n        string longWord = \"\";\\n        for(int i = 0; i < words.size(); i++) {\\n            longWord += words[i];\\n        }\\n        for(int i = 0; i < longWord.size(); i++) {\\n            count[longWord[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++) {\\n            if(count[i] % words.size() != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270888,
                "title": "c-easy-solution",
                "content": "C++ Easy Solution :-\\n\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector <int> v(27,0);\\n        for(int i=0; i<words.size(); i++){\\n            for(int j=0; j<words[i].size(); j++){\\n                v[words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0; i<27; i++){\\n            if(v[i]%words.size()==0){\\n                \\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector <int> v(27,0);\\n        for(int i=0; i<words.size(); i++){\\n            for(int j=0; j<words[i].size(); j++){\\n                v[words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        for(int i=0; i<27; i++){\\n            if(v[i]%words.size()==0){\\n                \\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270836,
                "title": "go-golang-solution",
                "content": ">Runtime: 4 ms, faster than 100.00% of Go online submissions for Redistribute Characters to Make All Strings Equal.\\nMemory Usage: 3.9 MB, less than 100.00% of Go online submissions for Redistribute Characters to Make All Strings Equal.\\n\\n```go\\nfunc makeEqual(words []string) bool {\\n    tmp, n := [26]int{}, len(words)\\n    for _, word := range words {\\n        for _, c := range word {\\n            tmp[c - \\'a\\']++\\n        }\\n    }\\n    for _, v := range tmp { if v % n != 0 { return false } }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc makeEqual(words []string) bool {\\n    tmp, n := [26]int{}, len(words)\\n    for _, word := range words {\\n        for _, c := range word {\\n            tmp[c - \\'a\\']++\\n        }\\n    }\\n    for _, v := range tmp { if v % n != 0 { return false } }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270394,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int>mp;\\n        for(auto w:words){\\n            for(int i=0;i<w.size();i++){\\n                mp[w[i]]++;\\n            }\\n        }\\n        for(auto m:mp){\\n            if(m.second%words.size()!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\ndo upvote if you like it",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int>mp;\\n        for(auto w:words){\\n            for(int i=0;i<w.size();i++){\\n                mp[w[i]]++;\\n            }\\n        }\\n        for(auto m:mp){\\n            if(m.second%words.size()!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270032,
                "title": "python",
                "content": "python 100% fast solution\\n```\\nclass Solution(object):\\n    def makeEqual(self, words):\\n        n=0\\n        l=[]\\n        a=\"\"\\n        m=[]\\n        t=0\\n        if len(words)==1:\\n            return True\\n        for i in range(len(words)):\\n            n=n+len(words[i])\\n            a=a+words[i]\\n            for j in range(len(words[i])):\\n                if words[i][j] not in l:\\n                    l.append(words[i][j])\\n        if n%len(words)==0:\\n            k=n/len(words)\\n            for i in range(len(l)):\\n                for d in range(len(a)):\\n                    if l[i]==a[d]:\\n                        t=t+1\\n                m.append(int(t))\\n                t=0\\n            z=m[0]\\n            for x in range(len(m)):\\n                if m[x]%len(words)!=0:\\n                    return False\\n            return True                   \\n        else:\\n            return False\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "python 100% fast solution\\n```\\nclass Solution(object):\\n    def makeEqual(self, words):\\n        n=0\\n        l=[]\\n        a=\"\"\\n        m=[]\\n        t=0\\n        if len(words)==1:\\n            return True\\n        for i in range(len(words)):\\n            n=n+len(words[i])\\n            a=a+words[i]\\n            for j in range(len(words[i])):\\n                if words[i][j] not in l:\\n                    l.append(words[i][j])\\n        if n%len(words)==0:\\n            k=n/len(words)\\n            for i in range(len(l)):\\n                for d in range(len(a)):\\n                    if l[i]==a[d]:\\n                        t=t+1\\n                m.append(int(t))\\n                t=0\\n            z=m[0]\\n            for x in range(len(m)):\\n                if m[x]%len(words)!=0:\\n                    return False\\n            return True                   \\n        else:\\n            return False\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1269764,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        s=\"\".join(words)\\n        if(len(words)==1):\\n            return True\\n        l=[i for i in s]\\n        s=list(set(l))\\n        m=len(words)\\n        for i in s:\\n            if(l.count(i)%m!=0):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        s=\"\".join(words)\\n        if(len(words)==1):\\n            return True\\n        l=[i for i in s]\\n        s=list(set(l))\\n        m=len(words)\\n        for i in s:\\n            if(l.count(i)%m!=0):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269544,
                "title": "c-straight-forward-strategy",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\nJUST COUNT ALL THE OCCURENCES OF CHARACTERS PRESENT IN ALL THE STRINGS , THEN CHECK AND DIVIDE THEIR OCCURENCES WITH SIZE OF STRINGS , IF RESULT IS NOT ZERO , THEN RETURN \" FALSE \"  ELSE RETURN TRUE\\n\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> umap;\\n        for(string s : words){\\n            for(int j=0;j<s.size();j++)\\n                umap[s[j]]++;\\n        }\\n        \\n        for(auto i=umap.begin();i!=umap.end();i++)\\n            if(i->second%words.size()!=0)return false;\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int> umap;\\n        for(string s : words){\\n            for(int j=0;j<s.size();j++)\\n                umap[s[j]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1269256,
                "title": "java-100-better-time-and-space",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] c = new int[26];\\n        for (String word: words) {\\n\\n            for (char ch: word.toCharArray()) {\\n\\n                c[ch - \\'a\\']++;\\n            }\\n        }\\n        for (int frequency: c) {\\n            if (frequency % words.length != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] c = new int[26];\\n        for (String word: words) {\\n\\n            for (char ch: word.toCharArray()) {\\n\\n                c[ch - \\'a\\']++;\\n            }\\n        }\\n        for (int frequency: c) {\\n            if (frequency % words.length != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268909,
                "title": "swift-hashmap-solution-with-explanation",
                "content": "You can move around any character at will. \\n\\nAfter all the moves, If a letter appears in one word, it should appear in every other word. If it appears x times in one word, it should appear x times in every other word.\\n\\nSo, the total count of a character in all the words should be a multiple of the number of words.\\n\\nFor example, if the number of words is 3 and the letter \\'b\\' appears a total of 3 times, it can be redistributed so that it appears exactly once in each word. If the total count of \\'b\\' were 6, the redistribution would be such that it will appear twice in each word.\\n\\nThe code follows:\\n```\\nclass Solution {\\n    func makeEqual(_ words: [String]) -> Bool {\\n        let wordCount = words.count\\n        var charCounts = [Character: Int]()\\n        \\n        for word in words {\\n            for char in word {\\n                charCounts[char, default: 0] += 1\\n            }\\n        }\\n        \\n        return charCounts.values.allSatisfy { $0.isMultiple(of: wordCount) }\\n    }\\n}\\n```\\n\\n**Time complexity**\\nFirst go through all the characters and store their counts in a dictionary. This is O(N) where N is the total number of characters. Or O(m * n) where m is the number of words and n is the average number of characters in a word.\\n\\nThen go through the values of each of the 26 characters and do a constant time check on them. This is O(1) because the number of distinct characters is finite.\\n\\n**Space complexity**\\nO(1) for the dictionary\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func makeEqual(_ words: [String]) -> Bool {\\n        let wordCount = words.count\\n        var charCounts = [Character: Int]()\\n        \\n        for word in words {\\n            for char in word {\\n                charCounts[char, default: 0] += 1\\n            }\\n        }\\n        \\n        return charCounts.values.allSatisfy { $0.isMultiple(of: wordCount) }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268684,
                "title": "golang-o-n-solution-easy-to-understand",
                "content": "```\\nfunc makeEqual(words []string) bool {\\n\\tcount := [26]int{}\\n\\tfor _, k := range words {\\n\\t\\tfor _, l := range k {\\n\\t\\t\\tcount[l-\\'a\\']++\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tif count[i]%len(words) != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc makeEqual(words []string) bool {\\n\\tcount := [26]int{}\\n\\tfor _, k := range words {\\n\\t\\tfor _, l := range k {\\n\\t\\t\\tcount[l-\\'a\\']++\\n\\t\\t}\\n\\t}\\n\\tfor i := 0; i < 26; i++ {\\n\\t\\tif count[i]%len(words) != 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268620,
                "title": "c-easy-with-hashmaps",
                "content": "```\\n  bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<char,int>mp;\\n        for(auto ele:words) for(auto c:ele)  mp[c]++;\\n        for(auto ele:mp)  if(ele.second%n!=0) return 0;\\n        return 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<char,int>mp;\\n        for(auto ele:words) for(auto c:ele)  mp[c]++;\\n        for(auto ele:mp)  if(ele.second%n!=0) return 0;\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268596,
                "title": "python-dict",
                "content": "```\\n    # Time O(N) Space O(M), N = all the chars, M = size of dict\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        size = len(words)\\n        c_dict = collections.defaultdict(int)\\n        for w in words:\\n            for c in w:\\n                c_dict[c] += 1\\n        \\n        for v in c_dict.values():\\n            if v % size != 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    # Time O(N) Space O(M), N = all the chars, M = size of dict\\n    def makeEqual(self, words: List[str]) -> bool:\\n        \\n        size = len(words)\\n        c_dict = collections.defaultdict(int)\\n        for w in words:\\n            for c in w:\\n                c_dict[c] += 1\\n        \\n        for v in c_dict.values():\\n            if v % size != 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1268526,
                "title": "c-map-easy-solution",
                "content": "Calculate the frequencies of all characters in all given strings. Now traverse on this map and check if all the frequencies are multiple of the number of strings given. If not then return false. If it\\'s coming out of loop, then return true.\\n```\\nbool makeEqual(vector<string>& w) {\\n        int m=w.size();\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                mp[w[i][j]]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second%m != 0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool makeEqual(vector<string>& w) {\\n        int m=w.size();\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                mp[w[i][j]]++;\\n            }\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.second%m != 0)\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1268507,
                "title": "python-1-line-solution",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(i%len(words)==0 for i in Counter(j for i in words for j in i).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return all(i%len(words)==0 for i in Counter(j for i in words for j in i).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268478,
                "title": "java-o-n-solution-count",
                "content": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] count = new int[26];\\n        for(String key : words){\\n            for(int i =0;i<key.length();i++){\\n                count[ key.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<count.length;i++){\\n            if(count[i]!=0 && count[i] % words.length !=0){\\n                return false;\\n            }\\n        }\\n         return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] count = new int[26];\\n        for(String key : words){\\n            for(int i =0;i<key.length();i++){\\n                count[ key.charAt(i) - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0;i<count.length;i++){\\n            if(count[i]!=0 && count[i] % words.length !=0){\\n                return false;\\n            }\\n        }\\n         return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268464,
                "title": "python3",
                "content": "class Solution:\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        h={}\\n        for i in words:\\n            for j in i:\\n                if j in h:\\n                    h[j]+=1\\n                else:\\n                    h[j]=1\\n        for i in h:\\n            if h[i]%len(words)!=0:\\n                return False\\n        return True\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def makeEqual(self, words: List[str]) -> bool:\\n        h={}",
                "codeTag": "Java"
            },
            {
                "id": 1268457,
                "title": "a-few-solutions",
                "content": "Return `true` if and only if the total count of all characters `c` of all strings `s` in `A` is evenly divisible by the cardinality of `A`.\\n\\n---\\n    \\n*Kotlin*\\n```\\nclass Solution {\\n    fun makeEqual(A: Array<String>): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        for (s in A)\\n            for (c in s)\\n                m[c] = 1 + m.getOrDefault(c, 0)\\n        return m.values.all{ it % A.size == 0 }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet makeEqual = (A, m = new Map()) => A.join(\\'\\').split(\\'\\').forEach(c => m.set(c, 1 + (m.get(c) || 0))) || [...m].map(([_, x]) => x).every(x => !(x % A.length));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def makeEqual(self, A: List[str]) -> bool:\\n        return all(x % len(A) == 0 for x in Counter(list(\\'\\'.join(A))).values())\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, int>;\\n    bool makeEqual(VS& A, Map m = {}) {\\n        for (auto& s: A)\\n            for (auto c: s)\\n                ++m[c];\\n        return all_of(m.begin(), m.end(), [&](auto& pair) {\\n            return !(pair.second % A.size());\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun makeEqual(A: Array<String>): Boolean {\\n        var m = mutableMapOf<Char, Int>()\\n        for (s in A)\\n            for (c in s)\\n                m[c] = 1 + m.getOrDefault(c, 0)\\n        return m.values.all{ it % A.size == 0 }\\n    }\\n}\\n```\n```\\nlet makeEqual = (A, m = new Map()) => A.join(\\'\\').split(\\'\\').forEach(c => m.set(c, 1 + (m.get(c) || 0))) || [...m].map(([_, x]) => x).every(x => !(x % A.length));\\n```\n```\\nclass Solution:\\n    def makeEqual(self, A: List[str]) -> bool:\\n        return all(x % len(A) == 0 for x in Counter(list(\\'\\'.join(A))).values())\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, int>;\\n    bool makeEqual(VS& A, Map m = {}) {\\n        for (auto& s: A)\\n            for (auto c: s)\\n                ++m[c];\\n        return all_of(m.begin(), m.end(), [&](auto& pair) {\\n            return !(pair.second % A.size());\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101053,
                "title": "c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<int,int> mp;\\n        for(int i=0;i<words.size();++i){\\n            string word=words[i];\\n            for(int j=0;j<word.size();++j){\\n                mp[word[j]-\\'a\\']++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.second<words.size() || x.second%words.size()!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<int,int> mp;\\n        for(int i=0;i<words.size();++i){\\n            string word=words[i];\\n            for(int j=0;j<word.size();++j){\\n                mp[word[j]-\\'a\\']++;\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.second<words.size() || x.second%words.size()!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097030,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        char ch;\\n        for(String word : words){\\n            for(int i = 0; i < word.length(); i++){\\n                ch = word.charAt(i);\\n                map.putIfAbsent(ch, 0);\\n                map.put(ch, map.get(ch) + 1);\\n            }\\n        }\\n\\n        List<Integer> values = new ArrayList<>(map.values());\\n        for(int val : values){\\n            if(val % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        HashMap<Character, Integer> map = new HashMap<>();\\n        char ch;\\n        for(String word : words){\\n            for(int i = 0; i < word.length(); i++){\\n                ch = word.charAt(i);\\n                map.putIfAbsent(ch, 0);\\n                map.put(ch, map.get(ch) + 1);\\n            }\\n        }\\n\\n        List<Integer> values = new ArrayList<>(map.values());\\n        for(int val : values){\\n            if(val % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091789,
                "title": "two-lines-solution-without-dictionary",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        s = \\'\\'.join([x for x in words])\\n        return sum([s.count(x)%len(words) for x in set(s)]) == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        s = \\'\\'.join([x for x in words])\\n        return sum([s.count(x)%len(words) for x in set(s)]) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078983,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int> alpha(26, 0);\\n\\n        for(auto i : words){\\n            for(auto j : i){\\n                alpha[j-\\'a\\']++;\\n            }\\n        }\\n        int val = 0, sz = words.size();\\n        for(int i=0; i<26; i++){\\n            if(alpha[i]%sz != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int> alpha(26, 0);\\n\\n        for(auto i : words){\\n            for(auto j : i){\\n                alpha[j-\\'a\\']++;\\n            }\\n        }\\n        int val = 0, sz = words.size();\\n        for(int i=0; i<26; i++){\\n            if(alpha[i]%sz != 0) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062843,
                "title": "optimize-solution-using-counting-algo-with-time-complexity-of-o-n-100-beats-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private void count(String word, int[] cnt){\\n        for(char ch : word.toCharArray()){\\n            cnt[ch-\\'a\\']++;\\n        }\\n    }\\n\\n    public boolean makeEqual(String[] words) {/*\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n        for(String word : words){\\n            for(char ch : word.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n                set.add(ch);\\n            }\\n        }\\n\\n        int len = words.length;\\n        for(char ch : set){\\n            if(map.get(ch)%len != 0) return false;\\n        }\\n        return true; */\\n\\n        int []cnt = new int [26];\\n        for(String word : words){\\n            count(word, cnt);\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(cnt[i]%(words.length) != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    private void count(String word, int[] cnt){\\n        for(char ch : word.toCharArray()){\\n            cnt[ch-\\'a\\']++;\\n        }\\n    }\\n\\n    public boolean makeEqual(String[] words) {/*\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n        for(String word : words){\\n            for(char ch : word.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n                set.add(ch);\\n            }\\n        }\\n\\n        int len = words.length;\\n        for(char ch : set){\\n            if(map.get(ch)%len != 0) return false;\\n        }\\n        return true; */\\n\\n        int []cnt = new int [26];\\n        for(String word : words){\\n            count(word, cnt);\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(cnt[i]%(words.length) != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062828,
                "title": "beginner-friendly-solution-using-hashtable-89-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n        for(String word : words){\\n            for(char ch : word.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n                set.add(ch);\\n            }\\n        }\\n\\n        int len = words.length;\\n        for(char ch : set){\\n            if(map.get(ch)%len != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        Set<Character> set = new HashSet<>();\\n        for(String word : words){\\n            for(char ch : word.toCharArray()){\\n                map.put(ch, map.getOrDefault(ch,0)+1);\\n                set.add(ch);\\n            }\\n        }\\n\\n        int len = words.length;\\n        for(char ch : set){\\n            if(map.get(ch)%len != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057870,
                "title": "c-self-explainatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int> characters(26, 0);\\n\\n        for (string word : words) {\\n            for (char letter : word) {\\n                characters[letter - \\'a\\'] += 1;\\n            }\\n        }\\n\\n        int amountOfWords = words.size();\\n        for (int character : characters)\\n            if (character % amountOfWords != 0) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int> characters(26, 0);\\n\\n        for (string word : words) {\\n            for (char letter : word) {\\n                characters[letter - \\'a\\'] += 1;\\n            }\\n        }\\n\\n        int amountOfWords = words.size();\\n        for (int character : characters)\\n            if (character % amountOfWords != 0) return false;\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051462,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return not any(cnt%len(words) for cnt in Counter(\"\".join(words)).values())     \\n```\\n> More readable\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        for cnt in Counter(\"\".join(words)).values():\\n            if cnt%len(words):\\n                return False\\n        return True      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        return not any(cnt%len(words) for cnt in Counter(\"\".join(words)).values())     \\n```\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        for cnt in Counter(\"\".join(words)).values():\\n            if cnt%len(words):\\n                return False\\n        return True      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044677,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to ask if it\\'s possible to redistribute characters amongst the given words in a way that each word gets an equal number of characters from the combined pool of all words. To determine this, we need to ensure that the frequency of each character across all words is divisible by the number of words. This would imply that the characters can be distributed evenly among the words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dictionary chars to keep track of the frequency of each character across all words.\\nFor each word in the given list, iterate through its characters and update their frequency in the chars dictionary.\\nAfter processing all words, iterate through the chars dictionary and check if the frequency of each character is divisible by the number of words.\\nIf any character\\'s frequency isn\\'t divisible by the number of words, return False as it won\\'t be possible to distribute the characters evenly. If all characters have frequencies divisible by the number of words, return True.\\n\\n# Complexity\\n- Time complexity: O(n x m) where n = number of words and m = average length of the word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        chars = {}\\n\\n        for w in words:\\n            for c in w:\\n                if c not in chars:\\n                    chars[c] = 1\\n                else:\\n                    chars[c] +=1\\n        for char, value in chars.items():\\n            if value % len(words) !=0:\\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        chars = {}\\n\\n        for w in words:\\n            for c in w:\\n                if c not in chars:\\n                    chars[c] = 1\\n                else:\\n                    chars[c] +=1\\n        for char, value in chars.items():\\n            if value % len(words) !=0:\\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043670,
                "title": "c-clean-code-fully-explained-solution",
                "content": "Hope you read the problem and tried to solve it on your own once. If you did great! Congratulations , If not , I will try my best to explain it here!\\n\\nYou are given an array of strings / words. \\n\\nIn this problem we can choose any two indices (i,j) and move the character from word[i] to word[j]]. \\n\\nWe can perform this opeartion any number of times. Note that we don\\'t have to print the steps , we just have to return true if all the strings in the array are equal in the end. Otherwise we return false.\\n\\nNote that for all strings to be equal , the characters in each string must be present in equal quantities. This is only possible when the count of the character is a multiple of n or the size of the array. So we can maintain a frequency array and check for the condition to solve this problem.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int>cnt(26,0);\\n        for(auto t : words) {\\n            for(auto x : t) {\\n                cnt[x-\\'a\\']++;\\n            }\\n        }\\n        int n = (int)words.size();\\n        for(int i = 0 ; i < 26 ; i++) {\\n            if(cnt[i]%n != 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<int>cnt(26,0);\\n        for(auto t : words) {\\n            for(auto x : t) {\\n                cnt[x-\\'a\\']++;\\n            }\\n        }\\n        int n = (int)words.size();\\n        for(int i = 0 ; i < 26 ; i++) {\\n            if(cnt[i]%n != 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037104,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        d = {}\\n\\n        for word in words:\\n            for char in word:\\n                if char in d:\\n                    d[char] += 1\\n                else:\\n                    d[char] = 1\\n\\n        for value in d.values():\\n            if value % len(words) != 0:\\n                return False\\n\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        d = {}\\n\\n        for word in words:\\n            for char in word:\\n                if char in d:\\n                    d[char] += 1\\n                else:\\n                    d[char] = 1\\n\\n        for value in d.values():\\n            if value % len(words) != 0:\\n                return False\\n\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997613,
                "title": "java-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] ans = new int[26];\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<words.length; i++){\\n            sb.append(words[i]);\\n        }\\n        for(int i=0; i<sb.length(); i++){\\n            ans[sb.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0 && ans[i] % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int[] ans = new int[26];\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<words.length; i++){\\n            sb.append(words[i]);\\n        }\\n        for(int i=0; i<sb.length(); i++){\\n            ans[sb.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0 && ans[i] % words.length != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984600,
                "title": "java-8-stream-api-solution-w-o-additional-variables",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        return Arrays.stream(words).\\n                      flatMap(s -> s.chars().mapToObj(c -> (char) c)).\\n                      collect(Collectors.toMap(y -> y, x -> 1, Integer::sum)).\\n                      values().\\n                      stream().\\n                      distinct().\\n                      noneMatch(i -> i % words.length != 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        return Arrays.stream(words).\\n                      flatMap(s -> s.chars().mapToObj(c -> (char) c)).\\n                      collect(Collectors.toMap(y -> y, x -> 1, Integer::sum)).\\n                      values().\\n                      stream().\\n                      distinct().\\n                      noneMatch(i -> i % words.length != 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928734,
                "title": "easy-c-beginner-friendly-solution",
                "content": "# Intuition\\nThis problem gives us an array of strings and asks us whether by moving any character from one string to any position in another string make all the strings same.\\n\\n# Approach\\n1. Use a frequency array to store the frequencies of all the characters of all the strings.\\n2. Traverse the frequency array and if any frequency of a character is not divisible by the number of strings in the array of strings, return false or else return true.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> freq(26, 0);\\n        for (auto s: words) {\\n            for (auto c: s) {\\n                freq[c-\\'a\\']++;\\n            }\\n        }\\n        for (auto i: freq) {\\n            if (i % n != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> freq(26, 0);\\n        for (auto s: words) {\\n            for (auto c: s) {\\n                freq[c-\\'a\\']++;\\n            }\\n        }\\n        for (auto i: freq) {\\n            if (i % n != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905611,
                "title": "easy-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        \\n        int[] c = new int[26];\\n        for(String s:words){\\n            for(char c1:s.toCharArray()){\\n                c[c1 - \\'a\\']++;\\n            }\\n        }\\n        for(int i:c){\\n            if((i!=0 && i%words.length!=0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        \\n        int[] c = new int[26];\\n        for(String s:words){\\n            for(char c1:s.toCharArray()){\\n                c[c1 - \\'a\\']++;\\n            }\\n        }\\n        for(int i:c){\\n            if((i!=0 && i%words.length!=0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904832,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int>ch;\\n        for(auto &word:words)\\n        {\\n            for(auto i:word)\\n            {\\n                ch[i]++;\\n            }\\n        }\\n        int n=words.size();\\n        for(auto c:ch)\\n        {\\n            if(c.second%n!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char,int>ch;\\n        for(auto &word:words)\\n        {\\n            for(auto i:word)\\n            {\\n                ch[i]++;\\n            }\\n        }\\n        int n=words.size();\\n        for(auto c:ch)\\n        {\\n            if(c.second%n!=0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896154,
                "title": "very-easy-95-95-without-hashmap-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the characters count should be multiple of n(all the strings) so that we can divide all the chars equally.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First we have to store the char\\'s count to an array or in hashmap\\n2. Then check if all char\\'s count is multiple of n.\\n\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        int count[26]={0};\\n        for(auto w:words){\\n            for(auto c:w){\\n                count[c-\\'a\\']++;\\n            }\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(count[i]%n!=0) return false;\\n        }\\n            return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        int count[26]={0};\\n        for(auto w:words){\\n            for(auto c:w){\\n                count[c-\\'a\\']++;\\n            }\\n        }\\n\\n        for(int i=0;i<26;i++){\\n            if(count[i]%n!=0) return false;\\n        }\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884389,
                "title": "solution-with-unordered-map-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        int n = words.size();\\n        for(auto word: words){\\n            for(auto x: word){\\n                mp[x]++;\\n            }\\n        }\\n        for(auto x: mp){\\n            if(x.second %  n != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        int n = words.size();\\n        for(auto word: words){\\n            for(auto x: word){\\n                mp[x]++;\\n            }\\n        }\\n        for(auto x: mp){\\n            if(x.second %  n != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878077,
                "title": "jebas-raja-veryeasy",
                "content": "# Intuition::KARUNYA UNIVERSITY::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) \\n    {\\n        \\nint[] atoz=new int[27];\\nint check=0;\\n\\nfor (int i=0;i<words.length;i++)\\n{\\n  for (int j=0;j<words[i].length();j++)\\n  {\\n    // System.out.print(words[i].charAt(j)+\" \");   \\n    \\n    atoz[words[i].charAt(j)-96]++; \\n    check=words[i].charAt(j);\\n  }\\n  //System.out.println();\\n}\\n\\nfor (int t=1;t<atoz.length;t++)\\n{\\n    //System.out.println(t+\" \"+atoz[t]);\\n    if (atoz[t]%words.length!=0)\\n    {\\n        //System.out.println(\"false\");\\n        return false;\\n    }\\n}\\n\\n//System.out.println(\"true\");\\nreturn true;\\n\\t}\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) \\n    {\\n        \\nint[] atoz=new int[27];\\nint check=0;\\n\\nfor (int i=0;i<words.length;i++)\\n{\\n  for (int j=0;j<words[i].length();j++)\\n  {\\n    // System.out.print(words[i].charAt(j)+\" \");   \\n    \\n    atoz[words[i].charAt(j)-96]++; \\n    check=words[i].charAt(j);\\n  }\\n  //System.out.println();\\n}\\n\\nfor (int t=1;t<atoz.length;t++)\\n{\\n    //System.out.println(t+\" \"+atoz[t]);\\n    if (atoz[t]%words.length!=0)\\n    {\\n        //System.out.println(\"false\");\\n        return false;\\n    }\\n}\\n\\n//System.out.println(\"true\");\\nreturn true;\\n\\t}\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873578,
                "title": "c-map-easy",
                "content": "# Complexity\\n- Time complexity:$$O(TotalNumberOfCharactersInAllWords)$$\\n\\n- Space complexity:$$O(NumberOfUniqueCharactersInAllWords)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<char , int> mp;\\n\\n        for(auto child : words){\\n            for(auto c : child){\\n                mp[c]++;\\n            }\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second % n != 0){\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n = words.size();\\n        unordered_map<char , int> mp;\\n\\n        for(auto child : words){\\n            for(auto c : child){\\n                mp[c]++;\\n            }\\n        }\\n        \\n        for(auto it : mp){\\n            if(it.second % n != 0){\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840300,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int len = words.length;\\n\\n        for (String s: words)\\n            for (int i = 0; i < s.length(); ++i)\\n                map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)+1);\\n            \\n\\n        for (Character key: map.keySet()) \\n            if (map.get(key) % len != 0)\\n                return false;\\n\\n        //upvote if helpful\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int len = words.length;\\n\\n        for (String s: words)\\n            for (int i = 0; i < s.length(); ++i)\\n                map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0)+1);\\n            \\n\\n        for (Character key: map.keySet()) \\n            if (map.get(key) % len != 0)\\n                return false;\\n\\n        //upvote if helpful\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832997,
                "title": "easy-to-understand-and-fast-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        str = \\'\\'.join(words)\\n        for key, value in collections.Counter(str).items():\\n            if value % len(words) != 0:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        str = \\'\\'.join(words)\\n        for key, value in collections.Counter(str).items():\\n            if value % len(words) != 0:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832852,
                "title": "easy-solution-java-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse a HashMap for frequency measure\\nAnd frequency of all the characters must be Integral Multiple of length of the String Array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int n = words.length;\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<words[i].length(); j++){\\n                char ch = words[i].charAt(j);\\n                if(hm.containsKey(ch)){\\n                    hm.put(ch, hm.get(ch)+1);\\n                }\\n                else{\\n                    hm.put(ch, 1);\\n                }\\n            }\\n        }\\n        for(int e : hm.values()){\\n            if(e%n != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int n = words.length;\\n        HashMap<Character, Integer> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<words[i].length(); j++){\\n                char ch = words[i].charAt(j);\\n                if(hm.containsKey(ch)){\\n                    hm.put(ch, hm.get(ch)+1);\\n                }\\n                else{\\n                    hm.put(ch, 1);\\n                }\\n            }\\n        }\\n        for(int e : hm.values()){\\n            if(e%n != 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808018,
                "title": "simple-and-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1] Count the occurences of individual characters in the entire words array.\\n2] Check whether occurence of each letter can be divided among words.size() no. of words.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void mp(string s,int *ar){\\n        for(auto &i : s) ar[i - \\'a\\']++;\\n    }\\n\\n    bool makeEqual(vector<string>& words) {\\n        // mapping all letters for all words\\n        int ar[26] = {0};\\n        int n = words.size();\\n        if (n == 1) return true;\\n\\n        for(auto &i : words){\\n            // mapping individual words\\n            mp(i,ar);\\n        }\\n\\n        // our ability to make every word equal depends\\n        // whether we have equal number of unique chars present \\n        // in all words\\n        for(int i=0;i<26;i++){\\n            // if(ar[i] == 1) return false;\\n            if(ar[i] && ar[i] % n != 0) return false;\\n            // else if(ar[i] > 1&& !prev) prev = ar[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void mp(string s,int *ar){\\n        for(auto &i : s) ar[i - \\'a\\']++;\\n    }\\n\\n    bool makeEqual(vector<string>& words) {\\n        // mapping all letters for all words\\n        int ar[26] = {0};\\n        int n = words.size();\\n        if (n == 1) return true;\\n\\n        for(auto &i : words){\\n            // mapping individual words\\n            mp(i,ar);\\n        }\\n\\n        // our ability to make every word equal depends\\n        // whether we have equal number of unique chars present \\n        // in all words\\n        for(int i=0;i<26;i++){\\n            // if(ar[i] == 1) return false;\\n            if(ar[i] && ar[i] % n != 0) return false;\\n            // else if(ar[i] > 1&& !prev) prev = ar[i];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802663,
                "title": "easy-acceptable-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string str=words[i];\\n            for(int j=0; j<str.length(); j++)\\n                mp[str[j]]++;\\n        }\\n        int n=words.size();\\n        for(auto i: mp)\\n        {\\n            if(i.second%n!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string str=words[i];\\n            for(int j=0; j<str.length(); j++)\\n                mp[str[j]]++;\\n        }\\n        int n=words.size();\\n        for(auto i: mp)\\n        {\\n            if(i.second%n!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794975,
                "title": "java-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean makeEqual(String[] words) {\\n\\t\\t\\tint[] counter = new int[26];\\n\\n\\t\\t\\tfor(String w: words){\\n\\t\\t\\t\\tfor(char ch: w.toCharArray()){\\n\\t\\t\\t\\t\\tcounter[ch -\\'a\\']++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// the frequencies of the alphabets should exactly be words.length(), if not then return false\\n\\t\\t\\tfor(int i=0; i<counter.length; i++){\\n\\t\\t\\t\\tif(counter[i] % words.length != 0) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean makeEqual(String[] words) {\\n\\t\\t\\tint[] counter = new int[26];\\n\\n\\t\\t\\tfor(String w: words){\\n\\t\\t\\t\\tfor(char ch: w.toCharArray()){\\n\\t\\t\\t\\t\\tcounter[ch -\\'a\\']++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3775399,
                "title": "dart-count",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  bool makeEqual(List<String> words) {\\n    final count = List.filled(128, 0);\\n    for (final word in words) {\\n      for (int i = 0; i < word.length; i++)\\n        count[word.codeUnitAt(i)]++;\\n    }\\n    for (final v in count)\\n      if (v % words.length != 0)\\n        return false;\\n    return true;\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool makeEqual(List<String> words) {\\n    final count = List.filled(128, 0);\\n    for (final word in words) {\\n      for (int i = 0; i < word.length; i++)\\n        count[word.codeUnitAt(i)]++;\\n    }\\n    for (final v in count)\\n      if (v % words.length != 0)\\n        return false;\\n    return true;\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774453,
                "title": "redistribute-characters-to-make-all-strings-equal-easiest-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        vector<int> alphabet(26,0);\\n        \\n        int length =(int)words.size();\\n        for(auto s : words) \\n        {\\n            for(auto c : s) \\n            {\\n                alphabet[c - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0; i<alphabet.size(); i++) \\n        \\n        {\\n            if(alphabet[i] % length !=0) \\n            {\\n                return false;\\n            } \\n        }\\n        return true;    \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        vector<int> alphabet(26,0);\\n        \\n        int length =(int)words.size();\\n        for(auto s : words) \\n        {\\n            for(auto c : s) \\n            {\\n                alphabet[c - \\'a\\']++;\\n            }\\n        }\\n        \\n        for(int i=0; i<alphabet.size(); i++) \\n        \\n        {\\n            if(alphabet[i] % length !=0) \\n            {\\n                return false;\\n            } \\n        }\\n        return true;    \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772470,
                "title": "shortest-and-easiest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>&w){\\n        unordered_map<char,int>mp;\\n        for(auto i:w){\\n            for(auto j:i){\\n                mp[j]++;\\n            }\\n        }\\n        for(auto i:mp){\\n            if(i.second%w.size()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>&w){\\n        unordered_map<char,int>mp;\\n        for(auto i:w){\\n            for(auto j:i){\\n                mp[j]++;\\n            }\\n        }\\n        for(auto i:mp){\\n            if(i.second%w.size()){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771799,
                "title": "python-collections-counter-clean-solution",
                "content": "Count all letters and ensure each letter total is divisible by the number of words.\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counts = Counter(\\'\\'.join(words))\\n        return all( count % len(words) == 0 for count in counts.values() )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counts = Counter(\\'\\'.join(words))\\n        return all( count % len(words) == 0 for count in counts.values() )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764606,
                "title": "redistribute-characters-to-make-all-strings-equal-using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char, int> m;\\n        if(words.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                m[words[i][j]]++;\\n            }\\n        }\\n        set<int> s;\\n        map<char, int>::iterator it;\\n        int size=words.size();\\n        for(it=m.begin();it!=m.end();it++){\\n            if(((*it).second)%(size)!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        map<char, int> m;\\n        if(words.size()==1){\\n            return 1;\\n        }\\n        for(int i=0;i<words.size();i++){\\n            for(int j=0;j<words[i].size();j++){\\n                m[words[i][j]]++;\\n            }\\n        }\\n        set<int> s;\\n        map<char, int>::iterator it;\\n        int size=words.size();\\n        for(it=m.begin();it!=m.end();it++){\\n            if(((*it).second)%(size)!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760546,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] w) {\\n         if(1==w.length){\\n                return true;\\n            }\\n         Map<Character,Integer> m=new HashMap<>();\\n         for(String s:w){\\n        for(char c:s.toCharArray())\\n        {\\n           if(!m.containsKey(c)){\\n               m.put(c,1);\\n           }\\n           else{\\n               m.put(c,m.get(c)+1);\\n           }\\n        }\\n         }\\n        //int y=m.get(s.charAt(0));\\n        for(char c:m.keySet()){\\n            int p=m.get(c);\\n            if(0!=p%w.length){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] w) {\\n         if(1==w.length){\\n                return true;\\n            }\\n         Map<Character,Integer> m=new HashMap<>();\\n         for(String s:w){\\n        for(char c:s.toCharArray())\\n        {\\n           if(!m.containsKey(c)){\\n               m.put(c,1);\\n           }\\n           else{\\n               m.put(c,m.get(c)+1);\\n           }\\n        }\\n         }\\n        //int y=m.get(s.charAt(0));\\n        for(char c:m.keySet()){\\n            int p=m.get(c);\\n            if(0!=p%w.length){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756126,
                "title": "easy-way-to-solve-in-python",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        k=\"\".join(words)\\n        a=list(set(k))\\n        b=len(words)\\n        if b==1:\\n            return True\\n        for i in a:\\n            if k.count(i)%b!=0:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        k=\"\".join(words)\\n        a=list(set(k))\\n        b=len(words)\\n        if b==1:\\n            return True\\n        for i in a:\\n            if k.count(i)%b!=0:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748450,
                "title": "python-simple-solution-hashset-counting",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n      joint = \\'\\'.join(words)\\n      unique = set(joint)\\n      n = len(words)\\n      for i in unique:\\n        if joint.count(i) % n != 0:\\n          return False\\n      return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n      joint = \\'\\'.join(words)\\n      unique = set(joint)\\n      n = len(words)\\n      for i in unique:\\n        if joint.count(i) % n != 0:\\n          return False\\n      return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742739,
                "title": "check-if-all-strings-can-be-made-equal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n        Dictionary<char, int> charFrq = new Dictionary<char, int>();\\n        for(int i = 0; i<words.Length; i++){\\n            for(int j=0; j<words[i].Length; j++){\\n                if(charFrq.ContainsKey(words[i][j])){\\n                    charFrq[words[i][j]] += 1;\\n                }\\n                else{\\n                    charFrq.Add(words[i][j], 1);\\n                }\\n            }\\n        }\\n        foreach(char c in charFrq.Keys){\\n            if(charFrq[c]%words.Length != 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n        Dictionary<char, int> charFrq = new Dictionary<char, int>();\\n        for(int i = 0; i<words.Length; i++){\\n            for(int j=0; j<words[i].Length; j++){\\n                if(charFrq.ContainsKey(words[i][j])){\\n                    charFrq[words[i][j]] += 1;\\n                }\\n                else{\\n                    charFrq.Add(words[i][j], 1);\\n                }\\n            }\\n        }\\n        foreach(char c in charFrq.Keys){\\n            if(charFrq[c]%words.Length != 0){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741256,
                "title": "char-hashing-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n    int c=0;\\n   \\n    // for(int i=0;i<words.size();i++){\\n    //     c+=words[i].size();\\n    // }\\n    // if(c%words.size()==0){\\n    //     return true;\\n    // }\\n    // return false;\\n    // }\\n     // frequency count hashmap\\n     unordered_map<char,int>m;\\n     int h[26]={0};\\n     for(int i=0;i<words.size();i++){\\n         for(auto j:words[i]){\\n             h[j-\\'a\\']++;\\n         }\\n     }\\n     for(int i=0;i<26;i++){\\n         if(h[i]==0)continue;\\n         if(h[i]%words.size()!=0){\\n             return false;\\n         }\\n\\n     }\\n\\n     return true;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n    int c=0;\\n   \\n    // for(int i=0;i<words.size();i++){\\n    //     c+=words[i].size();\\n    // }\\n    // if(c%words.size()==0){\\n    //     return true;\\n    // }\\n    // return false;\\n    // }\\n     // frequency count hashmap\\n     unordered_map<char,int>m;\\n     int h[26]={0};\\n     for(int i=0;i<words.size();i++){\\n         for(auto j:words[i]){\\n             h[j-\\'a\\']++;\\n         }\\n     }\\n     for(int i=0;i<26;i++){\\n         if(h[i]==0)continue;\\n         if(h[i]%words.size()!=0){\\n             return false;\\n         }\\n\\n     }\\n\\n     return true;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740375,
                "title": "c-1000-easiest-solution-for-begineers-using-hashmap",
                "content": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n       \\n        if(words.size()==1)\\n            return true;    // if only 1 word is present in the vector array\\n        \\n        unordered_map<char,int>mp;\\n        for(auto i:words)\\n        {                  // iterate through all the words\\n            for( auto x:i)\\n            {           // iterate through all the letters of each word\\n                mp[x]++;\\n            }   // add frequency of each letter like <char,int > for eg ( a, its frequency ) in the map\\n        }\\n        // after storing frequency of each letter in map\\n   for(auto k:mp)\\n   {            // iterate through the map\\n       if(k.second % words.size()!=0)\\n               // check if  a, b,c has occurence which is equally distributable to all words\\n           \\n           // so we check if a ,b,c has frequency equally distributable\\n           // if not return f\\n           return false;\\n   }\\n        // if nothing returns then return t\\n        return true;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n       \\n        if(words.size()==1)\\n            return true;    // if only 1 word is present in the vector array\\n        \\n        unordered_map<char,int>mp;\\n        for(auto i:words)\\n        {                  // iterate through all the words\\n            for( auto x:i)\\n            {           // iterate through all the letters of each word\\n                mp[x]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3732666,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m), where n is the number of words in the input vector words and m is the average length of the words\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++) mp[words[i][j]]++;\\n        }\\n        for(auto it:mp) if(it.second%words.size()!=0) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        unordered_map<char, int> mp;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++) mp[words[i][j]]++;\\n        }\\n        for(auto it:mp) if(it.second%words.size()!=0) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727225,
                "title": "easy-solutions-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int cnt[]=new int[26];\\n        for(String w:words){\\n            for(char c:w.toCharArray())cnt[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0&&cnt[i]%words.length!=0)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        int cnt[]=new int[26];\\n        for(String w:words){\\n            for(char c:w.toCharArray())cnt[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(cnt[i]!=0&&cnt[i]%words.length!=0)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717167,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n           if len(words) == 1:\\n               return True\\n           word = \\'\\'.join(words)\\n           con = Counter(word)\\n           for i in con.values():\\n               if i % len(words)!=0:\\n                   return False\\n           return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n           if len(words) == 1:\\n               return True\\n           word = \\'\\'.join(words)\\n           con = Counter(word)\\n           for i in con.values():\\n               if i % len(words)!=0:\\n                   return False\\n           return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703716,
                "title": "make-the-strings-equal-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe actually don\\'t need to transform strings by moving characters.\\nEach characters should be present in multiple of length of array. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach for this question is simple by using unordered map,to learn more see the code \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), where N is the number of all characters in the strings \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M), where M is the size of unique characters\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<char,int>m;\\n        for(auto str:words){\\n            for(auto chara:str){\\n                m[chara]++;\\n            }\\n        }\\n\\n        for(auto pair:m){\\n            if(pair.second %n!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int n=words.size();\\n        unordered_map<char,int>m;\\n        for(auto str:words){\\n            for(auto chara:str){\\n                m[chara]++;\\n            }\\n        }\\n\\n        for(auto pair:m){\\n            if(pair.second %n!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700373,
                "title": "dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  bool makeEqual(List<String> words) {\\n    int n = words.length;\\n    Map<String, int> countMap = {};\\n\\n    for (String word in words) {\\n      for (int i = 0; i < word.length; i++) {\\n        String ch = word[i];\\n        countMap[ch] = (countMap[ch] ?? 0) + 1;\\n      }\\n    }\\n\\n    for (int count in countMap.values) {\\n      if (count % n != 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool makeEqual(List<String> words) {\\n    int n = words.length;\\n    Map<String, int> countMap = {};\\n\\n    for (String word in words) {\\n      for (int i = 0; i < word.length; i++) {\\n        String ch = word[i];\\n        countMap[ch] = (countMap[ch] ?? 0) + 1;\\n      }\\n    }\\n\\n    for (int count in countMap.values) {\\n      if (count % n != 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698531,
                "title": "c-solution-explained-only-loops-and-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nadd every single character in each word into one array. Sort the array, store the frequency of each character into another array. Iterate over the array of frequencies and check if each frequency of each character is divisible by the amount of words present in the input array. If there are any leftover characters during division, this means that character will get left out after equal redistribution of characters, so return false. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<char> ch;\\n        for (string word : words)\\n        {\\n            for (char c : word)\\n            {\\n                ch.push_back(c);\\n            }\\n        }\\n\\n        if (ch.size() % words.size() != 0)\\n        {\\n            return false;\\n        }\\n\\n        sort(ch.begin(), ch.end());\\n\\n        int count = 1;\\n        vector<int> counts;\\n\\n        for (int i = 1; i < ch.size(); i++)\\n        {\\n            if (ch[i-1] == ch[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                counts.push_back(count);\\n                count = 1;\\n            }\\n        }\\n\\n        for (int n : counts)\\n        {\\n            if (n%words.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        vector<char> ch;\\n        for (string word : words)\\n        {\\n            for (char c : word)\\n            {\\n                ch.push_back(c);\\n            }\\n        }\\n\\n        if (ch.size() % words.size() != 0)\\n        {\\n            return false;\\n        }\\n\\n        sort(ch.begin(), ch.end());\\n\\n        int count = 1;\\n        vector<int> counts;\\n\\n        for (int i = 1; i < ch.size(); i++)\\n        {\\n            if (ch[i-1] == ch[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                counts.push_back(count);\\n                count = 1;\\n            }\\n        }\\n\\n        for (int n : counts)\\n        {\\n            if (n%words.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689358,
                "title": "my-shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& v) {\\n        int n=v.size();\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<v[i].size();j++)mp[v[i][j]]++;\\n        }\\n        vector<int>p;\\n        for(auto i:mp)p.push_back(i.second);\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]%n!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& v) {\\n        int n=v.size();\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<v.size();i++){\\n            for(int j=0;j<v[i].size();j++)mp[v[i][j]]++;\\n        }\\n        vector<int>p;\\n        for(auto i:mp)p.push_back(i.second);\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]%n!=0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681487,
                "title": "js-runtime-74-ms-beats-90",
                "content": "# Intuition\\nBuild Hash table to count letters and divide the toal for each char by the number of words.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n\\n    var l = words.length\\n    var obj = {}\\n    for (var i = 0; i<l; i++){\\n        var w = words[i]\\n        for (var j = 0; j<w.length; j++){\\n            var c = w[j]\\n\\n            if(obj[c]){\\n                obj[c]++\\n            }else{\\n                obj[c]=1\\n            }\\n        }\\n    }\\n\\n    var kk = Object.keys(obj);\\n    \\n    for (var k = 0; k<kk.length; k++){\\n        var bool = obj[kk[k]]%l==0 || l == 1\\n        if(!bool){return false}\\n    }\\n\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n\\n    var l = words.length\\n    var obj = {}\\n    for (var i = 0; i<l; i++){\\n        var w = words[i]\\n        for (var j = 0; j<w.length; j++){\\n            var c = w[j]\\n\\n            if(obj[c]){\\n                obj[c]++\\n            }else{\\n                obj[c]=1\\n            }\\n        }\\n    }\\n\\n    var kk = Object.keys(obj);\\n    \\n    for (var k = 0; k<kk.length; k++){\\n        var bool = obj[kk[k]]%l==0 || l == 1\\n        if(!bool){return false}\\n    }\\n\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666027,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport scala.collection.mutable\\n\\nobject Solution {\\ndef makeEqual(words: Array[String]): Boolean = {\\n  val frequencyMap: mutable.Map[Char, Int] = mutable.Map.empty[Char, Int]\\n\\n    if(words.length == 1){\\n        return true\\n    }\\n  for (word <- words) {\\n    for (char <- word) {\\n      frequencyMap(char) = frequencyMap.getOrElse(char, 0) + 1\\n    }\\n  }\\n\\n  frequencyMap.foreach { case (key, value) =>\\n    println(s\"Key: $key, Value: $value\")\\n    if (value%words.length != 0) {\\n      return false\\n    }\\n  }\\n\\n  true\\n}\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\ndef makeEqual(words: Array[String]): Boolean = {\\n  val frequencyMap: mutable.Map[Char, Int] = mutable.Map.empty[Char, Int]\\n\\n    if(words.length == 1){\\n        return true\\n    }\\n  for (word <- words) {\\n    for (char <- word) {\\n      frequencyMap(char) = frequencyMap.getOrElse(char, 0) + 1\\n    }\\n  }\\n\\n  frequencyMap.foreach { case (key, value) =>\\n    println(s\"Key: $key, Value: $value\")\\n    if (value%words.length != 0) {\\n      return false\\n    }\\n  }\\n\\n  true\\n}\\n}\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3658066,
                "title": "python-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = Counter(\\'\\'.join(words))\\n\\n        for v in freq.values():\\n            if v % len(words) != 0:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        freq = Counter(\\'\\'.join(words))\\n\\n        for v in freq.values():\\n            if v % len(words) != 0:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655981,
                "title": "c-time-o-mn-and-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if each character can distributed evenly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(mn) where m is the length of each word and n is the length of words array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n\\n        if (words.Length < 2)\\n            return true;\\n\\n        int[] charMap = new int[26];\\n\\n        foreach(string word in words)\\n        {\\n            foreach(char c in word)\\n            {\\n                charMap[c - \\'a\\']++;\\n            }\\n        }\\n\\n        foreach(int count in charMap)\\n        {\\n            if (count % words.Length != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool MakeEqual(string[] words) {\\n\\n        if (words.Length < 2)\\n            return true;\\n\\n        int[] charMap = new int[26];\\n\\n        foreach(string word in words)\\n        {\\n            foreach(char c in word)\\n            {\\n                charMap[c - \\'a\\']++;\\n            }\\n        }\\n\\n        foreach(int count in charMap)\\n        {\\n            if (count % words.Length != 0)\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632131,
                "title": "simple-python-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counter = Counter(i for i in \\'\\'.join(words))\\n        \\n        for val in counter.values():\\n            if val % len(words) != 0 :\\n                return False \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        counter = Counter(i for i in \\'\\'.join(words))\\n        \\n        for val in counter.values():\\n            if val % len(words) != 0 :\\n                return False \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618828,
                "title": "redistribute-characters-to-make-all-strings-equal-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int i, j;\\n        unordered_map<char,int> m;\\n        if(words.size()==1)\\n            return true;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                m[words[i][j]]++;\\n            }\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second%words.size()!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b7e7f6d5-11f5-4f07-a397-3f5adc5ffc84_1686327285.3286014.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int i, j;\\n        unordered_map<char,int> m;\\n        if(words.size()==1)\\n            return true;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            for(j=0 ; j<words[i].length() ; j++)\\n            {\\n                m[words[i][j]]++;\\n            }\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second%words.size()!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606491,
                "title": "python-counter-functional-approach",
                "content": "```\\nfrom collections import Counter\\nfrom typing import List\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        word_count = len(words)\\n        concat = \"\".join(words)\\n        \\n        letter_count = Counter(concat)\\n        \\n        vals = letter_count.values()\\n        test_mods = [ True if el % word_count == 0 else False for el in vals ]\\n        return all(test_mods)\\n        \\n \\nsol = Solution()\\nassert sol.makeEqual( words = [\"abc\",\"aabc\",\"bc\"] ) == True\\nassert sol.makeEqual( words = [\"ab\",\"a\"] ) == False\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom typing import List\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        word_count = len(words)\\n        concat = \"\".join(words)\\n        \\n        letter_count = Counter(concat)\\n        \\n        vals = letter_count.values()\\n        test_mods = [ True if el % word_count == 0 else False for el in vals ]\\n        return all(test_mods)\\n        \\n \\nsol = Solution()\\nassert sol.makeEqual( words = [\"abc\",\"aabc\",\"bc\"] ) == True\\nassert sol.makeEqual( words = [\"ab\",\"a\"] ) == False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583738,
                "title": "counter-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        char_counts = Counter(\\'\\'.join(words))  # Count the frequency of each character\\n        for count in char_counts.values():\\n            if count % len(words) != 0:\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        char_counts = Counter(\\'\\'.join(words))  # Count the frequency of each character\\n        for count in char_counts.values():\\n            if count % len(words) != 0:\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573896,
                "title": "easy-c-no-nested-loop-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        string giantWord=\"\";\\n        unordered_map<char,int> mp;\\n        int n=words.size();\\n        \\n        //return true if less than 2 length\\n        if(n<2) return true;\\n        \\n        //combining vector of strings into string\\n        for(int i=0;i<words.size();i++)\\n            giantWord.append(words[i]);\\n        \\n        //calculating frequency of each character\\n        for(int i=0;i<giantWord.size();i++) mp[giantWord[i]]++;\\n        \\n        //check if strings can be distributed\\n        for(auto i:mp) if(i.second%n!=0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        string giantWord=\"\";\\n        unordered_map<char,int> mp;\\n        int n=words.size();\\n        \\n        //return true if less than 2 length\\n        if(n<2) return true;\\n        \\n        //combining vector of strings into string\\n        for(int i=0;i<words.size();i++)\\n            giantWord.append(words[i]);\\n        \\n        //calculating frequency of each character\\n        for(int i=0;i<giantWord.size();i++) mp[giantWord[i]]++;\\n        \\n        //check if strings can be distributed\\n        for(auto i:mp) if(i.second%n!=0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570819,
                "title": "kotlin-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun makeEqual(words: Array<String>): Boolean {\\n        val charCount = IntArray(26)\\n        for (word in words) {\\n            for (ch in word) {\\n                charCount[ch - \\'a\\']++\\n            }\\n        }\\n\\n        for (count in charCount) {\\n            if (count % words.size != 0) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun makeEqual(words: Array<String>): Boolean {\\n        val charCount = IntArray(26)\\n        for (word in words) {\\n            for (ch in word) {\\n                charCount[ch - \\'a\\']++\\n            }\\n        }\\n\\n        for (count in charCount) {\\n            if (count % words.size != 0) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557116,
                "title": "solution-using-frequency-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        #Create a frequency list that shows the count of letters from all words\\n        #Take remainder each element in frequency list by length of words list\\n            #If all operations yield 0, then everything can be distributed evenly\\n            #If not, return False\\n        freq = [0]*26\\n\\n        for word in words:\\n            for ch in word:\\n                freq[ord(ch)-97]+=1\\n\\n        wordsLength = len(words)\\n        for num in freq:\\n            if num%wordsLength!=0:\\n                return False\\n        return True \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        #Create a frequency list that shows the count of letters from all words\\n        #Take remainder each element in frequency list by length of words list\\n            #If all operations yield 0, then everything can be distributed evenly\\n            #If not, return False\\n        freq = [0]*26\\n\\n        for word in words:\\n            for ch in word:\\n                freq[ord(ch)-97]+=1\\n\\n        wordsLength = len(words)\\n        for num in freq:\\n            if num%wordsLength!=0:\\n                return False\\n        return True \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510838,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int cnt[26] = {0};\\n        for(int i = 0; i < words.size(); ++i){\\n            for(int j = 0; j < words[i].size(); ++j){\\n                cnt[words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        for(int i = 0; i < 26; ++i){\\n            if(cnt[i]%words.size()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool makeEqual(vector<string>& words) {\\n        int cnt[26] = {0};\\n        for(int i = 0; i < words.size(); ++i){\\n            for(int j = 0; j < words[i].size(); ++j){\\n                cnt[words[i][j]-\\'a\\']++;\\n            }\\n        }\\n        for(int i = 0; i < 26; ++i){\\n            if(cnt[i]%words.size()) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503091,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n    \\t\\n    \\tHashMap<Character,Integer> map = new HashMap<>();\\n    \\t\\n    \\tfor(int i=0;i<words.length;i++) {\\n    \\t\\tfor(int j=0;j<words[i].length();j++) {\\n    \\t\\t\\tmap.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n    \\t\\t}\\n    \\t}\\n    \\t\\tfor(int i:map.values()) {\\n    \\t\\t\\tif(i % words.length != 0) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n    \\t\\n    \\tHashMap<Character,Integer> map = new HashMap<>();\\n    \\t\\n    \\tfor(int i=0;i<words.length;i++) {\\n    \\t\\tfor(int j=0;j<words[i].length();j++) {\\n    \\t\\t\\tmap.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n    \\t\\t}\\n    \\t}\\n    \\t\\tfor(int i:map.values()) {\\n    \\t\\t\\tif(i % words.length != 0) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493095,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun makeEqual(words: Array<String>): Boolean {\\n        val (n, arr) = Pair(words.size, IntArray(26))\\n        for (word in words) for (char in word) arr[char - \\'a\\']++\\n        for (freq in arr) if (freq % n != 0) return false\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun makeEqual(words: Array<String>): Boolean {\\n        val (n, arr) = Pair(words.size, IntArray(26))\\n        for (word in words) for (char in word) arr[char - \\'a\\']++\\n        for (freq in arr) if (freq % n != 0) return false\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484833,
                "title": "python3-collections-counter-based-solution-beats-95-50-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        n = len(words)\\n        d = Counter(\\'\\'.join(words))\\n        for v in d.values():\\n            if v % n:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def makeEqual(self, words: List[str]) -> bool:\\n        n = len(words)\\n        d = Counter(\\'\\'.join(words))\\n        for v in d.values():\\n            if v % n:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483002,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    const count = words.length\\n    let map = {}\\n\\n    for (const word of words) \\n      for (const char of word) \\n        map[char] ? map[char]++ : map[char] = 1\\n    \\n    for (const number of Object.values(map))\\n      if (number % count !== 0) \\n        return false\\n\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar makeEqual = function(words) {\\n    const count = words.length\\n    let map = {}\\n\\n    for (const word of words) \\n      for (const char of word) \\n        map[char] ? map[char]++ : map[char] = 1\\n    \\n    for (const number of Object.values(map))\\n      if (number % count !== 0) \\n        return false\\n\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3481311,
                "title": "c-easy-approach-use-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <unordered_map>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        if (words.size() == 1)\\n        {\\n            return true;\\n        }\\n        unordered_map<char, int> _map {};\\n        for (string str: words)\\n        {\\n            for (size_t i=0; i<str.length(); ++i)\\n            {\\n                _map[str[i]]++;\\n            }\\n        }\\n\\n        for (auto p: _map)\\n        {\\n            if (p.second % words.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\n#include <unordered_map>\\n#include <string>\\n\\nusing namespace std;\\n\\nclass Solution \\n{\\npublic:\\n    bool makeEqual(vector<string>& words) \\n    {\\n        if (words.size() == 1)\\n        {\\n            return true;\\n        }\\n        unordered_map<char, int> _map {};\\n        for (string str: words)\\n        {\\n            for (size_t i=0; i<str.length(); ++i)\\n            {\\n                _map[str[i]]++;\\n            }\\n        }\\n\\n        for (auto p: _map)\\n        {\\n            if (p.second % words.size() != 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1730929,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "In order to make strings equal, we only need to make sure all letters present in the array can be \"evenly distributed\"."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "yes , but I wonder what if Q demands to show steps :\")"
                    },
                    {
                        "username": "_ro_",
                        "content": "Test case 1: [\"a\",\"b\"]   ->   output: False \\nTest case 2: [\"b\"]         ->   output: True \\n\\nWhy?\\n"
                    },
                    {
                        "username": "_ro_",
                        "content": "[@DamianIvanochko](/DamianIvanochko) thanks"
                    },
                    {
                        "username": "oaaees",
                        "content": "I was also confused until I realized is not only length-equal but character-equal too."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, although characters are distributed equally they are different in first test case, in the second test case there is only one character, so he is already distributed equally and there are no different characters, hope this answers your question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Does anyone know how to run this code faster?\\n\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        int j = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            while(j < words[i].length()) {\\n                map.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n                j++;\\n            }\\n\\n            j = 0;\\n        }\\n\\n        for(var key : map.keySet()) {\\n            int freq = map.get(key);\\n            if(freq % words.length != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI want to run it in O(n) instead on n^2\\n"
                    },
                    {
                        "username": "dinesh2912",
                        "content": "import random\\nclass Solution:\\n    def makeEqual(self, words: List[str]):\\n        booo=\"True\"\\n        sol=random.randint(0,1)\\n        if sol==0:\\n            return True\\n        else :\\n            return False\\n        return booo"
                    }
                ]
            },
            {
                "id": 2038189,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "In order to make strings equal, we only need to make sure all letters present in the array can be \"evenly distributed\"."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "yes , but I wonder what if Q demands to show steps :\")"
                    },
                    {
                        "username": "_ro_",
                        "content": "Test case 1: [\"a\",\"b\"]   ->   output: False \\nTest case 2: [\"b\"]         ->   output: True \\n\\nWhy?\\n"
                    },
                    {
                        "username": "_ro_",
                        "content": "[@DamianIvanochko](/DamianIvanochko) thanks"
                    },
                    {
                        "username": "oaaees",
                        "content": "I was also confused until I realized is not only length-equal but character-equal too."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, although characters are distributed equally they are different in first test case, in the second test case there is only one character, so he is already distributed equally and there are no different characters, hope this answers your question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Does anyone know how to run this code faster?\\n\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        int j = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            while(j < words[i].length()) {\\n                map.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n                j++;\\n            }\\n\\n            j = 0;\\n        }\\n\\n        for(var key : map.keySet()) {\\n            int freq = map.get(key);\\n            if(freq % words.length != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI want to run it in O(n) instead on n^2\\n"
                    },
                    {
                        "username": "dinesh2912",
                        "content": "import random\\nclass Solution:\\n    def makeEqual(self, words: List[str]):\\n        booo=\"True\"\\n        sol=random.randint(0,1)\\n        if sol==0:\\n            return True\\n        else :\\n            return False\\n        return booo"
                    }
                ]
            },
            {
                "id": 2023947,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "In order to make strings equal, we only need to make sure all letters present in the array can be \"evenly distributed\"."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "yes , but I wonder what if Q demands to show steps :\")"
                    },
                    {
                        "username": "_ro_",
                        "content": "Test case 1: [\"a\",\"b\"]   ->   output: False \\nTest case 2: [\"b\"]         ->   output: True \\n\\nWhy?\\n"
                    },
                    {
                        "username": "_ro_",
                        "content": "[@DamianIvanochko](/DamianIvanochko) thanks"
                    },
                    {
                        "username": "oaaees",
                        "content": "I was also confused until I realized is not only length-equal but character-equal too."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, although characters are distributed equally they are different in first test case, in the second test case there is only one character, so he is already distributed equally and there are no different characters, hope this answers your question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Does anyone know how to run this code faster?\\n\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        int j = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            while(j < words[i].length()) {\\n                map.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n                j++;\\n            }\\n\\n            j = 0;\\n        }\\n\\n        for(var key : map.keySet()) {\\n            int freq = map.get(key);\\n            if(freq % words.length != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI want to run it in O(n) instead on n^2\\n"
                    },
                    {
                        "username": "dinesh2912",
                        "content": "import random\\nclass Solution:\\n    def makeEqual(self, words: List[str]):\\n        booo=\"True\"\\n        sol=random.randint(0,1)\\n        if sol==0:\\n            return True\\n        else :\\n            return False\\n        return booo"
                    }
                ]
            },
            {
                "id": 1882041,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "In order to make strings equal, we only need to make sure all letters present in the array can be \"evenly distributed\"."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "yes , but I wonder what if Q demands to show steps :\")"
                    },
                    {
                        "username": "_ro_",
                        "content": "Test case 1: [\"a\",\"b\"]   ->   output: False \\nTest case 2: [\"b\"]         ->   output: True \\n\\nWhy?\\n"
                    },
                    {
                        "username": "_ro_",
                        "content": "[@DamianIvanochko](/DamianIvanochko) thanks"
                    },
                    {
                        "username": "oaaees",
                        "content": "I was also confused until I realized is not only length-equal but character-equal too."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, although characters are distributed equally they are different in first test case, in the second test case there is only one character, so he is already distributed equally and there are no different characters, hope this answers your question"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Does anyone know how to run this code faster?\\n\\nclass Solution {\\n    public boolean makeEqual(String[] words) {\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        int j = 0;\\n        for(int i = 0; i < words.length; i++) {\\n            while(j < words[i].length()) {\\n                map.put(words[i].charAt(j), map.getOrDefault(words[i].charAt(j), 0) + 1);\\n                j++;\\n            }\\n\\n            j = 0;\\n        }\\n\\n        for(var key : map.keySet()) {\\n            int freq = map.get(key);\\n            if(freq % words.length != 0) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n\\nI want to run it in O(n) instead on n^2\\n"
                    },
                    {
                        "username": "dinesh2912",
                        "content": "import random\\nclass Solution:\\n    def makeEqual(self, words: List[str]):\\n        booo=\"True\"\\n        sol=random.randint(0,1)\\n        if sol==0:\\n            return True\\n        else :\\n            return False\\n        return booo"
                    }
                ]
            }
        ]
    }
]