[
    {
        "title": "Design a Number Container System",
        "question_content": "Design a number container system that can do the following:\n\n\tInsert or Replace a number at the given index in the system.\n\tReturn the smallest index for the given number in the system.\n\nImplement the NumberContainers class:\n\n\tNumberContainers() Initializes the number container system.\n\tvoid change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.\n\tint find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.\n\n&nbsp;\nExample 1:\n\nInput\n[\"NumberContainers\", \"find\", \"change\", \"change\", \"change\", \"change\", \"find\", \"change\", \"find\"]\n[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]\nOutput\n[null, -1, null, null, null, null, 1, null, 2]\nExplanation\nNumberContainers nc = new NumberContainers();\nnc.find(10); // There is no index that is filled with number 10. Therefore, we return -1.\nnc.change(2, 10); // Your container at index 2 will be filled with number 10.\nnc.change(1, 10); // Your container at index 1 will be filled with number 10.\nnc.change(3, 10); // Your container at index 3 will be filled with number 10.\nnc.change(5, 10); // Your container at index 5 will be filled with number 10.\nnc.find(10); // Number 10 is at the indices 1, 2, 3, and 5. Since the smallest index that is filled with 10 is 1, we return 1.\nnc.change(1, 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. \nnc.find(10); // Number 10 is at the indices 2, 3, and 5. The smallest index that is filled with 10 is 2. Therefore, we return 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= index, number <= 109\n\tAt most 105 calls will be made in total to change and find.",
        "solutions": [
            {
                "id": 2322272,
                "title": "two-maps",
                "content": "We map an index to a number, and a number to all its indexes (we use a set so indexes are sorted).\\n\\nFor `change`, we use the first map to get the previous number for the index.\\n    \\nThen, we remove that index from the second map for the previous number. \\n\\n**C++**\\n```cpp\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, int> ind_num;\\n    unordered_map<int, set<int>> num_inds;\\n    void change(int index, int number) {\\n        auto it = ind_num.find(index);\\n        if (it != end(ind_num))\\n            num_inds[it->second].erase(index);\\n        ind_num[index] = number;\\n        num_inds[number].insert(index);\\n    }\\n    int find(int number) {\\n        auto it = num_inds.find(number);\\n        return it == end(num_inds) || it->second.empty() ? -1 : *begin(it->second);\\n    }\\n};",
                "solutionTags": [],
                "code": "We map an index to a number, and a number to all its indexes (we use a set so indexes are sorted).\\n\\nFor `change`, we use the first map to get the previous number for the index.\\n    \\nThen, we remove that index from the second map for the previous number. \\n\\n**C++**\\n```cpp\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, int> ind_num;\\n    unordered_map<int, set<int>> num_inds;\\n    void change(int index, int number) {\\n        auto it = ind_num.find(index);\\n        if (it != end(ind_num))\\n            num_inds[it->second].erase(index);\\n        ind_num[index] = number;\\n        num_inds[number].insert(index);\\n    }\\n    int find(int number) {\\n        auto it = num_inds.find(number);\\n        return it == end(num_inds) || it->second.empty() ? -1 : *begin(it->second);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2322402,
                "title": "java-python-3-treeset-sortedlist-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: How many third party packages are pre installed on leetcode server? And where to get such list?\\nA1: Please see [What are the environments for the programming languages?](https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-).\\n\\nQ2: Why `find` is `O(logn)` since the values are sorted?\\nA2:  \\n\\n\\n1)  In Python 3 code `SortedList[i]` is actually `SortedList.__getitem__`, which cost time `O(logn)`. Please refer to [source code](https://grantjenks.com/docs/sortedcontainers/_modules/sortedcontainers/sortedlist.html#SortedList.__getitem__) for more details.\\n2)  In Java code, the `TreeSet` is implemented based on `TreeMap`, which is implemented using Red-Black Tree. [Red-Black Tree](https://en.m.wikipedia.org/wiki/Red%E2%80%93black_tree)  is a self-balancing binary search tree, and any search operation cost `O(logn)`. Hence the `TreeSet.first()` cost `O(logn)`.\\n\\n\\n**End of Q & A**\\n\\n----\\n\\nSince the problem request that the smallest index of a given `number` be returned, a `TreeSet/SortedList` is a reasonable choice.\\n\\nTherefore, we can use `2` `HashMap/dict` to store `number/indices` and `index/number` bindings respectively.\\n\\nNote: For each call of `change`, we first check if there has already been a `number` filled at the `index`: if yes, discard the old value at the `index` first, then update/insert the new value.\\n\\n```java\\n    private Map<Integer, TreeSet<Integer>> numToIndices = new HashMap<>();\\n    private Map<Integer, Integer> indexToNum = new HashMap<>();\\n\\n    public NumberContainers() {}\\n    \\n    public void change(int index, int number) {\\n        if (indexToNum.containsKey(index)) {\\n            int old = indexToNum.get(index);\\n            numToIndices.get(old).remove(index);\\n            if (numToIndices.get(old).isEmpty()) {\\n                numToIndices.remove(old);\\n            }\\n        }\\n        indexToNum.put(index, number);\\n        numToIndices.computeIfAbsent(number, s -> new TreeSet<>()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if (numToIndices.containsKey(number)) {\\n            return numToIndices.get(number).first();\\n        }\\n        return -1;\\n    }\\n```\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num_to_indices = defaultdict(SortedList)\\n        self.index_to_num = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_num:\\n            old = self.index_to_num[index]\\n            self.num_to_indices[old].discard(index)\\n            if not self.num_to_indices[old]:\\n                del self.num_to_indices[old]\\n        self.num_to_indices[number].add(index)\\n        self.index_to_num[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        if number in self.num_to_indices:\\n            return self.num_to_indices[number][0]\\n        return -1\\n```\\n\\n**Analysis:**\\n\\nOverall space: `O(n)`\\n\\nTime for both `change` and `find`: `O(logn)`, where `n` is the total count of numbers in the container.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    private Map<Integer, TreeSet<Integer>> numToIndices = new HashMap<>();\\n    private Map<Integer, Integer> indexToNum = new HashMap<>();\\n\\n    public NumberContainers() {}\\n    \\n    public void change(int index, int number) {\\n        if (indexToNum.containsKey(index)) {\\n            int old = indexToNum.get(index);\\n            numToIndices.get(old).remove(index);\\n            if (numToIndices.get(old).isEmpty()) {\\n                numToIndices.remove(old);\\n            }\\n        }\\n        indexToNum.put(index, number);\\n        numToIndices.computeIfAbsent(number, s -> new TreeSet<>()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if (numToIndices.containsKey(number)) {\\n            return numToIndices.get(number).first();\\n        }\\n        return -1;\\n    }\\n```\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num_to_indices = defaultdict(SortedList)\\n        self.index_to_num = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_num:\\n            old = self.index_to_num[index]\\n            self.num_to_indices[old].discard(index)\\n            if not self.num_to_indices[old]:\\n                del self.num_to_indices[old]\\n        self.num_to_indices[number].add(index)\\n        self.index_to_num[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        if number in self.num_to_indices:\\n            return self.num_to_indices[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322525,
                "title": "hashing-java-tree-set",
                "content": "I Used 2 map to solve this Problems\\nfirst one (map) which is of type Int, set , which stores all the number with the index in which the number is present\\nSecond one , will store the index and , number corresponding to that index\\n\\nchange  function :-\\nsimply push the index number in first map, \\nand change the value at index in second map\\n\\nfind function :-\\niterate through the tree set corresponding to that number,\\nand the return the first index in which that no is present , \\n\\nif no number satisfy the condition simply return -1;\\n\\nHappy Coding :)\\n***Upvote the post , if you learn something from it***\\n```\\nclass NumberContainers {\\n    \\n    Map<Integer,TreeSet<Integer>> map;\\n    Map<Integer,Integer> m;\\n    public NumberContainers() {\\n        map=new HashMap<>();\\n        m=new HashMap<>();\\n        \\n    }\\n    public void change(int index, int number) {\\n        m.put(index,number);\\n        if(!map.containsKey(number)) map.put(number,new TreeSet<>());\\n        map.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if(!map.containsKey(number)) return -1;\\n        for(Integer a:map.get(number)){\\n            if(m.get(a)==number) return a;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    \\n    Map<Integer,TreeSet<Integer>> map;\\n    Map<Integer,Integer> m;\\n    public NumberContainers() {\\n        map=new HashMap<>();\\n        m=new HashMap<>();\\n        \\n    }\\n    public void change(int index, int number) {\\n        m.put(index,number);\\n        if(!map.containsKey(number)) map.put(number,new TreeSet<>());\\n        map.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if(!map.containsKey(number)) return -1;\\n        for(Integer a:map.get(number)){\\n            if(m.get(a)==number) return a;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322653,
                "title": "cpp-one-map-easy-sol-n",
                "content": "It\\'s very simple, we want to insert a number at index i. In the case of an existing number, we need to update it. In this case, we will use a map since it stores the index sorted. This allows us to automatically return the first index  whenever we need to find some element.\\n\\n```cpp\\nclass NumberContainers {\\npublic:\\n    map<int, int> mp;\\n    NumberContainers() \\n    {\\n\\n    }\\n    \\n    void change(int index, int number)\\n    {\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number)\\n    {\\n       for(auto it: mp){\\n           if(it.second == number) return it.first;\\n       }\\n        \\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass NumberContainers {\\npublic:\\n    map<int, int> mp;\\n    NumberContainers() \\n    {\\n\\n    }\\n    \\n    void change(int index, int number)\\n    {\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number)\\n    {\\n       for(auto it: mp){\\n           if(it.second == number) return it.first;\\n       }\\n        \\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322273,
                "title": "hashing",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int, int> indexToNumber; // stores number corresponding to an index.\\n    map<int, set<int>>numberToIndex; // stores all the indexes corresponding to a number.\\n    NumberContainers() {}\\n        \\n    void change(int index, int number) {\\n        \\n        if (!indexToNumber.count(index)) { // if there is no number at the given index.\\n            numberToIndex[number].insert(index); // store index corresponding to the given number\\n            indexToNumber[index] = number; // store number corresponding to the index.\\n        }\\n        else { // Update both map.\\n            \\n            int num = indexToNumber[index]; // number at given index currently.\\n            \\n            // remove the index\\n            numberToIndex[num].erase(index); \\n            if (numberToIndex[num].empty())    numberToIndex.erase(num);\\n            \\n            //  insert the new number at the given index and store the index corresponding to that number.\\n            numberToIndex[number].insert(index);\\n            indexToNumber[index] = number;\\n        }   \\n    }\\n    \\n    int find(int number) {\\n        if (!numberToIndex.count(number))   return -1;\\n        // returning first element in the set as it will be the smallest index always.\\n        return *numberToIndex[number].begin(); \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int, int> indexToNumber; // stores number corresponding to an index.\\n    map<int, set<int>>numberToIndex; // stores all the indexes corresponding to a number.\\n    NumberContainers() {}\\n        \\n    void change(int index, int number) {\\n        \\n        if (!indexToNumber.count(index)) { // if there is no number at the given index.\\n            numberToIndex[number].insert(index); // store index corresponding to the given number\\n            indexToNumber[index] = number; // store number corresponding to the index.\\n        }\\n        else { // Update both map.\\n            \\n            int num = indexToNumber[index]; // number at given index currently.\\n            \\n            // remove the index\\n            numberToIndex[num].erase(index); \\n            if (numberToIndex[num].empty())    numberToIndex.erase(num);\\n            \\n            //  insert the new number at the given index and store the index corresponding to that number.\\n            numberToIndex[number].insert(index);\\n            indexToNumber[index] = number;\\n        }   \\n    }\\n    \\n    int find(int number) {\\n        if (!numberToIndex.count(number))   return -1;\\n        // returning first element in the set as it will be the smallest index always.\\n        return *numberToIndex[number].begin(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322510,
                "title": "python-hashmap-heap",
                "content": "For each `number` we have a set and a heap of indexes. The set lets us check quick if `number` is at `index` or not. The heap lets us return quick what is the smallest `index` at which `number` is.\\n\\n```\\nclass NumberContainers:\\n    def __init__(self):\\n        self.numbersByIndex = {}\\n        self.numberIndexes = defaultdict(set)\\n        self.numberIndexesHeap = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.numbersByIndex:\\n            if number != self.numbersByIndex[index]:\\n                self.numberIndexes[self.numbersByIndex[index]].remove(index)\\n                self.numbersByIndex[index] = number\\n                self.numberIndexes[number].add(index)\\n                heappush(self.numberIndexesHeap[number], index)\\n        else:\\n            self.numbersByIndex[index] = number\\n            self.numberIndexes[number].add(index)\\n            heappush(self.numberIndexesHeap[number], index)\\n\\n    def find(self, number: int) -> int:\\n        while self.numberIndexesHeap[number] and self.numberIndexesHeap[number][0] not in self.numberIndexes[number]:\\n                heappop(self.numberIndexesHeap[number])  # make sure the smallest index in heap is still an index for number\\n        return self.numberIndexesHeap[number][0] if self.numberIndexesHeap[number] else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers:\\n    def __init__(self):\\n        self.numbersByIndex = {}\\n        self.numberIndexes = defaultdict(set)\\n        self.numberIndexesHeap = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.numbersByIndex:\\n            if number != self.numbersByIndex[index]:\\n                self.numberIndexes[self.numbersByIndex[index]].remove(index)\\n                self.numbersByIndex[index] = number\\n                self.numberIndexes[number].add(index)\\n                heappush(self.numberIndexesHeap[number], index)\\n        else:\\n            self.numbersByIndex[index] = number\\n            self.numberIndexes[number].add(index)\\n            heappush(self.numberIndexesHeap[number], index)\\n\\n    def find(self, number: int) -> int:\\n        while self.numberIndexesHeap[number] and self.numberIndexesHeap[number][0] not in self.numberIndexes[number]:\\n                heappop(self.numberIndexesHeap[number])  # make sure the smallest index in heap is still an index for number\\n        return self.numberIndexesHeap[number][0] if self.numberIndexesHeap[number] else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322260,
                "title": "java-treemap",
                "content": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;                   // The map is sorted according to the natural ordering of its keys\\n\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        map.put(index,number);\\n    }\\n    \\n    public int find(int number) {\\n        \\n        for(int key:map.keySet()){\\n            if(map.get(key) == number)              // We will return the smallest index that contains a number since Sorted\\n            return key;\\n        }\\n        return -1;                                  // If number not present in map return -1;\\n    }\\n}\\n   \\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;                   // The map is sorted according to the natural ordering of its keys\\n\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        map.put(index,number);\\n    }\\n    \\n    public int find(int number) {\\n        \\n        for(int key:map.keySet()){\\n            if(map.get(key) == number)              // We will return the smallest index that contains a number since Sorted\\n            return key;\\n        }\\n        return -1;                                  // If number not present in map return -1;\\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322466,
                "title": "hashmap-with-intuition-and-explanation",
                "content": "\\n\\n**Intuition**:\\n\\nFor this we need two things:\\n1. **map of index - value pair, so that we can know which value is at a index and update when change() function is called.**\\n   {why?\\n    Because when we are told for replacement of a index with a new value, it means if index was present already, then we should remove the index from the list of the old value.\\n    BUT HOW WE WILL GET TO KNOW VALUE AT A PARTICULAR INDEX? only if we have index-value map} \\n    \\n2. the question is asking for smallest index of a number:\\n   **For this we need map of list of indecies assosiated to a number , but for faster we will use a set**\\n   {Now question arises, why can\\'t we use a priority queue, because we will have to remove an index from a list of number if we assign a new value to a index, and dedicated key removal is only possible in set data structure and not priority queue }\\n        \\n**Function implement explanation**        \\n\\n`void change function`:\\n**For this function we will need two things:**\\n   1.1. First we should remove the index from the list of indices of current value in map.\\n   1.2. Then we will simply assign value to index and adding index to list of new number in map\\n   \\n`int find function`:\\n1. **for this will simply check if size of index list of the given number is 0 or not, if 0 return -1**\\n   {Why we are checking size?\\n    Answer is that if we notice the change function, we are removing the index from list of old value,\\n    so in the worst case a number that was present in many indinces earlier might get empty as it got replaced and its list of indices got \\n    empty, because we remove index from list while replacement.\\n    Thats why we are checking size in this case.}\\n\\n**C++**\\n\\n    class NumberContainers{\\n    unordered_map<int,set<int>> KTH; //for getting kTH smallest everytime\\n    unordered_map<int,int> map; //index - value pair\\n    public:\\n    NumberContainers() {}\\n    \\n    //logn \\n    void change(int index, int number) {\\n     \\n        //remove this index from the list of indices of last mapped number if already present\\n        if(map.count(index)){\\n            int val= map[index];      //get its new value like i said in explanation\\n            KTH[val].erase(index);\\n        }\\n        \\n        //update key and insert inside indices list in map\\n        map[index]=number;\\n        KTH[number].insert(index);\\n    }\\n    \\n    //logn\\n    int find(int number) {\\n        //check size\\n        if(KTH[number].size()==0) return -1;\\n        //return first of set whichi is minimum always\\n        return *(KTH[number].begin());\\n    }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\n**Intuition**:\\n\\nFor this we need two things:\\n1. **map of index - value pair, so that we can know which value is at a index and update when change() function is called.**\\n   {why?\\n    Because when we are told for replacement of a index with a new value, it means if index was present already, then we should remove the index from the list of the old value.\\n    BUT HOW WE WILL GET TO KNOW VALUE AT A PARTICULAR INDEX? only if we have index-value map} \\n    \\n2. the question is asking for smallest index of a number:\\n   **For this we need map of list of indecies assosiated to a number , but for faster we will use a set**\\n   {Now question arises, why can\\'t we use a priority queue, because we will have to remove an index from a list of number if we assign a new value to a index, and dedicated key removal is only possible in set data structure and not priority queue }\\n        \\n**Function implement explanation**        \\n\\n`void change function`:\\n**For this function we will need two things:**\\n   1.1. First we should remove the index from the list of indices of current value in map.\\n   1.2. Then we will simply assign value to index and adding index to list of new number in map\\n   \\n`int find function`:\\n1. **for this will simply check if size of index list of the given number is 0 or not, if 0 return -1**\\n   {Why we are checking size?\\n    Answer is that if we notice the change function, we are removing the index from list of old value,\\n    so in the worst case a number that was present in many indinces earlier might get empty as it got replaced and its list of indices got \\n    empty, because we remove index from list while replacement.\\n    Thats why we are checking size in this case.}\\n\\n**C++**\\n\\n    class NumberContainers{\\n    unordered_map<int,set<int>> KTH; //for getting kTH smallest everytime\\n    unordered_map<int,int> map; //index - value pair\\n    public:\\n    NumberContainers() {}\\n    \\n    //logn \\n    void change(int index, int number) {\\n     \\n        //remove this index from the list of indices of last mapped number if already present\\n        if(map.count(index)){\\n            int val= map[index];      //get its new value like i said in explanation\\n            KTH[val].erase(index);\\n        }\\n        \\n        //update key and insert inside indices list in map\\n        map[index]=number;\\n        KTH[number].insert(index);\\n    }\\n    \\n    //logn\\n    int find(int number) {\\n        //check size\\n        if(KTH[number].size()==0) return -1;\\n        //return first of set whichi is minimum always\\n        return *(KTH[number].begin());\\n    }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2322299,
                "title": "using-hashmap-of-priorityqueue-min-heap",
                "content": "\\n     class NumberContainers {\\n        Map<Integer,PriorityQueue<Integer>> m;\\n        Map<Integer,Integer> m1;\\n    public NumberContainers() {\\n        m=new HashMap<>();\\n        m1=new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        m1.put(index,number);\\n        if(!m.containsKey(number)){\\n            m.put(number,new PriorityQueue<>());\\n        }\\n        m.get(number).add(index);\\n        \\n    }\\n    \\n    public int find(int number) {\\n        if(!m.containsKey(number))return -1;\\n        \\n            PriorityQueue<Integer> q=m.get(number);\\n        \\n            int z=-1;\\n            while(!q.isEmpty()){\\n                int t1=q.peek();\\n           //     System.out.print(t1+\" \");\\n                if(number==m1.get(t1)){\\n                    z=t1;\\n                    break;\\n                }\\n                else{\\n                    q.poll();\\n                }\\n            }\\n        return z;\\n    }\\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "\\n     class NumberContainers {\\n        Map<Integer,PriorityQueue<Integer>> m;\\n        Map<Integer,Integer> m1;\\n    public NumberContainers() {\\n        m=new HashMap<>();\\n        m1=new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        m1.put(index,number);\\n        if(!m.containsKey(number)){\\n            m.put(number,new PriorityQueue<>());\\n        }\\n        m.get(number).add(index);\\n        \\n    }\\n    \\n    public int find(int number) {\\n        if(!m.containsKey(number))return -1;\\n        \\n            PriorityQueue<Integer> q=m.get(number);\\n        \\n            int z=-1;\\n            while(!q.isEmpty()){\\n                int t1=q.peek();\\n           //     System.out.print(t1+\" \");\\n                if(number==m1.get(t1)){\\n                    z=t1;\\n                    break;\\n                }\\n                else{\\n                    q.poll();\\n                }\\n            }\\n        return z;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2322360,
                "title": "simple-and-short-solution-o-nlogn-only-1-map-readable-code",
                "content": "Just did as told in the Question\\nIf you understood the solution please upvote it. Thank you\\n```class NumberContainers {\\npublic:\\n    map< int, int> mp;\\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        mp[index]=number;\\n    }\\n    \\n    int find(int number) {\\n       for(auto it : mp){\\n           if(it.second==number){\\n               return it.first;\\n           }\\n       }\\n        return -1;\\n    }\\n};\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```class NumberContainers {\\npublic:\\n    map< int, int> mp;\\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        mp[index]=number;\\n    }\\n    \\n    int find(int number) {\\n       for(auto it : mp){\\n           if(it.second==number){\\n               return it.first;\\n           }\\n       }\\n        return -1;\\n    }\\n};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2323622,
                "title": "cpp-easy-briefly-explained-two-maps",
                "content": "* We are mapping smallest index to it\\'s value in hashmap mp1\\n* We are mapping that value to all it\\'s indices placed in set using hashmap mp\\n\\nNow lets take an examplechange:[2,10]\\nNow we have in hashmap mp1 as [2:10] 2 as a key(smallest index) and 10 as a value and in hashmap mp as [10:[2]]\\nchange:[3,10]\\nNow we have in hashmap mp1 as [2:10] 2 as a key(smallest index) and 10 as a value and in hashmap mp as [10:[2,3]]\\nchange:[2,7] Now here we are required to update the index two to a new value so first we will check if smallest index is already holding some value or not .\\nIf it\\'s holding then we will delete the index from the set of that value .\\nFirst we have 2 exists as an index.\\ncheck the value corresponding to this index using hashmap mp1 so we have 10 as value\\nnow remove 2 from the set of indices for 10\\nNow add [2:7,3:10] in hashmap mp1 and add 2 in the set of indices for value 7\\nso in hashmap mp we have [10:[3],7:[2]]\\nUpvote if you liked it !!\\n\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int idx, int n) {\\n        if(mp1.count(idx)){\\n            int val=mp1[idx];\\n            mp[val].erase(idx);\\n            if(!mp[val].empty())\\n                mp1[*mp[val].begin()]=val;\\n        }\\n        mp1[idx]=n;\\n        mp[n].insert(idx);\\n    }\\n    \\n    int find(int n) {\\n        return mp[n].empty()?-1:*mp[n].begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int idx, int n) {\\n        if(mp1.count(idx)){\\n            int val=mp1[idx];\\n            mp[val].erase(idx);\\n            if(!mp[val].empty())\\n                mp1[*mp[val].begin()]=val;\\n        }\\n        mp1[idx]=n;\\n        mp[n].insert(idx);\\n    }\\n    \\n    int find(int n) {\\n        return mp[n].empty()?-1:*mp[n].begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322256,
                "title": "cpp-easy-two-hashmaps",
                "content": "* We are mapping smallest index to it\\'s value in hashmap `mp1`\\n* We are mapping that value to all it\\'s indices placed in set using hashmap `mp`\\n\\n\\nNow lets take an example` change:[2,10]` \\nNow we have in hashmap `mp1` as `[2:10]` `2` as a key`(smallest index)` and `10` as a value and in hashmap `mp` as `[10:[2]]`\\n`change:[3,10]`\\nNow we have in hashmap `mp1` as `[2:10]` `2` as a key`(smallest index)` and `10` as a value and in hashmap `mp` as `[10:[2,3]]`\\n`change:[2,7]` Now here we are required to update the index two to a new value so first we will check if smallest index is already holding some value or not .\\nIf it\\'s holding then we will delete the index from the set of that value .\\nFirst we have `2` exists as an index.\\ncheck the value corresponding to this index using hashmap `mp1` so we have `10` as value\\nnow remove 2 from the set of indices for `10`\\nNow add `[2:7,3:10]` in hashmap `mp1` and add `2` in the set of indices for value `7`\\nso in hashmap `mp` we have `[10:[3],7:[2]]`\\n\\n```\\n\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int idx, int n) {\\n        if(mp1.count(idx)){\\n            int val=mp1[idx];\\n            mp[val].erase(idx);\\n            if(!mp[val].empty())\\n                mp1[*mp[val].begin()]=val;\\n        }\\n        mp1[idx]=n;\\n        mp[n].insert(idx);\\n    }\\n    \\n    int find(int n) {\\n        return mp[n].empty()?-1:*mp[n].begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int idx, int n) {\\n        if(mp1.count(idx)){\\n            int val=mp1[idx];\\n            mp[val].erase(idx);\\n            if(!mp[val].empty())\\n                mp1[*mp[val].begin()]=val;\\n        }\\n        mp1[idx]=n;\\n        mp[n].insert(idx);\\n    }\\n    \\n    int find(int n) {\\n        return mp[n].empty()?-1:*mp[n].begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325197,
                "title": "simple-solution-w-simple-explanation-c-commented",
                "content": "We use two maps, \\nFirst map `nums` is like an array, which maps index to the values.\\nSecond map `indices`, maps a certain value to the set of indexes where that value is present.\\nThe code is self-explanatory, as we simply have to update the values at both the maps when _change()_ is called.\\n\\n```\\nclass NumberContainers \\n{\\n    \\npublic:\\n    \\n    // Map to store the numbers at a particular index\\n    // index -> number\\n    unordered_map<int, int> nums;\\n    \\n    // Map which stores all indices of a given number\\n    // number -> set of indices\\n    unordered_map<int, set<int>> indices;\\n\\n    NumberContainers() \\n    {\\n    }\\n    \\n    void change(int index, int number) \\n    {\\n        // If number is already present at that index then\\n        // delete the index from the index set of the (old) element\\n        if(nums[index])\\n            indices[nums[index]].erase(index);\\n        \\n        // Update the nums mapping\\n        nums[index] = number;\\n\\n        // Update the indices mapping\\n        indices[number].insert(index);\\n    }\\n    \\n    int find(int number) \\n    {\\n        // If that number is present in the indices mapping and the first element is not zero\\n        // Then return the first element of the set (as set is sorted, the first element will contain the smallest index)\\n        if(indices.find(number) != indices.end())\\n        {\\n            if(*indices[number].begin() != 0)\\n                return *indices[number].begin();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumberContainers \\n{\\n    \\npublic:\\n    \\n    // Map to store the numbers at a particular index\\n    // index -> number\\n    unordered_map<int, int> nums;\\n    \\n    // Map which stores all indices of a given number\\n    // number -> set of indices\\n    unordered_map<int, set<int>> indices;\\n\\n    NumberContainers() \\n    {\\n    }\\n    \\n    void change(int index, int number) \\n    {\\n        // If number is already present at that index then\\n        // delete the index from the index set of the (old) element\\n        if(nums[index])\\n            indices[nums[index]].erase(index);\\n        \\n        // Update the nums mapping\\n        nums[index] = number;\\n\\n        // Update the indices mapping\\n        indices[number].insert(index);\\n    }\\n    \\n    int find(int number) \\n    {\\n        // If that number is present in the indices mapping and the first element is not zero\\n        // Then return the first element of the set (as set is sorted, the first element will contain the smallest index)\\n        if(indices.find(number) != indices.end())\\n        {\\n            if(*indices[number].begin() != 0)\\n                return *indices[number].begin();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322471,
                "title": "c-runtime-o-log-n-maps-commented-solution",
                "content": "### Structures used:\\n* numToConts - a map that maps a number with a set(containing the indices that number is stored) \\n* contToNum - a map that maps the index and the value stored at that index\\n\\n### Code:\\n\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, set<int>> numToConts; \\n    unordered_map<int, int> contToNum; \\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        if(contToNum.find(index) == contToNum.end()) {          // if there is no number in the container with given index, \\n                                                                // we straight-away insert the given number at given index\\n            numToConts[number].insert(index);\\n            contToNum[index] = number;\\n        } else if (contToNum[index] == number) {                // if there is a number in given index but that matches the given \\n                                                                // number, we need not do any thing as end result will be the same \\n            return;             \\n        } else {                                                // if there is a number(say x) in given index and it is different than given number then.\\n            numToConts[contToNum[index]].erase(index);          // unassign the given index from x\\n            numToConts[number].insert(index);                   // assign the index to the given number \\n            contToNum[index] = number;                          // update the number in corresponding to the given index\\n        }\\n    }\\n    \\n    int find(int number) {\\n        // if the number exists and there is a possible index for it then return that\\n        if(numToConts.find(number) != numToConts.end()  and  numToConts[number].size() != 0)    \\n            return *(numToConts[number].begin());\\n        return -1;                                               // else return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, set<int>> numToConts; \\n    unordered_map<int, int> contToNum; \\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        if(contToNum.find(index) == contToNum.end()) {          // if there is no number in the container with given index, \\n                                                                // we straight-away insert the given number at given index\\n            numToConts[number].insert(index);\\n            contToNum[index] = number;\\n        } else if (contToNum[index] == number) {                // if there is a number in given index but that matches the given \\n                                                                // number, we need not do any thing as end result will be the same \\n            return;             \\n        } else {                                                // if there is a number(say x) in given index and it is different than given number then.\\n            numToConts[contToNum[index]].erase(index);          // unassign the given index from x\\n            numToConts[number].insert(index);                   // assign the index to the given number \\n            contToNum[index] = number;                          // update the number in corresponding to the given index\\n        }\\n    }\\n    \\n    int find(int number) {\\n        // if the number exists and there is a possible index for it then return that\\n        if(numToConts.find(number) != numToConts.end()  and  numToConts[number].size() != 0)    \\n            return *(numToConts[number].begin());\\n        return -1;                                               // else return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322288,
                "title": "2-maps-set-c-o-log-n-o-1",
                "content": "Time Complexity : \\n change() : O(log n)\\n  find() : O(1)\\n\\n```\\nclass NumberContainers {\\npublic:\\n    \\n    map<int,int> hm;\\n    map<int,set<int>> mp;\\n\\n    \\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n     if(hm.count(index)!=0){\\n         int a = hm[index];\\n         \\n       \\n        set<int>::iterator it;\\n         \\n         it = mp[a].find(index);\\n         mp[a].erase(it);\\n       \\n         \\n        \\n         hm[index]= number;\\n         \\n         if(mp.count(number)!=0 && mp[number].size()!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n         \\n     }\\n        else{\\n            \\n            hm[index] = number;\\n               if(mp.count(number)!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find(int number) {\\n        \\n       if(mp.count(number)!=0 && mp[number].size()!=0){\\n           \\n           return *mp[number].begin();\\n       }\\n        \\n        return -1;\\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    \\n    map<int,int> hm;\\n    map<int,set<int>> mp;\\n\\n    \\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n     if(hm.count(index)!=0){\\n         int a = hm[index];\\n         \\n       \\n        set<int>::iterator it;\\n         \\n         it = mp[a].find(index);\\n         mp[a].erase(it);\\n       \\n         \\n        \\n         hm[index]= number;\\n         \\n         if(mp.count(number)!=0 && mp[number].size()!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n         \\n     }\\n        else{\\n            \\n            hm[index] = number;\\n               if(mp.count(number)!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find(int number) {\\n        \\n       if(mp.count(number)!=0 && mp[number].size()!=0){\\n           \\n           return *mp[number].begin();\\n       }\\n        \\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322259,
                "title": "javascript-priority-queue-detailed-explanation-clean-code",
                "content": "Let\\'s walk through question description\\n\\nDesign a number container system that can do the following:\\n\\n- Insert or Replace a number at the given index in the system.\\n*and* `void change(int index, int number)` Fills the container at index with the number. If there is already a number at that index, replace it.\\n**=>** We need to store `index` and `number at this index`. We can use **array** to store it. However, it would be a **waste of memory** if we use **array** here as `number` filled at random `index` in **array**. I decided to use **HashMap** here to **keep track** of number at index. (`{ index: numberAtIndex }`). Every time we called `change` function, we will set a `number` to the `index`\\n\\n- Return the smallest index for the given number in the system.\\n**=>** Why we have **smallest index** here ? It is because of we can fill a `number` to many `index`. So it could be like mapping `num1` to many indexes `[i1, i2, i3 ....]`. `find` function will return **smallest i** in `[i1, i2, i3 ....]`. Thinking about using **Priority Queue** is a good start. **Priority Queue** is efficient finding **smallest** or largest.\\nEvery time we called `change` function, we will **enqueue** an `index` to the `number`\\n\\n\\n\\u2757\\uFE0F\\u2757\\uFE0F\\u2757\\uFE0FThere is an issue with above walk through. We can **replace** a number at a specific index. `find` function will return wrong index if we don\\'t update the **Priority Queue**. \\nIf `front_number` at **front** element of the **queue** (`index`) is not the `number` we need to `find`, then the `front_number` is replaced by another `number` before. We are no longer need `front_number`. It is safe to **dequeue** it from the queue.\\n\\n<br />\\n\\u2139\\uFE0F [MinPriorityQueue](https://support.leetcode.com/hc/en-us/articles/360011833974-What-are-the-environments-for-the-programming-languages-) usage can be found here at Javascript row\\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />\\n\\n\\n\\n\\n```\\nclass NumberContainers {\\n  constructor() {\\n    this.nums = {};\\n    this.numMap = {};\\n  }\\n\\n  change(index, number) {\\n    this.nums[index] = number;\\n\\n    if (!this.numMap[number]) {\\n      this.numMap[number] = new MinPriorityQueue();\\n    }\\n\\n    this.numMap[number].enqueue(index);\\n  }\\n\\n  find(number) {\\n    while (\\n      this.numMap[number] &&\\n      this.numMap[number].size() > 0 &&\\n      this.nums[this.numMap[number].front().element] !== number\\n    ) {\\n      this.numMap[number].dequeue();\\n    }\\n\\n    return this.numMap[number] && this.numMap[number].size() > 0\\n      ? this.numMap[number].front().element\\n      : -1;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers {\\n  constructor() {\\n    this.nums = {};\\n    this.numMap = {};\\n  }\\n\\n  change(index, number) {\\n    this.nums[index] = number;\\n\\n    if (!this.numMap[number]) {\\n      this.numMap[number] = new MinPriorityQueue();\\n    }\\n\\n    this.numMap[number].enqueue(index);\\n  }\\n\\n  find(number) {\\n    while (\\n      this.numMap[number] &&\\n      this.numMap[number].size() > 0 &&\\n      this.nums[this.numMap[number].front().element] !== number\\n    ) {\\n      this.numMap[number].dequeue();\\n    }\\n\\n    return this.numMap[number] && this.numMap[number].size() > 0\\n      ? this.numMap[number].front().element\\n      : -1;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323762,
                "title": "c-one-map-solution",
                "content": "Declare map of int int\\n\\n**void change()** - map[index] = number *// this will store the number at given index*\\n\\n**void find()** - As the second parameter of map is the number we are looking for, run a for loop and check if the number is present or not else return -1.\\nAs the map is sorted w.r.t index, it will return the smallest index for that number :)\\n\\neg -\\nmap[1]= 20\\nmap[2]= 10\\nmap[4]= 10\\nmap[7]= 10\\n\\nfor find(10) - it will return the smallest index it encounterd i.e. **2**\\n\\n**C++ Approch :**\\n```\\nclass NumberContainers {\\npublic:\\n    map<int,int> mp;\\n    void change(int index, int number) {\\n        mp[index] = number;\\n    }\\n    int find(int number) {\\n        for(auto it:mp) if(it.second==number) return it.first;\\n        return -1;\\n    }\\n};\\n```\\n\\nUpvote if it helped you ; )",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int> mp;\\n    void change(int index, int number) {\\n        mp[index] = number;\\n    }\\n    int find(int number) {\\n        for(auto it:mp) if(it.second==number) return it.first;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322690,
                "title": "3-dictionaries-python-o-n-logn",
                "content": "Note: In C++ or Java, we can use Sorted HashMap, but here in Python, I didn\\'t have such option, so I used a heap and Counter to achieve that. (Will create a detailed article on how to do that saperately).\\n\\nSo here, I have to consider 2 maps:\\n1. For storing each index-value pair (number against each index)\\n2. For storing all indices of a value (heap against each value, to get the minimum index for O(logn))\\n\\n```\\nfrom collections import defaultdict, Counter\\nimport heapq\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.elementIndices = defaultdict(list)\\n        self.indexToElement = {}\\n        self.indicesRemoved = defaultdict(Counter)\\n\\n    def change(self, index: int, number: int) -> None:\\n        # element already exists on this index\\n        if index in self.indexToElement and self.indexToElement[index] == number:\\n            return\\n        \\n        # if some other element exists at the index, mark it to remove\\n        if index in self.indexToElement:\\n            prevVal = self.indexToElement[index]\\n            self.indicesRemoved[prevVal][index] += 1\\n        \\n        self.indexToElement[index] = number\\n        heapq.heappush(self.elementIndices[number], index)\\n            \\n\\n    def find(self, number: int) -> int:\\n        ## if the element exists in array\\n        if self.elementIndices[number]:\\n            mn = self.elementIndices[number][0]\\n            while self.indicesRemoved[number][mn] and self.elementIndices[number]:\\n                self.indicesRemoved[number][mn] -= 1\\n                heapq.heappop(self.elementIndices[number])\\n                if not self.elementIndices[number]:\\n                    break\\n                mn = self.elementIndices[number][0]\\n            if self.elementIndices[number]:\\n                return mn\\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict, Counter\\nimport heapq\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.elementIndices = defaultdict(list)\\n        self.indexToElement = {}\\n        self.indicesRemoved = defaultdict(Counter)\\n\\n    def change(self, index: int, number: int) -> None:\\n        # element already exists on this index\\n        if index in self.indexToElement and self.indexToElement[index] == number:\\n            return\\n        \\n        # if some other element exists at the index, mark it to remove\\n        if index in self.indexToElement:\\n            prevVal = self.indexToElement[index]\\n            self.indicesRemoved[prevVal][index] += 1\\n        \\n        self.indexToElement[index] = number\\n        heapq.heappush(self.elementIndices[number], index)\\n            \\n\\n    def find(self, number: int) -> int:\\n        ## if the element exists in array\\n        if self.elementIndices[number]:\\n            mn = self.elementIndices[number][0]\\n            while self.indicesRemoved[number][mn] and self.elementIndices[number]:\\n                self.indicesRemoved[number][mn] -= 1\\n                heapq.heappop(self.elementIndices[number])\\n                if not self.elementIndices[number]:\\n                    break\\n                mn = self.elementIndices[number][0]\\n            if self.elementIndices[number]:\\n                return mn\\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322393,
                "title": "easy-short-code-using-only-single-map-no-set",
                "content": "map<long long,long long>map;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        map[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        \\n        for(auto itr:map)\\n        {\\n            if(itr.second==number)\\n            {\\n                return itr.first;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "map<long long,long long>map;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        map[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        \\n        for(auto itr:map)\\n        {\\n            if(itr.second==number)\\n            {\\n                return itr.first;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2322352,
                "title": "c-map-map-with-set",
                "content": "**Approach**\\nI maintain `2` maps one is for `index` to `number` mapping. And other is for `number` to `index` storing. \\nWe have to output the `smallest index` and `set` can handle this thing easily.\\n\\n**Time:** `change: O(log N), find: O(log N), N = Number of elements present in the bucket`\\n**Space:** `O(M), M = Number of elements inserted with change function`\\n\\n```\\nclass NumberContainers {\\nprivate:\\n    unordered_map<int, set<int>> maps;\\n    unordered_map<int, int> index_to_num;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if (index_to_num.count(index)) {\\n            maps[index_to_num[index]].erase(index);\\n            index_to_num[index] = number;\\n            maps[number].insert(index);\\n        } else {\\n            index_to_num[index] = number;\\n            maps[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if (maps[number].size()) {\\n            return *maps[number].begin();\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\nprivate:\\n    unordered_map<int, set<int>> maps;\\n    unordered_map<int, int> index_to_num;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if (index_to_num.count(index)) {\\n            maps[index_to_num[index]].erase(index);\\n            index_to_num[index] = number;\\n            maps[number].insert(index);\\n        } else {\\n            index_to_num[index] = number;\\n            maps[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if (maps[number].size()) {\\n            return *maps[number].begin();\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322312,
                "title": "map-and-set-aasan-hai-c",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    \\n    // key: number | value: indices in the set -> used for finding indices associated with the number\\n    unordered_map<int, set<int>> m;\\n    \\n    // key: index | value: number -> used for searching the index with number\\n    unordered_map<int, int> s;\\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        // if that index was earlier present then clear that index from old number and delete from s map.\\n        if(s.find(index) != s.end()){\\n            m[s[index]].erase(m[s[index]].find(index));\\n            if(m[s[index]].size() == 0)m.erase(s[index]); // if set is empty then delete the key from map.\\n        }\\n        \\n        m[number].insert(index);\\n        s[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        //if number found as key then return first element.\\n        if(m.find(number) != m.end()){\\n            return *m[number].begin();\\n        }\\n        else return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    \\n    // key: number | value: indices in the set -> used for finding indices associated with the number\\n    unordered_map<int, set<int>> m;\\n    \\n    // key: index | value: number -> used for searching the index with number\\n    unordered_map<int, int> s;\\n    \\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        // if that index was earlier present then clear that index from old number and delete from s map.\\n        if(s.find(index) != s.end()){\\n            m[s[index]].erase(m[s[index]].find(index));\\n            if(m[s[index]].size() == 0)m.erase(s[index]); // if set is empty then delete the key from map.\\n        }\\n        \\n        m[number].insert(index);\\n        s[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        //if number found as key then return first element.\\n        if(m.find(number) != m.end()){\\n            return *m[number].begin();\\n        }\\n        else return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216483,
                "title": "c-easy-to-understand-with-intuition-comments-images-memory-beats-93-58",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Abbreviation :**\\n**By \"given number\" means : number that is passed to function as paramter.\\nBy \"given index\" means : index that is passed to function as paramter.**\\n\\nSo as soon as i read that i have to return the smallest indices of number (indices because same no. can be inserted at many index),\\ni understood that i have to create an key-value unordered map,\\nin that i can store the indices of number.\\nExample:\\n> number[10] -> indices[3,5,8]\\n\\nBut the case arrive when given number has to be inserted at given index where another number already exist.\\nfor example : \\n>     number 10 is at indices 1,3,5\\n>     now insert 20 at index 1\\n\\n**Now there can be three cases for existed value/number in this :** \\n1. Where it has only 1 index, means it only exist in one. index.\\n    \\n    ![image.png](https://assets.leetcode.com/users/images/f4bf3e25-d67a-427e-9b08-f1454a2a9c72_1677022831.2942252.png)\\n\\n2.  Where it has multiple indices:\\n    - given index is smallest for existing number.\\n    ![image.png](https://assets.leetcode.com/users/images/64e960a8-8432-4139-8d5c-6e7bc52512a4_1677022577.9675019.png)\\n    - given index is not smallest for existing number\\n    ![image.png](https://assets.leetcode.com/users/images/f4b886d0-7af4-46d1-8f13-65c3d00fa85b_1677022748.9980266.png)\\n\\n\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created an Index to number key-value unordered map,\\nso that i can keep track of what value/number is at what index.\\n> key[index] -> value[number]\\n\\nthen created an Number to indices key-value unordered map,\\nso that i can keep track of what value/number is exists/present at what index.\\n\\n- ***but here\\'s the catch,***\\n\\nstore these indices in a order set, why ?\\n    so that the smallest index is always at the beginning of set\\n\\nso now every \"key\"{number} will have an {order set} as their \"value\"\\n> key[number] -> value[set[index]]\\n\\n\\n---\\n\\n\\n\\n\\n# Complexity\\n# - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nerase method of set takes $$O(n)$$ time complex. .\\ninsert method of set takes $$O(log(n))$$ time complex. .\\nfind method of unordered_map can take $$O(1)$$ time complex. in average case but $$O(n)$$ time complex. in worst case .\\n\\n![image.png](https://assets.leetcode.com/users/images/30b493cc-b9d5-4692-9d43-19b7a524e609_1677024204.6087408.png)\\nimage from \"cplusplus.com\"\\n\\n**So overall Time Complexity becomes : $$O(n)$$**\\n\\n\\n# - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMainly i am creating these two maps :\\n> unordered_map<int, set<int>> container\\nunordered_map<int,int> ind\\n\\ni think Overall Space Complexity is : $$O(m * n)$$ \\nm is total unique numbers,\\nn is indices\\n*(not so sure about this)*\\n\\n\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    // To store key-values of number to indices\\n    unordered_map<int, set<int>> container;\\n\\n    // To store key-values of index to number\\n    unordered_map<int,int> ind;\\n\\n    NumberContainers() {\\n\\n        // initializing both of them\\n        container = unordered_map<int, set<int>>();\\n        ind = unordered_map<int,int>();\\n\\n    }\\n    \\n    void change(int index, int number) {\\n\\n        // checking if any value exist at given index or not\\n        // and if that existed value is equal to given number or not\\n        // if all this condition is true then\\n        //      erase given index from set of container\\n        if(ind[index] != 0 && ind[index] != number)\\n            container[ind[index]].erase(index);\\n\\n        // inserting/updating index & number\\n        ind[index] = number;\\n        container[number].insert(index);\\n\\n    }\\n    \\n    int find(int number) {\\n\\n        int res = -1; // initializing result\\n\\n        // checking if given number exist or not\\n        if(container.find(number) != container.end()){\\n\\n            // get the first value/index from given number\\'s set\\n            // we will automatically get the smallest index as it is sorted\\n            res = *(container[number].begin());\\n\\n            // fact : if set of *number* is empty then\\n            //        begin() of set will return 0 \\n            if(res == 0)\\n                res = -1;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    // To store key-values of number to indices\\n    unordered_map<int, set<int>> container;\\n\\n    // To store key-values of index to number\\n    unordered_map<int,int> ind;\\n\\n    NumberContainers() {\\n\\n        // initializing both of them\\n        container = unordered_map<int, set<int>>();\\n        ind = unordered_map<int,int>();\\n\\n    }\\n    \\n    void change(int index, int number) {\\n\\n        // checking if any value exist at given index or not\\n        // and if that existed value is equal to given number or not\\n        // if all this condition is true then\\n        //      erase given index from set of container\\n        if(ind[index] != 0 && ind[index] != number)\\n            container[ind[index]].erase(index);\\n\\n        // inserting/updating index & number\\n        ind[index] = number;\\n        container[number].insert(index);\\n\\n    }\\n    \\n    int find(int number) {\\n\\n        int res = -1; // initializing result\\n\\n        // checking if given number exist or not\\n        if(container.find(number) != container.end()){\\n\\n            // get the first value/index from given number\\'s set\\n            // we will automatically get the smallest index as it is sorted\\n            res = *(container[number].begin());\\n\\n            // fact : if set of *number* is empty then\\n            //        begin() of set will return 0 \\n            if(res == 0)\\n                res = -1;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146544,
                "title": "easy-solution-using-hashing",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>>mp;\\n    unordered_map<int,int>mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp2.find(index)!=mp2.end()){\\n            int val=mp2[index];\\n            mp[val].erase(index);\\n            if(!mp[val].size())mp.erase(val);\\n        }\\n        mp[number].insert(index);\\n        mp2[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number)==mp.end())return -1;\\n        auto it=mp[number].begin();\\n        return *it;\\n        \\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>>mp;\\n    unordered_map<int,int>mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp2.find(index)!=mp2.end()){\\n            int val=mp2[index];\\n            mp[val].erase(index);\\n            if(!mp[val].size())mp.erase(val);\\n        }\\n        mp[number].insert(index);\\n        mp2[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number)==mp.end())return -1;\\n        auto it=mp[number].begin();\\n        return *it;\\n        \\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741187,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n map<int,int> hm;\\n    map<int,set<int>> mp;\\n\\n    \\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n     if(hm.count(index)!=0){\\n         int a = hm[index];\\n         \\n       \\n        set<int>::iterator it;\\n         \\n         it = mp[a].find(index);\\n         mp[a].erase(it);\\n       \\n         \\n        \\n         hm[index]= number;\\n         \\n         if(mp.count(number)!=0 && mp[number].size()!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n         \\n     }\\n        else{\\n            \\n            hm[index] = number;\\n               if(mp.count(number)!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find(int number) {\\n        \\n       if(mp.count(number)!=0 && mp[number].size()!=0){\\n           \\n           return *mp[number].begin();\\n       }\\n        \\n        return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n map<int,int> hm;\\n    map<int,set<int>> mp;\\n\\n    \\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n     if(hm.count(index)!=0){\\n         int a = hm[index];\\n         \\n       \\n        set<int>::iterator it;\\n         \\n         it = mp[a].find(index);\\n         mp[a].erase(it);\\n       \\n         \\n        \\n         hm[index]= number;\\n         \\n         if(mp.count(number)!=0 && mp[number].size()!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n         \\n     }\\n        else{\\n            \\n            hm[index] = number;\\n               if(mp.count(number)!=0){\\n             \\n             mp[number].insert(index);\\n        \\n         }\\n         else{\\n             set<int> st ;\\n             st.insert(index);\\n             mp[number] = st;\\n         }\\n            \\n        }\\n        \\n        \\n        \\n    }\\n    \\n    \\n    \\n    int find(int number) {\\n        \\n       if(mp.count(number)!=0 && mp[number].size()!=0){\\n           \\n           return *mp[number].begin();\\n       }\\n        \\n        return -1;\\n\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419583,
                "title": "without-sorted-set",
                "content": "```\\ntype NumberContainers struct {\\n\\tindexMap    map[int]int\\n\\tnumberMap   map[int]map[int]struct{}\\n\\tminIndexMap map[int]int\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tindexMap:    make(map[int]int),\\n\\t\\tnumberMap:   make(map[int]map[int]struct{}),\\n\\t\\tminIndexMap: make(map[int]int),\\n\\t}\\n}\\n\\nfunc (this *NumberContainers) Change(index int, number int) {\\n\\toldNumber, exist := this.indexMap[index]\\n\\tthis.indexMap[index] = number\\n\\n\\tindexSet, ok := this.numberMap[number]\\n\\n\\tif !ok {\\n\\t\\tthis.minIndexMap[number] = index\\n\\t\\tindexSet = make(map[int]struct{})\\n\\t} else if index < this.minIndexMap[number] {\\n\\t\\tthis.minIndexMap[number] = index\\n\\t}\\n\\n\\tindexSet[index] = struct{}{}\\n\\tthis.numberMap[number] = indexSet\\n\\n\\tif exist && oldNumber != number {\\n\\t\\tdelete(this.numberMap[oldNumber], index)\\n\\n\\t\\tif len(this.numberMap[oldNumber]) == 0 {\\n\\t\\t\\tdelete(this.numberMap, oldNumber)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.minIndexMap[oldNumber] == index {\\n\\t\\t\\tminIndex := 1000000000\\n\\n\\t\\t\\tfor idx := range this.numberMap[oldNumber] {\\n\\t\\t\\t\\tif idx < minIndex {\\n\\t\\t\\t\\t\\tminIndex = idx\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.minIndexMap[oldNumber] = minIndex\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *NumberContainers) Find(number int) int {\\n\\t_, ok := this.numberMap[number]\\n\\n\\tif !ok {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn this.minIndexMap[number]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype NumberContainers struct {\\n\\tindexMap    map[int]int\\n\\tnumberMap   map[int]map[int]struct{}\\n\\tminIndexMap map[int]int\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tindexMap:    make(map[int]int),\\n\\t\\tnumberMap:   make(map[int]map[int]struct{}),\\n\\t\\tminIndexMap: make(map[int]int),\\n\\t}\\n}\\n\\nfunc (this *NumberContainers) Change(index int, number int) {\\n\\toldNumber, exist := this.indexMap[index]\\n\\tthis.indexMap[index] = number\\n\\n\\tindexSet, ok := this.numberMap[number]\\n\\n\\tif !ok {\\n\\t\\tthis.minIndexMap[number] = index\\n\\t\\tindexSet = make(map[int]struct{})\\n\\t} else if index < this.minIndexMap[number] {\\n\\t\\tthis.minIndexMap[number] = index\\n\\t}\\n\\n\\tindexSet[index] = struct{}{}\\n\\tthis.numberMap[number] = indexSet\\n\\n\\tif exist && oldNumber != number {\\n\\t\\tdelete(this.numberMap[oldNumber], index)\\n\\n\\t\\tif len(this.numberMap[oldNumber]) == 0 {\\n\\t\\t\\tdelete(this.numberMap, oldNumber)\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif this.minIndexMap[oldNumber] == index {\\n\\t\\t\\tminIndex := 1000000000\\n\\n\\t\\t\\tfor idx := range this.numberMap[oldNumber] {\\n\\t\\t\\t\\tif idx < minIndex {\\n\\t\\t\\t\\t\\tminIndex = idx\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.minIndexMap[oldNumber] = minIndex\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *NumberContainers) Find(number int) int {\\n\\t_, ok := this.numberMap[number]\\n\\n\\tif !ok {\\n\\t\\treturn -1\\n\\t}\\n\\n\\treturn this.minIndexMap[number]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356960,
                "title": "c-approach-faster-than-97-easy-to-understand",
                "content": "\\n\\n\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>> pq; //for storing minimum index\\n    unordered_map<int,int> mp; //for storing the latest value at a particular index\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        \\n        pq[number].push(index);\\n        mp[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n       while(!pq[number].empty())\\n       {\\n           if(mp[pq[number].top()]==number)\\n               return pq[number].top();\\n           else\\n               pq[number].pop();\\n       }\\n        return -1;\\n    }\\n\\t\\n\\t//Pls upvote if found helpful \\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\n\\n\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>> pq; //for storing minimum index\\n    unordered_map<int,int> mp; //for storing the latest value at a particular index\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        \\n        pq[number].push(index);\\n        mp[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n       while(!pq[number].empty())\\n       {\\n           if(mp[pq[number].top()]==number)\\n               return pq[number].top();\\n           else\\n               pq[number].pop();\\n       }\\n        return -1;\\n    }\\n\\t\\n\\t//Pls upvote if found helpful \\uD83D\\uDE0A",
                "codeTag": "Unknown"
            },
            {
                "id": 2336724,
                "title": "java-two-maps-easy-to-understand",
                "content": "```\\nclass NumberContainers {\\n    private class NumberContainer implements Comparable<NumberContainer> {\\n        int index;\\n        int number;\\n        \\n        public NumberContainer(int index, int number) {\\n            this.index = index;\\n            this.number = number;\\n        }\\n        \\n        public int compareTo(NumberContainer numberContainer) {\\n            return Integer.compare(this.index, numberContainer.index);\\n        }\\n    }\\n    \\n    private HashMap<Integer, NumberContainer> indexCache;\\n    private HashMap<Integer, PriorityQueue<NumberContainer>> numberHeapCache; \\n    \\n    public NumberContainers() {\\n        indexCache = new HashMap<>();\\n        numberHeapCache = new HashMap<>();\\n    }\\n    \\n    // T = O(log(n)) | S = O(1)\\n    public void change(int index, int number) {\\n        if (!numberHeapCache.containsKey(number)) {\\n            numberHeapCache.put(number, new PriorityQueue<>());\\n        }\\n        \\n        NumberContainer numberContainer;\\n        if (indexCache.containsKey(index)) {\\n            numberContainer = indexCache.get(index);\\n            \\n            if (numberContainer.number == number) {\\n                return;\\n            }\\n            \\n            numberHeapCache.get(numberContainer.number).remove(numberContainer);\\n            numberContainer.number = number;\\n        } else {\\n            numberContainer = new NumberContainer(index, number);\\n            indexCache.put(index, numberContainer);\\n        }\\n        \\n        numberHeapCache.get(number).add(numberContainer);\\n    }\\n    \\n    // T = O(1) | S = O(1)\\n    public int find(int number) {\\n        if (!numberHeapCache.containsKey(number) || numberHeapCache.get(number).isEmpty()) {\\n           return -1; \\n        }\\n        \\n        return numberHeapCache.get(number).peek().index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    private class NumberContainer implements Comparable<NumberContainer> {\\n        int index;\\n        int number;\\n        \\n        public NumberContainer(int index, int number) {\\n            this.index = index;\\n            this.number = number;\\n        }\\n        \\n        public int compareTo(NumberContainer numberContainer) {\\n            return Integer.compare(this.index, numberContainer.index);\\n        }\\n    }\\n    \\n    private HashMap<Integer, NumberContainer> indexCache;\\n    private HashMap<Integer, PriorityQueue<NumberContainer>> numberHeapCache; \\n    \\n    public NumberContainers() {\\n        indexCache = new HashMap<>();\\n        numberHeapCache = new HashMap<>();\\n    }\\n    \\n    // T = O(log(n)) | S = O(1)\\n    public void change(int index, int number) {\\n        if (!numberHeapCache.containsKey(number)) {\\n            numberHeapCache.put(number, new PriorityQueue<>());\\n        }\\n        \\n        NumberContainer numberContainer;\\n        if (indexCache.containsKey(index)) {\\n            numberContainer = indexCache.get(index);\\n            \\n            if (numberContainer.number == number) {\\n                return;\\n            }\\n            \\n            numberHeapCache.get(numberContainer.number).remove(numberContainer);\\n            numberContainer.number = number;\\n        } else {\\n            numberContainer = new NumberContainer(index, number);\\n            indexCache.put(index, numberContainer);\\n        }\\n        \\n        numberHeapCache.get(number).add(numberContainer);\\n    }\\n    \\n    // T = O(1) | S = O(1)\\n    public int find(int number) {\\n        if (!numberHeapCache.containsKey(number) || numberHeapCache.get(number).isEmpty()) {\\n           return -1; \\n        }\\n        \\n        return numberHeapCache.get(number).peek().index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333700,
                "title": "c-easy-to-understand",
                "content": "```\\n map<int, int>m;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(m.find(index) != m.end())\\n            m[index]=number;\\n        else\\n            m.insert({index,number});\\n    }\\n    \\n    int find(int number) {\\n        if(m.size() == 0)\\n            return -1;\\n        for(auto pr:m)\\n        {\\n            if(pr.second == number)\\n                return pr.first;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n map<int, int>m;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(m.find(index) != m.end())\\n            m[index]=number;\\n        else\\n            m.insert({index,number});\\n    }\\n    \\n    int find(int number) {\\n        if(m.size() == 0)\\n            return -1;\\n        for(auto pr:m)\\n        {\\n            if(pr.second == number)\\n                return pr.first;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332931,
                "title": "simple-solution-c-single-map",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int>m;\\n    vector<pair<int,int>>vp;\\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        m[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        for(auto i:m)\\n        {\\n            if(i.second==number)\\n            {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int>m;\\n    vector<pair<int,int>>vp;\\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        m[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        for(auto i:m)\\n        {\\n            if(i.second==number)\\n            {\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326829,
                "title": "golang-simple-redblacktree-solution",
                "content": "```go\\ntype NumberContainers struct {\\n\\tContainer map[int]int\\n\\tReIndexes map[int]*treemap.Map\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tContainer: make(map[int]int),\\n\\t\\tReIndexes: make(map[int]*treemap.Map),\\n\\t}\\n}\\n\\nfunc (nc *NumberContainers) Change(index int, newNumber int) {\\n\\t// remove ReIndex if oldNumber exists\\n\\tif oldNumber, exist := nc.Container[index]; exist {\\n\\t\\tnc.ReIndexes[oldNumber].Remove(index)\\n\\t}\\n\\t// initial ReIndex if not exists\\n\\tif nc.ReIndexes[newNumber] == nil {\\n\\t\\tnc.ReIndexes[newNumber] = treemap.NewWithIntComparator()\\n\\t}\\n\\t// store into container and reindex\\n\\tnc.Container[index] = newNumber\\n\\tnc.ReIndexes[newNumber].Put(index, struct{}{})\\n}\\n\\nfunc (nc *NumberContainers) Find(number int) int {\\n\\tif nc.ReIndexes[number] == nil || nc.ReIndexes[number].Empty() {\\n\\t\\treturn -1\\n\\t}\\n\\tk, _ := nc.ReIndexes[number].Min()\\n\\treturn k.(int)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype NumberContainers struct {\\n\\tContainer map[int]int\\n\\tReIndexes map[int]*treemap.Map\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tContainer: make(map[int]int),\\n\\t\\tReIndexes: make(map[int]*treemap.Map),\\n\\t}\\n}\\n\\nfunc (nc *NumberContainers) Change(index int, newNumber int) {\\n\\t// remove ReIndex if oldNumber exists\\n\\tif oldNumber, exist := nc.Container[index]; exist {\\n\\t\\tnc.ReIndexes[oldNumber].Remove(index)\\n\\t}\\n\\t// initial ReIndex if not exists\\n\\tif nc.ReIndexes[newNumber] == nil {\\n\\t\\tnc.ReIndexes[newNumber] = treemap.NewWithIntComparator()\\n\\t}\\n\\t// store into container and reindex\\n\\tnc.Container[index] = newNumber\\n\\tnc.ReIndexes[newNumber].Put(index, struct{}{})\\n}\\n\\nfunc (nc *NumberContainers) Find(number int) int {\\n\\tif nc.ReIndexes[number] == nil || nc.ReIndexes[number].Empty() {\\n\\t\\treturn -1\\n\\t}\\n\\tk, _ := nc.ReIndexes[number].Min()\\n\\treturn k.(int)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325744,
                "title": "python-hashmap",
                "content": "```\\nclass Node:\\n    def __init__(self):\\n        self.idxs = set()\\n        self.minimal = float(\"inf\")\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.number2index = defaultdict(Node)\\n        self.index2number = dict()\\n\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index2number:\\n            value = self.index2number[index]\\n            self.number2index[value].idxs.remove(index)\\n            if len(self.number2index[value].idxs) == 0:\\n                del self.number2index[value]\\n            elif self.number2index[value].minimal == index:\\n                self.number2index[value].minimal = min(self.number2index[value].idxs)\\n        self.number2index[number].idxs.add(index)\\n        self.number2index[number].minimal = min(self.number2index[number].minimal, index)\\n        self.index2number[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        return self.number2index[number].minimal if self.number2index[number].minimal != float(\"inf\") else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self):\\n        self.idxs = set()\\n        self.minimal = float(\"inf\")\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.number2index = defaultdict(Node)\\n        self.index2number = dict()\\n\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index2number:\\n            value = self.index2number[index]\\n            self.number2index[value].idxs.remove(index)\\n            if len(self.number2index[value].idxs) == 0:\\n                del self.number2index[value]\\n            elif self.number2index[value].minimal == index:\\n                self.number2index[value].minimal = min(self.number2index[value].idxs)\\n        self.number2index[number].idxs.add(index)\\n        self.number2index[number].minimal = min(self.number2index[number].minimal, index)\\n        self.index2number[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        return self.number2index[number].minimal if self.number2index[number].minimal != float(\"inf\") else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323368,
                "title": "c-map-and-sets-easy-solution",
                "content": "```\\n map<int,set<int>> m;  \\n    unordered_map<int,int> mp;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n       \\n        if(mp[index])\\n        {\\n            m[mp[index]].erase(index);\\n        }\\n         m[number].insert(index);\\n        mp[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        if(m[number].empty()) return -1;\\n        return *m[number].begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n map<int,set<int>> m;  \\n    unordered_map<int,int> mp;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n       \\n        if(mp[index])\\n        {\\n            m[mp[index]].erase(index);\\n        }\\n         m[number].insert(index);\\n        mp[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        if(m[number].empty()) return -1;\\n        return *m[number].begin();\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322593,
                "title": "python-solution-sortedset",
                "content": "```\\nfrom sortedcontainers import SortedSet\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.d1 = defaultdict(SortedSet)\\n        self.d2 = {}\\n        \\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.d2:\\n            self.d1[self.d2[index]].discard(index)\\n            self.d2[index]=number\\n            self.d1[number].add(index)\\n            \\n        else:\\n            self.d2[index]=number\\n            self.d1[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        #print(self.d1)\\n        if number in self.d1 and len(self.d1[number])>0:\\n            return self.d1[number][0]\\n        else:\\n            return -1\\n            \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.d1 = defaultdict(SortedSet)\\n        self.d2 = {}\\n        \\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.d2:\\n            self.d1[self.d2[index]].discard(index)\\n            self.d2[index]=number\\n            self.d1[number].add(index)\\n            \\n        else:\\n            self.d2[index]=number\\n            self.d1[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        #print(self.d1)\\n        if number in self.d1 and len(self.d1[number])>0:\\n            return self.d1[number][0]\\n        else:\\n            return -1\\n            \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322581,
                "title": "two-maps",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp1;\\n    NumberContainers() {}\\n    \\n    void change(int index, int number) \\n    {\\n        if(mp.find(index)!=mp.end())//updation\\n        {\\n            if(mp[index]==number)return;\\n            int val=mp[index];\\n            vector<int>vals;\\n            while(!mp1[val].empty())\\n            {\\n                int x=mp1[val].top();\\n                mp1[val].pop();\\n                if(x!=index)vals.push_back(x);\\n                else break;\\n            }\\n            for(auto i:vals)mp1[val].push(i);\\n            if(mp1[val].empty())mp1.erase(val);\\n        }\\n        mp[index]=number;\\n        mp1[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp1.find(number)!=mp1.end())\\n        {\\n            return mp1[number].top();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp1;\\n    NumberContainers() {}\\n    \\n    void change(int index, int number) \\n    {\\n        if(mp.find(index)!=mp.end())//updation\\n        {\\n            if(mp[index]==number)return;\\n            int val=mp[index];\\n            vector<int>vals;\\n            while(!mp1[val].empty())\\n            {\\n                int x=mp1[val].top();\\n                mp1[val].pop();\\n                if(x!=index)vals.push_back(x);\\n                else break;\\n            }\\n            for(auto i:vals)mp1[val].push(i);\\n            if(mp1[val].empty())mp1.erase(val);\\n        }\\n        mp[index]=number;\\n        mp1[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp1.find(number)!=mp1.end())\\n        {\\n            return mp1[number].top();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322391,
                "title": "python-sortedlist-and-dictionary-easy-to-understand",
                "content": "We keep a mapping from integer to numbers and numbers to sorted indices.\\n\\nDuring update:\\n* We check if the number has been seen before and if it\\'s changing it\\'s index. If it is, handle that case.\\n* If the number has never been seen before, initialize the SortedList containing the indices\\n* If the number has been seen before, clear the index as not to create duplicates.\\n* Add the number to both the mappings.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.n2i = {}\\n        self.i2n = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.i2n and self.i2n[index] != number:\\n            orig_num = self.i2n[index]\\n            self.n2i[orig_num].discard(index)\\n            \\n        if number not in self.n2i:\\n            self.n2i[number] = SortedList()\\n        else:\\n            self.n2i[number].discard(index)\\n            \\n        self.i2n[index] = number\\n        self.n2i[number].add(index)\\n        #print(\\'change\\', index, number, self.n2i[number])\\n\\n    def find(self, number: int) -> int:\\n        if number in self.n2i:\\n            if len(self.n2i[number]) > 0:\\n                return self.n2i[number][0]\\n            else:\\n                return -1\\n        else:\\n            return -1```\\n\\t\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.n2i = {}\\n        self.i2n = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.i2n and self.i2n[index] != number:\\n            orig_num = self.i2n[index]\\n            self.n2i[orig_num].discard(index)\\n            \\n        if number not in self.n2i:\\n            self.n2i[number] = SortedList()\\n        else:\\n            self.n2i[number].discard(index)\\n            \\n        self.i2n[index] = number\\n        self.n2i[number].add(index)\\n        #print(\\'change\\', index, number, self.n2i[number])\\n\\n    def find(self, number: int) -> int:\\n        if number in self.n2i:\\n            if len(self.n2i[number]) > 0:\\n                return self.n2i[number][0]\\n            else:\\n                return -1\\n        else:\\n            return -1```",
                "codeTag": "Java"
            },
            {
                "id": 2322379,
                "title": "trivial-java-solution-with-2-hash-maps",
                "content": "**Intuition**\\n\\nOne map is used to keep a track of number and their index and second hashmap is used to keep track which number is associated with which index.\\n\\nUsed TreeSet to sort the associated index of a number and get smalled among them in O(1) time.\\n\\n```\\nclass NumberContainers {\\n\\n    \\n    HashMap<Integer, Integer> idxMap;\\n    HashMap<Integer, TreeSet<Integer>> idxSet;\\n\\n    public NumberContainers() {\\n        this.idxMap = new HashMap<>();\\n        this.idxSet = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        \\n        // If the element is present remove its idx from its set \\n        if(this.idxMap.containsKey(index)){\\n            if(this.idxMap.get(index) == number){\\n                return;\\n            }else{\\n                TreeSet<Integer> temp = this.idxSet.get(this.idxMap.get(index));\\n                temp.remove(index);\\n            }\\n        }\\n        \\n        // Insert the element int the map\\n        this.idxMap.put(index, number);\\n        \\n        // Insert its idx in it\\'s set\\n        if(this.idxSet.containsKey(number)){\\n            this.idxSet.get(number).add(index);\\n        }else{\\n            TreeSet<Integer> temp = new TreeSet<>();\\n            temp.add(index);\\n            this.idxSet.put(number,temp);\\n        }\\n        \\n        return;\\n    }\\n    \\n    public int find(int number) {\\n        if(!this.idxSet.containsKey(number)){\\n            return -1;\\n        }else{\\n            TreeSet<Integer> temp =  this.idxSet.get(number);\\n            if(temp.size() == 0){\\n                return -1;\\n            }else{\\n                return temp.first();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    \\n    HashMap<Integer, Integer> idxMap;\\n    HashMap<Integer, TreeSet<Integer>> idxSet;\\n\\n    public NumberContainers() {\\n        this.idxMap = new HashMap<>();\\n        this.idxSet = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        \\n        // If the element is present remove its idx from its set \\n        if(this.idxMap.containsKey(index)){\\n            if(this.idxMap.get(index) == number){\\n                return;\\n            }else{\\n                TreeSet<Integer> temp = this.idxSet.get(this.idxMap.get(index));\\n                temp.remove(index);\\n            }\\n        }\\n        \\n        // Insert the element int the map\\n        this.idxMap.put(index, number);\\n        \\n        // Insert its idx in it\\'s set\\n        if(this.idxSet.containsKey(number)){\\n            this.idxSet.get(number).add(index);\\n        }else{\\n            TreeSet<Integer> temp = new TreeSet<>();\\n            temp.add(index);\\n            this.idxSet.put(number,temp);\\n        }\\n        \\n        return;\\n    }\\n    \\n    public int find(int number) {\\n        if(!this.idxSet.containsKey(number)){\\n            return -1;\\n        }else{\\n            TreeSet<Integer> temp =  this.idxSet.get(number);\\n            if(temp.size() == 0){\\n                return -1;\\n            }else{\\n                return temp.first();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322267,
                "title": "simple-java-solution-hashmap-treeset-lazy-updates",
                "content": "```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> IndvalueStore;\\n    HashMap<Integer, TreeSet<Integer>> valueIndStore;\\n    public NumberContainers() {\\n        IndvalueStore = new HashMap();\\n        valueIndStore = new HashMap();\\n    }\\n    \\n    public void change(int index, int number) {\\n        IndvalueStore.put(index, number);\\n        valueIndStore.computeIfAbsent(number, s -> new TreeSet()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if (valueIndStore.containsKey(number)) {\\n            TreeSet<Integer> ts = valueIndStore.get(number);\\n            while(ts.size() > 0) {\\n                int x = ts.pollFirst();\\n                if (IndvalueStore.get(x) == number) { // Check for outdated entry. If outdated ignore and don\\'t add again.\\n                    ts.add(x);\\n                    return x;\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> IndvalueStore;\\n    HashMap<Integer, TreeSet<Integer>> valueIndStore;\\n    public NumberContainers() {\\n        IndvalueStore = new HashMap();\\n        valueIndStore = new HashMap();\\n    }\\n    \\n    public void change(int index, int number) {\\n        IndvalueStore.put(index, number);\\n        valueIndStore.computeIfAbsent(number, s -> new TreeSet()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if (valueIndStore.containsKey(number)) {\\n            TreeSet<Integer> ts = valueIndStore.get(number);\\n            while(ts.size() > 0) {\\n                int x = ts.pollFirst();\\n                if (IndvalueStore.get(x) == number) { // Check for outdated entry. If outdated ignore and don\\'t add again.\\n                    ts.add(x);\\n                    return x;\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732244,
                "title": "easy-and-fastest-java-solution",
                "content": "# Code\\n```\\nclass NumberContainers {\\n\\n    HashMap<Integer,PriorityQueue<Integer>> res;\\n    HashMap<Integer,Integer> index_val;\\n\\n    public NumberContainers() {\\n        res = new HashMap<>();\\n        index_val = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n\\n        if(index_val.containsKey(index)){\\n            int num = index_val.get(index);\\n            if(num == number){\\n                return ;\\n            }\\n\\n            res.get(num).remove(index);\\n        }\\n\\n        res.computeIfAbsent(number, k-> new PriorityQueue<>()).offer(index);\\n        index_val.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n\\n        PriorityQueue<Integer> pq = res.getOrDefault(number, new PriorityQueue<>());\\n\\n        if(pq.size() == 0){\\n            return -1;\\n        }\\n\\n        return pq.peek();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    HashMap<Integer,PriorityQueue<Integer>> res;\\n    HashMap<Integer,Integer> index_val;\\n\\n    public NumberContainers() {\\n        res = new HashMap<>();\\n        index_val = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n\\n        if(index_val.containsKey(index)){\\n            int num = index_val.get(index);\\n            if(num == number){\\n                return ;\\n            }\\n\\n            res.get(num).remove(index);\\n        }\\n\\n        res.computeIfAbsent(number, k-> new PriorityQueue<>()).offer(index);\\n        index_val.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n\\n        PriorityQueue<Integer> pq = res.getOrDefault(number, new PriorityQueue<>());\\n\\n        if(pq.size() == 0){\\n            return -1;\\n        }\\n\\n        return pq.peek();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573743,
                "title": "java-simple-treeset-solution",
                "content": "```java\\nclass NumberContainers {\\n    private final Map<Integer, Integer> indexToNumber;\\n    private final Map<Integer, TreeSet<Integer>> numberToIndexes;\\n\\n    public NumberContainers() {\\n        this.indexToNumber = new HashMap<>();\\n        this.numberToIndexes = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(this.indexToNumber.containsKey(index)) {\\n            final int n = this.indexToNumber.get(index);\\n            final TreeSet<Integer> treeSet = this.numberToIndexes.get(n);\\n\\n            treeSet.remove(index);\\n\\n            if(treeSet.isEmpty())\\n                this.numberToIndexes.remove(n);\\n        }\\n\\n        this.indexToNumber.put(index, number);\\n        this.numberToIndexes.putIfAbsent(number, new TreeSet<>());\\n        this.numberToIndexes.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        return this.numberToIndexes.containsKey(number) ? this.numberToIndexes.get(number).first() : -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass NumberContainers {\\n    private final Map<Integer, Integer> indexToNumber;\\n    private final Map<Integer, TreeSet<Integer>> numberToIndexes;\\n\\n    public NumberContainers() {\\n        this.indexToNumber = new HashMap<>();\\n        this.numberToIndexes = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(this.indexToNumber.containsKey(index)) {\\n            final int n = this.indexToNumber.get(index);\\n            final TreeSet<Integer> treeSet = this.numberToIndexes.get(n);\\n\\n            treeSet.remove(index);\\n\\n            if(treeSet.isEmpty())\\n                this.numberToIndexes.remove(n);\\n        }\\n\\n        this.indexToNumber.put(index, number);\\n        this.numberToIndexes.putIfAbsent(number, new TreeSet<>());\\n        this.numberToIndexes.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        return this.numberToIndexes.containsKey(number) ? this.numberToIndexes.get(number).first() : -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827601,
                "title": "dear-mj",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing two hashmap(dictionary, set) and renew the min index of the value each time we call the method \\'change\\'\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndescription is in the code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nchange:\\n    - if the set of prev_value is not empty after removal, we have to find min value from the set and it takes O(N)\\n    - all other operation takes O(1) because we are using hashtables\\nfind: O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        # {value: [\\'min index\\', set(indices at which the value is taking place)]}\\n        self.val_dict = {}\\n        # {index: value that is taking place at the index}\\n        self.idx_dict = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        # if there is already a number at the index,\\n        if index in self.idx_dict:\\n            # we call the number \\'prev_value\\'\\n            prev_value = self.idx_dict[index]\\n            # if prev_value is same as the given number, we do nothing\\n            if prev_value == number:\\n                return\\n            # remove the index from the set of indices of the prev_value\\n            self.val_dict[prev_value][1].remove(index)\\n            # if the set is empty, we assign \\'infinity\\' to min index of the prev_value\\n            # because it is useful when we compare the current min index and the new index\\n            if not self.val_dict[prev_value][1]:\\n                self.val_dict[prev_value][0] = sys.maxsize\\n            # if the set is not empty after removal, we assign min value of the set to the min index\\n            else:\\n                self.val_dict[prev_value][0] = min(self.val_dict[prev_value][1])\\n\\n        # now we\\'re done with the prev_value\\n        # let\\'s handle the new number and the index\\n\\n        # set the number to the idx_dict[index]\\n        self.idx_dict[index] = number\\n\\n        # if the number has already been filled into this container,\\n        if number in self.val_dict:\\n            # renew the min index\\n            # (if the min index == sys.maxsize,\\n            #  it will automatically assign new index to the min index)\\n            self.val_dict[number][0] = min(self.val_dict[number][0], index)\\n            # add new index to the set\\n            self.val_dict[number][1].add(index)\\n        # else we should make new list of [new index, {new index}]\\n        else:\\n            self.val_dict[number] = [index, {index}]\\n\\n\\n    def find(self, number: int) -> int:\\n        # if there is no index that is filled by number\\n        if number not in self.val_dict or not self.val_dict[number][1]:\\n            return -1\\n        # it will return the smallest index for the given number\\n        return self.val_dict[number][0]\\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        # {value: [\\'min index\\', set(indices at which the value is taking place)]}\\n        self.val_dict = {}\\n        # {index: value that is taking place at the index}\\n        self.idx_dict = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        # if there is already a number at the index,\\n        if index in self.idx_dict:\\n            # we call the number \\'prev_value\\'\\n            prev_value = self.idx_dict[index]\\n            # if prev_value is same as the given number, we do nothing\\n            if prev_value == number:\\n                return\\n            # remove the index from the set of indices of the prev_value\\n            self.val_dict[prev_value][1].remove(index)\\n            # if the set is empty, we assign \\'infinity\\' to min index of the prev_value\\n            # because it is useful when we compare the current min index and the new index\\n            if not self.val_dict[prev_value][1]:\\n                self.val_dict[prev_value][0] = sys.maxsize\\n            # if the set is not empty after removal, we assign min value of the set to the min index\\n            else:\\n                self.val_dict[prev_value][0] = min(self.val_dict[prev_value][1])\\n\\n        # now we\\'re done with the prev_value\\n        # let\\'s handle the new number and the index\\n\\n        # set the number to the idx_dict[index]\\n        self.idx_dict[index] = number\\n\\n        # if the number has already been filled into this container,\\n        if number in self.val_dict:\\n            # renew the min index\\n            # (if the min index == sys.maxsize,\\n            #  it will automatically assign new index to the min index)\\n            self.val_dict[number][0] = min(self.val_dict[number][0], index)\\n            # add new index to the set\\n            self.val_dict[number][1].add(index)\\n        # else we should make new list of [new index, {new index}]\\n        else:\\n            self.val_dict[number] = [index, {index}]\\n\\n\\n    def find(self, number: int) -> int:\\n        # if there is no index that is filled by number\\n        if number not in self.val_dict or not self.val_dict[number][1]:\\n            return -1\\n        # it will return the smallest index for the given number\\n        return self.val_dict[number][0]\\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503087,
                "title": "c-hashmap-and-hashset-easy-to-understand",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>>map_nums; //(number,{index}) (used set in place of unordered set to get minimum quickly )\\n    unordered_map<int,int>map_index;// (index,number)\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n         //if index already exists we have to change the map_index at given \"index\"\\n         if(map_index.find(index)!=map_index.end())\\n         {\\n             int num=map_index[index];  \\n             if(map_nums[num].size()) map_nums[num].erase(index);\\n             if(map_nums[num].size()==0)\\n                 map_nums.erase(num);\\n         }\\n          map_index[index]=number;\\n            map_nums[number].insert(index);    \\n    }\\n    \\n    int find(int number) {\\n        if(map_nums.find(number)==map_nums.end())\\n            return -1;\\n        return *map_nums[number].begin();\\n    }\\n};\\n\\n```\\nDo Upvote !",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>>map_nums; //(number,{index}) (used set in place of unordered set to get minimum quickly )\\n    unordered_map<int,int>map_index;// (index,number)\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n         //if index already exists we have to change the map_index at given \"index\"\\n         if(map_index.find(index)!=map_index.end())\\n         {\\n             int num=map_index[index];  \\n             if(map_nums[num].size()) map_nums[num].erase(index);\\n             if(map_nums[num].size()==0)\\n                 map_nums.erase(num);\\n         }\\n          map_index[index]=number;\\n            map_nums[number].insert(index);    \\n    }\\n    \\n    int find(int number) {\\n        if(map_nums.find(number)==map_nums.end())\\n            return -1;\\n        return *map_nums[number].begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366416,
                "title": "sortedlist-and-simple-dictionary-python",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass NumberContainers:\\n    def __init__(self):\\n        self.numberIndices = defaultdict(SortedList)\\n        self.indexNumber = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.indexNumber:\\n            num  = self.indexNumber[index]\\n            self.numberIndices[num].discard(index)\\n        self.indexNumber[index] = number\\n        self.numberIndices[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        if number not in self.numberIndices or not self.numberIndices[number]:\\n            return -1\\n        return self.numberIndices[number][0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass NumberContainers:\\n    def __init__(self):\\n        self.numberIndices = defaultdict(SortedList)\\n        self.indexNumber = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.indexNumber:\\n            num  = self.indexNumber[index]\\n            self.numberIndices[num].discard(index)\\n        self.indexNumber[index] = number\\n        self.numberIndices[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        if number not in self.numberIndices or not self.numberIndices[number]:\\n            return -1\\n        return self.numberIndices[number][0]",
                "codeTag": "Java"
            },
            {
                "id": 2354559,
                "title": "c-easy-code-with-2-maps",
                "content": "```class NumberContainers {\\npublic:\\n    map<int, int> ind_value;\\n    map<int, set<int>>num;\\n    NumberContainers() {\\n        ind_value.clear();\\n        num.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        if(ind_value.find(index) != ind_value.end())\\n        {\\n            int b = ind_value[index];\\n            auto it = num[b].find(index);\\n            num[b].erase(it);\\n            if(num[b].size() == 0) num.erase(b);\\n        }\\n        ind_value[index] = number;\\n        num[number].insert(index);\\n    }\\n    \\n    int find(int number) \\n    {\\n        if(num.find(number) == num.end()) return -1;\\n        return *num[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */```",
                "solutionTags": [],
                "code": "```class NumberContainers {\\npublic:\\n    map<int, int> ind_value;\\n    map<int, set<int>>num;\\n    NumberContainers() {\\n        ind_value.clear();\\n        num.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        if(ind_value.find(index) != ind_value.end())\\n        {\\n            int b = ind_value[index];\\n            auto it = num[b].find(index);\\n            num[b].erase(it);\\n            if(num[b].size() == 0) num.erase(b);\\n        }\\n        ind_value[index] = number;\\n        num[number].insert(index);\\n    }\\n    \\n    int find(int number) \\n    {\\n        if(num.find(number) == num.end()) return -1;\\n        return *num[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */```",
                "codeTag": "Java"
            },
            {
                "id": 2340555,
                "title": "javascript-two-maps-easy-to-understand",
                "content": "```\\n\\nvar NumberContainers = function() {\\n    this.obj = {}\\n    this.global = {}\\n};\\n\\n\\nNumberContainers.prototype.change = function(index, number) {\\n\\n    if(this.global[index])\\n        {\\n            for(var key in this.obj)\\n            {\\n               let ind = this.obj[key].indexOf(index)\\n                if(ind != -1)\\n                    {\\n                         this.obj[key].splice(ind, 1);\\n                        if(this.obj[number])\\n                            this.obj[number].push(index);\\n                        else\\n                            this.obj[number] = [index];\\n                        \\n                        this.global[index]=1;\\n                        return;\\n                    }\\n            }\\n        }\\n    \\n    if(this.obj[number])\\n        this.obj[number].push(index);\\n    else\\n        this.obj[number] = [index];\\n    this.global[index]=1;\\n};\\n\\nNumberContainers.prototype.find = function(number) {\\n    if(this.obj[number])\\n        {\\n            if(this.obj[number].length == 0)\\n                return -1\\n            else\\n                return Math.min(...this.obj[number])\\n        }\\n    return -1;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar NumberContainers = function() {\\n    this.obj = {}\\n    this.global = {}\\n};\\n\\n\\nNumberContainers.prototype.change = function(index, number) {\\n\\n    if(this.global[index])\\n        {\\n            for(var key in this.obj)\\n            {\\n               let ind = this.obj[key].indexOf(index)\\n                if(ind != -1)\\n                    {\\n                         this.obj[key].splice(ind, 1);\\n                        if(this.obj[number])\\n                            this.obj[number].push(index);\\n                        else\\n                            this.obj[number] = [index];\\n                        \\n                        this.global[index]=1;\\n                        return;\\n                    }\\n            }\\n        }\\n    \\n    if(this.obj[number])\\n        this.obj[number].push(index);\\n    else\\n        this.obj[number] = [index];\\n    this.global[index]=1;\\n};\\n\\nNumberContainers.prototype.find = function(number) {\\n    if(this.obj[number])\\n        {\\n            if(this.obj[number].length == 0)\\n                return -1\\n            else\\n                return Math.min(...this.obj[number])\\n        }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2331602,
                "title": "python-friedly-approach-with-analysis-simple-code",
                "content": "We are getting a sequence of numbers to either be inserted in a certain position or to be found on the structure.  We need a structure to quickly check if the index where it is going to be inserted already exists and if the number to be inserted exists as well.  We can do that with two hashes since the look-up is O(1). So we have two cases:\\n\\n1. The index of the number to be inserted does not exist. Then, we add it to our dictionary.\\n2. The index already exists.  So we update the new number at which that index is pointing to and delete from the old number\\'s list this index (next step).\\n\\nThe second dictionary keeps track of the indexes the numbers are placed in. So again, after processing the indexes, now we need to process the list of indexes of the numbers. We have two cases:\\n\\n1. The number did not exist before the insertion. We add a new entry to the second dictionary and create a list with the indexes where this number is on. In this case the list only contains one index.\\n2. The number already exists before the insertion. We look for the list of indexes and update it. We can use binary search to insert the new element which would take us O(log n) as well for deleting the index from the previous number this index belonged to.\\n\\nIt is important to keep sorted the list of numbers since that will allow us to do the lookup in O(1) because we only need to look for the number in the dictionary and return the first index on the list in case it is not empty.\\n\\nComplexity: O(1) for searching a number, O(log n) for inserting/updating.\\n\\n```\\nimport bisect  \\n\\nclass NumberContainers(object):\\n\\n    def __init__(self):\\n        self.pos = {}\\n        self.nums = {}\\n\\t\\t\\n    def change(self, index, number):\\n\\t#Look if the index has been created already\\n        if index in self.pos:\\n\\t\\t#If yes, update the old number\\'s list of indexes\\n            old = self.pos[index]\\n            del self.nums[old][bisect.bisect_left(self.nums[old], index)]\\n        self.pos[index] = number\\n\\t\\t#If the number already existed, insert to its list the new index\\n        if number in self.nums:\\n            bisect.insort(self.nums[number], index)\\n        else:    \\n            self.nums[number] = [index]\\n\\t\\t\\t\\n\\t#Look for the number, return the first position of its list of indexes            \\n    def find(self, number):\\n        if number in self.nums:\\n            if len(self.nums[number]) >= 1:\\n                return self.nums[number][0]\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nimport bisect  \\n\\nclass NumberContainers(object):\\n\\n    def __init__(self):\\n        self.pos = {}\\n        self.nums = {}\\n\\t\\t\\n    def change(self, index, number):\\n\\t#Look if the index has been created already\\n        if index in self.pos:\\n\\t\\t#If yes, update the old number\\'s list of indexes\\n            old = self.pos[index]\\n            del self.nums[old][bisect.bisect_left(self.nums[old], index)]\\n        self.pos[index] = number\\n\\t\\t#If the number already existed, insert to its list the new index\\n        if number in self.nums:\\n            bisect.insort(self.nums[number], index)\\n        else:    \\n            self.nums[number] = [index]\\n\\t\\t\\t\\n\\t#Look for the number, return the first position of its list of indexes            \\n    def find(self, number):\\n        if number in self.nums:\\n            if len(self.nums[number]) >= 1:\\n                return self.nums[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328730,
                "title": "c-easy-to-understand-solution",
                "content": "Runtime: 1220 ms, faster than 33.33% of C++ online submissions for Design a Number Container System.\\nMemory Usage: 174.3 MB, less than 33.33% of C++ online submissions for Design a Number Container System.\\n```\\nclass NumberContainers {\\npublic:\\n  unordered_map<int, set<int>> table;\\n  unordered_map<int, int> helper;\\n  \\n  void change(int index, int number) {\\n    int n;\\n    if(helper.count(index) && number != (n = helper[index]) ){\\n      table[n].erase(index);\\n      if(table[n].empty()) table.erase(n);\\n    }\\n    table[number].insert(index);\\n    helper[index] = number;\\n  }\\n    \\n  int find(int number) {\\n    if(table.count(number)) return *table[number].begin();\\n    return -1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n  unordered_map<int, set<int>> table;\\n  unordered_map<int, int> helper;\\n  \\n  void change(int index, int number) {\\n    int n;\\n    if(helper.count(index) && number != (n = helper[index]) ){\\n      table[n].erase(index);\\n      if(table[n].empty()) table.erase(n);\\n    }\\n    table[number].insert(index);\\n    helper[index] = number;\\n  }\\n    \\n  int find(int number) {\\n    if(table.count(number)) return *table[number].begin();\\n    return -1;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327473,
                "title": "design-a-number-container-system",
                "content": "Solution using unordered_map:\\n\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int ,set<int>>mm;\\n    unordered_map<int , int>v;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(!v.count(index)){\\n            v[index] = number;\\n            mm[number].insert(index);\\n        }else{\\n            mm[v[index]].erase( mm[v[index]].find(index));\\n            v[index] = number;\\n            mm[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mm[number].size() == 0)\\n\\t\\t\\treturn -1;\\n        \\n        return *(mm[number].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int ,set<int>>mm;\\n    unordered_map<int , int>v;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(!v.count(index)){\\n            v[index] = number;\\n            mm[number].insert(index);\\n        }else{\\n            mm[v[index]].erase( mm[v[index]].find(index));\\n            v[index] = number;\\n            mm[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mm[number].size() == 0)\\n\\t\\t\\treturn -1;\\n        \\n        return *(mm[number].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327255,
                "title": "python-solution-using-minheap-and-hashmap-lru-cache",
                "content": "```\\n\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nimport heapq\\n\\nclass NumberContainers:\\n    \\n    # Solution with LRU cache\\n    \\n    def __init__(self):\\n        self.index_to_num = {}\\n        self.number_to_indices = defaultdict(set)\\n        \\n    def change(self, index: int, number: int) -> None:            \\n        if index in self.index_to_num:\\n            previous_num = self.index_to_num[index]     \\n            self.number_to_indices[previous_num].discard(index)\\n\\n        self.index_to_num[index] = number    \\n        self.number_to_indices[number].add(index)\\n\\t\\t# Clears the cache, ideal would be removal of given key from cache\\n        self.find.cache_clear()\\n\\n    @lru_cache\\n    def find(self, number: int) -> int:\\n        if not number in self.number_to_indices or not self.number_to_indices[number]:\\n            return -1\\n        return min(self.number_to_indices[number])\\n    \\n    \\n    \\n    # Solution Using MinHeap\\n    \\n    def __init__(self):\\n        self.index_to_num = {}\\n        self.number_to_indices = defaultdict(list)\\n        \\n    def change(self, index: int, number: int) -> None:              \\n        if index in self.index_to_num:\\n            previous_num = self.index_to_num[index]\\n            \\n            if previous_num != number: \\n                # Remove the stale index: a) set value to -1, b) re-heapify and c) pop \\n                for i, idx in enumerate(self.number_to_indices[previous_num]):\\n                    if idx == index:\\n                        self.number_to_indices[previous_num][i] = -1\\n                        heapq.heapify(self.number_to_indices[previous_num])\\n                        heapq.heappop(self.number_to_indices[previous_num])\\n                        break\\n\\n                # If new number is to be populated at given index \\n                self.index_to_num[index] = number \\n                heapq.heappush(self.number_to_indices[number], index)\\n        else:\\n            # If no number populated before at given index \\n            self.index_to_num[index] = number      \\n            heapq.heappush(self.number_to_indices[number], index)\\n        \\n    def find(self, number: int) -> int:\\n        if not number in self.number_to_indices or not self.number_to_indices[number]:\\n            return -1\\n        return self.number_to_indices[number][0]\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfrom collections import defaultdict\\nfrom functools import lru_cache\\nimport heapq\\n\\nclass NumberContainers:\\n    \\n    # Solution with LRU cache\\n    \\n    def __init__(self):\\n        self.index_to_num = {}\\n        self.number_to_indices = defaultdict(set)\\n        \\n    def change(self, index: int, number: int) -> None:            \\n        if index in self.index_to_num:\\n            previous_num = self.index_to_num[index]     \\n            self.number_to_indices[previous_num].discard(index)\\n\\n        self.index_to_num[index] = number    \\n        self.number_to_indices[number].add(index)\\n\\t\\t# Clears the cache, ideal would be removal of given key from cache\\n        self.find.cache_clear()\\n\\n    @lru_cache\\n    def find(self, number: int) -> int:\\n        if not number in self.number_to_indices or not self.number_to_indices[number]:\\n            return -1\\n        return min(self.number_to_indices[number])\\n    \\n    \\n    \\n    # Solution Using MinHeap\\n    \\n    def __init__(self):\\n        self.index_to_num = {}\\n        self.number_to_indices = defaultdict(list)\\n        \\n    def change(self, index: int, number: int) -> None:              \\n        if index in self.index_to_num:\\n            previous_num = self.index_to_num[index]\\n            \\n            if previous_num != number: \\n                # Remove the stale index: a) set value to -1, b) re-heapify and c) pop \\n                for i, idx in enumerate(self.number_to_indices[previous_num]):\\n                    if idx == index:\\n                        self.number_to_indices[previous_num][i] = -1\\n                        heapq.heapify(self.number_to_indices[previous_num])\\n                        heapq.heappop(self.number_to_indices[previous_num])\\n                        break\\n\\n                # If new number is to be populated at given index \\n                self.index_to_num[index] = number \\n                heapq.heappush(self.number_to_indices[number], index)\\n        else:\\n            # If no number populated before at given index \\n            self.index_to_num[index] = number      \\n            heapq.heappush(self.number_to_indices[number], index)\\n        \\n    def find(self, number: int) -> int:\\n        if not number in self.number_to_indices or not self.number_to_indices[number]:\\n            return -1\\n        return self.number_to_indices[number][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324374,
                "title": "python3-sortedlist",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.mp = {} # index-to-number \\n        self.data = defaultdict(SortedList) # number-to-index \\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.mp: \\n            oldNumber = self.mp[index]\\n            self.data[oldNumber].remove(index)\\n        self.mp[index] = number \\n        self.data[number].add(index)\\n        \\n    def find(self, number: int) -> int:\\n        if self.data[number]: return self.data[number][0]\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.mp = {} # index-to-number \\n        self.data = defaultdict(SortedList) # number-to-index \\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.mp: \\n            oldNumber = self.mp[index]\\n            self.data[oldNumber].remove(index)\\n        self.mp[index] = number \\n        self.data[number].add(index)\\n        \\n    def find(self, number: int) -> int:\\n        if self.data[number]: return self.data[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323706,
                "title": "c-map-simple-algorithm-beginner-friendly-code",
                "content": "```\\n unordered_map<int,set<int>>eleindex;\\n    unordered_map<int,int>inele;\\n    NumberContainers() {   \\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(inele.count(index)){\\n            auto ele=inele[index];\\n            auto it=eleindex[ele].find(index);\\n            eleindex[ele].erase(it); \\n            if(eleindex[ele].size()==0){\\n                eleindex.erase(ele);\\n            }\\n        }\\n        inele[index]=number;\\n        eleindex[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(eleindex.find(number)==eleindex.end()){\\n            return -1;\\n        }\\n        return *eleindex[number].begin();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n unordered_map<int,set<int>>eleindex;\\n    unordered_map<int,int>inele;\\n    NumberContainers() {   \\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(inele.count(index)){\\n            auto ele=inele[index];\\n            auto it=eleindex[ele].find(index);\\n            eleindex[ele].erase(it); \\n            if(eleindex[ele].size()==0){\\n                eleindex.erase(ele);\\n            }\\n        }\\n        inele[index]=number;\\n        eleindex[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(eleindex.find(number)==eleindex.end()){\\n            return -1;\\n        }\\n        return *eleindex[number].begin();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323698,
                "title": "c-using-a-single-map-o-n",
                "content": "**Intuition**: Use a ordered map because-\\n1) for change(index, number): we can just store number at given index easily using map.\\n2) for find(number) fn, we want to get the smallest index, since the map is ordered so it can be done easily.\\n\\n**Code:**\\n```\\nclass NumberContainers {\\npublic:\\n    map<int, int> mpp;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        mpp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto &it: mpp){\\n            if(it.second== number)\\n                return it.first;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int, int> mpp;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        mpp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto &it: mpp){\\n            if(it.second== number)\\n                return it.first;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323591,
                "title": "python-3-two-dictionaries-and-heap",
                "content": "We need a dictionary *indexes*, which is simple dictionary key - value.\\nAlso we need a dictionary *numbers*. For each number we have a heap data structure (import heapq in python). \\n\\n**change function:** we update dict *indexes*. If we don\\'t have this number then we create a heap (it\\'s enouth to create a list []).\\nThen we add index in this heap.\\n\\n**find function:** if we haven\\'t added number then return -1. In another case we need to be sure that minimum that we have a heap is a valid value (information can be outdated if we call change with the index), so we check that this index has value equal to number. Otherwise we need to remove this index from the heap.\\n\\n**Example:**\\nchange(10, 5)\\nchange(20, 5)\\nchange(10, 6)\\nfind(5) -- here the minimum in the heap is 10, but this information is outdated (current value for 10 is 6), so we extract this value from the heap. In fact we can have outdated value in heap in any time, but we are interested only in minimum in change function.\\n\\n\\n```\\nclass NumberContainers:\\n    def __init__(self):\\n        self.indexes = dict()\\n        self.numbers = dict()\\n        \\n    def change(self, index: int, number: int) -> None:\\n        self.indexes[index] = number\\n        if number not in self.numbers:\\n            self.numbers[number] = []\\n        heapq.heappush(self.numbers[number], index)\\n        \\n    def find(self, number: int) -> int:\\n        if number not in self.numbers:\\n            return -1\\n        while self.numbers[number]:\\n            index = self.numbers[number][0]\\n            if self.indexes[index] != number:\\n                heapq.heappop(self.numbers[number])\\n                continue\\n            return index\\n        return -1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers:\\n    def __init__(self):\\n        self.indexes = dict()\\n        self.numbers = dict()\\n        \\n    def change(self, index: int, number: int) -> None:\\n        self.indexes[index] = number\\n        if number not in self.numbers:\\n            self.numbers[number] = []\\n        heapq.heappush(self.numbers[number], index)\\n        \\n    def find(self, number: int) -> int:\\n        if number not in self.numbers:\\n            return -1\\n        while self.numbers[number]:\\n            index = self.numbers[number][0]\\n            if self.indexes[index] != number:\\n                heapq.heappop(self.numbers[number])\\n                continue\\n            return index\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323233,
                "title": "simple-to-understand-and-very-fast-approach-using-c",
                "content": "This is very simple approach. I\\'m making use of the fact that a map in c++ has ordering of pairs in increasing  order of their key value. therefore a pair with lower index will be placed earlier. \\nNow we only need to put the key value pair in the map in the change function which is very simple one liner\\n\\n```\\n c[index] =number;\\n ```\\n**Complexity of insertion = log(n)**\\n afterwards at the time of retrieval, we iterate over all the pairs an return as soon as we get the desired number.\\n If the loop ends it means item not found so we return -1.\\n ```\\n  for(auto x: c){\\n           if(x.second == number) return x.first;\\n           }\\n ```\\n**Complexity of search O(n)**\\n\\n\\n**Full Code**\\n\\n```\\nclass NumberContainers {\\npublic:\\n    map<int,int> c;\\n    NumberContainers() {\\n       \\n    }\\n    \\n    void change(int index, int number) {\\n            c[index] =number;\\n    }\\n    \\n    int find(int number) {\\n       for(auto x: c){\\n           if(x.second == number) return x.first;\\n           }\\n        return -1;\\n       }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n c[index] =number;\\n ```\n```\\n  for(auto x: c){\\n           if(x.second == number) return x.first;\\n           }\\n ```\n```\\nclass NumberContainers {\\npublic:\\n    map<int,int> c;\\n    NumberContainers() {\\n       \\n    }\\n    \\n    void change(int index, int number) {\\n            c[index] =number;\\n    }\\n    \\n    int find(int number) {\\n       for(auto x: c){\\n           if(x.second == number) return x.first;\\n           }\\n        return -1;\\n       }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323013,
                "title": "accepted-brute-force-c",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int, int> m;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        m[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto i : m) {\\n            if(i.second == number) return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int, int> m;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        m[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto i : m) {\\n            if(i.second == number) return i.first;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322957,
                "title": "c-hashmap-easy-to-understand",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int , int>mp;\\n    NumberContainers() {\\n        mp[0] = 0;\\n    }\\n    \\n    void change(int index, int number) {\\n        mp[index] = number; \\n    }\\n    \\n    int find(int number) {\\n        int ans = INT_MAX;\\n        for(auto x : mp)\\n        {\\n            if(x.second == number)\\n            {\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int , int>mp;\\n    NumberContainers() {\\n        mp[0] = 0;\\n    }\\n    \\n    void change(int index, int number) {\\n        mp[index] = number; \\n    }\\n    \\n    int find(int number) {\\n        int ans = INT_MAX;\\n        for(auto x : mp)\\n        {\\n            if(x.second == number)\\n            {\\n                return x.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2322684,
                "title": "python3-2-maps-and-sorted-arrays",
                "content": "```\\n\\nimport bisect\\n\\n\\ndef bisect_find(a, x):\\n    \\'Locate the leftmost value exactly equal to x\\'\\n    i = bisect_left(a, x)\\n    if i != len(a) and a[i] == x:\\n        return i\\n    raise ValueError\\n\\t\\n\\t\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.index_to_value = {}\\n        self.value_to_indices = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_value:\\n            old_number = self.index_to_value[index]\\n            self.value_to_indices[old_number].pop(bisect_find(self.value_to_indices[old_number], index))\\n            if len(self.value_to_indices[old_number]) == 0:\\n                del self.value_to_indices[old_number]\\n        \\n        self.index_to_value[index] = number\\n        bisect.insort(self.value_to_indices[number], index)\\n\\n    def find(self, number: int) -> int:\\n        if number in self.value_to_indices:\\n            return self.value_to_indices[number][0]\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n\\nimport bisect\\n\\n\\ndef bisect_find(a, x):\\n    \\'Locate the leftmost value exactly equal to x\\'\\n    i = bisect_left(a, x)\\n    if i != len(a) and a[i] == x:\\n        return i\\n    raise ValueError\\n\\t\\n\\t\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.index_to_value = {}\\n        self.value_to_indices = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_value:\\n            old_number = self.index_to_value[index]\\n            self.value_to_indices[old_number].pop(bisect_find(self.value_to_indices[old_number], index))\\n            if len(self.value_to_indices[old_number]) == 0:\\n                del self.value_to_indices[old_number]\\n        \\n        self.index_to_value[index] = number\\n        bisect.insort(self.value_to_indices[number], index)\\n\\n    def find(self, number: int) -> int:\\n        if number in self.value_to_indices:\\n            return self.value_to_indices[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322678,
                "title": "easy-implementation-hashing-using-map-set",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> idxArr; // index -> number\\n    unordered_map<int,set<int>> mpp;    // number -> set of indexes\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(idxArr.count(index)) {\\n            int prevNum=idxArr[index];\\n            idxArr[index]=number;\\n            mpp[prevNum].erase(index);\\n            mpp[number].insert(index);\\n        }\\n        \\n        else {\\n            idxArr[index]=number;\\n            mpp[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mpp.count(number)) {\\n            if(mpp[number].size()==0)   return -1;\\n            return *(mpp[number].begin());\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Please upvote if you liked the solution\\n\\n# \\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> idxArr; // index -> number\\n    unordered_map<int,set<int>> mpp;    // number -> set of indexes\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(idxArr.count(index)) {\\n            int prevNum=idxArr[index];\\n            idxArr[index]=number;\\n            mpp[prevNum].erase(index);\\n            mpp[number].insert(index);\\n        }\\n        \\n        else {\\n            idxArr[index]=number;\\n            mpp[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mpp.count(number)) {\\n            if(mpp[number].size()==0)   return -1;\\n            return *(mpp[number].begin());\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322632,
                "title": "map-c",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    int sz = 1e9+1;\\n    unordered_map<int,int> indexNum;\\n    unordered_map<int,set<int>> mp;\\n    \\n    NumberContainers() {\\n        indexNum.clear();\\n        mp.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        if(indexNum.find(index) == indexNum.end()){\\n            mp[number].insert(index);\\n            indexNum[index] = number;\\n        } else {\\n            int num = indexNum[index];\\n            mp[num].erase(mp[num].find(index));\\n            \\n            if(mp[num].size() == 0){\\n                mp.erase(num);\\n            }\\n            \\n            mp[number].insert(index);\\n            indexNum[index] = number;\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number) == mp.end())\\n            return -1;\\n        else{\\n            auto it = mp[number].begin();\\n            return *it;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    int sz = 1e9+1;\\n    unordered_map<int,int> indexNum;\\n    unordered_map<int,set<int>> mp;\\n    \\n    NumberContainers() {\\n        indexNum.clear();\\n        mp.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        if(indexNum.find(index) == indexNum.end()){\\n            mp[number].insert(index);\\n            indexNum[index] = number;\\n        } else {\\n            int num = indexNum[index];\\n            mp[num].erase(mp[num].find(index));\\n            \\n            if(mp[num].size() == 0){\\n                mp.erase(num);\\n            }\\n            \\n            mp[number].insert(index);\\n            indexNum[index] = number;\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number) == mp.end())\\n            return -1;\\n        else{\\n            auto it = mp[number].begin();\\n            return *it;\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2322615,
                "title": "python-sortedlist-bst",
                "content": "```\\nfrom sortedcontainers import SortedList as bst\\n\\nclass NumberContainers:\\n    def __init__(self):\\n        self.index = dict()\\n        self.num_indices = defaultdict(bst)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index:\\n            old_val = self.index[index]\\n            self.num_indices[old_val].remove(index)\\n        self.index[index] = number\\n        self.num_indices[number].add(index)\\n    \\n    def find(self, number: int) -> int:\\n        if self.num_indices[number]:\\n            return self.num_indices[number][0]\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList as bst\\n\\nclass NumberContainers:\\n    def __init__(self):\\n        self.index = dict()\\n        self.num_indices = defaultdict(bst)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index:\\n            old_val = self.index[index]\\n            self.num_indices[old_val].remove(index)\\n        self.index[index] = number\\n        self.num_indices[number].add(index)\\n    \\n    def find(self, number: int) -> int:\\n        if self.num_indices[number]:\\n            return self.num_indices[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322611,
                "title": "using-map-easy-to-understand-readable-shortest-code",
                "content": "map<int,int >map;\\n //  unordered_map<int,vector<int>>map;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int i, int n) {\\n       map[i]=n;       \\n    }\\n    int find(int n) {\\nfor(auto it:map)\\n{\\nif(it.second==n)  return it.first;\\n}\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "map<int,int >map;\\n //  unordered_map<int,vector<int>>map;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int i, int n) {\\n       map[i]=n;       \\n    }\\n    int find(int n) {\\nfor(auto it:map)\\n{\\nif(it.second==n)  return it.first;\\n}\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2322601,
                "title": "using-single-hashmap",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int> mp;\\n    NumberContainers() { \\n    }\\n    \\n    void change(int index, int number) {\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto i:mp){\\n            if(i.second==number) return i.first;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int> mp;\\n    NumberContainers() { \\n    }\\n    \\n    void change(int index, int number) {\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto i:mp){\\n            if(i.second==number) return i.first;\\n        }\\n        return -1;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2322579,
                "title": "java-two-maps",
                "content": "```\\nclass NumberContainers {\\n    Map<Integer, Integer> idxMap;\\n    Map<Integer, TreeSet<Integer>> numMap;\\n    public NumberContainers() {\\n        idxMap = new HashMap<>();\\n        numMap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        int curNum = idxMap.getOrDefault(index, -1);\\n        if(curNum != -1){\\n            if(numMap.get(curNum) != null) numMap.get(curNum).remove(index);\\n        }\\n        numMap.putIfAbsent(number, new TreeSet<>());\\n        numMap.get(number).add(index);\\n        idxMap.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        if(numMap.get(number) != null){\\n            if(!numMap.get(number).isEmpty()){\\n                return numMap.get(number).first();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer, Integer> idxMap;\\n    Map<Integer, TreeSet<Integer>> numMap;\\n    public NumberContainers() {\\n        idxMap = new HashMap<>();\\n        numMap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        int curNum = idxMap.getOrDefault(index, -1);\\n        if(curNum != -1){\\n            if(numMap.get(curNum) != null) numMap.get(curNum).remove(index);\\n        }\\n        numMap.putIfAbsent(number, new TreeSet<>());\\n        numMap.get(number).add(index);\\n        idxMap.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        if(numMap.get(number) != null){\\n            if(!numMap.get(number).isEmpty()){\\n                return numMap.get(number).first();\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322490,
                "title": "map-c",
                "content": "**C++**\\n\\n       public:\\n       map<int,int> m;\\n    NumberContainers() {\\n        }\\n    \\n    void change(int index, int number) {\\n        m[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==number)return it->first;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**C++**\\n\\n       public:\\n       map<int,int> m;\\n    NumberContainers() {\\n        }\\n    \\n    void change(int index, int number) {\\n        m[index]=number;\\n    }\\n    \\n    int find(int number) {\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second==number)return it->first;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2322426,
                "title": "c-map-and-set-easy-to-understand",
                "content": "class NumberContainers {\\npublic:\\n\\n    unordered_map<int,set<int>> m;\\n    unordered_set<int> usedIdx; \\\\\\n\\t\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(usedIdx.count(index)){\\n            for(auto& it: m){\\n                if(it.second.count(index)){\\n                    it.second.erase(index);\\n                    usedIdx.erase(index);\\n                }\\n            }\\n        }\\n        \\n        m[number].insert(index);\\n        usedIdx.insert(index);\\n    \\n    }\\n    \\n    int find(int number) {\\n\\t\\n        if(m.count(number) && m[number].size() > 0)\\n            return *(m[number].begin());\\n        else return -1;\\n\\t\\t\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class NumberContainers {\\npublic:\\n\\n    unordered_map<int,set<int>> m;\\n    unordered_set<int> usedIdx; \\\\\\n\\t\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(usedIdx.count(index)){\\n            for(auto& it: m){\\n                if(it.second.count(index)){\\n                    it.second.erase(index);\\n                    usedIdx.erase(index);\\n                }\\n            }\\n        }\\n        \\n        m[number].insert(index);\\n        usedIdx.insert(index);\\n    \\n    }\\n    \\n    int find(int number) {\\n\\t\\n        if(m.count(number) && m[number].size() > 0)\\n            return *(m[number].begin());\\n        else return -1;\\n\\t\\t\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2322384,
                "title": "sortedset-java-very-easy",
                "content": "```\\nclass NumberContainers {\\n    \\n    HashMap<Integer, SortedSet<Integer>> numb = new HashMap();\\n    HashMap<Integer, Integer> ind = new HashMap();\\n\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        int n = ind.getOrDefault(index, -1);\\n        if(ind.getOrDefault(index, Integer.MAX_VALUE) == number)\\n            return;\\n        \\n        SortedSet<Integer> set= numb.getOrDefault(number, new TreeSet());\\n        set.add(index);\\n        numb.put(number, set);\\n        \\n        ind.put(index,number);\\n        \\n        \\n        if(n != -1){\\n            SortedSet<Integer> set2= numb.getOrDefault(n, new TreeSet());\\n            set2.remove(Integer.valueOf(index));\\n            numb.put(n, set2);\\n        }\\n               \\n    }\\n    \\n    public int find(int number) {\\n        SortedSet<Integer> set= numb.getOrDefault(number, new TreeSet());\\n        if(set.size() == 0)\\n            return -1;\\n        int ans = set.first();\\n        return ans;\\n        \\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    \\n    HashMap<Integer, SortedSet<Integer>> numb = new HashMap();\\n    HashMap<Integer, Integer> ind = new HashMap();\\n\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        int n = ind.getOrDefault(index, -1);\\n        if(ind.getOrDefault(index, Integer.MAX_VALUE) == number)\\n            return;\\n        \\n        SortedSet<Integer> set= numb.getOrDefault(number, new TreeSet());\\n        set.add(index);\\n        numb.put(number, set);\\n        \\n        ind.put(index,number);\\n        \\n        \\n        if(n != -1){\\n            SortedSet<Integer> set2= numb.getOrDefault(n, new TreeSet());\\n            set2.remove(Integer.valueOf(index));\\n            numb.put(n, set2);\\n        }\\n               \\n    }\\n    \\n    public int find(int number) {\\n        SortedSet<Integer> set= numb.getOrDefault(number, new TreeSet());\\n        if(set.size() == 0)\\n            return -1;\\n        int ans = set.first();\\n        return ans;\\n        \\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2322341,
                "title": "java-simple-using-1-treemap-o-n",
                "content": "```\\nclass NumberContainers {\\nTreeMap<Integer,Integer>map;\\n    public NumberContainers() {\\n    map=new TreeMap<>();\\n        \\n    }\\n    public void change(int index, int number) {\\n       map.put(index,number); \\n    }\\n    \\n    public int find(int number) {\\n        for(int i:map.keySet())\\n            if(map.get(i)==number)return i;\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumberContainers {\\nTreeMap<Integer,Integer>map;\\n    public NumberContainers() {\\n    map=new TreeMap<>();\\n        \\n    }\\n    public void change(int index, int number) {\\n       map.put(index,number); \\n    }\\n    \\n    public int find(int number) {\\n        for(int i:map.keySet())\\n            if(map.get(i)==number)return i;\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322340,
                "title": "c-map-with-priority-queue-easily-understandable-code",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, priority_queue<int,vector<int>, greater<int>>> mp;\\n    unordered_map<int, int> blockedList;\\n    \\n    NumberContainers() {\\n\\n    }\\n    \\n    void change(int index, int number) {\\n        blockedList[index] = number;\\n       \\n        mp[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        \\n        if(mp.find(number)!=mp.end()) {\\n            \\n           while(!mp[number].empty()){\\n               int x = mp[number].top();\\n               if(blockedList[x]==number) return x;\\n               mp[number].pop();\\n           }   \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int, priority_queue<int,vector<int>, greater<int>>> mp;\\n    unordered_map<int, int> blockedList;\\n    \\n    NumberContainers() {\\n\\n    }\\n    \\n    void change(int index, int number) {\\n        blockedList[index] = number;\\n       \\n        mp[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        \\n        if(mp.find(number)!=mp.end()) {\\n            \\n           while(!mp[number].empty()){\\n               int x = mp[number].top();\\n               if(blockedList[x]==number) return x;\\n               mp[number].pop();\\n           }   \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322318,
                "title": "solution-with-explanation-and-example-priority-queue",
                "content": "We will store indices and use number as index because we have to find index based on number.\\nfor getting the minimum index we used priority_queue.\\nFor change operation we will track the current index\\'s number using another map.\\nIn find function-\\nwe will go to the priority queue saved in ```number``` index \\nif we see that priority queue\\'s top element\\'s current ```number``` is not the given ```number``` we will pop it .\\nwe will pop till the priority queue becomes empty then we will return -1 \\nelse we will return priority queue\\'s top element.\\n\\nexample - \\n\\tchange(2,10)    -> 10- 2\\n\\t\\t\\t\\t\\t\\t\\t\\treg-> 2->10\\n\\tchange(1,10)     -> 10- 1,2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treg-> 1->10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2-.10\\n\\tfind(10)     ->    OUTPUT- 1    \\n\\t\\t\\t\\t\\t\\t\\t\\tsince pq.top() is 1 and res[1] is 10 \\n\\tchange(1,20)    ->   10 -> 1,2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t20-> 1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treg->  1->20\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2->10\\n\\tfind(10)          ->   OUTPUT-> 2\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpq.top() is 1 but when we checked reg[1] it is 20 so we poped it and the pq.top() becomes 2 whose reg value is 10 so we retured 2. \\n\\n```\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>>dic;\\n    unordered_map<int,int>reg;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        // if(reg[number]){\\n            dic[number].push(index);\\n            reg[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(dic[number].empty())return -1;\\n        while(!dic[number].empty() &&\\n            reg[dic[number].top()]!=number\\n        ){\\n            dic[number].pop();\\n        }\\n        if(dic[number].empty())return -1;\\n        return dic[number].top();\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```number```\n```number```\n```number```\n```\\n    unordered_map<int,priority_queue<int,vector<int>,greater<int>>>dic;\\n    unordered_map<int,int>reg;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        // if(reg[number]){\\n            dic[number].push(index);\\n            reg[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(dic[number].empty())return -1;\\n        while(!dic[number].empty() &&\\n            reg[dic[number].top()]!=number\\n        ){\\n            dic[number].pop();\\n        }\\n        if(dic[number].empty())return -1;\\n        return dic[number].top();\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322317,
                "title": "simple-python-solution-heap-hashmap-7-lines-o-nlogn-time-o-n-space-complexity",
                "content": "Basic idea:\\n=========\\nUse a combination of hashmaps and heap:\\n- Heap hashmap - key is number, value is a heap to store the indexes and get the minimum index.\\n- Array hashmap - key is index, value is number.\\n\\nArray hashmap is used to inform the heap hashmap if the ```index``` is still used for ```number```. If the ```index``` is no longer used, it will be ignored, and it will be popped from the heap.\\n\\n```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.arr = defaultdict(int)\\n        self.heapht = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.arr[index] = number        \\n        heappush(self.heapht[number], index)\\n\\n    def find(self, number: int) -> int:\\n        while len(self.heapht[number]) > 0 and self.arr[self.heapht[number][0]] != number:\\n            heappop(self.heapht[number])\\n        return self.heapht[number][0] if len(self.heapht[number]) > 0 else -1\\n```",
                "solutionTags": [],
                "code": "```index```\n```number```\n```index```\n```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.arr = defaultdict(int)\\n        self.heapht = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.arr[index] = number        \\n        heappush(self.heapht[number], index)\\n\\n    def find(self, number: int) -> int:\\n        while len(self.heapht[number]) > 0 and self.arr[self.heapht[number][0]] != number:\\n            heappop(self.heapht[number])\\n        return self.heapht[number][0] if len(self.heapht[number]) > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322302,
                "title": "c-map-and-set",
                "content": "**Code:**\\n```cpp\\nclass NumberContainers {\\npublic:\\n    map<int, int> keyToVal;\\n    map<int, set<int>> index;\\n    NumberContainers() {}\\n    \\n    void change(int indx, int number) {\\n        if(keyToVal.find(indx) != keyToVal.end())\\n        {\\n            int oldVal = keyToVal[indx];\\n            index[oldVal].erase(indx);\\n        }\\n        keyToVal[indx] = number;\\n        index[number].insert(indx);\\n    }\\n    \\n    int find(int number) {\\n        if(index[number].size() == 0) return -1;\\n        return *(index[number].begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass NumberContainers {\\npublic:\\n    map<int, int> keyToVal;\\n    map<int, set<int>> index;\\n    NumberContainers() {}\\n    \\n    void change(int indx, int number) {\\n        if(keyToVal.find(indx) != keyToVal.end())\\n        {\\n            int oldVal = keyToVal[indx];\\n            index[oldVal].erase(indx);\\n        }\\n        keyToVal[indx] = number;\\n        index[number].insert(indx);\\n    }\\n    \\n    int find(int number) {\\n        if(index[number].size() == 0) return -1;\\n        return *(index[number].begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322300,
                "title": "clean-c-code",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    map<int, int> m1;\\n    map<int, set<int>> m2;\\n\\n    void change(int index, int number) {\\n        m2[number].insert(index);\\n        if(m1.find(index)!=m1.end() and m1[index]!=number)\\n        {\\n            int x=m1[index];\\n            m2[x].erase(m2[x].find(index));\\n            m1[index]=number;\\n        }\\n        else\\n            m1[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        \\n        int ans =-1;\\n        if(m2[number].size()==0) return ans;\\n        else\\n            ans= *m2[number].begin();\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    map<int, int> m1;\\n    map<int, set<int>> m2;\\n\\n    void change(int index, int number) {\\n        m2[number].insert(index);\\n        if(m1.find(index)!=m1.end() and m1[index]!=number)\\n        {\\n            int x=m1[index];\\n            m2[x].erase(m2[x].find(index));\\n            m1[index]=number;\\n        }\\n        else\\n            m1[index]=number;\\n        \\n    }\\n    \\n    int find(int number) {\\n        \\n        int ans =-1;\\n        if(m2[number].size()==0) return ans;\\n        else\\n            ans= *m2[number].begin();\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322297,
                "title": "very-simple-easy-to-understand-c-solution-using-map-reverse-indexing",
                "content": "<b> Up Vote if you like the solution\\n```\\n//take two maps and one is used for reverse indexing \\nclass NumberContainers {\\npublic:\\n    unordered_map<int, set<int>> mp;\\n    unordered_map<int, int> tmp;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        if(tmp.find(index) != tmp.end()) {\\n            int t = tmp[index];\\n            mp[t].erase(index);\\n            if(mp[t].size() == 0) mp.erase(t);\\n        }\\n        tmp[index] = number;\\n        mp[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number) == mp.end()) return -1;\\n        return *mp[number].begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//take two maps and one is used for reverse indexing \\nclass NumberContainers {\\npublic:\\n    unordered_map<int, set<int>> mp;\\n    unordered_map<int, int> tmp;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        if(tmp.find(index) != tmp.end()) {\\n            int t = tmp[index];\\n            mp[t].erase(index);\\n            if(mp[t].size() == 0) mp.erase(t);\\n        }\\n        tmp[index] = number;\\n        mp[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number) == mp.end()) return -1;\\n        return *mp[number].begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322293,
                "title": "java-hashmap-treeset",
                "content": "**Logic:**\\nMaintain a hashmap for mapping indices to values stored.\\nMaintain another hashmap to map all the indices containing same values. A treeset sorts the values in ascending order so the first value is the smallest index.\\nOn calling the change() function, if the index already has an element, need to remove the index from the treeset.\\nFinally, while calling find(), if the value is absent, return -1 else the first value in treeset.\\n\\n```\\nclass NumberContainers\\n{\\n    HashMap<Integer,Integer> val;\\n    HashMap<Integer,TreeSet<Integer>> min_id;\\n    public NumberContainers()\\n    {\\n        val = new HashMap<>();\\n        min_id = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number)\\n    {\\n        if(val.containsKey(index))\\n            min_id.get(val.get(index)).remove(index);\\n        if(!min_id.containsKey(number))\\n            min_id.put(number,new TreeSet<Integer>());\\n        val.put(index,number);\\n        min_id.get(number).add(index);\\n    }\\n    \\n    public int find(int number)\\n    {\\n        if(!min_id.containsKey(number) || min_id.get(number).size() == 0)\\n            return -1;\\n        return min_id.get(number).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers\\n{\\n    HashMap<Integer,Integer> val;\\n    HashMap<Integer,TreeSet<Integer>> min_id;\\n    public NumberContainers()\\n    {\\n        val = new HashMap<>();\\n        min_id = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number)\\n    {\\n        if(val.containsKey(index))\\n            min_id.get(val.get(index)).remove(index);\\n        if(!min_id.containsKey(number))\\n            min_id.put(number,new TreeSet<Integer>());\\n        val.put(index,number);\\n        min_id.get(number).add(index);\\n    }\\n    \\n    public int find(int number)\\n    {\\n        if(!min_id.containsKey(number) || min_id.get(number).size() == 0)\\n            return -1;\\n        return min_id.get(number).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322277,
                "title": "with-explanation-c",
                "content": "```\\n\\nclass NumberContainers {\\n public:\\n  // numToIdx will store number as key and indices as value\\n  // idxToNum will store index as key and number as value\\n  unordered_map<int, set<int> > numToIdx;\\n  unordered_map<int, int> idxToNum;\\n  NumberContainers() {}\\n  void change(int index, int number) {\\n    // if we have number at this index then remove it from numToIdx and change in idxToNum\\n    if (idxToNum.count(index)) {\\n      int toDelete = idxToNum[index];\\n      numToIdx[toDelete].erase(index);\\n      if (numToIdx[toDelete].empty()) numToIdx.erase(toDelete);\\n    }\\n    idxToNum[index] = number;\\n    numToIdx[number].insert(index);\\n  }\\n  int find(int number) {\\n    // if we have this number then return otherwise return -1\\n    return !numToIdx.count(number) ? -1 : *begin(numToIdx[number]);\\n  }\\n};\\n\\n\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [],
                "code": "```\\n\\nclass NumberContainers {\\n public:\\n  // numToIdx will store number as key and indices as value\\n  // idxToNum will store index as key and number as value\\n  unordered_map<int, set<int> > numToIdx;\\n  unordered_map<int, int> idxToNum;\\n  NumberContainers() {}\\n  void change(int index, int number) {\\n    // if we have number at this index then remove it from numToIdx and change in idxToNum\\n    if (idxToNum.count(index)) {\\n      int toDelete = idxToNum[index];\\n      numToIdx[toDelete].erase(index);\\n      if (numToIdx[toDelete].empty()) numToIdx.erase(toDelete);\\n    }\\n    idxToNum[index] = number;\\n    numToIdx[number].insert(index);\\n  }\\n  int find(int number) {\\n    // if we have this number then return otherwise return -1\\n    return !numToIdx.count(number) ? -1 : *begin(numToIdx[number]);\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322274,
                "title": "java-with-detailed-comments-6130-design-a-number-container-system",
                "content": "**Idea**:\\nWe can have 2 maps, for storing\\n- `Index -> Number mapping` and\\n- `Number -> Indices mapping`\\n\\nWhile storing `Number -> Indices`, we can store the indices in a TreeSet for faster lookup.\\n\\n**Code**:\\n```\\nclass NumberContainers {\\n\\n    Map<Integer, Integer> map;                  // Map to store \"Index -> Number\" mapping\\n    Map<Integer, TreeSet<Integer>> numbers;     // Map to store \"Number -> TreeSet of indices\" mapping\\n\\n    public NumberContainers() {\\n        map = new HashMap();\\n        numbers = new HashMap();\\n    }\\n\\n    public void change(int index, int number) {\\n        if (map.containsKey(index)) {                   // If we are replacing a number on an existing index\\n            int prev = map.get(index);                  // Get the number which was there earlier\\n            // From the numbers list, remove the index\\n            Set<Integer> set1 = numbers.get(prev);      // Get the Set of indices on this number\\n            if (set1 != null)\\n                set1.remove(index);                     // Remove the index from this set\\n\\n        }\\n        map.put(index, number);                         // Add the \"Index -> Number\" mapping for given index\\n        TreeSet<Integer> set = numbers.get(number);\\n        if (set == null)\\n            set = new TreeSet<>();\\n        set.add(index);                                \\n        numbers.put(number, set);                       // Add the \"Number -> index\" mapping in corresponding TreeSet of indices\\n    }\\n\\n    public int find(int number) {\\n        TreeSet<Integer> set = numbers.get(number);\\n        if (set == null || set.ceiling(0) == null)\\n            return -1;                                  // If the number does not exist, return -1\\n        return set.ceiling(0);                          // From the \"Number -> TreeSet of indices\" mapping, get the smallest index if it exist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    Map<Integer, Integer> map;                  // Map to store \"Index -> Number\" mapping\\n    Map<Integer, TreeSet<Integer>> numbers;     // Map to store \"Number -> TreeSet of indices\" mapping\\n\\n    public NumberContainers() {\\n        map = new HashMap();\\n        numbers = new HashMap();\\n    }\\n\\n    public void change(int index, int number) {\\n        if (map.containsKey(index)) {                   // If we are replacing a number on an existing index\\n            int prev = map.get(index);                  // Get the number which was there earlier\\n            // From the numbers list, remove the index\\n            Set<Integer> set1 = numbers.get(prev);      // Get the Set of indices on this number\\n            if (set1 != null)\\n                set1.remove(index);                     // Remove the index from this set\\n\\n        }\\n        map.put(index, number);                         // Add the \"Index -> Number\" mapping for given index\\n        TreeSet<Integer> set = numbers.get(number);\\n        if (set == null)\\n            set = new TreeSet<>();\\n        set.add(index);                                \\n        numbers.put(number, set);                       // Add the \"Number -> index\" mapping in corresponding TreeSet of indices\\n    }\\n\\n    public int find(int number) {\\n        TreeSet<Integer> set = numbers.get(number);\\n        if (set == null || set.ceiling(0) == null)\\n            return -1;                                  // If the number does not exist, return -1\\n        return set.ceiling(0);                          // From the \"Number -> TreeSet of indices\" mapping, get the smallest index if it exist\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060053,
                "title": "c-python-heap-lazy-remove-solution-with-explanation",
                "content": "### heap + lazy remove\\nwe have 2 hash map,\\nself.idx_to_number record index\\'s number,\\nself.number_to_idxs is to mapping a number to a min heap.\\n\\nwhen we change a index\\'s number,\\nif index\\'s number is not changed, just return,\\nor update self.idx_to_number, and put index to min heap.\\n\\nwhen we find smallest index,\\nwhen top index of min heap  whose number != number,\\npop it until top index of min heap  whose number == number.\\nif heap is empty return -1.\\n\\n### python\\n```python\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.number_to_idxs = defaultdict(list)\\n        self.idx_to_number = defaultdict(int)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.idx_to_number and self.idx_to_number[index] == number: return\\n        self.idx_to_number[index] = number\\n        heappush(self.number_to_idxs[number], index)\\n    \\n    def find(self, number: int) -> int:\\n        if not self.number_to_idxs[number]: return -1\\n        heap = self.number_to_idxs[number]\\n        while heap and self.idx_to_number[heap[0]] != number:\\n            heappop(heap)\\n        return heap[0] if heap else -1\\n```\\n\\n### c++\\n```cpp\\nclass cmp {\\npublic:\\n    bool operator()(int &x, int& y) {return y < x;}\\n};\\n\\nclass NumberContainers {\\npublic:\\n     \\n    unordered_map<int, int> idx_to_number;\\n    unordered_map<int, priority_queue<int, vector<int>, cmp>> number_to_idxs;\\n    NumberContainers(){}\\n    \\n    void change(int index, int number) {\\n        if (this -> idx_to_number.count(index) == 1 && this -> idx_to_number[index] == number) return;\\n        this -> idx_to_number[index] = number;\\n        this -> number_to_idxs[number].emplace(index);\\n    }\\n    \\n    int find(int number) {\\n        if (this -> number_to_idxs[number].size() == 0) return -1;\\n        auto& heap = this -> number_to_idxs[number];\\n        while (!heap.empty() && this -> idx_to_number[heap.top()] != number)\\n            heap.pop();\\n        return !heap.empty()? heap.top(): -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.number_to_idxs = defaultdict(list)\\n        self.idx_to_number = defaultdict(int)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.idx_to_number and self.idx_to_number[index] == number: return\\n        self.idx_to_number[index] = number\\n        heappush(self.number_to_idxs[number], index)\\n    \\n    def find(self, number: int) -> int:\\n        if not self.number_to_idxs[number]: return -1\\n        heap = self.number_to_idxs[number]\\n        while heap and self.idx_to_number[heap[0]] != number:\\n            heappop(heap)\\n        return heap[0] if heap else -1\\n```\n```cpp\\nclass cmp {\\npublic:\\n    bool operator()(int &x, int& y) {return y < x;}\\n};\\n\\nclass NumberContainers {\\npublic:\\n     \\n    unordered_map<int, int> idx_to_number;\\n    unordered_map<int, priority_queue<int, vector<int>, cmp>> number_to_idxs;\\n    NumberContainers(){}\\n    \\n    void change(int index, int number) {\\n        if (this -> idx_to_number.count(index) == 1 && this -> idx_to_number[index] == number) return;\\n        this -> idx_to_number[index] = number;\\n        this -> number_to_idxs[number].emplace(index);\\n    }\\n    \\n    int find(int number) {\\n        if (this -> number_to_idxs[number].size() == 0) return -1;\\n        auto& heap = this -> number_to_idxs[number];\\n        while (!heap.empty() && this -> idx_to_number[heap.top()] != number)\\n            heap.pop();\\n        return !heap.empty()? heap.top(): -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049079,
                "title": "java-map-treeset-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Use a Map<Index, Number> indexToNumber to map each index to each number\\n2. Use a Map<Number, TreeSet<Indices>> numberIndices to map each number to its set of indices\\n3. find(number)\\n    - if numberIndices contains the given number, return the first entry of the TreeSet\\n4. change\\n    - Integer oldNumber = indexToNumber.put(index, number).\\n    - If indexToNumber DID contain another number at that index, then you have to remove that index\\nfrom the set of indices:   numberIndices.get(oldNumber).remove(index).\\n    - Add the new index to map & TreeSet of numberIndices: numberIndices.get(number).add(index)   \\n\\n# Complexity\\n- Time complexity:$$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\n    private final Map<Integer, Integer> indexToNumber;\\n    private final Map<Integer, TreeSet<Integer>> numberIndices;\\n    public NumberContainers() {\\n        indexToNumber = new HashMap<>();\\n        numberIndices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = indexToNumber.put(index, number);\\n        if (oldNumber != null) {\\n            // remove from set\\n            TreeSet<Integer> oldNumberSet = numberIndices.get(oldNumber);\\n            if (oldNumberSet.size() == 1) {\\n                numberIndices.remove(oldNumber);\\n            } else {\\n                oldNumberSet.remove(index);\\n            }\\n        }\\n        // add to new index set\\n        numberIndices.computeIfAbsent(number, k -> new TreeSet<>()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        TreeSet<Integer> indices = numberIndices.get(number);\\n        if (indices != null) {\\n            return indices.first();\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    private final Map<Integer, Integer> indexToNumber;\\n    private final Map<Integer, TreeSet<Integer>> numberIndices;\\n    public NumberContainers() {\\n        indexToNumber = new HashMap<>();\\n        numberIndices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = indexToNumber.put(index, number);\\n        if (oldNumber != null) {\\n            // remove from set\\n            TreeSet<Integer> oldNumberSet = numberIndices.get(oldNumber);\\n            if (oldNumberSet.size() == 1) {\\n                numberIndices.remove(oldNumber);\\n            } else {\\n                oldNumberSet.remove(index);\\n            }\\n        }\\n        // add to new index set\\n        numberIndices.computeIfAbsent(number, k -> new TreeSet<>()).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        TreeSet<Integer> indices = numberIndices.get(number);\\n        if (indices != null) {\\n            return indices.first();\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021100,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Use two maps to keep the track of the data.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Map will keep the track of the index and second one will be keeping  track of the index corresponding to a number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>ind;\\n    unordered_map<int,multiset<int>>vec;\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        //check if  it already exist in the system or not\\n        if(ind.find(index)==ind.end()){\\n            //it does not exists create a entry\\n            ind[index] = number;\\n            vec[number].insert(index);\\n        }\\n        else{\\n            //it  does exits in the system now we need to change it\\n            vec[ind[index]].erase(index);\\n            if(vec[ind[index]].size()==0){\\n                vec.erase(ind[index]);\\n            }\\n            ind[index] = number;\\n            vec[number].insert(index);\\n        }\\n\\n\\n    }\\n    \\n    int find(int number) {\\n        \\n        //if that number is even present or  not\\n        if(vec.find(number)==vec.end()){\\n            //it does not  exists in the system\\n            return -1;\\n        }\\n        else{\\n            auto  ele =  vec[number].begin();\\n            return *ele;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>ind;\\n    unordered_map<int,multiset<int>>vec;\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        \\n        //check if  it already exist in the system or not\\n        if(ind.find(index)==ind.end()){\\n            //it does not exists create a entry\\n            ind[index] = number;\\n            vec[number].insert(index);\\n        }\\n        else{\\n            //it  does exits in the system now we need to change it\\n            vec[ind[index]].erase(index);\\n            if(vec[ind[index]].size()==0){\\n                vec.erase(ind[index]);\\n            }\\n            ind[index] = number;\\n            vec[number].insert(index);\\n        }\\n\\n\\n    }\\n    \\n    int find(int number) {\\n        \\n        //if that number is even present or  not\\n        if(vec.find(number)==vec.end()){\\n            //it does not  exists in the system\\n            return -1;\\n        }\\n        else{\\n            auto  ele =  vec[number].begin();\\n            return *ele;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919382,
                "title": "heap-hashmap-python3-solution",
                "content": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num_indices = defaultdict(list)\\n        self.num_at_index = {}\\n        \\n\\n    def change(self, index: int, number: int) -> None:\\n        self.num_at_index[index] = number\\n        heapq.heappush(self.num_indices[number], index)\\n        \\n\\n    def find(self, number: int) -> int:\\n        while self.num_indices[number] and self.num_at_index[self.num_indices[number][0]] != number:\\n            heapq.heappop(self.num_indices[number])\\n        \\n        return self.num_indices[number][0] if len(self.num_indices[number]) > 0 else -1\\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num_indices = defaultdict(list)\\n        self.num_at_index = {}\\n        \\n\\n    def change(self, index: int, number: int) -> None:\\n        self.num_at_index[index] = number\\n        heapq.heappush(self.num_indices[number], index)\\n        \\n\\n    def find(self, number: int) -> int:\\n        while self.num_indices[number] and self.num_at_index[self.num_indices[number][0]] != number:\\n            heapq.heappop(self.num_indices[number])\\n        \\n        return self.num_indices[number][0] if len(self.num_indices[number]) > 0 else -1\\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908327,
                "title": "c-2-maps",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> m1;\\n    unordered_map<int, set<int>> m2;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        if (m1.count(index)){\\n            m2[m1[index]].erase(index);\\n            if (m2[m1[index]].empty()) m2.erase(m1[index]);\\n        }\\n        m1[index] = number;\\n        m2[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if (!m2.count(number)) return -1;\\n        return *m2[number].begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> m1;\\n    unordered_map<int, set<int>> m2;\\n    NumberContainers() {\\n        \\n    }\\n    void change(int index, int number) {\\n        if (m1.count(index)){\\n            m2[m1[index]].erase(index);\\n            if (m2[m1[index]].empty()) m2.erase(m1[index]);\\n        }\\n        m1[index] = number;\\n        m2[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if (!m2.count(number)) return -1;\\n        return *m2[number].begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885517,
                "title": "python3-priority-queue-hash-solution",
                "content": "# Code\\n```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.indexDict = {}\\n        self.numberDict = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.indexDict[index] = number\\n        heappush(self.numberDict[number],index)\\n        \\n    def find(self, number: int) -> int:\\n        while self.numberDict[number]:\\n            if self.indexDict[self.numberDict[number][0]]!=number:\\n                heappop(self.numberDict[number])\\n            else:\\n                break\\n        if len(self.numberDict[number])==0:\\n            return -1\\n        else:\\n            return self.numberDict[number][0]\\n        \\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.indexDict = {}\\n        self.numberDict = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.indexDict[index] = number\\n        heappush(self.numberDict[number],index)\\n        \\n    def find(self, number: int) -> int:\\n        while self.numberDict[number]:\\n            if self.indexDict[self.numberDict[number][0]]!=number:\\n                heappop(self.numberDict[number])\\n            else:\\n                break\\n        if len(self.numberDict[number])==0:\\n            return -1\\n        else:\\n            return self.numberDict[number][0]\\n        \\n        \\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792551,
                "title": "two-maps-easy-to-understand-c",
                "content": "# Intuition\\nJust design two maps(one for number->all its indices and another for index->number)\\nSee code for understanding it better\\n\\n# Complexity\\n- Time complexity:\\nchange:O(logn+log m)(n:No. of distinct numbers and k=number of distinct indices) (Worst case because of erase function)\\nfind:O(1)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> m;\\n    unordered_map<int,int> m2;\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        if(m2.find(index)==m2.end())\\n        {   m2[index]=number;\\n            m[number].insert(index);\\n        }\\n        else\\n        {\\n            int curr=m2[index];\\n            m[curr].erase(index);\\n            if(m[curr].size()==0)\\n                m.erase(curr);\\n            m[number].insert(index);\\n            m2[index]=number;\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(m.find(number)==m.end())\\n            return -1;\\n        return *m[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> m;\\n    unordered_map<int,int> m2;\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        if(m2.find(index)==m2.end())\\n        {   m2[index]=number;\\n            m[number].insert(index);\\n        }\\n        else\\n        {\\n            int curr=m2[index];\\n            m[curr].erase(index);\\n            if(m[curr].size()==0)\\n                m.erase(curr);\\n            m[number].insert(index);\\n            m2[index]=number;\\n            \\n            \\n        }\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(m.find(number)==m.end())\\n            return -1;\\n        return *m[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782802,
                "title": "c-solution-using-map-beats-72",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are using the map<int,set> in order to store all the indexes at which a number is present. So for a given no, we can keep inserting all the indices at which it is present. so since the set stores element in sorted order. we can use this to implement the find function.\\n\\nAnd in change function, we are checking if that index is already occupied by some number ,if it is already occupied by some number, we can make the changes accordingly to the map and then insert it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nfor find function\\nO(1)\\nfor change function\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp.find(index)!=mp.end())\\n            mp1[mp[index]].erase(index);\\n\\n        mp[index]=number;\\n        mp1[number].insert(index);     \\n    }\\n    \\n    int find(int number) {\\n        if(mp1[number].size()==0)\\n            return -1;\\n        else\\n            return *mp1[number].begin();     \\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp.find(index)!=mp.end())\\n            mp1[mp[index]].erase(index);\\n\\n        mp[index]=number;\\n        mp1[number].insert(index);     \\n    }\\n    \\n    int find(int number) {\\n        if(mp1[number].size()==0)\\n            return -1;\\n        else\\n            return *mp1[number].begin();     \\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712979,
                "title": "java-simple-and-short",
                "content": "```\\nclass NumberContainers {\\n    Map<Integer, Integer>      idxToNumber = new HashMap<>();\\n    Map<Integer, Set<Integer>> numToIdxs   = new HashMap<>();\\n    \\n    public void change(int idx, int number) {\\n        var formerNumber = idxToNumber.get(idx);\\n        numToIdxs.getOrDefault(formerNumber,Collections.emptySet()).remove(idx);            \\n        numToIdxs.computeIfAbsent(number,v->new TreeSet<Integer>()).add(idx);\\n        idxToNumber.put(idx,number);\\n    }\\n    \\n    public int find(int n) {\\n        var indices = numToIdxs.getOrDefault(n,Collections.emptySet());\\n        return indices.isEmpty()? -1 : indices.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer, Integer>      idxToNumber = new HashMap<>();\\n    Map<Integer, Set<Integer>> numToIdxs   = new HashMap<>();\\n    \\n    public void change(int idx, int number) {\\n        var formerNumber = idxToNumber.get(idx);\\n        numToIdxs.getOrDefault(formerNumber,Collections.emptySet()).remove(idx);            \\n        numToIdxs.computeIfAbsent(number,v->new TreeSet<Integer>()).add(idx);\\n        idxToNumber.put(idx,number);\\n    }\\n    \\n    public int find(int n) {\\n        var indices = numToIdxs.getOrDefault(n,Collections.emptySet());\\n        return indices.isEmpty()? -1 : indices.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701786,
                "title": "using-map-and-set-of-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n\\nunordered_map<int,int> m;\\nunordered_map<int,set<int>> ms;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(m.find(index)!=m.end()){\\n            int num=m[index];\\n            ms[num].erase(index);\\n            m[index]=number;\\n            ms[number].insert(index);\\n        }else{\\n            m[index]=number;\\n            ms[number].insert(index);\\n        }\\n      \\n    }\\n    \\n    int find(int number) {\\n        if(ms[number].empty())\\n        return -1;\\n        int ans=*ms[number].begin();\\n        return ans;\\n       // return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n\\nunordered_map<int,int> m;\\nunordered_map<int,set<int>> ms;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(m.find(index)!=m.end()){\\n            int num=m[index];\\n            ms[num].erase(index);\\n            m[index]=number;\\n            ms[number].insert(index);\\n        }else{\\n            m[index]=number;\\n            ms[number].insert(index);\\n        }\\n      \\n    }\\n    \\n    int find(int number) {\\n        if(ms[number].empty())\\n        return -1;\\n        int ans=*ms[number].begin();\\n        return ans;\\n       // return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634448,
                "title": "2-solutions-basic-array-and-sorted-array-for-optimisation-two-maps",
                "content": "# Naive\\n```\\nclass NumberContainers {\\n    var nums: [Int: Int]\\n    var indexes: [Int: [Int]]\\n    init() {\\n        nums = [:]\\n        indexes = [:]\\n    }\\n    \\n    func change(_ index: Int, _ number: Int) {\\n        if let n = nums[index] {\\n            indexes[n]!.removeAll { $0 == index }\\n        }\\n        nums[index] = number\\n        indexes[number, default: []].append(index)\\n    }\\n    \\n    func find(_ number: Int) -> Int {\\n        indexes[number]?.min() ?? -1\\n    }\\n}\\n\\n```\\n# Optimized (Use SortedArray instead of regular array)\\n```\\nclass NumberContainers {\\n    var nums: [Int: Int]\\n    var indexes: [Int: SortedArray<Int>]\\n    init() {\\n        nums = [:]\\n        indexes = [:]\\n    }\\n    \\n    func change(_ index: Int, _ number: Int) {\\n        if let n = nums[index] {\\n            indexes[n]!.remove(index)\\n        }\\n        nums[index] = number\\n        indexes[number, default: SortedArray()].insert(index)\\n    }\\n    \\n    func find(_ number: Int) -> Int {\\n        indexes[number]?.min() ?? -1\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass NumberContainers {\\n    var nums: [Int: Int]\\n    var indexes: [Int: [Int]]\\n    init() {\\n        nums = [:]\\n        indexes = [:]\\n    }\\n    \\n    func change(_ index: Int, _ number: Int) {\\n        if let n = nums[index] {\\n            indexes[n]!.removeAll { $0 == index }\\n        }\\n        nums[index] = number\\n        indexes[number, default: []].append(index)\\n    }\\n    \\n    func find(_ number: Int) -> Int {\\n        indexes[number]?.min() ?? -1\\n    }\\n}\\n\\n```\n```\\nclass NumberContainers {\\n    var nums: [Int: Int]\\n    var indexes: [Int: SortedArray<Int>]\\n    init() {\\n        nums = [:]\\n        indexes = [:]\\n    }\\n    \\n    func change(_ index: Int, _ number: Int) {\\n        if let n = nums[index] {\\n            indexes[n]!.remove(index)\\n        }\\n        nums[index] = number\\n        indexes[number, default: SortedArray()].insert(index)\\n    }\\n    \\n    func find(_ number: Int) -> Int {\\n        indexes[number]?.min() ?? -1\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625634,
                "title": "cracking-the-code",
                "content": "**Solution**\\n\\n```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = dict()\\n        self.indexes = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.nums[index] = number\\n        heapq.heappush(self.indexes[number], index)\\n\\n    def find(self, number: int) -> int:\\n        \\n        while self.indexes[number] and number != self.nums[self.indexes[number][0]]:\\n            heapq.heappop(self.indexes[number])\\n        \\n        if self.indexes[number]:\\n            return self.indexes[number][0]\\n        return -1\\n```\\n\\nGreetings, code enthusiasts! \\uD83D\\uDD25 Today, we are going to unravel a unique and exciting Python class named `NumberContainers` which serves as an exemplary demonstration of effective number management. With its intuitive yet powerful approach, this Python class will revolutionize the way you handle numbers in your programs. \\n\\nAre you ready to get a deep dive into the world of heaps and dictionaries? Let\\'s jump in! \\uD83D\\uDCA5\\n\\n## Understanding the Blueprint \\uD83C\\uDFD7\\uFE0F\\n\\nThe `NumberContainers` class utilizes Python\\'s dictionary and default dictionary data structures, coupled with a min-heap structure to manage numbers at specific indices in an incredibly efficient manner. \\n\\n```python\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = dict()\\n        self.indexes = defaultdict(list)\\n```\\nOur journey begins with the initialization of two essential data structures in our class: a dictionary `self.nums` to store the number along with its index and a defaultdict `self.indexes`, which leverages Python\\'s built-in heap structure to store all indices for a specific number.\\n\\n```python\\n    def change(self, index: int, number: int) -> None:\\n        self.nums[index] = number\\n        heapq.heappush(self.indexes[number], index)\\n```\\n\\nNext up is the `change` function. This function updates or inserts a new number at the provided index. To keep our indices sorted for each number, we utilize the `heapq.heappush()` method, which efficiently pushes a new index into the heap while maintaining the heap invariant.\\n\\n```python\\n    def find(self, number: int) -> int:\\n        \\n        while self.indexes[number] and number != self.nums[self.indexes[number][0]]:\\n            heapq.heappop(self.indexes[number])\\n        \\n        if self.indexes[number]:\\n            return self.indexes[number][0]\\n        return -1\\n```\\n\\nLastly, we have the `find` function, which is in charge of returning the smallest index for the provided number. If no such number exists in our system, it simply returns -1.\\n\\n## Unmasking the Magic Behind The Code \\uD83C\\uDFA9\\n\\nThis implementation shines due to its clever use of data structures and their properties. By storing numbers and their indices in `self.nums` and maintaining a min-heap of indices for each number in `self.indexes`, we have constant time access to the smallest index of any number. \\n\\nWhen we need to find the smallest index for a number, we can directly access the heap\\'s root from `self.indexes` and retrieve the smallest index in O(1) time. The only challenge arises when an index in the heap is outdated (i.e., when the number at that index has been replaced by a different number). However, our implementation handles this efficiently by removing outdated indices at the beginning of the `find` function.\\n\\n## Performance & Efficiency: Time Complexity \\uD83D\\uDD51\\n\\nThe efficiency of this solution lies in the performance of the operations it executes. The `change` operation, which involves pushing an index to a heap, has a time complexity of O(log K), where K is the number of indices that a number has. \\n\\nThe `find` operation has a time complexity of O(K) in the worst-case scenario, where K is the number of outdated indices that have to be popped from the heap. However, in most cases, the number of outdated indices will be significantly small, making the operation highly efficient.\\n\\nWith the `NumberContainers` class, you\\'ll be handling numbers and indices like a pro! This class presents a robust and efficient solution to manage numbers in an intuitive yet powerful manner, making it a fantastic tool to have in your programming toolkit! \\uD83D\\uDCBC\\n\\nRemember, the key to unlocking your code\\'s potential lies in understanding the logic behind it. So, keep coding, keep exploring, and most importantly, enjoy the process! Happy coding! \\uD83C\\uDF89\\n\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = dict()\\n        self.indexes = defaultdict(list)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.nums[index] = number\\n        heapq.heappush(self.indexes[number], index)\\n\\n    def find(self, number: int) -> int:\\n        \\n        while self.indexes[number] and number != self.nums[self.indexes[number][0]]:\\n            heapq.heappop(self.indexes[number])\\n        \\n        if self.indexes[number]:\\n            return self.indexes[number][0]\\n        return -1\\n```\n```python\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = dict()\\n        self.indexes = defaultdict(list)\\n```\n```python\\n    def change(self, index: int, number: int) -> None:\\n        self.nums[index] = number\\n        heapq.heappush(self.indexes[number], index)\\n```\n```python\\n    def find(self, number: int) -> int:\\n        \\n        while self.indexes[number] and number != self.nums[self.indexes[number][0]]:\\n            heapq.heappop(self.indexes[number])\\n        \\n        if self.indexes[number]:\\n            return self.indexes[number][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623859,
                "title": "hashmap-treeset-cqrs-principle",
                "content": "# Intuition\\nThis is a problem to be solved using two objects, one to keep the most updated list and one to store all the indexes changes of the number.\\n\\n# Approach\\nThe key point is when there`s comming a change in the updated list, so you have to maintain the find list\\nThe TreeSet help up keeping the value we need in the first position.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass NumberContainers() {\\n\\n     val changeHashMap = HashMap<Int, Int>()\\n        val findHashMap = HashMap<Int, TreeSet<Int>>()\\n\\n        fun change(index: Int, number: Int) {\\n            changeHashMap[index]?.let { oldNumber ->\\n                findHashMap[oldNumber]?.remove(index)\\n            }\\n\\n            changeHashMap[index] = number\\n            findHashMap.computeIfAbsent(number) { TreeSet() }.add(index)\\n        }\\n\\n        fun find(number: Int): Int {\\n            return findHashMap[number]?.firstOrNull() ?: -1\\n        }\\n\\n        \\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * var obj = NumberContainers()\\n * obj.change(index,number)\\n * var param_2 = obj.find(number)\\n */\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass NumberContainers() {\\n\\n     val changeHashMap = HashMap<Int, Int>()\\n        val findHashMap = HashMap<Int, TreeSet<Int>>()\\n\\n        fun change(index: Int, number: Int) {\\n            changeHashMap[index]?.let { oldNumber ->\\n                findHashMap[oldNumber]?.remove(index)\\n            }\\n\\n            changeHashMap[index] = number\\n            findHashMap.computeIfAbsent(number) { TreeSet() }.add(index)\\n        }\\n\\n        fun find(number: Int): Int {\\n            return findHashMap[number]?.firstOrNull() ?: -1\\n        }\\n\\n        \\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * var obj = NumberContainers()\\n * obj.change(index,number)\\n * var param_2 = obj.find(number)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580600,
                "title": "set-map-c",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,set<int>> mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        int prev_num=mp1[index];\\n        mp1[index]=number;\\n        if (mp2[prev_num].find(index)!=mp2[prev_num].end())\\n        {\\n             mp2[prev_num].erase(index);\\n             if (mp2[prev_num].size()==0)\\n               mp2.erase(prev_num);\\n        }\\n           \\n        mp2[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if (mp2.find(number)==mp2.end())\\n          return -1;\\n        return *(mp2[number].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,set<int>> mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        int prev_num=mp1[index];\\n        mp1[index]=number;\\n        if (mp2[prev_num].find(index)!=mp2[prev_num].end())\\n        {\\n             mp2[prev_num].erase(index);\\n             if (mp2[prev_num].size()==0)\\n               mp2.erase(prev_num);\\n        }\\n           \\n        mp2[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if (mp2.find(number)==mp2.end())\\n          return -1;\\n        return *(mp2[number].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566139,
                "title": "java-python3-easy-understanding-sortedlist",
                "content": "\\n# Complexity\\n- Time complexity:   O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nimport java.util.*;\\n\\nclass NumberContainers {\\n    private Map<Integer, TreeSet<Integer>> num;\\n    private Map<Integer, Integer> index;\\n\\n    public NumberContainers() {\\n        this.num = new HashMap<>();\\n        this.index = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        if (this.index.containsKey(index)) {\\n            int old = this.index.get(index);\\n            TreeSet<Integer> oldSet = this.num.get(old);\\n            oldSet.remove(index);\\n            if (oldSet.isEmpty()) {\\n                this.num.remove(old);\\n            }\\n        }\\n        this.num.computeIfAbsent(number, k -> new TreeSet<>()).add(index);\\n        this.index.put(index, number);\\n    }\\n\\n    public int find(int number) {\\n        TreeSet<Integer> numberSet = this.num.get(number);\\n        return (numberSet != null && !numberSet.isEmpty()) ? numberSet.first() : -1;\\n    }\\n}\\n\\n\\n```\\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num = defaultdict(SortedList)\\n        self.index = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index:\\n            old = self.index[index]\\n            self.num[old].discard(index)\\n            if not self.num[old]:\\n                del self.num[old]\\n        self.num[number].add(index)\\n        self.index[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        return self.num[number][0] if number in self.num else -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nimport java.util.*;\\n\\nclass NumberContainers {\\n    private Map<Integer, TreeSet<Integer>> num;\\n    private Map<Integer, Integer> index;\\n\\n    public NumberContainers() {\\n        this.num = new HashMap<>();\\n        this.index = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        if (this.index.containsKey(index)) {\\n            int old = this.index.get(index);\\n            TreeSet<Integer> oldSet = this.num.get(old);\\n            oldSet.remove(index);\\n            if (oldSet.isEmpty()) {\\n                this.num.remove(old);\\n            }\\n        }\\n        this.num.computeIfAbsent(number, k -> new TreeSet<>()).add(index);\\n        this.index.put(index, number);\\n    }\\n\\n    public int find(int number) {\\n        TreeSet<Integer> numberSet = this.num.get(number);\\n        return (numberSet != null && !numberSet.isEmpty()) ? numberSet.first() : -1;\\n    }\\n}\\n\\n\\n```\n```python []\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.num = defaultdict(SortedList)\\n        self.index = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index:\\n            old = self.index[index]\\n            self.num[old].discard(index)\\n            if not self.num[old]:\\n                del self.num[old]\\n        self.num[number].add(index)\\n        self.index[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        return self.num[number][0] if number in self.num else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491441,
                "title": "two-maps-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar NumberContainers = function() {\\n    this.map1={}\\n    this.map2={}\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} number\\n * @return {void}\\n */\\nNumberContainers.prototype.change = function(index, number) {\\n    if (this.map1[index]!==undefined){\\n        if (this.map1[index] !==number ){\\n        var i=this.map2[this.map1[index]].indexOf(index)\\n        this.map2[this.map1[index]].splice(i,1)\\n      }\\n    }\\n    if (this.map2[number] !==undefined){\\n        if (!this.map2[number].includes(index)) this.map2[number].push(index)\\n    }else this.map2[number]=[index]\\n    this.map1[index]=number\\n};\\n\\n/** \\n * @param {number} number\\n * @return {number}\\n */\\nNumberContainers.prototype.find = function(number) {\\n  \\n   if (this.map2[number] ===undefined || this.map2[number].length===0) return -1\\n   \\n   return Math.min(...this.map2[number])\\n\\n};\\n\\n/** \\n * Your NumberContainers object will be instantiated and called as such:\\n * var obj = new NumberContainers()\\n * obj.change(index,number)\\n * var param_2 = obj.find(number)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nvar NumberContainers = function() {\\n    this.map1={}\\n    this.map2={}\\n};\\n\\n/** \\n * @param {number} index \\n * @param {number} number\\n * @return {void}\\n */\\nNumberContainers.prototype.change = function(index, number) {\\n    if (this.map1[index]!==undefined){\\n        if (this.map1[index] !==number ){\\n        var i=this.map2[this.map1[index]].indexOf(index)\\n        this.map2[this.map1[index]].splice(i,1)\\n      }\\n    }\\n    if (this.map2[number] !==undefined){\\n        if (!this.map2[number].includes(index)) this.map2[number].push(index)\\n    }else this.map2[number]=[index]\\n    this.map1[index]=number\\n};\\n\\n/** \\n * @param {number} number\\n * @return {number}\\n */\\nNumberContainers.prototype.find = function(number) {\\n  \\n   if (this.map2[number] ===undefined || this.map2[number].length===0) return -1\\n   \\n   return Math.min(...this.map2[number])\\n\\n};\\n\\n/** \\n * Your NumberContainers object will be instantiated and called as such:\\n * var obj = new NumberContainers()\\n * obj.change(index,number)\\n * var param_2 = obj.find(number)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462859,
                "title": "design-a-number-container-system",
                "content": "------------- Easy C++ Solution -------------------\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\nunordered_map<int, priority_queue<int, vector<int>, greater<int>>> values;\\n    unordered_map<int, int> data;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        data[index] = number;\\n        values[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        while (!values[number].empty()) {\\n            int idx = values[number].top();\\n            if (data[idx] == number) return idx;\\n            values[number].pop();\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\nunordered_map<int, priority_queue<int, vector<int>, greater<int>>> values;\\n    unordered_map<int, int> data;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        data[index] = number;\\n        values[number].push(index);\\n    }\\n    \\n    int find(int number) {\\n        while (!values[number].empty()) {\\n            int idx = values[number].top();\\n            if (data[idx] == number) return idx;\\n            values[number].pop();\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442231,
                "title": "javascript-two-maps-extended-heap-time-beats-100",
                "content": "# Approach\\n- We can use two maps to store index-to-number and number-to-index mappings.\\n- Let\\'s store index-to-number mappings as they are, and use min priority queues to keep indices in number-to-index mappings. This will allow us to restore a previous minimum index in case the current minimum index is re-assigned.\\n- We need the priority queue to support \"delete by value\" operation, so let\\'s implement a binary heap with `delete()` method. The heap will use internal value-to-index mappings for fast search. \\n\\n# Time Complexity\\n- `change()`: O(log n)\\n- `find()`: O(1)\\n\\n\\n# Code\\n```\\nclass NumberContainers {\\n  _indicesToNumbers = new Map();\\n  _numbersToIndices = new Map();\\n\\n  change(index, number) {\\n    const prevNumber = this._indicesToNumbers.get(index);\\n\\n    // Do nothing if the number is the same\\n    if (prevNumber === number) {\\n      return;\\n    }\\n\\n    // Remove association between the previous number and the index\\n    if (prevNumber !== undefined) {\\n      const prevNumberQueue = this._numbersToIndices.get(prevNumber);\\n      prevNumberQueue.delete(index);\\n\\n      if (prevNumberQueue.isEmpty) {\\n        this._numbersToIndices.delete(prevNumber);\\n      }\\n    }\\n\\n    this._indicesToNumbers.set(index, number);\\n\\n    // Add association between the new number and the index\\n    const currentNumberQueue = this._numbersToIndices.get(number);\\n    if (currentNumberQueue) {\\n      currentNumberQueue.insert(index);\\n    } else {\\n      const newQueue = new MinHeap();\\n      newQueue.insert(index);\\n      this._numbersToIndices.set(number, newQueue);\\n    }\\n  }\\n\\n  find(number) {\\n    const queue = this._numbersToIndices.get(number);\\n    return queue === undefined ? -1 : queue.min;\\n  }\\n}\\n\\n\\nclass MinHeap {\\n  _values = [];\\n  _valuesToIndices = new Map();\\n\\n  insert(x) {\\n    this._values.push(x);\\n    this._valuesToIndices.set(x, this.size - 1);\\n\\n    this._siftUp(this.size - 1);\\n  }\\n\\n  delete(x) {\\n    const index = this._valuesToIndices.get(x);\\n\\n    this._valuesToIndices.delete(x);\\n\\n    if (this.size === 1 || index === this.size - 1) {\\n      this._values.pop();\\n      return;\\n    }\\n\\n    this._values[index] = this._values.pop();\\n    this._valuesToIndices.set(this._values[index], index);\\n\\n    // We should restore the heap property, but we don\\'t know the direction,\\n    // so we have to call both (only one will actually change the heap)\\n    this._siftDown(index);\\n    this._siftUp(index);\\n  }\\n\\n  get min() {\\n    return this._values[0];\\n  }\\n\\n  get isEmpty() {\\n    return this.size === 0;\\n  }\\n\\n  get size() {\\n    return this._values.length;\\n  }\\n\\n  _siftUp(i) {\\n    const parent = Math.floor((i - 1) / 2);\\n\\n    if (parent >= 0 && this._values[i] < this._values[parent]) {\\n      [this._values[i], this._values[parent]] =\\n        [this._values[parent], this._values[i]];\\n\\n      this._valuesToIndices.set(this._values[i], i);\\n      this._valuesToIndices.set(this._values[parent], parent);\\n\\n      this._siftUp(parent);\\n    }\\n  }\\n\\n  _siftDown(i) {\\n    const left = i * 2 + 1;\\n    const right = i * 2 + 2;\\n\\n    let min = i;\\n\\n    if (left < this.size && this._values[left] < this._values[min]) {\\n      min = left;\\n    }\\n\\n    if (right < this.size && this._values[right] < this._values[min]) {\\n      min = right;\\n    }\\n\\n    if (min === i) return;\\n\\n    [this._values[i], this._values[min]] =\\n      [this._values[min], this._values[i]];\\n\\n    this._valuesToIndices.set(this._values[i], i);\\n    this._valuesToIndices.set(this._values[min], min);\\n\\n    this._siftDown(min);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers {\\n  _indicesToNumbers = new Map();\\n  _numbersToIndices = new Map();\\n\\n  change(index, number) {\\n    const prevNumber = this._indicesToNumbers.get(index);\\n\\n    // Do nothing if the number is the same\\n    if (prevNumber === number) {\\n      return;\\n    }\\n\\n    // Remove association between the previous number and the index\\n    if (prevNumber !== undefined) {\\n      const prevNumberQueue = this._numbersToIndices.get(prevNumber);\\n      prevNumberQueue.delete(index);\\n\\n      if (prevNumberQueue.isEmpty) {\\n        this._numbersToIndices.delete(prevNumber);\\n      }\\n    }\\n\\n    this._indicesToNumbers.set(index, number);\\n\\n    // Add association between the new number and the index\\n    const currentNumberQueue = this._numbersToIndices.get(number);\\n    if (currentNumberQueue) {\\n      currentNumberQueue.insert(index);\\n    } else {\\n      const newQueue = new MinHeap();\\n      newQueue.insert(index);\\n      this._numbersToIndices.set(number, newQueue);\\n    }\\n  }\\n\\n  find(number) {\\n    const queue = this._numbersToIndices.get(number);\\n    return queue === undefined ? -1 : queue.min;\\n  }\\n}\\n\\n\\nclass MinHeap {\\n  _values = [];\\n  _valuesToIndices = new Map();\\n\\n  insert(x) {\\n    this._values.push(x);\\n    this._valuesToIndices.set(x, this.size - 1);\\n\\n    this._siftUp(this.size - 1);\\n  }\\n\\n  delete(x) {\\n    const index = this._valuesToIndices.get(x);\\n\\n    this._valuesToIndices.delete(x);\\n\\n    if (this.size === 1 || index === this.size - 1) {\\n      this._values.pop();\\n      return;\\n    }\\n\\n    this._values[index] = this._values.pop();\\n    this._valuesToIndices.set(this._values[index], index);\\n\\n    // We should restore the heap property, but we don\\'t know the direction,\\n    // so we have to call both (only one will actually change the heap)\\n    this._siftDown(index);\\n    this._siftUp(index);\\n  }\\n\\n  get min() {\\n    return this._values[0];\\n  }\\n\\n  get isEmpty() {\\n    return this.size === 0;\\n  }\\n\\n  get size() {\\n    return this._values.length;\\n  }\\n\\n  _siftUp(i) {\\n    const parent = Math.floor((i - 1) / 2);\\n\\n    if (parent >= 0 && this._values[i] < this._values[parent]) {\\n      [this._values[i], this._values[parent]] =\\n        [this._values[parent], this._values[i]];\\n\\n      this._valuesToIndices.set(this._values[i], i);\\n      this._valuesToIndices.set(this._values[parent], parent);\\n\\n      this._siftUp(parent);\\n    }\\n  }\\n\\n  _siftDown(i) {\\n    const left = i * 2 + 1;\\n    const right = i * 2 + 2;\\n\\n    let min = i;\\n\\n    if (left < this.size && this._values[left] < this._values[min]) {\\n      min = left;\\n    }\\n\\n    if (right < this.size && this._values[right] < this._values[min]) {\\n      min = right;\\n    }\\n\\n    if (min === i) return;\\n\\n    [this._values[i], this._values[min]] =\\n      [this._values[min], this._values[i]];\\n\\n    this._valuesToIndices.set(this._values[i], i);\\n    this._valuesToIndices.set(this._values[min], min);\\n\\n    this._siftDown(min);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440836,
                "title": "simple-set-and-map-approach-c-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logN) --> change O(1) --> find\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map <int,set<int>> umap;\\n    unordered_map <int,int> data;\\n\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int ind, int num) {\\n        if(data.find(ind)==data.end()){\\n            data[ind] = num;\\n            umap[num].insert(ind);\\n        }\\n        else{\\n            int curr = data[ind];\\n            umap[curr].erase(ind);\\n            umap[num].insert(ind);\\n            data[ind] = num;\\n        }\\n    }\\n    \\n    int find(int num) {\\n        if(umap[num].empty()) return -1;\\n        return *umap[num].begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map <int,set<int>> umap;\\n    unordered_map <int,int> data;\\n\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int ind, int num) {\\n        if(data.find(ind)==data.end()){\\n            data[ind] = num;\\n            umap[num].insert(ind);\\n        }\\n        else{\\n            int curr = data[ind];\\n            umap[curr].erase(ind);\\n            umap[num].insert(ind);\\n            data[ind] = num;\\n        }\\n    }\\n    \\n    int find(int num) {\\n        if(umap[num].empty()) return -1;\\n        return *umap[num].begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417826,
                "title": "python-hashmap-heap",
                "content": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        #this is hold which value has which index\\n        self.mp = defaultdict(int)\\n        #this will be used to keep track of the order of indexs\\n        self.mpOrd = defaultdict(list)\\n        #this will be used to quickly mark a value as deleted without having to update our MpOrd.\\n        #We can make write times much faster at a slight runtime cost on our read\\n        self.tombstone = defaultdict(dict)\\n    def change(self, index: int, number: int) -> None:\\n        \\n        #mark the tombstone if we are overwriting this value\\n        if index in self.mp:\\n            self.tombstone[self.mp[index]][index] = False\\n        \\n        #assign the index to the value\\n        self.mp[index] = number\\n        \\n        #add this index to our ordering\\n        heappush(self.mpOrd[number], index)\\n        \\n        #this value is being re overwritten again so we can remove the tombstone\\n        if number in self.tombstone and index in self.tombstone[number] and self.tombstone[number][index] == False:\\n            del self.tombstone[number][index]\\n        \\n\\n    def find(self, number: int) -> int:\\n        #find next index\\n        #if we have no ordering return -1\\n        if number in self.mpOrd:\\n            \\n            #lets loop through all our or indexes smallest to largest and grab the first non deleted one\\n            while self.mpOrd[number]:\\n                #check the index\\n                val = self.mpOrd[number][0]\\n                #if our index is tombstoned we cannot use it so pop and continue\\n                if number in self.tombstone and val in self.tombstone[number]:\\n                    heappop(self.mpOrd[number])\\n                else:\\n                    #we found a value that is not tombstoned\\n                    return val\\n                \\n            #all of the values are tombstoned\\n            return -1\\n            \\n        else:\\n            return -1\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        #this is hold which value has which index\\n        self.mp = defaultdict(int)\\n        #this will be used to keep track of the order of indexs\\n        self.mpOrd = defaultdict(list)\\n        #this will be used to quickly mark a value as deleted without having to update our MpOrd.\\n        #We can make write times much faster at a slight runtime cost on our read\\n        self.tombstone = defaultdict(dict)\\n    def change(self, index: int, number: int) -> None:\\n        \\n        #mark the tombstone if we are overwriting this value\\n        if index in self.mp:\\n            self.tombstone[self.mp[index]][index] = False\\n        \\n        #assign the index to the value\\n        self.mp[index] = number\\n        \\n        #add this index to our ordering\\n        heappush(self.mpOrd[number], index)\\n        \\n        #this value is being re overwritten again so we can remove the tombstone\\n        if number in self.tombstone and index in self.tombstone[number] and self.tombstone[number][index] == False:\\n            del self.tombstone[number][index]\\n        \\n\\n    def find(self, number: int) -> int:\\n        #find next index\\n        #if we have no ordering return -1\\n        if number in self.mpOrd:\\n            \\n            #lets loop through all our or indexes smallest to largest and grab the first non deleted one\\n            while self.mpOrd[number]:\\n                #check the index\\n                val = self.mpOrd[number][0]\\n                #if our index is tombstoned we cannot use it so pop and continue\\n                if number in self.tombstone and val in self.tombstone[number]:\\n                    heappop(self.mpOrd[number])\\n                else:\\n                    #we found a value that is not tombstoned\\n                    return val\\n                \\n            #all of the values are tombstoned\\n            return -1\\n            \\n        else:\\n            return -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3373077,
                "title": "c-hash-table-and-pq",
                "content": "```\\npublic class NumberContainers {\\n    Dictionary<int,PriorityQueue<int,int>> dict=new Dictionary<int,PriorityQueue<int,int>>();\\n    Dictionary<int,int> pos=new Dictionary<int,int>();\\n    \\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void Change(int index, int number) {\\n        if(!dict.ContainsKey(number))\\n            dict.Add(number,new PriorityQueue<int,int>());\\n        \\n        dict[number].Enqueue(index,index);\\n        if(!pos.ContainsKey(index))\\n            pos.Add(index,number);\\n        else \\n            pos[index]=number;\\n    }\\n    \\n    public int Find(int number) {\\n        if(!dict.ContainsKey(number))\\n            return -1;\\n        \\n        var pq=dict[number];\\n        while(pq.Count>0 && pos[pq.Peek()]!=number)\\n            pq.Dequeue();\\n        \\n        if(pq.Count>0)\\n            return pq.Peek();\\n        else \\n            return -1;\\n        \\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.Change(index,number);\\n * int param_2 = obj.Find(number);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NumberContainers {\\n    Dictionary<int,PriorityQueue<int,int>> dict=new Dictionary<int,PriorityQueue<int,int>>();\\n    Dictionary<int,int> pos=new Dictionary<int,int>();\\n    \\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void Change(int index, int number) {\\n        if(!dict.ContainsKey(number))\\n            dict.Add(number,new PriorityQueue<int,int>());\\n        \\n        dict[number].Enqueue(index,index);\\n        if(!pos.ContainsKey(index))\\n            pos.Add(index,number);\\n        else \\n            pos[index]=number;\\n    }\\n    \\n    public int Find(int number) {\\n        if(!dict.ContainsKey(number))\\n            return -1;\\n        \\n        var pq=dict[number];\\n        while(pq.Count>0 && pos[pq.Peek()]!=number)\\n            pq.Dequeue();\\n        \\n        if(pq.Count>0)\\n            return pq.Peek();\\n        else \\n            return -1;\\n        \\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.Change(index,number);\\n * int param_2 = obj.Find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370282,
                "title": "using-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    map<int, set<int>> umap;\\n    unordered_map<int, int> indexes;\\n    NumberContainers() {\\n        umap.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        int a;\\n        if(indexes.find(index)!=indexes.end()){\\n            a = indexes[index];\\n            umap[a].erase(index);\\n        }\\n        indexes[index] = number;\\n        umap[number].insert(index);\\n        \\n\\n    }\\n    \\n    int find(int number) {\\n        int res = -1; // initializing result\\n\\n        // checking if given number exist or not\\n        if(umap.find(number) != umap.end()){\\n\\n            // get the first value/index from given number\\'s set\\n            // we will automatically get the smallest index as it is sorted\\n            res = *(umap[number].begin());\\n\\n            // fact : if set of *number* is empty then\\n            //        begin() of set will return 0 \\n            if(res == 0)\\n                res = -1;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int, set<int>> umap;\\n    unordered_map<int, int> indexes;\\n    NumberContainers() {\\n        umap.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n        int a;\\n        if(indexes.find(index)!=indexes.end()){\\n            a = indexes[index];\\n            umap[a].erase(index);\\n        }\\n        indexes[index] = number;\\n        umap[number].insert(index);\\n        \\n\\n    }\\n    \\n    int find(int number) {\\n        int res = -1; // initializing result\\n\\n        // checking if given number exist or not\\n        if(umap.find(number) != umap.end()){\\n\\n            // get the first value/index from given number\\'s set\\n            // we will automatically get the smallest index as it is sorted\\n            res = *(umap[number].begin());\\n\\n            // fact : if set of *number* is empty then\\n            //        begin() of set will return 0 \\n            if(res == 0)\\n                res = -1;\\n\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339656,
                "title": "c",
                "content": "```\\nclass NumberContainers {\\n    unordered_map<int, int>indexToVal ; //{index, val}\\n    unordered_map<int, set<int>>valToIndex ; //{number, setOfIndex}\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(indexToVal.find(index) == indexToVal.end()){\\n            indexToVal[index] = number ;\\n            valToIndex[number].insert(index) ;\\n        }\\n        else{\\n            int old_num = indexToVal[index] ;\\n            valToIndex[old_num].erase(index) ;\\n            if(valToIndex[old_num].size() == 0)\\n                valToIndex.erase(old_num) ;\\n            indexToVal[index] = number ;\\n            valToIndex[number].insert(index) ;\\n        }\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(valToIndex.find(number) == valToIndex.end())\\n            return -1 ;\\n        return *valToIndex[number].begin() ;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\n    unordered_map<int, int>indexToVal ; //{index, val}\\n    unordered_map<int, set<int>>valToIndex ; //{number, setOfIndex}\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(indexToVal.find(index) == indexToVal.end()){\\n            indexToVal[index] = number ;\\n            valToIndex[number].insert(index) ;\\n        }\\n        else{\\n            int old_num = indexToVal[index] ;\\n            valToIndex[old_num].erase(index) ;\\n            if(valToIndex[old_num].size() == 0)\\n                valToIndex.erase(old_num) ;\\n            indexToVal[index] = number ;\\n            valToIndex[number].insert(index) ;\\n        }\\n        \\n    }\\n    \\n    int find(int number) {\\n        if(valToIndex.find(number) == valToIndex.end())\\n            return -1 ;\\n        return *valToIndex[number].begin() ;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334137,
                "title": "java-two-maps",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\n    private Map<Integer, Queue<Integer>> numberToIndexes;\\n    private Map<Integer, Integer> indexToNumber;\\n\\n    public NumberContainers() {\\n        this.numberToIndexes = new HashMap<>();\\n        this.indexToNumber = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if (indexToNumber.containsKey(index)) {\\n            int previousNumber = indexToNumber.get(index);\\n\\n            if (previousNumber == number)\\n                return;\\n            else\\n                numberToIndexes.get(previousNumber).remove(index);\\n        }\\n\\n        numberToIndexes.putIfAbsent(number, new PriorityQueue<>());\\n        numberToIndexes.get(number).add(index);\\n        indexToNumber.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        int ans = -1;\\n\\n        if (numberToIndexes.containsKey(number)) {\\n            Queue<Integer> que = numberToIndexes.get(number);\\n            ans = que.size() > 0 ? que.peek() : -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    private Map<Integer, Queue<Integer>> numberToIndexes;\\n    private Map<Integer, Integer> indexToNumber;\\n\\n    public NumberContainers() {\\n        this.numberToIndexes = new HashMap<>();\\n        this.indexToNumber = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if (indexToNumber.containsKey(index)) {\\n            int previousNumber = indexToNumber.get(index);\\n\\n            if (previousNumber == number)\\n                return;\\n            else\\n                numberToIndexes.get(previousNumber).remove(index);\\n        }\\n\\n        numberToIndexes.putIfAbsent(number, new PriorityQueue<>());\\n        numberToIndexes.get(number).add(index);\\n        indexToNumber.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        int ans = -1;\\n\\n        if (numberToIndexes.containsKey(number)) {\\n            Queue<Integer> que = numberToIndexes.get(number);\\n            ans = que.size() > 0 ? que.peek() : -1;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325556,
                "title": "java-solution-with-two-map",
                "content": "\\n# Code\\n```\\nclass NumberContainers {\\n    Map<Integer , Integer> map;\\n    Map<Integer , Set<Integer>> idxmap;\\n    public NumberContainers() {\\n        map = new HashMap<>();\\n        idxmap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(map.containsKey(index)){\\n            idxmap.get(map.get(index)).remove(index);\\n        }\\n        map.put(index , number);\\n        if(!idxmap.containsKey(number))\\n            idxmap.put(number , new TreeSet<>());\\n        idxmap.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if(!idxmap.containsKey(number) || idxmap.get(number).isEmpty()){\\n            return -1;\\n        }\\n        return idxmap.get(number).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer , Integer> map;\\n    Map<Integer , Set<Integer>> idxmap;\\n    public NumberContainers() {\\n        map = new HashMap<>();\\n        idxmap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(map.containsKey(index)){\\n            idxmap.get(map.get(index)).remove(index);\\n        }\\n        map.put(index , number);\\n        if(!idxmap.containsKey(number))\\n            idxmap.put(number , new TreeSet<>());\\n        idxmap.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        if(!idxmap.containsKey(number) || idxmap.get(number).isEmpty()){\\n            return -1;\\n        }\\n        return idxmap.get(number).iterator().next();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314476,
                "title": "c-hashmap-set",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    map<int,set<int>> p;\\n    map<int,int> q;\\n\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(q.count(index)>0)\\n         {\\n             int n=q[index];\\n             p[n].erase(index);\\n         }\\n        q[index]=number;\\n        p[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(!p[number].empty())\\n        {\\n            return *p[number].begin();\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int,set<int>> p;\\n    map<int,int> q;\\n\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(q.count(index)>0)\\n         {\\n             int n=q[index];\\n             p[n].erase(index);\\n         }\\n        q[index]=number;\\n        p[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(!p[number].empty())\\n        {\\n            return *p[number].begin();\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311735,
                "title": "547-ms-44-1-mb",
                "content": "```\\ntype PriorityQueueItem struct {\\n\\tcontainerIndex  uint32\\n\\tcontainerNumber uint32\\n\\tqueueIndex      uint32\\n}\\n\\ntype PriorityQueue []*PriorityQueueItem\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].containerIndex < pq[j].containerIndex\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].queueIndex = uint32(i)\\n\\tpq[j].queueIndex = uint32(j)\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := uint32(len(*pq))\\n\\titem := x.(*PriorityQueueItem)\\n\\titem.queueIndex = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\ntype NumberContainers struct {\\n\\tindexToItem   map[uint32]*PriorityQueueItem\\n\\tnumberToQueue map[uint32]*PriorityQueue\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tindexToItem:   make(map[uint32]*PriorityQueueItem),\\n\\t\\tnumberToQueue: make(map[uint32]*PriorityQueue),\\n\\t}\\n}\\n\\nfunc (n *NumberContainers) Change(index int, number int) {\\n\\titem := n.indexToItem[uint32(index)]\\n\\tif item == nil {\\n\\t\\titem = &PriorityQueueItem{\\n\\t\\t\\tcontainerIndex:  uint32(index),\\n\\t\\t\\tcontainerNumber: uint32(number),\\n\\t\\t}\\n\\t\\tn.indexToItem[uint32(index)] = item\\n\\t} else if item.containerNumber == uint32(number) {\\n\\t\\treturn\\n\\t} else {\\n\\t\\theap.Remove(n.numberToQueue[item.containerNumber], int(item.queueIndex))\\n\\t\\titem.containerNumber = uint32(number)\\n\\t}\\n\\tqueue := n.numberToQueue[item.containerNumber]\\n\\tif queue == nil {\\n\\t\\tqueue = new(PriorityQueue)\\n\\t\\tn.numberToQueue[item.containerNumber] = queue\\n\\t}\\n\\theap.Push(queue, item)\\n}\\n\\nfunc (n *NumberContainers) Find(number int) int {\\n\\tqueue := n.numberToQueue[uint32(number)]\\n\\tif queue == nil || queue.Len() == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int((*queue)[0].containerIndex)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype PriorityQueueItem struct {\\n\\tcontainerIndex  uint32\\n\\tcontainerNumber uint32\\n\\tqueueIndex      uint32\\n}\\n\\ntype PriorityQueue []*PriorityQueueItem\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].containerIndex < pq[j].containerIndex\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].queueIndex = uint32(i)\\n\\tpq[j].queueIndex = uint32(j)\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := uint32(len(*pq))\\n\\titem := x.(*PriorityQueueItem)\\n\\titem.queueIndex = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\ntype NumberContainers struct {\\n\\tindexToItem   map[uint32]*PriorityQueueItem\\n\\tnumberToQueue map[uint32]*PriorityQueue\\n}\\n\\nfunc Constructor() NumberContainers {\\n\\treturn NumberContainers{\\n\\t\\tindexToItem:   make(map[uint32]*PriorityQueueItem),\\n\\t\\tnumberToQueue: make(map[uint32]*PriorityQueue),\\n\\t}\\n}\\n\\nfunc (n *NumberContainers) Change(index int, number int) {\\n\\titem := n.indexToItem[uint32(index)]\\n\\tif item == nil {\\n\\t\\titem = &PriorityQueueItem{\\n\\t\\t\\tcontainerIndex:  uint32(index),\\n\\t\\t\\tcontainerNumber: uint32(number),\\n\\t\\t}\\n\\t\\tn.indexToItem[uint32(index)] = item\\n\\t} else if item.containerNumber == uint32(number) {\\n\\t\\treturn\\n\\t} else {\\n\\t\\theap.Remove(n.numberToQueue[item.containerNumber], int(item.queueIndex))\\n\\t\\titem.containerNumber = uint32(number)\\n\\t}\\n\\tqueue := n.numberToQueue[item.containerNumber]\\n\\tif queue == nil {\\n\\t\\tqueue = new(PriorityQueue)\\n\\t\\tn.numberToQueue[item.containerNumber] = queue\\n\\t}\\n\\theap.Push(queue, item)\\n}\\n\\nfunc (n *NumberContainers) Find(number int) int {\\n\\tqueue := n.numberToQueue[uint32(number)]\\n\\tif queue == nil || queue.Len() == 0 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn int((*queue)[0].containerIndex)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3310909,
                "title": "solution-with-dictionary-and-heap",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee the code snippet below\\n---\\n---\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ (in the worst case), $$O(n)$$ (usually), where $$n$$ is a total number of calls\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is a total number of calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```python []\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.container = {}\\n        self.pqs = defaultdict(list)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.container:\\n            num = self.container[index]\\n            if len(self.pqs[num]) == 1:\\n                self.pqs.pop(num)\\n        \\n        self.container[index] = number\\n        heappush(self.pqs[number], index)\\n\\n    def find(self, number: int) -> int:\\n        if number not in self.pqs: return -1\\n        index = heappop(self.pqs[number])\\n        while self.container[index] != number and self.pqs[number]:\\n            index = heappop(self.pqs[number])\\n\\n        if self.container[index] != number: \\n            self.pqs.pop(number)\\n            return -1\\n        heappush(self.pqs[number], index)\\n        return index\\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```\\n```\\nIf you like this solution, upvote, please !\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```python []\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.container = {}\\n        self.pqs = defaultdict(list)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if index in self.container:\\n            num = self.container[index]\\n            if len(self.pqs[num]) == 1:\\n                self.pqs.pop(num)\\n        \\n        self.container[index] = number\\n        heappush(self.pqs[number], index)\\n\\n    def find(self, number: int) -> int:\\n        if number not in self.pqs: return -1\\n        index = heappop(self.pqs[number])\\n        while self.container[index] != number and self.pqs[number]:\\n            index = heappop(self.pqs[number])\\n\\n        if self.container[index] != number: \\n            self.pqs.pop(number)\\n            return -1\\n        heappush(self.pqs[number], index)\\n        return index\\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```\n```\\nIf you like this solution, upvote, please !\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299074,
                "title": "java-tc-86-sc-99-two-maps-solution",
                "content": "# Code\\n```\\nclass NumberContainers {\\n    Map<Integer, Integer> mapIdxNum;\\n    Map<Integer, Set<Integer>> mapNumListIdx;\\n\\n    public NumberContainers() {\\n        mapIdxNum = new HashMap<>();\\n        mapNumListIdx = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        mapIdxNum.put(index, number);\\n        if (mapNumListIdx.containsKey(number)) {\\n            mapNumListIdx.get(number).add(index);\\n        } else {\\n            Set<Integer> set = new TreeSet<>();\\n            set.add(index);\\n            mapNumListIdx.put(number, set);\\n        }\\n    }\\n\\n    public int find(int number) {\\n        if (mapNumListIdx.containsKey(number)) {\\n            Set<Integer> indices = mapNumListIdx.get(number);\\n            for (int idx : indices) \\n                if (mapIdxNum.get(idx) == number) return idx;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer, Integer> mapIdxNum;\\n    Map<Integer, Set<Integer>> mapNumListIdx;\\n\\n    public NumberContainers() {\\n        mapIdxNum = new HashMap<>();\\n        mapNumListIdx = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        mapIdxNum.put(index, number);\\n        if (mapNumListIdx.containsKey(number)) {\\n            mapNumListIdx.get(number).add(index);\\n        } else {\\n            Set<Integer> set = new TreeSet<>();\\n            set.add(index);\\n            mapNumListIdx.put(number, set);\\n        }\\n    }\\n\\n    public int find(int number) {\\n        if (mapNumListIdx.containsKey(number)) {\\n            Set<Integer> indices = mapNumListIdx.get(number);\\n            for (int idx : indices) \\n                if (mapIdxNum.get(idx) == number) return idx;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268641,
                "title": "intutive-accepted-beginner-friendly-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\nmap<int, int> mp; // indx->val\\nmap<int,set<int>> pm; //val-> indx\\n    NumberContainers() \\n    {\\n\\n    }\\n    \\n    void change(int index, int number)\\n    {\\n          if(mp.find(index)!=mp.end())\\n          {\\n              pm[mp[index]].erase(index);\\n              \\n          }\\n          mp[index]=number;\\n          pm[number].insert(index);\\n    }\\n    \\n    int find(int number)\\n    {\\n       if(pm.find(number)!=pm.end())\\n       {\\n           int x= *pm[number].begin();\\n           if(x>0) return x;\\n           else\\n            return -1;\\n       }\\n       else\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\nmap<int, int> mp; // indx->val\\nmap<int,set<int>> pm; //val-> indx\\n    NumberContainers() \\n    {\\n\\n    }\\n    \\n    void change(int index, int number)\\n    {\\n          if(mp.find(index)!=mp.end())\\n          {\\n              pm[mp[index]].erase(index);\\n              \\n          }\\n          mp[index]=number;\\n          pm[number].insert(index);\\n    }\\n    \\n    int find(int number)\\n    {\\n       if(pm.find(number)!=pm.end())\\n       {\\n           int x= *pm[number].begin();\\n           if(x>0) return x;\\n           else\\n            return -1;\\n       }\\n       else\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254327,
                "title": "treeset-treemap-java-solution",
                "content": "# Code\\n```\\nclass NumberContainers {\\n    TreeMap<Integer,TreeSet<Integer>>map;\\n    HashMap<Integer,Integer>idx=new HashMap<>();\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(!map.containsKey(number)){\\n            map.put(number,new TreeSet<Integer>());\\n        }\\n       if(idx.containsKey(index)){\\n           int x=idx.get(index);\\n           map.get(x).remove(index);\\n       }\\n       map.get(number).add(index);\\n        idx.put(index,number);\\n    }\\n    public int find(int number) {\\n       if(map.containsKey(number)){\\n          if(map.get(number).size()>0) return map.get(number).first();\\n       }\\n       return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    TreeMap<Integer,TreeSet<Integer>>map;\\n    HashMap<Integer,Integer>idx=new HashMap<>();\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(!map.containsKey(number)){\\n            map.put(number,new TreeSet<Integer>());\\n        }\\n       if(idx.containsKey(index)){\\n           int x=idx.get(index);\\n           map.get(x).remove(index);\\n       }\\n       map.get(number).add(index);\\n        idx.put(index,number);\\n    }\\n    public int find(int number) {\\n       if(map.containsKey(number)){\\n          if(map.get(number).size()>0) return map.get(number).first();\\n       }\\n       return -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227814,
                "title": "simple-c-solution-unordered-map-set",
                "content": "# Code\\n```cpp\\nclass NumberContainers {\\n    unordered_map<int, int> map;\\n    unordered_map<int, set<int>>pam;\\npublic:\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        if(map.find(index) != map.end()) {\\n            pam[map[index]].erase(index);\\n        }\\n        map[index] = number;\\n        pam[map[index]].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(pam[number].empty()) {\\n            return -1;\\n        }\\n        auto it = pam[number].begin();\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass NumberContainers {\\n    unordered_map<int, int> map;\\n    unordered_map<int, set<int>>pam;\\npublic:\\n    NumberContainers() {\\n    }\\n    \\n    void change(int index, int number) {\\n        if(map.find(index) != map.end()) {\\n            pam[map[index]].erase(index);\\n        }\\n        map[index] = number;\\n        pam[map[index]].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(pam[number].empty()) {\\n            return -1;\\n        }\\n        auto it = pam[number].begin();\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204226,
                "title": "using-priority-queue-and-map",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\n    map<int, priority_queue<int, vector<int>, greater<int>>> mpq;\\n    map<int, int> mp;\\npublic:    \\n    NumberContainers() {\\n\\n    }\\n     \\n    void change(int index, int number) {\\n        mpq[number].push(index);\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        while(!mpq[number].empty()) {\\n            if(mp[mpq[number].top()] == number) return mpq[number].top();\\n            else mpq[number].pop();\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\n    map<int, priority_queue<int, vector<int>, greater<int>>> mpq;\\n    map<int, int> mp;\\npublic:    \\n    NumberContainers() {\\n\\n    }\\n     \\n    void change(int index, int number) {\\n        mpq[number].push(index);\\n        mp[index] = number;\\n    }\\n    \\n    int find(int number) {\\n        while(!mpq[number].empty()) {\\n            if(mp[mpq[number].top()] == number) return mpq[number].top();\\n            else mpq[number].pop();\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194964,
                "title": "c-unordered-map",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    NumberContainers() {      \\n    }\\n    \\n    void change(int index, int number) {\\n        auto old = vals[index];\\n        vals[index] = number;\\n        m[old].erase(index);\\n        if(m[old].empty()) m.erase(old);\\n        m[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        auto it = m.find(number);\\n        return it == m.end() ? -1 : *it->second.begin();\\n    }\\n\\nprivate:\\n    unordered_map<int, set<int>> m; //num, set<index>\\n    unordered_map<int,int> vals; //index, num\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    NumberContainers() {      \\n    }\\n    \\n    void change(int index, int number) {\\n        auto old = vals[index];\\n        vals[index] = number;\\n        m[old].erase(index);\\n        if(m[old].empty()) m.erase(old);\\n        m[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        auto it = m.find(number);\\n        return it == m.end() ? -1 : *it->second.begin();\\n    }\\n\\nprivate:\\n    unordered_map<int, set<int>> m; //num, set<index>\\n    unordered_map<int,int> vals; //index, num\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143394,
                "title": "java-simple-hashmap-and-sortedset-interface-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass NumberContainers {\\n    private Map <Integer, SortedSet <Integer>> numbersMap;\\n    private Map <Integer, Integer> indexMap;\\n    \\n    public NumberContainers() {\\n        numbersMap = new HashMap <> ();\\n        indexMap = new HashMap <> ();    \\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = indexMap.get(index);\\n        if (oldNumber != null) {\\n            numbersMap.get(oldNumber).remove(index);\\n            if (numbersMap.get(oldNumber).size() == 0)\\n                numbersMap.remove(oldNumber);\\n        }\\n        numbersMap.putIfAbsent(number, new TreeSet <> ());\\n        numbersMap.get(number).add(index);\\n        indexMap.put (index, number);\\n    }\\n    \\n    public int find(int number) {\\n        if (!numbersMap.containsKey(number))\\n            return -1;\\n        return numbersMap.get(number).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    private Map <Integer, SortedSet <Integer>> numbersMap;\\n    private Map <Integer, Integer> indexMap;\\n    \\n    public NumberContainers() {\\n        numbersMap = new HashMap <> ();\\n        indexMap = new HashMap <> ();    \\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = indexMap.get(index);\\n        if (oldNumber != null) {\\n            numbersMap.get(oldNumber).remove(index);\\n            if (numbersMap.get(oldNumber).size() == 0)\\n                numbersMap.remove(oldNumber);\\n        }\\n        numbersMap.putIfAbsent(number, new TreeSet <> ());\\n        numbersMap.get(number).add(index);\\n        indexMap.put (index, number);\\n    }\\n    \\n    public int find(int number) {\\n        if (!numbersMap.containsKey(number))\\n            return -1;\\n        return numbersMap.get(number).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062383,
                "title": "java-priorityqueue-clean-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Keep index to value map.\\n2. Keep value to indexes map.\\n3. Use Priority queue to get minimum index first in case of value to indexes map.\\n4. change method will not invalidate old index to value in  second hashmap (value to indexes).\\n5. find method will check if minimum index is outdated or not. If no then remove the index.\\n\\n\\n\\n\\n# Code\\n```\\nclass NumberContainers {\\n\\n    private HashMap<Integer, Integer> indexValueHolder;\\n    private HashMap<Integer, PriorityQueue<Integer> > valueIndexesHolder;\\n\\n    public NumberContainers() {\\n        this.indexValueHolder = new HashMap<>();\\n        this.valueIndexesHolder = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        indexValueHolder.put(index, number);\\n        PriorityQueue<Integer> numPQ = valueIndexesHolder.getOrDefault(number, new PriorityQueue<>());\\n        numPQ.add(index);\\n        valueIndexesHolder.put(number, numPQ);\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> numPQ = valueIndexesHolder.getOrDefault(number, new PriorityQueue<>());\\n        while (!numPQ.isEmpty() && indexValueHolder.get(numPQ.peek()) != number) {\\n            numPQ.poll();\\n        }\\n        return numPQ.isEmpty() ? -1 : numPQ.peek();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    private HashMap<Integer, Integer> indexValueHolder;\\n    private HashMap<Integer, PriorityQueue<Integer> > valueIndexesHolder;\\n\\n    public NumberContainers() {\\n        this.indexValueHolder = new HashMap<>();\\n        this.valueIndexesHolder = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        indexValueHolder.put(index, number);\\n        PriorityQueue<Integer> numPQ = valueIndexesHolder.getOrDefault(number, new PriorityQueue<>());\\n        numPQ.add(index);\\n        valueIndexesHolder.put(number, numPQ);\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> numPQ = valueIndexesHolder.getOrDefault(number, new PriorityQueue<>());\\n        while (!numPQ.isEmpty() && indexValueHolder.get(numPQ.peek()) != number) {\\n            numPQ.poll();\\n        }\\n        return numPQ.isEmpty() ? -1 : numPQ.peek();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059456,
                "title": "python3-sortedlist",
                "content": "\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.dic=defaultdict(int)\\n        self.dic2=defaultdict(SortedList)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.dic:\\n            self.dic2[self.dic[index]].discard(index)\\n\\n        self.dic[index]=number\\n        self.dic2[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        if number in self.dic2 and self.dic2[number]!=[]:\\n            return (self.dic2[number][0])\\n\\n        return -1\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.dic=defaultdict(int)\\n        self.dic2=defaultdict(SortedList)\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.dic:\\n            self.dic2[self.dic[index]].discard(index)\\n\\n        self.dic[index]=number\\n        self.dic2[number].add(index)\\n\\n    def find(self, number: int) -> int:\\n        if number in self.dic2 and self.dic2[number]!=[]:\\n            return (self.dic2[number][0])\\n\\n        return -1\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997945,
                "title": "simple-java-solution-map-and-treeset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass NumberContainers {\\n\\n    Map<Integer, TreeSet<Integer>> mapSet;\\n     Map<Integer, Integer> map;\\n    public NumberContainers() {\\n        this.mapSet = new HashMap<>();\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = map.get(index);\\n        if(oldNumber !=null){\\n             mapSet.get(oldNumber).remove(index);\\n        }\\n        map.put(index, number);\\n        mapSet.putIfAbsent(number, new TreeSet<>());\\n        mapSet.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n       TreeSet<Integer> set =  mapSet.get(number);\\n        if(set!=null && set.size()>0){\\n           return mapSet.get(number).first(); \\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    Map<Integer, TreeSet<Integer>> mapSet;\\n     Map<Integer, Integer> map;\\n    public NumberContainers() {\\n        this.mapSet = new HashMap<>();\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer oldNumber = map.get(index);\\n        if(oldNumber !=null){\\n             mapSet.get(oldNumber).remove(index);\\n        }\\n        map.put(index, number);\\n        mapSet.putIfAbsent(number, new TreeSet<>());\\n        mapSet.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n       TreeSet<Integer> set =  mapSet.get(number);\\n        if(set!=null && set.size()>0){\\n           return mapSet.get(number).first(); \\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980213,
                "title": "java-hashmap-treeset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\n    Map<Integer, Integer> indexVal;\\n    Map<Integer, TreeSet<Integer>> valIndexes;\\n    public NumberContainers() {\\n        indexVal = new HashMap<>();\\n        valIndexes = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(indexVal.containsKey(index)){\\n            int prevVal = indexVal.get(index);\\n            if(valIndexes.containsKey(prevVal)) {\\n                valIndexes.get(prevVal).remove(index);\\n                if(valIndexes.get(prevVal).isEmpty()) valIndexes.remove(prevVal);\\n            }\\n        }\\n        indexVal.put(index, number);\\n        valIndexes.putIfAbsent(number, new TreeSet<>());\\n        valIndexes.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        return (valIndexes.containsKey(number))\\n        ? valIndexes.get(number).first()\\n        : -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer, Integer> indexVal;\\n    Map<Integer, TreeSet<Integer>> valIndexes;\\n    public NumberContainers() {\\n        indexVal = new HashMap<>();\\n        valIndexes = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(indexVal.containsKey(index)){\\n            int prevVal = indexVal.get(index);\\n            if(valIndexes.containsKey(prevVal)) {\\n                valIndexes.get(prevVal).remove(index);\\n                if(valIndexes.get(prevVal).isEmpty()) valIndexes.remove(prevVal);\\n            }\\n        }\\n        indexVal.put(index, number);\\n        valIndexes.putIfAbsent(number, new TreeSet<>());\\n        valIndexes.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        return (valIndexes.containsKey(number))\\n        ? valIndexes.get(number).first()\\n        : -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973171,
                "title": "ok",
                "content": "**space: `O(N)`**\\nboth operations: **time: `O(N)`**\\n```\\nclass NumberContainers \\n{\\n    unordered_map<int, int> m;\\n    unordered_map<int, set<int>> i;\\npublic:\\n    NumberContainers() \\n    {    \\n    }\\n    \\n    void change(int ind, int n) \\n    {\\n        i[m[ind]].erase(ind);\\n        m[ind] = n;\\n        i[n].insert(ind);\\n    }\\n    \\n    int find(int n) \\n    {\\n        return empty(i[n]) ? -1 : *i[n].begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumberContainers \\n{\\n    unordered_map<int, int> m;\\n    unordered_map<int, set<int>> i;\\npublic:\\n    NumberContainers() \\n    {    \\n    }\\n    \\n    void change(int ind, int n) \\n    {\\n        i[m[ind]].erase(ind);\\n        m[ind] = n;\\n        i[n].insert(ind);\\n    }\\n    \\n    int find(int n) \\n    {\\n        return empty(i[n]) ? -1 : *i[n].begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965003,
                "title": "ruby-398-ms-using-crbtreemap",
                "content": "```ruby\\nclass NumberContainers\\n\\n    def initialize = (@c, @t = {}, {})\\n\\n    def change i, n\\n        p = @c[i]\\n        if p != n\\n            @t[p].delete i if p\\n            @c[i] = n\\n            @t[n] ||= CRBTreeMap.new\\n            @t[n][i] = true\\n        end\\n    end\\n\\n    def find(n) = @t[n]&.min_key || -1\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass NumberContainers\\n\\n    def initialize = (@c, @t = {}, {})\\n\\n    def change i, n\\n        p = @c[i]\\n        if p != n\\n            @t[p].delete i if p\\n            @c[i] = n\\n            @t[n] ||= CRBTreeMap.new\\n            @t[n][i] = true\\n        end\\n    end\\n\\n    def find(n) = @t[n]&.min_key || -1\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964585,
                "title": "c-2-maps-ordinary-map-map-of-set",
                "content": "# Code\\n```\\nclass NumberContainers {\\n    unordered_map<int, int> indexToNum;\\n    unordered_map<int, set<int>> numToIndexes;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        numToIndexes[indexToNum[index]].erase(index);\\n        indexToNum[index] = number; \\n        numToIndexes[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(numToIndexes[number].size())\\n            return *numToIndexes[number].begin();\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    unordered_map<int, int> indexToNum;\\n    unordered_map<int, set<int>> numToIndexes;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        numToIndexes[indexToNum[index]].erase(index);\\n        indexToNum[index] = number; \\n        numToIndexes[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(numToIndexes[number].size())\\n            return *numToIndexes[number].begin();\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946313,
                "title": "kotlin-hashmap-treeset",
                "content": "```\\nclass NumberContainers() {\\n\\n    // index | number\\n    private val containers = hashMapOf<Int, Int>()\\n\\n    // numb | indexes\\n    private val numbToIndexes = hashMapOf<Int, TreeSet<Int>>()\\n    \\n    fun change(index: Int, number: Int) {\\n        val prevNumber = containers[index]\\n\\n        if (prevNumber != null) {\\n            numbToIndexes[prevNumber]?.remove(index)\\n        }\\n        containers[index] = number\\n        \\n        val indexesTree = numbToIndexes.getOrDefault(number, TreeSet())\\n        indexesTree.add(index)\\n        numbToIndexes[number] = indexesTree\\n    }\\n\\n    fun find(number: Int): Int {\\n        val indexes = numbToIndexes[number] ?: return -1\\n        return if (indexes.isEmpty()) {\\n            return -1\\n        } else {\\n            indexes.first()\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\nclass NumberContainers() {\\n\\n    // index | number\\n    private val containers = hashMapOf<Int, Int>()\\n\\n    // numb | indexes\\n    private val numbToIndexes = hashMapOf<Int, TreeSet<Int>>()\\n    \\n    fun change(index: Int, number: Int) {\\n        val prevNumber = containers[index]\\n\\n        if (prevNumber != null) {\\n            numbToIndexes[prevNumber]?.remove(index)\\n        }\\n        containers[index] = number\\n        \\n        val indexesTree = numbToIndexes.getOrDefault(number, TreeSet())\\n        indexesTree.add(index)\\n        numbToIndexes[number] = indexesTree\\n    }\\n\\n    fun find(number: Int): Int {\\n        val indexes = numbToIndexes[number] ?: return -1\\n        return if (indexes.isEmpty()) {\\n            return -1\\n        } else {\\n            indexes.first()\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2937671,
                "title": "hashmap-orderedset",
                "content": "\\n\\n# Code\\n```\\nclass NumberContainers {\\n    map<int,int>m;\\n    map<int,set<int>>ms;\\npublic:\\n    void change(int index, int number) {\\n        if(m.find(index) == m.end()){\\n            ms[number].insert(index);\\n            m[index] = number;\\n        }\\n        else{\\n            int val = m[index];\\n            m[index] = number;\\n            auto it = ms[val].find(index);\\n            if( it != ms[val].end()){\\n                ms[val].erase(it);\\n                if(ms[val].size()==0){\\n                    ms.erase(val);\\n                }\\n            }\\n            ms[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(ms.find(number)== ms.end()) return -1;\\n        return *ms[number].begin();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\n    map<int,int>m;\\n    map<int,set<int>>ms;\\npublic:\\n    void change(int index, int number) {\\n        if(m.find(index) == m.end()){\\n            ms[number].insert(index);\\n            m[index] = number;\\n        }\\n        else{\\n            int val = m[index];\\n            m[index] = number;\\n            auto it = ms[val].find(index);\\n            if( it != ms[val].end()){\\n                ms[val].erase(it);\\n                if(ms[val].size()==0){\\n                    ms.erase(val);\\n                }\\n            }\\n            ms[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(ms.find(number)== ms.end()) return -1;\\n        return *ms[number].begin();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925803,
                "title": "java-simple-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse 2 HashMaps.\\nOne for storing all the indices for one number.\\nAnother for storing what value one index stores.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHashMap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$ for change\\n$$O(1)$$ for find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass NumberContainers {\\n    Map<Integer, TreeSet<Integer>> map;\\n    Map<Integer, Integer> indVal;\\n    public NumberContainers() {\\n        map = new HashMap<>();\\n        indVal = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        map.putIfAbsent(number, new TreeSet<Integer>());\\n        if(indVal.containsKey(index)) {\\n            int val = indVal.get(index);\\n            map.get(val).remove(index);\\n        }\\n        map.get(number).add(index);\\n        indVal.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        return map.get(number) != null && !map.get(number).isEmpty() ? map.get(number).first():-1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer, TreeSet<Integer>> map;\\n    Map<Integer, Integer> indVal;\\n    public NumberContainers() {\\n        map = new HashMap<>();\\n        indVal = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        map.putIfAbsent(number, new TreeSet<Integer>());\\n        if(indVal.containsKey(index)) {\\n            int val = indVal.get(index);\\n            map.get(val).remove(index);\\n        }\\n        map.get(number).add(index);\\n        indVal.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        return map.get(number) != null && !map.get(number).isEmpty() ? map.get(number).first():-1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915869,
                "title": "c-quick-find-using-lookup-tables-in-both-directions",
                "content": "# Complexity\\n- Time complexity lookup: $$O(1)$$\\n- Time complexity change (worst case, duplicate numbers): $$O(n*log(n))$$\\n- Time complexity change (best case, unique numbers): $$O(1)$$\\n- Space complexity: $$O(n)$$\\n\\nBy using an unordered_set instead, insert complexity can be changed to $$O(1)$$ in the worst case. This would give a worst case find complexity of $$O(n)$$ instead since every element in the set would need to be traversed.\\n\\n# Code\\n```\\nclass NumberContainers {\\npublic:    \\n    void change(const int index, const int number) {\\n        if (indexToNum.count(index)) {\\n            numToIndex[indexToNum[index]].erase(index);\\n        }\\n        indexToNum[index] = number;\\n        numToIndex[number].insert(index);\\n    }\\n    \\n    int find(const int number) {\\n        if (numToIndex[number].empty()) {\\n            return -1;\\n        }\\n        return *numToIndex[number].begin();\\n    }\\n\\nprivate:\\n    unordered_map<int, set<int>> numToIndex;\\n    unordered_map<int, int> indexToNum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:    \\n    void change(const int index, const int number) {\\n        if (indexToNum.count(index)) {\\n            numToIndex[indexToNum[index]].erase(index);\\n        }\\n        indexToNum[index] = number;\\n        numToIndex[number].insert(index);\\n    }\\n    \\n    int find(const int number) {\\n        if (numToIndex[number].empty()) {\\n            return -1;\\n        }\\n        return *numToIndex[number].begin();\\n    }\\n\\nprivate:\\n    unordered_map<int, set<int>> numToIndex;\\n    unordered_map<int, int> indexToNum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878765,
                "title": "java-2-hashmap-treeset-faster-easily-understandable",
                "content": "# Complexity\\n- Time complexity: $$ O(n*logm)$$ Worst case (n = number of calls, m = number of indexes it can store).\\n\\n- Space complexity: $$O(2*n)$$\\n\\n# Code\\n```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> valueMap;\\n    HashMap<Integer, TreeSet<Integer>> indexMap;\\n\\n    public NumberContainers() {\\n\\n        valueMap = new HashMap<>();\\n        indexMap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        \\n        if(valueMap.containsKey(index)){\\n            int value = valueMap.get(index);\\n            TreeSet<Integer> ts = indexMap.get(value);\\n            ts.remove(index);\\n            \\n            if(ts.size() == 0)\\n                indexMap.remove(value);\\n        }\\n\\n        valueMap.put(index, number);\\n        if(!indexMap.containsKey(number))\\n            indexMap.put(number, new TreeSet<>());\\n        \\n        indexMap.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        \\n        if(!indexMap.containsKey(number))\\n            return -1;\\n\\n        TreeSet<Integer> mp = indexMap.get(number);\\n        return mp.first();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> valueMap;\\n    HashMap<Integer, TreeSet<Integer>> indexMap;\\n\\n    public NumberContainers() {\\n\\n        valueMap = new HashMap<>();\\n        indexMap = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        \\n        if(valueMap.containsKey(index)){\\n            int value = valueMap.get(index);\\n            TreeSet<Integer> ts = indexMap.get(value);\\n            ts.remove(index);\\n            \\n            if(ts.size() == 0)\\n                indexMap.remove(value);\\n        }\\n\\n        valueMap.put(index, number);\\n        if(!indexMap.containsKey(number))\\n            indexMap.put(number, new TreeSet<>());\\n        \\n        indexMap.get(number).add(index);\\n    }\\n    \\n    public int find(int number) {\\n        \\n        if(!indexMap.containsKey(number))\\n            return -1;\\n\\n        TreeSet<Integer> mp = indexMap.get(number);\\n        return mp.first();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2878617,
                "title": "c-easy-solution-95-beat",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp1;\\n    map<pair<int,int>,int>mp2;\\n    unordered_map<int,int>mp3;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp1.find(index)!=mp1.end())\\n        {\\n            map<pair<int,int>,int>::iterator itr;\\n            itr = mp2.find({mp1[index],index});\\n            int uu = mp1[index];\\n            itr++;\\n            int rr = -1;\\n            int gg = -1;\\n            if(itr!=mp2.end())\\n            {\\n                rr = itr->first.first;\\n                gg = itr->first.second;\\n            }\\n            mp2.erase({mp1[index],index});\\n            if(mp3[uu]==index)\\n            {\\n                if(rr==uu)\\n                {\\n                    mp3[uu]=gg;\\n                }\\n                else\\n                {\\n                    mp3.erase(uu);\\n                }\\n            }\\n        }\\n        mp1[index]=number;\\n        mp2[{number,index}]++;\\n        if(mp3.find(number)!=mp3.end())\\n        {\\n            mp3[number]=min(index,mp3[number]);\\n        }\\n        else\\n        {\\n            mp3[number]=index;\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp3.find(number)!=mp3.end())\\n        {\\n            return mp3[number];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp1;\\n    map<pair<int,int>,int>mp2;\\n    unordered_map<int,int>mp3;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp1.find(index)!=mp1.end())\\n        {\\n            map<pair<int,int>,int>::iterator itr;\\n            itr = mp2.find({mp1[index],index});\\n            int uu = mp1[index];\\n            itr++;\\n            int rr = -1;\\n            int gg = -1;\\n            if(itr!=mp2.end())\\n            {\\n                rr = itr->first.first;\\n                gg = itr->first.second;\\n            }\\n            mp2.erase({mp1[index],index});\\n            if(mp3[uu]==index)\\n            {\\n                if(rr==uu)\\n                {\\n                    mp3[uu]=gg;\\n                }\\n                else\\n                {\\n                    mp3.erase(uu);\\n                }\\n            }\\n        }\\n        mp1[index]=number;\\n        mp2[{number,index}]++;\\n        if(mp3.find(number)!=mp3.end())\\n        {\\n            mp3[number]=min(index,mp3[number]);\\n        }\\n        else\\n        {\\n            mp3[number]=index;\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp3.find(number)!=mp3.end())\\n        {\\n            return mp3[number];\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856813,
                "title": "java-treeset-as-ordered-set-for-number-index-cross-reference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use a HashMap as sparsely populated list of indexed number containers.\\n- Use kind of an ordered set as storage for the number to index cross reference, to allow quick finding of numbers in containers with lowest index. I choose TreeMap.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$ for the change method, because the TreeMap keeps its key set always ordered. $$O(1)$$ for the find method.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ with n := numbers+indexes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\n\\n    private final HashMap<Integer, TreeSet<Integer>> indexes;\\n    private final HashMap<Integer, Integer> containers;\\n\\n    public NumberContainers() {\\n        indexes = new HashMap<>();\\n        containers = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        var oldNumber = containers.get(index);\\n        if (oldNumber != null && oldNumber != number) indexes.get(oldNumber).remove(index);\\n        TreeSet<Integer> entry = indexes.computeIfAbsent(number, k -> new TreeSet<>());\\n        entry.add(index);\\n        containers.put(index, number);\\n    }\\n\\n    public int find(int number) {\\n        var entry = indexes.get(number);\\n        if (entry == null || entry.isEmpty()) return -1;\\n        return entry.first();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    private final HashMap<Integer, TreeSet<Integer>> indexes;\\n    private final HashMap<Integer, Integer> containers;\\n\\n    public NumberContainers() {\\n        indexes = new HashMap<>();\\n        containers = new HashMap<>();\\n    }\\n\\n    public void change(int index, int number) {\\n        var oldNumber = containers.get(index);\\n        if (oldNumber != null && oldNumber != number) indexes.get(oldNumber).remove(index);\\n        TreeSet<Integer> entry = indexes.computeIfAbsent(number, k -> new TreeSet<>());\\n        entry.add(index);\\n        containers.put(index, number);\\n    }\\n\\n    public int find(int number) {\\n        var entry = indexes.get(number);\\n        if (entry == null || entry.isEmpty()) return -1;\\n        return entry.first();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846839,
                "title": "java-solution-using-treeset",
                "content": "```\\nclass NumberContainers {\\n    private HashMap<Integer, Integer> indxToNumber = new HashMap<>();\\n    private HashMap<Integer, TreeSet<Integer>> numberToIndx = new HashMap<>();\\n\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        if (indxToNumber.containsKey(index)) {\\n            int oldNum = indxToNumber.get(index);\\n            TreeSet<Integer> set = numberToIndx.get(oldNum);\\n            set.remove(index);\\n            if (set.size() == 0) {\\n               numberToIndx.remove(oldNum);\\n            } else {\\n                numberToIndx.put(oldNum, set);\\n            }\\n        }\\n        indxToNumber.put(index, number);\\n        TreeSet<Integer> set = numberToIndx.getOrDefault(number, new TreeSet<Integer>());\\n        set.add(index);\\n        numberToIndx.put(number, set);\\n    }\\n    \\n    public int find(int number) {\\n        return !numberToIndx.containsKey(number)? -1: numberToIndx.get(number).first();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\n    private HashMap<Integer, Integer> indxToNumber = new HashMap<>();\\n    private HashMap<Integer, TreeSet<Integer>> numberToIndx = new HashMap<>();\\n\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        if (indxToNumber.containsKey(index)) {\\n            int oldNum = indxToNumber.get(index);\\n            TreeSet<Integer> set = numberToIndx.get(oldNum);\\n            set.remove(index);\\n            if (set.size() == 0) {\\n               numberToIndx.remove(oldNum);\\n            } else {\\n                numberToIndx.put(oldNum, set);\\n            }\\n        }\\n        indxToNumber.put(index, number);\\n        TreeSet<Integer> set = numberToIndx.getOrDefault(number, new TreeSet<Integer>());\\n        set.add(index);\\n        numberToIndx.put(number, set);\\n    }\\n    \\n    public int find(int number) {\\n        return !numberToIndx.containsKey(number)? -1: numberToIndx.get(number).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845129,
                "title": "cpp-very-easy-to-understand-design",
                "content": "# Code\\n```\\nclass NumberContainers \\n{\\npublic:\\n    unordered_map<int,set<int>>mp;  //val vs all index\\n    unordered_map<int,int>mp_;   //index vs value mapping \\n    NumberContainers() \\n    {\\n    \\n    }\\n    void change(int index, int val) \\n    {\\n        if(mp_[index] != val)\\n        {\\n            int ele = mp_[index];\\n            mp[ele].erase(index);\\n        }\\n        //this value is present on all these indexes\\n        mp[val].insert(index);\\n        mp_[index] = val;\\n    }\\n        \\n    int find(int val) \\n    {\\n        if(mp.find(val) == mp.end())\\n        return -1;\\n        \\n        if(mp[val].size() == 0)\\n        return -1;\\n        \\n        return *(mp[val].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers \\n{\\npublic:\\n    unordered_map<int,set<int>>mp;  //val vs all index\\n    unordered_map<int,int>mp_;   //index vs value mapping \\n    NumberContainers() \\n    {\\n    \\n    }\\n    void change(int index, int val) \\n    {\\n        if(mp_[index] != val)\\n        {\\n            int ele = mp_[index];\\n            mp[ele].erase(index);\\n        }\\n        //this value is present on all these indexes\\n        mp[val].insert(index);\\n        mp_[index] = val;\\n    }\\n        \\n    int find(int val) \\n    {\\n        if(mp.find(val) == mp.end())\\n        return -1;\\n        \\n        if(mp[val].size() == 0)\\n        return -1;\\n        \\n        return *(mp[val].begin());\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836670,
                "title": "c-ordered-set",
                "content": "\\n# Code\\n```\\nclass NumberContainers {\\npublic:\\n    map<int , set<int>>mp;\\n    map<int , int >marked;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(marked.find(index) == marked.end()){\\n            mp[number].insert(index);\\n            marked[index] = number;\\n        }\\n        else{\\n            int val = marked[index];\\n            marked[index] = number;\\n            auto it = mp[val].find(index);\\n            if( it != mp[val].end()){\\n                mp[val].erase(it);\\n                if(mp[val].size()==0){\\n                    mp.erase(val);\\n                }\\n            }\\n            mp[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number)== mp.end()) return -1;\\n        return *mp[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int , set<int>>mp;\\n    map<int , int >marked;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(marked.find(index) == marked.end()){\\n            mp[number].insert(index);\\n            marked[index] = number;\\n        }\\n        else{\\n            int val = marked[index];\\n            marked[index] = number;\\n            auto it = mp[val].find(index);\\n            if( it != mp[val].end()){\\n                mp[val].erase(it);\\n                if(mp[val].size()==0){\\n                    mp.erase(val);\\n                }\\n            }\\n            mp[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        if(mp.find(number)== mp.end()) return -1;\\n        return *mp[number].begin();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825207,
                "title": "impress-your-interviewer-by-this-code-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\n\\n    HashMap<Integer,SortedSet<Integer>>pq=new HashMap<>();\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    public NumberContainers() {\\n\\n    }\\n    \\n    public void change(int index, int number) {\\n    \\n    if(!pq.isEmpty())\\n    {\\n    \\n    if(!mp.containsKey(index))\\n    mp.put(index,number);\\n\\n    else\\n    {\\n    pq.get(mp.get(index)).remove(index);\\n    mp.put(index,number);\\n    }\\n\\n    if(!pq.containsKey(number)){\\n    \\n        pq.put(number,new TreeSet<Integer>());\\n    \\n    }\\n    }\\n    else{\\n        pq.put(number,new TreeSet<Integer>());\\n        mp.put(index,number);\\n    }\\n\\n    pq.get(number).add(index);\\n    \\n    }\\n    \\n    public int find(int number) {\\n        \\n    if(!pq.isEmpty()&&pq.containsKey(number)&&!pq.get(number).isEmpty())\\n    return pq.get(number).first();\\n\\n    return -1;\\n\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n\\n    HashMap<Integer,SortedSet<Integer>>pq=new HashMap<>();\\n\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n\\n    public NumberContainers() {\\n\\n    }\\n    \\n    public void change(int index, int number) {\\n    \\n    if(!pq.isEmpty())\\n    {\\n    \\n    if(!mp.containsKey(index))\\n    mp.put(index,number);\\n\\n    else\\n    {\\n    pq.get(mp.get(index)).remove(index);\\n    mp.put(index,number);\\n    }\\n\\n    if(!pq.containsKey(number)){\\n    \\n        pq.put(number,new TreeSet<Integer>());\\n    \\n    }\\n    }\\n    else{\\n        pq.put(number,new TreeSet<Integer>());\\n        mp.put(index,number);\\n    }\\n\\n    pq.get(number).add(index);\\n    \\n    }\\n    \\n    public int find(int number) {\\n        \\n    if(!pq.isEmpty()&&pq.containsKey(number)&&!pq.get(number).isEmpty())\\n    return pq.get(number).first();\\n\\n    return -1;\\n\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797518,
                "title": "two-maps-solution-beats-90",
                "content": "```\\nclass NumberContainers {\\nprivate:\\n    unordered_map<int, int> iton; // maps indices to numbers.\\n    unordered_map<int, set<int>> ntoi; // num to indices.\\n    \\npublic:\\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        int prev = iton[index];\\n        \\n        if(prev != 0) {\\n            auto it = ntoi[prev].find(index);\\n            ntoi[prev].erase(it);\\n        }\\n        \\n        iton[index] = number;\\n        ntoi[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(ntoi[number].empty()) {\\n            return -1;\\n        }\\n        \\n        return *(ntoi[number].begin());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\nprivate:\\n    unordered_map<int, int> iton; // maps indices to numbers.\\n    unordered_map<int, set<int>> ntoi; // num to indices.\\n    \\npublic:\\n    NumberContainers() {}\\n    \\n    void change(int index, int number) {\\n        int prev = iton[index];\\n        \\n        if(prev != 0) {\\n            auto it = ntoi[prev].find(index);\\n            ntoi[prev].erase(it);\\n        }\\n        \\n        iton[index] = number;\\n        ntoi[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(ntoi[number].empty()) {\\n            return -1;\\n        }\\n        \\n        return *(ntoi[number].begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789448,
                "title": "cpp-solution-intutive-2-hashmaps-set-solution",
                "content": "**Utilities Required - 2 Hashmaps - map<int, set>, map<int, int>  and one set**\\n-> First hashmap for storing index - value pairs.\\n-> Second hashmap to store index storing a number.\\n-> Set to get unique indexes and smallest value at the start.\\n\\n**Operations:**\\n-> insert / change - O(log N)\\n-> find - O(log N)\\n\\n```\\nclass NumberContainers\\n{\\n    unordered_map<int, set < int>> set;\\t// for getting smallest value\\n    unordered_map<int, int> map;\\t// index / key - value pair\\n    public:\\n    NumberContainers() {}\\n\\n   \\t//logn \\n    void change(int index, int number)\\n    {\\n        // check if value previously exists\\n        if (map.count(index))\\n        {\\n            // store the value and erase it\\n            int val = map[index];\\n            set[val].erase(index);\\n        }\\n\\n       \\t//update key / index - value pair and add corresponding index to the set\\n        map[index] = number;\\n        set[number].insert(index);\\n    }\\n\\n   \\t//logn\\n    int find(int number)\\n    {\\n       \\t// check if the number is prev inserted or not\\n        if (set[number].size() == 0) return -1;\\n       \\t// return first of set which will be the minimum value\\n        return *(set[number].begin());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers\\n{\\n    unordered_map<int, set < int>> set;\\t// for getting smallest value\\n    unordered_map<int, int> map;\\t// index / key - value pair\\n    public:\\n    NumberContainers() {}\\n\\n   \\t//logn \\n    void change(int index, int number)\\n    {\\n        // check if value previously exists\\n        if (map.count(index))\\n        {\\n            // store the value and erase it\\n            int val = map[index];\\n            set[val].erase(index);\\n        }\\n\\n       \\t//update key / index - value pair and add corresponding index to the set\\n        map[index] = number;\\n        set[number].insert(index);\\n    }\\n\\n   \\t//logn\\n    int find(int number)\\n    {\\n       \\t// check if the number is prev inserted or not\\n        if (set[number].size() == 0) return -1;\\n       \\t// return first of set which will be the minimum value\\n        return *(set[number].begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789298,
                "title": "c-2-hashmaps-min-heap-easy-to-understand-solution",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    // To Store what value/number an index holds\\n    // < index, number >\\n    unordered_map<int, int>indInfo;\\n    \\n    // To store the indexes in a min heap for each and every number in their own min heaps;\\n    // < index, min heap of indexes >\\n    unordered_map<int, priority_queue<int, vector<int>, greater<int>>>numInfo;\\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int i, int n) {\\n        // update index info in indInfo map\\n        indInfo[i] = n;\\n        \\n        // add that index to the min heap which our number is mapped to number\\n        numInfo[n].push(i);\\n    }\\n    \\n    int find(int n) {\\n        // this while loop keeps on removing the indexes from the heap of number \"n\" till we find\\n        // the index that is still holding the number \"n\" or till heap is empty\\n        while(!(numInfo[n].empty()) && indInfo[numInfo[n].top()] != n){\\n            numInfo[n].pop();\\n        }\\n        \\n        // return the minimum index that holds the number \"n\" or if no such index is present\\n        // (min heap is empty) then return -1\\n        return numInfo[n].empty() ? -1 : numInfo[n].top();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    // To Store what value/number an index holds\\n    // < index, number >\\n    unordered_map<int, int>indInfo;\\n    \\n    // To store the indexes in a min heap for each and every number in their own min heaps;\\n    // < index, min heap of indexes >\\n    unordered_map<int, priority_queue<int, vector<int>, greater<int>>>numInfo;\\n    \\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int i, int n) {\\n        // update index info in indInfo map\\n        indInfo[i] = n;\\n        \\n        // add that index to the min heap which our number is mapped to number\\n        numInfo[n].push(i);\\n    }\\n    \\n    int find(int n) {\\n        // this while loop keeps on removing the indexes from the heap of number \"n\" till we find\\n        // the index that is still holding the number \"n\" or till heap is empty\\n        while(!(numInfo[n].empty()) && indInfo[numInfo[n].top()] != n){\\n            numInfo[n].pop();\\n        }\\n        \\n        // return the minimum index that holds the number \"n\" or if no such index is present\\n        // (min heap is empty) then return -1\\n        return numInfo[n].empty() ? -1 : numInfo[n].top();\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788510,
                "title": "best-solution-in-c-two-hashmaps",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp.find(index)!=mp.end()){\\n            int prevNum=mp[index];\\n            mp1[prevNum].erase(index);\\n            if(mp1[prevNum].size()==0)\\n                mp1.erase(prevNum);\\n        }\\n        mp[index]=number;\\n        mp1[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp1.find(number)!=mp1.end()){\\n            int ans=*(mp1[number].begin());\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> mp1;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp.find(index)!=mp.end()){\\n            int prevNum=mp[index];\\n            mp1[prevNum].erase(index);\\n            if(mp1[prevNum].size()==0)\\n                mp1.erase(prevNum);\\n        }\\n        mp[index]=number;\\n        mp1[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        if(mp1.find(number)!=mp1.end()){\\n            int ans=*(mp1[number].begin());\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785345,
                "title": "java-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumberContainers {\\n    Map<Integer,Integer>  indexToNumber = new HashMap();\\n    Map<Integer,TreeSet<Integer>>  NumberToIndex = new HashMap();\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        if(indexToNumber.containsKey(index)){\\n        int num = indexToNumber.get(index);\\n        NumberToIndex.get(num).remove(index);\\n        }\\n       \\n        if(!NumberToIndex.containsKey(number)){\\n           NumberToIndex.put(number, new TreeSet());\\n        }\\n        NumberToIndex.get(number).add(index);\\n        indexToNumber.put(index, number);\\n\\n\\n\\n    }\\n    \\n    public int find(int number) {\\n         if(NumberToIndex.containsKey(number) && NumberToIndex.get(number).size()> 0){\\n               return NumberToIndex.get(number).first();\\n        }\\nreturn -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    Map<Integer,Integer>  indexToNumber = new HashMap();\\n    Map<Integer,TreeSet<Integer>>  NumberToIndex = new HashMap();\\n    public NumberContainers() {\\n        \\n    }\\n    \\n    public void change(int index, int number) {\\n        if(indexToNumber.containsKey(index)){\\n        int num = indexToNumber.get(index);\\n        NumberToIndex.get(num).remove(index);\\n        }\\n       \\n        if(!NumberToIndex.containsKey(number)){\\n           NumberToIndex.put(number, new TreeSet());\\n        }\\n        NumberToIndex.get(number).add(index);\\n        indexToNumber.put(index, number);\\n\\n\\n\\n    }\\n    \\n    public int find(int number) {\\n         if(NumberToIndex.containsKey(number) && NumberToIndex.get(number).size()> 0){\\n               return NumberToIndex.get(number).first();\\n        }\\nreturn -1;\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782851,
                "title": "python-sortedset-solution-easy-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialize two dictionaries.\\n\\n1 -> To keep track of the different indices the number is in.\\n        Using SortedSet() for this purpose. For every number, we will add the index of it to this. If a number is in multiple indices, then we need to return the minimum index. Since SortedSet() keeps the values in sorted order, all we need to do is return the first element in the SortedSet() for the given number.\\n\\n2 -> To keep track of which number is there in a given index.\\nif we wanna add a number to an index, we need to make sure that no other number is occupying that index. If there\\'s another number occupying it, we need to replace that number with the new number and remove this index from the SortedSet() for the previous number.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn) for every change and find call.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedSet\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = defaultdict(SortedSet)\\n        self.indices = defaultdict(int)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if self.indices[index] > 0 and self.indices[index] != number:\\n            self.nums[self.indices[index]].discard(index)\\n        self.nums[number].add(index)\\n        self.indices[index] = number\\n\\n        #print(self.nums.items())\\n        #print(self.ind.items())\\n        \\n    def find(self, number: int) -> int:\\n        return self.nums[number][0] if len(self.nums[number]) > 0 else -1\\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.nums = defaultdict(SortedSet)\\n        self.indices = defaultdict(int)\\n        \\n    def change(self, index: int, number: int) -> None:\\n        if self.indices[index] > 0 and self.indices[index] != number:\\n            self.nums[self.indices[index]].discard(index)\\n        self.nums[number].add(index)\\n        self.indices[index] = number\\n\\n        #print(self.nums.items())\\n        #print(self.ind.items())\\n        \\n    def find(self, number: int) -> int:\\n        return self.nums[number][0] if len(self.nums[number]) > 0 else -1\\n\\n\\n# Your NumberContainers object will be instantiated and called as such:\\n# obj = NumberContainers()\\n# obj.change(index,number)\\n# param_2 = obj.find(number)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745743,
                "title": "java-solution-double-mapping-hashset-treeset",
                "content": "```\\nclass NumberContainers {\\n    private Map<Integer, Integer> numbers;\\n    private Map<Integer, TreeSet<Integer>> indices;\\n    \\n    public NumberContainers() {\\n        this.numbers = new HashMap<>();\\n        this.indices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer num = this.numbers.getOrDefault(index, null);\\n        \\n        TreeSet<Integer> inds = this.indices.getOrDefault(number, new TreeSet<>());\\n        inds.add(index);\\n        this.indices.put(number, inds);\\n        \\n        if (num != null && num != number) {\\n            TreeSet<Integer> inds2 = this.indices.getOrDefault(num, new TreeSet<>());\\n            inds2.remove(index);\\n        }\\n        \\n        this.numbers.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        TreeSet<Integer> inds = this.indices.getOrDefault(number, null);\\n        \\n        if (inds == null || inds.size() == 0)\\n            return -1;\\n        \\n        return inds.first();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\n    private Map<Integer, Integer> numbers;\\n    private Map<Integer, TreeSet<Integer>> indices;\\n    \\n    public NumberContainers() {\\n        this.numbers = new HashMap<>();\\n        this.indices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        Integer num = this.numbers.getOrDefault(index, null);\\n        \\n        TreeSet<Integer> inds = this.indices.getOrDefault(number, new TreeSet<>());\\n        inds.add(index);\\n        this.indices.put(number, inds);\\n        \\n        if (num != null && num != number) {\\n            TreeSet<Integer> inds2 = this.indices.getOrDefault(num, new TreeSet<>());\\n            inds2.remove(index);\\n        }\\n        \\n        this.numbers.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        TreeSet<Integer> inds = this.indices.getOrDefault(number, null);\\n        \\n        if (inds == null || inds.size() == 0)\\n            return -1;\\n        \\n        return inds.first();\\n    }\\n}\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers obj = new NumberContainers();\\n * obj.change(index,number);\\n * int param_2 = obj.find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733329,
                "title": "2-maps",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp1;\\n    unordered_map<int,set<int>>mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp1[index] && mp1[index]!=number ){\\n            int temp=mp1[index];\\n            mp1[index]=number;\\n            \\n            mp2[temp].erase(index);\\n            mp2[number].insert(index);\\n        }\\n        else{\\n            mp1[index]=number;\\n            mp2[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        return (mp2[number].size()!=0)?*mp2[number].begin():-1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,int>mp1;\\n    unordered_map<int,set<int>>mp2;\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if(mp1[index] && mp1[index]!=number ){\\n            int temp=mp1[index];\\n            mp1[index]=number;\\n            \\n            mp2[temp].erase(index);\\n            mp2[number].insert(index);\\n        }\\n        else{\\n            mp1[index]=number;\\n            mp2[number].insert(index);\\n        }\\n    }\\n    \\n    int find(int number) {\\n        return (mp2[number].size()!=0)?*mp2[number].begin():-1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704006,
                "title": "simple-stl-solution",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> Number2Index;\\n    unordered_map<int,int> Index2Number;\\n    NumberContainers() {\\n    }\\n    void change(int index, int number) {\\n        if(Index2Number.find(index)!=Index2Number.end()){\\n            if(Number2Index[Index2Number[index]].find(index)!=Number2Index[Index2Number[index]].end()){\\n                    Number2Index[Index2Number[index]].erase(index);\\n                    if(Number2Index[Index2Number[index]].size()==0){\\n                        Number2Index.erase(Index2Number[index]);\\n                    }\\n                }\\n        }\\n        Index2Number[index] = number;\\n        Number2Index[number].insert(index);\\n    }\\n    int find(int number) {\\n        if(Number2Index.find(number)==Number2Index.end()){return -1;}\\n        int smallestIndex = *(Number2Index[number].begin());\\n        return smallestIndex;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> Number2Index;\\n    unordered_map<int,int> Index2Number;\\n    NumberContainers() {\\n    }\\n    void change(int index, int number) {\\n        if(Index2Number.find(index)!=Index2Number.end()){\\n            if(Number2Index[Index2Number[index]].find(index)!=Number2Index[Index2Number[index]].end()){\\n                    Number2Index[Index2Number[index]].erase(index);\\n                    if(Number2Index[Index2Number[index]].size()==0){\\n                        Number2Index.erase(Index2Number[index]);\\n                    }\\n                }\\n        }\\n        Index2Number[index] = number;\\n        Number2Index[number].insert(index);\\n    }\\n    int find(int number) {\\n        if(Number2Index.find(number)==Number2Index.end()){return -1;}\\n        int smallestIndex = *(Number2Index[number].begin());\\n        return smallestIndex;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672026,
                "title": "java-100-runtime-with-2-hashmaps",
                "content": "Let n = the number of indices.\\n\\n**1. Use a single integer array - Memory limit exceeded**\\n\\nThe simplest solution is to use a single array to map indices to numbers.\\n- change operation: just update the value at that index - O(1) runtime\\n- find operation: iterate through the entire array and return the first index where the number is found - O(n) runtime\\n\\nHowever, this is extremely inefficient in terms of memory consumption as we have to allocate enough space for all possible indices even if we do not end up accessing many of these indices.\\n\\n```\\nclass NumberContainers {\\n    int[] idxToValue;\\n\\n    public NumberContainers() {\\n        idxToValue = new int[(int) Math.pow(10, 9) + 1];\\n    }\\n    \\n    public void change(int index, int number) {\\n        idxToValue[index] = number;\\n    }\\n    \\n    public int find(int number) {\\n        for (int i = 0; i < idxToValue.length; i++) {\\n            if (idxToValue[i] == number) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThis suggests we need some additional data structure to store information about what indices are used as well.\\n\\n**2. Use a hashmap to track index -> number, and another hashmap to track number -> indices**\\n\\nWe can do better by using 2 hashmaps:\\na) `HashMap<Integer, Integer>`  to track index -> number\\nb) `HashMap<Integer, PriorityQueue<Integer>>` to track number -> indices \\n\\n- change operation: insert the number into hashmap (a). Remove the index from the priority queue of the original number (if any). Add the index to the priority queue of the new number - O(logn) runtime\\n- find operation: get the smallest value in the priority queue of the target number - O(1) runtime\\n\\n```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> idxToNum;\\n    HashMap<Integer, PriorityQueue<Integer>> numToIndices;\\n    \\n    public NumberContainers() {\\n        idxToNum = new HashMap<>();\\n        numToIndices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        int originalNumber = idxToNum.getOrDefault(index, -1);\\n\\t\\t\\n\\t\\t// nothing to update\\n        if (originalNumber == number) {\\n            return;\\n        }\\n        \\n\\t\\t// remove the index from the priority queue of the original number\\n        if (originalNumber != -1 && originalNumber != number) {\\n            PriorityQueue<Integer> origIndices = numToIndices.get(originalNumber);\\n            origIndices.remove(index);\\n            numToIndices.put(originalNumber, origIndices);\\n        }\\n\\t\\t\\n        // add the index to the priority queue of the new number\\n        PriorityQueue<Integer> newIndices = numToIndices.getOrDefault(\\n            number, new PriorityQueue<>());\\n        newIndices.add(index);\\n        numToIndices.put(number, newIndices);\\n\\t\\t\\n\\t\\t// update the index -> number hashmap\\n        idxToNum.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> indices = numToIndices.getOrDefault(\\n            number, new PriorityQueue<>());\\n        if (indices.size() == 0) {\\n            return -1;\\n        }\\n        \\n        return indices.peek();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumberContainers {\\n    int[] idxToValue;\\n\\n    public NumberContainers() {\\n        idxToValue = new int[(int) Math.pow(10, 9) + 1];\\n    }\\n    \\n    public void change(int index, int number) {\\n        idxToValue[index] = number;\\n    }\\n    \\n    public int find(int number) {\\n        for (int i = 0; i < idxToValue.length; i++) {\\n            if (idxToValue[i] == number) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass NumberContainers {\\n    HashMap<Integer, Integer> idxToNum;\\n    HashMap<Integer, PriorityQueue<Integer>> numToIndices;\\n    \\n    public NumberContainers() {\\n        idxToNum = new HashMap<>();\\n        numToIndices = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        int originalNumber = idxToNum.getOrDefault(index, -1);\\n\\t\\t\\n\\t\\t// nothing to update\\n        if (originalNumber == number) {\\n            return;\\n        }\\n        \\n\\t\\t// remove the index from the priority queue of the original number\\n        if (originalNumber != -1 && originalNumber != number) {\\n            PriorityQueue<Integer> origIndices = numToIndices.get(originalNumber);\\n            origIndices.remove(index);\\n            numToIndices.put(originalNumber, origIndices);\\n        }\\n\\t\\t\\n        // add the index to the priority queue of the new number\\n        PriorityQueue<Integer> newIndices = numToIndices.getOrDefault(\\n            number, new PriorityQueue<>());\\n        newIndices.add(index);\\n        numToIndices.put(number, newIndices);\\n\\t\\t\\n\\t\\t// update the index -> number hashmap\\n        idxToNum.put(index, number);\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> indices = numToIndices.getOrDefault(\\n            number, new PriorityQueue<>());\\n        if (indices.size() == 0) {\\n            return -1;\\n        }\\n        \\n        return indices.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663041,
                "title": "map-and-set-solution-c",
                "content": "```\\nclass NumberContainers\\n{\\n    public:\\n\\n        unordered_map<int, int> mp;\\n    unordered_map<int, set < int>> m;\\n\\n    NumberContainers() {}\\n\\n    void change(int index, int number)\\n    {\\n       \\t\\n\\n        if (mp.find(index) != mp.end())\\n        {\\n            int ele = mp[index];\\n            m[ele].erase(index);\\n            if(m[ele].size()==0)\\n                m.erase(ele);\\n            \\n        }\\n\\n            \\n        \\n        \\n        mp[index] = number;\\n        m[number].insert(index);\\n    }\\n\\n    int find(int number)\\n    {\\n       \\t\\n        if (m.find(number) == m.end())\\n            return -1;\\n\\n        return *m[number].begin();\\n\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers\\n{\\n    public:\\n\\n        unordered_map<int, int> mp;\\n    unordered_map<int, set < int>> m;\\n\\n    NumberContainers() {}\\n\\n    void change(int index, int number)\\n    {\\n       \\t\\n\\n        if (mp.find(index) != mp.end())\\n        {\\n            int ele = mp[index];\\n            m[ele].erase(index);\\n            if(m[ele].size()==0)\\n                m.erase(ele);\\n            \\n        }\\n\\n            \\n        \\n        \\n        mp[index] = number;\\n        m[number].insert(index);\\n    }\\n\\n    int find(int number)\\n    {\\n       \\t\\n        if (m.find(number) == m.end())\\n            return -1;\\n\\n        return *m[number].begin();\\n\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644805,
                "title": "python-solution-easy",
                "content": "from sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n\\n    def __init__(self):\\n        self.num_to_indices = defaultdict(SortedList)\\n        self.index_to_num = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_num:\\n            old = self.index_to_num[index]\\n            self.num_to_indices[old].discard(index)\\n            if not self.num_to_indices[old]:\\n                del self.num_to_indices[old]\\n        self.num_to_indices[number].add(index)\\n        self.index_to_num[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        if number in self.num_to_indices:\\n            return self.num_to_indices[number][0]\\n        return -1",
                "solutionTags": [],
                "code": "from sortedcontainers import SortedList\\n\\nclass NumberContainers:\\n\\n\\n    def __init__(self):\\n        self.num_to_indices = defaultdict(SortedList)\\n        self.index_to_num = {}\\n\\n    def change(self, index: int, number: int) -> None:\\n        if index in self.index_to_num:\\n            old = self.index_to_num[index]\\n            self.num_to_indices[old].discard(index)\\n            if not self.num_to_indices[old]:\\n                del self.num_to_indices[old]\\n        self.num_to_indices[number].add(index)\\n        self.index_to_num[index] = number\\n            \\n\\n    def find(self, number: int) -> int:\\n        if number in self.num_to_indices:\\n            return self.num_to_indices[number][0]\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2629756,
                "title": "golang-two-maps-and-priority-queue",
                "content": "```go\\ntype NumberContainers struct {\\n  numbers map[int]*Number\\n  indices map[int]*PriorityQueue\\n}\\n\\ntype Number struct {\\n  val int\\n  index int\\n  \\n  heapIndex int // index of item in the heap\\n}\\n\\ntype PriorityQueue []*Number\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i].index < pq[j].index\\n}\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n  pq[i], pq[j] = pq[j], pq[i]\\n  pq[i].heapIndex = i // maintain indices after the swap\\n  pq[j].heapIndex = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(*Number)\\n  item.heapIndex = len(*pq)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  var item *Number\\n  n := len(*pq)\\n  *pq, item = (*pq)[:n-1], (*pq)[n-1]\\n  item.heapIndex = -1 // for safety\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc Constructor() NumberContainers {\\n  numbers := make(map[int]*Number)\\n  indices := make(map[int]*PriorityQueue)\\n  return NumberContainers{numbers, indices}\\n}\\n\\n\\nfunc (this *NumberContainers) Change(index int, number int)  {\\n  if item, ok := this.numbers[index]; !ok { // number at this index doesn\\'t exist\\n    item = &Number{index: index, val: number}\\n    this.numbers[index] = item\\n    // Let\\'s add this to the pq for the number\\n    pq, ok := this.indices[number]\\n    if !ok {\\n      pq = &PriorityQueue{}\\n      this.indices[number] = pq\\n    }\\n    heap.Push(pq, item)\\n  } else {\\n    // index already exists\\n    // Let\\'s change the value\\n    oldVal := item.val\\n    item.val = number\\n    // We need to remove this item from the pq\\n    heap.Remove(this.indices[oldVal], item.heapIndex)\\n    // We need to add this number to the new value pq\\n    pq, ok := this.indices[number]\\n    if !ok {\\n      pq = &PriorityQueue{}\\n      this.indices[number] = pq\\n    }\\n    heap.Push(pq, item)\\n  }\\n}\\n\\n\\nfunc (this *NumberContainers) Find(number int) int {\\n  pq := this.indices[number]\\n  if pq == nil || pq.Len() == 0 {\\n    return -1\\n  }\\n  return (*pq).Top().(*Number).index\\n}\\n\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Change(index,number);\\n * param_2 := obj.Find(number);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype NumberContainers struct {\\n  numbers map[int]*Number\\n  indices map[int]*PriorityQueue\\n}\\n\\ntype Number struct {\\n  val int\\n  index int\\n  \\n  heapIndex int // index of item in the heap\\n}\\n\\ntype PriorityQueue []*Number\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n  return pq[i].index < pq[j].index\\n}\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n  pq[i], pq[j] = pq[j], pq[i]\\n  pq[i].heapIndex = i // maintain indices after the swap\\n  pq[j].heapIndex = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  item := x.(*Number)\\n  item.heapIndex = len(*pq)\\n  *pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  var item *Number\\n  n := len(*pq)\\n  *pq, item = (*pq)[:n-1], (*pq)[n-1]\\n  item.heapIndex = -1 // for safety\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc Constructor() NumberContainers {\\n  numbers := make(map[int]*Number)\\n  indices := make(map[int]*PriorityQueue)\\n  return NumberContainers{numbers, indices}\\n}\\n\\n\\nfunc (this *NumberContainers) Change(index int, number int)  {\\n  if item, ok := this.numbers[index]; !ok { // number at this index doesn\\'t exist\\n    item = &Number{index: index, val: number}\\n    this.numbers[index] = item\\n    // Let\\'s add this to the pq for the number\\n    pq, ok := this.indices[number]\\n    if !ok {\\n      pq = &PriorityQueue{}\\n      this.indices[number] = pq\\n    }\\n    heap.Push(pq, item)\\n  } else {\\n    // index already exists\\n    // Let\\'s change the value\\n    oldVal := item.val\\n    item.val = number\\n    // We need to remove this item from the pq\\n    heap.Remove(this.indices[oldVal], item.heapIndex)\\n    // We need to add this number to the new value pq\\n    pq, ok := this.indices[number]\\n    if !ok {\\n      pq = &PriorityQueue{}\\n      this.indices[number] = pq\\n    }\\n    heap.Push(pq, item)\\n  }\\n}\\n\\n\\nfunc (this *NumberContainers) Find(number int) int {\\n  pq := this.indices[number]\\n  if pq == nil || pq.Len() == 0 {\\n    return -1\\n  }\\n  return (*pq).Top().(*Number).index\\n}\\n\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Change(index,number);\\n * param_2 := obj.Find(number);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2612628,
                "title": "unordered-map-set-c-commented",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> m;\\n    NumberContainers() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n\\t// find if index already have a value\\n        if(m.find(index)!=m.end()){\\n\\t\\t// if exist erase index assign from set assign to previous value \\n            mp[m[index]].erase(index);\\n        }\\n\\t\\t// update value to index\\n        m[index]=number;\\n\\t\\t// push index to new value\\n        mp[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n\\t// find if index exist to this value\\n        if(mp[number].begin()!=mp[number].end()){\\n\\t\\t// if exist return first value from set(which will be smallest\\n            return *(mp[number].begin());\\n        }\\n\\t\\t// return -1;\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    unordered_map<int,int> m;\\n    NumberContainers() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void change(int index, int number) {\\n\\t// find if index already have a value\\n        if(m.find(index)!=m.end()){\\n\\t\\t// if exist erase index assign from set assign to previous value \\n            mp[m[index]].erase(index);\\n        }\\n\\t\\t// update value to index\\n        m[index]=number;\\n\\t\\t// push index to new value\\n        mp[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n\\t// find if index exist to this value\\n        if(mp[number].begin()!=mp[number].end()){\\n\\t\\t// if exist return first value from set(which will be smallest\\n            return *(mp[number].begin());\\n        }\\n\\t\\t// return -1;\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your NumberContainers object will be instantiated and called as such:\\n * NumberContainers* obj = new NumberContainers();\\n * obj->change(index,number);\\n * int param_2 = obj->find(number);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611957,
                "title": "c-95-unordered-map-set",
                "content": "```\\nclass NumberContainers {\\n    unordered_map<long, long> indexToNumber;\\n    unordered_map<long, set<long>> numberToVectorOfIndexes;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if (indexToNumber.find(index) != indexToNumber.end()) {\\n            int prevNum = indexToNumber[index];\\n            numberToVectorOfIndexes[prevNum].erase(index);\\n            if (numberToVectorOfIndexes[prevNum].empty()) {\\n                numberToVectorOfIndexes.erase(prevNum);\\n            }\\n        }\\n        indexToNumber[index] = number;\\n        numberToVectorOfIndexes[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        auto it = numberToVectorOfIndexes.find(number);\\n        if (it == numberToVectorOfIndexes.end()) return -1;\\n        return *((it->second).begin());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\n    unordered_map<long, long> indexToNumber;\\n    unordered_map<long, set<long>> numberToVectorOfIndexes;\\npublic:\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int index, int number) {\\n        if (indexToNumber.find(index) != indexToNumber.end()) {\\n            int prevNum = indexToNumber[index];\\n            numberToVectorOfIndexes[prevNum].erase(index);\\n            if (numberToVectorOfIndexes[prevNum].empty()) {\\n                numberToVectorOfIndexes.erase(prevNum);\\n            }\\n        }\\n        indexToNumber[index] = number;\\n        numberToVectorOfIndexes[number].insert(index);\\n    }\\n    \\n    int find(int number) {\\n        auto it = numberToVectorOfIndexes.find(number);\\n        if (it == numberToVectorOfIndexes.end()) return -1;\\n        return *((it->second).begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605968,
                "title": "java-treemap",
                "content": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    public void change(int index, int number) {\\n        map.put(index,number);\\n    }\\n    public int find(int number) {   \\n        for(int key:map.keySet()){\\n            if(map.get(key) == number)      return key;\\n        }\\n        return -1;                 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;\\n    public NumberContainers() {\\n        map=new TreeMap<>();\\n    }\\n    public void change(int index, int number) {\\n        map.put(index,number);\\n    }\\n    public int find(int number) {   \\n        for(int key:map.keySet()){\\n            if(map.get(key) == number)      return key;\\n        }\\n        return -1;                 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601806,
                "title": "faster-than-98-59-using-heap-in-python3",
                "content": "![image](https://assets.leetcode.com/users/images/1e2e579c-c268-40e2-a207-e32793d3d030_1663689261.1270013.png)\\n\\n```\\nfrom heapq import heappop, heappush\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.indices = {}\\n        self.numbers = defaultdict(list)\\n\\n    # O(log(len(self.numbers[number]))) Time\\n    def change(self, index: int, number: int) -> None:\\n        self.indices[index] = number\\n        # insert index in the respective heap\\n        heappush(self.numbers[number], index)\\n\\n    # O(len(self.numbers[number]) * log(len(self.numbers[number]))) Time\\n    def find(self, number: int) -> int:\\n        # number not present\\n        if number not in self.numbers: return -1\\n        \\n        while len(self.numbers[number]) > 0 and self.indices[self.numbers[number][0]] != number:\\n            heappop(self.numbers[number])\\n            \\n        # if heap is not empty that means root of heap is our resultant index\\n        return self.numbers[number][0] if len(self.numbers[number]) != 0 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappop, heappush\\nclass NumberContainers:\\n\\n    def __init__(self):\\n        self.indices = {}\\n        self.numbers = defaultdict(list)\\n\\n    # O(log(len(self.numbers[number]))) Time\\n    def change(self, index: int, number: int) -> None:\\n        self.indices[index] = number\\n        # insert index in the respective heap\\n        heappush(self.numbers[number], index)\\n\\n    # O(len(self.numbers[number]) * log(len(self.numbers[number]))) Time\\n    def find(self, number: int) -> int:\\n        # number not present\\n        if number not in self.numbers: return -1\\n        \\n        while len(self.numbers[number]) > 0 and self.indices[self.numbers[number][0]] != number:\\n            heappop(self.numbers[number])\\n            \\n        # if heap is not empty that means root of heap is our resultant index\\n        return self.numbers[number][0] if len(self.numbers[number]) != 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574701,
                "title": "brute-force-solution-using-2-map-c",
                "content": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int> m; // index - number\\n    map<int,set<int>> mp; // number - indexs\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int ind, int number) {\\n        if(m.find(ind) != m.end()) mp[m[ind]].erase(ind);\\n        m[ind] = number;\\n        mp[number].insert(ind);\\n    }\\n    \\n    int find(int number) {\\n        return mp[number].begin() == mp[number].end() ? -1 : *(mp[number].begin()) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumberContainers {\\npublic:\\n    map<int,int> m; // index - number\\n    map<int,set<int>> mp; // number - indexs\\n    NumberContainers() {\\n        \\n    }\\n    \\n    void change(int ind, int number) {\\n        if(m.find(ind) != m.end()) mp[m[ind]].erase(ind);\\n        m[ind] = number;\\n        mp[number].insert(ind);\\n    }\\n    \\n    int find(int number) {\\n        return mp[number].begin() == mp[number].end() ? -1 : *(mp[number].begin()) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544727,
                "title": "rust-solution-using-hashmap-and-btreeset",
                "content": "```\\nuse std::collections::*;\\nstruct NumberContainers {\\n    map: HashMap<i32, BTreeSet<i32>>,\\n    dict: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumberContainers {\\n\\n    fn new() -> Self {\\n        NumberContainers {\\n            map: HashMap::new(),\\n            dict: HashMap::new(),\\n        }\\n    }\\n    \\n    fn change(&mut self, index: i32, number: i32) {\\n        let v = if let Some(&v) = self.dict.get(&index) {\\n            v\\n        } else {\\n            self.dict.insert(index, number);\\n            self.map.entry(number).or_insert(BTreeSet::new()).insert(index);\\n            return\\n        };\\n\\n        self.dict.insert(index, number);\\n        let entry = self.map.entry(v).or_insert(BTreeSet::new());\\n        if entry.len() == 1 {\\n            self.map.remove(&v);\\n        } else {\\n            entry.remove(&index);\\n        }\\n        self.map.entry(number).or_insert(BTreeSet::new()).insert(index);\\n    }\\n    \\n    fn find(&mut self, number: i32) -> i32 {\\n        if let Some(btreeset) = self.map.get(&number) {\\n                *btreeset.iter().next().unwrap()\\n        } else {\\n                -1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\nstruct NumberContainers {\\n    map: HashMap<i32, BTreeSet<i32>>,\\n    dict: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumberContainers {\\n\\n    fn new() -> Self {\\n        NumberContainers {\\n            map: HashMap::new(),\\n            dict: HashMap::new(),\\n        }\\n    }\\n    \\n    fn change(&mut self, index: i32, number: i32) {\\n        let v = if let Some(&v) = self.dict.get(&index) {\\n            v\\n        } else {\\n            self.dict.insert(index, number);\\n            self.map.entry(number).or_insert(BTreeSet::new()).insert(index);\\n            return\\n        };\\n\\n        self.dict.insert(index, number);\\n        let entry = self.map.entry(v).or_insert(BTreeSet::new());\\n        if entry.len() == 1 {\\n            self.map.remove(&v);\\n        } else {\\n            entry.remove(&index);\\n        }\\n        self.map.entry(number).or_insert(BTreeSet::new()).insert(index);\\n    }\\n    \\n    fn find(&mut self, number: i32) -> i32 {\\n        if let Some(btreeset) = self.map.get(&number) {\\n                *btreeset.iter().next().unwrap()\\n        } else {\\n                -1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2543339,
                "title": "easy-python-sorted-dict-approach",
                "content": "```\\nfrom sortedcontainers import SortedDict\\nclass NumberContainers:\\n    def __init__(self):       \\n        self.l={}\\n        self.sorted_dict=SortedDict(self.l)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.sorted_dict[index]=number\\n\\n    def find(self, number: int) -> int:\\n        for k,v in self.sorted_dict.items():\\n            if v==number:\\n                return k\\n        return -1    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nclass NumberContainers:\\n    def __init__(self):       \\n        self.l={}\\n        self.sorted_dict=SortedDict(self.l)\\n\\n    def change(self, index: int, number: int) -> None:\\n        self.sorted_dict[index]=number\\n\\n    def find(self, number: int) -> int:\\n        for k,v in self.sorted_dict.items():\\n            if v==number:\\n                return k\\n        return -1    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538028,
                "title": "java-treemap-straightforward-solution",
                "content": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;\\n    public NumberContainers() {\\n        map=new TreeMap<Integer,Integer>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(map.containsKey(index))\\n            map.replace(index,number);\\n        else\\n            map.put(index,number);\\n    }\\n    \\n    public int find(int number) {\\n        for(Map.Entry m: map.entrySet()){\\n            int num = (int)m.getValue();\\n            if(num==number)\\n                return (int)m.getKey();\\n        }\\n        return -1;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumberContainers {\\n    TreeMap<Integer,Integer> map;\\n    public NumberContainers() {\\n        map=new TreeMap<Integer,Integer>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        if(map.containsKey(index))\\n            map.replace(index,number);\\n        else\\n            map.put(index,number);\\n    }\\n    \\n    public int find(int number) {\\n        for(Map.Entry m: map.entrySet()){\\n            int num = (int)m.getValue();\\n            if(num==number)\\n                return (int)m.getKey();\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514833,
                "title": "java-easy-hashmap-and-heap-priorityqueue-soln",
                "content": "class NumberContainers {\\n\\n    HashMap<Integer, Integer> mapChange;\\n    HashMap<Integer, PriorityQueue<Integer>> mapFind;\\n    public NumberContainers() {\\n        mapChange = new HashMap<>();\\n        mapFind = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        mapChange.put(index, number);\\n        if(mapFind.containsKey(number)){\\n            mapFind.get(number).add(index);\\n        }else{\\n            PriorityQueue<Integer> queue = new PriorityQueue<>();\\n            queue.add(index);\\n            mapFind.put(number, queue);\\n        }\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> queue = mapFind.get(number);\\n        while(queue != null && !queue.isEmpty()){\\n            int index = queue.peek();\\n            if(mapChange.get(index) == number){\\n                return index;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class NumberContainers {\\n\\n    HashMap<Integer, Integer> mapChange;\\n    HashMap<Integer, PriorityQueue<Integer>> mapFind;\\n    public NumberContainers() {\\n        mapChange = new HashMap<>();\\n        mapFind = new HashMap<>();\\n    }\\n    \\n    public void change(int index, int number) {\\n        mapChange.put(index, number);\\n        if(mapFind.containsKey(number)){\\n            mapFind.get(number).add(index);\\n        }else{\\n            PriorityQueue<Integer> queue = new PriorityQueue<>();\\n            queue.add(index);\\n            mapFind.put(number, queue);\\n        }\\n    }\\n    \\n    public int find(int number) {\\n        PriorityQueue<Integer> queue = mapFind.get(number);\\n        while(queue != null && !queue.isEmpty()){\\n            int index = queue.peek();\\n            if(mapChange.get(index) == number){\\n                return index;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040630,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "The time constraints for python are absurd. Using the two dicts method is not enough? I AM using set as the values for the num_found_at_indexes dict so updates are O(1), the find method is O(n) at worst as it just has to iterate the indices that match that number. O(n) isnt good enough? I could make them heaps but then I lose the O(1) updating. Same for ordered list which now would need to add binary search to even bring that down to O(nlogn) for updates.\n\nThe hint says \"use ordered sets\", which is not even a standard python package, but from SortedContainers and is *very* niche and shouldn't be expected, if even allowed. I could do that, but I think usually that is frowned on in these types of problems as being \"too good/automatic\"... whatever that means. Same reason I \"shouldn't\" just use itertools library functions for combinatorics problems.  Could store THREE versions to maintain all the benefits: the plain dict O(1), the CURRENT_valid_indicies O(1), add to heap O(logn),  and retrieve from heap for 0(... something?) Its not O(1) Worst case it IS O(n) if all the values in the heap are invalid but the last one.  We dont actually remove updated values from; when popped if they are the smallest but no longer valid indices per the other other dict keep popping? If this is the only valid solution, then this is a bad problem.\n\nUsually O(n) is good enough for any problem, and if not it needs to state that clearly in the outline.  "
                    },
                    {
                        "username": "heyrohan",
                        "content": "> [ HINT ] : \n1. create key-value pairs for index to number,\n2. create another key-value pairs for number to **indices**"
                    }
                ]
            },
            {
                "id": 1810017,
                "content": [
                    {
                        "username": "cswartzell",
                        "content": "The time constraints for python are absurd. Using the two dicts method is not enough? I AM using set as the values for the num_found_at_indexes dict so updates are O(1), the find method is O(n) at worst as it just has to iterate the indices that match that number. O(n) isnt good enough? I could make them heaps but then I lose the O(1) updating. Same for ordered list which now would need to add binary search to even bring that down to O(nlogn) for updates.\n\nThe hint says \"use ordered sets\", which is not even a standard python package, but from SortedContainers and is *very* niche and shouldn't be expected, if even allowed. I could do that, but I think usually that is frowned on in these types of problems as being \"too good/automatic\"... whatever that means. Same reason I \"shouldn't\" just use itertools library functions for combinatorics problems.  Could store THREE versions to maintain all the benefits: the plain dict O(1), the CURRENT_valid_indicies O(1), add to heap O(logn),  and retrieve from heap for 0(... something?) Its not O(1) Worst case it IS O(n) if all the values in the heap are invalid but the last one.  We dont actually remove updated values from; when popped if they are the smallest but no longer valid indices per the other other dict keep popping? If this is the only valid solution, then this is a bad problem.\n\nUsually O(n) is good enough for any problem, and if not it needs to state that clearly in the outline.  "
                    },
                    {
                        "username": "heyrohan",
                        "content": "> [ HINT ] : \n1. create key-value pairs for index to number,\n2. create another key-value pairs for number to **indices**"
                    }
                ]
            }
        ]
    }
]